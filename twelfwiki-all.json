{
  "mediawiki": {
    "@xmlns": "http://www.mediawiki.org/xml/export-0.10/",
    "@xmlns:xsi": "http://www.w3.org/2001/XMLSchema-instance",
    "@xsi:schemaLocation": "http://www.mediawiki.org/xml/export-0.10/ http://www.mediawiki.org/xml/export-0.10.xsd",
    "@version": 0.1,
    "@xml:lang": "en",
    "siteinfo": {
      "sitename": "The Twelf Project",
      "dbname": "twelfwiki",
      "base": "http://twelf.org/wiki/Main_Page",
      "generator": "MediaWiki 1.26.2",
      "case": "first-letter",
      "namespaces": {
        "namespace": [
          {
            "@key": -2,
            "@case": "first-letter",
            "#text": "Media"
          },
          {
            "@key": -1,
            "@case": "first-letter",
            "#text": "Special"
          },
          {
            "@key": 0,
            "@case": "first-letter",
            "#text": null
          },
          {
            "@key": 1,
            "@case": "first-letter",
            "#text": "Talk"
          },
          {
            "@key": 2,
            "@case": "first-letter",
            "#text": "User"
          },
          {
            "@key": 3,
            "@case": "first-letter",
            "#text": "User talk"
          },
          {
            "@key": 4,
            "@case": "first-letter",
            "#text": "The Twelf Project"
          },
          {
            "@key": 5,
            "@case": "first-letter",
            "#text": "The Twelf Project talk"
          },
          {
            "@key": 6,
            "@case": "first-letter",
            "#text": "File"
          },
          {
            "@key": 7,
            "@case": "first-letter",
            "#text": "File talk"
          },
          {
            "@key": 8,
            "@case": "first-letter",
            "#text": "MediaWiki"
          },
          {
            "@key": 9,
            "@case": "first-letter",
            "#text": "MediaWiki talk"
          },
          {
            "@key": 10,
            "@case": "first-letter",
            "#text": "Template"
          },
          {
            "@key": 11,
            "@case": "first-letter",
            "#text": "Template talk"
          },
          {
            "@key": 12,
            "@case": "first-letter",
            "#text": "Help"
          },
          {
            "@key": 13,
            "@case": "first-letter",
            "#text": "Help talk"
          },
          {
            "@key": 14,
            "@case": "first-letter",
            "#text": "Category"
          },
          {
            "@key": 15,
            "@case": "first-letter",
            "#text": "Category talk"
          },
          {
            "@key": 100,
            "@case": "first-letter",
            "#text": "Elves"
          },
          {
            "@key": 101,
            "@case": "first-letter",
            "#text": "Elves talk"
          },
          {
            "@key": 102,
            "@case": "first-letter",
            "#text": "Proving metatheorems"
          },
          {
            "@key": 103,
            "@case": "first-letter",
            "#text": "Proving metatheorems talk"
          }
        ]
      }
    },
    "page": [
      {
        "title": "%.",
        "ns": 0,
        "id": 1802,
        "revision": {
          "id": 4821,
          "parentid": 4816,
          "timestamp": "2007-09-26T17:23:42Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "rv vandal",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 751,
            "#text": "The '''<tt>%.</tt>''' keyword instructs Twelf to stop reading input in the current file. It is most useful in [[Twelf with Emacs|emacs mode]] to check some prefix of a file that you are currently working on.\n\n== Example ==\n\nThe following example shows a simple Twelf declaration at top, and the text below it [[TwelfTag|in green]] shows the response from Twelf. Notice that the last three lines are not considered by Twelf, because it stops reading input when it reaches the <tt>%.</tt> keyword.\n\n<twelf check=decl>\nnat : type.\n\n%.\n\nThis line will not be checked.\nNeither will anything else that gets put after the %.\n%total T (pretendlemma T _ _). \n</twelf>\n\n== See also ==\n* {{guide|chapter=2|section=4|title=Lexical Conventions}}\n\n{{keyword|key=.}}"
          },
          "sha1": "sxk5dc80dhi4d9juafafh3pzjb0ibt2"
        }
      },
      {
        "title": "%assert",
        "ns": 0,
        "id": 1829,
        "revision": {
          "id": 3459,
          "parentid": 3458,
          "timestamp": "2006-12-29T16:12:11Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "minor": null,
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 1451,
            "#text": "The '''<tt>%assert</tt>''' directive instructs the [[theorem prover]] to accept a previously stated theorem as true without trying to prove that theorem. This directive is thus analogous to a <tt>[[%trustme]]&nbsp;[[%total]]</tt> directive. Because it instructs Twelf to treat something as true without a proof, Twelf must be in [[unsafe mode]] to use this directive.\n\n== Example == \n\nThe example from the [[theorem prover]] article can be modified to use <tt>%assert</tt> instead of <tt>%prove</tt> for the two lemmas that are needed to establish the commutativity of addition (this example cannot be run on the wiki, which uses Twelf in safe mode).\n\n<twelf>\nnat : type.\ns : nat -> nat.\nz : nat.\n\nplus : nat -> nat -> nat -> type.\nplus/z : plus z N N.\nplus/s : plus (s N1) N2 (s N3) <- plus N1 N2 N3.\n\n%theorem plus-z : forall {N: nat} \n                 exists {D: plus N z N} \n                 true.\n%assert (plus-z N D).\n\n%theorem plus-s : forall* {N1: nat}{N2: nat}{N3: nat}\n                 forall {D1: plus N1 N2 N3} \n                 exists {D2: plus N1 (s N2) (s N3)} \n                 true.\n%assert (plus-s D1 D2).\n\n%theorem plus-comm : forall* {N1: nat}{N2: nat}{N3: nat}\n                 forall {D1: plus N1 N2 N3} \n                 exists {D2: plus N2 N1 N3} \n                 true.\n%prove 5 D1 (plus-comm D1 D2).\n</twelf>\n\n== See also ==\n\n* [[Theorem prover]]\n* {{guide|title=Theorem Prover|chapter=10|section=57}}\n\n{{keyword|key=assert}}"
          },
          "sha1": "bpv7me5h795t4f4cybnezfv2hlc06su"
        }
      },
      {
        "title": "%block",
        "ns": 0,
        "id": 1881,
        "revision": {
          "id": 6238,
          "parentid": 4603,
          "timestamp": "2011-03-19T14:07:47Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "add bit about block definitions",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 2418,
            "#text": "A '''<tt>%block</tt>''' declaration names a '''block''', which is a partial description of an LF context. Blocks are composed into [[regular worlds]] with <tt>[[%worlds]]</tt> declarations, which describe the complete set of possible contexts for a type family. This description of the context is an important part of the [[adequacy]] of the [[metatheorem]] established by a <tt>[[%total]]</tt> declaration.\n\nA <tt>%block</tt> declaration acts more like a definition than other keywords, which generally cause Twelf to ''do'' something rather than ''define'' something. The obvious exception to this is [[define declaration|%define]].\n\n\n== Sample <tt>%block</tt> declarations ==\n\nThese sample <tt>%block</tt> declarations are in the context of the definitions of <tt>exp</tt> and <tt>height</tt> in the <tt>[[%worlds]]</tt> article.\n\nUsing this block in a <tt>%worlds</tt> declaration means that arbitrary variables representing expressions can appear in the context:\n<twelf>\n%block var-rand : block {x : exp}.   \n</twelf>\n\nUsing this block in a <tt>%worlds</tt> declaration means that variables representing expressions can appear in the context, but only if they are accompanied by a judgment that defines the height of that variable to be one.\n<twelf>\n%block var-height : block {x : exp}{_ : height x (s z)}.\n</twelf>\n\nUsing this block in a <tt>%worlds</tt> declaration means that variables representing expressions can appear in the context, but only if they are accompanied by a judgment that defines the height of that variable to be some natural number.\n<twelf>\n%block var-heightN : some {N: nat} block {x : exp}{_ : height x N}.\n</twelf>\n\n== Block definitions ==\n\nAs of 1.7.1, block <i>definitions</i> are now supported. \n\n<twelf import=\"new\">\ntyp : type.\nexp : typ -> type.\n\n%block typ-var : block {a : typ}.\n%block exp-var : some {T : typ} block {x : exp T}.\n%block vars = (typ-var | exp-var).\n</twelf>\n\nUsing <tt>vars</tt> in a <tt>[[%worlds]]</tt> declaration is the same as using <tt>typ-var | exp-var</tt>, and in fact when Twelf prints out the <tt>%worlds</tt> declaration, block definitions will be automatically expanded.\n\n<twelf import=\"new\" check=\"decl\">\n%worlds (vars) (exp _).\n</twelf>\n\n== See also ==\n\n* <tt>[[%worlds]]</tt>\n* {{proving|title=Proving totality assertions in non-empty contexts}}\n* [[Totality assertion]]\n* {{guide|chapter=9|section=53|title=Regular Worlds}}\n\n{{keyword|key=block}}"
          },
          "sha1": "hng7xjg7fnasdlnypls84jnwv2phrdg"
        }
      },
      {
        "title": "%clause",
        "ns": 0,
        "id": 1870,
        "revision": {
          "id": 4295,
          "parentid": 3790,
          "timestamp": "2007-03-18T04:57:43Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "minor": null,
          "comment": "point elsewhere",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 823,
            "#text": "The '''<tt>%clause</tt>''' keyword allows a constant that is defined to be used by Twelf during proof search. If '''<tt>%clause</tt>''' is not used, then Twelf will only perform proof search on constants that are declared in the [[signature]].\n\nThis function of Twelf is incompatible with Twelf's ability to prove [[metatheorems]], and so type families that use '''<tt>%clause</tt>''' or depend on other type families that use '''<tt>%clause</tt>''' cannot be a part of directives that specify [[totality assertions]] such as <tt>[[%total]]</tt>. It has mostly been used to do [[tactical theorem proving]] in Twelf, and the article on that subject has an example of <tt>%clause</tt> being used.\n\n== See also ==\n\n*{{guide|title=Clause Definitions|chapter=5|section=29}}\n*[[Tactical theorem proving]]\n\n\n{{keyword|key=clause}}"
          },
          "sha1": "hvl0zk6x14gc484orveq2p5hctndij4"
        }
      },
      {
        "title": "%covers",
        "ns": 0,
        "id": 1965,
        "revision": {
          "id": 5031,
          "parentid": 4988,
          "timestamp": "2007-11-30T21:00:56Z",
          "contributor": {
            "ip": "70.17.167.76"
          },
          "comment": "fix typo",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 3382,
            "#text": "A '''<tt>%covers</tt>''' declaration checks [[input coverage]] for a type family, which is one of the two kinds of [[coverage checking]] that Twelf performs. Running a <tt>[[%total]]</tt> declaration checks input coverage as well as [[output coverage]].\n\nThe <tt>%covers</tt> declaration essentially checks that your type family does an ML-style exhaustive match on its inputs; this does not establish that running your program will succeed, or even terminate!\n\n== Example ==\n\nFor this example, we define a type <tt>elem</tt> with three elements, <tt>a</tt>, <tt>b</tt>, <tt>c</tt>, and a relation <tt>rel</tt> with three positions. We will then use <tt>%covers</tt> to check coverage on this relation given a number of different ways of assigning positions as either inputs or outputs.\n\n<twelf>\nelem: type.\n\na: elem.\nb: elem.\nc: elem.\n\nrel: elem -> elem -> elem -> type.\nfail : type.\n\nrel1 : rel a X c.\nrel2 : rel b Y b <- fail.\nrel3 : rel c c c <- rel c a c.\n\n%worlds () (rel _ _ _) (fail).\n</twelf>\n\n\nThe first <tt>%covers</tt> declaration below checks that <tt>rel</tt> covers the first position - it does, as there is one case for each of the three possibilities. This is true even though <tt>rel b X Y</tt> will fail and the query <tt>rel c X Y</tt> will loop forever. The second declaration checks that <tt>rel</tt> covers the second position, which happens trivially because the first case, labeled <tt>rel1</tt>, and the second case <tt>rel2</tt>, have a [[metavariable]] in the second position that matches any possible input.\n\n<twelf check=true discard=true>\n%covers rel +X1 -X2 -X3.\n%covers rel -X1 +X2 -X3.\n</twelf>\n\n\nIf we try to check coverage on the third position, however, we get an error; the third position does not have a case that handles <tt>a</tt>.\n\n<twelf check=decl discard=true>\n%covers rel -X1 -X2 +X3.\n</twelf>\n\n\nFurthermore, even though we cover the first and second positions individually, if we consider them together we leave out two cases, which is what Twelf's response below explains:\n\n<twelf check=decl discard=true>\n%covers rel +X1 +X2 -X3.\n</twelf>\n\n== Limitations ==\n\nCoverage checking is a weak test; it only checks that at least one constant will immediately apply during proof search. For example, the following program coverage checks:\n\n<twelf>\nbit : type.\n0 : bit.\n1 : bit.\n\nnope : bit -> type.\n%mode nope +B.\n\nnot : bit -> bit -> type.\n%mode not +B -B'.\n\nn0 : not 0 1.\nn1 : not 1 0.\n\nzero : bit -> bit -> type.\n%mode zero +B -B'.\n\ncn : zero X 0\n  <- nope X.\n\ncz : zero X 0\n  <- zero X 1.\n\ncf : zero X 0\n  <- not X X.\n\n%worlds () (nope _) (not _ _) (zero _ _).\n%covers zero +B -B'.\n</twelf>\n\nAlthough <tt>zero</tt> passes the coverage check, it always fails. <tt>cn</tt> matches all inputs, but then appeals to a subgoal (<tt>nope</tt>) that is empty and immediately fails. <tt>cz</tt> appeals recursively to <tt>zero</tt>, but insists that its output be <tt>1</tt>, so this also fails. <tt>cf</tt> appeals to the total relation <tt>not</tt>, but in a way that constrains the output so that it also always fails (see [[output freeness]]). To get all of these tests, you must use the [[%total]] declaration. Here, totality fails on the first case as expected:\n\n<twelf check=decl discard=true>\n%total D (zero D _).\n</twelf>\n\n== See also ==\n\n* {{guide|chapter=9|section=54|title=Input Coverage}}\n* [[Input coverage]]\n* [[Coverage checking]]"
          },
          "sha1": "6bacr1gab3e2m6bp663fd3ycezed3g2"
        }
      },
      {
        "title": "%establish",
        "ns": 0,
        "id": 1826,
        "revision": {
          "id": 3464,
          "parentid": 3460,
          "timestamp": "2006-12-29T19:08:04Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 474,
            "#text": "The '''<tt>%establish</tt>''' directive attempts to prove a theorem specified by a <tt>[[%theorem]]</tt> directive using the [[theorem prover]]. It is therefore similar to the <tt>[[%prove]]</tt> directive. However, unlike the <tt>%prove</tt> directive, theorems shown to be true by the <tt>%establish</tt> directive are not used to prove other theorems.\n\n== See also ==\n\n* [[Theorem prover]]\n* {{guide|title=Theorem Prover|chapter=10|section=57}}\n\n{{keyword|key=establish}}"
          },
          "sha1": "5lv5kwppqe0dazw608li0xnxiaz3sx2"
        }
      },
      {
        "title": "%freeze",
        "ns": 0,
        "id": 1807,
        "revision": {
          "id": 6100,
          "parentid": 6099,
          "timestamp": "2010-09-01T20:06:27Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 2076,
            "#text": "{{undocumented|article}}\nThe '''<tt>%freeze</tt>''' declaration ''freezes'' a set of type families. A frozen family cannot be extended: new constants at that type cannot be added, nor can the [[subordination]] relation be extended such that the family could depend on other types. The <tt>[[%thaw]]</tt> declaration can be used to reenable the extension of a type family.\n\n== Syntax ==\n\nThe syntax is as follows:\n\n<tt>%freeze t1 t2 ... tn.</tt>\n\nThe type families <tt>t1</tt>&ndash;<tt>tn</tt> are frozen.\n\n== Example ==\n\nSuppose we define addition in the natural way:\n\n<twelf>\nnat : type.\nz : nat. \ns : nat -> nat.    %prefix 9999 s.\n\nplus : nat -> nat -> nat -> type.\n%mode plus +N +M -O.\n\nplus/z : plus z N N.\nplus/s : plus (s N) M (s P)\n      <- plus N M P.\n</twelf>\n\nAt this point, we may still extend the definition of addition:\n\n<twelf check=decl>\nplus/zz : plus M z M.\n</twelf>\n\nHowever, if we freeze <tt>plus</tt> then this will not be allowed:\n\n<twelf check=decl discard=true>\n%freeze plus.\nplus/zzz : plus z z z.\n</twelf>\n\nMore subtly, we will not be able to extend the [[subordination]] relation for <tt>plus</tt>:\n\n<twelf check=decl discard=true>\n%freeze plus.\nthing : type.\n\noops : (thing -> plus _ _ _) -> type.\n</twelf>\n\nThe subordination relation can be extended such that other non-frozen types depend on a frozen type, of course:\n\n<twelf check=decl discard=true>\n%freeze plus.\nthing : type.\n\nokay : (plus _ _ _ -> thing) -> type.\n</twelf>\n\nBecause types are automatically frozen in common cases (see below), one may occasionally need to induce subordination relations in anticipation of code that follows freezing. This can be done as in the type <tt>oops</tt> above, before using <tt>%freeze</tt> or metatheory like <tt>%worlds</tt>.\n\n== Autofreeze ==\n\nTwelf CVS{{discuss|Version}} automatically freezes any family for which there has been a <tt>[[%worlds]]</tt> declaration. This prevents mistakes where a metatheorem is proved for a type family but then that type family is extended, invalidating the theorem.{{discuss|Soundness}}\n\n{{keyword|key=freeze}}"
          },
          "sha1": "taes7tcxrp4vrnhxtntfsj647dte9sj"
        }
      },
      {
        "title": "%infix",
        "ns": 0,
        "id": 1655,
        "redirect": {
          "@title": "Fixity declaration",
          "#text": null
        },
        "revision": {
          "id": 2333,
          "timestamp": "2006-10-02T17:12:14Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "comment": "redirect to fixity declaration",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 32,
            "#text": "#REDIRECT [[Fixity declaration]]"
          },
          "sha1": "mjupvuj4wcblpva99enzv3s88m25xoa"
        }
      },
      {
        "title": "%mode",
        "ns": 0,
        "id": 1746,
        "revision": {
          "id": 6378,
          "parentid": 6377,
          "timestamp": "2011-09-21T13:51:23Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "minor": null,
          "comment": "Reverted edits by [[Special:Contributions/Harmon|Harmon]] ([[User talk:Harmon|talk]]) to last revision by [[User:Rsimmons|Rsimmons]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 4632,
            "#text": "The '''<tt>%mode</tt>''' declaration specifies the way in which a relation is intended to be used, by specifying those arguments that are ''inputs'' or ''outputs''. Twelf then checks that all constants defining the relation respect the mode specified (are \"well-moded\").\n\nThe <tt>%mode</tt> declaration is an important part of the specification of a [[totality assertion]]. In the \"for all/exists\" statement about a relation, the \"for all\" terms are the input arguments to the relation, and the \"exists\" terms are its outputs.\n\n== Syntax ==\n\nA mode declaration for the family ''id'' with ''n'' arguments usually takes the following (\"short\") form:\n\n<code>%mode id a1 ... an.</code>\n\nEach argument <tt>ai</tt> is <tt>+</tt>''ID'', <tt>-</tt>''ID'', or <tt>*</tt>''ID'' for some distinct identifier ''ID''. <tt>+</tt> indicates that the argument is an input, <tt>-</tt> that it is an output, and <tt>*</tt> that the argument is unrestricted. (The <tt>*</tt> mode is rarely used.) For example, a natural mode for the <tt>plus</tt> relation on [[natural numbers]] is:\n\n<twelf discard=true>\nplus : nat -> nat -> nat -> type.\n%mode plus +N1 +N2 -N3.\n</twelf>\n\nThe names <tt>N1</tt>..<tt>N3</tt> are arbitrary, but each must be distinct.\n\n=== Full form ===\n\nThe short mode declaration above only specifies the mode for explicit parameters; the modes for implicit parameters are then assigned automatically. Occasionally, one needs to use a \"full\" form to specify the modes of implicit parameters:\n\n<twelf discard=true>\n%mode p1 ... pm  term.\n</twelf>\n\nEach parameter <tt>pi</tt> is <tt>+{</tt>''ID''<tt> : term}</tt>, <tt>-{</tt>''ID''<tt> : term}</tt>, or <tt>*{</tt>''ID''<tt> : term}</tt> for distinct identifiers ''ID''. Terms may refer to the variables bound in the previous parameters. For example, the full mode declaration corresponding to the short one above would be:\n\n<twelf discard=true>\nplus : nat -> nat -> nat -> type.\n%mode +{N1:nat} +{N2:nat} -{N3:nat} plus N1 N2 N3.\n</twelf>\n\n{{needs|an example where the full mode specification is actually needed}}\n\n== Mode checking ==\n\n===Basic mode checking errors===\n\nSay we give a definition of the natural numbers with addition in line with the descriptions above:\n\n<twelf>\nnat: type.\nz: nat.\ns: nat -> nat.\n\nplus: nat -> nat -> nat -> type.\n%mode plus +N1 +N2 -N3.\n\npz: plus z N N.\nps: plus (s N1) N2 (s N3)\n     <- plus N1 N2 N3.\n</twelf>\n\nThe input of plus is the first and second positions, and the output of plus is the third position, which means that for any [[ground]] objects in the first and second positions, there must only be a ground object in the third position. If one of the output arguments is not forced to be a ground, which would be the case if the output of plus no longer matched the output of the [[subgoal]], then \n\n<twelf check=decl discard=true>\npx: plus (s N1) N2 (s N)\n     <- plus N1 N2 N3.\n</twelf>\n\nAnother problem occurs when the ''inputs'' to a subgoal are not known to be ground, which would happen if we mis-named one of the inputs to the subgoal.\n\n<twelf check=decl discard=true>\npy: plus (s N1) N2 (s N3)\n     <- plus N N2 N3.\n</twelf>\n\n===Ordering subgoals===\n\nMode checking considers subgoals ''in order'', i.e. from top to bottom when the subgoals are written out in the standard style using backwards arrows. The order of subgoals matters very much for mode checking. Say we have an identity function that maps inputs (the first position) to outputs (the second position).\n\n<twelf>\nid: nat -> nat -> type.\n%mode id +N1 -N2.\n\nid/refl: id N N.\n</twelf>\n\nThe rule <tt>ps'</tt> below passes the mode checker, because the call to <tt>id</tt> takes the ground argument <tt>N1</tt> and creates a ground output <tt>N1'</tt>, which is then used in the derivation for <tt>plus N1' N2 N3</tt>.\n\n<twelf check=decl discard=true>\nps': plus (s N1) N2 (s N3)\n      <- id N1 N1'\n      <- plus N1' N2 N3.\n</twelf>\n\nHowever, if we reverse the order of the two subgoals, even though the result is logically equivalent, Twelf considers <tt>plus N1' N2 N3</tt> before <tt>id N1 N1'</tt>, and so does consider <tt>N1'</tt> to be ground when it encounters it; thus, complaining accordingly: \n\n<twelf check=decl discard=true>\nps': plus (s N1) N2 (s N3)\n      <- plus N1' N2 N3\n      <- id N1 N1'.\n</twelf>\n\n{{needs|a more complete description of more interesting mode checking problems}}\n\n== See also ==\n* {{guide|chapter=7|section=41|title=Modes}}\n* {{proving|title=Proving totality assertions about the natural numbers}}, particulary the section on [[Proving metatheorems:Proving_totality_assertions_about_the_natural_numbers#Mode|Mode]].\n\n\n{{keyword|key=mode}}"
          },
          "sha1": "6gyq8fzrrtybo9bd8j61lm148ai4nm7"
        }
      },
      {
        "title": "%name",
        "ns": 0,
        "id": 1750,
        "revision": {
          "id": 6102,
          "parentid": 3483,
          "timestamp": "2010-09-01T20:08:50Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "tag fixes",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 3066,
            "#text": "A '''<tt>%name</tt>''' declaration allows us to direct Twelf to name unnamed variables in a certain way, which can make it much easier to understand Twelf's output. Using a <tt>%name</tt> declaration is never required, but it often makes the task of proving [[metatheorem]]s significantly easier. More information can be found in the section on {{guide|chapter=3|section=5|title=name preferences}}.\n\nTwo examples show the use of <tt>%name</tt> - the first shows its use to give a default name for universally quantified variables, and the second example shows its use to give a default name for both universally quantified variables and bound variables.\n\n== Example 1: Natural numbers ==\n\nWe start with a standard presentation of unary numbers and addition:\n\n<twelf>\nnat : type.\n\nz : nat.\ns : nat -> nat.\n\n\n\nplus : nat -> nat -> nat -> type.\n\nplus/z : plus z N N.\n\nplus/s : plus (s N1) N2 (s N3) <- plus N1 N2 N3.\n</twelf>\n\n\nIf we give Twelf a derivation, but do not give it information about the type of that derivation, it will infer the type. In order to return the most general possible type, Twelf considers the second type to be an \"anonymous\" (or [[universally quantified]]) variable. If Twelf is given no other information, it will automatically name all anonymous variables <tt>X1</tt>, <tt>X2</tt>, etc...\n\n<twelf check=\"decl\">\n_ = plus/s (plus/s plus/z).\n</twelf>\n\n\nThese type reconstructions can become rather complicated, particularly when we are dealing with metatheorems that have multiple types. A good way to deal with this complexity is by giving Twelf a different prefix for anonymous variables of different types using the <tt>%name</tt> declaration.\n\n<twelf>\n%name nat N.\n</twelf>\n\n\nThis identifier ''must'' start with an uppercase letter, and often only a single uppercase letter suffices; however, any identifier starting with an uppercase letter works. Given this information, Twelf will change the prefix of anonymous variables from <tt>X</tt> to whatever was defined in the <tt>%name</tt> declaration.\n\n<twelf check=\"decl\">\n_ = plus/s (plus/s plus/z).\n</twelf>\n\n== Example 2: Call-by-name lambda calculus ==\n\nWe can also use the <tt>%name</tt> declaration to define the default name for bound variables. \n\n<twelf import=\"lam\">\nexp : type. \n\nlam : (exp -> exp) -> exp.\napp : exp -> exp -> exp.\n\n\n\nstep : exp -> exp -> type.\n\nstep/app : step (app E1 E2) (app E1' E2) <- step E1 E1'.\n\nstep/appabs : step (app (lam E1) E2) (E1 E2).\n</twelf>\n\n\nThe default prefix for universally quantified variables is again <tt>X</tt>. Also, observe that the default prefix for bound variables is <tt>x</tt>.\n\n<twelf import=\"lam\" check=decl>\n_ = (step/app (step/app step/appabs)).\n</twelf>\n\n\nThis <tt>%name</tt> declaration causes no output from Twelf, but it changes the prefixes of universally quantified and bound variables to <tt>E</tt> and <tt>e</tt>, respectively.\n\n<twelf import=\"lam\" check=decl>\n%name exp E e.\n\n_ = (step/app (step/app step/appabs)).\n</twelf>\n\n== See also ==\n* {{guide|chapter=3|section=5|title=Name preferences}}\n\n{{keyword|key=name}}"
          },
          "sha1": "6ntied75zffdtrii7d8ryna1lz2ed8x"
        }
      },
      {
        "title": "%postfix",
        "ns": 0,
        "id": 1657,
        "redirect": {
          "@title": "Fixity declaration",
          "#text": null
        },
        "revision": {
          "id": 2335,
          "timestamp": "2006-10-02T17:12:35Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "comment": "redirect to fixity declaration",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 32,
            "#text": "#REDIRECT [[fixity declaration]]"
          },
          "sha1": "k5vzgkrhi1sop7wr9vg2xafz5f4o6ct"
        }
      },
      {
        "title": "%prefix",
        "ns": 0,
        "id": 1656,
        "redirect": {
          "@title": "Fixity declaration",
          "#text": null
        },
        "revision": {
          "id": 2334,
          "timestamp": "2006-10-02T17:12:24Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "comment": "redirect to fixity declaration",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 32,
            "#text": "#REDIRECT [[fixity declaration]]"
          },
          "sha1": "k5vzgkrhi1sop7wr9vg2xafz5f4o6ct"
        }
      },
      {
        "title": "%prove",
        "ns": 0,
        "id": 1825,
        "revision": {
          "id": 3463,
          "parentid": 3422,
          "timestamp": "2006-12-29T19:07:21Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "near-duplicate of %establish",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 526,
            "#text": "The '''<tt>%prove</tt>''' directive attempts to prove a theorem specified by a <tt>[[%theorem]]</tt> directive using the [[theorem prover]]. It is therefore similar to the <tt>[[%establish]]</tt> directive. However, unlike the <tt>%establish</tt> directive, theorems shown to be true by the <tt>%prove</tt> directive are considered as potential lemmas when the theorem prover attempts to prove future theorems.\n\n== See also ==\n\n* [[Theorem prover]]\n* {{guide|title=Theorem Prover|chapter=10|section=57}}\n\n{{keyword|key=prove}}"
          },
          "sha1": "9b4c8kie6yfwz4jleknzlo1oi6c9ulp"
        }
      },
      {
        "title": "%query",
        "ns": 0,
        "id": 1886,
        "revision": {
          "id": 6103,
          "parentid": 4881,
          "timestamp": "2010-09-01T21:15:15Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 3306,
            "#text": "The '''<tt>%query</tt>''' declarations specify a type (that corresponds to a judgment by the [[judgments as types]] principle), and tells Twelf's [[logic programming]] engine to search for a proof of that judgment. \n\nA query declaration also takes two other inputs, which can either be a number or a star \"<tt>*</tt>\". The meaning of this can be slightly counterintuitive:\n\n* The first input is the ''expected number of solutions'' - a star here means \"as many solutions as you let Twelf look for\"\n* The second input is the ''number of solutions to find'' - a star here means \"keep looking until you have found all solutions\"\n\nThis meaning that some possible queries will always fail:\n\n* <tt>%query 5 4 ...</tt> will always fail because there is no way to come up with 5 solutions in 4 tries\n* <tt>%query 6 6 ...</tt> means the same thing as <tt>%query * 6 ...</tt>, because both mean \"try six times, and find a solution every time\"\n* <tt>%query * * ...</tt> will either keep coming up with more solutions forever (and will therefore not terminatie) or it will eventually fail to come up with a solution and so will fail.\n\n== Example ==\n\nWe will use the example of list membership to demonstrate <tt>%query</tt> because there may be multiple ways to find an element in a list (if that element occurs multiple times).\n\n<twelf>\nelem : type.\na : elem.\nb : elem.\nc : elem.\nd : elem.\n\nlist : type.\nnil : list.\n, : elem -> list -> list. %infix right 10 ,.\n\nsample-list : list = a , c , a , b , a , c , a , a , b , c , c , d , nil.\n\nmember : elem -> list -> type.\nmember/hit  : member A (A , L).\nmember/skip : member A (B , L)\n               <- member A L.\n</twelf>\n\n<twelf discard=true check=true>\n%query 1 * member d sample-list.   % There is exactly one \"d\" in the list\n%query 3 3 member a sample-list.   % There are at least three \"a's\" in the list\n%query * 2 member b sample-list.   % There are at least two \"b's\" in the list\n%query * 0 member c sample-list.   % Try zero times (the query isn't even run)\n%query 8 0 member c sample-list.   % Try zero times (the query isn't even run)\n%query 3 * member a sample-list.   % Fails because there are more than 3 solutions\n</twelf>\n\n=== Getting output from <tt>%query</tt> ===\n\nUnlike <tt>[[%solve]]</tt>, <tt>%query</tt> declarations do not allow you to insert the output of a query into the [[signature]]. However, you can inspect the output in the Twelf buffer. For example, if we leave the first argument of <tt>%query</tt> as a [[metavariable]], the following query will output the first two elements it finds in the list (the first two elements in the list).\n\n<twelf check=decl>\n%query * 2 member E sample-list. \n</twelf>\n\nFurthermore, if you change the format of a query from <tt>%query 1 * ...</tt> to <tt>%query 1 * D : ...</tt>, where <tt>D</tt> is some uppercase identifier, it will print the [[proof term]] that caused the query to succeed. The proof terms below indicate that the first two instances of <tt>b</tt> is located in the fourth position in the list (the search skips three times and then hits) and in the ninth position in the list (the search skips eight times and then hits).\n\n<twelf check=decl>\n%query * 2 D : member b sample-list. \n</twelf>\n\n== See also ==\n\n* {{guide|chapter=5|section=23|title=Query Declaration}}\n{{keyword|key=query}}"
          },
          "sha1": "02b5ndwl3kz5qwq662413z76vlb0ahd"
        }
      },
      {
        "title": "%querytabled",
        "ns": 0,
        "id": 1866,
        "revision": {
          "id": 3898,
          "parentid": 3795,
          "timestamp": "2007-03-09T18:53:59Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 428,
            "#text": "The '''<tt>%querytabled</tt>''' directive starts a query using Twelf's [[tabled logic programming]] engine, so that instances of a type family marked with <tt>[[%tabled]]</tt> directive will be derived at most once during proof search. It otherwise looks the same as <tt>[[%query]]</tt>.\n\n== See also ==\n\n* [[Tabled logic programming]]\n* {{guide|chapter=5|section=31|title=Tabled Logic Programming}}\n\n{{keyword|key=querytabled}}"
          },
          "sha1": "ei82n49be38z2qs0z536f92z8q7zbce"
        }
      },
      {
        "title": "%reduces",
        "ns": 0,
        "id": 1491,
        "revision": {
          "id": 4849,
          "parentid": 4838,
          "timestamp": "2007-09-27T04:20:19Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "minor": null,
          "comment": "Reverted edits by [[Special:Contributions/209.99.227.70|209.99.227.70]] ([[User_talk:209.99.227.70|Talk]]); changed back to last version by [[User:128.237.253.199|128.237.253.199]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 2706,
            "#text": "{{needswork|Example should be broken up in to more literate-code-like pieces}}\n\nThe '''<tt>%reduces</tt>''' declaration checks a specified subderivation relationship between two derivations in a judgment. Once a <tt>%reduces</tt> relationship has been established for a judgment, the termination checker can use that information to verify that inductive calls are always on smaller derivations. Its primary use is for termination checking in inductive proofs that induct on the output of some other judgment, rather than directly on a subderivation.\n\n== Example ==\n\n<twelf>nat : type.\n\nnat/z\t: nat.\nnat/s\t: nat -> nat.\n\n\n\nnat-plus : nat -> nat -> nat -> type.\n\nnat-plus/z\t: nat-plus nat/z N N.\n\nnat-plus/s\t: nat-plus (nat/s N1) N2 (nat/s N3)\n\t\t   <- nat-plus N1 N2 N3.\n\n\n\nnat-plus-reduces\t: {N2}{N3}\n\t\t\t   nat-plus N1 N2 N3\n\t\t\t   -> type.\n%mode nat-plus-reduces +D1 +D2 +D3.\n\n-\t: nat-plus-reduces _ _ nat-plus/z.\n\n-\t: nat-plus-reduces _ _ (nat-plus/s DL)\n\t   <- nat-plus-reduces _ _ DL.\n\n%worlds () (nat-plus-reduces _ _ _).\n%reduces N2 <= N3 (nat-plus-reduces N2 N3 _).\n%total {D1} (nat-plus-reduces _ _ D1).\n\n\n\nnat-plus-reduces-s\t: {N2}{N3}\n\t\t\t   nat-plus (nat/s N1) N2 N3\n\t\t\t   -> type.\n%mode nat-plus-reduces-s +D1 +D2 +D3.\n\n-\t: nat-plus-reduces-s _ _ (nat-plus/s nat-plus/z).\n\n-\t: nat-plus-reduces-s _ _ (nat-plus/s DL)\n\t   <- nat-plus-reduces-s _ _ DL.\n\n%worlds () (nat-plus-reduces-s _ _ _).\n%reduces N2 < N3 (nat-plus-reduces-s N2 N3 _).\n%total {D1} (nat-plus-reduces-s _ _ D1).\n</twelf>\n\nIn the above example, addition over the natural numbers was defined in the standard way. Two properties about <tt>nat-plus</tt> were proven. The first is that if <tt>nat-plus N1 N2 N3</tt>, then <tt>N2</tt> is a subderivation of <tt>N3</tt>. The second is that if <tt>nat-plus (nat/s N1) N2 N3</tt>, then <tt>N2</tt> is a strict subderivation of <tt>N3</tt>. In this particular case, these theorems do not produce any output derivations. Instead, verifying the subderivation relation through the <tt>%reduces</tt> declaration is the output.\n\nTwelf also permits the relations <tt>&lt;=</tt> and <tt>=</tt> to be established via <tt>%reduces</tt>. The former may be useful when the [[%terminates|termination order]] (of the theorem using the lemma in question) is complex, such as a lexicographic or mutual order.\n\n<!-- maybe these should be in see also? -Tom -->\nA good example of making use of <tt>%reduces</tt> information in another proof is available in the tutorial on [[division over the natural numbers]]. An extended version of this example is in [[using nat-less with %reduces]].\n\n== See also ==\n* {{guide|chapter=8|section=47|title=%reduces declaration}}\n\n{{keyword|key=reduces}}\n\n== Headline text =="
          },
          "sha1": "j86skdh1ki518re15ar9cfcaf9hj44t"
        }
      },
      {
        "title": "%solve",
        "ns": 0,
        "id": 1919,
        "revision": {
          "id": 4299,
          "parentid": 4298,
          "timestamp": "2007-03-18T05:27:49Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "wrap up",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 1166,
            "#text": "A <tt>[[%solve]]</tt> declaration specifies a type and then uses Twelf's [[logic programming]] engine to search for an term with that type. It is different from <tt>[[%query]]</tt>, both because it can only cause Twelf to search for the ''first'' proof it can find and because it can add the result of the search to the [[Twelf signature]].\n\n== Example ==\n\nWe can define [[natural numbers]] with addition in the standard manner:\n\n<twelf>\nnat : type.\nz : nat.\ns : nat -> nat.\n\nplus : nat -> nat -> nat -> type.\npz : plus z N N.\nps : plus N1 N2 N3 -> plus (s N1) N2 (s N3).\n</twelf>\n\nThen we can use <tt>%solve</tt> and <tt>%define</tt> to insert the result of adding two and two to the signature as <tt>four</tt>, and the derivation itself to the signature as <tt>deriv</tt>.\n\n<twelf check=decl>\n%define four = N\n%solve deriv : plus (s (s z)) (s (s z)) N.\n</twelf>\n\nWe can then use <tt>five</tt> and <tt>deriv</tt> as a defined constants for the rest of the program:\n\n<twelf check=true>\nsix : nat = s (s four).\nderiv2 : plus four (s (s z)) six = ps (ps deriv).\n</twelf>\n\n== See also ==\n\n* {{guide|title=Solve Declaration|section=24|chapter=5}}\n\n\n{{keyword|key=solve}}"
          },
          "sha1": "qovttbau2glamy1ryo02fav5qs3ixtp"
        }
      },
      {
        "title": "%subord",
        "ns": 0,
        "id": 2051,
        "revision": {
          "id": 5186,
          "parentid": 5184,
          "timestamp": "2008-07-12T20:43:41Z",
          "contributor": {
            "username": "Geoffw",
            "id": 33
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 506,
            "#text": "{{undocumented|article}}\n\nThe '''<tt>%subord</tt>''' declaration adds edges to the [[subordination]] relation.  This declaration is currently only available in Twelf CVS{{discuss|Version}} and may not yet be available in [[TwelfTag]]. \n\n== Syntax ==\n\nThe syntax is as follows:\n\n<tt>%subord (t1 t1') ... (tn tn').</tt>\n\nThe type families <tt>ti'</tt> will then be treated as being dependent on the type family <tt>ti</tt>.\n\n== Example ==\n\n{{needs|a good concise example.}}\n\n\n{{keyword|key=subord}}\n\n{{stub}}"
          },
          "sha1": "8lkdcysx351co2qn1imoioqgvlen8q4"
        }
      },
      {
        "title": "%tabled",
        "ns": 0,
        "id": 1867,
        "revision": {
          "id": 3799,
          "parentid": 3794,
          "timestamp": "2007-02-28T09:23:25Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "the reverse is also true...",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 511,
            "#text": "The <tt>'''%tabled'''</tt> directive informs Twelf's [[tabled logic programming]] engine to record derivations for a certain type family ''at most once'' during a query started with a <tt>[[%querytabled]]</tt> directive. It is therefore a bit like <tt>[[Deterministic declaration|%deterministic]]</tt> in that it changes Twelf's search behavior for a single type family.\n\n== See also ==\n\n* [[Tabled logic programming]]\n* {{guide|chapter=5|section=31|title=Tabled Logic Programming}}\n\n{{keyword|key=querytabled}}"
          },
          "sha1": "qmw62mo271xzp02mlv26i4gtnldtc5f"
        }
      },
      {
        "title": "%terminates",
        "ns": 0,
        "id": 1977,
        "revision": {
          "id": 6187,
          "parentid": 6145,
          "timestamp": "2010-11-17T15:58:36Z",
          "contributor": {
            "ip": "24.131.94.40"
          },
          "comment": "typo",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 7571,
            "#text": "A '''[[%terminates]]''' declaration provides checks that a program will either succeed or fail in a finite amount of time when given [[ground]] inputs. \n\nA <tt>[[%total]]</tt> declaration uses the same syntax as a <tt>%terminates</tt> declaration. \n\n== Termination checking in Twelf == \n\nTermination is in general an undecidable problem, and so Twelf uses a simple strategy of requiring the user to define some '''termination ordering''', and then checking that every recursive subgoal makes that ordering smaller. \n\nTwelf considers a term to be smaller than another term if it can inspect the two terms to see that the first is a strict subterm or if it follows from a <tt>[[%reduces]]</tt> declaration that the first is smaller. Twelf also uses [[mode]] information to ensure that it is reasoning about [[ground]] terms.\n\nA term A is only considered to be smaller than B if A is a strict subterm of B. So, for instance, <tt>(s (s z))</tt>, <tt>(s z)</tt>, and <tt>z</tt> are all subterms of <tt>(f (s (s z)) (s z))</tt>, but <tt>(f z z)</tt> is not. \n\nAs usual, we will use the [[natural numbers]] as the basis for our example. \n\n<twelf>\nnat: type.\n\nz: nat.\ns: nat -> nat.\n</twelf>\n\n=== Non-ordering ===\n\nThe simplest termination ordering says that no termination argument is needed, because there are no recursive calls! We can write such an ordering for <tt>triv</tt>, which takes a number and can either return a number one greater or one less.\n\n<twelf>\ntriv: nat -> nat -> type.\n%mode triv +A -B.\n\ntriv/: triv (s N) N.\ntriv/: triv N (s N).\n</twelf>\n\n<twelf check=decl>\n%terminates {} (triv _ _).\n</twelf>\n\n=== Simple ordering ===\n\nA simple ordering says that one term always gets smaller in a subgoal, even if the other ones get larger. The first argument to <tt>a</tt> always gets smaller in this example (even though the second may get bigger). We only need to be able to reason about the first argument, but we define both to be inputs.\n\n<twelf>\na : nat -> nat -> type.\n%mode a +A +B.\n\na0 : a z z.\na1 : a (s N1) N\n      <- a N1 (s (s (s N))).\n</twelf>\n<twelf check=decl>\n%terminates N (a N _).\n</twelf>\n\nAlternatively, the second argument to <tt>b</tt> always gets smaller (even though the first may stay the same), and the termination declarations capture this information. The <tt>*A</tt> in the <tt>[[%mode]]</tt> declaration means that we do not care whether the first argument to <tt>b</tt> is an input or an output. \n\nNotice that because we already showed <tt>a</tt> to be terminating, we can use it as a subgoal to <tt>b</tt> as long as it is only called with ground terms.\n\n<twelf>\nb : nat -> nat -> type.\n%mode b *A +B.\n\nb0 : b (s z) (s z).\nb1 : b N (s (s M))\n      <- b N M\n      <- a (s (s (s M))) M.\n</twelf>\n<twelf check=decl>\n%terminates N (b _ N).\n</twelf>\n\n=== Simultaneous ordering ===\n\nWe can define a relation <tt>c</tt> that non-deterministically counts three numbers down to zero:\n\n<twelf>\nc : nat -> nat -> nat -> type.\n%mode c +N1 +N2 +N3.\n\nc0 : c z z z.\nc1 : c (s N1) N2 N3\n      <- c N1 N2 N3.\nc2 : c N1 (s N2) N3\n      <- c N1 N2 N3.\nc3 : c N1 N2 (s N3)\n      <- c N1 N2 N3.\n</twelf>\n\nNo single term gets smaller at any one step, but ''some'' term gets smaller at every step. We can express this using a simultaneous ordering:\n\n<twelf check=decl>\n%terminates [N1 N2 N3] (c N1 N2 N3).\n</twelf>\n\n=== Lexicographic ordering ===\n\nLexicographic orders generalize simultaneous orders - using a lexicographic ordering we can define <tt>d</tt> in a manner similar to <tt>c</tt>, but we can allow the second and third numbers to count ''up'' whenever the first number counts down, and allow the third number to count up whenever the second number counts down.  However, the first number must stay constant when the second counts down, and the first and second both must stay constant when the third counts down.\n\n<twelf>\nd : nat -> nat -> nat -> type.\n%mode d +N1 +N2 +N3.\n\nd0 : d z z z.\nd1 : d (s N1) N2 N3\n      <- d N1 (s (s (s (s N2)))) (s (s N3)).\nd2 : d N1 (s N2) N3\n      <- d N1 N2 (s N3).\nd3 : d N1 N2 (s N3)\n      <- d N1 N2 N3.\n</twelf>\n\n<twelf check=decl>\n%terminates {N1 N2 N3} (d N1 N2 N3).\n</twelf>\n\n=== Lexicographic ordering II ===\n\nAnother example that is (slightly) less contrived arises with lists of natural numbers. If we want to directly represent the sum of a natural number <tt>N</tt> and a list <tt>L</tt>, then we can define it as follows:\n\n* The sum of <tt>z</tt> and <tt>nil</tt> is <tt>z</tt>.\n* The sum of <tt>z</tt> and <tt>cons N L</tt> is the sum of <tt>N</tt> and <tt>L</tt>.\n* The sum of <tt>(s N)</tt> and <tt>L</tt> is <tt>s M</tt>, if <tt>M</tt> is the sume of <tt>N</tt> and <tt>L</tt>.\n\nThis is a lexicographic induction - either the list gets smaller, or the natural number gets smaller and the list stays the same size.\n\n<twelf>\nlist : type.\nnil : list.\ncons : nat -> list -> list.\n\nlistsum : nat -> list -> nat -> type.\n%mode listsum +N +L -M.\n\nlsz : listsum z nil z.\nlsl : listsum z (cons N L) M <- listsum N L M.\nlss : listsum (s N) L (s M) <- listsum N L M.\n</twelf>\n\n<twelf check=decl>\n%terminates {L N} (listsum N L M).\n</twelf>\n\n=== Mutual, lexicographic ordering ===\n\nIn this case, we have a program that is non-deterministic to illustrate more possibilities. We will describe a \"big\" lemma and a \"small\" lemma, each with two arguments. Twelf decides what is \"big\" or \"small\" based on the way we order things - from small to large - in the <tt>%terminates</tt> declaration below.\n\n<twelf check=true>\nbig : nat -> nat -> nat -> type.\nsmall : nat -> nat -> nat -> type.\n%mode big +A +B -C.\n%mode small +A +B -C.\n</twelf>\n\nWe can split up the possibilities into four cases:\n\n* We \"bottom out\" in a base case or a call to another theorem:\n\n<twelf>\n& : small z N N.\n& : big N M P\n     <- listsum N (cons M (cons M nil)) P.\n</twelf>\n\n* The second argument gets smaller (nothing else matters)\n\n<twelf>\n& : small N1 (s N2) N3\n     <- big (s (s N1)) N2 N3.\n& : small N1 (s N2) N3\n     <- big N2 N2 N3.\n& : big N1 (s (s N2)) N3\n     <- big N1 N2 N3.\n</twelf>\n\n* The first argument gets smaller, and the second argument gets no bigger.\n\n<twelf>\n& : small (s N1) (s N2) (s N3)\n     <- big N1 N2 N3.\n& : big (s N1) N2 N3\n     <- big N1 N2 N3.\n</twelf>\n\n* The \"lemma\" gets smaller and everything else gets no bigger.\n\n<twelf>\n& : big N1 N2 N3\n     <- small N1 N2 N3.\n& : big (s N1) (s N2) N3\n     <- small N1 N2 N3.\n</twelf>\n\nThese requirements are encoded in the declaration below. The ordering of the patterns declares <tt>small</tt> to be smaller than <tt>big</tt>, and either the second argument (<tt>B1</tt> and <tt>B2</tt>) gets smaller, or else it gets no bigger and the first\nargument (<tt>A1</tt> and <tt>A2</tt>) gets smaller.\n\n<twelf check=decl>\n%terminates {(B1 B2) (A1 A2)} (small A2 B2 _) (big A1 B1 _).\n</twelf>\n\n== Troubleshooting ==\n\nThe simplest example of running afoul of the Twelf termination checker is if the recursive call uses an argument unrelated to the original argument. \n\n<twelf discard=true check=decl>\ne: nat -> nat -> type.\n- : e N M <- e M N.\n%mode e +N +M.\n%terminates N (e N M).\n</twelf>\n\nAs the error message indicates, Twelf requires that <tt>M</tt> be less than <tt>N</tt> in the recursive call in order for termination analysis to hold, but it has\nno way of establishing this. If, for some reason, the un-fufilled termination requirement is actually true, it can often be established with a <tt>[[%reduces]]</tt>\ndeclaration.\n\n== See also ==\n\n* {{guide|chapter=8|section=45|title=Termination}}\n* <tt>[[%total]]</tt>\n* [[Lexicographic induction]]\n* [[Mutual induction]]"
          },
          "sha1": "0y19w4gb1bhmw5zdttt1zdtbgoj5lw2"
        }
      },
      {
        "title": "%thaw",
        "ns": 0,
        "id": 1871,
        "revision": {
          "id": 3801,
          "parentid": 3789,
          "timestamp": "2007-02-28T15:18:57Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "minor": null,
          "comment": "minor punctuation / wordsmithing",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 615,
            "#text": "{{undocumented}}\nThe '''<tt>%thaw</tt>''' directive allows previously [[frozen]] type families to be extended with new [[canonical forms]]. Because this can easily be used to invalidate [[metatheorem]]s, it is a directive that can only be used in [[unsafe mode]].\n\nIf Twelf is in unsafe mode, the following code can be run to demonstrate '''<tt>%thaw</tt>''':\n\n<twelf>\nnat : type.\nz : nat.\ns : nat -> nat.\n\n%freeze nat.\n\n% Right here I could not declare a new constant of type nat\n\n%thaw nat.\n\n% Now I can define a wacky new natural number\nq : nat.\n</twelf>\n\n== See also ==\n\n* [[Auto-freezing]]\n{{keyword|key=thaw}}"
          },
          "sha1": "c45g00jn8yzt6jzlc5aqoa3cv5ibfc1"
        }
      },
      {
        "title": "%theorem",
        "ns": 0,
        "id": 1824,
        "revision": {
          "id": 5043,
          "parentid": 5041,
          "timestamp": "2008-01-31T07:56:50Z",
          "contributor": {
            "ip": "12.108.175.130"
          },
          "comment": "typos, 'needs'",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 928,
            "#text": "The '''<tt>%theorem</tt>''' declaration acts as the ''specification'' of a theorem.\n\n{{needs|syntax of the declaration}}\n\n== Use to write statements of metatheorems ==\n\nSome people find the notation a clearer way of specifying [[metatheorems]]; a <tt>%theorem</tt> declaration used in this style handles the type family declation and the <tt>[[%mode]]</tt> declaration parts of a [[totality assertion]].\n\n== Use with the theorem prover ==\n\nWhen using the Twelf [[theorem prover]], a <tt>%theorem</tt> declaration establishes a proposition that the theorem prover may later attempt to establish. A '''<tt>%theorem</tt>''' declaration is thus somewhat analogous to the three-part specification of a [[totality assertions]], the type family definition, the [[%mode]] declaration, and the [[%worlds]] declaration. \n\n== See also ==\n\n* [[Theorem prover]]\n* {{guide|title=Theorem Prover|chapter=10|section=57}}\n\n{{keyword|key=theorem}}"
          },
          "sha1": "rbodpd7ns42w3ikvx6s14hnvv5jmh1q"
        }
      },
      {
        "title": "%total",
        "ns": 0,
        "id": 1653,
        "revision": {
          "id": 4616,
          "parentid": 4583,
          "timestamp": "2007-03-21T15:27:38Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "comment": "improve accuracy; remove reminders of our bugs that are like ancient history anyway",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 2805,
            "#text": "In Twelf, a [[totality assertion]] for an LF [[type family]] is specified by a <tt>[[%mode]]</tt> declaration and a <tt>[[%worlds]]</tt> declarations. A '''<tt>%total</tt>''' declaration for a type family causes Twelf to attempt to verify the specified totality assertion.  Twelf does so by attempting to prove that the type family defines a total logic program.  The <tt>%total</tt> declaration is used both to verify properties of object-language [[judgment]]s and to check proofs of general [[metatheorem]]s.  \n\nA <tt>%total</tt> declaration requires that [[%mode]] checking and [[%worlds]] checking have already succeeded.  \nThen a '''<tt>%total</tt>''' declaration causes Twelf to run a number of analyses:\n* '''[[Termination analysis]]''' - The syntax of a <tt>%total</tt> declaration is the same as a <tt>[[%terminates]]</tt> declaration, and Twelf runs its termination analysis with that information.  This verifies that the logic program always terminates when given [[ground]] inputs. \n* '''[[Coverage checking|Input coverage checking]]''' - Twelf uses the modes specified by the <tt>[[%mode]]</tt> declaration (<tt>[[%mode]]</tt> and <tt>[[%covers]]</tt> declarations also have the same syntax) to check input coverage.  This verifies that the logic program will match all possible ground inputs in the specified set of contexts.  \n* '''[[Coverage checking|Output coverage checking]]''' - Twelf checks that the output of a [[subgoal]] can never fail to unify.  First, it checks for incorrect constant pattern-matching; next, it checks for [[output freeness]] violations. \n\nTaken together, these analyses verify that if the type family is run as a [[logic program]] in Twelf with ground derivations in the input positions, then it the execution will terminate successfully and will derive ground derivations in the output positions.  This proves the [[totality assertion]] for the type family:  \nin any context conforming to the <tt>%worlds</tt> declaration, for any ground derivations in the input positions (as specified by the <tt>%mode</tt> declaration), there exist ground derivations for the output positions such that the type family is inhabited.\n\n== See also ==\n* Read the [[introductions to Twelf]] to learn more about <tt>%total</tt>.  The following sections of [[Proving metatheorems with Twelf]] are particularly relevant: [[Proving metatheorems:Proving totality assertions about the natural numbers|Proving totality assertions about the natural numbers]], [[Proving metatheorems:Proving metatheorems about the natural numbers|Proving metatheorems about the natural numbers]], [[Proving metatheorems:Proving totality assertions in non-empty contexts|Proving totality assertions in non-empty contexts]].\n* {{guide|chapter=9|section=55|title=Totality}}\n\n{{keyword|key=total}}\n{{stub}}"
          },
          "sha1": "arj4p39mje994w1twilo8yffblyhkow"
        }
      },
      {
        "title": "%trustme",
        "ns": 0,
        "id": 1458,
        "revision": {
          "id": 4929,
          "parentid": 4926,
          "timestamp": "2007-10-11T02:40:46Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "minor": null,
          "comment": "Reverted edits by [[Special:Contributions/217.171.176.46|217.171.176.46]] ([[User_talk:217.171.176.46|Talk]]); changed back to last version by [[User:Rsimmons|Rsimmons]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 385,
            "#text": "{{undocumented}} The '''<tt>%trustme</tt>''' keyword, when it precedes another directive such as a '''<tt>%total</tt>''' directive, causes Twelf to believe that the directive succeeded even if it did not. This feature is only available in [[unsafe mode]], and can be used to easily create [[holes in metatheorems]].\n\n== See also ==\n\n* [[Holes in metatheorems]]\n\n{{keyword|key=trustme}}"
          },
          "sha1": "qfu422d2iwsm6x6pepnnb7jrvjddd1k"
        }
      },
      {
        "title": "%unique",
        "ns": 0,
        "id": 1933,
        "revision": {
          "id": 5957,
          "parentid": 5956,
          "timestamp": "2009-03-24T04:53:54Z",
          "contributor": {
            "username": "William Lovas",
            "id": 11
          },
          "comment": "on impossible goals, and some rewording /* Coverage checking */",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 5096,
            "#text": "{{undocumented}}\nA '''<tt>%unique</tt>''' declaration attempts to automatically check whether some positions of a relation (its outputs) are uniquely determined by some other positions (its inputs). Its syntax is similar to that of <tt>[[%mode]]</tt>, except that in addition to being able to specify an argument to be an input (<tt>+</tt>), an output (<tt>-</tt>), or unmoded (<tt>*</tt>), you may also specify an argument to be a unique output (<tt>-1</tt>).\n\nSuccessful <tt>%unique</tt> declarations are used to simplify [[coverage checking]], and they can easily be transformed into first-class [[uniqueness lemma|uniqueness lemmas]].\n\n<!--\nCurrently there is no way to utilize the result of a successful <tt>%unique</tt> declaration and so its use is not suggested - an equivalent result can be established by a [[uniqueness lemma]].\n-->\n\n== Example ==\n\nWe define the oft-used example of addition of [[natural numbers]]:\n\n<twelf>\nnat : type.\nz : nat.\ns : nat -> nat.\n\nplus : nat -> nat -> nat -> type.\npz : plus z N N.\nps : plus (s N1) N2 (s N3)\n      <- plus N1 N2 N3.\n</twelf>\n\n\n\nWe can then check for uniqueness using <tt>%unique</tt> (a <tt>[[%worlds]]</tt> declaration is also required).\n\n<twelf check=decl discard=true>\n%worlds () (plus _ _ _).\n%unique plus +N1 +N2 -1N3.\n</twelf>\n\n\n\nIf we had created a non-unique definition of <tt>plus</tt>, for instance by adding an additional, broken version of <tt>ps2</tt>, Twelf would have indicated an error upon checking for uniqueness:\n\n<twelf>\nps2 : plus (s N1) N2 N3 \n      <- plus N1 N2 N3.\n</twelf>\n\n<twelf check=decl discard=true>\n%worlds () (plus _ _ _).\n%unique plus +N1 +N2 -1N3.\n</twelf>\n\n\n== Mutual recursion ==\n\nChecking the uniqueness of mutually recursive predicates\ncreates a problem, because uniqueness (unlike <tt>[[%mode]]</tt>) cannot\nbe checked incrementally.  We therefore introduce a simultaneous\nform of uniqueness declarations, in analogy with other\nsimultaneous declarations.\n\n<twelf>\nnat : type.\nz : nat.\ns : nat -> nat.\n\ndiv2 : nat -> nat -> type.\ndiv2' : nat -> nat -> type.\nd2s : div2 (s N) (s M)\n      <- div2' N M.\nd2z : div2 z z.\nd2's : div2' (s N) M\n       <- div2 N M.\n\n%worlds () (div2 _ _) (div2' _ _).\n\n%unique (div2 +N -1M) (div2' +N' -1M').\n</twelf>\n\n== Coverage checking ==\n\nSuccessful <tt>%unique</tt> declarations are taken into account to simplify certain kinds of coverage goals in [[coverage checking]].  Suppose you have a goal with two hypotheses of the form\n ... {x : a N1 ... Nk M } ... {y : a N1 ... Nk M' } ...\nwhere the inputs <tt>N1 ... Nk</tt> are all equal, and suppose further that you have declared (and Twelf checked)\n %unique a +X1 ... +Xk -1Y.\nThen, Twelf's coverage checker will unify the unique outputs <tt>M</tt> and <tt>M'</tt> in the coverage goal, which may cause some otherwise non-exhaustive pattern match to be recognized as exhaustive.  (If <tt>M</tt> and <tt>M'</tt> do not unify, the coverage goal is impossible, and no case will be needed to cover it.)\n\nAs a simple example, consider proving a first-class [[uniqueness lemma]] for the original <tt>plus</tt> relation defined above.\n<twelf>\nnat : type.\nz : nat.\ns : nat -> nat.\n\nplus : nat -> nat -> nat -> type.\npz : plus z N N.\nps : plus (s N1) N2 (s N3)\n      <- plus N1 N2 N3.\n</twelf>\n\nTo state such a lemma , we first define [[identity]] on natural numbers with just one constructor, reflexivity.\n<twelf>\nid : nat -> nat -> type.\nrefl : id N N.\n</twelf>\nThen we can say that for any <math>N_1</math> and <math>N_2</math>, if both <math>N_1 + N_2 = M</math> and <math>N_1 + N_2 = M'</math>, then in fact <math>M = M'</math>.\n<twelf>\nplus-unique : plus N1 N2 M -> plus N1 N2 M' -> id M M' -> type.\n%mode plus-unique +D +D' -Did.\n</twelf>\nWe might naively hope to be able to prove this theorem with a single case:\n<twelf>\n- : plus-unique D D' refl.\n</twelf>\nHowever, before taking any uniqueness information into account, this pattern match isn't sufficiently general to cover all cases, since matching the third argument as <tt>refl</tt> requires the types of <tt>D</tt> and <tt>D'</tt> to be equal.\n<twelf check=decl discard=true>\n%worlds () (plus-unique _ _ _).\n%total {} (plus-unique _ _ _).\n</twelf>\nIf we can show that <tt>plus</tt>'s output is unique, though, the coverage checker can determine that the coverage goal need not be so generic: the types of <tt>D</tt> and <tt>D'</tt> ''can'' be considered equal, since the uniqueness declaration says that they ''will'' be.\n<twelf>\n%worlds () (plus _ _ _).\n%unique plus +X1 +X2 -1Y.\n</twelf>\n<twelf check=decl>\n%worlds () (plus-unique _ _ _).\n%total {} (plus-unique _ _ _).\n</twelf>\n\n== See also ==\n\n<bibtex>@InProceedings{\n  editor = \"K.Slind and A.Bunker and G.Gopalakrishnan\",\n  author = \"Penny Anderson and Frank Pfenning\",\n  title = \"Verifying uniqueness in a logical framework\",\n  booktitle = \"Proceedings of the 17th International Conference on Theorem Proving in Higher Order Logics (TPHOLs'04)\",\n  pages = \"18-33\",\n  month = \"September\",\n  year = \"2004\",\n  address = \"Park City, Utah\",\n  note = \"Springer LNCS 3223\",\n}</bibtex>\n\n\n\n{{keyword|key=unique}}"
          },
          "sha1": "e22h0ftptkphbx1x5swanns19lblatr"
        }
      },
      {
        "title": "%use",
        "ns": 0,
        "id": 1796,
        "revision": {
          "id": 3814,
          "parentid": 3810,
          "timestamp": "2007-02-28T17:40:49Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "minor": null,
          "comment": "guidelink",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 378,
            "#text": "A '''<tt>%use</tt>''' directive adds a [[constraint domain]] to the current Twelf [[signature]]. \n\nLike some other directives, for instance <tt>[[%clause]]</tt>, it is incompatible with Twelf's ability to verify [[totality assertions]] and [[metatheorems]].\n\n== See also ==\n\n* [[Constraint domains]]\n* {{guide|chapter=6|section=32|title=Constraint domains}}\n\n{{keyword|key=use}}"
          },
          "sha1": "d0iaal9qkfgy1hzmex4unb2fojybhi9"
        }
      },
      {
        "title": "%worlds",
        "ns": 0,
        "id": 1880,
        "revision": {
          "id": 6526,
          "parentid": 6522,
          "timestamp": "2012-06-18T20:50:11Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "Undo revision 6522 by [[Special:Contributions/178.235.240.203|178.235.240.203]] ([[User talk:178.235.240.203|talk]])  -- that's not actual twelf, it's just twelf output, so it should be in a code tag",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 8454,
            "#text": "A '''world''' (or '''worlds''') is a set of [[LF]] contexts.  \n\nThe representation of an [[object language]] in LF is specified not just by an LF [[signature]], but also by the world in which that signature is considered.  This is because a representation that is [[adequate]] in one set of contexts may not be adequate in another. Similarly, a [[totality assertion]] about an LF type family may be true in one set of contexts but false in another. \n\nTwelf includes a '''<tt>%worlds</tt>''' declaration that serves two purposes.  First, it declares the world for which a [[totality assertion]] about a type family is proved. Second, it verifies that the constants inhabiting a type family stay within contexts in the specified world.\n\nIn Twelf, a world is specified by first defining a set of ''blocks'' using a [[%block]] declaration. A block is a pattern that describes a fragment of an LF context.  Then a world is specified by a regular expression <tt>(b1 | b2 | ... | bn)*</tt> for blocks <tt>b1</tt> through <tt>bn</tt>.  This regular expression matches any LF context consisting of any number of these blocks in any order.  Hence, Twelf supports the specification of '''regular worlds'''.  \n\n== Specifying the world of a totality assertion ==\n\nWe can define natural numbers and a relation <tt>max</tt> that defines the larger of two natural numbers.\n\n<twelf>\nnat : type.\nz : nat.\ns : nat -> nat.\n\nmax : nat -> nat -> nat -> type.\nmzz : max z z z.\nmzs : max z (s N) (s N).\nmsz : max (s N) z (s N).\nmss : max (s N1) (s N2) (s N)\n      <- max N1 N2 N.\n</twelf>\n\nAs discussed in the introduction article on [[Proving metatheorems:Representing the judgements of the natural numbers|Representing the judgments of the natural numbers]], the type <tt>nat</tt> in this signature [[adequacy|adequately]] represents the natural numbers only if the LF context does not contain variables of type <tt>nat</tt>.\n\n=== Totality of <tt>max</tt> in the empty context ===\n\nThe judgement <tt>max</tt> defined in this signature is a [[%total|total]] relation on natural numbers, or LF terms of type <tt>nat</tt> in the empty LF context.  We specify this totality assertion in Twelf with the following declarations:\n\n<twelf check=true export=\"maxtotal\">\n%mode max +N1 +N2 -N3.\n%worlds () (max _ _ _).\n%total T (max T _ _).\n</twelf>\n\nThe <tt>%worlds</tt> declaration does not mention any blocks; the world <tt>()*</tt> describes only the empty LF context.  \n\n=== Non-totality of <tt>max</tt> in an extended context ===\n\nWhat happens if we consider <tt>max</tt> in an LF context that includes variables of type <tt>nat</tt>?  (Note that in this world <tt>nat</tt> no longer represents the natural numbers.)\n\nThe following <tt>[[%block]]</tt> declaration defines the block <tt>random_nat</tt>, which allows such variables:\n\n<twelf export=\"badnews\">\n%block random_nat : block {x: nat}.\n\n%mode max +N1 +N2 -N3.\n%worlds (random_nat) (max _ _ _).\n</twelf>\n\nIf we attempt to verify the totality assertion for <tt>max</tt> in these worlds, Twelf reports an error: <tt>max</tt> is not defined in the \"natural numbers\" arising from LF variables in the context.\n\n<twelf import=\"badnews\" check=decl>\n%total T (max T _ _).\n</twelf>\n\n== World checking ==\n\nUp until this point, we have focused on the role of a <tt>%worlds</tt> declaration has in specifying a totality assertion.  However, just as <tt>%mode</tt> both specifies the mode of a totality assertion and mode-checks a type family, <tt>%worlds</tt> both specifies the world of a totality assertion and ''world checks'' a type family.  \n\nWhat property does a world declaration specify?  Intuitively, a world declaration for a type family circumscribes the contexts in which we consider inhabitants of that type family.  For example, the world declaration for <tt>max</tt> says that we should only ever consider terms of type <tt>max</tt> in the empty LF context.\nThus, it is a world error if some piece of Twelf code introduces a variable relevant to <tt>max</tt>.  World checking ensures that we only consider a term in the contexts declared for its type.\n\nWhen Twelf processes a <tt>%worlds</tt> declaration, it world checks each constant in the type family. A constant ''world checks'' under the following condition: whenever the ambient LF context is of the form specified by the world declaration, each premise of the constant occurs in an LF context that is within the world specified for the premise's type family. \n\n=== Example world violation ===\n\nFor example, consider the following signature for the lambda-calculus:\n<twelf import=\"maxtotal\" export=\"height\">\nexp : type.\nlam : (exp -> exp) -> exp.\napp : exp -> exp -> exp.\n</twelf>\n\nWe define a height relation on open lambda-terms as a [[hypothetical judgement]]; note that the height rule for variables is represented as an LF assumption:\n<twelf import=\"height\">\nheight : exp -> nat -> type.\n\nheight/lam : height (lam ([x] E x)) (s N)\n              <- {x: exp} height x (s z) -> height (E x) N. \nheight/app : height (app E1 E2) (s N)\n              <- height E1 N1\n              <- height E2 N2 \n              <- max N1 N2 N.\n</twelf>\n\nIf we try to declare <tt>height</tt> to be defined in the closed world, as we did for <tt>max</tt>, Twelf will fail with a <tt>World violation</tt> [[error messages|error message]]:\n\n<twelf import=\"height\" discard=true check=decl>\n%worlds () (height _ _).\n</twelf>\n\nThis is because <tt>height/lam</tt> adds variables to the LF context, so saying that the context should always be empty is wrong!  Additionally, this world declaration is incorrect for another reason: the adequacy argument for <tt>exp</tt> says LF terms in contexts including variables of type <tt>tm</tt> adequately represent open object language terms; so if we wish <tt>height</tt> to represent a judgement on open terms, it must be declared in a world including such variables.  Declaring <tt>height</tt> as above, even if it succeeded, would not capture the idea we have in mind that <tt>height</tt> is a relation on open terms.  \n\n=== Example world success ===\n\nThe correct world for this type family consists of blocks of the form defined in the following <tt>[[%block]]</tt> declaration called <tt>var-height</tt>.  These blocks specify that whenever a new variable with type <tt>exp</tt> is added to the context, it is added along with a derivation of <tt>height x (s z)</tt>. The type family <tt>height</tt> adequately represents the notion of height that we have in mind in this world.  Moreover, it also world-checks in this world:\n\n<twelf import=\"height\" check=true>\n%block var-height : block {x: exp}{_: height x (s z)}.\n\n%mode height +E -N.\n%worlds (var-height) (height _ _).\n</twelf>\n\nIndeed, the type family is total in this world as well:\n<twelf import=\"height\" check=decl>\n%total T (height T _).\n</twelf>\n\n=== Subordination and world subsumption ===\n\nIt should be interesting that <tt>max</tt> can be called by <tt>height</tt>, even though <tt>height</tt> is defined for non-empty LF contexts.  Technically, these contexts are not in the world for <tt>max</tt>, so the call to <tt>max</tt> from <tt>height</tt> would seem to be a world violation.  However, Twelf knows, by keeping track of the [[subordination]] relation, that any <tt>var-height</tt> blocks can never change the [[canonical forms]] of <tt>nat</tt> or <tt>max</tt>. The [[Twelf server]] will print out the current subordination relation if you type in <tt>Print.subord</tt>. For the example above, this is the subordination relation:\n\n<code>%% OK %%\nPrint.subord\nnat #> nat \nmax #> max nat \nexp #> exp \nheight #> height exp max nat \n%% OK %%</code>\n\nThe line <tt>max #> max nat</tt> means that the canonical forms (i.e. the possible derivations) of <tt>max</tt> will not change unless the definitions of <tt>max</tt> or <tt>nat</tt> are changed. Because the block <tt>var-height</tt> does not add any declarations that are subordinate to either of these types, it is permissible to call <tt>max</tt> from within an LF context that includes blocks of the form <tt>var-height</tt>.\nThis is an instance of what is called [[world subsumption]], which is the criterion under which a type family in one world can be called from a type family in another.\n\n== See also ==\n\n* <tt>[[%block]]</tt>\n* [[Totality assertion]]\n* {{guide|chapter=9|section=53|title=Regular Worlds}}\n* The case study [[Church-Rosser via complete development]] uses regular worlds heavily.\n\n{{keyword|key=worlds}}"
          },
          "sha1": "7mje4ca8j6ff23unpbgmktdc3ot982w"
        }
      },
      {
        "title": "Abbrev declaration",
        "ns": 0,
        "id": 1869,
        "revision": {
          "id": 6909,
          "parentid": 6903,
          "timestamp": "2013-05-13T15:28:27Z",
          "contributor": {
            "ip": "213.219.147.134"
          },
          "comment": "Undo revision 6903 by [[Special:Contributions/Wniiimperial|Wniiimperial]] ([[User talk:Wniiimperial|talk]])",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 1097,
            "#text": "The '''<tt>%abbrev</tt>''' keyword can be placed before any [[definition]] in a Twelf [[signature]] to cause the definition to, in the future, act as syntatic shorthand for some other term.\n\n== Example ==\n\nSay, for some reason, we had extremely verbose names for the syntax of the [[natural numbers]].\n\n<twelf>\nthis-is-a-long-name-for-nat : type.\nthis-is-a-long-name-for-z : this-is-a-long-name-for-nat.\nthis-is-a-long-name-for-s : this-is-a-long-name-for-nat -> this-is-a-long-name-for-nat.\n</twelf>\n\nWe can define <tt>nat</tt> and <tt>z</tt> from their long names using <tt>%abbrev</tt>, and <tt>s</tt> without <tt>%abbrev</tt>.\n\n<twelf>\n%abbrev nat = this-is-a-long-name-for-nat.\n%abbrev z   = this-is-a-long-name-for-z.\ns   = this-is-a-long-name-for-s.\n</twelf>\n\nWe can see the difference here - while definitions like <tt>s</tt> will be expanded only if they have to be, definitions made with the <tt>%abbrev</tt> keyword are always expanded by Twelf.\n\n<twelf check=decl>\nthree = s (s (s z)).\n</twelf>\n\n== See also ==\n\n* {{guide|title=Definitions|chapter=3|section=10}}\n{{keyword|key=abbrev}}"
          },
          "sha1": "biu1xnuhvbjfvgng6mxc7f22fu32lgk"
        }
      },
      {
        "title": "About The Twelf Project",
        "ns": 0,
        "id": 1380,
        "revision": {
          "id": 7964,
          "parentid": 7963,
          "timestamp": "2013-09-27T22:55:21Z",
          "contributor": {
            "ip": "74.108.218.198"
          },
          "comment": "Undo revision 7963 by [[Special:Contributions/Bodywell|Bodywell]] ([[User talk:Bodywell|talk]])",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 1400,
            "#text": "Twelf is a research project concerned with the design, implementation, and application of logical frameworks funded by the National Science Foundation under grants CCR-9619584 and CCR-9988281 Meta-Logical Frameworks, CCR-0306313 Efficient Logical Frameworks (Principal Investigator: Frank Pfenning) and by DARPA under the contract number F196268-95-C-0050 The Fox Project: Advanced Languages for Systems Software (Principal Investigators: Robert Harper, Peter Lee, and Frank Pfenning).\n\nThe Twelf implementation comprises\n\n*the LF logical framework, including type reconstruction;\n*the Elf constraint logic programming language;\n*an inductive meta-theorem prover for LF (very preliminary);\n*and an Emacs interface.\n\nThe principal authors of Twelf are\n\n*[http://www.cs.cmu.edu/~fp/ Frank Pfenning], and\n*[http://www.itu.dk/people/carsten/ Carsten Schürmann]\n\nwith major contrubtions by\n\n*[http://www.cs.mcgill.ca/~bpientka/ Brigitte Pientka],\n* Roberto Virga, and\n*[http://www.cs.cmu.edu/~kw/ Kevin Watkins]\n\nTwelf provides a uniform meta-language for specifying, implementing, and proving properties of programming languages and logics. Example suites include Cartesian Closed Categories and lambda-calculus, the Church-Rosser theorem for the untyped lambda-calculus, Mini-ML including type preservation and compilation, cut elimination, theory of logic programming, and Hilbert's deduction theorem."
          },
          "sha1": "9f4dmys6argjzui6e2rhbmijzwjptyl"
        }
      },
      {
        "title": "Abstract syntax",
        "ns": 0,
        "id": 1954,
        "revision": {
          "id": 5119,
          "parentid": 4465,
          "timestamp": "2008-03-23T17:49:28Z",
          "contributor": {
            "username": "William Lovas",
            "id": 11
          },
          "minor": null,
          "comment": "missing 6 /* Example */",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 995,
            "#text": "The '''abstract syntax''' of a programming language is an unambiguous representation of the syntax of a language; most compilers and most language definitions work in terms of the abstract syntax of a language as opposed to the '''concrete syntax''' of a language, which is what the programmer actually writes down. Twelf can encode the abstract syntax of a language, and can furthermore gracefully encode the idea of ''binding'' by using [[higher-order abstract syntax]].\n\n== Example == \n\nThe concrete syntax of a simple language might look like this:\n\n<code>if 1 = 2 then 1 + if true then 3 else 6 else 6</code>\n\nand the abstract syntax in a language like ML might look like this:\n\n<code>If(Eq(Num(1),Num(2)),\n   Plus(Num(1),If(True,Num(3),Num(6))),\n   Num(6))</code> \n\nand the same abstract syntax in a language like Twelf might look like this:\n\n<code>(if (eq (num 1) (num 2)) \n    (plus (num 1) (if true (num 3) (num 6)))\n    (num 6))</code>\n\n== See also ==\n\n[[Higher-order abstract syntax]]"
          },
          "sha1": "hl4e0rvyag4uecr00ca9rp54bnydneq"
        }
      },
      {
        "title": "Ad hoc binding structures",
        "ns": 0,
        "id": 2015,
        "revision": {
          "id": 6910,
          "parentid": 6904,
          "timestamp": "2013-05-13T15:28:40Z",
          "contributor": {
            "ip": "213.219.147.134"
          },
          "comment": "Undo revision 6904 by [[Special:Contributions/Wniiimperial|Wniiimperial]] ([[User talk:Wniiimperial|talk]])",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 739,
            "#text": "Many of the Twelf [[tutorials]] and [[case studies]] use very simple binding structures (e.g. lambdas that take a single argument). However, calculi and programming languages of interest often have more complex binding structures. '''Ad hoc binding structures''' such as pattern matching and mutual recursion can be encoded quite naturally in LF. Here are some examples:\n\n* [[Pattern matching]]: A case study on pattern matching with disjunctive patterns.\n* [[letrec]]: A case study on letrec (let binding a bundle of mutually recursive expressions). \n\nNOTE: There is actually a lot of overlap between the two examples, in terms of special machinery to do the \"real-world binding structures\". The two case studies could easily be combined."
          },
          "sha1": "clhd3k8lo1gk2vhfh2i6ga5z2zwlb66"
        }
      },
      {
        "title": "Adequacy",
        "ns": 0,
        "id": 1948,
        "revision": {
          "id": 4471,
          "parentid": 4447,
          "timestamp": "2007-03-20T21:20:24Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 1246,
            "#text": "Twelf is based on the logical framework [[LF]]. When we write down a logical system (an [[object logic]] such as a programming language) in Twelf, we are defining the objects and judgments of our language as LF types and terms. \nThe correctness criterion for such a representation is called '''adequacy'''.  An LF representation is '''adequate''' iff it is isomorphic to the original description of the object logic. Specifically, we require a ''compositional bijection'' between the original description and the LF representations, which means that:\n\n# There is a bijection between object language entities and LF objects of a particular type (the \"bijection\" part).\n# For representations that use  [[higher-order abstract syntax]] and [[higher-order judgment]]s, LF's notion of substitution correctly models object-language substitution (the \"compositional\" part). \n\nSee the introductory article [[Proving metatheorems with Twelf]], as well as Harper and Licata's paper <ref>{{bibtex:hl07mechanizing}}</ref>, for example adequacy statements and proofs.\n\n== References ==\n\n<references/>\n\n* [[Proving metatheorems with Twelf]]\n* [http://www-2.cs.cmu.edu/~rwh/papers/how/believe-twelf.pdf How to Believe a Twelf Proof]\n{{bibtex:hhp93lf}}\n\n{{stub}}"
          },
          "sha1": "tuxo8eq0xkfxsdzguwj1gs146l2w6cu"
        }
      },
      {
        "title": "Adequate",
        "ns": 0,
        "id": 1949,
        "redirect": {
          "@title": "Adequacy",
          "#text": null
        },
        "revision": {
          "id": 4448,
          "timestamp": "2007-03-20T20:29:51Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "[[Adequate]] moved to [[Adequacy]]: Noun",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 22,
            "#text": "#REDIRECT [[Adequacy]]"
          },
          "sha1": "1n2otja0eq1vjca07w7qb5y316iz8fy"
        }
      },
      {
        "title": "Admissibility of cut",
        "ns": 0,
        "id": 1762,
        "revision": {
          "id": 5910,
          "parentid": 5060,
          "timestamp": "2009-02-24T21:55:19Z",
          "contributor": {
            "ip": "128.2.223.28"
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 14334,
            "#text": "The '''admissibility of cut''' (also called '''cut elimination''') is one of the most important metatheorems of an [[object logic]] sequent calculus. It is the key theorem for showing the equivalence of natural deduction and the cut-free sequent calculus, which has several corollaries, including the existence of normal forms for every natural deduction term, and the consistency of the logic. This [[tutorials|tutorial]] shows how to prove admissibility of cut for a simple intuitionistic sequent calculus in Twelf. We will make use of lexicographic orderings in the [[%terminates|termination]] argument. <!-- and other tricks? -->\n\n== Cut ==\n\nFor a sequent calculus Γ {{darrow}} C, where Γ holds hypotheses and the proposition C is the conclusion, the statement of cut is as follows: If Γ {{darrow}} A and Γ,A {{darrow}} C then Γ {{darrow}} C.\n\nOften, logicians will include cut in the sequent calculus as a rule:\n\n<math>{ { \\Gamma \\Rightarrow A \\qquad \\Gamma, A \\Rightarrow C }\\over{ \\Gamma \\Rightarrow C  } }{\\quad \\rm cut }</math>\n\nThey then prove that any proof that uses the cut rule can be transformed into a proof without cut (thus, \"cut elimination\"). In Twelf, it will be simpler to prove cut as a metatheorem (\"admissibility of cut\") over a sequent calculus with no cut rule.\n\n== Sequent calculus ==\n\nSuppose we have the following sequent calculus:\n\n<!-- nb. in this math code we use \\supset for implication -->\n<table style=\"margin-left:auto;margin-right:auto\" cellpadding=\"24\">\n<tr><td>\n<math>{ { \\qquad }\\over{ \\Gamma, C \\Rightarrow C  } }{\\quad \\rm init }</math>\n</td><td>\n<math>{ { \\qquad }\\over{\\Gamma \\Rightarrow \\top} }{\\quad \\top\\rm R}</math>\n</td></tr>\n<tr><td>\n<math>{ { \\Gamma \\Rightarrow A \\qquad \\Gamma \\Rightarrow B }\\over{ \\Gamma \\Rightarrow A \\land B  } }{\\quad \\land\\rm R  }</math>\n</td><td>\n<math>{ { \\Gamma, A \\land B, A, B \\Rightarrow C }\\over{ \\Gamma, A \\land B \\Rightarrow C  } }{\\quad \\land\\rm L  }</math>\n</td></tr>\n<tr><td>\n<math>{ { \\Gamma, A \\Rightarrow B }\\over{ \\Gamma \\Rightarrow A \\supset B  } }{\\quad \\supset\\rm R  }</math>\n</td><td>\n<math>{ { \\Gamma, A \\supset B \\Rightarrow A \\qquad \\Gamma, A \\supset B, B \\Rightarrow C}\\over{ \\Gamma, A \\supset B \\Rightarrow C  } }{\\quad \\supset\\rm L  }</math>\n</td></tr>\n</table>\n\nThe logic supports only the {{top}}, ∧, and ⊃ connectives to simplify this tutorial. In LF, we encode the sequent calculus as follows:\n\n<twelf>\n\nprop : type.    %name prop A.\ntop : prop.\nimp : prop -> prop -> prop.\nand : prop -> prop -> prop.\n\n% hypotheses\nhyp : prop -> type.\n\n% G |- C\nconc : prop -> type.\n\ninit : hyp A -> conc A.\ntopR : conc top.\nandL : (hyp A -> hyp B -> conc C) ->\n       (hyp (and A B) -> conc C).\nandR : conc A -> conc B ->\n       conc (and A B).\nimpL : conc A -> (hyp B -> conc C) ->\n       (hyp (imp A B) -> conc C).\nimpR : (hyp A -> conc B) ->\n       conc (imp A B).\n</twelf>\n\nThe sequent is represented as the judgment <tt>conc</tt>, which is hypothetical in hypotheses <tt>hyp</tt>. A rule <tt>init</tt> allows us to use a hypothesis to satisfy a conclusion.\n\n== Statement and proof of cut ==\n\n<twelf>\ncut : {A: prop} \n      {D: conc A}\n      {E: hyp A -> conc C}\n      {F: conc C}\n      type.\n%mode cut +A +D +E -F.\n</twelf>\n\nWe will refer to the input derivations as <tt>D</tt> and <tt>E</tt> throughout this tutorial and the output as <tt>F</tt>. Because we will induct on the structure of the type <tt>A</tt>, we make it an explicit argument.\n\nThere are nominally about ''n''² cases to consider in this proof; for each of the ''n'' rules that can be at the bottom of <tt>D</tt>, ''n'' rules can be used at the bottom of <tt>E</tt>. In actuality, two factors reduce the number of cases we'll make: some combinations of rules are incompatible (Twelf's excludes them via unification, so we don't even need to write them down) and some cases can be done schematically by using universal quantification.\n\n=== Initial cuts ===\n\nIf either derivation is an instance of the <tt>init</tt> rule, we are done:\n\n<twelf>\ninitD : cut A (init Ha) ([Ha] E Ha) (E Ha).\n\ninitE : cut A D ([Ha] init Ha) D.\nclosed : cut A D ([Ha] E') E'.\n</twelf>\n\nIf <tt>D</tt> is the <tt>init</tt> rule used to conclude <tt>conc A</tt> from <tt>hyp A</tt>, then Γ includes <tt>hyp A</tt> already, so we can satisfy the hypothesis in <tt>E</tt> by simply using the <tt>A</tt> that is already around (case <tt>initD</tt>).\n\nIf <tt>E</tt> is the <tt>init</tt> rule used to conclude <tt>conc C</tt> from <tt>hyp A</tt> (so <tt>A</tt> = <tt>C</tt>), then <tt>D</tt> is a proof of Γ {{darrow}} C, so <tt>F</tt> is just <tt>D</tt> (case <tt>initE</tt>).\n\nIt's also possible that <tt>E</tt> is the <tt>init</tt> rule used to conclude <tt>conc C</tt> from some other hypothesis <tt>C</tt> in Γ. In this case, <tt>E</tt> doesn't use the hypothesis <tt>A</tt> at all, so <tt>E</tt> can be strengthened to produce the output derivation <tt>F</tt> which doesn't depend on <tt>A</tt>. In fact, we can easily generalize this case to any derivation <tt>E</tt> that does not use the hypothesis <tt>A</tt>; this is the <tt>closed</tt> case. (When we write <tt>([Ha] E')</tt>, the variable <tt>E'</tt>&mdash;which is implicitly quantified at the outside of the goal&mdash;cannot depend on the lambda-bound variable <tt>Ha</tt>. This is how we indicate the derivation is closed with respect to its argument.)\n\n=== Principal cuts ===\n\nThe most interesting cases are those where the cut formula <tt>A</tt> is concluded with a right rule in <tt>D</tt>, and used with a left rule in <tt>E</tt>. These are known as ''principal cuts''.\n\nThere is no principal cut for {{top}} because there is no left rule, so the easiest one will be <tt>A ∧ B</tt>:\n<twelf>\nandC : cut (and A B) (andR D1 D2) ([Hab : hyp (and A B)] andL ([Ha : hyp A] [Hb : hyp B] E' Hab Ha Hb) Hab) F\n    <- ({Ha} {Hb} cut (and A B) (andR D1 D2) ([Hab] E' Hab Ha Hb) (F1 Ha Hb))\n    <- ({Hb} cut A D1 ([Ha] F1 Ha Hb) (F2 Hb))\n    <- cut B D2 ([Hb] F2 Hb) F.\n</twelf>\n\nWe identify the case where <tt>D</tt> is an instance of <tt>andR</tt>, and <tt>E</tt> is <tt>andL</tt> acting on the hypothesis of the cut formula. (The hypothetical derivation <tt>E</tt> is represented as a LF function taking the hypothesis <tt>A ∧ B</tt>; we identify the case where this specific hypothesis is used by <tt>andL</tt> by passing that bound variable (<tt>Hab</tt>) to the <tt>andL</tt> constant.) We have a subderivation <tt>E'</tt> of  <tt>conc C</tt> under hypotheses <tt>hyp (and A B)</tt>, <tt>hyp A</tt>, and <tt>hyp B</tt>. We must eliminate each of these to produce <tt>F</tt>. In the first subgoal we eliminate the <tt>and A B</tt> hypothesis. <tt>D</tt> itself is a derivation of <tt>conc (and A B)</tt> in Γ, so we want to appeal to the IH on <tt>D</tt> and <tt>E'</tt>. There are a few things to notice. First, we did not name <tt>D</tt> (indeed there is no way to do so) because we pattern matched against it as an application of <tt>andR</tt>; therefore, in the inductive call we have to build up <tt>D</tt> again as <tt>andR D1 D2</tt>. Second, <tt>E'</tt> is not of the correct type for the inductive call, because it is a curried function of three arguments, not one. We therefore must make the subgoal higher order: we hypothesize the existence of <tt>Ha</tt> and <tt>Hb</tt> (of type <tt>hyp A</tt> and <tt>hyp B</tt> respectively). We then form the term of type <tt>hyp (and A B) -> conc C</tt> by abstracting the hypothesis we seek to eliminate (<tt>Hab</tt>) and applying <tt>E'</tt> to it and the Π-bound <tt>Ha</tt> and <tt>Hb</tt>. Because this inductive call is in a context including <tt>Ha</tt> and <tt>Hb</tt>, the resulting derivation <tt>F1</tt> depends on those two variables as well.\n\nWe then want to do the same thing to eliminate the hypotheses for <tt>A</tt> and <tt>B</tt>. In the second subgoal, we prove that for all derivations of <tt>hyp B</tt> (Π-bound variable <tt>Hb</tt>), we can cut <tt>D1</tt> with the result of the previous induction <tt>F1</tt> to get <tt>F2</tt>, which only depends on <tt>Hb</tt>. Finally, in the third subgoal we eliminate the <tt>hyp B</tt> hypothesis to produce a derivation of <tt>conc C</tt> in the ambient Γ with no extra assumptions, which is what we need for <tt>F</tt>.\n\nWe must pay close attention to the induction order. The first inductive call is well-founded because it is on a subderivation <tt>E'</tt>. The output derivation <tt>F1</tt> may be larger, however, and it is used as an input to the second inductive call. Observe, however, that the cut formula <tt>A</tt> is a subderivation of the original cut formula <tt>and A B</tt>. Ultimately, our induction order will be lexicographic. Either <tt>D</tt> or <tt>E</tt> will get smaller (with the other staying the same size), or they both may get larger but <tt>A</tt> will get smaller. We will specify this induction measure in the [[%total]] declaration when we check the [[metatheorem]] below.\n\n<twelf>\nimpC : cut (imp A B) (impR ([Ha] D' Ha))\n           ([Hab] impL (E1 Hab : conc A) ([Hb] E2 Hab Hb : conc C) Hab)\n           F\n    <- cut (imp A B) (impR D') E1 (F1 : conc A)\n    <- ({Hb:hyp B} cut (imp A B) (impR D') ([Hab] E2 Hab Hb) (F2 Hb : conc C))\n    <- cut A F1 D' (F3 : conc B)\n    <- cut B F3 F2 F.\n</twelf>\n\nThe <tt>impC</tt> case works in much the same way. We first cut the <tt>A ⊃ B</tt> hypothesis from both subderivations <tt>E1</tt> and <tt>E2</tt>. We then have <tt>F1 : conc A</tt> and <tt>F2 : hyp B -> conc C</tt>. To get <tt>F3 : conc B</tt> we cut the <tt>hyp A</tt> from <tt>D' : hyp A -> conc B</tt> using <tt>F1</tt> (note that in this inductive call, derivations from the \"<tt>D</tt> side\" and \"<tt>E</tt> side\" have switched roles!). Finally, we cut the <tt>hyp B</tt> from <tt>F2</tt> to get the result <tt>F</tt>.\n\n=== Left-commutative cuts ===\n\nThe remainder of the cases are ''commutative'' cases where we search for initial and principal cuts to apply. The first set are the ''left commutative''  cases, where the rule used to derive <tt>D</tt> is a left rule.\n\n<twelf>\nandLLC : cut A (andL ([Ha][Hb] D' Ha Hb) Hab) E \n               (andL ([Ha][Hb] F' Ha Hb) Hab)\n      <- ({Ha}{Hb} cut A (D' Ha Hb) E (F' Ha Hb)).\n\nimpLLC : cut A (impL D1 ([Hb] D2 Hb) Hi) E\n               (impL D1 F2 Hi)\n      <- ({Hb} cut A (D2 Hb) E (F2 Hb)).\n</twelf>\n\nIn the <tt>andLLC</tt>, <tt>D : conc A</tt> is an instance of <tt>andL</tt>. We proceed by hypothesizing the <tt>Ha : hyp A1</tt> and <tt>Hb : hyp B1</tt> that <tt>D' : hyp A1 -> hyp B1 -> conc A</tt> depends on, so that we may cut it against <tt>E</tt>. The resulting derivation <tt>F'</tt> then also depends on a <tt>hyp A1</tt> and <tt>hyp B1</tt>; we wrap it with an instance of the <tt>andL</tt> rule. In these commutative cases, we find rules that do not involve the cut formula, work underneath them inductively, and then re-apply the rule to the cut-free proof we obtained. The <tt>impLLC</tt> case follows the same pattern.\n\n=== Right-commutative cuts ===\n\nThe ''right commutative'' cuts are those where the rule at the bottom of <tt>E</tt> is not a left rule acting on the cut formula. The first two cases are where <tt>E</tt> is a right rule:\n\n<twelf>\nandRRC : cut A D ([Ha] andR (E1 Ha) (E2 Ha)) (andR F1 F2)\n      <- cut A D E1 F1\n      <- cut A D E2 F2.\n\nimpRRC : cut A D ([Ha] impR ([H1] E1 Ha H1)) (impR ([H1] F1 H1))\n      <- ({H1} cut A D ([Ha] E1 Ha H1) (F1 H1)).\n</twelf>\n\nIn the <tt>andRRC</tt> case, we simply apply straightforward induction. <tt>E</tt> consists of two subderivations, <tt>E1</tt> and <tt>E2</tt>, each of which may use the cut formula <tt>A</tt>. We inductively cut out uses of <tt>A</tt>, and then rebuild the derivation with the <tt>impR</tt> rule. The <tt>impRRC</tt> rule is similar.\n\nThe final two cases are uses of the left rules, but where they act on a hypothesis different from the cut hypothesis:\n\n<twelf>\nandLRC : cut A (D : conc A) ([Ha] andL ([H1] [H2] E' Ha H1 H2) Hp)\n                            (andL ([H1][H2] F' H1 H2) Hp)\n      <- ({H1}{H2} cut A D ([Ha] E' Ha H1 H2) (F' H1 H2)).\n\nimpLRC : cut A (D : conc A) ([Ha] impL (E1 Ha) ([Hb] E2 Ha Hb) Hi)\n                            (impL F1 ([Hb] F2 Hb) Hi)\n      <- cut A D ([Ha] E1 Ha) F1\n      <- ({Hb} cut A D ([Ha] E2 Ha Hb) (F2 Hb)).\n</twelf>\n\nThe <tt>andLRC</tt> case is similar to the principal cut case <tt>andC</tt>, but here the <tt>andL</tt> in <tt>E</tt> acts on some hypothesis <tt>Hp : and A1 B1</tt> instead of the cut hypothesis <tt>Ha : hyp A</tt>. To proceed, we simply eliminate uses of <tt>Ha</tt> within E' inductively, and then reapply the <tt>andL</tt> rule to the resulting derivation. We follow a similar pattern for the <tt>impLRC</tt> case.\n\n== The metatheorem ==\n\nWe can now state and check the metatheorem: that for every [[ground]] arguments <tt>A</tt>, <tt>D</tt> and <tt>E</tt> to the <tt>cut</tt> relation, there exists a derivation <tt>F</tt> that concludes <tt>C</tt> without using the hypothesis <tt>A</tt>. Our [[%worlds]] declaration for cut is only that hypotheses may appear in the context:\n\n<twelf>\n%block hyp : some {A : prop} block {H : hyp A}.\n%worlds (hyp) (cut _ _ _ _).\n</twelf>\n\nWe check the totality of <tt>cut</tt> using a lexicographic induction order, as discussed above. We write <tt>{A [D E]}</tt> to mean that either the cut formula <tt>A</tt> gets smaller, or it stays the same size and one of <tt>D</tt> or <tt>E</tt> gets smaller with the other staying the same size.\n\n<twelf>\n%total {A [D E]} (cut A D E F).\n</twelf>\n\n\n\nWe proved the admissibility of cut for a small sequent calculus with only a few connectives. Experience shows that this same strategy works for more complex logics. For instance, the case study on [[Classical S5]] includes a cut theorem for a classical modal logic. It also formalizes the translations between natural deduction and the sequent calculus.\n\n<twelflink>All code from this tutorial</twelflink>. <twelflink check=\"true\">Twelf's output from this tutorial</twelflink>.\n\n\n== See also ==\n\n* [[Lax logic]] - Cut elimination for a polarized variant of the Pfenning-Davies reconstruction of lax logic\n* [[Tethered modal logic]] - Cut elimination for the Pfenning-Davies reconstruction of Modal S4\n* [[Weak focusing]] - Cut elimination for a focused sequent calculus (lacks commentary)\n\n{{case study}}[[Category:Twelf code]]"
          },
          "sha1": "lqm58z0pxuy09o10xquuk9a10wx4eul"
        }
      },
      {
        "title": "Alpha-equivalence",
        "ns": 0,
        "id": 1927,
        "revision": {
          "id": 6235,
          "parentid": 4333,
          "timestamp": "2011-03-16T02:47:52Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 901,
            "#text": "Alpha-equivalence is a notion of equivalence on terms with binding structure.  It captures the notion that the names of bound variables are unimportant; all that matters is the binding structure they induce.\n\nConsider the untyped lambda-calculus.\n\n<math>e ::= x \\mid \\lambda x.\\, e \\mid e_1\\ e_2</math>\n\nAlpha-equivalence for terms <math>\\texttt{}e</math> is the least [[congruence relation]] <math>\\texttt{}e_1 =_\\alpha e_2</math> closed under the <math>\\texttt{}\\alpha</math> axiom:\n\n<math>{(y \\not = x \\,and\\, y \\not\\in \\mathit{FV}(e)) \\over \\lambda x.\\, e =_\\alpha \\lambda y.\\,  [y/x]e}\\alpha</math>\n\nAlpha-equivalence generalizes in a straightforward manner to any term language with binding structure.\n\nTwelf's notion of term equality respects alpha-equivalence; when an object-language is represented using [[higher-order abstract syntax]], the representation enjoys alpha-equivalence for free."
          },
          "sha1": "pveinq9ghxv5h35ixardp4v63jpjnv8"
        }
      },
      {
        "title": "Ambiguous hyperkind",
        "ns": 0,
        "id": 1776,
        "revision": {
          "id": 3193,
          "parentid": 3192,
          "timestamp": "2006-10-26T18:59:13Z",
          "contributor": {
            "ip": "128.2.223.28"
          },
          "comment": "a twelf error message I've never gotten!",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 126,
            "#text": "An '''ambiguous hyperkind''' occurs in pathological cases like this:\n\n<twelf check=\"decl\">\n\na : type.\n\nb = a : _ _ .\n\n</twelf>"
          },
          "sha1": "5iuk5iiygbk4pp4qtf9qcdf51irejq9"
        }
      },
      {
        "title": "Ask Twelf Elf",
        "ns": 0,
        "id": 1708,
        "revision": {
          "id": 6518,
          "parentid": 5716,
          "timestamp": "2012-03-09T15:48:22Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 2091,
            "#text": "If you have a question about Twelf, you can [http://twelf.org/w/index.php?title=Talk:Ask_Twelf_Elf&action=edit&section=new leave a message] on this wiki! \nIf you have a question that you do not want to ask publicly, you can [mailto:twelfelf@gmail.com Ask Twelf Elf] by email.  You should get a reply within 48 hours. Probably sooner. If your question involves diagnosing a particular piece of code, it is very helpful if you can send in enough code that we can re-produce the issue on our own machines.\n\nAt any given time, the spirit of Twelf Elf possesses the body of someone knowledgeable with Twelf. Twelf Elf regularly rotates who he possesses, in order to avoid exhausting the poor person. Twelf Elf reserves the right to re-work interesting replies into content for the Wiki. E-mail the Twelf Elf or post a message on the [[Talk:Ask Twelf Elf|talk]] for this page if you would like to volunteer to join the Twelf Elf rotation.\n\n== Interesting responses ==\n\n<!-- make a tutorial or case study or glossary entry if the question has wide applicability; otherwise put it here -->\n\nSome responses to questions turn into other forms of [[documentation]]; the rest are collected here.\n\n* [[Ask Twelf Elf:Short answers|Short Answers]] - collected answers that have not (yet) been turned into their own pages.\n\n* [[Manipulating proof witnesses]] - running a <tt>[[%solve]]</tt> creates a proof object if it is successful. But what if you want to manipulate such proof objects within the context of a single <tt>%solve</tt>? The cost of the ability to do this is writing a bunch of [[effectiveness lemmas]] - in this case, if you were working with relations which were not total functions, they could be called ''effectiveness relations.''\n\n* [[Concrete representations]] - [[higher-order abstract syntax]] is a convenient way to approach languages with binding, but it is possible to imagine a problem where manipulating a fully concrete object without binding is simpler. In these cases, it is possible to establish a bijection between your HOAS terms and de Bruijn versions of the same terms."
          },
          "sha1": "n176wl273rmegyk7tkrrgx693edrxsn"
        }
      },
      {
        "title": "Ask Twelf Elf:Short Answers",
        "ns": 0,
        "id": 1985,
        "redirect": {
          "@title": "Ask Twelf Elf:Short answers",
          "#text": null
        },
        "revision": {
          "id": 4682,
          "timestamp": "2007-04-08T21:07:23Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "comment": "[[Ask Twelf Elf:Short Answers]] moved to [[Ask Twelf Elf:Short answers]]: proper nouns confused my capitalization",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 41,
            "#text": "#REDIRECT [[Ask Twelf Elf:Short answers]]"
          },
          "sha1": "m0p7ie2oxngwoodx4dsxbclbprhouqh"
        }
      },
      {
        "title": "Ask Twelf Elf:Short answers",
        "ns": 0,
        "id": 1984,
        "revision": {
          "id": 4807,
          "parentid": 4796,
          "timestamp": "2007-09-26T12:29:45Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "rv vandal",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 6114,
            "#text": "This page collects short answers to [[Talk:Ask Twelf Elf|questions]] people asked.  These answers have not (yet) been made into their own pages, but feel free to fork a page off if you want to give a more thorough answer to a question.\n\n== Comparing Coq and Twelf ==\n\nMichael Fortson asks: ''I can't find any papers comparing Coq and Twelf.  Can someone summarize the differences?''\n\nThis is a hard question to answer in any comprehensive manner, since there are lots of differences, in theory and in practice, between the two systems.  However, here's a slapdash list of bullet-points to keep in mind as you think about the two, tailored to representing and proving theorems about programming languages, and quite biased towards talking about LF and Twelf because that's what I know the most about.  There are\n\n'''Differences in how you represent languages:''' \n* In LF, you represent your language as the canonical forms of particular LF types; the representation is not an inductive definition inside the LF type theory.  This representation strategy enables [[higher-order abstract syntax]] and [[higher-order judgements]], which are very useful ways of dealing with programming languages and logics that involve binding.  LF has a theory of [[adequacy]], which tells you when a representation is correct.\n* In Coq, you represent your language's syntax and judgements as inductively defined types and propositions.  The techniques for dealing with binding are different because you can't use HOAS and HOJ in the same manner as you do in LF.  Also, I don't know of a formal theory of adequacy for Coq, but I haven't looked very hard for one.\n\n'''Differences in what constitutes a proof of a metatheorem:'''\n* When using Twelf's [[metatheorem]] features, a proof of a metatheorem consists of an LF type family that Twelf proves [[%total|total]] (this can be confusing at first; start with [[Proving metatheorems:Proving totality assertions about the natural numbers|this section of the intro]] for details).  Thus, we don't prove metatheorems in LF, we prove metatheorems about LF using extra features in Twelf.  \n\n* In contrast, metatheorems in Coq are (more or less) just terms in the Calculus of Inductive Constructions (CiC), which is the same type theory you use for representing languages; there is no separate language for metatheorems.  \n\n'''Differences in how you write proofs:'''\n*  In Twelf, you write a proof of a metatheorem directly by exhibiting the cases as constants inhabiting an LF type family.  The computational context of the proof is explicit, because this type family can be run as a logic program.  \n\n* The Coq proofs that I've seen consist mostly of tactical proof scripts that instruct Coq how to find the proof term that you're trying to create.  \n\n'''Differences in what's provable (in theory):'''  Twelf's metatheorem apparatus only checks proofs of {{forall}}{{exists}}-statements, so there are some theorems you can't use it to check.\n\n'''Differences in what's provable (in practice):'''  Of course, the theoretical limits don't tell you much about what people are actually able to do in their day-to-day work.  See the page of [[Research projects using Twelf]] for some examples on the Twelf side of things; there are lots of Coq examples on the Web as well.  \n\n'''Differences in foundations:'''  LF is a very simple type theory, whereas the CiC (which is something like what Coq implements, but I'm not exactly sure) is a richer type theory.  For proofs of metatheorems, the fair comparison is between LF with Twelf's metatheorem features and CiC with whatever additions Coq implements, and there I'm not sure which is simpler.\n\nThis is not intended to be a fair or comprehensive answer to your question, but it's something to think about.  Others might have opinions to add as well.  \n\nAlso, you should read the Appel and Leroy list machine benchmark paper that's linked from the [[documentation]] page. It compares Twelf and Coq on a simple example (note that the example doesn't use [[higher-order abstract syntax]] or [[higher-order judgements]], so it's not even a case where Twelf really shines).   \n[[User:Drl|Drl]] 16:40, 8 April 2007 (EDT)\n\n== Different ways of using Twelf ==\n\nMichael Fortson asks: ''Can you explain the vast difference in style between the examples shown on this site and what is done by Andrew Appel at Princeton?  The two styles seem as if they are two completely different languages!''\n\nFrom my understanding of the Princeton project and Appel's notes, there's a sense in which they are two different languages.  On the wiki, we give various examples of representing languages and logics as an LF signature (see, e.g., [[Proving metatheorems:Representing the judgements of the natural numbers|this section of the intro article]]) and then proving metatheorems about them using Twelf's [[metatheorem]] features such as [[%mode]], [[%worlds]], and [[%total]]  (see, e.g., [[Proving metatheorems:Proving totality assertions about the natural numbers|this section of the intro article]]).\n\nHowever, there are ways of using Twelf that don't use the metatheorem features at all.  In this style, you encode a particular logic in LF and then reason entirely '''within''' that logic.  In particular, you prove theorems in that logic by writing LF terms of the appropriate types, which correspond to derivations constructed according to the rules of the logic.  In this setting, Twelf is used as:\n* a type checker for LF, which serves a a proof checker for the encoded logic, and\n* a logic programming language that can be used to search for proofs in the encoded logic.\n\nI don't have much experience using Twelf in this style; others (e.g., [[User:Rsimmons|Rob]]) can say more.  Someone should write an article about why you might want to reason within your own logic encoded in LF instead of using the metatheorem features.  However, I recommend that beginners start by learning how to use Twelf's metatheorem features, since they provide a very useful logic for reasoning about programming languages and logics. [[User:Drl|Drl]] 15:28, 8 April 2007 (EDT)"
          },
          "sha1": "ijnuvaelvly2uq6st0cr180xtg330jx"
        }
      },
      {
        "title": "Auto-freezing",
        "ns": 0,
        "id": 1963,
        "redirect": {
          "@title": "%freeze",
          "#text": null
        },
        "revision": {
          "id": 4492,
          "timestamp": "2007-03-20T22:12:58Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "comment": "Redirecting to [[%freeze]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 21,
            "#text": "#REDIRECT [[%freeze]]"
          },
          "sha1": "865e3pbjqyv9fu4qm2j34zk62ncx4qi"
        }
      },
      {
        "title": "Autofreeze",
        "ns": 0,
        "id": 2008,
        "redirect": {
          "@title": "%freeze",
          "#text": null
        },
        "revision": {
          "id": 4875,
          "parentid": 4874,
          "timestamp": "2007-10-03T21:36:35Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "Redirecting to [[%freeze#Autofreeze]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 31,
            "#text": "#REDIRECT[[%freeze#Autofreeze]]"
          },
          "sha1": "0rpsshsxv67tlu2mom6xd60l5u83xuh"
        }
      },
      {
        "title": "Beta-equivalence",
        "ns": 0,
        "id": 1932,
        "revision": {
          "id": 4414,
          "parentid": 4375,
          "timestamp": "2007-03-20T14:19:35Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "comment": "doesn't exist, but target should be singular, alternate name",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 1291,
            "#text": "'''Beta-equivalence''' (β-equivalence) is a notion of proof equivalence in natural deduction logics with introduction and elimination forms.  Roughly, it says that when an elimination form is applied to an introduction form, they cancel.\n\nConsider the simply-typed lambda-calculus with arrow types.\n\n<math>A ::= a \\mid A_1 \\rightarrow A_2</math>\n\n<math>e ::= x \\mid \\lambda x{:}A.\\, e \\mid e_1\\ e_2</math>\n\nThe beta-equivalence induced by the arrow type <math>A \\rightarrow B</math> says that the elimination form <math>e_1\\ e_2</math> \"cancels\" the introduction form <math>\\lambda x{:}A.\\, e</math>; formally, it is the least [[congruence relation]] <math>\\texttt{}e_1 =_\\beta e_2</math> closed under the <math>\\texttt{}\\beta</math> axiom:\n\n<math>{\\; \\over (\\lambda x{:}A.\\, e_1)\\ e_2 =_\\beta [e_2/x] e_1} \\beta</math>\n\nBeta-equivalence is usually oriented to the right yielding a notion of ''beta-reduction''.  For example:\n\n<math>(\\lambda x{:}A.\\, e_1)\\ e_2 \\Longrightarrow_\\beta [e_2/x] e_1</math>\n\nThe term on the left-hand side of the <math>\\texttt{}\\beta</math> axiom is called a ''beta-redex'', and the term on the right-hand side is its ''beta-reduct''.  A term with no beta-redexes is called ''beta-normal''.  Being beta-normal is one aspect of being [[canonical form|canonical]]."
          },
          "sha1": "ai31fqufpxveptdp75gg2dlariqfga0"
        }
      },
      {
        "title": "Beta-equivalent",
        "ns": 0,
        "id": 1944,
        "redirect": {
          "@title": "Beta-equivalence",
          "#text": null
        },
        "revision": {
          "id": 4419,
          "timestamp": "2007-03-20T14:21:06Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "comment": "alt name",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 30,
            "#text": "#redirect [[beta-equivalence]]"
          },
          "sha1": "1aejry983yufb6ry2rvp62qnowuyuz6"
        }
      },
      {
        "title": "Beta-normal",
        "ns": 0,
        "id": 1962,
        "redirect": {
          "@title": "Beta-equivalence",
          "#text": null
        },
        "revision": {
          "id": 4488,
          "timestamp": "2007-03-20T22:09:06Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "comment": "Redirecting to [[Beta-equivalence]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 30,
            "#text": "#REDIRECT [[beta-equivalence]]"
          },
          "sha1": "3oslru5rgknteyedz29mennf9114acm"
        }
      },
      {
        "title": "Beta-reduction",
        "ns": 0,
        "id": 1958,
        "redirect": {
          "@title": "Beta-equivalence",
          "#text": null
        },
        "revision": {
          "id": 4483,
          "timestamp": "2007-03-20T22:01:46Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "comment": "Redirecting to [[Beta-equivalence]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 30,
            "#text": "#REDIRECT [[beta-equivalence]]"
          },
          "sha1": "3oslru5rgknteyedz29mennf9114acm"
        }
      },
      {
        "title": "Beta equivalence",
        "ns": 0,
        "id": 1942,
        "redirect": {
          "@title": "Beta-equivalence",
          "#text": null
        },
        "revision": {
          "id": 4417,
          "timestamp": "2007-03-20T14:20:35Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "comment": "alt name",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 30,
            "#text": "#REDIRECT [[beta-equivalence]]"
          },
          "sha1": "3oslru5rgknteyedz29mennf9114acm"
        }
      },
      {
        "title": "Beta equivalent",
        "ns": 0,
        "id": 1943,
        "redirect": {
          "@title": "Beta-equivalence",
          "#text": null
        },
        "revision": {
          "id": 4418,
          "timestamp": "2007-03-20T14:20:51Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "comment": "alt name",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 30,
            "#text": "#REDIRECT [[beta-equivalence]]"
          },
          "sha1": "3oslru5rgknteyedz29mennf9114acm"
        }
      },
      {
        "title": "Bibliography of LF",
        "ns": 0,
        "id": 1406,
        "revision": {
          "id": 18711,
          "parentid": 18710,
          "timestamp": "2019-05-08T16:29:35Z",
          "contributor": {
            "username": "Solen",
            "id": 22444
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 26149,
            "#text": "{{needswork|The links haven't all been taken over from the [http://www.cs.cmu.edu/~twelf/elf-bib.html old page], and after that happens, they should be tested as many are dead links.}}\n\nThis is a bibliography collected by Frank Pfenning on the LF logical framework, the logic programming language Elf which is based on LF, and the Twelf meta-logical framework (which includes an implementation of Elf). It is a selection of papers from a more general bibliography on logical frameworks. Papers with known URLs in the World-Wide Web have been annotated with their location and can be previewed or retrieved directly. Corrections, additions, and new URL's for papers and implementations are welcome.\n\n== Basic References ==\n\n* For the [[LF|LF logical framework]]: R. Harper, F. Honsell, and G. Plotkin, [http://www.cs.cmu.edu/~twelf/elf-bib.html#Harper93jacm A Framework for Defining Logics].\n* For the Elf language: F. Pfenning, [http://www.cs.cmu.edu/~twelf/elf-bib.html#Pfenning91lf Logic Programming in the LF Logical Framework].\n* For the Twelf implementation: [http://www.cs.cmu.edu/~twelf/elf-bib.html#Pfenning99cade System description: Twelf - a meta-logical framework for deductive systems].\n\n== Full Bibliography ==\n\n# Penny Anderson. Program Derivation by Proof Transformation. PhD thesis, Carnegie Mellon University, October 1993. Available as Technical Report CMU-CS-93-206. [ftp://babar.inria.fr/pub/croap/anderson/thesis Available electronically].\n# Penny Anderson. Program extraction in a logical framework setting. In Frank Pfenning, editor, Proceedings of the 5th International Conference on Logic Programming and Automated Reasoning, pages 144-158, Kiev, Ukraine, July 1994. Springer-Verlag LNAI 822.\n# Penny Anderson. Representing proof transformations for program optimization. In Proceedings of the 12th International Conference on Automated Deduction, pages 575-589, Nancy, France, June 1994. Springer-Verlag LNAI 814. [ftp://babar.inria.fr/pub/croap/anderson/cade94 Available electronically].\n# Andrew W. Appel and Edward W. Felten. Proof-carrying authentication. In G. Tsudik, editor, Proceedings of the 6th Conference on Computer and Communications Security, Singapore, November 1999. ACM Press. To appear.\n# Andrew W. Appel and Amy P. Felty. Lightweight lemmas in lambda prolog. In Danny De Schreye, editor, Proceedings of the International Conference on Logic Programming (ICLP'99), Las Cruces, New Mexico, December 1999. MIT Press. To appear.\n# Andrew W. Appel and Amy P. Felty. A semantic model of types and machine instructions for proof-carrying code. Submitted, July 1999.\n# David Aspinall and Adriana Compagnoni. Subtyping dependent types. In E. Clarke, editor, Proceedings of the 11th Annual Symposium on Logic in Computer Science, pages 86-97, New Brunswick, New Jersey, July 1996. IEEE Computer Society Press.\n# Arnon Avron, Furio A. Honsell, Ian A. Mason, and Robert Pollack. Using typed lambda calculus to implement formal systems on a machine. Journal of Automated Reasoning, 9(3):309-354, 1992. A preliminary version appeared as University of Edinburgh Report ECS-LFCS-87-31.\n# Jason J. Brown. Presentations of Unification in a Logical Framework. PhD thesis, University of Oxford, January 1996.\n# Rod Burstall and Furio Honsell. Operational semantics in a natural deduction setting. In Gérard Huet and Gordon Plotkin, editors, Logical Frameworks, pages 185-214. Cambridge University Press, 1991.\n# Iliano Cervesato. A Linear Logical Framework. PhD thesis, Dipartimento di Informatica, Università di Torino, February 1996.\n# Iliano Cervesato. Proof-theoretic foundation of compilation in logic programming languages. In J. Jaffar, editor, Proceedings of the 1998 Joint International Conference and Symposium on Logic Programming (JICSLP'98), pages 115-129, Manchester, UK, June 1998. MIT Press. Available in [http://theory.stanford.edu/~iliano/papers/jicslp98.ps.gz PostScript] format.\n# Iliano Cervesato, Joshua S. Hodas, and Frank Pfenning. Efficient resource management for linear logic proof search. Theoretical Computer Science, 1997. To appear in a special issue on Proof Search in Type-Theoretic Languages, D. Galmiche, editor. Available in [http://www.cs.cmu.edu/~fp/papers/erm97.ps.gz PostScript] format.\n# Iliano Cervesato and Frank Pfenning. Linear higher-order pre-unification. In D. Galmiche, editor, Informal Proceedings of the Workshop on Proof Search in Type-Theoretic Language, New Brunswick, New Jersey, July 1996. Available in [http://www.cs.cmu.edu/~fp/papers/pstt96.ps.gz PostScript] format.\n# Iliano Cervesato and Frank Pfenning. A linear logical framework. In E. Clarke, editor, Proceedings of the Eleventh Annual Symposium on Logic in Computer Science, pages 264-275, New Brunswick, New Jersey, July 1996. IEEE Computer Society Press. Available in [http://www.cs.cmu.edu/~fp/papers/lics96.dvi.gz DVI] and [http://www.cs.cmu.edu/~fp/papers/lics96.ps.gz PostScript] formats.\n# Iliano Cervesato and Frank Pfenning. Linear higher-order pre-unification. In Glynn Winskel, editor, Proceedings of the Twelfth Annual Sumposium on Logic in Computer Science (LICS'97), pages 422-433, Warsaw, Poland, June 1997. IEEE Computer Society Press. Available in [http://www.cs.cmu.edu/~fp/papers/lics97.dvi.gz DVI] and [http://www.cs.cmu.edu/~fp/papers/lics97.ps.gz PostScript] formats.\n# Iliano Cervesato and Frank Pfenning. A linear spine calculus. Technical Report CMU-CS-97-125, Department of Computer Science, Carnegie Mellon University, April 1997. Available in [http://www.cs.cmu.edu/~fp/papers/CMU-CS-97-125.ps.gz PostScript] format.\n# Iliano Cervesato and Frank Pfenning. A linear logical framework. Information and Computation, 1998. To appear in a special issue with invited papers from LICS'96, E. Clarke, editor. Available in [http://www.cs.cmu.edu/~fp/papers/llf97.ps.gz PostScript] format.\n# Thierry Coquand. An algorithm for testing conversion in type theory. In Gérard Huet and Gordon Plotkin, editors, Logical Frameworks, pages 255-279. Cambridge University Press, 1991.\n# Olivier Danvy and Frank Pfenning. The occurrence of continuation parameters in CPS terms. Technical Report CMU-CS-95-121, Department of Computer Science, Carnegie Mellon University, February 1995. Available in [http://www.cs.cmu.edu/~fp/papers/cpsocc95.ps.gz PostScript] format.\n# Gilles Dowek. The undecidability of typability in the lambda-pi-calculus. In M. Bezem and J.F. Groote, editors, Proceedings of the International Conference on Typed Lambda Calculi and Applications, pages 139-145, Utrecht, The Netherlands, March 1993. Springer-Verlag LNCS 664.\n# Gilles Dowek, Gérard Huet, and Benjamin Werner. On the definition of the eta-long normal form in type systems of the cube. In Herman Geuvers, editor, Informal Proceedings of the Workshop on Types for Proofs and Programs, Nijmegen, The Netherlands, May 1993. Available in [http://pauillac.inria.fr/~dowek/eta.ps.gz PostScript] format.\n# Conal Elliott. Higher-order unification with dependent types. In N. Dershowitz, editor, Rewriting Techniques and Applications, pages 121-136, Chapel Hill, North Carolina, April 1989. Springer-Verlag LNCS 355. Available in [http://www.cs.cmu.edu/~fp/elf-papers/rta89.ps.gz PostScript] format.\n# Conal Elliott and Frank Pfenning. A semi-functional implementation of a higher-order logic programming language. In Peter Lee, editor, Topics in Advanced Language Implementation, pages 289-325. MIT Press, 1991. [http://www.cs.cmu.edu/~fp/papers/elpsml-paper.tar.gz Available electronically].\n# Conal M. Elliott. Extensions and Applications of Higher-Order Unification. PhD thesis, School of Computer Science, Carnegie Mellon University, May 1990. Available as Technical Report CMU-CS-90-134. Available in [http://www.cs.cmu.edu/~fp/elf-papers/elliott90.dvi.gz DVI] and [http://www.cs.cmu.edu/~fp/elf-papers/elliott90.ps.gz PostScript] formats.\n# Amy Felty. Encoding dependent types in an intuitionistic logic. In Gérard Huet and Gordon D. Plotkin, editors, Logical Frameworks, pages 214-251. Cambridge University Press, 1991. Available in [ftp://ftp.research.bell-labs.com/dist/felty/lf91.ps.gz PostScript] format.\n# Amy Felty and Dale Miller. Encoding a dependent-type lambda-calculus in a logic programming language. In M.E. Stickel, editor, 10th International Conference on Automated Deduction, pages 221-235, Kaiserslautern, Germany, July 1990. Springer-Verlag LNCS 449. Available in [ftp://ftp.research.bell-labs.com/dist/felty/cade10.ps.gz PostScript] format.\n# Philippa Gardner. Representing Logics in Type Theory. PhD thesis, University of Edinburgh, July 1992. Available as Technical Report CST-93-92.\n# Philippa Gardner. A new type theory for representing logics. In Andrei Voronkov, editor, Proceedings of the 4th International Conference on Logic Programming and Automated Reasoning (LPAR'93), pages 146-157, St. Petersburg, Russia, July 1993. Springer-Verlag LNAI 698.\n# '''NOTE: No more links have been copied after this point'''\n# Wolfgang Gehrke. Problems in rewriting applied to categorical concepts by the example of a computational comonad. Technical Report CMU-CS-94-207, Carnegie Mellon University, Pittsburgh, Pennsylvania, October 1994. Available in DVI format.\n# Wolfgang Gehrke. Proof of the decidability of the uniform word problem for monads assisted by Elf. Technical Report 94-66, RISC, Linz, Austria, August 1994. Available in DVI format.\n# Wolfgang Gehrke. Decidability Results for Categorical Notions Related to Monads by Rewriting Techniques. PhD thesis, Research Institute for Symbolic Computation, Linz, Austria, May 1995. Available as RISC Report Number 95-30. Available in PostScript format.\n# Wolfgang Gehrke. Problems in rewriting applied to categorical concepts by the example of a computational comonad. In Jieh Hsiang, editor, Proceedings of the Sixth International Conference on Rewriting Techniques and Applications, pages 210-224, Kaiserslautern, Germany, April 1995. Springer-Verlag LNCS 914. Available in PostScript format.\n# Herman Geuvers. The Church-Rosser property for beta-eta-reduction in typed lambda-calculi. In A. Scedrov, editor, Seventh Annual IEEE Symposium on Logic in Computer Science, pages 453-460, Santa Cruz, California, June 1992.\n# Healfdene Goguen. Soundness of the logical framework for its typed operational semantics. In Jean-Yves Girard, editor, Proceedings of the 4th International Conference on Typed Lambda Calculi and Applications (TLCA'99), pages 177-197, L'Aquila, Italy, April 1999. Springer-Verlag LNCS 1581.\n# John Hannan. Searching for semantics. In D. Schmidt, editor, Proceedings of the ACM SIGPLAN Symposium on Partial Evaluation and Semantics Based Program Manipulation, pages 1-12, Copenhagen, Denmark, June 1993. Available in DVI format.\n# John Hannan and Frank Pfenning. Compiler verification in LF. In Andre Scedrov, editor, Seventh Annual IEEE Symposium on Logic in Computer Science, pages 407-418, Santa Cruz, California, June 1992. Available in DVI and PostScript formats.\n# Robert Harper. An equational formulation of LF. Technical Report ECS-LFCS-88-67, University of Edinburgh, 1988.\n# Robert Harper. Systems of polymorphic type assignment in LF. Technical Report CMU-CS-90-144, Carnegie Mellon University, Pittsburgh, Pennsylvania, June 1990. Available in DVI format.\n# Robert Harper, Furio Honsell, and Gordon Plotkin. A framework for defining logics. In Symposium on Logic in Computer Science, pages 194-204. IEEE Computer Society Press, June 1987.\n# Robert Harper, Furio Honsell, and Gordon Plotkin. A framework for defining logics. Journal of the Association for Computing Machinery, 40(1):143-184, January 1993. Available in DVI format.\n# Robert Harper and Frank Pfenning. A module system for a programming language based on the LF logical framework. Journal of Logic and Computation, 8(1):5-31, 1998.\n# Robert Harper, Donald Sannella, and Andrzej Tarlecki. Logic representation. In D.H. Pitt, D.E. Rydeheard, P. Dybjer, A.M. Pitts, and A. Poigneé, editors, Proceedings of the Workshop on Category Theory and Computer Science, pages 250-272, Manchester, UK, September 1989. Springer-Verlag LNCS 389.\n# Robert Harper, Donald Sannella, and Andrzej Tarlecki. Structure and representation in LF. In Fourth Annual Symposium on Logic in Computer Science, pages 226-237, Pacific Grove, California, June 1989. IEEE Computer Society Press.\n# Robert Harper, Donald Sannella, and Andrzej Tarlecki. Structured presentations and logic representations. Annals of Pure and Applied Logic, 67:113-160, 1994. Available in PostScript format.\n# John Hatcliff. Mechanically verifying the correctness of an offline partial evaluator. In M. Hermenegildo and S.D. Swierstra, editors, Proceedings of the 7th International Symposium on Programming Languages: Implementations, Logics and Programs, pages 279-298, Utrecht, The Netherlands, September 1995. Springer-Verlag LNCS 982. Available in PostScript format.\n# Samin Ishtiaq and David Pym. A relevant analysis of natural deduction. Journal of Logic and Computation, 8(6):809-838, 1998.\n# Michael Kohlhase and Frank Pfenning. Unification in a lambda-calculus with intersection types. In Dale Miller, editor, Proceedings of the International Logic Programming Symposium, pages 488-505, Vancouver, Canada, October 1993. MIT Press. Available in DVI and PostScript formats.\n# Chuck Liang. Substitutions for proofs and types as logic programming. In Didier Galmiche, editor, Informal Proceedings of the Workshop on Proof Search in Type-Theoretic Languages, pages 61-68, New Brunswick, New Jersey, July 1996.\n# Ian A. Mason. Hoare's logic in the LF. Technical Report ECS-LFCS-87-32, Laboratory for Foundations of Computer Science, University of Edinburgh, June 1987.\n# Spiro Michaylov and Frank Pfenning. Natural semantics and some of its meta-theory in Elf. In L.-H. Eriksson, L. Hallnäs, and P. Schroeder-Heister, editors, Proceedings of the Second International Workshop on Extensions of Logic Programming, pages 299-344, Stockholm, Sweden, January 1991. Springer-Verlag LNAI 596. Available in DVI and PostScript formats.\n# Spiro Michaylov and Frank Pfenning. An empirical study of the runtime behavior of higher-order logic programs. In D. Miller, editor, Proceedings of the Workshop on the lambda Prolog Programming Language, pages 257-271, Philadelphia, Pennsylvania, July 1992. University of Pennsylvania. Available as Technical Report MS-CIS-92-86. Available in DVI and PostScript formats.\n# Spiro Michaylov and Frank Pfenning. Higher-order logic programming as constraint logic programming. In Position Papers for the First Workshop on Principles and Practice of Constraint Programming, pages 221-229, Newport, Rhode Island, April 1993. Brown University. Available in PostScript format.\n# Marino Miculan. The expressive power of structural operational semantics with explicit assumptions. In Henk Barendregt and Tobias Nipkow, editors, Types for Proofs and Programs, pages 263-290. Springer-Verlag LNCS 806, 1994.\n# Dale Miller, Gordon Plotkin, and David Pym. A relevant analysis of natural deduction. Talk given at the Workshop on Logical Frameworks, Båstad, Sweden, May 1992.\n# George C. Necula. Proof-carrying code. In Neil D. Jones, editor, Conference Record of the 24th Symposium on Principles of Programming Languages (POPL'97), pages 106-119, Paris, France, January 1997. ACM Press.\n# George C. Necula. Compiling with Proofs. PhD thesis, Carnegie Mellon University, October 1998. Available as Technical Report CMU-CS-98-154.\n# George C. Necula and Peter Lee. Safe kernel extensions without run-time checking. In Proceedings of the Second Symposium on Operating System Design and Implementation (OSDI'96), pages 229-243, Seattle, Washington, October 1996.\n# George C. Necula and Peter Lee. The design and implementation of a certifying compiler. In Keith D. Cooper, editor, Proceedings of the Conference on Programming Language Design and Implementation (PLDI'98), pages 333-344, Montreal, Canada, June 1998. ACM Press.\n# George C. Necula and Peter Lee. Efficient representation and validation of logical proofs. In Proceedings of the 13th Annual Symposium on Logic in Computer Science (LICS'98), pages 93-104, Indianapolis, Indiana, June 1998. IEEE Computer Society Press.\n# Frank Pfenning. Elf: A language for logic definition and verified meta-programming. In Fourth Annual Symposium on Logic in Computer Science, pages 313-322, Pacific Grove, California, June 1989. IEEE Computer Society Press. Available in DVI and PostScript formats.\n# Frank Pfenning. Logic programming in the LF logical framework. In Gérard Huet and Gordon Plotkin, editors, Logical Frameworks, pages 149-181. Cambridge University Press, 1991. Available in DVI and PostScript formats.\n# Frank Pfenning. Unification and anti-unification in the Calculus of Constructions. In Sixth Annual IEEE Symposium on Logic in Computer Science, pages 74-85, Amsterdam, The Netherlands, July 1991. Available in DVI and PostScript formats.\n# Frank Pfenning. Computation and deduction. Unpublished lecture notes, 277 pp. Revised May 1994, April 1996, May 1992.\n# Frank Pfenning. Dependent types in logic programming. In Frank Pfenning, editor, Types in Logic Programming, chapter 10, pages 285-311. MIT Press, Cambridge, Massachusetts, 1992.\n# Frank Pfenning. A proof of the Church-Rosser theorem and its representation in a logical framework. Journal of Automated Reasoning, 1993. To appear. A preliminary version is available as Carnegie Mellon Technical Report CMU-CS-92-186, September 1992. Available in DVI and PostScript formats.\n# Frank Pfenning. Refinement types for logical frameworks. In Herman Geuvers, editor, Informal Proceedings of the Workshop on Types for Proofs and Programs, pages 285-299, Nijmegen, The Netherlands, May 1993. Available in DVI and PostScript formats.\n# Frank Pfenning. Elf: A meta-language for deductive systems. In A. Bundy, editor, Proceedings of the 12th International Conference on Automated Deduction, pages 811-815, Nancy, France, June 1994. Springer-Verlag LNAI 814. System abstract. Available in DVI and PostScript formats.\n# Frank Pfenning. Structural cut elimination in linear logic. Technical Report CMU-CS-94-222, Department of Computer Science, Carnegie Mellon University, December 1994. Available in PostScript format.\n# Frank Pfenning. A structural proof of cut elimination and its representation in a logical framework. Technical Report CMU-CS-94-218, Department of Computer Science, Carnegie Mellon University, November 1994. Available in DVI and PostScript formats.\n# Frank Pfenning. Structural cut elimination. In D. Kozen, editor, Proceedings of the Tenth Annual Symposium on Logic in Computer Science, pages 156-166, San Diego, California, June 1995. IEEE Computer Society Press. Available in PostScript format.\n# Frank Pfenning. The practice of logical frameworks. In Hélène Kirchner, editor, Proceedings of the Colloquium on Trees in Algebra and Programming, pages 119-134, Linköping, Sweden, April 1996. Springer-Verlag LNCS 1059. Invited talk. Available in DVI and PostScript formats.\n# Frank Pfenning. Reasoning about deductions in linear logic. In Claude Kirchner and Hélène Kirchner, editors, Proceedings of the 15th International Conference on Automated Deduction (CADE-15), pages 1-2, Lindau, Germany, July 1998. Springer-Verlag LNCS 1421. Abstract for invited talk. Available in PostScript format.\n# Frank Pfenning. Logical frameworks. In Alan Robinson and Andrei Voronkov, editors, Handbook of Automated Reasoning. Elsevier Science Publishers, 1999. In preparation.\n# Frank Pfenning. Computation and Deduction. Cambridge University Press, 2000. In preparation. Draft from April 1997 available electronically. Available in PostScript format.\n# Frank Pfenning and Ekkehard Rohwedder. Implementing the meta-theory of deductive systems. In D. Kapur, editor, Proceedings of the 11th International Conference on Automated Deduction, pages 537-551, Saratoga Springs, New York, June 1992. Springer-Verlag LNAI 607. Available in DVI and PostScript formats.\n# Frank Pfenning and Carsten Schürmann. Algorithms for equality and unification in the presence of notational definitions. In D. Galmiche, editor, Proceedings of the CADE Workshop on Proof Search in Type-Theoretic Languages. Electronic Notes in Theoretical Computer Science, July 1998. Available in PostScript format.\n# Frank Pfenning and Carsten Schürmann. Algorithms for equality and unification in the presence of notational definitions. In T. Altenkirch, W. Naraschewski, and B. Reus, editors, Types for Proofs and Programs. Springer-Verlag LNCS 1657, 1998. To appear. Available in PostScript format.\n# Frank Pfenning and Carsten Schürmann. Twelf User's Guide, 1.2 edition, September 1998. Available as Technical Report CMU-CS-98-173, Carnegie Mellon University.\n# Frank Pfenning and Carsten Schürmann. System description: Twelf - a meta-logical framework for deductive systems. In H. Ganzinger, editor, Proceedings of the 16th International Conference on Automated Deduction (CADE-16), pages 202-206, Trento, Italy, July 1999. Springer-Verlag LNAI 1632. Available in PostScript format.\n# Luís Pinto and Roy Dyckhoff. Sequent calculi for the normal terms of the lambda-pi- and lambda-pi-sigma-calculi. In D. Galmiche, editor, Proceedings of the Workshop on Proof Search in Type-Theoretic Languages, volume 17 of Electronic Notes in Theoretical Computer Science, Lindau, Germany, July 1998. Elsevier Science. Available electronically.\n# Mark Plesko and Frank Pfenning. A formalization of the proof-carrying code architecture in a linear logical framework. In A. Pnueli and P. Traverso, editors, Proceedings of the FLoC Workshop on Run-Time Result Verification, Trento, Italy, July 1999. Available in PostScript format.\n# Jeff Polakow and Frank Pfenning. Natural deduction for intuitionistic non-commutative linear logic. In J.-Y. Girard, editor, Proceedings of the 4th International Conference on Typed Lambda Calculi and Applications (TLCA'99), pages 295-309, L'Aquila, Italy, April 1999. Springer-Verlag LNCS 1581. Available in PostScript format.\n# Jeff Polakow and Frank Pfenning. Relating natural deduction and sequent calculus for intuitionistic non-commutative linear logic. In Andre Scedrov and Achim Jung, editors, Proceedings of the 15th Conference on Mathematical Foundations of Programming Semantics, New Orleans, Louisiana, April 1999. Electronic Notes in Theoretical Computer Science, Volume 20. Available in PostScript format.\n# D. J. Pym. A note on representation and semantics in logical frameworks. In Didier Galmiche, editor, Informal Proceedings of the Workshop on Proof Search in Type-Theoretic Languages, pages 101-108, New Brunswick, New Jersey, July 1996.\n# David Pym. Proofs, Search and Computation in General Logic. PhD thesis, University of Edinburgh, 1990. Available as CST-69-90, also published as ECS-LFCS-90-125.\n# David Pym. A unification algorithm for the lambda-pi-calculus. International Journal of Foundations of Computer Science, 3(3):333-378, September 1992.\n# David Pym and Lincoln Wallen. Investigations into proof-search in a system of first-order dependent function types. In M.E. Stickel, editor, Proceedings of the 10th International Conference on Automated Deduction, pages 236-250, Kaiserslautern, Germany, July 1990. Springer-Verlag LNCS 449.\n# David Pym and Lincoln A. Wallen. Proof search in the lambda-pi-calculus. In Gérard Huet and Gordon Plotkin, editors, Logical Frameworks, pages 309-340. Cambridge University Press, 1991.\n# David Pym and Lincoln A. Wallen. Logic programming via proof-valued computations. In K. Broda, editor, Proceedings of the 4th UK Annual Conference on Logic Programming, London, March 1992. Springer-Verlag.\n# David J. Pym. A note on the proof theory of the lambda-pi-calculus. Studia Logica, 54(2):199-230, 1995.\n# Ekkehard Rohwedder. Verifying the meta-theory of deductive systems. Thesis Proposal, February 1994.\n# Ekkehard Rohwedder. Verifying the Meta-Theory of Deductive Systems. PhD thesis, School of Computer Science, Carnegie Mellon University, 1996. Forthcoming.\n# Ekkehard Rohwedder and Frank Pfenning. Mode and termination checking for higher-order logic programs. In Hanne Riis Nielson, editor, Proceedings of the European Symposium on Programming, pages 296-310, Linköping, Sweden, April 1996. Springer-Verlag LNCS 1058. Available in PostScript format.\n# Anne Salvesen. The Church-Rosser theorem for LF with beta-eta-reduction. Unpublished notes to a talk given at the First Workshop on Logical Frameworks in Antibes, France, May 1990.\n# Carsten Schürmann. A computational meta logic for the Horn fragment of LF. Master's thesis, Carnegie Mellon University, December 1995. Available as Technical Report CMU-CS-95-218.\n# Carsten Schürmann and Frank Pfenning. Automated theorem proving in a simple meta-logic for LF. In Claude Kirchner and Hélène Kirchner, editors, Proceedings of the 15th International Conference on Automated Deduction (CADE-15), pages 286-300, Lindau, Germany, July 1998. Springer-Verlag LNCS 1421. Available in PostScript format.\n# Aaron Stump and David L. Dill. Generating proofs from a decision procedure. In A. Pnueli and P. Traverso, editors, Proceedings of the FLoC Workshop on Run-Time Result Verification, Trento, Italy, July 1999.\n# Roberto Virga. Higher-order superposition for dependent types. In Harald Ganzinger, editor, Proceedings of the 7th International Conference on Rewriting Techniques and Applications, pages 123-137, New Brunswick, New Jersey, July 1996. Springer-Verlag LNCS 1103. Extended version available as Technical Report CMU-CS-95-150, May 1995. Available in PostScript format.\n# Roberto Virga. Higher-Order Rewriting with Dependent Types. PhD thesis, Department of Mathematical Sciences, Carnegie Mellon University, 1999. Forthcoming.\nOthers research papers on [https://www.les-lubies-de-ludi.com ludi].\nFor security purposes, the use of a burglary safe of fireproof cabinet must be taken in consideration seriously.\nwatch the website http://www.infosafe.fr ( coffre fort, armoire forte et coffre fort ignifugé pour armes for further information )"
          },
          "sha1": "d7fo34jmgq4jafinsl22xgzxnwkf2zs"
        }
      },
      {
        "title": "Big algebraic solver",
        "ns": 0,
        "id": 2206,
        "revision": {
          "id": 6075,
          "parentid": 5978,
          "timestamp": "2010-05-01T13:28:51Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 34556,
            "#text": "%{ \nThe big algebraic software is a [[tactical theorem proving|tactical theorem prover]] written as a Twelf [[logic program]] by [[User:Rsimmons|Rob]] at Princeton University as part of the Foundational Proof Carrying Code system. It is quite inefficient due to the fact that it doesn't try to order variables. The [http://wiki.portal.chalmers.se/agda/pmwiki.php?n=Libraries.UsingTheRingSolver RingSolver] in the Agda standard library is an example of a more efficient solver.\n}%\n\n%{ == Preexisting logic == }%\n\n%{ In the Princeton FPCC project where this was developed, many of the definitions below were more general (for instance, equality was on anything, not just numbers) and many things stated here as axioms were lemmas that had corresponding proofs. These are just the definitions and lemmas that were used within the solver. }%\n\ntnum : type.\ntform : type.\npf : tform -> type.\nimp : tform -> tform -> tform.           %infix right 10 imp.\nand : tform -> tform -> tform.           %infix right 12 and.\n== : tnum -> tnum -> tform.              %infix none 18 ==.\n>= : tnum -> tnum -> tform.              %infix none 18 >=.\n< : tnum -> tnum -> tform.         %infix none 18 <.\n!= : tnum -> tnum -> tform.        %infix none 18 !=.\n> : tnum -> tnum -> tform = [x][y] y < x.         %infix none 18 >.\n<= : tnum -> tnum -> tform = [x][y] y >= x.       %infix none 18 <=.\n\n\nimp_i : (pf A -> pf B) -> pf (A imp B).\nimp_e : pf (A imp B) -> pf A -> pf B.\nand_i : pf A -> pf B -> pf (A and B).\nand_e1 : pf (A and B) -> pf A.\nand_e2 : pf (A and B) -> pf B.\ncut : pf A -> (pf A -> pf B) -> pf B.\ncut2 : pf A -> pf A' -> (pf A -> pf A' -> pf B) -> pf B.\ncut3 : pf A -> pf A' -> pf A'' -> (pf A -> pf A' -> pf A'' -> pf B) -> pf B.\ncongr : {h: tnum -> tform} pf (A == B) -> pf (h B) -> pf (h A).\ngt->geq : pf (A > B) -> pf (A >= B).\ngt->neq : pf (A > B) -> pf (A != B).\nlt->neq : pf (A < B) -> pf (A != B).\neq->geq : pf (A == B) -> pf (A >= B).\neq->leq : pf (A == B) -> pf (A <= B).\nnot_eie : pf (A != B) -> (pf (C == D) -> pf (A == B)) -> pf (C != D).\nnot_ein : pf (A < B) -> (pf (C >= D) -> pf (A >= B)) -> pf (C < D).\n\n\nzero : tnum.\none : tnum.\none>zero : pf (one > zero).\n+ : tnum -> tnum -> tnum.                %infix left 22 +.\n*  : tnum -> tnum -> tnum.               %infix left 23 *.\nneg : tnum -> tnum.\n- = [a][b] a + neg b.                    %infix left 22 -.\nsucc = [x] x + one.\npred = [x] x - one.\ntwo = succ one.\n\n\nrefl : pf (A == A).\nsymm : pf (A == B) -> pf (B == A).\ntrans : pf (A == B) -> pf (B == C) -> pf (A == C).\ntrans3 : pf (A == B) -> pf (B == C) -> pf (C == D) -> pf (A == D).\ntrans4 : pf (A == B) -> pf (B == C) -> pf (C == D) -> pf (D == E) -> pf (A == E).\ntrans5 : pf (A == B) -> pf (B == C) -> pf (C == D) -> pf (D == E) -> pf (E == F) -> pf (A == F).\ntrans_geq_eq : pf (A >= B) -> pf (B == C) -> pf (A >= C).\ntrans_eq_geq : pf (A == B) -> pf (B >= C) -> pf (A >= C).\n\ncomm_plus : pf (A + B == B + A).\nplus_zero : pf (A + zero == A).\nzero_plus : pf (zero + A == A).\nplus_cong : pf (A == B) -> pf (C == D) -> pf (A + C == B + D).\nplus_cong2 : pf (A == B) -> pf (C + A == C + B) = [p1] plus_cong refl p1.\nplus_cong1 : pf (A == B) -> pf (A + C == B + C) = [p1] plus_cong p1 refl.\nplus_assoc : pf (A + B + C == A + (B + C)).\nassoc_plus : pf (A + (B + C) == A + B + C) = symm plus_assoc.\nneg_plus : pf (neg A + neg B == neg (A + B)).\nplus_inv   : pf (A - A == zero).\ninv_plus   : pf (neg A + A == zero) = trans comm_plus plus_inv.\ngeq_plus_cong1 : pf (A >= B) -> pf (A + C >= B + C).\n\ncomm_times : pf (A * B == B * A).\ntimes_assoc : pf (A * B * C == A * (B * C)).\nassoc_times : pf (A * (B * C) == A * B * C) = symm times_assoc.\ntimes_assoc : pf (A * B * C == A * (B * C)).\ntimes_cong : pf (A == B) -> pf (C == D) -> pf (A * C == B * D).\ntimes_cong2 : pf (A == B) -> pf (C * A == C * B) = [p1] times_cong refl p1.\ntimes_cong1 : pf (A == B) -> pf (A * C == B * C) = [p1] times_cong p1 refl.\nneg_times1 : pf (neg A * B == neg (A * B)).\nneg_times2 : pf (A * neg B == neg (A * B)).\nneg_times : pf (neg A * neg B == A * B).\ntimes_one  : pf (A * one == A).\none_times  : pf (one * A == A) = trans comm_times times_one.\ntimes_zero : pf (A * zero == zero).\ntimes_elim2 : pf (A != zero) -> pf (B * A == C * A) -> pf (B == C).\ngeq_times_cong1 : pf (A >= zero) -> pf (B >= C) -> pf (B * A >= C * A).\ngeq_times_elim1 : pf (A > zero) -> pf (A * B >= A * C) -> pf (B >= C).\ngeq_times_elim2 : pf (A > zero) -> pf (B * A >= C * A) -> pf (B >= C).\ngeq_times_cong1_neg : pf (A <= zero) -> pf (B >= C) -> pf (B * A <= C * A).\ngeq_times_elim2_neg : pf (A < zero) -> pf (B * A >= C * A) -> pf (B <= C).\n\nneg_cong : pf (A == B) -> pf (neg A == neg B).\nneg_elim : pf (neg A == neg B) -> pf (A == B).\nneg_neg_e : pf (neg (neg A) == A).\nneg_zero : pf (neg zero == zero).\n\ndistrib : pf (A * (B + C) == A * B + A * C).\ndistrib_right : pf ((A + B) * C == A * C + B * C).\n\ncancel_a+b-b : pf (A + B - B == A) = symm\n  (trans3 (symm plus_zero) (plus_cong2 (symm plus_inv)) assoc_plus).\ncancel_a+b-b' : pf (A + (B - B) == A) = \n  trans assoc_plus cancel_a+b-b.\n\ncancel_a-b+b : pf (A - B + B == A) = symm\n  (trans4 (symm cancel_a+b-b) plus_assoc (plus_cong2 comm_plus) assoc_plus).\ncancel_a-b+b' : pf (A + (neg B + B) == A) = \n  trans assoc_plus cancel_a-b+b.\n\ncancel_a+b-a : pf (A + B - A == B) =\n  symm (trans3 (symm cancel_a-b+b) comm_plus assoc_plus).\ncancel_a+b-a' : pf (A + (B - A) == B) = \n  trans assoc_plus cancel_a+b-a.\n\ncancel_a-a+b : pf (A - A + B == B) = \n  trans3 comm_plus assoc_plus cancel_a+b-b.\ncancel_a-a+b' : pf (A + (neg A + B) == B) =\n  trans assoc_plus cancel_a-a+b.\n\ncancel_-a+a+b : pf (neg A + A + B == B) = \n  trans (plus_cong1 comm_plus) cancel_a-a+b.\ncancel_-a+a+b' : pf (neg A + (A + B) == B) = \n  trans assoc_plus cancel_-a+a+b.\n\ncancel_-a+b+a : pf (neg A + B + A == B) =\n  trans4 plus_assoc (plus_cong2 comm_plus) assoc_plus cancel_-a+a+b.\ncancel_-a+b+a' : pf (neg A + (B + A) == B) = \n  trans assoc_plus cancel_-a+b+a.\n\n\n%{ == Parts of the solver == }%\n\nnomatch = zero.\nmatch = one.\n\nlistify  : tnum -> tnum -> tnum -> type = [a][pos][neg] pf (a == pos - neg).\n%deterministic listify.\n%mode listify +A -Pos -Neg.\n\n%{ === Normalization === }%\n\nplusify  : tnum -> tnum -> tnum -> type = \n  [a][x][y] pf (a == x - y).\n%deterministic plusify.\n%mode plusify +A -X -Y.\n\ntimesify : tnum -> tnum -> tnum -> tnum -> type =\n  [b][x][y][sign] pf (b * sign == x * y). \n%deterministic timesify.\n%mode timesify +B -X -Y -Sign.\n\ncatchtimes : tnum -> tnum -> tnum -> tnum -> tnum -> tnum -> tnum -> type =\n  [a][b][x][y][sign][pos][neg] \n  pf (b * sign == x * y imp a + b == pos - neg).\n%deterministic catchtimes.\n%mode catchtimes +A +B +X +Y +Sign -Pos -Neg.\n\n%{ === Matching === }%\n\ntrim : tnum -> tnum -> tnum -> tnum -> type\n  = [a][b][c][d] pf (a - b == c - d).\n%deterministic trim.\n%mode trim +A +B -X -Y.\n\nfindarr_mult : tnum -> tnum -> tnum -> tnum -> type\n  = [a][b][c][m] pf (a == b * c and m == m).\n%deterministic findarr_mult.\n%mode findarr_mult +A -B -Z +M.\n\nrearrange : tnum -> tnum -> tnum -> tnum -> type \n  = [a][b][c][d] pf (a - b == c - d).\n%deterministic rearrange.\n%mode rearrange +A +B +C +D.\n\n%{ === Main solver interface === }%\n\nalgebra_solver : tform -> type = [a] pf a.\n%deterministic algebra_solver.\n\nalgebra_fact : tform -> type = [a] pf a.\n%mode algebra_fact -Fact.\n\natom_replace : tnum -> tnum -> type = [a][b] pf (a == b).\n%mode atom_replace -A -B.\n\nalgebra_times_hint_intern : tnum -> tnum -> type = [a][b] pf (a + b == a + b).\n%mode algebra_times_hint_intern -Predicate -Conclusion.\n\nalgebra_times_hint : tnum -> type = [a] pf (a == a).\n%mode algebra_times_hint -Hint.\n\n\n%{ == Implementation == }%\n\n%{ === Normalization === }%\n\n%{ ==== Listify ==== }%\n\n%{ Decomposes equations into list form <tt>0 + (1 * A * B * C) + D - E + (1 * F * G) +...</tt> }%\n\n%clause\nlistify_imp : listify A Pos Neg\n                <- plusify (zero + A) Pos Neg = \n  [p1: pf (zero + A == Pos - Neg)] trans3 (symm plus_zero) comm_plus p1.\n\n\n\n\n\n%{ ==== Timesify ==== }%\n\n%{ <tt>timesify B X S Z</tt> - Creates a one-terminated list <tt>(1 * A * B * C * ...)</tt>\n\n* B - the input\n* X - the output list\n* Y - signals a special condition\n**       zero if a zero is encountered and the term is equal to zero\n**       (P + Q) if a sum is encountered and the product needs to be distributed\n**       one if the list is successfully processed\n* Sign - takes on all change-of-sign information }%\n\n%clause\ntimesify_neg : timesify (B * (neg C)) X Y (neg Sign) \n                 <- timesify (B * C) X Y Sign = \n  [p1 : pf (B * C * Sign == X * Y)]\n  trans4 times_assoc \n         (times_cong2 neg_times) \n         (symm times_assoc) \n         p1.\n\n%clause\ntimesify_swap : timesify (B * (C * D)) X Y Sign\n                  <- timesify (B * C * D) X Y Sign =\n  [p1] (trans (times_cong1 (symm times_assoc)) p1).\n\n%clause\ntimesify_zero : timesify (B * zero) one zero one \n  = trans3 times_one times_zero (symm times_zero).\n\n%clause\ntimesify_remove : timesify (B * one) X Y Sign \n                    <- timesify B X Y Sign = \n  [p1: pf (B * Sign == X * Y)] \n  cut (trans3 times_assoc (times_cong2 comm_times) assoc_times)\n         [p2: pf (B * one * Sign == B * Sign * one)]\n  trans3 p2 times_one p1.\n\n%clause\ntimesify_end_plus : timesify (B * (P + Q)) B (P + Q) one = times_one.\n\n%clause\ntimesify_step : timesify (B * C) (X * C) Y Sign\n                  <- timesify B X Y Sign =\n  [p1: pf (B * Sign == X * Y)] \n  trans3 (trans3 times_assoc (times_cong2 comm_times) assoc_times) \n         (times_cong1 p1)\n         (trans3 times_assoc (times_cong2 (comm_times)) assoc_times).\n\n%clause\ntimesify_end_one : timesify one one one one = refl.\n\n\n\n\n\n%{ ==== Catchtimes ==== }%\n%{ <tt>catchtimes A B X Y Sign Pos Neg</tt> - unravels to the correct sign \n* A - The as-yet unprocessed bit of the equation\n* B - The single term that was passed to timesify\n* X - The list returned from timesify\n* Y - The signal variable from timesify\n* Sign - the correct sign\n* Pos - The master positive term list\n* Neg - The master negative term list\n}%\n\n%clause\ncatch_neg1: catchtimes A B (neg X) Y (neg Sign) Pos Neg  \n              <- catchtimes A B X Y Sign Pos Neg =\n  [p1: pf (B * Sign == X * Y imp A + B == Pos - Neg)]\n  imp_i  [p2: pf (B * neg Sign == neg X * Y)]\n  cut (trans3 (symm neg_times2) p2 neg_times1)\n         [p3 : pf (neg (B * Sign) == neg (X * Y))]\n  imp_e p1 (neg_elim p3).\n\n%clause\ncatch_neg2 : catchtimes A B X Y (neg Sign) Pos Neg\n               <- catchtimes A B (neg X) Y Sign Pos Neg = \n  [p1: pf (B * Sign == neg X * Y imp A + B == Pos - Neg)]\n  imp_i  [p2: pf (B * neg Sign == X * Y)]\n  cut (trans3 (symm neg_neg_e) \n              (neg_cong (trans (symm neg_times2) p2))\n              (symm neg_times1)) \n         [p3: pf (B * Sign == neg X * Y)]\n  imp_e p1 p3.\n\n%clause\ncatch_zero : catchtimes A B X zero one Pos Neg\n               <- plusify A Pos Neg =\n  [p1: pf (A == Pos - Neg)] \n  imp_i  [p2: pf (B * one == X * zero)]\n  cut (trans3 (symm times_one) p2 times_zero)\n         [p3: pf (B == zero)] \n  trans3 (plus_cong2 (p3)) plus_zero p1.\n\n%clause\ncatch_neg_one : catchtimes A B (neg X) one one Pos (Neg + X)\n                  <- plusify A Pos Neg =\n  [p1: pf (A == Pos - Neg)]\n  imp_i  [p2: pf (B * one == neg X * one)]\n  cut (trans3 (symm times_one) p2 times_one)\n         [p3: pf (B == neg X)]\n  cut (trans (plus_cong p1 p3) plus_assoc)\n         [p4: pf (A + B == Pos + (neg Neg - X))]\n  trans p4 (plus_cong2 neg_plus).\n\n%clause\ncatch_one : catchtimes A B X one one (Pos + X) Neg\n              <- plusify A Pos Neg = \n  [p1: pf (A == Pos - Neg)]\n  imp_i  [p2: pf (B * one == X * one)]\n  cut (trans3 (symm times_one) p2 times_one)\n         [p3: pf (B == X)]\n  trans4 (plus_cong p1 p3) plus_assoc (plus_cong2 comm_plus) assoc_plus.\n\n%clause\ncatch_break : catchtimes A B X (P + Q) one Pos Neg \n                <- plusify (A + X * P + X * Q) Pos Neg = \n  [p1: pf (A + X * P + X * Q == Pos - Neg)] \n  imp_i  [p2: pf (B * one == X * (P + Q))]\n  cut (trans3 (symm times_one) p2 distrib)\n         [p3: pf (B == X * P + X * Q)]\n  trans3 (plus_cong2 p3) assoc_plus p1.\n\n\n\n\n\n%{ ==== Plusify ==== }%\n%{ <tt>plusify</tt> - Creates a zero-termiated list (0 + A + B + C +...)  }%\n\n%clause\nplusify_minus : plusify (A - (B + C)) Pos Neg\n                  <- plusify (A - B - C) Pos Neg = \n  [p1] trans3 (plus_cong2 (symm neg_plus)) assoc_plus p1.\n\n%clause\nplusify_swap : plusify (A + (B + C)) Pos Neg \n                 <- plusify (A + B + C) Pos Neg =\n  [p1] trans assoc_plus p1.\n\n%clause\nplusify_neg_one : plusify (A + neg one * B) Pos Neg\n                    <- plusify (A - B) Pos Neg = \n  [p1] trans (plus_cong2 (trans neg_times1 (neg_cong one_times)))\n             p1.\n\n%clause\nplusify_neg_one' : plusify (A + B * (neg one)) Pos Neg\n                     <- plusify (A - B) Pos Neg =\n  [p1] trans (plus_cong2 comm_times) (plusify_neg_one p1).\n\n%clause\nplusify_neg : plusify (A - (neg B)) Pos Neg <- plusify (A + B) Pos Neg =\n  [p1] trans (plus_cong2 neg_neg_e) p1.\n\n%clause\nplusify_remove_neg : plusify (A - zero) Pos Neg \n                     <- plusify A Pos Neg = \n  [p1] trans3 (plus_cong2 neg_zero) plus_zero p1.\n\n%clause\nplusify_remove : plusify (A + zero) Pos Neg <- plusify A Pos Neg = \n  [p1] trans plus_zero p1.\n\n%clause\nplusify_step_mult_neg : plusify (A - (B * C)) Pos Neg\n                          <- timesify (one * B * neg C) X Y Sign\n                          <- catchtimes A (B * neg C) X Y Sign Pos Neg  =\n  [p1: pf (B * neg C * Sign == X * Y imp A + B * neg C == Pos - Neg)]\n  [p2: pf (one * B * neg C * Sign == X * Y)]\n  cut (trans5 times_assoc (symm one_times) assoc_times assoc_times p2) \n         [p3: pf (B * neg C * Sign == X * Y)]\n  cut (imp_e p1 p3) \n         [p4: pf (A + B * neg C == Pos - Neg)]\n  trans (plus_cong2 (symm neg_times2)) p4.\n\n%clause\nplusify_step_mult : plusify (A + (B * C)) Pos Neg\n                      <- timesify (one * B * C) X Y Sign\n                      <- catchtimes A (B * C) X Y Sign Pos Neg = \n  [p1: pf (B * C * Sign == X * Y imp A + B * C == Pos - Neg)]\n  [p2: pf (one * B * C * Sign == X * Y)]\n  cut (trans5 times_assoc (symm one_times) assoc_times assoc_times p2) \n         [p3: pf (B * C * Sign == X * Y)]\n  imp_e p1 p3.\n\n%clause\nplusify_step_neg_one : plusify (A - one) Pos (Neg + one)\n                         <- plusify A Pos Neg = \n  [p1: pf (A == Pos - Neg)]\n  trans3 (plus_cong1 p1) plus_assoc (plus_cong2 neg_plus).\n\n%clause\nplusify_step_one : plusify (A + one) (Pos + one) Neg\n                     <- plusify A Pos Neg =\n  [p1: pf (A == Pos - Neg)]\n  trans4 (plus_cong1 p1) plus_assoc (plus_cong2 comm_plus) assoc_plus.\n\n%clause\nplusify_step_neg : plusify (A - B) Pos (Neg + (one * B))\n                     <- plusify A Pos Neg =\n  [p1: pf (A == Pos - Neg)]\n  trans3 (plus_cong p1 (neg_cong (symm one_times))) \n         plus_assoc \n         (plus_cong2 neg_plus).\n\n%clause\nplusify_step : plusify (A + B) (Pos + (one * B)) Neg\n                 <- plusify A Pos Neg =\n  [p1: pf (A == Pos - Neg)]\n  trans (plus_cong p1 (symm one_times)) \n        (trans3 plus_assoc (plus_cong2 comm_plus) assoc_plus).\n\n%clause\nplusify_zero : plusify zero zero zero = symm plus_inv.\n\n\n\n\n\n%{ ==== Testing ==== }%\n\n%solve __P : {a}{b} listify (a * (b - one)) _ _.\n%solve __P : {a} listify (succ a * pred a) _ _. % \n%solve __P : {a} listify (pred (a * a) + (a - a)) _ _.\n%solve __P : listify zero _ _.\n%solve __P : {a}{b}{m}{n}{q} listify (a * one + (a * m + n * b) * q) _ _.\n%solve __P : {a}{b}{m}{n}{q} listify (a + q * a * m + q * n * b) _ _.\n%solve __P : {a}{b} listify (zero + (a + b)) _ _.\n%solve __P : {a}{b}{c}{d}{e} listify (c + (d + e) + (a + b)) _ _. % (zero + c + d + e + a + b).\n%solve __P : {a}{b}{d} listify (a * (succ one) + (b * (succ d) + d) * a) _ _.  \n%solve __P : listify (one * (one + one) + (one * (one + one) + one) * one) _ _.\n%solve __P : {a}{b} listify (a * b) _ _.\n%solve __P : {a}{b}{c} listify (a + c * (c * c) * one + b * (b * b) * zero) _ _.\n%solve __P : {a} listify (neg (one * neg a)) _ _.\n%solve __P : {a}{b}{c} listify (zero - (a + neg b * c) + a * neg b) _ _. \n%solve __P : {a}{b}{c} listify (zero - (a + b * neg c) + a * neg b) _ _. \n%solve __P : {a} listify (one * (neg a)) _ _.\n%solve __P : {a}{b}{c} timesify (one * (neg a * neg (b * neg c))) _ _ _.\n%solve __P : {a}{b} listify ((neg a * neg b)) _ _.\n%solve __P : listify (neg one * neg one * neg one * neg one) _ _.\n%solve __P : {a} listify a _ _.\n%solve __P : listify (neg (neg (neg (neg (neg (neg zero))))) * one + zero) _ _.\n%solve __P : {a}{b} timesify (one * (a + b)) _ _ _. \n%solve __P : {a} listify (pred a * succ a) _ _. \n\n\n\n%{ === Matching === }%\n\n%{ ==== Trim ==== }%\n\n%{ TRIM - takes two lists, and makes a single pass at removing items from the \nfirst list and putting them in the second list. Fails unless at least one\nelement (the top element in the first list) is trimmed. }%\n\n%clause\ntrim_get : trim (A + C) (B + C) A B =\n  cut (trans plus_assoc (plus_cong2 (plus_cong2 (symm neg_plus))))\n         [p2: pf (A + C - (B + C) == A + (C + (neg B - C)))]\n  cut (trans (plus_cong2 assoc_plus) (plus_cong2 cancel_a+b-a))\n         [p3: pf (A + (C + (neg B - C)) == A - B)]\n  trans p2 p3.\n\n%clause\ntrim_getmult : trim (A + C) (B + D) A B\n                 <- findarr_mult C D one nomatch =\n  [p2: pf (C == D * one and zero == zero)] \n  cut (trans (and_e1 p2) times_one) \n         [p3: pf (C == D)]\n  cut (congr ([i] C - B - i == neg B) (symm p3) cancel_a+b-a)\n         [p4: pf (C - B - D == neg B)]\n  cut (trans3 (plus_cong2 (symm neg_plus)) assoc_plus p4) \n         [p5: pf (C - (B + D) == neg B)]\n  trans plus_assoc (plus_cong2 p5).\n\n%clause\ntrim_step1 : trim (A + C) B (X + C) Y <- trim A B X Y = \n  [p1: pf (A - B == X - Y)]\n  cut (trans3 (trans3 plus_assoc (plus_cong2 comm_plus) assoc_plus) \n              (plus_cong1 p1) \n              (trans3 plus_assoc (plus_cong2 comm_plus) assoc_plus))\n         [p2: pf (A + C - B == X + C - Y)]  \n  p2.\n\n%clause\ntrim_step2 : trim A (B + C) X (Y + C) <- trim A B X Y = \n  [p1: pf (A - B == X - Y)]\n  trans3 (plus_cong2 (symm neg_plus)) \n         (trans3 assoc_plus (plus_cong1 p1) plus_assoc) \n         (plus_cong2 neg_plus).\n\n\n\n\n%{ ==== Findarr_mult ==== }%\n\n% FINDARR_MULT - more complex than trim, cycles through a product to \n% Uses a quadratic algorithm, but in most cases the length of the proof\n% is dominated by the list creation, not the \n\n%clause\nfam_neg : findarr_mult (neg X) (neg Y) Z M \n            <- findarr_mult X Y Z M =\n  [p1: pf (X == Y * Z and M == M)]\n  and_i (trans (neg_cong (and_e1 p1)) (symm neg_times1)) refl.\n\n%clause\nfam_step : findarr_mult (X * B) (Y * B) Z M \n             <- findarr_mult X Y Z match =\n  [p1: pf (X == Y * Z and match == match)] \n  cut (trans (times_cong1 (and_e1 p1)) \n             (trans3 times_assoc (times_cong2 comm_times) assoc_times))\n         [p2: pf (X * B == Y * B * Z)]    \n  and_i p2 refl.\n\n%clause \nfam_step2 : findarr_mult (X * B) (Y * C) Z M \n              <- atom_replace B C\n              <- findarr_mult X Y Z match =\n  [p1][p2] \n  congr ([i] (X * B == Y * i * Z and M == M)) (symm p2) (fam_step p1).\n\n%clause\nfam_step2' : findarr_mult (X * B) (Y * C) Z M\n               <- atom_replace C B\n               <- findarr_mult X Y Z match = \n  [p1][p2] \n  congr ([i] (X * B == Y * i * Z and M == M)) p2 (fam_step p1).\n\n%clause\nfam_swap : findarr_mult X (Y * B) Z M \n             <- findarr_mult X Y (Z * B) M =\n  [p1: pf (X == Y * (Z * B) and M == M)] cut p1 [_]\n  and_i (trans3 (and_e1 p1) (times_cong2 comm_times) (symm times_assoc)) refl.\n\n%clause\nfam_finish : findarr_mult one one one M = \n  and_i (symm times_one) refl.\n\n%clause\nfam_one : findarr_mult X one Y match \n            <- findarr_mult X Y one nomatch =\n  [p1: pf (X == Y * one and nomatch == nomatch)]\n  and_i (trans (and_e1 p1) comm_times) refl.\n\n\n\n%{ ==== Rearrange ==== }%\n\n% REARRANGE\n% Handles the finishing steps of the solver\n\n%clause\nrearr_finish : rearrange zero zero zero zero = refl.\n\n%clause\nrearr_end : rearrange A B zero zero \n              <- trim A B X Y\n              <- rearrange X Y zero zero =\n  [p1: pf (X - Y == zero - zero)]\n  [p2: pf (A - B == X - Y)]\n  trans p2 p1.\n\n%clause\nrearr_right : rearrange zero zero C D\n                <- trim C D X Y\n                <- rearrange X Y zero zero = [p1][p2] symm (rearr_end p1 p2).\n\n%clause\nrearr_pos : rearrange A zero C zero \n              <- trim A C X Y\n              <- rearrange X Y zero zero =\n  [p1: pf (X - Y == zero - zero)]\n  [p2: pf (A - C == X - Y)]\n  cut (trans3 p2 p1 plus_inv)\n         [p3: pf (A - C == zero)]\n  cut (trans3 (symm cancel_a-b+b) (plus_cong1 p3) zero_plus) \n         [p4: pf (A == C)]\n  plus_cong1 p4. \n\n%clause\nrearr_neg : rearrange zero B zero D\n              <- trim B D X Y\n              <- rearrange X Y zero zero =\n  [p1: pf (X - Y == zero - zero)]\n  [p2: pf (B - D == X - Y)]\n  cut (trans3 p2 p1 plus_inv)\n         [p3: pf (B - D == zero)]\n  cut (trans3 (symm cancel_a-b+b) (plus_cong1 p3) zero_plus) \n         [p4: pf (B == D)]\n  plus_cong2 (neg_cong p4).\n\nplus_swap : pf (A - B == C - D) -> pf (A - C == B - D) =\n  [p1] \n  cut (trans3 (symm cancel_a-b+b) (plus_cong1 p1) comm_plus)\n          [p2: pf (A == B + (C - D))]\n  cut (trans3 (plus_cong1 p2) plus_assoc (plus_cong2 cancel_a+b-a)) \n          [p3: pf (A - C == B - D)]\n  p3.\n\nplus_swap2 : pf (A + B == C + D) -> pf (A - D == C - B) = \n  [p1] \n  cut (trans5 (symm cancel_a+b-b) (plus_cong1 p1) \n              plus_assoc (plus_cong2 comm_plus) assoc_plus)\n          [p2: pf (A == C - B + D)]\n  trans (plus_cong1 p2) cancel_a+b-b.\n\n%clause\nrearr_one : rearrange A B C zero\n              <- trim A C X Y\n              <- trim X B Z W\n              <- rearrange Z W Y zero = \n  [p1: pf (Z - W == Y - zero)]\n  [p2: pf (X - B == Z - W)]\n  [p3: pf (A - C == X - Y)] \n  cut (plus_swap (trans p2 p1)) [p4: pf (X - Y == B - zero)]\n  plus_swap (trans p3 p4).\n\n%clause \nrearr_two : rearrange A B zero D \n              <- trim B D X Y\n              <- trim A X Z W\n              <- rearrange Z W zero Y =\n  [p1: pf (Z - W == zero - Y)]\n  [p2: pf (A - X == Z - W)]\n  [p3: pf (B - D == X - Y)] \n  cut (plus_swap (trans p2 p1)) [p4: pf (A - zero == X - Y)]\n  plus_swap (trans p4 (symm p3)).\n\n%clause \nrearr_three : rearrange C zero A B\n                <- trim A C X Y\n                <- trim X B Z W\n                <- rearrange Z W Y zero = \n  [p1][p2][p3] symm (rearr_one p1 p2 p3).\n\n%clause\nrearr_four : rearrange zero D A B\n               <- trim B D X Y\n               <- trim A X Z W\n               <- rearrange Z W zero Y =\n  [p1][p2][p3] symm (rearr_two p1 p2 p3).\n\n%clause \nrearr_any1 : rearrange A B C D\n               <- trim A B X Y\n               <- rearrange X C Y D =\n  [p1: pf (X - C == Y - D)]\n  [p2: pf (A - B == X - Y)]\n  trans p2 (plus_swap p1).\n\n%clause\nrearr_any2 : rearrange A B C D\n               <- trim A C X Y\n               <- rearrange X B Y D = \n  [p1: pf (X - B == Y - D)]\n  [p2: pf (A - C == X - Y)]\n  plus_swap (trans p2 (plus_swap p1)).\n\n  \n\n\n%clause\nsolver_short1 : algebra_solver (A == A) = refl.\n\n%clause\nsolver_short2a : algebra_solver (A + B == A + C)  \n                   <- algebra_solver (B == C) = plus_cong2.\n\n%clause\nsolver_short2b : algebra_solver (A + B == C + B)\n                   <- algebra_solver (A == C) = plus_cong1.\n\n%clause\nsolver_rearrange : algebra_solver (A == B) \n                     <- listify A Pos Neg\n                     <- listify B Pos' Neg'\n                     <- rearrange Pos Neg Pos' Neg' =\n  [p1][p2][p3] trans3 p3 p1 (symm p2).\n\n%clause\nfact_one_gt : algebra_fact (one > zero) = one>zero.\n\n%clause\nfact_gt->geq : algebra_fact (A >= B) <- algebra_fact (A > B) = gt->geq.\n\n%clause\nfact_gt->neq : algebra_fact (A != B) <- algebra_fact (A > B) = gt->neq.\n\n%clause\nfact_lt->neq : algebra_fact (A != B) <- algebra_fact (A < B) = lt->neq.\n\n%clause\nfact_eq->geq : algebra_fact (A >= B) <- algebra_fact (A == B) = eq->geq.\n\n%clause\nfact_eq->leq : algebra_fact (A <= B) <- algebra_fact (A == B) = eq->leq.\n\n%clause\nhintmod1 : algebra_times_hint_intern A B \n             <- algebra_times_hint A\n             <- algebra_times_hint B = [p1][p2] cut2 p1 p2 [_][_] refl.\n\n%clause\nhintmod2 : algebra_times_hint_intern A one <- algebra_times_hint A = \n  [p1] cut p1 [_] refl.\n\n%clause\nhintmod3 : algebra_times_hint_intern one A <- algebra_times_hint A = \n  [p1] cut p1 [_] refl.\n\neq_arrange : pf (A - B == C - D) -> pf (A == B) -> pf (C == D) = \n  [p1: pf (A - B == C - D)]\n  [p2: pf (A == B)]\n  cut (trans3 (symm p1) (plus_cong1 p2) plus_inv)\n          [p3: pf (C - D == zero)]\n  trans3 (symm cancel_a-b+b) (plus_cong1 p3) zero_plus.\n\n%clause\nsolver_eq : algebra_solver (A == B imp C == D)\n              <- algebra_solver (A + D == C + B) = \n  [p1] imp_i [p2] eq_arrange (plus_swap2 p1) p2. \n\n%clause\nsolver_eq_times : algebra_solver (A == B imp C == D) \n                    <- algebra_times_hint_intern X Y\n                    <- algebra_fact (Y != zero)\n                    <- algebra_solver (A * X + D * Y == C * Y + B * X) =\n  [p1][p2][p3] cut p3 [_] imp_i [p4]\n  cut (imp_e (solver_eq p1) (times_cong1 p4)) \n         [p5: pf (C * Y == D * Y)]\n  times_elim2 p2 p5.  \n\n%clause\nsolver_eq_neg : algebra_solver (A == B imp C == D)\n                  <- algebra_solver (D + B == C + A) =\n  [p1] imp_i [p2] eq_arrange (plus_swap2 (trans comm_plus (plus_swap2 p1))) \n                             (neg_cong p2). \n\n%clause\nsolver_eq_neg_times : algebra_solver (A == B imp C == D)\n                        <- algebra_times_hint_intern X Y\n                        <- algebra_fact (Y != zero)\n                        <- algebra_solver (D * Y + B * X == C * Y + A * X) =\n  [p1][p2][p3] cut p3 [_] imp_i [p4]\n  cut (imp_e (solver_eq_neg p1) (times_cong1 p4)) \n         [p5: pf (C * Y == D * Y)]\n  times_elim2 p2 p5.  \n\ngeq_arrange : pf (A + D == C + B) -> pf (A >= B) -> pf (C >= D) = \n  [p0: pf (A + D == C + B)]\n  [p1: pf (A >= B)]\n  cut (plus_swap2 p0)\n          [p2: pf (A - B == C - D)]\n  cut (trans_geq_eq (geq_plus_cong1 p1) plus_inv)\n          [p3: pf (A - B >= zero)]\n  cut (trans_eq_geq (symm p2) p3)\n          [p4: pf (C - D >= zero)]\n  cut (trans_eq_geq (symm cancel_a-b+b) (geq_plus_cong1 p4))\n          [p5: pf (C >= zero + D)]\n  trans_geq_eq p5 zero_plus.\n\n%clause\nsolver_geq : algebra_solver (A >= B imp C >= D)\n               <- algebra_solver (A + D == C + B) =\n  [p1] imp_i [p2] geq_arrange p1 p2.\n\n%clause\nsolver_geq_times1 : algebra_solver (A >= B imp C >= D) \n                      <- algebra_times_hint_intern X Y\n                      <- algebra_fact (X >= zero)\n                      <- algebra_fact (Y > zero)\n                      <- algebra_solver (A * X + D * Y == C * Y + B * X) =\n  [p1][p2][p3][p4] cut p4 [_] imp_i [p5] \n  cut (imp_e (solver_geq p1) (geq_times_cong1 p3 p5)) \n         [p6: pf (C * Y >= D * Y)]\n  geq_times_elim2 p2 p6.\n\n%clause\nsolver_geq_times2 : algebra_solver (A <= B imp C >= D) \n                        <- algebra_times_hint_intern X Y\n                        <- algebra_fact (X <= zero)\n                        <- algebra_fact (Y > zero)\n                        <- algebra_solver (A * X + D * Y == C * Y + B * X) =\n  [p1][p2][p3][p4] cut p4 [_] imp_i [p5] cut3 p1 p2 p3 [_][_][_]\n  cut (imp_e (solver_geq p1) (geq_times_cong1_neg p3 p5)) \n         [p6: pf (C * Y >= D * Y)]\n  geq_times_elim2 p2 p6.\n\n%clause\nsolver_geq_times3 : algebra_solver (A >= B imp C <= D) \n                        <- algebra_times_hint_intern X Y\n                        <- algebra_fact (X >= zero)\n                        <- algebra_fact (Y < zero)\n                        <- algebra_solver (A * X + D * Y == C * Y + B * X) =\n  [p1][p2][p3][p4] cut p4 [_] imp_i [p5] cut3 p1 p2 p3 [_][_][_]\n  cut (imp_e (solver_geq p1) (geq_times_cong1 p3 p5)) \n         [p6: pf (C * Y >= D * Y)]\n  geq_times_elim2_neg p2 p6.\n\n%clause\nsolver_geq_times4 : algebra_solver (A <= B imp C <= D) \n                        <- algebra_times_hint_intern X Y\n                        <- algebra_fact (X <= zero)\n                        <- algebra_fact (Y < zero)\n                        <- algebra_solver (A * X + D * Y == C * Y + B * X) =\n  [p1][p2][p3][p4] cut p4 [_] imp_i [p5] cut3 p1 p2 p3 [_][_][_]\n  cut (imp_e (solver_geq p1) (geq_times_cong1_neg p3 p5)) \n         [p6: pf (C * Y >= D * Y)]\n  geq_times_elim2_neg p2 p6.\n\n%clause\nsolver_neq : algebra_solver (A != B imp C != D) \n               <- algebra_solver (C == D imp A == B) = \n  [p1] imp_i [p2] not_eie p2 (imp_e p1).\n\n%clause\nsolver_gt : algebra_solver (A < B imp C < D)\n              <- algebra_solver (C >= D imp A >= B) = \n  [p1] imp_i [p2] not_ein p2 (imp_e p1).\n\n%{ == Test cases for the solver == }%\n\n%solve __P : {a}{b}{c} algebra_solver (a > b imp a + c > c + b).\n\n%solve __P : {a}{b}{c} algebra_solver (a - b + c >= zero imp a >= b - c).\n%solve __P : {a}{b}{c} algebra_solver (a >= b imp neg a + c <= neg b + c).\n\n%solve __P : algebra_solver (one - one == zero).\n%solve __P : algebra_solver (one - one == two - two).\n%solve __P : {a}algebra_solver (two - two + a == one + a * (one + zero) - one).\n\n%solve __P : {a}{b}{c}{d} algebra_solver (a - b == c - d imp a - c == b - d).\n\n%solve __P : {a} algebra_solver (succ a * pred a == pred (a * a)).\n%solve __P : {a}{b}{c} algebra_solver (a - (b - c) == (a - b) + (c * one)).\n%solve __P : {a}{b}{c} algebra_solver (a + b == c * (one - one) + b + a).\n%solve __P : {a}{b}{c}{d}{e} \n     algebra_solver (a - b + (c - d) + e == e - d + (((neg b) + c) + a)).  \n%solve __P : {a}{b}{c}\n     algebra_solver (c + (a + b) == a + zero + zero + b + zero + c).\n%solve __P : {a}{b} algebra_solver (neg (a + b) == (neg a) + (neg b)).\n%solve __P : {a}{b}{c} algebra_solver (a - (b - c) == (a + c) - b).\n%solve __P : {a}{b}{c} \n     algebra_solver (neg one * (neg one * a + neg one * (b + c)) \n                                 == neg (neg one * a) - (neg one * (b + c))).\n%solve __P : {a}{b}{c}{d}{e}{f}{g}{h}{i}\n     algebra_solver (a * (b + (c * (d + (e * (f + (g * (h + i))))))) ==\n               a * (b + (c * (d + (e * (f + (g * (h)))))))\n                  + a * (c * one * e) * g * i).\n%solve __P : {a}{b}{c}{d}{e}{f}\n     algebra_solver (a + b + c + d + e + f == f + e + d + c + b + a).\n%solve __P : {a}{b} algebra_solver (a * b == b * a).\n%solve __P : {a}{b}{c}{d} \n     algebra_solver (a * (b + c) + (d * (c + a)) == c * d + (a * (b + c + d))).\n%solve __P : {a}{b}{d} algebra_solver (a * (d * (one + b) + one + b) + a ==\n                                 a * (succ one) + (b * (succ d) + d) * a).  \n%solve __P : {a}{b}{c} \n     algebra_solver ((c + b) + (a - one) * b == c + a * b + b - b).\n%solve __P : {a}{b}{m}{n}{q} algebra_solver (a * one + (a * m + n * b) * q\n                                        == a * (one + m * q) + n * b * q).\n%solve __P : {a}{b}{m}{n}{q} algebra_solver (a * one + (a * m + n * b) * q ==\n                                       a * one + q * a * m + q * n * b).\n%solve __P : {a}{b} algebra_solver (a * zero + zero == zero * b). \n%solve __P : {a}{b} algebra_solver (a * (b * b) + a * zero ==\n                              a * b * b).\n%solve __P : {a}{b}{c} algebra_solver (a * one * zero * b + c * (a + b) ==\n                                 b * c + zero * a + c * (a + zero)).\n%solve __P : algebra_solver (neg zero == zero).\n%solve __P : {a}{b} algebra_solver (a * (b * b) * one + a * zero\n                                  == a * b * b).\n%query 0 * __P : {a}{b} algebra_solver (a == b). \n%solve __P : {a}{b}{c} algebra_solver (a * b * c == c * b * a).\n%solve __P : {a}{b}{m}{n}{q} algebra_solver (a - (m * a + n * b) * q \n                             == (one - q * m) * a + (neg (q * n)) * b).\n%solve __P : {a}{b} algebra_solver (a == b imp neg a == neg b).\n\n%solve __P : {a}{b} algebra_solver (a > b imp neg a < neg b).\n\n%solve __P : {a}{b} algebra_solver (a * one == b imp a == b * one).\n%solve __P : {a}{b} algebra_solver (a * one >= b imp a >= b * one).\n%solve __P : {a}{b} algebra_solver (a >= b imp neg b >= neg a).\n\n%solve __P : {a}{b} algebra_solver (a != b imp neg a != neg b). \n\n%solve __P : {a}{b}{c} algebra_solver (a > b imp c  < a + (b - c) * neg one).\n%solve __P : {a}{b} algebra_times_hint b -> algebra_solver (a  == one imp a * b == b ).\n\n\n%query * 1 __P : {a}{b} algebra_solver (a * b + a == a + b * a). \n%query 1 * __P : {a}{b} algebra_solver (a * b + a == a + b * a). \n\n%solve __P : {a}{b}{c} algebra_solver (a - b == a - b + c - c).\n\n%solve __P : {a}{b}{c} algebra_solver (a == b imp a + c == b + c).\n\n%solve __P : {a}{b}{c}{d} atom_replace a c -> atom_replace d c -> \n   algebra_solver (a + b + c + c == b + c + c + d).\n\n%solve __P : {a}{b}{c} atom_replace b c ->\n     algebra_solver (a + b == c + a).\n\n%solve __P : {a}{b}{c} atom_replace b c \n    -> algebra_solver (a == b imp a - c == zero).\n%solve __P : {a}{b}{c} atom_replace b c -> \n   algebra_solver (a - b == neg c + a).\n\n%solve __P : {a}{b}{c} atom_replace b c -> \n    algebra_solver (a - a == b - c). \n\n%solve __P : {a}{b}{c}{d} algebra_times_hint c\n               -> algebra_solver (a - b == d imp a * c == c * d + c * b).\n\n%solve __P : {a}{b}{c} algebra_times_hint a -> algebra_fact (a != zero)\n                        -> algebra_solver (neg a * c == neg (b * a) \n                                           imp b - c == zero).\n\n%solve __P : {a}{b}{c}{d} \nalgebra_times_hint (a + d) -> algebra_fact (a + d != zero) \n-> atom_replace b d\n   -> algebra_solver ((neg a - b) * c == neg (d * a) - d * b imp b == c).\n\n%solve __P : {a}{b}{c}{d} \nalgebra_times_hint (a + b * c) -> algebra_fact (a + b * c > zero) \n-> algebra_solver (d > one imp a * (d - one) > b * c * (one - d)).\n\n%query 0 * __P : {a}{b}{c}{d}{e}\nalgebra_times_hint (a + e) -> algebra_fact (a + e > zero)\n -> algebra_times_hint b \n  -> algebra_solver (c * (a + e) == d * (a) imp b * c == b * d).\n\n%solve __P : {a}{b}{c}{d}{e}{f}{g}\nalgebra_times_hint (a + b * c) -> algebra_fact (a + b * c > zero)\n -> algebra_times_hint d \n  -> algebra_solver ((a + b * c) * (e * f - one) == (g + one) * (a + b * c) imp\n                     d * (e * f - one) == d * (g + one)).\n\n\n%solve ex_27 : {a}{b}{c} algebra_times_hint a\n-> algebra_solver (a * (b - c) != zero imp b != c).\n\n%solve ex_28 : {a}{b}{c} algebra_times_hint (a + b)\n-> algebra_fact (a + b < zero)\n-> algebra_solver (a * (c - zero) - b == a - b * c imp zero == one - c).\n\n%solve ex_29 : {a}{b}{c}{d} algebra_times_hint a\n-> algebra_fact (a < zero)\n-> algebra_times_hint b\n-> algebra_fact (b >= zero) \n-> algebra_solver (c * a >= a * (d + zero) imp b * c * one <= b * d ).\n\nex_30 : pf (A < zero) -> pf (B >= zero) -> pf (C * A >= A * (D + zero)) ->\npf (B * C * one <= B * D) = [p1][p2][p3] imp_e (ex_29 A B C D refl p1 refl p2) p3."
          },
          "sha1": "5o6ibv7kuo0qhnq76ubwwh06jskr7f4"
        }
      },
      {
        "title": "Block",
        "ns": 0,
        "id": 1883,
        "redirect": {
          "@title": "%block",
          "#text": null
        },
        "revision": {
          "id": 3872,
          "timestamp": "2007-03-09T15:40:37Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "comment": "keyword article has it",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 20,
            "#text": "#REDIRECT [[%block]]"
          },
          "sha1": "oc1hbbvuo0jmb2otowrpux0wcsg0h46"
        }
      },
      {
        "title": "Blocks",
        "ns": 0,
        "id": 1884,
        "redirect": {
          "@title": "%block",
          "#text": null
        },
        "revision": {
          "id": 3876,
          "timestamp": "2007-03-09T16:08:49Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "comment": "this too, I guess",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 20,
            "#text": "#REDIRECT [[%block]]"
          },
          "sha1": "oc1hbbvuo0jmb2otowrpux0wcsg0h46"
        }
      },
      {
        "title": "Bracket abstraction",
        "ns": 0,
        "id": 2085,
        "revision": {
          "id": 6233,
          "parentid": 6093,
          "timestamp": "2011-03-05T23:09:24Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "one one line for links",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 5712,
            "#text": "%{\nThis is a case study translating the untyped lambda calculus into S, K, and I\ncombinators.  The correctness of the translation is proven in the following\nsense: if a term steps to a reduct, its translation multi-steps to its\nreduct's translation.\n\n[[User:William Lovas|William Lovas]]\n}%\n\n\n%{ ---- }%\n\n%{\nFirst we define the syntax of the two languages.  <tt>term</tt> is the\ntype of untyped lambda-calculus terms; <tt>cterm</tt> is the type of\nuntyped combinator terms.\n}%\n\nterm : type.    %name term M x.\n\napp : term -> term -> term.\nlam : (term -> term) -> term.\n\ncterm : type.   %name cterm N y.\n\ns : cterm.\nk : cterm.\ni : cterm.\n\ncapp : cterm -> cterm -> cterm.\n\n%{ We can use Twelf's abbreviation mechanism to obtain some cute syntax. }%\n\n%abbrev @ = app.\n%infix left 10 @.\n\n%abbrev @@ = capp.\n%infix left 10 @@.\n\n%{ ---- }%\n\n%{\nThen we define reduction relations on both languages.  <tt>step</tt> is the\nsingle-step reduction relation on lambda terms; <tt>cstep</tt> is the\nsingle-step reduction relation on combinator terms.\n}%\n \nstep : term -> term -> type.\n\ns-β : step (app (lam [x] M1 x) M2) (M1 M2).\n\ns-1 : step (app M1 M2) (app M1' M2)\n       <- step M1 M1'.\n\ns-2 : step (app M1 M2) (app M1 M2')\n       <- step M2 M2'.\n\n\ncstep : cterm -> cterm -> type.\n\ncs-i : cstep (capp i X) X.\ncs-k : cstep (capp (capp k X) Y) X.\ncs-s : cstep (capp (capp (capp s X) Y) Z) (capp (capp X Z) (capp Y Z)).\n\ncs-1 : cstep (capp X Y) (capp X' Y)\n        <- cstep X X'.\n\ncs-2 : cstep (capp X Y) (capp X Y')\n        <- cstep Y Y'.\n\n%{\nWe also define multi-step reduction on combinator terms.\n\nOur simulation will relate single-step derivations in the lambda-calculus\nto multi-step derivations on the translated terms.\n}%\n\ncstep* : cterm -> cterm -> type.\n\ncs-cons : cstep* N N''\n           <- cstep N N'\n           <- cstep* N' N''.\n\ncs-nil  : cstep* N N.\n\n\n%{\nWe can pre-emptively prove some compatibility lemmas about multi-step\nreduction.\n}%\n\ncs-1* : cstep* N1 N1' -> cstep* (capp N1 N2) (capp N1' N2) -> type.\n%mode +{N1:cterm} +{N1':cterm} +{N2:cterm}\n      +{CS1:cstep* N1 N1'} -{CS2:cstep* (capp N1 N2) (capp N1' N2)}\n      (cs-1* CS1 CS2).\n\n- : cs-1* cs-nil cs-nil.\n- : cs-1* (cs-cons CS C) (cs-cons CS' (cs-1 C))\n     <- cs-1* CS CS'.\n\n%worlds () (cs-1* _ _).\n%total {CS} (cs-1* CS _).\n\ncs-2* : cstep* N2 N2' -> cstep* (capp N1 N2) (capp N1 N2') -> type.\n%mode +{N1:cterm} +{N2:cterm} +{N2':cterm}\n      +{CS1:cstep* N2 N2'} -{CS2:cstep* (capp N1 N2) (capp N1 N2')}\n      (cs-2* CS1 CS2).\n\n- : cs-2* cs-nil cs-nil.\n- : cs-2* (cs-cons CS C) (cs-cons CS' (cs-2 C))\n     <- cs-2* CS CS'.\n\n%worlds () (cs-2* _ _).\n%total {CS} (cs-2* CS _).\n\ncs-trans : cstep* N1 N2 -> cstep* N2 N3 -> cstep* N1 N3 -> type.\n%mode cs-trans +Cs1 +Cs2 -Cs3.\n\n- : cs-trans cs-nil Cs2 Cs2.\n- : cs-trans (cs-cons Cs1 C) Cs2 (cs-cons Cs12 C)\n     <- cs-trans Cs1 Cs2 Cs12.\n\n%worlds () (cs-trans _ _ _).\n%total {Cs} (cs-trans Cs _ _).\n\n%{ ---- }%\n\n%{\nWe can now define our translation in the standard way.  Bracket abstraction\nis represented by a judgement relating LF-level abstractions in the combinator\nlanguage to closed combinator terms.  This is essentially \n[[higher-order abstract syntax]].\n}%\n\ntrans : term -> cterm -> type.\nbracket : (cterm -> cterm) -> cterm -> type.\n\n\nt-app : trans (app M1 M2) (capp N1 N2)\n         <- trans M1 N1\n         <- trans M2 N2.\n\nt-lam : trans (lam [x] M x) N'\n         <- ({x:term} {y:cterm} trans x y -> trans (M x) (N y))\n         <- bracket ([y] N y) N'.\n\n\nb-i : bracket ([x] x) i.\n\nb-k : bracket ([x] Y) (capp k Y).\n\nb-s : bracket ([x] capp (N1 x) (N2 x)) (capp (capp s N1') N2')\n       <- bracket ([x] N1 x) N1'\n       <- bracket ([x] N2 x) N2'.\n\n%{ ---- }%\n\n%{\nFirst, we prove the correctness of bracket abstraction itself:\nthe application of a bracket abstraction reduces to a substitution.\n}%\n\nsubst : bracket ([x] N x) N' -> {N0} cstep* (capp N' N0) (N N0) -> type.\n%mode subst +B +N0 -CS.\n\n- : subst b-i N0 (cs-cons cs-nil cs-i).\n\n- : subst b-k N0 (cs-cons cs-nil cs-k).\n\n% developing incrementally, it's useful to write down the type of each output\n- : subst (b-s (B2 : bracket ([x] N2 x) N2')\n               (B1 : bracket ([x] N1 x) N1'))\n          N0\n          (cs-cons CS12' cs-s)\n     <- subst B1 N0 (CS1 : cstep* (N1' @@ N0) (N1 N0))\n     <- subst B2 N0 (CS2 : cstep* (N2' @@ N0) (N2 N0))\n     <- cs-1* CS1 (CS1' : cstep* ((N1' @@ N0) @@ (N2' @@ N0)) (N1 N0 @@ (N2' @@ N0)))\n     <- cs-2* CS2 (CS2' : cstep* (N1 N0 @@ (N2' @@ N0)) (N1 N0 @@ N2 N0))\n     <- cs-trans CS1' CS2' CS12'.\n\n% turns out that once the case is done, the types are unnecessary!\n%%- : subst (b-s B2 B1) N0 (cs-cons CS12' cs-s)\n%%     <- subst B1 N0 CS1\n%%     <- subst B2 N0 CS2\n%%     <- cs-1* CS1 CS1'\n%%     <- cs-2* CS2 CS2'\n%%     <- cs-trans CS1' CS2' CS12'.\n\n%worlds () (subst _ _ _).\n%total {B} (subst B _ _).\n\n%{\nThen, we can prove simulation, the correctness of translation, by a\nstraightforward induction on single-step derivations in the lambda-calculus,\nusing the correctness of bracket abstraction as a lemma in the case of a\nbeta-reduction.\n}%\n\nsimulate : step M M' -> trans M N -> trans M' N' -> cstep* N N' -> type.\n%mode simulate +S +T -T' -CS.\n\n%{\nNB: in this step, on paper, you have to prove two compositionality lemmas.\nIn Twelf, using higher-order abstract syntax, we get them for free -- see\n(T1 _ _ T2) output.\n}%\n- : simulate s-β (t-app T2 (t-lam B1 T1)) (T1 _ _ T2) CS\n     <- subst B1 N2 CS.\n\n- : simulate (s-1 S1) (t-app T2 T1) (t-app T2 T1') CSapp\n     <- simulate S1 T1 T1' CS1\n     <- cs-1* CS1 CSapp.\n\n- : simulate (s-2 S2) (t-app T2 T1) (t-app T2' T1) CSapp\n     <- simulate S2 T2 T2' CS2\n     <- cs-2* CS2 CSapp.\n\n%worlds () (simulate _ _ _ _).\n%total D (simulate D _ _ _)."
          },
          "sha1": "ke98q91p3xl310txamkhyryxmadqkqr"
        }
      },
      {
        "title": "CADE Tutorial",
        "ns": 0,
        "id": 2381,
        "revision": {
          "id": 7938,
          "parentid": 7937,
          "timestamp": "2013-06-10T12:41:28Z",
          "contributor": {
            "username": "Carsten",
            "id": 38
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 2980,
            "#text": "<!--\n<div style=\"font-size:162%;border:none;margin: 0;padding:.1em;color:#F00\">'''''We want your input!'''''</div>\n\nHelp us out by filling out our handy dandy [http://spreadsheets.google.com/viewform?key=pff4VF1v6KVNcwC_c2qFAGA feedback form]!\n-->\n\n== Mechanizing Metatheory with LF and Twelf ==\n\nDo you want to learn how to use [[Main page|Twelf]] to specify, implement, and prove\nproperties about programming languages?  \n\nCome to the Twelf tutorial on '''June 10, 2013, 9:00-12:30''', co-located with CADE 2013, in\n'''Lake Placid, New York'''.  Location \"Mirror Lake\" in  The Crowne Plaza Resort.\n\nLearn to:\n* Represent [[deductive systems|languages and logics]] in [[LF]]\n* Prove [[metatheorem]]s with [[Main page|Twelf]]\nunder the helpful guidance of Twelf experts.  \n\nThe tutorial will be a highly interactive introduction to LF and Twelf\naimed at programming languages researchers. No prior experience with LF\nand Twelf is presumed.  Participants will leave the workshop with\nexperience in reading and writing LF representations of programming\nlanguages, and experience reading, writing, and debugging Twelf proofs.\n                                                                                                                                                            \nThe tutorial is organized and jointly presented by the the IT University of Copenhagen and the CMU  Principles of Programming group.  The presenters and TAs at CADE will be Taus Brock-Nannestad, Chris Martens, and Carsten Schürmann.\n\n== Schedule ==\n\nThe tutorial will begin at '''9:00AM'''. Get [http://www.demtech.dk/raw-attachment/wiki/News/lectures.pdf the slides]!\n\n* Part 1: [[CADE_Tutorial/Basics|Basic Twelf Skills]] \n* Part 2: [[CADE_Tutorial/MinML|Mechanizing MinML]]\n* Part 3: [[CADE_Tutorial/Combinators|Combinators: Worlds and Adequacy]]\n* Coda: [[CADE_Tutorial/Next|What's next?]]\n\nThere will be a coffee break at 10:30AM.\n\n== Get Twelf before the tutorial! ==\n\nThe tutorial will be interactive, with participants writing Twelf code, so you should come with Twelf installed on your laptop.\n\nPre-built binaries of Twelf are available for most operating systems: see the [[Download|download page]].\n\nOtherwise:\n* you can build Twelf from the [http://twelf.plparty.org/builds/twelf-src.tar.gz source tarball].  You will need [http://www.mlton.org MLton] or [http://www.smlnj.org sml/nj]. \n* you can make yourself an account on the wiki, and do the exercises on your User:<login> page (linked at the top after you log in).\n\nThen see [[Twelf with Emacs]] for the basics of interacting with Twelf.  (You can also use [[Twelf without Emacs]], by interacting with the Twelf server directly.)\n\n== Sponsors ==\n\nThanks to our sponsors: \n[http://www.cs.cmu.edu Carnegie Mellon School of Computer Science],\n[http://www.demtech.dk DemTech Project],\n[http://www.itu.dk IT University of Copenhagen],\n\n[[Image:POPL_Tutorial-cmu.gif|250px]] [[Image:POPL_Tutorial-scslogo.gif]]\n[[Image:demtech.png|100px]]"
          },
          "sha1": "i62xidxn09vnky2z4jrzhfzj1evdzp7"
        }
      },
      {
        "title": "CADE Tutorial/Basic error messages",
        "ns": 0,
        "id": 2385,
        "revision": {
          "id": 7921,
          "timestamp": "2013-06-09T19:25:07Z",
          "contributor": {
            "username": "Carsten",
            "id": 38
          },
          "comment": "Created page with \"==How Twelf checks assertions==  Twelf proves a totality assertion for a type family such as <tt>mult</tt> by checking several properties.  These properties, taken together, cons...\"",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 9399,
            "#text": "==How Twelf checks assertions==\n\nTwelf proves a totality assertion for a type family such as\n<tt>mult</tt> by checking several properties.  These properties, taken\ntogether, constitute a proof by induction on canonical forms that the\ntype family defines a total relation.\n\n===Running Example ===\n\nWe'll start from the following code:\n\n<twelf import=\"base\">\nnat : type.  \nzero : nat.\nsucc : nat -> nat.\n\nadd : nat -> nat -> nat -> type.\n%mode add +M +N -P.\n\nadd/z : add zero N N.\nadd/s : add (succ M) N (succ P) \n\t <- add M N P.\n\n%worlds () (add _ _ _).\n%total M (add M _ _).\n</twelf>\n\n<twelf import=\"base\" export=\"mult\">\nmult : nat -> nat -> nat -> type.\n%mode mult +M +N -P.\n\nmult/z : mult zero N zero.\nmult/s : mult (succ M) N P'\n\t  <- mult M N P\n\t  <- add N P P'.\n</twelf>\n\n===Mode=== \n\nTwelf checks that each constant inhabiting the type family is\n''well-moded''.  Roughly, this means that the inputs to the conclusion\nof a constant determine the inputs of the first premise, and that these\ntogether with the outputs of the first premise determine the inputs of\nthe second premise, and so on, until the outputs of all the premises\ndetermine the outputs of the conclusion.\nFor example, the constant\n<twelf import=\"mult\" discard=true>\nmult/s : mult (succ M) N P'\n\t  <- mult M N P\n\t  <- add N P P'.\n</twelf>\n\nhas mode <tt>+M +N -P</tt> because the input <tt>M</tt> and <tt>N</tt>\nin the conclusion determine the inputs of the premise, and the\n<tt>P</tt> output by the premise determines the first input to the second\npremise (add), and the output of that determines the conclusion.  \nOn the other hand, a constant\n\n<twelf import=\"mult\" check=decl discard=true>\nmult/bad-mode-output : mult zero N P.\n</twelf>\nis not well-moded---the output <tt>P</tt> is not determined by the\ninputs.  Similarly, \n<twelf import=\"mult\" check=decl discard=true>\nmult/bad-mode-input : mult (succ M) N zero\n \t\t       <- mult M Q P.\n</twelf> \nis not well-moded---the second input to the premise is not determined\nby the inputs of the conclusion.\n\nNote that subgoal order matters: \n\n<twelf import=\"mult\" check=decl discard=true>\nmult/s : mult (succ M) N Q\n\t  <- add P N Q\n\t  <- mult M N P.\n</twelf>\n\nThe premises are mode-checked in order; the outputs from one subgoal are\nconsider ground in subsequent premises.\n\n===Worlds===\n\nTwelf checks that each constant inhabiting the type family obeys the\nworlds declaration.  Because we are only proving theorems about closed\nterms right now, we will not run across any problems with world\nchecks.  \n\n===Termination===\n\nTwelf checks that each constant inhabiting the type family obeys the\ninduction order specified in the <tt>%total</tt> declaration.  In each\ninductive premise of a constant, the specified induction position must\nbe a strict subterm of the corresponding argument in the conclusion.\nFor example, the constant\n\n<twelf import=\"mult\" discard=true>\nmult/s : mult (s M) N Q\n\t  <- mult M N P\n\t  <- add P N Q.\n</twelf>\nobeys the induction order <tt>M</tt> specified in the above totality\nassertion because the term <tt>M</tt> is a strict subterm of the term\n<tt>(s M)</tt>.\n\nRecuring on exactly the same term is obviously a termination error:\n<twelf import=\"mult\" check=decl discard=true>\nmult/bad-termination-1 : mult M N P\n\t\t\t  <- mult M N P.\n%total M (mult M _ _).\n</twelf>\n\nAs is recuring on an entirely unrelated argumenet:\n\n<twelf import=\"mult\" check=decl discard=true>\nmult/bad-termination-2 : mult M N P\n\t\t\t  <- mult N N P.\n%total M (mult M _ _).\n</twelf>\n\nFor example Twelf would not accept the totality of <tt>mult</tt>\nif <tt>N</tt> were used as the induction order&mdash;the same term\n<tt>N</tt> in the conclusion of this constant appears in the premise:\n\n<twelf import=\"mult\" check=decl discard=true>\n%total N (mult _ N _).\n</twelf>\n\nIn addition to the subterm ordering on a single argument, Twelf supports\n[[mutual induction]] and [[lexicographic induction]].\n\n===Output coverage===\n\nIn the definition of a type family, you may pattern-match the outputs of\na premise.  For example, we might write\n<twelf import=\"mult\" check=decl discard=true>\nmult/bad-output-cov : mult (succ M) N zero\n\t\t       <- mult M N (succ P).\n%worlds () (mult _ _ _).\n%total N1 (mult N1 N2 N3).\n</twelf>\n\nHere we have insisted that the output of the premise has the form\n<tt>succ P</tt> for some <tt>P</tt>.  Twelf correctly reports an output\ncoverage error because this condition can fail.\n\nPattern-matching the output of a premise is like an [[inversion]] step\nin a proof: you're insisting that the premise derivation must conclude a\nparticular fact that is more specific than the judgement form itself.\nFor Twelf to accept a relation as total, Twelf must notice that all of\nthese inversions are permissible.  Twelf permits such inversions when it\nis readily apparent that they are justified, and those inversions that\nTwelf does not accept can be proved explicitly.\n\nIn this example, we got an output coverage error because we constrained\nthe output of the premise by insisting it be formed by a particular\nconstant.  The other way to get output coverage errors is to insist that\nthe output of a premise be a variable that occurs elsewhere in the type.\nFor example:\n\n<twelf import=\"mult\" check=decl discard=true>\nmult/bad-output-free : mult (succ M) N zero\n\t\t\t<- mult M N N.\n%worlds () (mult _ _ _).\n%total N1 (mult N1 N2 N3).\n</twelf>\n\nHere, we insisted that the output of the premise be the number\n<tt>N</tt> that we put in.  Twelf is very conservative in checking\n[[output freeness]]: a type family will not be judged total if you\nconstrain the outputs of any premise at all in this manner.\n\n===Input coverage===\n\nMode, worlds, termination, and output coverage ensure that each constant\nreally does cover the part of the relation indicated by its conclusion.\nFor example, if <tt>mult</tt> passes these four checks, we know that\n<tt>mult/z</tt> and <tt>mult/s</tt> cover <tt>(zero, N, _)</tt> and <tt>(succ M,\nN, _)</tt>, respectively.  What else is necessary to know that\n<tt>mult</tt> defines a total relation?  We need to know that all the\nconstants inhabiting <tt>mult</tt>, taken together, cover all of the\ninputs.  Input coverage checks exactly this.\n\nFor example, if we forgot <tt>mult/z</tt>, input coverage for\n<tt>mult</tt> would fail.  For example:\n\n<twelf import=\"base\" check=decl discard=true>\nmult' : nat -> nat -> nat -> type.\n%mode mult' +N1 +N2 -X3.\n\nmult'/s : mult' (succ M) N Q\n\t  <- mult' M N P\n\t  <- add P N Q.\n\n%worlds () (mult' _ _ _).\n%total M (mult' M _ _).\n</twelf>\n\nHere's an analogy that might be helpful: You can think of each constant\nof a type as being a clause in an ML pattern matching declaration.  Then\ninput coverage is like the exhaustiveness checker for pattern matching.\n\nTwelf checks input coverage by [[splitting]] the input types to\ncase-analyze the various constants that could have been used to inhabit\nthem.  For <tt>add</tt>, Twelf splits the first <tt>nat</tt> argument\n<tt>M</tt>, and then checks that the cases <tt>plus z N N</tt> and\n<tt>add (succ M) N P</tt> are covered.  Fortunately, these are exactly\nthe cases we wrote down.  If we had case-analyzed further in the\ndefinition of the judgement (e.g., if the definition of <tt>plus</tt>\ncase-analyzed the second argument as well), Twelf would continue\nsplitting the input space.  Because Twelf separates termination checking\nand coverage checking, the constants defining a type family do not need\nto follow any particular primitive recursion schema-the constants may\npattern-match the inputs in a general manner.\n\n==When Twelf checks what==\n\nTo a first approximation, you can think of the <tt>%mode</tt> and <tt>%worlds</tt> declarations as specifying a totality assertion and the <tt>%total</tt> declaration as checking it.  This isn't exactly how Twelf works, though:\n\n# When a <tt>%mode</tt> declaration is entered, Twelf checks that all previous constants inhabiting the specified type family are well-moded; further, it then mode-checks any subsequent constants inhabiting that family.  \n# When a <tt>%worlds</tt> declaration is entered, Twelf world-checks the type family; further, it then reports an error if any new constants contributing to the family at all are added.\n# When a <tt>%total</tt> declaration is entered, Twelf checks termination, then input coverage, then output coverage.  When checking output coverage, Twelf checks for unjustified constant pattern-matching in a first pass and then output freeness problems in a second pass.\n\nThis separation allows you to, for example, check that each constant in a family is well-moded (i.e., takes specified inputs to specified outputs) without checking that the entire type family is total.  You can also use the declarations [[%terminates]] and [[%covers]] to check termination and input coverage independently.\n\nIf any constant in a type family fails mode, worlds, or output coverage, then mode, worlds, or totality checking fails for the whole type family.  One could imagine that Twelf instead would just disregard the offending constant: it is possible that the type family as a whole satisfies a totality assertion without that constant, and, in a mathematical sense, adding additional constants never invalidates the fact a totality assertion is true of a family.    The reason Twelf does not work this way is that <tt>%total</tt> actually has a more specific meaning, as we discuss in the next section."
          },
          "sha1": "6eusoegqax55kmlqc0bp3wt5am24t91"
        }
      },
      {
        "title": "CADE Tutorial/Basics",
        "ns": 0,
        "id": 2384,
        "revision": {
          "id": 7939,
          "parentid": 7923,
          "timestamp": "2013-06-10T12:42:42Z",
          "contributor": {
            "username": "Carsten",
            "id": 38
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 130,
            "#text": "* [[CADE Tutorial/Basic error messages|Examples of basic error messages]]\n* [[CADE Tutorial/Basics Answer|Solutions to exercises]]"
          },
          "sha1": "261ntr5xm796yqungchz21i12wt1fl6"
        }
      },
      {
        "title": "CADE Tutorial/Basics Answer",
        "ns": 0,
        "id": 2386,
        "revision": {
          "id": 7922,
          "timestamp": "2013-06-09T19:25:35Z",
          "contributor": {
            "username": "Carsten",
            "id": 38
          },
          "comment": "Created page with \"%{   == Natural numbers ==  }%  nat : type.  zero : nat. succ : nat -> nat.  %{  == Addition ==  }%  add : nat -> nat -> nat -> type.  add/z : add zero N N.  add/s : add (succ M)...\"",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 2450,
            "#text": "%{ \n\n== Natural numbers ==\n\n}%\n\nnat : type.\n\nzero : nat.\nsucc : nat -> nat.\n\n%{\n\n== Addition ==\n\n}%\n\nadd : nat -> nat -> nat -> type.\n\nadd/z : add zero N N.\n\nadd/s : add (succ M) N (succ P)\n\t <- add M N P.\n\n%{\n\n=== Example derivations ===\n\n}%\n\n1 : nat = succ zero.\n2 : nat = succ 1.\n1+1is2 : add 1 1 2 = add/s (add/z).\n\n%% explicit version of add/z\n%% add/z-explicit  : {n:nat} add zero n n.\n%% 1+1is2-explicit : add 1 1 2 = add/s (add/z-explicit 1).\n\n%{\n\n== Exercise: Multiplication ==\n\n}%\n\nmult : nat -> nat -> nat -> type.\n\nmult/z : mult zero N zero.\n\nmult/s : mult (succ M) N P'\n\t  <- mult M N P\n\t  <- add N P P'.\n\n%% note that the arguments are \"backwards\"\n1*2is2 : mult 1 2 2 = mult/s (add/s (add/s add/z)) mult/z.\n\n%{\n\n== Mode, worlds total ==\n\n}%\n\n%mode add +M +N -P.\n%worlds () (add _ _ _).\n%total M (add M _ _).\n\n%solve 1+1is2' : add 1 1 N.\n\n%% Examples of errors:\n%% \n%% mult/bad-mode-output : mult zero N Q.\n%% \n%% mult/bad-mode-input : mult (succ M) N zero\n%% \t\t       <- mult M Q P.\n%% \n%% %% do input coverage by removing cases\n%% \n%% mult/bad-termination-1 : mult M N P\n%% \t\t\t  <- mult M N P.\n%% mult/bad-termination-2 : mult M N P\n%% \t\t\t  <- mult N N P.\n%% \n%% mult/bad-output-free : mult (succ M) N zero\n%% \t\t\t<- mult M N N.\n%% mult/bad-output-cov : mult (succ M) N zero\n%% \t\t       <- mult M N (succ P).\n\n%mode mult +M +N -P.\n%worlds () (mult _ _ _).\n%total M (mult M _ _).\n\n%{\n\n== Right-hand zero ==\n\n}%\n\nrhzero : {M : nat} add M zero M -> type.\n%mode rhzero +M -D.\n\n- : rhzero zero add/z.\n- : rhzero (succ M) (add/s D)\n     <- rhzero M (D : add M zero M).\n     \n%worlds () (rhzero _ _).\n%total M (rhzero M _).\n\n%{\n\n== Right-hand succ ==\n\n}%\n\nrhsucc : add M N P -> add M (succ N) (succ P) -> type.\n%mode rhsucc +D1 -D2.\n\n- : rhsucc (add/z : add zero M M) (add/z : add zero (succ M) (succ M)).\n- : rhsucc (add/s (D1 : add M N P)) (add/s D2)\n     <- rhsucc D1 (D2 : add M (succ N) (succ P)).\n\n%% remark that type annotations are optional:\n%% - : rhsucc add/z add/z.\n%% - : rhsucc (add/s D1) (add/s D2)\n%%      <- rhsucc D1 D2.\n     \n%worlds () (rhsucc _ _).\n%total M (rhsucc M _).\n\n%{\n\n== Exercise: addition is commutative ==\n\n}%\n\ncommute : add M N P -> add N M P -> type.\n%mode commute +D1 -D2.\n\n- : commute (add/z : add zero M M) D\n     <- rhzero M D.\n\n- : commute (add/s (D : add M N P)) D''\n     <- commute D  (D' : add N M P)\n     <- rhsucc D' (D'' : add N (succ M) (succ P)).\n\n%worlds () (commute _ _).\n%total D (commute D _)."
          },
          "sha1": "1du2ian8rdknyotmllfz2ure861ec84"
        }
      },
      {
        "title": "CADE Tutorial/Combinators",
        "ns": 0,
        "id": 2390,
        "revision": {
          "id": 7931,
          "parentid": 7928,
          "timestamp": "2013-06-09T19:31:39Z",
          "contributor": {
            "username": "Carsten",
            "id": 38
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 127,
            "#text": "* [[CADE Tutorial/Combinators Support|Support code]] \n* [[CADE Tutorial/Combinators Answer|Solutions to interactive exercises]]"
          },
          "sha1": "289r63dngir9zladbhgxthx7b22lhfi"
        }
      },
      {
        "title": "CADE Tutorial/Combinators Answer",
        "ns": 0,
        "id": 2392,
        "revision": {
          "id": 7930,
          "timestamp": "2013-06-09T19:31:22Z",
          "contributor": {
            "username": "Carsten",
            "id": 38
          },
          "comment": "Created page with \"%{ Adapted from the case study on [[Typed combinators soundness and completeness]].  == Syntax ==  }%  % lambda calculus  term : type.                    %name term M x.  app : t...\"",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 4024,
            "#text": "%{\nAdapted from the case study on [[Typed combinators soundness and completeness]].\n\n== Syntax ==\n\n}%\n\n% lambda calculus\n\nterm : type.                    %name term M x.\n\napp : term -> term -> term.\nlam : (term -> term) -> term.\n\n%block term-block : block {x:term}.\n%worlds (term-block) (term).\n\n% combinator calculus\n\ncomb : type.                    %name comb A y.\n\ns : comb.\nk : comb.\ni : comb.\ncapp : comb -> comb -> comb.\n\n%block comb-block : block {y:comb}.\n%worlds (comb-block) (comb).\n\n%{\n\n== Translation ==\n\n}%\n\n% bracket abstraction\n\nbracket : (comb -> comb) -> comb -> type.\n%mode bracket +A -A'.\n\nbracket/var : bracket ([y] y) i.\n\nbracket/i : bracket ([y] i) (capp k i).\nbracket/k : bracket ([y] k) (capp k k).\nbracket/s : bracket ([y] s) (capp k s).\n\nbracket/app : bracket ([y] capp (A y) (B y)) (capp (capp s A') B')\n               <- bracket ([y] A y) A'\n               <- bracket ([y] B y) B'.\n\n%block bracket-block : block {y:comb} {bracket/y:bracket ([z] y) (capp k y)}.\n\n%worlds (bracket-block) (bracket _ _).\n%total A (bracket A _).\n\n\n% translation\n\ntranslate : term -> comb -> type.\n%mode translate +M -A.\n\ntranslate/app : translate (app M N) (capp A B)\n                 <- translate M A\n                 <- translate N B.\n\ntranslate/lam : translate (lam ([x] M x)) A'\n                 <- ({x} {y} bracket ([z] y) (capp k y)\n                            -> translate x y\n                            -> translate (M x) (A y))\n                 <- bracket ([y] A y) A'.\n\n%block translate-block\n        : block {x:term} {y:comb}\n                {bracket/y: bracket ([z] y) (capp k y)}\n                {translate/x: translate x y}.\n%worlds (translate-block) (translate _ _).\n%total M (translate M _).\n\n%{\n\n== Equational theory ==\n\n}%\n\n% lambda term equality\n\nteq : term -> term -> type.\n\n% beta\nteq/beta : teq (app (lam ([x] M x)) N) (M N).\n\n% extensionality (eta)\nteq/ext : teq M M'\n           <- ({x:term} teq (app M x) (app M' x)).\n\n% compatibilities\nteq/app : teq (app M N) (app M' N')\n           <- teq M M'\n           <- teq N N'.\n\nteq/lam : teq (lam ([x] M x)) (lam ([x] M' x))\n           <- ({x:term} teq (M x) (M' x)).\n\n% equivalence\nteq/refl : teq M M.\n\nteq/symm : teq M M'\n            <- teq M' M.\n\nteq/trans : teq M M'\n             <- teq M N\n             <- teq N M'.\n\n%worlds (term-block) (teq _ _).\n\n\n% combinator equality\n\nceq : comb -> comb -> type.\n\n% betas\nceq/i : ceq (capp i A) A.\nceq/k : ceq (capp (capp k A) B) A.\nceq/s : ceq (capp (capp (capp s A) B) C) (capp (capp A C) (capp B C)).\n\n% extensionality\nceq/ext : ceq A A'\n           <- ({y:comb} ceq (capp A y) (capp A' y)).\n\n% compatibility\nceq/app : ceq (capp A B) (capp A' B')\n           <- ceq A A'\n           <- ceq B B'.\n\n% equivalence\nceq/refl : ceq A A.\n\nceq/symm : ceq A A'\n            <- ceq A' A.\n\nceq/trans : ceq A A'\n             <- ceq A B\n             <- ceq B A'.\n\n%worlds (comb-block) (ceq _ _).\n\n\n\n%{\n\n== Correctness of the translation ==\n\n}%\n\n% substitution lemma\n\nsubst : bracket ([y] A y) A' -> {C:comb} ceq (capp A' C) (A C) -> type.\n%mode subst +Dbrack +C -Dceq.\n\n- : subst (bracket/var : bracket ([y] y) i)\n          C\n          (ceq/i : ceq (capp i C) C).\n\n- : subst (bracket/i : bracket ([y] i) (capp k i))\n          C\n          (ceq/k : ceq (capp (capp k i) C) i).\n\n- : subst (bracket/k : bracket ([y] k) (capp k k))\n          C\n          (ceq/k : ceq (capp (capp k k) C) k).\n\n- : subst (bracket/s : bracket ([y] s) (capp k s))\n          C\n          (ceq/k : ceq (capp (capp k s) C) s).\n\n- : subst (bracket/app (Dbrack2 : bracket ([y] B y) B')\n                       (Dbrack1 : bracket ([y] A y) A'))\n          C\n          (ceq/trans\n              (ceq/app Dceq2 Dceq1)\n              ceq/s)\n     <- subst Dbrack1 C (Dceq1 : ceq (capp A' C) (A C))\n     <- subst Dbrack2 C (Dceq2 : ceq (capp B' C) (B C)).\n\n%block subst-block : block {y:comb} {dbrack: bracket ([z] y) (capp k y)}\n                           {thm-subst: {C:comb} subst dbrack C ceq/k}.\n%worlds (subst-block) (subst _ _ _).\n%total D (subst D _ _)."
          },
          "sha1": "1l3c3gdz8uki4ilmqtish4j1lp645op"
        }
      },
      {
        "title": "CADE Tutorial/Combinators Support",
        "ns": 0,
        "id": 2391,
        "revision": {
          "id": 7929,
          "timestamp": "2013-06-09T19:31:02Z",
          "contributor": {
            "username": "Carsten",
            "id": 38
          },
          "comment": "Created page with \"%{ Adapted from the case study on [[Typed combinators soundness and completeness]].  == Syntax ==  }%  % lambda calculus  term : type.                    %name term M x.  app : t...\"",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 1215,
            "#text": "%{\nAdapted from the case study on [[Typed combinators soundness and completeness]].\n\n== Syntax ==\n\n}%\n\n% lambda calculus\n\nterm : type.                    %name term M x.\n\napp : term -> term -> term.\nlam : (term -> term) -> term.\n\n\n% combinator calculus\n\ncomb : type.                    %name comb A y.\n\ns : comb.\nk : comb.\ni : comb.\ncapp : comb -> comb -> comb.\n\n\n\n%{\n\n== Translation ==\n\n}%\n\n% bracket abstraction\n% XXX fill in\n\n% translation\n% XXX fill in\n\n\n%{\n\n== Equational theory ==\n\n}%\n\n% lambda term equality\n\n% (elided)\n\n% combinator equality\n\nceq : comb -> comb -> type.\n\n% betas\nceq/i : ceq (capp i A) A.\nceq/k : ceq (capp (capp k A) B) A.\nceq/s : ceq (capp (capp (capp s A) B) C) (capp (capp A C) (capp B C)).\n\n% extensionality\nceq/ext : ceq A A'\n           <- ({y:comb} ceq (capp A y) (capp A' y)).\n\n% compatibility\nceq/app : ceq (capp A B) (capp A' B')\n           <- ceq A A'\n           <- ceq B B'.\n\n% equivalence\nceq/refl : ceq A A.\n\nceq/symm : ceq A A'\n            <- ceq A' A.\n\nceq/trans : ceq A A'\n             <- ceq A B\n             <- ceq B A'.\n\n%block comb-block : block {y:comb}.\n%worlds (comb-block) (ceq _ _).\n\n%{\n\n== Correctness of the translation ==\n\n}%\n\n% substitution lemma\n% XXX fill in"
          },
          "sha1": "7jnwtsm1ldzuid2bn5pp9zm8ii9mvqg"
        }
      },
      {
        "title": "CADE Tutorial/MinML",
        "ns": 0,
        "id": 2387,
        "revision": {
          "id": 7940,
          "parentid": 7927,
          "timestamp": "2013-06-10T12:43:12Z",
          "contributor": {
            "username": "Carsten",
            "id": 38
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 144,
            "#text": "* [[CADE Tutorial/MinML encoding| MinML Syntax and judgments---the code we just wrote]] \n* [[CADE Tutorial/MinML Answer|Solutions to exercises]]"
          },
          "sha1": "k0j5kzcl52cirjssogw3gp2nl6k5gqr"
        }
      },
      {
        "title": "CADE Tutorial/MinML Answer",
        "ns": 0,
        "id": 2389,
        "revision": {
          "id": 7926,
          "timestamp": "2013-06-09T19:28:50Z",
          "contributor": {
            "username": "Carsten",
            "id": 38
          },
          "comment": "Created page with \"%{  == Syntax ==  }%  tp : type.\t\t\t\t%name tp T. num : tp. arr : tp -> tp -> tp.  %% you can world-check syntax if you want %worlds () (tp).  exp : type.\t\t\t\t%name exp E. fn : tp -...\"",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 4400,
            "#text": "%{\n\n== Syntax ==\n\n}%\n\ntp : type.\t\t\t\t%name tp T.\nnum : tp.\narr : tp -> tp -> tp.\n\n%% you can world-check syntax if you want\n%worlds () (tp).\n\nexp : type.\t\t\t\t%name exp E.\nfn : tp -> (exp -> exp) -> exp.\napp : exp -> exp -> exp.\nz : exp.\ns : exp -> exp.\n\n%{\n==== Exercise: constant for ifz ====\n}%\n\nifz : exp -> exp -> (exp -> exp) -> exp.\n\n%% you can world-check syntax if you want\n%block exp_block : block {x:exp}.\n%worlds (exp_block) (exp).\n\n%{\n\n== Static semantics ==\n\n}%\n\nof : exp -> tp -> type.                %name of Dof.\n\nof/z : of z num.\n\nof/app : of (app E1 E2) T\n\t  <- of E1 (arr T' T)\n\t  <- of E2 T'.\n\nof/fn : of (fn T1 ([x] E x)) (arr T1 T2)\n\t <- ({x:exp} of x T1 -> of (E x) T2).\n\n%{ \n==== Exercise: typing rules for s and ifz ====\n}%\n\nof/s : of (s E) num\n\t<- of E num.\n\nof/ifz : of (ifz E E0 ([x] E1 x)) T\n\t  <- of E num\n\t  <- of E0 T\n\t  <- ({x:exp} of x num -> of (E1 x) T).\n\n%block of_block : some {T:tp} block {x:exp}{dx: of x T}.\n%worlds (of_block) (of _ _).\n\n%{\n\n== Dynamic semantics ==\n\n=== value judgement ===\n\n\n}%\n\nvalue : exp -> type.               %name value Dval.\n\nvalue/fn : value (fn T ([x] E x)).\n%{ \n==== Exercise: value rules for z and s ====\n}%\nvalue/z  : value z.\nvalue/s  : value (s E)\n\t    <- value E.\n\n%{\n\n=== step judgement ===\n\n}%\n\nstep : exp -> exp -> type.        %name step Dstep.\n\nstep/app/fn : step (app E1 E2) (app E1' E2)\n\t       <- step E1 E1'.\n\nstep/app/arg : step (app E1 E2) (app E1 E2')\n\t\t<- value E1\n\t\t<- step E2 E2'.\n\nstep/app/beta : step (app (fn T ([x] E x)) E2) (E E2)\n\t\t <- value E2.\n\n%{ \n==== Exercise: step rules for s and ifz ====\n}%\n\nstep/s : step (s E) (s E')\n\t  <- step E E'.\n\nstep/ifz/arg : step (ifz E E0 ([x] E1 x)) (ifz E' E0 ([x] E1 x))\n\t\t<- step E E'.\n\nstep/ifz/z   : step (ifz z E0 ([x] E1 x)) E0.\n\nstep/ifz/s   : step (ifz (s E) E0 ([x] E1 x)) (E1 E)\n\t\t<- value E.\n\n%{ \n\n== Progress theorem ==\n\n=== Sum type for the result ===\n\n}%\n\nval-or-step : exp -> type.        %name val-or-step Dvos.\n\nvos/value : val-or-step E\n\t     <- value E.\nvos/step  : val-or-step E\n\t     <- step E E'.\n\n%{\n\n=== Lemmas ===\n\n}%\n\nprog/app : of E1 (arr T' T) \n\t    -> val-or-step E1\n\t    -> val-or-step E2\n\t    -> val-or-step (app E1 E2)\n\t    -> type.\n%mode prog/app +Dof +Dvos1 +Dvos2 -Dvos.\n\n- : prog/app \n     _ \n     (vos/step (Dstep1 : step E1 E1'))\n     _\n     (vos/step (step/app/fn Dstep1)).\n\n- : prog/app\n     _\n     (vos/value (Dval1 : value E1))\n     (vos/step (Dstep2 : step E2 E2'))\n     (vos/step (step/app/arg Dstep2 Dval1)).\n\n- : prog/app\n     (of/fn _ : of (fn T ([x] E' x)) (arr T T'))\n     (vos/value (Dval1 : value (fn T ([x] E' x))))\n     (vos/value (Dval2 : value E2))\n     (vos/step (step/app/beta Dval2)).\n\n%worlds () (prog/app _ _ _ _).\n%total {} (prog/app _ _ _ _).\n\n%{\n\n==== Exercise: lemma for s ====\n\n}%\n\nprog/s : val-or-step E -> val-or-step (s E) -> type.\n%mode prog/s +Dvos1 -Dvos2.\n\n- : prog/s\n     (vos/step (Dstep : step E E'))\n     (vos/step (step/s Dstep)).\n\n- : prog/s\n     (vos/value (Dval : value E))\n     (vos/value (value/s Dval)).\n\n%worlds () (prog/s _ _).\n%total {} (prog/s _ _).\n\n%{\n\n==== Exercise: lemma for ifz ====\n\n}%\n\nprog/ifz : of E num\n \t    -> {E0:exp} \n \t       {E1:exp -> exp}\n\t       val-or-step E\n\t    -> step (ifz E E0 ([x] E1 x)) E'\n\t    -> type.\n%mode prog/ifz +Dof +E0 +E1 \n+Dvos -Dstep.\n\n%mode prog/ifz +Dof +Dvos +E1 +E2 -Dstep.\n\n- : prog/ifz _ _ _ (vos/step Dstep) (step/ifz/arg Dstep).\n- : prog/ifz _ _ _ (vos/value value/z) step/ifz/z.\n- : prog/ifz _ _ _ (vos/value (value/s Dval)) (step/ifz/s Dval).\n\n%worlds () (prog/ifz _ _ _ _ _).\n%total {} (prog/ifz _ _ _ _ _).\n\n%{\n\n=== Main theorem ===\n\n}%\n\nprog : of E T -> val-or-step E -> type.\n%mode prog +Dof -Dvos.\n\n- : prog (of/z : of z num) (vos/value (value/z : value z)).\n\n- : prog (of/fn _) (vos/value value/fn).\n\n- : prog (of/app \n\t    (D2 : of E2 T') \n\t    (D1 : of E1 (arr T' T)))\n     DvosApp\n     <- prog D1 (Dvos1 : val-or-step E1)\n     <- prog D2 (Dvos2 : val-or-step E2)\n     <- prog/app D1 Dvos1 Dvos2 DvosApp.\n\n%{ \n\n==== Exercise: cases for s and ifz ====\n\n}%\n\n- : prog (of/s (D : of E num)) DvosS\n     <- prog D (Dvos : val-or-step E)\n     <- prog/s Dvos DvosS.\n\n- : prog (of/ifz ([x] [dx : of x num] (D1 x dx : of (E1 x) T)) \n\t    (D0 : of E0 T)\n\t    (D  : of E num))\n     (vos/step DstepIfz)\n     <- prog D (Dvos : val-or-step E)\n     <- prog/ifz D E0 ([x] E1 x) Dvos DstepIfz.\n\n%worlds () (prog _ _).\n%total Dof (prog Dof _)."
          },
          "sha1": "poeppwwl1bwxest6vcj5x7u7hgr2tf8"
        }
      },
      {
        "title": "CADE Tutorial/MinML encoding",
        "ns": 0,
        "id": 2388,
        "revision": {
          "id": 7925,
          "timestamp": "2013-06-09T19:28:20Z",
          "contributor": {
            "username": "Carsten",
            "id": 38
          },
          "comment": "Created page with \"%{  == Syntax ==  }%  tp : type.\t\t\t\t%name tp T. num : tp. arr : tp -> tp -> tp.  %% you can world-check syntax if you want %worlds () (tp).  exp : type.\t\t\t\t%name exp E. fn : tp -...\"",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 3323,
            "#text": "%{\n\n== Syntax ==\n\n}%\n\ntp : type.\t\t\t\t%name tp T.\nnum : tp.\narr : tp -> tp -> tp.\n\n%% you can world-check syntax if you want\n%worlds () (tp).\n\nexp : type.\t\t\t\t%name exp E.\nfn : tp -> (exp -> exp) -> exp.\napp : exp -> exp -> exp.\nz : exp.\ns : exp -> exp.\n\n%{\n==== Exercise: constant for ifz ====\n}%\n\nifz : exp -> exp -> (exp -> exp) -> exp.\n\n%% you can world-check syntax if you want\n%block exp_block : block {x:exp}.\n%worlds (exp_block) (exp).\n\n%{\n\n== Static semantics ==\n\n}%\n\nof : exp -> tp -> type.                %name of Dof.\n\nof/z : of z num.\n\nof/app : of (app E1 E2) T\n\t  <- of E1 (arr T' T)\n\t  <- of E2 T'.\n\nof/fn : of (fn T1 ([x] E x)) (arr T1 T2)\n\t <- ({x:exp} of x T1 -> of (E x) T2).\n\n%{ \n==== Exercise: typing rules for s and ifz ====\n}%\n\nof/s : of (s E) num\n\t<- of E num.\n\nof/ifz : of (ifz E E0 ([x] E1 x)) T\n\t  <- of E num\n\t  <- of E0 T\n\t  <- ({x:exp} of x num -> of (E1 x) T).\n\n%block of_block : some {T:tp} block {x:exp}{dx: of x T}.\n%worlds (of_block) (of _ _).\n\n%{\n\n== Dynamic semantics ==\n\n=== value judgement ===\n\n\n}%\n\nvalue : exp -> type.               %name value Dval.\n\nvalue/fn : value (fn T ([x] E x)).\n%{ \n==== Exercise: value rules for z and s ====\n}%\nvalue/z  : value z.\nvalue/s  : value (s E)\n\t    <- value E.\n\n%{\n\n=== step judgement ===\n\n}%\n\nstep : exp -> exp -> type.        %name step Dstep.\n\nstep/app/fn : step (app E1 E2) (app E1' E2)\n\t       <- step E1 E1'.\n\nstep/app/arg : step (app E1 E2) (app E1 E2')\n\t\t<- value E1\n\t\t<- step E2 E2'.\n\nstep/app/beta : step (app (fn T ([x] E x)) E2) (E E2)\n\t\t <- value E2.\n\n%{ \n==== Exercise: step rules for s and ifz ====\n}%\n\nstep/s : step (s E) (s E')\n\t  <- step E E'.\n\nstep/ifz/arg : step (ifz E E0 ([x] E1 x)) (ifz E' E0 ([x] E1 x))\n\t\t<- step E E'.\n\nstep/ifz/z   : step (ifz z E0 ([x] E1 x)) E0.\n\nstep/ifz/s   : step (ifz (s E) E0 ([x] E1 x)) (E1 E)\n\t\t<- value E.\n\n%{ \n\n== Progress theorem ==\n\n=== Sum type for the result ===\n\n}%\n\nval-or-step : exp -> type.        %name val-or-step Dvos.\n\nvos/value : val-or-step E\n\t     <- value E.\nvos/step  : val-or-step E\n\t     <- step E E'.\n\n%{\n\n=== Lemmas ===\n\n}%\n\nprog/app : of E1 (arr T' T) \n\t    -> val-or-step E1\n\t    -> val-or-step E2\n\t    -> val-or-step (app E1 E2)\n\t    -> type.\n%mode prog/app +Dof +Dvos1 +Dvos2 -Dvos.\n\n- : prog/app \n     _ \n     (vos/step (Dstep1 : step E1 E1'))\n     _\n     (vos/step (step/app/fn Dstep1)).\n\n- : prog/app\n     _\n     (vos/value (Dval1 : value E1))\n     (vos/step (Dstep2 : step E2 E2'))\n     (vos/step (step/app/arg Dstep2 Dval1)).\n\n- : prog/app\n     (of/fn _ : of (fn T ([x] E' x)) (arr T T'))\n     (vos/value (Dval1 : value (fn T ([x] E' x))))\n     (vos/value (Dval2 : value E2))\n     (vos/step (step/app/beta Dval2)).\n\n%worlds () (prog/app _ _ _ _).\n%total {} (prog/app _ _ _ _).\n\n%{\n\n==== Exercise: lemma for s ====\n\n}%\n\n\n%{\n\n==== Exercise: lemma for ifz ====\n\n}%\n\n%{\n\n=== Main theorem ===\n\n}%\n\nprog : of E T -> val-or-step E -> type.\n%mode prog +Dof -Dvos.\n\n- : prog (of/z : of z num) (vos/value (value/z : value z)).\n\n- : prog (of/fn _) (vos/value value/fn).\n\n- : prog (of/app \n\t    (D2 : of E2 T') \n\t    (D1 : of E1 (arr T' T)))\n     DvosApp\n     <- prog D1 (Dvos1 : val-or-step E1)\n     <- prog D2 (Dvos2 : val-or-step E2)\n     <- prog/app D1 Dvos1 Dvos2 DvosApp.\n\n%{ \n\n==== Exercise: cases for s and ifz ====\n\n}%\n\n%worlds () (prog _ _).\n%total Dof (prog Dof _)."
          },
          "sha1": "5gds9pz94j4x6mzzq7e6h47xz1s3iy0"
        }
      },
      {
        "title": "CADE Tutorial/Next",
        "ns": 0,
        "id": 2383,
        "revision": {
          "id": 7918,
          "timestamp": "2013-06-09T19:21:34Z",
          "contributor": {
            "username": "Carsten",
            "id": 38
          },
          "comment": "Created page with \"If you want to read more about Twelf, you can check out the [[introductions to Twelf|introductions]], [[tutorials]], and [[case studies]] on the wiki.  We strongly recommend that...\"",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 2588,
            "#text": "If you want to read more about Twelf, you can check out the [[introductions to Twelf|introductions]], [[tutorials]], and [[case studies]] on the wiki.\n\nWe strongly recommend that you work on some of the following exercises: you'll get a flavor for the experience of defining systems and proving theorems in Twelf.  If we have time at the end of the tutorial, we'll break into small groups and you can pick an interesting problem or two to work on.  If you get stuck, ask a TA!  Refer to the solutions to check your work (though Server OK from Twelf should be assurance enough!)  Feel free to ask us for help during the rest of the conference. \n\n== Beginner problems (Recommended) ==\n* [[POPL Tutorial/MinML Preservation Theorem|Preservation for MinML]] -- Prove type preservation for MinML. ([[POPL Tutorial/MinML Preservation Theorem Answer|Solution]])\n* [[POPL Tutorial/Sequent vs Natural Deduction|Sequent calculus vs. natural deduction]] -- Prove the logical equivalence of Gentzen's intuitionistic sequent calculus and intuitionistic natural deduction. ([[POPL Tutorial/Sequent vs Natural Deduction: Solution|Solution]])\n* [[POPL Tutorial/Big step, small step|Big-step evaluation vs. small-step transition semantics]] -- Prove the operational equivalence of the big-step and small-step views of operational semantics.  ([[POPL Tutorial/Big step, small step: Solution|Solution]])\n\n== Intermediate problems ==\n* [[POPL Tutorial/cps-problem|Call-by-value CPS transform, with administrative redexes]] -- Define an algorithm for converting lambda terms to continuation-passing style ([[POPL Tutorial/CPS Solutions|Solution]])\n* [[POPL Tutorial/cps-problem2|Higher-order call-by-value CPS transform, no administrative redexes]] -- Define a higher-order variant of the CPS conversion that never creates administrative redexes ([[POPL Tutorial/CPS Solution2|Solution]])\n* [[POPL Tutorial/Church Rosser (Problem)|Church-Rosser]] -- Prove Church and Rosser's seminal result via a Diamond Lemma for the untyped lambda calculus. ([[POPL Tutorial/Church Rosser|Solution]])\n* [[POPL Tutorial/Exceptions-problem|MinML with exceptions]] -- Prove type safety for an extension of MinML with exceptions defined using structural operational semantics with a \"raises\" judgement.  ([[POPL Tutorial/Exceptions|Solution]])\n* [[POPL Tutorial/Typed bracket abstraction|Lambda calculus and combinators]] -- Explore the relation between the simply-typed lambda calculus and combinatory logic using Curry's classic bracket abstraction algorithm.  ([[POPL Tutorial/Typed bracket abstraction (solution)|Solution]])"
          },
          "sha1": "12kwp44wuo2sa3rqrxp26knefc5pz00"
        }
      },
      {
        "title": "CPS conversion",
        "ns": 0,
        "id": 1660,
        "revision": {
          "id": 6337,
          "parentid": 5029,
          "timestamp": "2011-09-13T20:13:11Z",
          "contributor": {
            "username": "Luke Maurer",
            "id": 167
          },
          "minor": null,
          "comment": "/* Translation relation */  Removing obsolete attributes",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 26809,
            "#text": "'''CPS conversion''' is the process of translating a [[direct style]] calculus into a [[continuation passing style]] (CPS) one. This tutorial describes one way of formalizing CPS conversion in Twelf. It is an advanced tutorial because it relies on techniques described in other tutorials, such as [[reversing the polarity]].\n\nWe will define a direct style lambda calculus and its static semantics, then a CPS language and its static semantics. We will then prove that any well-formed direct style expression can be translated into a well-formed CPS expression.\n\n== Direct style language ==\n\nWe begin with a direct style lambda calculus with products, unit, and a <tt>let</tt> construct.\n\n<twelf>\ntyp : type.                             %name  typ A a.\n\n=>   : typ -> typ -> typ.               %infix right 8 =>.\n&    : typ -> typ -> typ.               %infix none 9 &.\nunit : typ.\n\n%% expressions\n\nexp : type.\nval : type.\n\n%% values are expressions, too.\nvalue  : val -> exp.\n\nlam    : (val -> exp) -> val.\napp    : exp -> exp -> exp.\nmkpair : exp -> exp -> exp.\npair   : val -> val -> val.\nfst    : exp -> exp.\nsnd    : exp -> exp.\n1      : val.\nlet    : exp -> (val -> exp) -> exp.\n</twelf>\n\nHere we make a syntactic distinction between values (of LF type <tt>val</tt>) and expressions (<tt>exp</tt>). A constructor <tt>value</tt> injects syntactic values into expressions. It would also be possible to do a more [[extrinsic encoding]] of values by instead defining a judgment over expressions that defined the subset that are values. This encoding makes more facts explicit in the typing (for instance it is immediately evident that the calculus is call-by-value since lambdas expect values as arguments) which resists mistakes and saves us some lemmas. Note that we distinguish between the expression <tt>mkpair</tt> whose evaluation creates a pair and the value that results, <tt>pair</tt>.\n\nThe typing rules for this language are straightforward:\n\n<twelf>\n% |- e : t\nof : exp -> typ -> type.\n% |- v : t\nofv : val -> typ -> type.\n\nofvalue : of (value V) A <- ofv V A.\n\nunitI : ofv 1 unit.\n\n=>I : ofv (lam [x:val] M x) (A => B)\n     <- ({x:val} ofv x A ->\n                 of (M x) B).\n\n=>E : \n      of M1 (A => B) ->\n      of M2 A ->\n      of (app M1 M2) B.\n\n\n&Iv : \n     ofv V1 A ->\n     ofv V2 B ->\n     ofv (pair V1 V2) (A & B).\n\n&I : \n     of M1 A ->\n     of M2 B ->\n     of (mkpair M1 M2) (A & B).\n\n&E1 : of (fst M) A\n   <- of M (A & B).\n\n&E2 : of (snd M) B\n   <- of M (A & B).\n\noflet :\n     of M A ->\n     ({y:val}{ofy : ofv y A}\n        of (N y) C) ->\n     of (let M N) C.\n</twelf>\n\nThe type family <tt>of M A</tt> encodes the typing judgment Γ {{vdash}} M : A, and <tt>ofv V A</tt> the judgment Γ {{vdash}} V : A.\n\n== CPS language ==\n\nWe then define the syntax of the CPS language that will be the target of CPS conversion:\n\n<twelf>\n%% CPS language\n\ncexp : type.    %name cexp C c.\nctyp : type.    %name ctyp A a.\ncval : type.    %name cval V v.\n\nccont  : ctyp -> ctyp.                      %postfix 8 ccont.\nc&     : ctyp -> ctyp -> ctyp.              %infix none 9 c&.\ncunit  : ctyp.\n\n\n% continuation expressions\ncmkpair : cval -> cval -> (cval -> cexp) -> cexp.\ncfst    : cval -> (cval -> cexp) -> cexp.\ncsnd    : cval -> (cval -> cexp) -> cexp.\n\n% continuations can end with a call to a function\nccall : cval -> cval -> cexp.\nchalt : cexp.\n\n\n% continuation values\ncpair : cval -> cval -> cval.\nclam  : (cval -> cexp) -> cval.\nc1    : cval.\n</twelf>\n\nThis language makes the same syntactic distinction between continuation expressions (<tt>cexp</tt>) and values (<tt>cval</tt>). A continuation expression is a linear sequence of operations on values (here <tt>cmkpair</tt>, <tt>cfst</tt> and <tt>csnd</tt>), each of which binds a variable. A continuation expression ends with a call to a continuation (<tt>ccall</tt>) or by halting (<tt>chalt</tt>). A continuation value is either a pair of values (<tt>cpair</tt>), the unit element (<tt>c1</tt>) or a lambda (<tt>clam</tt>) which abstracts a continuation expression. Because continuations never return, lambdas have type <tt>A ccont</tt> for some argument type A. (Note that the <tt>ccont</tt> type constructor is written in postfix notation.) In some presentations of CPS, this is written as A → 0, A → ⊥, or ¬A.\n\n{{needs|an example of a CPS term}}\n\nThe static semantics for the CPS language is as follows:\n\n<twelf>\n% |- c ok\ncof : cexp -> type.              %name cof WC wc.\n%mode cof *C.\n\n% |- cv : A\ncofv : cval -> ctyp -> type.     %name cofv WV wv.\n%mode cofv *A *B.\n\nco_halt : cof chalt.\n\nco_mkpair :  cofv V1 A ->\n             cofv V2 B ->\n             ({v:cval} cofv v (A c& B) -> \n                cof (K v)) ->\n             cof (cmkpair V1 V2 K).\n\nco_call : cofv F (A ccont) ->\n          cofv V A ->\n          cof (ccall F V).\n\nco_fst : cofv V (A c& B) ->\n         ({v}{ov : cofv v A} cof (C v)) ->\n         cof (cfst V C).\n\nco_snd : cofv V (A c& B) ->\n         ({v}{ov : cofv v B} cof (C v)) ->\n         cof (csnd V C).\n\ncov_unit : cofv c1 cunit.\n\ncov_pair : cofv V1 A ->\n           cofv V2 B ->\n           cofv (cpair V1 V2) (A c& B).\n\ncov_lam : ({x} cofv x A ->\n               cof (C x)) ->\n          cofv (clam C) (A ccont).\n</twelf>\n\nThe type family <tt>cof C</tt> encodes the typing judgment Γ {{vdash}} C ''ok''. Continuations do not return, so they do not have a type. The type family <tt>ofv V A</tt> the judgment Γ {{vdash}} V : A for CPS values V. The typing rules are straightforward.\n\n== Translation ==\n\n=== Type translation ===\n\nWe can now translate from the direct style language to the CPS language. Because a translated value will have a different type in the source and destination languages (indeed, the source and destination types are different LF types!), we start by defining a translation for the types of the source language.\n\n<twelf>\nttoct : typ -> ctyp -> type.\n%mode ttoct +A -CA.\n\nttoct/unit : ttoct unit cunit.\nttoct/& : ttoct (A & B) (A' c& B') <- ttoct B B' <- ttoct A A'.\nttoct/=> : ttoct (A => B) ((A' c& (B' ccont)) ccont) \n\t     <- ttoct B B' <- ttoct A A'.\n</twelf>\n\nThe family <tt>ttoct A A'</tt> (\"typ to ctyp\") encodes the type translation, which is often written using [[:w:Dana Scott|Scott brackets]] like <nowiki>[[A]]</nowiki>. The unit type and product types simply translate recursively into their correspondents in the CPS types. An arrow type A → B translates into (A' c& (B' ccont)) ccont. That is, a function is translated into a continuation that expects the (translated) argument paired with a return continuation for the (translated) result.\n\nTo check our work, we can verify that type translation is [[%total|total]]. This result will not be important to our main theorem, but every type should certainly have a translation and it is an easy way to check for mistakes early.\n\n<twelf>\n%worlds () (ttoct _ _).\n%total D (ttoct D _).\n</twelf>\n\n=== Translation relation ===\n\nThe translation for values is a three place relation:\n\n<twelf>\ntocpsv+ : {WV  : ofv V A}\n\t  {CT  : ttoct A CA}\n\t  {WCV : cofv CV CA}\n\t  type.\n%mode tocpsv+ +WV +CT -WCV.\n</twelf>\n\n<tt>WV</tt> is a value typing derivation in the source language. Our translation will be type-directed, translating typing derivations to typing derivations. The terms, which are in the types of the typing derivations, can easily be recovered (in fact, they are [[implicit parameter]]s in this judgment). The middle place in the relation is the translation of the type; this is necessary to ensure that the translated value has the appropriate translated type.\n\nSometimes it is necessary for the type translation to be an [[%mode|output]] of the relation, and sometimes it is necessary for it to be an input. As is standard for translations between languages, we will need to use the [[reversing the polarity]] technique to give two versions of this relation with two different modes. The second one is identical except for the mode of the middle argument:\n\n<twelf>\ntocpsv- : {WV  : ofv V A}\n\t  {CT  : ttoct A CA}\n\t  {WCV : cofv CV CA}\n\t  type.\n%mode tocpsv- +WV -CT -WCV.\n</twelf>\n\nThe CPS translation relation for expressions, which is the crux of this tutorial, is much less straightforward:\n\n<twelf>\ntocps- : {M  : exp}\n\t {WM : of M A}\n \t {CT : ttoct A CA}\n\t % term representing the result of conversion\n\t {CC : (cval -> cexp) -> cexp}\n\t % typing for result of conversion\n         {WCC : {C : cval -> cexp}\n                ({cv : cval}\n                 {wcv : cofv cv CA}\n                 cof (C cv)) ->\n                cof (CC C)}\n\t type.\n%mode tocps- +M +WM -CT -CC -WCC.\n</twelf>\n\nFor this relation we will use explicit parameters for the terms. The first two arguments are the expression <tt>M</tt> to be translated and its typing <tt>WM</tt> (the letter w is often used in variable names within this code to stand for \"well-formed\"). The next argument is the translation for the type <tt>A</tt> of the expression, as in the translation for values. The argument <tt>CC</tt> is the continuation expression that is the result of CPS conversion. However, it is parameterized over the \"tail\" of the continuation (of type <tt>cval -> cexp</tt>), because an expression cannot be CPS-converted in isolation. For example, the direct style expression <tt>mkpair 1 1</tt> will translate into\n\n<twelf>\n[rest : cval -> cexp]\n  cmkpair c1 c1 [p : cval]\n  rest p</twelf>\n\nThe output <tt>CC</tt> is accompanied by <tt>WCC</tt>, a typing derivation for it. The typing derivation is also parameterized. Its type is\n\n<twelf>\n{C : cval -> cexp}\n({cv : cval} {wcv : cofv cv CA} cof (C cv)) ->\n cof (CC C)\n</twelf>\n\nThe first parameter <tt>C</tt> is the tail of the continuation, as above. The second argument is a typing derivation for the tail. The tail must be well-formed for any well-formed <tt>cval</tt> we might pass to it, so that typing derivation is itself parameterized. To summarize, <tt>WCC</tt> is a parameterized typing derivation that allows us to instantiate it with any well-formed tail.\n\nWe also need to give a version of this relation with reversed polarity.\n<twelf>\ntocps+ : {M  : exp}\n         {WM : of M A}\n         {CT : ttoct A CA}\n         {CC : (cval -> cexp) -> cexp}\n         {WCC : {C : cval -> cexp}\n                ({cv : cval}\n                 {wcv : cofv cv CA}\n                 cof (C cv)) ->\n                cof (CC C)}\n         type.\n%mode tocps+ +M +WM +CT -CC -WCC.\n</twelf>\n\n\nThe type of this relation may be more clear when we see how it is used. But before we are able to give the translation for expressions and values, we need to prove some lemmas about the type translation relation.\n\n=== Lemmas ===\n\nFirst, we define a [[equality|shallow equality]] relation on continuation types and prove that it is preserved when type constructors are applied:\n\n<twelf>\nceqtyp : ctyp -> ctyp -> type.\nceqtyp_ : ceqtyp A A.\n\nceqtyp_& : ceqtyp A A' -> ceqtyp B B' -> ceqtyp (A c& B) (A' c& B') -> type.\n%mode ceqtyp_& +A +B -C.\n- : ceqtyp_& ceqtyp_ ceqtyp_ ceqtyp_.\n\nceqtyp_cont : ceqtyp A A' -> ceqtyp (A ccont) (A' ccont) -> type.\n%mode ceqtyp_cont +A -C.\n- : ceqtyp_cont ceqtyp_ ceqtyp_.\n</twelf>\n\nWe need to prove that continuation value typing respects equality, and that continuation tail typing respects equality. These theorems are trivial because equality is shallow.\n\n<twelf>\ncofv_resp : cofv C A -> ceqtyp A A' -> cofv C A' -> type.\n%mode cofv_resp +COF +EQ -COF'.\n- : cofv_resp D ceqtyp_ D.\n\nwcc_resp : {WCC :\n\t     ({C  : cval -> cexp}\n\t      ({cv : cval}\n\t       {wcv : cofv cv A}\n\t       cof (C cv)) ->\n\t      cof (CC C))}\n\n\t    {EQ : ceqtyp A A'} \n\n\t    {K' :\n\t     ({C  : cval -> cexp}\n\t      ({cv : cval}\n\t       {wcv : cofv cv A'}\n\t       cof (C cv)) ->\n\t      cof (CC C))}\n\n\t    type.\n%mode wcc_resp +K +EQ -K'.\n\nwcc_resp_ : wcc_resp D ceqtyp_ D.\n</twelf>\n\nIt is also necessary that the type translation relation <tt>ttoct</tt> be a [[function (relation)|function]]. That means we must prove a [[uniqueness lemma]] and [[effectiveness lemma]] for it. \n\n<twelf>\n% uniqueness\nttoct_fun : ttoct A A' -> ttoct A A'' -> ceqtyp A' A'' -> type.\n%mode ttoct_fun +X +Y -Z.\n\n- : ttoct_fun (ttoct/& A B) (ttoct/& C D) OUT\n <- ttoct_fun A C EQ1\n <- ttoct_fun B D EQ2\n <- ceqtyp_& EQ1 EQ2 OUT.\n\n- : ttoct_fun (ttoct/=> A B) (ttoct/=> C D) OUT\n <- ttoct_fun A C EQ1\n <- ttoct_fun B D EQ2\n <- ceqtyp_cont EQ2 EQ3\n <- ceqtyp_& EQ1 EQ3 EQ4\n <- ceqtyp_cont EQ4 OUT.\n\n- : ttoct_fun ttoct/unit ttoct/unit ceqtyp_.\n\n% effectiveness\nttoct_gimme : {A:typ} {A':ctyp} ttoct A A' -> type.\n%mode ttoct_gimme +A -A' -D.\n\n- : ttoct_gimme (A & B) _ (ttoct/& CT1 CT2)\n <- ttoct_gimme A A' CT1\n <- ttoct_gimme B B' CT2.\n\n- : ttoct_gimme (A => B) _ (ttoct/=> CT1 CT2)\n <- ttoct_gimme A A' CT1\n <- ttoct_gimme B B' CT2.\n\n- : ttoct_gimme unit cunit ttoct/unit.\n</twelf>\n\nWe can then check that these are total:\n\n<twelf>\n%worlds () (ttoct_fun _ _ _) (ceqtyp_& _ _ _) (ceqtyp_cont _ _).\n\n%total D (ceqtyp_& D _ _).\n%total D (ceqtyp_cont D _).\n%total D (ttoct_fun D _ _).\n</twelf>\n\n=== Term translation ===\n\nWe can now give the translation for expressions and values. We start by proving the <tt>tocpsv+</tt> and <tt>tocps+</tt> lemmas, since they are one case each:\n\n<twelf>\ntocps+/- : tocps+ V WV CTi CC K\n        <- tocps- V WV CTo CC K'\n        <- ttoct_fun CTo CTi EQ\n        <- wcc_resp K' EQ K.\n\ntocpsv+/- : tocpsv+ WV CTi WCV'\n         <- tocpsv- WV CTo WCV\n         <- ttoct_fun CTo CTi EQ\n         <- cofv_resp WCV EQ WCV'.\n</twelf>\n\nBoth work the same way. We take the type translation as input (<tt>CTi</tt>), then invoke the version of the theorem that returns it as output (<tt>CTo</tt>). Suppose <tt>CTi : ttoct A A'</tt> and <tt>CTo : ttoct A A'<nowiki></nowiki>'</tt>. We just need to show that the output of that theorem (<tt>K</tt> or <tt>WCV</tt>), which depends on <tt>A'<nowiki></nowiki>'</tt>, works for the type <tt>A'</tt>. We simply verify that <tt>A'</tt> and <tt>A'<nowiki></nowiki>'</tt> are equal with our lemma <tt>ttoct_fun</tt>, and then use the fact that the outputs respect equality on types (<tt>wcc_resp</tt> or <tt>cofv_resp</tt>) to do so.\n\n\nThe translation of the expressions <tt>fst</tt> and <tt>snd</tt> are illustrative:\n\n<twelf>\nc_fst : tocps- (fst M) (&E1 WM) CT\n              % parameterized expression resulting from translation\n              ([tail:cval -> cexp]\n                 CC ([v:cval] cfst v ([a:cval] tail a)))\n              % its parameterized typing derivation\n              ([c][wc]\n                 F _ ([v][wv] co_fst wv wc))\n     <- tocps- M WM (ttoct/& CT _) CC F.\n\nc_snd : tocps- (snd M) (&E2 WM) CT _\n              ([c][wc]\n                 F _ ([v][wv] co_snd wv wc))\n     <- tocps- M WM (ttoct/& _ CT) _ F.\n</twelf>\n\nTo translate the expression <tt>fst M</tt>, we inductively translate the argument. It must have type <tt>A & B</tt> and so the only case for translating it is <tt>ttoct/&</tt>, so this subgoal [[output coverage|covers all outputs]]. We return the translation for <tt>A</tt>, called <tt>CT</tt>. We must then build the continuation expression and its typing derivation. The expression is parameterized by a <tt>tail</tt> that takes the result of the <tt>fst</tt> operation, so the tail has type <tt>cval -> cexp</tt>. The resulting term first evaluates <tt>M</tt> by invoking its translation <tt>CC</tt> on a tail we write; that tail takes <tt>v</tt>, the pair value, performs <tt>cfst</tt> on it and binds the result to <tt>a</tt>. It finishes by invoking the outer <tt>tail</tt> argument on that projected first component.\n\nThe parameterized typing derivation is similar. It takes a tail <tt>c</tt> and a typing derivation for the tail, <tt>wc</tt>. The derivation starts with the typing for the translation of <tt>M</tt>, which is represented by the function <tt>F</tt>. We apply <tt>F</tt> to the actual tail we produce&mdash;Twelf can deduce what this is by [[unification]], so we just write <tt>_</tt> to avoid repeating ourselves. The second argument is the typing derivation for that tail; it takes a variable <tt>v</tt> representing the result of evaluating <tt>M</tt> and a typing derivation for it <tt>wv</tt>. The derivation consists simply of the typing rule for <tt>c_fst</tt> applied to the well-formedness of its argument and the code that follows, both of which we get from arguments.\n\nThe translation is challenging because it is so high-order (typing responsibilities pass from callee to caller and vice versa) but most of the cases follow the same pattern. The case for <tt>c_snd</tt> is symmetric, but we have now left out terms that Twelf can infer by type inference and unification. Because terms can be uniquely determined from the types of typing derivations, we almost never need to write them down explicitly.\n\nThe translation for <tt>mkpair</tt> follows the same pattern.\n\n<twelf>\nc_mkpair : tocps- (mkpair M1 M2) (&I WM1 WM2) (ttoct/& CT1 CT2) _\n              ([c][wc] \n                  F1 _ ([v1][wv1]\n                          F2 _ ([v2][wv2]\n                                 co_mkpair wv1 wv2 wc)))\n        <- tocps- M1 WM1 CT1 _ F1\n        <- tocps- M2 WM2 CT2 _ F2.\n</twelf>\n\nWe translate the two subexpressions, string together the continuation expressions that evaluate them, build the pair and pass it to the tail. Application is interesting because of the way functions are represented:\n\n<twelf>\nc_app : tocps- (app M N) (=>E WM WN) CTB _\n           ([c][wc]\n              FM _ ([f][wf]\n                      FN _ ([a][wa]\n                              % making argument of type A' c& (B ccont)\n                              co_mkpair wa (cov_lam ([r][wr] wc r wr)) [p][wp]\n                              co_call wf wp)))\n     <- ttoct_gimme (A => B) (A' c& (B' ccont) ccont) (ttoct/=> CTA CTB)\n     <- tocps+ M WM (ttoct/=> CTA CTB) _ FM\n     <- tocps+ N WN CTA _ FN.\n</twelf>\n\nThe first subgoal (<tt>ttoct_gimme</tt>) exists to reconcile the various type translations that will occur: We will have a translation for <tt>A</tt>, <tt>B</tt>, and <tt>A =&gt; B</tt> which all must agree. We therefore invoke the [[effectiveness lemma]] on the largest type (<tt>A =&gt; B</tt>) and the others will be subterms. We then invoke tocps inductively to translate the function and argument expressions (we use the + version here so that we need not do equality reasoning about the type translations). The resulting typing derivation begins with the derivations for the translation of <tt>M</tt> and <tt>N</tt>. Given these, it builds a pair of the argument <tt>wa</tt> and return continuation. The body of the return continuation is the outermost tail passed to the translation of the <tt>app</tt>. We then end with a call to the translated function value on the pair we created.\n\n==== Binding ====\n\nSo far, everything in the source object language has been first order. We'll now translate the <tt>let</tt> construct, which is a simple binder.\n\n<twelf>\nc_let : tocps- (let M N) (oflet WM WN) CTN _\n          ([c][wc] FM _ ([v][wv] FN v wv c wc))\n\n     <- ttoct_gimme A A' CTM\n     <- tocps+ M WM CTM _ FM\n     <- ( {x}{xof : ofv x A}\n          {x'}{x'of : cofv x' A'}\n          {thm:tocpsv- xof CTM x'of}\n\n         tocps- (N x) (WN x xof) CTN (CC x') (FN x' x'of)).\n</twelf>\n\nThis translation begins as before, by translating <tt>M</tt>. We then want to translate the body, <tt>N</tt>, but it has type <tt>val -&gt; exp</tt>, so it must be in a subgoal with a hypothetical value variable in context. The subgoal actually introduces five hypotheses: the direct style value <tt>x</tt>; a derivation that it is well-formed at type <tt>A</tt>, <tt>xof</tt>; the CPS value it will be translated to, <tt>x'</tt>; its derivation <tt>x'of</tt>; and the case of the theorem that relates the two. Once we have translated <tt>N</tt> and <tt>WN</tt> in this context, we build the result typing derivation. Because we have set up the translation such that the tail always takes a value as an argument, we do not need a CPS-level <tt>let</tt> construct; we simply invoke <tt>FM</tt>, which types the translation of <tt>M</tt>, and then invoke <tt>FN</tt> on the value and typing derivation resulting from that, and continue with the outermost tail.\n\nThe final case of translation for expressions is the inclusion of values:\n\n<twelf>\nc_val : tocps- (value V) (ofvalue WV) CT _ ([c][wc] wc CV WCV)\n     <- tocpsv- WV CT WCV.\n</twelf>\n\nIt simply invokes the mutually inductive translation <tt>tocpsv-</tt>, which we define next.\n\n=== Value translation ===\n\nValue translation is not continuation-based, so two of the three cases are very easy:\n\n<twelf>\ncv_pair : tocpsv- (&Iv WV1 WV2) (ttoct/& CT1 CT2)  (cov_pair WV1' WV2')\n       <- tocpsv- WV1 CT1 WV1'\n       <- tocpsv- WV2 CT2 WV2'.\n\ncv_unit : tocpsv- unitI ttoct/unit cov_unit.\n</twelf>\n\nPairs are translated pointwise and unit is trivial.\n\nThe final case in the theorem is the translation of lambda values:\n\n<twelf>\ncv_lam : tocpsv- ((=>I WM) : ofv (lam M) (A => B)) (ttoct/=> CTA CTB)\n          (cov_lam [arg][argof : cofv arg (A' c& (B' ccont))]\n             co_fst argof [x:cval][xof:cofv x A']\n             co_snd argof [r:cval][rof:cofv r (B' ccont)]\n             F x xof r rof ([v:cval] ccall r v) \n                ([v:cval][wv:cofv v B'] co_call rof wv))\n    <- ttoct_gimme A A' CTA\n    <- (% original argument\n        {x}{xof : ofv x A}\n        {x'}{x'of : cofv x' A'}\n        % how to convert it\n        {thm:tocpsv- xof CTA x'of}\n\n        % (object language) return continuation\n        {r}{rof : cofv r (B' ccont)}\n\n          tocps- (M x) (WM x xof) CTB (CC x' r) (F x' x'of r rof)).\n</twelf>\n\nRecall that the <tt>tocpsv</tt> relations are between typing derivations only (the terms are implicit) but <tt>tocps</tt> takes them explicitly. Thus the first thing to notice is that we use type annotations to recover the implicit arguments so that we can pass them explicitly to <tt>tocps</tt>. (This is an instance of [[converting between implicit and explicit parameters]].) As before, we then use effectiveness to translate the type <tt>A</tt>. The inductive call to <tt>tocps</tt> has seven hypotheses. The first five are as in the case for <tt>let</tt>, which represent the bound argument variable and its translation. The last two represent the return continuation, which will be another argument to the continuation we generate. Also notice that in this case we do not have a wildcard <tt>_</tt> for the translated term in the subgoal&mdash;we write <tt>(CC x' r)</tt>&mdash;without this help Twelf's higher-order unification cannot resolve all of the constraints. (This one case is the reason that the terms cannot be implicit parameters as they are for the value translation.) The result of translation is a typing derivation for a continuation. The continuation's argument <tt>arg</tt> has type <tt>(A' c& (B' ccont))</tt>; we start by projecting the first and second components of the pair. We then use the derivation for the translated body, which depends on the argument and return continuation. Its tail takes the result of the body, <tt>v</tt> and calls the continuation on that value.\n\n== Metatheorem ==\n\nWe can now check our metatheorem, which is that these translations are total. We start by declaring [[%block|block]]s for use in the [[%worlds]] declarations:\n\n<twelf>\n%block blockcvar : \n              some {A : typ} {A' : ctyp} {CTA : ttoct A A'}\n              block\n               {x}{xof : ofv x A}\n               {x'}{x'of : cofv x' A'}\n               {thm:tocpsv- xof CTA x'of}.\n\n%block blockwcv :\n             some {CA : ctyp}\n             block {r}{rof : cofv r CA}.\n</twelf>\n\nThe first block corresponds to the five hypotheses we needed in the <tt>let</tt> and <tt>lam</tt> cases. The second is for the return continuation we assume in the <tt>lam</tt> case&mdash;it does not correspond to any direct style assumption so it need only be well-formed.\n\nFor this proof to check we must also make world declarations for the type families <tt>cof</tt>, <tt>cofv</tt>, <tt>cval</tt> and <tt>cexp</tt>. I believe this has to do with Twelf's overconservativity of world subsumption on third-order metatheorems, but I am not sure of the exact cause.{{discuss|Strange world declarations}} Although they are strange (and meaningless, since we do not check the totality of these type families, whose modes are all <tt>[[%mode|*]]</tt>), they pose no problem here:\n\n<twelf>\n%block blockcv : block {v : cval}.\n\n%worlds (blockcv) (cval) (cexp).\n%worlds (blockwcv) (cofv _ _) (cof _).\n</twelf>\n\nThen, the world declarations for our theorems and lemmas:\n\n<twelf>\n%worlds (blockcvar | blockwcv) \n                   (tocps+ _ _ _ _ _)\n                   (tocps- _ _ _ _ _)\n                   (tocpsv+ _ _ _)\n                   (tocpsv- _ _ _)\n                   (cofv_resp _ _ _)\n                   (ttoct_gimme _ _ _)\n                   (wcc_resp _ _ _).\n</twelf>\n\nWe can check the lemmas individually for totality; they are simple inductions:\n\n<twelf>\n%total A (cofv_resp _ A _).\n%total A (wcc_resp _ A _).\n%total A (ttoct_gimme A _ _).\n</twelf>\n\nFinally, we can check the type-directed translations for totality:\n\n<twelf>\n%total (A B C D) \n          (tocpsv- A _ _) \n          (tocpsv+ B _ _) \n          (tocps- _ C _ _ _) \n          (tocps+ _ D _ _ _).\n</twelf>\n\nThe termination order here is important. The <tt>+</tt> versions of each relation call the <tt>-</tt> versions on the same input derivation, so we must specify mutual recursion with parentheses in this order <tt>(A B C D)</tt> so that these forward calls are allowed. Other calls obey the strict [[subterm]] ordering. See {{guide|chapter=8|section=51|title=mutual recursion}} for more information. (Note: the call order in the documentation appears to be the opposite of what is implemented.{{discuss|Termination order backwards?}})\n\nThat's it! You may see <twelflink check=\"true\">Twelf's output</twelflink> or download <twelflink>all the source code</twelflink> for the tutorial. We showed how to define a CPS language with an intrinsic distinction between values and expressions, and translate a direct style language into it. The translation is given as a relation on typing derivations, which builds the type correctness of the translation into the translation itself. The translation makes use of LF's ability to encode higher-order reasoning to avoid generating object-level \"administrative redices\" that would need to be cleaned up and would complicate the metatheory. The code is brief by being simultaneously both proof and program: A metatheorem showing the translation works for all well-typed direct style terms is obtained simply by a [[%total]] declaration for the translation. Alternately, we can think of the computational content of our proof as being the translation itself. \n\n<!-- See also Frank's CPS example in the twelf/examples source? -->\n\n\n{{case study}}"
          },
          "sha1": "a33nbecrs42dxwpidf1u3fraplyg331"
        }
      },
      {
        "title": "C machine and focusing",
        "ns": 0,
        "id": 2192,
        "revision": {
          "id": 5932,
          "timestamp": "2009-03-10T03:43:24Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "comment": "New page: %{  C Machine and Focusing }%  %{ == Syntax == }%  pos : type.  %name pos A+. neg : type.  %name neg A-.  down : neg -> pos. plus : pos -> pos -> pos. times : pos -> pos -> pos. zero  : po...",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 4355,
            "#text": "%{ \nC Machine and Focusing\n}%\n\n%{ == Syntax == }%\n\npos : type.  %name pos A+.\nneg : type.  %name neg A-.\n\ndown : neg -> pos.\nplus : pos -> pos -> pos.\ntimes : pos -> pos -> pos.\nzero  : pos.\none   : pos.\n\nup   : pos -> neg.\narr  : pos -> neg -> neg.\nwith : neg -> neg -> neg.\ntop  : neg.\n\n%abbrev conc = neg.\n\nval+  : pos -> type.\ncont- : neg -> conc -> type.\ncont+ : pos -> conc -> type.\nval-  : neg  -> type.\nexp   : conc -> type.\n\n%% positive values\n\nmt+    : val+ one.\n%% no rule for zero\npair+  : val+ A -> val+ B -> val+ (times A B).\ninl    : val+ A -> val+ (plus A B).\ninr    : val+ B -> val+ (plus A B).\ndelay- : exp A- -> val+ (down A-).\n\n%% positive continuations (shallow matching)\n\n%% positive conts\nlet1   : exp C -> cont+ one C.\n%% no rule for zero\nsplit  : (val+ A -> val+ B -> exp C) -> cont+ (times A B) C.\ncase   : (val+ A -> exp C) -> (val+ B -> exp C) -> cont+ (plus A B) C.\nforce- : cont- A- C -> cont+ (down A-) C.\n  %% wait to peel off the shift until you're ready to focus.\n\n%% negative continuations\n\napp    : val+ A+ -> cont- B C -> cont- (arr A+ B) C.\nfst    : cont- A C -> cont- (with A B) C.\nsnd    : cont- B C -> cont- (with A B) C.\nforce+ : (val+ A+ -> exp C) -> cont- (up A+) C.\n%% internalize identity so we don't need to eta-expand\nid-    : cont- A A.\n\n%% negative values (shallow)\n\nlam    : (val+ A+ -> exp B-) -> val- (arr A+ B-).\npair-  : exp A- -> exp B- -> val- (with A- B-).\nmt-    : val- top.\ndelay+ : val+ A+ -> val- (up A+).  %% wait to peel off shift until focus\n\n%% neutral sequents\n\nreturn : val- A -> exp A.\n\n  %% canonical when the value is a variable;\n  %% non-canonical otherwise\ncut+   : val+ A+ -> cont+ A+ C -> exp C.\n  %% non-canonical\ncut-   : val- A- -> cont- A- C -> exp C.\n\n%% value variables can be used to stop right focus early\n%block valb : some {A} block {x : val+ A}.\n%worlds (valb) (cont+ _ _) (cont- _ _) (val+ _) (exp _) (val- _).\n\n%{ == Operational Semantics == }%\n\n%{ === Composition === }%\n\ncomp+- : cont+ A+ B- -> cont- B- C- -> cont+ A+ C- -> type.\n%mode comp+- +K1 +K2 -K3.\n\ncompe- : exp A- -> cont- A- C- -> exp C- -> type.\n%mode compe- +E1 +K2 -E3.\n\ncomp-- : cont- A- B- -> cont- B- C- -> cont- A- C- -> type.\n%mode comp-- +K1 +K2 -K3.\n\n%% + -\n\ncomp+-/let1 : comp+- (let1 E) K (let1 E')\n\t       <- compe- E K E'.\n\ncomp+-/split : comp+- (split E) K (split E')\n\t\t<- {x}{y} compe- (E x y) K (E' x y). \n\ncomp+-/case : comp+- (case E1 E2) K (case E1' E2')\n\t       <- ({x} compe- (E1 x) K (E1' x))\n\t       <- ({x} compe- (E2 x) K (E2' x)).\n\t       \ncomp+-/force : comp+- (force- K-) K (force- K-')\n\t       <- comp-- K- K K-'.\n\n%% e -\n\ncompe-/return : compe- (return V) K (cut- V K).\ncompe-/cut-   : compe- (cut- V K1) K2 (cut- V K3)\n\t\t <- comp-- K1 K2 K3.\ncompe-/cut+   : compe- (cut+ V K1) K2 (cut+ V K3)\n\t\t <- comp+- K1 K2 K3.\n\n%% - - \n\ncomp--/app : comp-- (app V K1) K2 (app V K3)\n\t      <- comp-- K1 K2 K3.\n\ncomp--/fst : comp-- (fst K1) K2 (fst K3)\n\t      <- comp-- K1 K2 K3.\n\ncomp--/snd : comp-- (snd K1) K2 (snd K3)\n\t      <- comp-- K1 K2 K3.\n\ncomp--/force : comp-- (force+ E) K2 (force+ E')\n\t\t<- {x} compe- (E x) K2 (E' x).\n\ncomp--/id : comp-- id- K2 K2.\n\n%worlds (valb) (comp+- _ _ _) (comp-- _ _ _) (compe- _ _ _).\n%total (D1 D2 D3) (comp+- D1 _ _) (comp-- D3 _ _) (compe- D2 _ _).\n\n%{ === Stack Machine === }%\n\n%% the sum type that you'd define for progress is\n%% (val C) + (exp C)\n%% so let's just abuse exp C for this sum and write the\n%% operational semantics as the progress proof.\n%% the only downside is that you can't tell whether an expression\n%% took a real step towards a value or already was a value.\n\nstep : exp C -> exp C -> type.\n%mode step +S1 -S2.\n\nstep/return : step (return V) (return V).\n\nstep/let1   : step (cut+ mt+ (let1 E)) E.\nstep/split  : step (cut+ (pair+ V1 V2) (split E)) (E V1 V2).\nstep/case1  : step (cut+ (inl V1) (case E1 E2)) (E1 V1).\nstep/case2  : step (cut+ (inr V2) (case E1 E2)) (E2 V2).\nstep/force- : step (cut+ (delay- E) (force- K)) E'\n\t       <- compe- E K E'.\nstep/app    : step (cut- (lam E) (app V K)) E'\n\t       <- compe- (E V) K E'.\nstep/fst   : step (cut- (pair- E1 E2) (fst K)) E'\n\t       <- compe- E1 K E'.\nstep/snd   : step (cut- (pair- E1 E2) (snd K)) E'\n\t       <- compe- E2 K E'.\nstep/force+ : step (cut- (delay+ V) (force+ E)) (E V).\nstep/id     : step (cut- V id-) (return V).\n\n%worlds () (step _ _).\n%total D (step D _)."
          },
          "sha1": "eljmpahsquwgxq1nrdsegcbchjrhlki"
        }
      },
      {
        "title": "C machine and focusing (composition in machine state)",
        "ns": 0,
        "id": 2194,
        "revision": {
          "id": 5934,
          "timestamp": "2009-03-10T16:27:39Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "comment": "New page: %{  C Machine and Focusing }%  %{ == Syntax == }%  pos : type.  %name pos A+. neg : type.  %name neg A-.  down : neg -> pos. plus : pos -> pos -> pos. times : pos -> pos -> pos. zero  : po...",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 4498,
            "#text": "%{ \nC Machine and Focusing\n}%\n\n%{ == Syntax == }%\n\npos : type.  %name pos A+.\nneg : type.  %name neg A-.\n\ndown : neg -> pos.\nplus : pos -> pos -> pos.\ntimes : pos -> pos -> pos.\nzero  : pos.\none   : pos.\n\nup   : pos -> neg.\narr  : pos -> neg -> neg.\nwith : neg -> neg -> neg.\ntop  : neg.\n\n%abbrev conc = neg.\n\n%{ \n\n=== Proofs ===\n\nTo mimic direct style, we don't internalize continuation composition\n(because continuations aren't separate syntactic categories in direct\nstyle).  Also, we treat negative cuts as a special case of the\ninternalized exp/cont composition principle; there is no need to\ndistinguish the redices.\n\nUnlike higher-order focusing, neutral sequents are \"pos entails neg\",\nand the shifts hand around until we choose to focus on a formula.\n\n}%\n\nval+  : pos -> type.\ncont- : neg -> conc -> type.\ncont+ : pos -> conc -> type.\nval-  : neg  -> type.\nexp   : conc -> type.\n\n%% positive values\n\nmt+    : val+ one.\n%% no rule for zero\npair+  : val+ A -> val+ B -> val+ (times A B).\ninl    : val+ A -> val+ (plus A B).\ninr    : val+ B -> val+ (plus A B).\ndelay- : exp A- -> val+ (down A-).\n\n%% positive continuations (shallow matching)\n\nlet1   : exp C -> cont+ one C.\n%% no rule for zero\nsplit  : (val+ A -> val+ B -> exp C) -> cont+ (times A B) C.\ncase   : (val+ A -> exp C) -> (val+ B -> exp C) -> cont+ (plus A B) C.\nforce- : cont- A- C -> cont+ (down A-) C.\n\n%% negative continuations\n\napp    : val+ A+ -> cont- B C -> cont- (arr A+ B) C.\nfst    : cont- A C -> cont- (with A B) C.\nsnd    : cont- B C -> cont- (with A B) C.\nforce+ : (val+ A+ -> exp C) -> cont- (up A+) C.\n%% internalize identity so we don't need to eta-expand\nid-    : cont- A A.\n\n%% negative values (shallow)\n\nlam    : (val+ A+ -> exp B-) -> val- (arr A+ B-).\npair-  : exp A- -> exp B- -> val- (with A- B-).\nmt-    : val- top.\ndelay+ : val+ A+ -> val- (up A+).  %% wait to peel off shift until focus\n\n%% neutral sequents\n\nreturn : val- A -> exp A.\n\n%% canonical when the value is a variable;\n%% non-canonical otherwise\ncut+   : val+ A+ -> cont+ A+ C -> exp C.\n\n%% internalize exp / cont composition\ncompose : exp A- -> cont- A- C- -> exp C-.\n\n%{ === Stack Machine === \n\nLists of continuations:\n\n}%\n\nconts- : neg -> conc -> type.\nconts-/cons : cont- A B -> conts- B C -> conts- A C.\nconts-/nil  : conts- A A.\n\nconts+ : pos -> conc -> type.\nconts+/cons : cont+ A B -> conts- B C -> conts+ A C.\n\n%{\n\nMachine states are basically expressions, except (1) they have lists of\ncontinuations in place of continuations and (2) they distinguish\nexp/cont composition states from negative redex states.\n\n}%\n\nstate : conc -> type.\ndone  : val- A -> state A.                %% answer\nst-   : exp  A -> conts- A C -> state C.  %% composition\nstv-  : val- A -> conts- A C -> state C.  %% negative cut\nstv+  : val+ A -> conts+ A C -> state C.  %% positive cut\n\n%{ \n\nThe sum type that you'd define for progress is (val C) + (exp C) so\nlet's just abuse exp C for this sum and write the operational semantics\nas the progress proof.  The only downside is that you can't tell whether\nan expression took a real step towards a value or already was a value.\n\n}%\n\nstep : state C -> state C -> type.\n%mode step +S1 -S2.\n\nstep/return : step (done V) (done V).\n\nstep/let1   : step (stv+ mt+ (conts+/cons (let1 E) Ks)) (st- E Ks).\nstep/split  : step (stv+ (pair+ V1 V2) (conts+/cons (split E) Ks)) \n\t           (st- (E V1 V2) Ks).\nstep/case1  : step (stv+ (inl V1) (conts+/cons (case E1 E2) Ks)) \n\t           (st- (E1 V1) Ks).\nstep/case2  : step (stv+ (inr V2) (conts+/cons (case E1 E2) Ks)) \n\t           (st- (E2 V2) Ks).\nstep/force- : step (stv+ (delay- E) (conts+/cons (force- K) Ks)) \n\t           (st- E (conts-/cons K Ks)).\n\nstep/app    : step (stv- (lam E) (conts-/cons (app V K) Ks)) \n\t           (st- (E V) (conts-/cons K Ks)).\nstep/fst    : step (stv- (pair- E1 E2) (conts-/cons (fst K) Ks)) \n\t           (st- E1 (conts-/cons K Ks)).\nstep/snd    : step (stv- (pair- E1 E2) (conts-/cons (snd K) Ks)) \n\t           (st- E2 (conts-/cons K Ks)).\nstep/force+ : step (stv- (delay+ V) (conts-/cons (force+ E) Ks)) \n\t           (st- (E V) Ks).\nstep/id-    : step (stv- V (conts-/cons id- Ks)) \n\t           (stv- V Ks).\nstep/ids    : step (stv- V conts-/nil) \n\t           (done V).\n\nstep/compose : step (st- (compose E K) Ks) \n\t\t         (st- E (conts-/cons  K Ks)).\nstep/return  : step (st- (return V) Ks) \n\t\t    (stv- V Ks).\nstep/cut+    : step (st- (cut+ V K) Ks) \n\t\t    (stv+ V (conts+/cons K Ks)).\n\n%worlds () (step _ _).\n%total D (step D _)."
          },
          "sha1": "730fhw2bt2y2nptesl4vrexhk62yfhv"
        }
      },
      {
        "title": "C machine and focusing (internalized compositon)",
        "ns": 0,
        "id": 2193,
        "revision": {
          "id": 5933,
          "timestamp": "2009-03-10T13:08:22Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "comment": "New page: %{  C Machine and Focusing }%  %{ == Syntax == }%  pos : type.  %name pos A+. neg : type.  %name neg A-.  down : neg -> pos. plus : pos -> pos -> pos. times : pos -> pos -> pos. zero  : po...",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 4423,
            "#text": "%{ \nC Machine and Focusing\n}%\n\n%{ == Syntax == }%\n\npos : type.  %name pos A+.\nneg : type.  %name neg A-.\n\ndown : neg -> pos.\nplus : pos -> pos -> pos.\ntimes : pos -> pos -> pos.\nzero  : pos.\none   : pos.\n\nup   : pos -> neg.\narr  : pos -> neg -> neg.\nwith : neg -> neg -> neg.\ntop  : neg.\n\n%abbrev conc = neg.\n\nval+  : pos -> type.\ncont- : neg -> conc -> type.\ncont+ : pos -> conc -> type.\nval-  : neg  -> type.\nexp   : conc -> type.\n\n%% positive values\n\nmt+    : val+ one.\n%% no rule for zero\npair+  : val+ A -> val+ B -> val+ (times A B).\ninl    : val+ A -> val+ (plus A B).\ninr    : val+ B -> val+ (plus A B).\ndelay- : exp A- -> val+ (down A-).\n\n%% positive continuations (shallow matching)\n\n%% positive conts\nlet1   : exp C -> cont+ one C.\n%% no rule for zero\nsplit  : (val+ A -> val+ B -> exp C) -> cont+ (times A B) C.\ncase   : (val+ A -> exp C) -> (val+ B -> exp C) -> cont+ (plus A B) C.\n%% wait to peel off the shift until you're ready to focus.\nforce- : cont- A- C -> cont+ (down A-) C.\ncomp+- : cont+ A+ B- -> cont- B- C- -> cont+ A+ C-.\n\n%% negative continuations\n\napp    : val+ A+ -> cont- B C -> cont- (arr A+ B) C.\nfst    : cont- A C -> cont- (with A B) C.\nsnd    : cont- B C -> cont- (with A B) C.\nforce+ : (val+ A+ -> exp C) -> cont- (up A+) C.\n%% internalize identity so we don't need to eta-expand\nid-    : cont- A A.\ncomp-- : cont- A- B- -> cont- B- C- -> cont- A- C-.\n\n%% negative values (shallow)\n\nlam    : (val+ A+ -> exp B-) -> val- (arr A+ B-).\npair-  : exp A- -> exp B- -> val- (with A- B-).\nmt-    : val- top.\ndelay+ : val+ A+ -> val- (up A+).  %% wait to peel off shift until focus\n\n%% neutral sequents\n\nreturn : val- A -> exp A.\n\n  %% canonical when the value is a variable;\n  %% non-canonical otherwise\ncut+   : val+ A+ -> cont+ A+ C -> exp C.\n  %% non-canonical\ncut-   : val- A- -> cont- A- C -> exp C.\n\ncompe- : exp A- -> cont- A- C- -> exp C-.\n\n%{ === Stack Machine === }%\n\n%% the sum type that you'd define for progress is\n%% (val C) + (exp C)\n%% so let's just abuse exp C for this sum and write the\n%% operational semantics as the progress proof.\n%% the only downside is that you can't tell whether an expression\n%% took a real step towards a value or already was a value.\n\nstep : exp C -> exp C -> type.\n%mode step +S1 -S2.\n\nstep/return : step (return V) (return V).\n\nstep/let1   : step (cut+ mt+ (let1 E)) E.\nstep/split  : step (cut+ (pair+ V1 V2) (split E)) (E V1 V2).\nstep/case1  : step (cut+ (inl V1) (case E1 E2)) (E1 V1).\nstep/case2  : step (cut+ (inr V2) (case E1 E2)) (E2 V2).\nstep/force- : step (cut+ (delay- E) (force- K)) (compe- E K).\nstep/app    : step (cut- (lam E) (app V K)) (compe- (E V) K).\nstep/fst    : step (cut- (pair- E1 E2) (fst K)) (compe- E1 K).\nstep/snd    : step (cut- (pair- E1 E2) (snd K)) (compe- E2 K).\nstep/force+ : step (cut- (delay+ V) (force+ E)) (E V).\nstep/id     : step (cut- V id-) (return V).\n\n%% find the redex\nstep/compe-/compe- : step (compe- (compe- E K1) K2) (compe- E (comp-- K1 K2)).\nstep/compe-/cut+   : step (compe- (cut+ V K1) K2) (cut+ V (comp+- K1 K2)).\nstep/compe-/cut-   : step (compe- (cut- V K1) K2) (cut- V (comp-- K1 K2)).\nstep/compe-/cut-   : step (compe- (return V) K2) (cut- V K2).\n\n%% find the top of the stack\nstep/comp+-/let1   : step (cut+ V (comp+- (let1 E) K)) \n\t\t          (cut+ V (let1 (compe- E K))).\nstep/comp+-/split  : step (cut+ V (comp+- (split E) K)) \n\t\t          (cut+ V (split [x] [y] (compe- (E x y) K))).\nstep/comp+-/case   : step (cut+ V (comp+- (case E1 E2) K)) \n\t\t          (cut+ V (case ([x] (compe- (E1 x) K)) ([x] (compe- (E2 x) K)))).\nstep/comp+-/force  : step (cut+ V (comp+- (force- K1) K2)) \n\t\t          (cut+ V (force- (comp-- K1 K2))).\nstep/comp+-/force  : step (cut+ V (comp+- (comp+- K1 K2) K3)) \n\t\t          (cut+ V (comp+- K1 (comp-- K2 K3))).\nstep/comp--/app    : step (cut- V1 (comp-- (app V2 K) K2))\n\t\t          (cut- V1 (app V2 (comp-- K K2))).\nstep/comp--/fst    : step (cut- V1 (comp-- (fst K) K2))\n\t\t          (cut- V1 (fst (comp-- K K2))).\nstep/comp--/snd    : step (cut- V1 (comp-- (snd K) K2))\n\t\t          (cut- V1 (snd (comp-- K K2))).\nstep/comp--/snd    : step (cut- V1 (comp-- (force+ E) K2))\n\t\t          (cut- V1 (force+ ([x] compe- (E x) K2))).\nstep/comp--/id     : step (cut- V1 (comp-- id- K))\n\t\t          (cut- V1 K).\nstep/comp--/id     : step (cut- V1 (comp-- (comp-- K1 K2) K))\n\t\t          (cut- V1 (comp-- K1 (comp-- K2 K))).\n\n%worlds () (step _ _).\n%total D (step D _)."
          },
          "sha1": "2gns6kiev5otqfsq3km308p08uvhhz4"
        }
      },
      {
        "title": "Canonical form",
        "ns": 0,
        "id": 1971,
        "revision": {
          "id": 4660,
          "parentid": 4658,
          "timestamp": "2007-03-26T04:58:17Z",
          "contributor": {
            "username": "William Lovas",
            "id": 11
          },
          "comment": "bold",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 4447,
            "#text": ": ''This page describes the canonical forms of the LF type theory.  You might also be looking for the [[canonical forms lemma]] used to prove the [[progress]] theorem about a programming language.\n\n'''Canonical forms''' are terms in a type theory that are both [[beta-equivalence|β-normal]] and [[eta-equivalence|η-long]].\n\nThe [[LF]] type theory is defined so that all well-typed terms are '''canonical forms'''.  This is useful because the LF methodology for representing object languages consists of creating an isomorphic representation of the object language as the canonical forms of particular LF types.  Defining the type theory with only canonical forms  uses an algorithm called [[hereditary substitution]].   \n\n== Syntax of LF == \n\n<math>\nK ::= \\texttt{type} \\, | \\, \\Pi x:A. K \n</math>\n\n<math>\nA ::= b \\, | \\, A \\, M \\, | \\, \\Pi x:A_1. A_2 \n</math>\n\n<math>\nR ::= c \\, | \\, x \\, | \\, R \\, M \n</math>\n\n<math>\nM ::= R \\, | \\, \\lambda x. M\n</math>\n\nIn Twelf's concrete syntax, the type <math>\\texttt{}\\Pi x:A_1.A_2</math> is written <tt>{x:A1} A2</tt>, the kind <math>\\texttt{}\\Pi x:A.K</math> is written <tt>{x:A} K</tt>, and the term <math>\\texttt{}\\lambda x.M</math> is written <tt>[x] M</tt>.  The type families include both dependent function types and applications <math>A \\, M</math> of type families to terms.  The kind level classifies type families. Type families of kind <math>\\texttt{type}</math> classify terms. Type families that are not yet fully instantiated have kinds <math> \\{x:A\\} K</math>.  In both types and kinds, we use <tt>-></tt> as an abbreviation when the argument is not free in the result.  \n\n== Motivation for canonical forms ==\n\nThe above syntax describes what we call ''[[canonical form]]s''.  Note what is ''not'' a canonical form: there is no syntactic way to apply a lambda-abstraction <math>\\texttt{}\\lambda x.M</math> to an argument.  Based on your past experience with programming languages, it may seem strange to define LF so that only canonical forms exist—we are not allowed to write down any programs that have any computation left to do.  However, this restriction makes sense if you think about our methodology for representing object languages in LF.  For example, we represent [[natural numbers]] with the following LF signature:\n<twelf>\nnat : type.\nz   : nat.\ns   : nat -> nat.\n</twelf>\nFor this representation to be [[adequate]], the only LF terms of type <tt>nat</tt> must be <tt>z</tt>, <tt>s z</tt>, <tt>s (s z)</tt>, and so on.  It is easy to see that non-canonical LF terms interfere with this encoding.  For example, the LF term <math>(\\lambda x. \\texttt{s} \\, x) \\, \\texttt{z}</math> would have type <tt>nat</tt>, but it is not the representation of any informal natural number. \n\n== Canonical LF ==\n\nIf you have encountered [[beta-reduction]] and [[eta-expansion]] before in your study of programming languages, it may help your intuition to know that the canonical forms of LF coincide with the beta-normal, eta-long terms of the lambda calculus.  What we were saying above is that the syntax of canonical forms forces them to be beta-normal,  and that the typing rules for canonical forms ensure that they are eta-long.  In logic, canonical forms correspond to normal and neutral natural deduction proofs and cut-free sequent calculus proofs.\n\nWe do not present the typing rules for canonical forms here (see, e.g., ''Mechanizing Metatheory''<ref>{{bibtex:hl07mechanizing}}</ref>).  However, we note two details:\n\nTerms <math>\\texttt{}R</math> are only canonical at base type <math>\\texttt{}a</math>, not at function type.  For example, the constant <tt>s</tt> is ''not'' a canonical form of type <tt>nat -> nat</tt>.  However, the term <math>\\lambda x.\\texttt{s} x</math>, which is equivalent, is a canonical form.  \n\nIn a dependently typed language, the application typing rules must substitute the argument into the body of the dependent function type:\n\n<math>\n{R : \\Pi x : A. B \\;\\;\\;\\; M : A \\over R \\; M : [M/x]B}\n</math>\n\nIn LF, this substitution is in fact a [[hereditary substitution]], ensuring that the terms embedded in the result of the substitution are in canonical form.  The typing rule for family applications <math>\\mathsf{}A \\; M</math> has a similar substitution into the result kind.\n\n== See also ==\n* See the [[introductions to Twelf]] to learn how object languages are represented as the canonical forms of LF.\n\n== References ==\n<references/>\n\n{{stub}}"
          },
          "sha1": "mdgon15w070w5nity3r10ks455l159j"
        }
      },
      {
        "title": "Canonical forms",
        "ns": 0,
        "id": 1973,
        "redirect": {
          "@title": "Canonical form",
          "#text": null
        },
        "revision": {
          "id": 4537,
          "timestamp": "2007-03-21T02:11:08Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "comment": "Redirecting to [[Canonical form]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 28,
            "#text": "#REDIRECT [[canonical form]]"
          },
          "sha1": "h4zz86e9hh8ras8wenrisbf9ucrjr1z"
        }
      },
      {
        "title": "Canonical forms lemma",
        "ns": 0,
        "id": 1526,
        "revision": {
          "id": 6104,
          "parentid": 4491,
          "timestamp": "2010-09-01T21:43:17Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "Fix twelftag bugs",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 8458,
            "#text": ":''This article is about proving an [[object language]] lemma. For the notion of canonical form within LF itself, see [[canonical form]].''\n\nIn a standard proofs of [[type safety]], the [[progress]] theorem requires '''canonical forms''' lemmas about the values in a language. These lemmas are usually in the form \"If e is a value and {{vdash}} e : T, then e is of some form appropriate for T\". A specific example would be \"If e is a value and {{vdash}} e : T1 → T2, then e is of the form λx:T1.e'\".\n\nDepending on the complexity of the type system, there are two general ways to state and prove these lemmas.  In some cases, Twelf's input coverage can give you the canonical forms lemma for free.  In other cases, you must state and prove canonical forms explicitly using [[equality]].  \n\n== Canonical forms lemmas for free ==\n\nIf there is only one rule through which the canonical form at a particular type can be derived, then Twelf's input coverage is actually strong enough to give you canonical forms for free via [[inversion]]. \n\nConsider the following language:\n\n<twelf import=\"free-judgements\">\ntp : type.\ntp/unit  : tp.\ntp/arrow : tp -> tp -> tp.\n\nexp : type.\n\nexp/unit : exp.\nexp/lam  : tp -> (exp -> exp) -> exp.\nexp/app  : exp -> exp -> exp.\n\nof : exp -> tp -> type.\n\nof/unit : of exp/unit tp/unit.\n\nof/lam  : of (exp/lam T1 E) (tp/arrow T1 T2)\n           <- ({x} of x T1\n                -> of (E x) T2).\n\nof/app  : of (exp/app E1 E2) T2\n           <- of E2 T1\n           <- of E1 (tp/arrow T1 T2).\n\n\nval : exp -> type.\n\nval/unit : val exp/unit.\n\nval/lam  : val (exp/lam _ _).\n\n\nstep : exp -> exp -> type.\n\nstep/app-1    : step (exp/app E1 E2) (exp/app E1' E2)\n                 <- step E1 E1'.\n\nstep/app-2    : step (exp/app E1 E2) (exp/app E1 E2')\n                 <- step E2 E2'\n                 <- val E1.\n\nstep/app-beta : step (exp/app (exp/lam _ E) E2) (E E2)\n                 <- val E2.\n\n\nnotstuck : exp -> type.\n\nnotstuck/val  : notstuck E\n                 <- val E.\n\nnotstuck/step : notstuck E\n                 <- step E E'.\n</twelf>\n\nTo prove progress for this language, we use an [[output factoring]] lemma that collects the post-inductive-call reasoning in the application case:\n\n<twelf export=\"free\" import=\"free-judgements\">\nprogress-exp/app : notstuck E1\n                    -> notstuck E2\n                    -> of E1 (tp/arrow _ _)\n                    -> notstuck (exp/app E1 E2)\n                    -> type.\n%mode progress-exp/app +D1 +D2 +D3 -D4.\n\n- : progress-exp/app (notstuck/step S)  _ _ \n     (notstuck/step (step/app-1 S)).\n\n- : progress-exp/app (notstuck/val V) (notstuck/step S) _\n     (notstuck/step (step/app-2 V S)).\n\n- : progress-exp/app (notstuck/val val/lam) (notstuck/val V2) (of/lam _)\n     (notstuck/step (step/app-beta V2)).\n\n%worlds () (progress-exp/app _ _ _ _).\n%total {} (progress-exp/app _ _ _ _).\n</twelf>\n\nIn the final case, we use inversion to assert that <tt>E1</tt> is a value in the form of a lambda. Because we also pass in a typing derivation that says E1 is of an arrow type, Twelf's input coverage verifies that the only time <tt>E1</tt> is a value and has an arrow type is when it is a lambda. Because the type system is simple enough that Twelf can figure out that the only values of arrow type are lambdas, we get canonical forms \"for free\".\n\nIt is then simple to complete the proof of progress:\n<twelf import=\"free\" check=true>\nprogress : of E T\n            -> notstuck E\n            -> type.\n%mode progress +D1 -D2.\n\n- : progress of/unit (notstuck/val val/unit).\n\n- : progress (of/lam _) (notstuck/val val/lam).\n\n- : progress (of/app D1 D2) NS\n     <- progress D1 NS1\n     <- progress D2 NS2\n     <- progress-exp/app NS1 NS2 D1 NS.\n\n%worlds () (progress _ _).\n%total (D1) (progress D1 _).\n</twelf>\n\n== Canonical forms lemmas stated using equality ==\n\nSome languages do not have the luxury of having exactly one rule through which a canonical form could be derived. This is common for languages with re-typing rules that make use of subtyping/type equality. In such languages, canonical forms lemmas must be explicitly stated and proven. The conclusion of the lemma \"e is of the form ...\" can be stated in a straightforward way using [[shallow equality]]. This example makes use of [[output factoring]] and [[reasoning from equality]].\n\nFor example, we extend the above language with a trivial notion of subtyping. It is equivalent to syntactic equality on types. The purpose of this tutorial is to illustrate how to state/prove canonical forms lemmas when subtyping/equality are part of the type system, and this trivial notion is enough to motivate the discussion.\n\n<twelf import=\"free-judgements\" export=\"equality-judgements\">\ntp-sub  : tp -> tp -> type.\n\ntp-sub/unit  : tp-sub tp/unit tp/unit.\n\ntp-sub/arrow : tp-sub (tp/arrow T1 T2) (tp/arrow T3 T4)\n                <- tp-sub T2 T4\n                <- tp-sub T3 T1.\n\nof/sub  : of E1 T2\n           <- tp-sub T1 T2\n           <- of E1 T1.\n</twelf>\n\nNow, we state and prove the canonical forms lemma explicitly.  In the theorem statement, we use the syntactic equality judgement as an output in order to state \"E1 is of the form (exp/lam T E)\".\n\n<twelf import=\"equality-judgements\" export=\"equality\">\nseq-exp : exp -> exp -> type.\nseq-exp/i : seq-exp E E. \n\ncfl-tp/arrow    : val E1\n                  -> of E1 (tp/arrow _ _)\n                  -> seq-exp E1 (exp/lam T E)\n                  -> type.\n%mode cfl-tp/arrow +D1 +D2 -D3.\n\n- : cfl-tp/arrow val/lam (of/lam _) seq-exp/i.\n\n- : cfl-tp/arrow V (of/sub D1 (tp-sub/arrow _ _)) DQ\n     <- cfl-tp/arrow V D1 DQ.\n\n%worlds () (cfl-tp/arrow _ _ _).\n%total (D1) (cfl-tp/arrow _ D1 _).\n</twelf>\n\nNext, we define a helper lemma for showing that (exp/app E1 E2) is notstuck when E1 is of the form (exp/lam T E) and E2 is a value.  We use this lemma because we get the derivation of (seq-exp E1 (exp/lam T E)) as the output of the canonical forms lemma. If we were to try to invert the derivation as an output, we would cause Twelf's coverage checker to fail. So instead, we call a helper lemma with the equality derivation as an input. Because the derivation is an input, we can safely apply inversion on it.\n\n<twelf import=\"equality\">\nprogress-exp/app-beta : seq-exp E1 (exp/lam T E)\n                         -> val E2\n                         -> notstuck (exp/app E1 E2)\n                         -> type.\n%mode progress-exp/app-beta +D1 +D2 -D3.\n\n- : progress-exp/app-beta seq-exp/i V (notstuck/step (step/app-beta V)).\n\n%worlds () (progress-exp/app-beta _ _ _).\n%total {} (progress-exp/app-beta _ _ _).\n</twelf>\n\nNext, we prove the output factoring lemma:\n\n<twelf import=\"equality\">\nprogress-exp/app : notstuck E1\n                    -> notstuck E2\n                    -> of E1 (tp/arrow _ _)\n                    -> notstuck (exp/app E1 E2)\n                    -> type.\n%mode progress-exp/app +D1 +D2 +D3 -D4.\n\n- : progress-exp/app (notstuck/step S)  _ _\n     (notstuck/step (step/app-1 S)).\n\n- : progress-exp/app (notstuck/val V) (notstuck/step S) _\n     (notstuck/step (step/app-2 V S)).\n</twelf>\n\nBecause there is more than one way to derive that a value that has an arrow type, we must use the canonical forms lemma we have just proven. To make use of the equality we get out of the canonical forms lemma, we call the special helper lemma progress-exp/app-beta.\n\n<twelf import=\"equality\" check=true>\n- : progress-exp/app (notstuck/val V) (notstuck/val V2) D1\n     NS\n     <- cfl-tp/arrow V D1 DQ\n     <- progress-exp/app-beta DQ V2 NS.\n\n%worlds () (progress-exp/app _ _ _ _).\n%total {} (progress-exp/app _ _ _ _).\n</twelf>\n\nFinally, we prove the overall progress theorem as before.  \n\n<twelf import=\"equality\" check=true>\nprogress : of E T\n            -> notstuck E\n            -> type.\n%mode progress +D1 -D2.\n\n- : progress of/unit (notstuck/val val/unit).\n\n- : progress (of/lam _) (notstuck/val val/lam).\n\n- : progress (of/app D1 D2) NS\n     <- progress D1 NS1\n     <- progress D2 NS2\n     <- progress-exp/app NS1 NS2 D1 NS.\n\n- : progress (of/sub D1 _) NS\n     <- progress D1 NS.\n\n%worlds () (progress _ _).\n%total (D1) (progress D1 _).</twelf>\n\nThe only change from before is the case for of-sub, where the inductive hypothesis gives the result.\n\nNote: There is actually a very subtle way to prove <tt>progress-exp/app</tt> using canonical forms lemmas \"for free\". However, explicitly stating and proving the canonical forms lemma is the more robust strategy in general.\n\n{{tutorial}}"
          },
          "sha1": "97w676jcf0nw7texe6f6dh0637nashm"
        }
      },
      {
        "title": "Case studies",
        "ns": 0,
        "id": 1688,
        "revision": {
          "id": 5893,
          "parentid": 5710,
          "timestamp": "2009-02-22T08:00:56Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "/* Advanced */",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 4161,
            "#text": "The following '''case studies''' present interesting applications of Twelf.  Some of these case studies use proof techniques that are explained in the [[tutorials]], so you may wish to read those first.  \n\nFeel free to add your own case studies here.  We would welcome experience reports that document not just the Twelf code you wrote but your experience writing it. (If the goal of your article is to teach a specific Twelf technique, it should instead be a [[tutorials|tutorial]], and if your Twelf code is off-site, you should instead add it to the list of [[Research projects using Twelf]].)\n\n==== Beginner ====\n\n* [[Bracket abstraction]], by [[User:William Lovas|William Lovas]]\n: A translation of the untyped lambda calculus into the SKI combinator calculus.  Bracket abstraction is defined by pattern matching over LF-level lambda abstractions, making essential use of [[higher-order abstract syntax]].\n\n* [[Typed combinators soundness and completeness]], by [[User:William Lovas|William Lovas]]\n: A translation of the simply-typed lambda calculus into the SKI combinator calculus.  The translation is shown correct by showing that it preserves and reflects full beta-eta equality.  This case study uses uses [[Intrinsic and extrinsic encodings|intrinsic typing]] and [[regular worlds|open worlds]]. (Roughly an extended version of the above [[bracket abstraction]] case study.)\n\n* [[Division over the natural numbers]], by [[User:DanielKLee|Daniel K. Lee]]\n: A study of the encoding of division over the natural numbers. The definition is shown to be \"correct\" in a number of ways, including termination of division by a non-zero number and correctness with respect to multiplication. The former involves a use of <tt>%reduces</tt> for strong induction.\n\n* [[Church-Rosser via complete development]], by [[User:drl|Dan Licata]]\n: Takahashi's proof of the diamond property of parallel reduction.  This case study includes lots of examples of theorems in [[regular world]]s.\n\n* [[Admissibility of cut]], by [[User:Tom7|Tom Murphy VII]]\n: A proof of an important theorem about an intuitionistic sequent calculus. Uses lexicographic [[%terminates|termination]] orderings.\n\n* [[Hereditary substitution for the STLC]], by [[User:drl|Dan Licata]] \n: The above proof of cut admissibility recast as an algorithm for normalizing λ-terms.  Uses many of the proof techniques explained in the [[tutorials]].\n\n* [[Double-negation translation]], by [[User:drl|Dan Licata]] \n: The Godel-Gentzen negative translation of classical logic into intuitionistic logic.\n\n* [[Linear logic]], by [[User:Crary|Karl Crary]] \n: An encoding of linear logic that uses a judgment to enforce linearity, along with a proof of subject reduction for it.\n\n* [[Mutable state]], by [[User:Rsimmons|Robert J. Simmons]]\n: Encoding a simple imperative language with state.\n\n* [[Zermelo Frankel]], by Daniel Wang\n: A particular encoding of ZF set theory in Twelf\n\n* Twelf Data structures:\n** [[heterogeneous lists| Lists]], by [[User:Varming|Carsten Varming]]\n** [[natural numbers with inequality | Unary natural numbers with inequality]], by [[User:Rsimmons|Robert J. Simmons]]\n** [[Dense lexicographical orderings]], by [[User:DanielKLee|Daniel K. Lee]]\n\n==== Advanced ====\n\n* [[CPS conversion]], by [[User:Tom7|Tom Murphy VII]]\n: A type-directed conversion from direct style lambda calculus into continuation passing style.\n\n* [[Classical S5]], by [[User:Tom7|Tom Murphy VII]]\n: A proof that a non-standard natural deduction for the modal logic Classical S5 is equivalent to the standard cut-free sequent calculus.\n\n* [[Lily]], by [[User:Varming|Carsten Varming]]\n: An encoding of a polymorphic linear lambda calculus with fixed points in LF, and a metatheorem proving that ground contextual equivalence with respect to a call-by-name semantics coincides with ground contextual equivalence with respect to a call-by-value semantics.\n\n* [[Lax logic]], by [[User:Rsimmons|Robert J. Simmons]]\n: Establishing the correspondence between two different presentations of propositional lax logic and showing soundness and completeness of the two systems, in the process establishing cut and identity."
          },
          "sha1": "o4l0m37tyymivfkrkif1ou830qet8my"
        }
      },
      {
        "title": "Catch-all case",
        "ns": 0,
        "id": 1892,
        "revision": {
          "id": 6336,
          "parentid": 4783,
          "timestamp": "2011-09-13T19:06:21Z",
          "contributor": {
            "username": "Luke Maurer",
            "id": 167
          },
          "minor": null,
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 9232,
            "#text": "When defining relations in non-empty contexts, it is often necessary to put a case of the relation in the LF context. In some circumstances, it is possible to avoid doing so by writing a '''catch-all case''' instead. \nThis technique works when you can cover the space of the relation that would be covered by a context case without mentioning any variables from the context explicitly.  \n\nUsing a catch-all case leads to simpler Twelf code because it saves you from having to repeat the context case at a variety of context extension points.  \n\nAs a motivating example, we use the theorem about the size of a STLC term from {{proving|title=Proving metatheorems in non-empty contexts}}.  For review, here are the relevant judgements:\n\n<twelf>\ntp    : type.\nunit  : tp.\narrow : tp -> tp -> tp.\n\ntm    : type.\nempty : tm.\nlam   : tp -> (tm -> tm) -> tm.\napp   : tm -> tm -> tm.\n\nnat : type.\nz   : nat.\ns   : nat -> nat.\n\nplus   : nat -> nat -> nat -> type.\n%mode plus +X1 +X2 -X3.\n\nplus-z : plus z N2 N2.\nplus-s : plus (s N1) N2 (s N3)\n\t  <- plus N1 N2 N3.\n\n%worlds () (plus _ _ _).\n%total N (plus N _ _).\n</twelf>\n<twelf hidden=\"true\">\nplus-exists : {N1} {N2} plus N1 N2 N3 -> type.\n%mode plus-exists +X1 +X2 -X3.\n\n- : plus-exists z _ plus-z.\n- : plus-exists (s N1) N2 (plus-s D)\n     <- plus-exists N1 N2 D.\n\n%worlds () (plus-exists _ _ _).\n%total N1 (plus-exists N1 _ _).\n\nplus-z-rh : {n:nat} plus n z n -> type.\n%mode plus-z-rh +N -D.\n\n- : plus-z-rh z plus-z.\n- : plus-z-rh (s N) (plus-s D)\n     <- plus-z-rh N (D : plus N z N).\n\n%worlds () (plus-z-rh _ _).\n%total N (plus-z-rh N _).\n\nplus-s-rh : plus N1 N2 N3 -> plus N1 (s N2) (s N3) -> type.\n%mode plus-s-rh +D1 -D2.\n\n- : plus-s-rh plus-z plus-z.\n- : plus-s-rh (plus-s (D : plus N1' N2 N3')) (plus-s D')\n     <- plus-s-rh D (D' : plus N1' (s N2) (s N3')).\n\n%worlds () (plus-s-rh _ _).\n%total D (plus-s-rh D _).\n\nplus-commute : plus N1 N2 N3 -> plus N2 N1 N3 -> type.\n%mode plus-commute +D1 -D2.\n\n-       : plus-commute (plus-z : plus z N N) D\n           <- plus-z-rh N D.\n-       : plus-commute (plus-s D : plus (s N1) N2 (s N3)) D''\n           <- plus-commute D (D' : plus N2 N1 N3)\n           <- plus-s-rh D' (D'' : plus N2 (s N1) (s N3)).\n\n%worlds () (plus-commute _ _).\n%total D (plus-commute D _).\n\nid/nat      : nat -> nat -> type.\nid/nat-refl : id/nat N N.\n\nid/nat-s-cong : id/nat N1 N2\n                 -> id/nat (s N1) (s N2)\n                 -> type.\n%mode id/nat-s-cong +X1 -X2.\n\n- : id/nat-s-cong id/nat-refl  id/nat-refl.\n\n%worlds () (id/nat-s-cong _ _).\n%total {} (id/nat-s-cong _ _).\n\nplus-unique : plus N1 N2 N3\n\t      -> plus N1 N2 N3'\n\t      -> id/nat N3 N3'\n\t      -> type.\n%mode plus-unique +X1 +X2 -X3.\n\n- : plus-unique D D id/nat-refl.\n- : plus-unique (plus-s D) (plus-s D') DidS\n     <- plus-unique D D' Did\n     <- id/nat-s-cong Did DidS.\n\n%worlds () (plus-unique _ _ _).\n%total D (plus-unique D _ _).\n\nplus-respects-id : plus N1 N2 N3\n                   -> id/nat N1 N1'\n                   -> id/nat N2 N2'\n                   -> id/nat N3 N3'\n                   -> plus N1' N2' N3'\n                   -> type.\n%mode plus-respects-id +X1 +X2 +X3 +X4 -X5.\n\n- : plus-respects-id D id/nat-refl id/nat-refl id/nat-refl  D.\n\n%worlds () (plus-respects-id _ _ _ _ _).\n%total {} (plus-respects-id _ _ _ _ _).\n\nid/nat-sym : id/nat N1 N2\n              -> id/nat N2 N1\n              -> type.\n%mode id/nat-sym +X1 -X2.\n\n- : id/nat-sym id/nat-refl  id/nat-refl.\n\n%worlds () (id/nat-sym _ _).\n%total {} (id/nat-sym _ _).\n\nplus-assoc : plus A B AB\n             -> plus B C BC\n             -> plus AB C ABC\n             -> plus A BC ABC\n             -> type.\n%mode plus-assoc +X1 +X2 +X3 -X4.\n\n- : plus-assoc \n     plus-z\n     DplusB-C \n     DplusB-C' \n     Dplus\n     <- plus-unique DplusB-C DplusB-C' Did\n     <- plus-respects-id plus-z id/nat-refl id/nat-refl Did Dplus.\n\n- : plus-assoc \n     (plus-s DplusA'-B)\n     DplusB-C\n     (plus-s DplusA'B-C) \n     (plus-s DplusA'-BC)\n     <- plus-assoc DplusA'-B DplusB-C DplusA'B-C DplusA'-BC.\n\n%worlds () (plus-assoc _ _ _ _).\n%total D (plus-assoc D _ _ _).\n\nplus-assoc2 : plus A B AB\n\t       -> plus B C BC\n\t       -> plus AB C ABC\n\t       -> plus A BC ABC\n\t       -> type.\n%mode plus-assoc2 +X1 +X2 -X3 +X4.\n\n- : plus-assoc2 D1 D2 D3' D4\n     <- plus-exists _ _ D3\n     <- plus-assoc D1 D2 D3 D4'\n     <- plus-unique D4 D4' Did\n     <- id/nat-sym Did Did'\n     <- plus-respects-id D3 id/nat-refl id/nat-refl Did' D3'.\n\n%worlds () (plus-assoc2 _ _ _ _).\n%total {} (plus-assoc2 _ _ _ _).\n\nlemma : plus N1 N2 Nsum\t      \n\t -> plus Ndiff1 N1 N1'\n\t -> plus Ndiff2 N2 N2'\n\t -> plus N1' N2' Nsum'\n\t -> plus Ndiff Nsum  Nsum'\n\t -> type.\n%mode lemma +X1 +X2 +X3 +X4 -X5.\n\n- : lemma \n     (D    : plus N1 N2 Nsum)\n     (D1pre   : plus Ndiff1 N1 N1')\n     (D2pre   : plus Ndiff2 N2 N2')\n     (D'   : plus N1' N2' Nsum')\n     Dres'\n     %% there's probably a way to do without these two commutes\n     %% and the one at the end;\n     %% proof was originally written with the other argument order\n     <- plus-commute D1pre D1\n     <- plus-commute D2pre D2\n     <- plus-exists Ndiff1 N2' (Ddiff1+2' : plus Ndiff1 N2' Ndiff1+2')\n     <- plus-assoc D1 Ddiff1+2' D' (Dassoc : plus N1 Ndiff1+2' Nsum')\n     <- plus-commute D2 (D2' : plus Ndiff2 N2 N2')\n     <- plus-exists Ndiff1 Ndiff2 (Ddiff1+2 : plus Ndiff1 Ndiff2 Ndiff1+2)\n     <- plus-assoc2 Ddiff1+2 D2' \n\t(Dassoc' : plus Ndiff1+2 N2 Ndiff1+2')\n\tDdiff1+2'\n     <- plus-commute Dassoc' \n\t(Dassoc'' : plus N2 Ndiff1+2 Ndiff1+2')\n     <- plus-assoc2 D Dassoc'' Dres Dassoc\n     <- plus-commute Dres Dres'.\n\n%worlds () (lemma _ _ _ _ _).\n%total {}  (lemma _ _ _ _ _).\n</twelf>\n<twelf check=\"true\">\nsize       : tm -> nat -> type.\n%mode size +E -N.\n\nsize-empty : size empty (s z). \nsize-lam   : size (lam _ E) (s N)\n\t\t<- ({x} {dx : size x (s z)}\n\t\t      size (E x) N).\nsize-app   : size (app E1 E2) (s N)\n\t\t<- size E1 N1\n\t\t<- size E2 N2 \n\t\t<- plus N1 N2 N.\n\n%block size-block : block {x : tm} {dx : size x (s z)}.\n\n%worlds (size-block) (size _ _).\n%total E (size E _).\n</twelf>\n\n==Original proof==\n<twelf hidden=\"true\">\nsize-at-least-one : size E N\n\t\t      -> plus (s z) N' N\n\t\t      -> type.\n%mode size-at-least-one +X1 -X2.\n\n- : size-at-least-one _ (plus-s plus-z).\n\n%worlds (size-block) (size-at-least-one _ _).\n%total {} (size-at-least-one _ _).\n</twelf>\n\nIn {{proving|title=Proving metatheorems in non-empty contexts}}, we proved the following theorem:\n\n<twelf>\nsubst-size : {E' : tm}\n\t       ({x : tm} size x (s z) -> size (E x) N)\n\t       -> size (E E') N'\n\t       -> plus Ndiff N N'\n\t       -> type.\n%mode subst-size +E' +D1 +D2 -DL.\n\n%block sdblock : block {y : tm} \n\t\t       {dy : size y (s z)}\n\t\t       {_ : {E' : tm} subst-size E' ([x] [dx] dy) dy plus-z}.\n\n%worlds (sdblock) (subst-size _ _ _ _).\n</twelf>\n\nThe <tt>%block</tt> declaration includes a case of the theorem for the variable <tt>dy</tt> declared in the context.  \n\n==Alternate proof using a catch-all case==\n\nIn this instance, it is possible to avoid putting the theorem case in the context.  How?  We instead write a catch-all case that covers the context variable case '''without mentioning the context variable explicitly''':\n\n<twelf check=\"true\">\nsubst-size-ca : {E' : tm}\n\t\t  ({x : tm} size x (s z) -> size (E x) N)\n\t\t  -> size (E E') N'\n\t\t  -> plus Ndiff N N'\n\t\t  -> type.\n%mode subst-size-ca +E' +D1 +D2 -DL.\n\n- : subst-size-ca E'\n     ([x] [dx] D)\n     D\n     plus-z.\n</twelf>\n\nThis case covers any first-argument derivation <tt>D</tt> that does not mention the bound variables <tt>x</tt> and <tt>dx</tt>, as long as the second argument is also that derivation <tt>D</tt>.  Note that the context case in the previous proof has this form.  To complete the proof for these inputs, we simply use <tt>plus-z : plus z N N</tt> to derive the result. This technique works because we do not actually need to use any reasoning specific to the variable from the context.\n\nThe remaining cases are the same as in the previous proof, except that \n* the catch-all case happens to cover the case for <tt>size-empty</tt> as well, so we can elide it.\n* the case for <tt>size-lam</tt> no longer adds the theorem case to the context.\n\n<twelf check=\"true\">\n- : subst-size-ca E'\n     ([x] [dx] dx)\n     D\n     Dplus'\n     <- size-at-least-one D Dplus\n     <- plus-commute Dplus Dplus'.\n     \n- : subst-size-ca E'\n     ([x] [dx] \n\t(size-lam ([y] [dy] D x dx y dy)\n\t   %% tell reconstruction that T doesn't depend on x\n\t   : size (lam T _) _))\n     (size-lam D')\n     Dplus'\n     <- ({y : tm}\n\t   {dy : size y (s z)}\n\t   subst-size-ca E' ([x] [dx] D x dx y dy) (D' y dy) Dplus)\n     <- plus-s-rh Dplus Dplus'.\n\n- : subst-size-ca E'\n     ([x] [dx] \n\tsize-app \n\t(Dplus : plus N1 N2 Nsum)\n\t((D2 x dx) : size (E2 x) N2)\n\t((D1 x dx) : size (E1 x) N1)\n\t)\n     (size-app \n\t(Dplus' : plus N1' N2' Nsum')\n\t(D2' : size (E2 E') N2')\n\t(D1' : size (E1 E') N1'))\n     DplusRes'\n     <- subst-size-ca E' D1 \n\t(D1' : size (E1 E') N1')\n\t(Dplus1 : plus Ndiff1 N1 N1')\n     <- subst-size-ca E' D2 \n\t(D2' : size (E2 E') N2')\n\t(Dplus2 : plus Ndiff2 N2 N2')\n     <- lemma Dplus Dplus1 Dplus2 Dplus' DplusRes\n     <- plus-s-rh DplusRes DplusRes'.\n%worlds (size-block) (subst-size-ca _ _ _ _).\n%total D (subst-size-ca _ D _ _).\n</twelf>\n\n{{tutorial}}"
          },
          "sha1": "sf9ulyowv8y6iucmbm37p17rkhjl38a"
        }
      },
      {
        "title": "Church-Rosser (w/ catch-all case)",
        "ns": 0,
        "id": 2137,
        "revision": {
          "id": 5682,
          "parentid": 5681,
          "timestamp": "2008-11-22T23:04:43Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 12389,
            "#text": "%{ == Syntax == }%\n\nexp : type.  %name exp E.\nlam : (exp -> exp) -> exp.\napp : exp -> exp -> exp.\n\n%{ \n\nWhen we use this <tt>%block</tt>, it expresses that we can be working in a \ncontext with arbitrary expression variables. \n\n}%\n\n%block exps : block {x: exp}.\n%worlds (exps) (exp).\n\n%{ == Reduction == }%\n%{ \n\nWe can reduce under binders and \nreduce both sides of an application \"in parallel.\" If we have a β-redex \n<tt>(λx.ea) eb</tt>, then after reducing <tt>ea</tt> (with <tt>x</tt> free) to \n<tt>ea'</tt> (with <tt>x</tt> free) and reducing <tt>eb</tt> to <tt>eb'</tt>,\nwe can return <tt>[eb'/x]ea'</tt>, the substitution of <tt>eb'</tt> into\n<tt>ea'</tt>. When we introduce a new variable, we always add in the fact \nthat it can evaluate to itself.\n\nThe <tt>%block</tt> <tt>exps_red</tt> \nexplicitly states that we will be reducing in a setting \nwith free variables, with the invariant that every variable is added\nwith the invariant that it can evaluate to itself.\n\n}%\n\nreduce : exp -> exp -> type.\n%mode reduce +E -E'.\n\nreduce/lam : reduce (lam E) (lam E')\n              <- ({x:exp} reduce x x -> reduce (E x) (E' x)).\n\nreduce/app : reduce (app E1 E2) (app E1' E2')\n              <- reduce E1 E1'\n              <- reduce E2 E2'.\n\nreduce/beta : reduce (app (lam E1) E2) (E1' E2')\n              <- ({x:exp} reduce x x -> reduce (E1 x) (E1' x))\n              <- reduce E2 E2'.\n\n%block exps_red : block {x: exp}{d: reduce x x}.\n%worlds (exps_red) (reduce _ _).\n%total E (reduce E _).\n\n%{ === Reduction is reflexive === }%\n%{ \n\nWe will need to know later that reduction is reflexive. It is an easy\nproof by induction on the first argument, but we cannot get away with\nusing a [[catch-all case]], so when we go under a binder. This forces us\nto describe a new world, <tt>exps_id</tt>, that captures the variable\ncase of this theorem.\n\n}%\n\nidentity : {E} reduce E E -> type.\n%mode identity +A -B.\n\n- : identity (lam ([x] E x)) (reduce/lam D)\n     <- ({x}{idx : reduce x x} \n           identity x idx\n           -> identity (E x) (D x idx : reduce (E x) (E x))).\n\n- : identity (app E1 E2) (reduce/app D2 D1)\n     <- identity E1 (D1 : reduce E1 E1)\n     <- identity E2 (D2 : reduce E2 E2).\n\n%block exps_id : block {x: exp}{redx: reduce x x}{idx: identity x redx}.\n%worlds (exps_id) (identity _ _).\n%total T (identity T _).\n\n%{ == Substitution == }%\n%{ \n\nThe substitution theorem says that if we have a term <tt>e</tt> with \n<tt>x</tt> free that reduces to <tt>e'</tt> (with <tt>x</tt> still free)\nand <tt>e<sub>arg</sub></tt> reduces to <tt>e'<sub>arg</sub></tt>, \nthen <tt>[e<sub>arg</sub>/x]e</tt> reduces to <tt>[e'<sub>arg</sub>/x]e'</tt>. \n\nThe proof is by induction on the structure of the term with the free variable.\n\n}%\n\nsubstitute \n   : ({x: exp} reduce x x -> reduce (E x) (E' x))\n      -> reduce Earg Earg'\n      -> reduce (E Earg) (E' Earg') -> type.\n%mode substitute +D +Darg -D'.\n\n%{ \n\nWe actually need to think about what block this theorem will take place in,\nbecause there are at least two options. In this variant, we utilize the\ntechnique of using a [[catch-all case]] in order to avoid putting\na fact about variable substitution cases in the context. This latter\nstyle is used in the Twelf examples directory and is explored on the wiki\nin the page [[Church-Rosser (alternate substitution theorem)]].\n\nThe interesting cases are really the first two - if we reach a reduction for\nthe variable we are substituing for, then our second argument is \nthe answer (the rest of the time that variable just gets passed around).\nIf we reach a point where the\nvariable we are substuiting for doesn't even appear in the term (this\nis the catch-all case), then that first argument is the answer.\n\n}%\n\n- : substitute ([x] [redx: reduce x x] redx) Darg Darg.\n\n- : substitute ([x] [redx: reduce x x] D) Darg D.\n\n- : substitute \n     ([x] [redx: reduce x x] \n        reduce/lam \n        (D x redx : {y} reduce y y -> reduce (E x y) (E' x y)))            \n     (Darg: reduce Earg Earg')\n     (reduce/lam D'\n        : reduce (lam ([y] (E Earg) y)) (lam ([y] (E' Earg') y)))\n     <- ({y} {redy: reduce y y} \n           substitute ([x] [redx: reduce x x] D x redx y redy) Darg \n           (D' y redy : reduce (E Earg y) (E' Earg' y))).\n\n- : substitute\n     ([x] [redx: reduce x x]\n        reduce/app\n        (Db x redx : reduce (Eb x) (Eb' x))\n        (Da x redx : reduce (Ea x) (Ea' x)))\n     (Darg: reduce Earg Earg')\n     (reduce/app Db' Da' \n        : reduce (app (Ea Earg) (Eb Earg)) (app (Ea' Earg') (Eb' Earg')))\n     <- substitute Da Darg (Da': reduce (Ea Earg) (Ea' Earg'))\n     <- substitute Db Darg (Db': reduce (Eb Earg) (Eb' Earg')).\n\n- : substitute\n     ([x] [redx: reduce x x]\n        reduce/beta\n        (Db x redx : reduce (Eb x) (Eb' x))\n        (Da x redx : {y} reduce y y -> reduce (Ea x y) (Ea' x y)))\n     (Darg: reduce Earg Earg')\n     (reduce/beta Db' Da'\n        : reduce (app (lam (Ea Earg)) (Eb Earg)) ((Ea' Earg') (Eb' Earg')))\n     <- ({y} {redy: reduce y y}\n           substitute ([x] [redx: reduce x x] Da x redx y redy) Darg \n           (Da' y redy : reduce (Ea Earg y) (Ea' Earg' y)))\n     <- substitute Db Darg (Db': reduce (Eb Earg) (Eb' Earg')).\n\n%worlds (exps_red) (substitute _ _ _).\n%total D (substitute D _ _).\n\n%{ == The Diamond Property == }%\n%{\n\nNow we come to the interesting part: the diamond property.\n\n    E\n   / \\\n  /   \\\n E1   E2\n  \\   /\n   \\ /\n    E'\n\nIf <tt>E</tt> reduces to both <tt>E1</tt>, and <tt>E2</tt>, then there is a \ncommon E' such that <tt>E1</tt> and <tt>E2</tt> both reduce to it.\n\n}%\n\ndiamond : reduce E E1 -> reduce E E2 -> reduce E1 E' -> reduce E2 E' -> type.\n%mode diamond +X1 +X2 -X3 -X4.\n\n%{ === Identity === }%\n%{ \n\nIf either case is the identity, then we are done. \n\n id:    E  D:       D:     E  id:\n e=>e  / \\ e=>e2    e=>e1 / \\ e=>e\n      /   \\              /   \\\n     E    E2            E1    E\n D:   \\   /id:      id:  \\   /D:\n e=>e2 \\ / e2=>e2   e1=>e1\\ / e=>e1\n        e2                 E1\n\n}%\n\n- : diamond (ID : reduce E E) (D : reduce E E2) \n     D ID'\n     <- identity E2 ID'. \n- : diamond (D : reduce E E1) (ID : reduce E E) \n     (ID' : reduce E1 E1) D\n     <- identity E1 ID'.\n\n%{ === Lambda-Lambda === }%\n%{ \n\nIf both cases are reductions under a binder, we pull the result straight \nfrom the induction hypothesis. \n\n             λx.e              by induction:\n reduce/lam   / \\  reduce/lam    D1, D2 ---> D1': e1'=>e'\n (D1: e=>e1) /   \\ (D2: e=>e2)               D2': e2'=>e'\n            /     \\\n         λx.e1   λx.e2\n            \\     /\n reduce/lam  \\   / reduce/lam\n D1'          \\ /  D2'\n             λx.e' \n\nNote the oversimplification being made in the graphical presentation, in that\nthe subterms and sub-derivations are not clearly shown to have a free variable.\nTwelf will, of course, not allow this sloppiness.\n\n}%\n\n- : diamond \n     (reduce/lam (D1 : {x: exp}{redx: reduce x x} reduce (E x) (E1 x))\n        : reduce (lam E) (lam E1))\n     (reduce/lam (D2 : {x: exp}{redx: reduce x x} reduce (E x) (E2 x))\n        : reduce (lam E) (lam E2))\n     (reduce/lam D1') (reduce/lam D2')\n     <- ({x: exp}{redx: reduce x x}{idx: identity x redx}\n           diamond (D1 x redx) (D2 x redx)\n          (D1' x redx : reduce (E1 x) (E' x))\n          (D2' x redx : reduce (E2 x) (E' x))).\n\n%{ === Application-Application === }%\n%{\n\nIf both cases are applications, we pull the result straight from the \ninduction hypothesis. \n\n                  ea eb                by induction\n reduce/app       /   \\   reduce/app     D1a, D2a ---> D1a': e1a=>ea'\n (D1b: eb=>e1b)  /     \\  (D2b: eb=>e2b)               D2a': e2a=>ea'\n (D1a: ea=>e1a) /       \\ (D2a: ea=>e2a) D1b, D2b ---> D1b': e1b=>eb' \n            e1a e1b   e2a e2b                          D2b': e2b=>eb'\n                \\       /\n reduce/app      \\     /  reduce/app\n D1b' D1a'        \\   /   D2b' D2a'\n                 ea' eb'\n}%\n\n- : diamond \n     (reduce/app (D1b : reduce Eb E1b) (D1a : reduce Ea E1a)\n        : reduce (app Ea Eb) (app E1a E1b))\n     (reduce/app (D2b : reduce Eb E2b) (D2a : reduce Ea E2a) \n        : reduce (app Ea Eb) (app E2a E2b)) \n     (reduce/app D1b' D1a') (reduce/app D2b' D2a')\n     <- diamond D1a D2a \n          (D1a' : reduce E1a Ea')\n          (D2a' : reduce E2a Ea')\n     <- diamond D1b D2b \n          (D1b' : reduce E1b Eb') \n          (D2b' : reduce E2b Eb').\n\n%{ === Beta-Beta === }%\n%{\n\nIf both cases are beta reductions, we get the result from performing two \nsubstitutions. \n\n               (λx.ea) eb            by induction\n reduce/beta      / \\   reduce/beta    D1a, D2a ---> D1a': e1a=>ea'\n (D1b: eb=>e1b)  /   \\  (D2b: eb=>e2b)               D2a': e2a=>ea'\n (D1a: ea=>e1a) /     \\ (D2a: ea=>e1a) D1b, D2b ---> D1b': e1b=>eb'\n         [e1b/x]e1a  [e2b/x]e2a                      D2b': e2b=>eb'\n                \\     /\n substitute      \\   /  substitute\n D1b' into D1a'   \\ /   D2b' into D2a'\n              [eb'/x]ea\n}% \n\n- : diamond \n     (reduce/beta \n          (D1b : reduce Eb E1b)\n          (D1a : {x} reduce x x -> reduce (Ea x) (E1a x))\n        : reduce (app (lam Ea) Eb) (E1a E1b))\n     (reduce/beta\n          (D2b : reduce Eb E2b)\n          (D2a : {x} reduce x x -> reduce (Ea x) (E2a x))\n        : reduce (app (lam Ea) Eb) (E2a E2b))\n     D1 D2\n     <- ({x}{redx : reduce x x}\n           identity x redx -> diamond (D1a x redx) (D2a x redx)\n          (D1a' x redx : reduce (E1a x) (Ea' x))\n          (D2a' x redx : reduce (E2a x) (Ea' x)))\n     <- diamond D1b D2b\n          (D1b' : reduce E1b Eb')\n          (D2b' : reduce E2b Eb')\n     <- substitute D1a' D1b' \n          (D1   : reduce (E1a E1b) (Ea' Eb'))\n     <- substitute D2a' D2b'\n          (D2   : reduce (E2a E2b) (Ea' Eb')).\n\n%{ === Beta-Application === }%\n%{\n\nIf the left-hand side is a β-reduction \n<tt>(λx.ea) eb => [e1b/x] e1a</tt> but the right-hand side is not, then we \nknow that the right-hand side reduction must be \n<tt>(λx.ea) eb => (λx.e2a) e2b</tt>, which means it is a \n<tt>reduce/lam</tt> hiding inside a <tt>reduce/app</tt>.\n\nThe first subcase:\n\n              (λx.ea) eb              by induction  \n reduce/beta      / \\   reduce/app      D1a, D2a ---> D1a': e1a=>ea'\n (D1b: eb=>e1b)  /   \\  (D2b: eb=>e2b)                D2a': e2a=>ea'\n (D1a: ea=>e1a) /     \\ (reduce/lam     D1b, D2b ---> D1b': e1b=>eb'\n               /       \\  (D2a: ea=>e2a))             D2b': e1b=>eb'\n        [e1b/x]e1a  (λx.e2a) e2b\n               \\       /\n substitute     \\     / reduce/beta     \n D1b' into D2a'  \\   /  D2b' D2a'      \n                  \\ /   \n               [eb'/x]ea'              \n}%\n\n- : diamond\n     (reduce/beta \n          (D1b : reduce Eb E1b) \n          (D1a : {x: exp} reduce x x -> reduce (Ea x) (E1a x))\n        : reduce (app (lam Ea) Eb) (E1a E1b))\n     (reduce/app \n          (D2b : reduce Eb E2b) \n          (reduce/lam (D2a : {x: exp} reduce x x -> reduce (Ea x) (E2a x)))\n        : reduce (app (lam Ea) Eb) (app (lam E2a) E2b))\n     D1 (reduce/beta D2b' D2a')\n     <- ({x: exp}{redx: reduce x x} \n           identity x redx -> diamond (D1a x redx) (D2a x redx)\n          (D1a' x redx : reduce (E1a x) (Ea' x))\n          (D2a' x redx : reduce (E2a x) (Ea' x)))\n     <- diamond D1b D2b\n          (D1b' : reduce E1b Eb')\n          (D2b' : reduce E2b Eb')\n     <- substitute D1a' D1b' \n          (D1   : reduce (E1a E1b) (Ea' Eb')).\n\n%{ === Application-Beta === }%\n%{ \n\nIf the right-hand hand side is a β-reduction but the left-hand side is not, we \nhave to do the same case in reverse; we omit the graphic.\n\n}% \n\n- : diamond\n     (reduce/app\n          (D1b : reduce Eb E1b)\n          (reduce/lam (D1a : {x} reduce x x -> reduce (Ea x) (E1a x)))\n        : reduce (app (lam Ea) Eb) (app (lam E1a) E1b))\n     (reduce/beta \n          (D2b : reduce Eb E2b)\n          (D2a : {x} reduce x x -> reduce (Ea x) (E2a x))\n        : reduce (app (lam Ea) Eb) (E2a E2b))\n     (reduce/beta D1b' D1a') D2\n     <- ({x}{redx: reduce x x}\n           identity x redx -> diamond (D1a x redx) (D2a x redx)\n          (D1a' x redx : reduce (E1a x) (Ea' x))\n          (D2a' x redx : reduce (E2a x) (Ea' x)))\n     <- diamond D1b D2b\n          (D1b' : reduce E1b Eb')\n          (D2b' : reduce E2b Eb')\n     <- substitute D2a' D2b' \n          (D2   : reduce (E2a E2b) (Ea' Eb')).\n\n%{ Now we are done! We check in the <tt>exps</tt> world with free variables.}%\n\n%worlds (exps_id) (diamond _ _ _ _).\n%total D1 (diamond D1 D2 _ _)."
          },
          "sha1": "49m9cfchqdfhk1d8nu3vkajhd51jaxg"
        }
      },
      {
        "title": "Church-Rosser (w/ identity reduction)",
        "ns": 0,
        "id": 2102,
        "revision": {
          "id": 5683,
          "parentid": 5597,
          "timestamp": "2008-11-22T23:06:19Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "minor": null,
          "comment": "[[POPL Tutorial/Church Rosser]] moved to [[Church-Rosser (w/ identity reduction)]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 12141,
            "#text": "%{ == Syntax == }%\n\nexp : type.  %name exp E.\nlam : (exp -> exp) -> exp.\napp : exp -> exp -> exp.\n\n%{ \n\nWhen we use this <tt>%block</tt>, it expresses that we can be working in a \ncontext with arbitrary expression variables. This will be the only world we \nwill need for this exercise. \n\n}%\n\n%block exps : block {x: exp}.\n\n\n%{ == Reduction == }%\n%{ \n\nWe can always reduce an expression to itself (which means that we don't \nexplicitly need a case to handle variables). We can reduce under binders and \nreduce both sides of an application \"in parallel.\" If we have a β-redex \n<tt>(λx.ea) eb</tt>, then after reducing <tt>ea</tt> (with <tt>x</tt> free) to \n<tt>ea'</tt> (with <tt>x</tt> free) and reducing <tt>eb</tt> to <tt>eb'</tt>,\nwe can return <tt>[eb'/x]ea'</tt>, the substitution of <tt>eb'</tt> into\n<tt>ea'</tt>.\n\nThe <tt>%worlds</tt> explicitly states that we will be reducing in a setting \nwith free variables. \n\n}%\n\nreduce : exp -> exp -> type.\n\nreduce/id : reduce E E.\n\nreduce/lam : reduce (lam E) (lam E')\n              <- ({x:exp} reduce (E x) (E' x)).\n\nreduce/app : reduce (app E1 E2) (app E1' E2')\n              <- reduce E1 E1'\n              <- reduce E2 E2'.\n\nreduce/beta : reduce (app (lam E1) E2) (E1' E2')\n              <- ({x:exp} reduce (E1 x) (E1' x))\n              <- reduce E2 E2'.\n\n%worlds (exps) (reduce _ _).\n\n%{ == Substitution == }%\n%{ \n\nThe first substitution theorem says that if we have a term <tt>e1</tt> with \n<tt>x</tt> free and a term <tt>e2</tt> that reduces to term <tt>e2'</tt>, \nthen <tt>[e2/x]e1</tt> reduces to <tt>[e2'/x]e1</tt>. \n\nThe interesting cases are really the first two - if the term is just the free \nvariable being substituted for, the result follows from the hypothesis. In the \ncase that the free variable is ''not'' free (i.e. the term has no hole), then \nthe result follows from the reflexivity of reduction. This is more than \nsufficient to handle the case of a variable that is not the distinguished free \nvariable, and all other cases are covered.\n\nThe proof is by induction on the structure of the term with the free variable.\n\n}%\n\nsubstitute1 : {E1:exp -> exp} reduce E2 E2' -> reduce (E1 E2) (E1 E2') -> type.\n%mode substitute1 +X1 +X2 -X3.\n\n- : substitute1 ([x] x) D D.\n\n- : substitute1 ([x] E) _ reduce/id.\n\n- : substitute1 ([x] lam ([y] E x y)) D (reduce/lam D')\n     <- ({y} substitute1 ([x] E x y) D (D' y)).\n\n- : substitute1 ([x] app (E1 x) (E2 x)) D (reduce/app D2 D1)\n     <- substitute1 E1 D D1\n     <- substitute1 E2 D D2.\n\n%worlds (exps) (substitute1 _ _ _).\n%total E (substitute1 E _ _).\n\n%{ \n\nThe second substitution theorem is similar, except that we are reducing \n<tt>e1</tt> with <tt>x</tt> free to <tt>e1'</tt> as well as by reducing\n<tt>e2</tt> to <tt>e2'</tt>, showing that <tt>[e2/x]e1</tt> reduces to\n<tt>[e2'/x]e1'</tt>.\n\nProof is by induction on the structure of the reduction of <tt>e1</tt> to \n<tt>e1'</tt>. We call to the <tt>substitute1</tt> lemma \nwhen we \"bottom out\" at the reflexive case <tt>reduce/id</tt>.\n\n}%\n\nsubstitute2 \n   : ({x:exp} reduce (E1 x) (E1' x)) \n      -> reduce E2 E2' \n      -> reduce (E1 E2) (E1' E2') \n      -> type.\n%mode substitute2 +X1 +X2 -X3.\n\n- : substitute2 ([x] reduce/id : reduce (E x) (E x)) D D'\n     <- substitute1 E D D'.\n\n- : substitute2 ([x] reduce/lam ([y] D1 x y)) D2 (reduce/lam D)\n     <- ({y} substitute2 ([x] D1 x y) D2 (D y)).\n\n- : substitute2 ([x] reduce/app (D2 x) (D1 x)) D (reduce/app D2' D1')\n     <- substitute2 D1 D D1'\n     <- substitute2 D2 D D2'.\n\n- : substitute2 ([x] reduce/beta (D2 x) ([y] D1 x y)) D (reduce/beta D2' D1')\n     <- ({y} substitute2 ([x] D1 x y) D (D1' y))\n     <- substitute2 D2 D D2'.\n\n%worlds (exps) (substitute2 _ _ _).\n%total D (substitute2 D _ _).\n\n%{ == The Diamond Property == }%\n%{\n\nNow we come to the interesting part: the diamond property.\n\n    E\n   / \\\n  /   \\\n E1   E2\n  \\   /\n   \\ /\n    E'\n\nIf <tt>E</tt> reduces to both <tt>E1</tt>, and <tt>E2</tt>, then there is a \ncommon E' such that <tt>E1</tt> and <tt>E2</tt> both reduce to it.\n\n}%\n\ndiamond : reduce E E1 -> reduce E E2 -> reduce E1 E' -> reduce E2 E' -> type.\n%mode diamond +X1 +X2 -X3 -X4.\n\n%{ === Identity === }%\n%{ \n\nIf either case is the identity, then we are done. \n\n id:    E  D:       D:     E  id:\n e=>e  / \\ e=>e2    e=>e1 / \\ e=>e\n      /   \\              /   \\\n     E    E2            E1    E\n D:   \\   /id:      id:  \\   /D:\n e=>e2 \\ / e2=>e2   e1=>e1\\ / e=>e1\n        e2                 E1\n\n}%\n\n- : diamond reduce/id D D reduce/id.\n- : diamond D reduce/id reduce/id D.\n\n%{ === Lambda-Lambda === }%\n%{ \n\nIf both cases are reductions under a binder, we pull the result straight \nfrom the induction hypothesis. \n\n             λx.e              by induction:\n reduce/lam   / \\  reduce/lam    D1, D2 ---> D1': e1'=>e'\n (D1: e=>e1) /   \\ (D2: e=>e2)               D2': e2'=>e'\n            /     \\\n         λx.e1   λx.e2\n            \\     /\n reduce/lam  \\   / reduce/lam\n D1'          \\ /  D2'\n             λx.e' \n\nNote the oversimplification being made in the graphical presentation, in that\nthe subterms and sub-derivations are not clearly shown to have a free variable.\nTwelf will, of course, not allow this sloppiness.\n\n}%\n\n- : diamond \n     (reduce/lam (D1 : {x: exp} reduce (E x) (E1 x))\n        : reduce (lam E) (lam E1))\n     (reduce/lam (D2 : {x: exp} reduce (E x) (E2 x))\n        : reduce (lam E) (lam E2))\n     (reduce/lam D1') (reduce/lam D2')\n     <- ({x: exp} diamond (D1 x) (D2 x) \n          (D1' x : reduce (E1 x) (E' x))\n          (D2' x : reduce (E2 x) (E' x))).\n\n%{ === Application-Application === }%\n%{\n\nIf both cases are applications, we pull the result straight from the \ninduction hypothesis. \n\n                  ea eb                by induction\n reduce/app       /   \\   reduce/app     D1a, D2a ---> D1a': e1a=>ea'\n (D1b: eb=>e1b)  /     \\  (D2b: eb=>e2b)               D2a': e2a=>ea'\n (D1a: ea=>e1a) /       \\ (D2a: ea=>e2a) D1b, D2b ---> D1b': e1b=>eb' \n            e1a e1b   e2a e2b                          D2b': e2b=>eb'\n                \\       /\n reduce/app      \\     /  reduce/app\n D1b' D1a'        \\   /   D2b' D2a'\n                 ea' eb'\n}%\n\n- : diamond \n     (reduce/app (D1b : reduce Eb E1b) (D1a : reduce Ea E1a)\n        : reduce (app Ea Eb) (app E1a E1b))\n     (reduce/app (D2b : reduce Eb E2b) (D2a : reduce Ea E2a) \n        : reduce (app Ea Eb) (app E2a E2b)) \n     (reduce/app D1b' D1a') (reduce/app D2b' D2a')\n     <- diamond D1a D2a \n          (D1a' : reduce E1a Ea')\n          (D2a' : reduce E2a Ea')\n     <- diamond D1b D2b \n          (D1b' : reduce E1b Eb') \n          (D2b' : reduce E2b Eb').\n\n%{ === Beta-Beta === }%\n%{\n\nIf both cases are beta reductions, we get the result from performing two \nsubstitutions. \n\n               (λx.ea) eb            by induction\n reduce/beta      / \\   reduce/beta    D1a, D2a ---> D1a': e1a=>ea'\n (D1b: eb=>e1b)  /   \\  (D2b: eb=>e2b)               D2a': e2a=>ea'\n (D1a: ea=>e1a) /     \\ (D2a: ea=>e1a) D1b, D2b ---> D1b': e1b=>eb'\n         [e1b/x]e1a  [e2b/x]e2a                      D2b': e2b=>eb'\n                \\     /\n substitute      \\   /  substitute\n D1b' into D1a'   \\ /   D2b' into D2a'\n              [eb'/x]ea\n}% \n\n- : diamond \n     (reduce/beta \n          (D1b : reduce Eb E1b)\n          (D1a : {x} reduce (Ea x) (E1a x))\n        : reduce (app (lam Ea) Eb) (E1a E1b))\n     (reduce/beta\n          (D2b : reduce Eb E2b)\n          (D2a : {x} reduce (Ea x) (E2a x))\n        : reduce (app (lam Ea) Eb) (E2a E2b))\n     D1 D2\n     <- ({x} diamond (D1a x) (D2a x)\n          (D1a' x : reduce (E1a x) (Ea' x))\n          (D2a' x : reduce (E2a x) (Ea' x)))\n     <- diamond D1b D2b\n          (D1b'   : reduce E1b Eb')\n          (D2b'   : reduce E2b Eb')\n     <- substitute2 D1a' D1b' \n          (D1     : reduce (E1a E1b) (Ea' Eb'))\n     <- substitute2 D2a' D2b'\n          (D2     : reduce (E2a E2b) (Ea' Eb')).\n\n%{ === Beta-Application === }%\n%{\n\nIf the left-hand side is a β-reduction \n<tt>(λx.ea) eb => [e1b/x] e1a</tt> but the right-hand side is not, then we \nknow that the right-hand side reduction must be \n<tt>(λx.ea) eb => (λx.e2a) e2b</tt>.\n\nUnfortunately, then we have two options - either <tt>λx.ea => λx.e2a</tt> by\n<tt>reduce/refl</tt> and <tt>reduce/lam</tt>. The <tt>reduce/refl</tt> case\nis essentially just an inconvenience caused by allowing identity reductions\nanywhere (not just at variables).\n\nThe first subcase:\n\n              (λx.ea) eb              by induction  \n reduce/beta      / \\   reduce/app      D1a, D2a ---> D1a': e1a=>ea'\n (D1b: eb=>e1b)  /   \\  (D2b: eb=>e2b)                D2a': e2a=>ea'\n (D1a: ea=>e1a) /     \\ (reduce/lam     D1b, D2b ---> D1b': e1b=>eb'\n               /       \\  (D2a: ea=>e2a))             D2b': e1b=>eb'\n        [e1b/x]e1a  (λx.e2a) e2b\n               \\       /\n substitute     \\     / reduce/beta     \n D1b' into D2a'  \\   /  D2b' D2a'      \n                  \\ /   \n               [eb'/x]ea'              \n}%\n\n- : diamond\n     (reduce/beta \n          (D1b : reduce Eb E1b) \n          (D1a : {x: exp} reduce (Ea x) (E1a x))\n        : reduce (app (lam Ea) Eb) (E1a E1b))\n     (reduce/app \n          (D2b : reduce Eb E2b) \n          (reduce/lam (D2a : {x: exp} reduce (Ea x) (E2a x)))\n        : reduce (app (lam Ea) Eb) (app (lam E2a) E2b))\n     D1 (reduce/beta D2b' D2a')\n     <- ({x: exp} diamond (D1a x) (D2a x)\n          (D1a' x : reduce (E1a x) (Ea' x))\n          (D2a' x : reduce (E2a x) (Ea' x)))\n     <- diamond D1b D2b\n          (D1b'   : reduce E1b Eb')\n          (D2b'   : reduce E2b Eb')\n     <- substitute2 D1a' D1b' \n          (D1     : reduce (E1a E1b) (Ea' Eb')).\n\n%{\n\nThe second subcase:\n\n              (λx.ea) eb              by induction  \n reduce/beta      / \\   reduce/app      D1b, D2b ---> D1b': e1b=>eb'\n (D1b: eb=>e1b)  /   \\  (D2b: eb=>e2b)                D2b': e1b=>eb'\n (D1a: ea=>e1a) /     \\ (reduce/id      \n               /       \\   ea=>ea))     \n        [e1b/x]e1a   (λx.ea) e2b\n               \\       /\n substitute     \\     / reduce/beta     \n D1b' into e1a   \\   /  D2b' D1a   \n                  \\ /   \n               [eb'/x]e1a        \n}%\n\n- : diamond\n     (reduce/beta \n          (D1b : reduce Eb E1b) \n          (D1a : {x} reduce (Ea x) (E1a x))\n        : reduce (app (lam Ea) Eb) (E1a E1b))\n     (reduce/app \n          (D2b : reduce Eb E2b) \n          (reduce/id : reduce (lam Ea) (lam Ea))\n        : reduce (app (lam Ea) Eb) (app (lam Ea) E2b))\n     D1 (reduce/beta D2b' D1a) \n     <- diamond D1b D2b\n          (D1b'   : reduce E1b Eb')\n          (D2b'   : reduce E2b Eb')\n     <- substitute1 E1a D1b' \n          (D1     : reduce (E1a E1b) (E1a Eb')).\n\n\n%{ === Application-Beta === }%\n%{ \n\nIf the right-hand hand side is a β-reduction but the left-hand side is not, we \nhave to do the same two cases in reverse; we omit the graphics for those \ntwo cases as they are symmetric.\n\n}% \n\n- : diamond\n     (reduce/app \n          (D1b : reduce Eb E1b) \n          (reduce/id : reduce (lam Ea) (lam Ea))\n        : reduce (app (lam Ea) Eb) (app (lam Ea) E1b))\n     (reduce/beta \n          (D2b : reduce Eb E2b) \n          (D2a : {x} reduce (Ea x) (E2a x))\n        : reduce (app (lam Ea) Eb) (E2a E2b))\n     (reduce/beta D1b' D2a) D2\n     <- diamond D1b D2b\n          (D1b'   : reduce E1b Eb')\n          (D2b'   : reduce E2b Eb')\n     <- substitute1 E2a D2b' \n          (D2     : reduce (E2a E2b) (E2a Eb')).\n\n- : diamond\n     (reduce/app\n          (D1b : reduce Eb E1b)\n          (reduce/lam (D1a : {x} reduce (Ea x) (E1a x)))\n        : reduce (app (lam Ea) Eb) (app (lam E1a) E1b))\n     (reduce/beta \n          (D2b : reduce Eb E2b)\n          (D2a : {x} reduce (Ea x) (E2a x))\n        : reduce (app (lam Ea) Eb) (E2a E2b))\n     (reduce/beta D1b' D1a') D2\n     <- ({x} diamond (D1a x) (D2a x)\n          (D1a' x : reduce (E1a x) (Ea' x))\n          (D2a' x : reduce (E2a x) (Ea' x)))\n     <- diamond D1b D2b\n          (D1b'   : reduce E1b Eb')\n          (D2b'   : reduce E2b Eb')\n     <- substitute2 D2a' D2b' \n          (D2     : reduce (E2a E2b) (Ea' Eb')).\n\n%{ Now we are done! We check in the <tt>exps</tt> world with free variables.}%\n\n%worlds (exps) (diamond _ _ _ _).\n%total D1 (diamond D1 D2 _ _)."
          },
          "sha1": "ntglnxbaki8x8sw64o57d5nh3405eul"
        }
      },
      {
        "title": "Church-Rosser via Complete Development",
        "ns": 0,
        "id": 2040,
        "redirect": {
          "@title": "Church-Rosser via complete development",
          "#text": null
        },
        "revision": {
          "id": 5111,
          "timestamp": "2008-03-05T17:42:03Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "comment": "[[Church-Rosser via Complete Development]] moved to [[Church-Rosser via complete development]]: case",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 52,
            "#text": "#REDIRECT [[Church-Rosser via complete development]]"
          },
          "sha1": "qjxigl5xs1uaog23e759sxj7825ehu7"
        }
      },
      {
        "title": "Church-Rosser via complete development",
        "ns": 0,
        "id": 2039,
        "revision": {
          "id": 5115,
          "parentid": 5110,
          "timestamp": "2008-03-05T17:50:53Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 14503,
            "#text": "%{ \nIn this case study, we give a simple proof of the diamond property of\nuntyped parallel reduction.  The proof, due to \nMasako Takahashi (Parallel Reductions in <math>\\lambda</math>-Calculus, \nInformation and Computation 118(1), 1995) makes use of a auxilary relation called complete\ndevelopement.  This case study is a good example of proving\nmetatheorems in [[regular worlds]]: we use several different worlds, and\ntransport theorems between them.\n}%\n\n%{ == Syntax and judgements == \n\nFirst, we define the syntax of the language, along with parallel reduction and complete development.  \nSee [[Reformulating languages to use hypothetical judgements]] for a discussion of these judgements and their encodings.\nThe only difference between the two relations is the side condition on the complete development application rule, which forces the \nbeta-reduction rule to take precedence over it.  \nThus, a single step of complete development contracts all beta-redices in the left-hand term one step.\nConsequently, all beta-redices must be reduced away before a term can take a reflexivity step.\n\n}%\n\ntrm : type.\nlam : (trm -> trm) -> trm.\napp : trm -> trm -> trm.\n\n%block trmb : block {x : trm}.\n%worlds (trmb) (trm).\n\n%{ === Parallel reduction === }%\n\n=> : trm -> trm -> type.  %infix none 10 =>.\n%mode => +M -N.\n\n=>/beta : (app (lam M) N) => M' N'\n          <- ({x:trm} x => x -> M x => M' x)\n          <- N => N'.\n=>/app  : (app M N) => (app M' N')\n          <- M => M'\n          <- N => N'.\n=>/lam  : lam M => lam M'\n          <- ({x:trm} x => x -> M x => M' x).\n\n%block =>b : block {x : trm} {prx : x => x}.\n%worlds (=>b) (=> _ _).\n%total E (=> E _).\n\n%{ Note that Twelf can prove that parallel reduction is total automatically! }%\n\n%{ === Complete development === }%\n\nnotlam : trm -> type.\n%mode notlam +M.\n\nnotlam/app : notlam (app _ _).\n\n%block nlb : block {x : trm} {nlx : notlam x}.\n%worlds (nlb) (notlam _).\n\n==> : trm -> trm -> type.  %infix none 10 ==>.\n%mode ==> +M -N.\n\n==>/beta : (app (lam M) N) ==> M' N'\n          <- ({x:trm} notlam x -> x ==> x -> M x ==> M' x)\n          <- N ==> N'.\n==>/app  : (app M N) ==> (app M' N')\n          <- M ==> M'\n          <- N ==> N'\n\t  <- notlam M.\n==>/lam  : lam M ==> lam M'\n          <- ({x:trm} notlam x -> x ==> x -> M x ==> M' x).\n\n%block ==>b : block {x : trm} {nlx : notlam x} {cdx : x ==> x}.\n%worlds (==>b) (==> _ _).\n\n%{ Twelf cannot prove that complete development is total automatically,\nbut we will prove this fact ourselves below. }%\n\n%{ \nBelow, we will want to work in a world where both parallel reduction and complete development exist.  \nThus, we define a block that includes all the assumptions in both <tt>=>b</tt> and <tt>==>b</tt>:\n}%\n%block =>&==>b : block \n\t\t  {x : trm} \n\t\t  {prx : x => x}\n\t\t  {nlx : notlam x} \n\t\t  {cdx : x ==> x} .\n\n%{ == Diamond property of parallel reduction == }%\n\n%{ === Every term either is or isn't a lambda === \n\nAs a lemma, we need to prove that every term either is or is not a lambda.\n\n}%\n\nlam-or-not : trm -> type.\nlam-or-not/lam : lam-or-not (lam _).\nlam-or-not/not : lam-or-not E\n\t\t  <- notlam E.\n\ndecide : {E} lam-or-not E -> type.\n%mode decide +E -D.\n\n- : decide (lam _) lam-or-not/lam.\n- : decide (app _ _) (lam-or-not/not notlam/app).\n\n%{\nWhat world should this lemma be stated in?  \nIt talks about <tt>trm</tt>s, so we definitely need term assumptions, and <tt>notlam</tt> only makes sense with its assumptions.\nBut neither of the reduction relations are relevant, so we should leave off their hypotheses.\nHowever, to prove the theorem, we need to cover the case of <tt>decide</tt> for variables <tt>x</tt>, which we\ndo by putting a case in the LF context.  \n(See [[Proving metatheorems: Proving metatheorems in non-empty contexts]] for a discussion of this technique.)\nThus, we arrive at:\n}%\n\n%block decideb : block \n\t\t{x : trm} \n\t\t{nlx : notlam x} \n\t\t{decx : decide x (lam-or-not/not nlx)}.\n%worlds (decideb) (decide _ _).\n%total E (decide E _).\n\n%{ === Complete development is total === \n\nTo prove the diamond property, we need to know that every term is reducible under complete-development.  \nFirst, we prove a lemma showing that an application reduces if its components do:\n\n}%\n\n==>-tot/app : lam-or-not E1 -> E1 ==> E1' -> E2 ==> E2' -> (app E1 E2) ==> E'' -> type.\n%mode ==>-tot/app +D0 +D1 +D2 -D3.\n\n- : ==>-tot/app \n     lam-or-not/lam \n     (==>/lam D1)\n     D2 \n     (==>/beta D2 D1).\n\n- : ==>-tot/app \n     (lam-or-not/not Nl)\n     D1\n     D2 \n     (==>/app Nl D2 D1).\n\n%worlds (==>b) (==>-tot/app _ _ _ _).\n%total {} (==>-tot/app _ _ _ _).\n\n%{\nNote that the world <tt>==>b</tt> is the minimal one in which both <tt>==></tt> and <tt>lam-or-not</tt> make sense,\nso it is the most appropriate world to use here.\n}%\n\n==>-tot : {E : trm} E ==> E' -> type.\n%mode ==>-tot +E -D.\n\n- : ==>-tot (lam E) (==>/lam D)\n     <- {x : trm} {nlx : notlam x} \n\t{cdx : x ==> x}  \n\t{_ : decide x (lam-or-not/not nlx)}\n\t{_ : ==>-tot x cdx}\n\t==>-tot (E x) (D x nlx cdx).\n\n- : ==>-tot (app E E') D\n     <- ==>-tot E  De\n     <- ==>-tot E' De'\n     <- decide E Dlon\n     <- ==>-tot/app Dlon De De' D.\n\n%{ \nThis lemma at least needs the assumptions in <tt>==>b</tt> for complete development to be adequately represented.\nAdditionally, because the above case uses <tt>decide</tt> as a lemma, we need to ensure that its assumptions are in \nthe world we choose here.  Additionally, to show that variables reduce, we need a theorem case in the context.\nThus, we arrive at the following block:\n}%\n\n%block ==>totb : block \n\t\t  {x : trm} \n\t\t  {nlx : notlam x} \n\t\t  {cdx : x ==> x}\n\t\t  {_ : decide x (lam-or-not/not nlx)}\n\t\t  {_ : ==>-tot x cdx}.\n\n%worlds (==>totb) (==>-tot _ _).\n%total D (==>-tot D _).\n\n%{\nWhy may we call <tt>decide</tt> from contexts made up of <tt>==>totb</tt> blocks when decide was only stated for\ncontexts made up of <tt>decideb</tt> blocks?  In general, extending the context could create new cases that\n<tt>decide</tt> would be unable to handle.  However, in this instance, both of the new assumptions, which have types\n<tt>==></tt> and <tt>==>-tot</tt>, are irrelevant (in[[subordinate]]) to <tt>decide</tt>, \nso Twelf permits this world subsumption.  That is, <tt>decide</tt> is only concerned with <tt>trm</tt>s and derivations of\n<tt>notlam</tt> and derivations of <tt>decide</tt> itself, and neither <tt>==></tt> nor <tt>==>-tot</tt> assumptions \ninfluence those types.\n}%\n\n%{ === Substituting reductions into parallel reduction === \n\nWe also need to show that the substitution of a reduction is the reduction of the substitution.\nTo prove this lemma, we distinguish cases on an LF function representing the \nhypothetical derivation:\n\n}%\n\nsubst : ({x : trm} x => x -> (M x => M' x))\n\t -> (N => N')\n\t -> (M N) => M' N'\n\t -> type.\n%mode subst +D1 +D2 -D3.\n\n%{ (M x) is x: }%\n- : subst ([x] [prx] prx) Dn Dn.\n\n%{ (M x) doesn't mention x at all (this covers all other variables in the context, as well any other x-closed term): }%\n- : subst ([x] [prx] D) _ D.\n\n%{ The remaining cases proceed compositionally: }%\n- : subst ([x] [prx] (=>/app (Dm2 x prx) (Dm1 x prx))) Dn (=>/app Dm2' Dm1')\n     <- subst Dm2 Dn Dm2'\n     <- subst Dm1 Dn Dm1'.\n\n- : subst ([x] [prx] (=>/beta (Dm2 x prx) ([y] [pry] Dm1 y pry x prx))) \n     Dn \n     (=>/beta Dm2' Dm1')\n     <- subst Dm2 Dn Dm2'\n     <- {y : trm} {pry : y => y}\n\tsubst ([x] [prx] Dm1 y pry x prx) Dn (Dm1' y pry).\n\n- : subst ([x] [prx] (=>/lam ([y] [pry] Dm y pry x prx))) \n     Dn \n     (=>/lam Dm')\n     <- {y : trm} {pry : y => y}\n\tsubst ([x] [prx] Dm y pry x prx) Dn (Dm' y pry).\n\n%{ \nBecause this theorem is property only of parallel reduction, \nwe use the block containing only parallel reduction assumptions:\n}%\n%worlds (=>b) (subst _ _ _).\n%total D (subst D _ _).\n\n%{ === The triangle property === \n\nThe key lemma in this proof is that given a split of parallel reduction on one side and\ncomplete development on the other, there is a parallel reduction on the other side\nof the triangle:\n\n}%\n\ntri : (M ==> M') -> (M => M'') -> (M'' => M') -> type.\n%mode tri +X1 +X2 -X3.\n\n- : tri D1 D2 D2.\n\n- : tri \n     (==>/app Dnl \n\t(Dn' : N ==> N')\n\t(Dm' : M ==> M'))\n     (=>/app \n\t(Dn'' : N => N'')\n\t(Dm''  : M => M'')\n\t) \n     (=>/app Dn Dm)\n     <- tri Dn' Dn'' Dn\n     <- tri Dm' Dm'' Dm.\n\n- : tri\n     (==>/lam Dn')\n     (=>/lam Dn'')\n     (=>/lam Dn)\n     <- {x : trm} \n\t{prx : x => x}\n\t{nlx : notlam x} \n\t{cdx : x ==> x}\n\ttri (Dn' x nlx cdx) (Dn'' x prx) (Dn x prx).\n\n- : tri \n     (==>/beta \n\t(Dn' : N ==> N')\n\t(Dm' : {x} {nlx} {cdx} (M x) ==> (M' x)))   \n     (=>/app \n \t(Dn'' : N => N'')\n \t(=>/lam (Dm'' : {x} {prx} (M x) => (M'' x))))\n     (=>/beta Dn Dm)\n     <- tri Dn' Dn'' Dn\n     <- {x : trm} \n\t{prx : x => x}\n\t{nlx : notlam x} \n\t{cdx : x ==> x}\n\ttri (Dm' x nlx cdx) (Dm'' x prx) (Dm x prx).\n\n- : tri \n     (==>/beta \n\t(Dn' : N ==> N')\n\t(Dm' : {x} {nlx} {cdx} (M x) ==> (M' x)))   \n     (=>/beta\n \t(Dn'' : N => N'')\n \t(Dm'' : {x} {prx} (M x) => (M'' x)))\n     D\n     <- tri Dn' Dn'' Dn\n     <- ({x : trm} \n\t   {prx : x => x}\n\t   {nlx : notlam x} \n\t   {cdx : x ==> x}\n\t   tri (Dm' x nlx cdx) (Dm'' x prx) (Dm x prx))\n     <- subst Dm Dn D.\n\n%{ The best world for this proof is the one where both parallel reduction\nand complete development exist, and we don't need any additional assumptions\nfor the proof, so this is the world we use:\n}%\n\n%worlds (=>&==>b) (tri _ _ _).\n%total D (tri D _ _).\n\n%{ Let's investigate why complete development is necessary for this proof to go through.  \nWithout the side condition on application, we'd have an additional case to consider, \nwhere the complete development was by the application rule, and the parallel reduction was by the beta rule.  We'd set up this case as follows:\n\n<twelf ignore=\"true\">\n- : tri \n     (==>/app \n\tIMPOSSIBLE\n \t(Dn' : N ==> N')\n \t(==>/lam (Dm' : {x} {nlx} {cdx} (M x) ==> (M' x))))\n     (=>/beta \n\t(Dn'' : N => N'')\n\t(Dm'' : {x} {prx} (M x) => (M'' x)))  \n     (XXX : M'' N'' => app (lam M') N')\n     <- tri Dn' Dn'' \n\t(Dn : N'' => N')\n     <- {x : trm} \n\t{prx : x => x}\n\t{nlx : notlam x} \n\t{cdx : x ==> x}\n\ttri (Dm' x nlx cdx) \n\t(Dm'' x prx)\n\t((Dm : {x} x => x -> (M'' x) => (M' x)) x prx).\n</twelf>\n\nFrom the inductive hypotheses, we know that <tt>M'' x => M' x</tt> for all <tt>x</tt> and that <tt>N'' => N'</tt>.\nHowever, we need to prove that <tt>M'' N'' => app (lam M') N'</tt>.  By <tt>subst</tt>, we can get that the left-hand side reduces\nto the '''beta-reduction''' of the right-hand side, but there the proof breaks down.\n\n}%  \n\n\n%{ === The diamond property === \n\nWe prove the diamond property by first generating a parallel reduction for <tt>M</tt> and \nthen making two triangles, which complete the square.\n\n}%\n\ndia : (M => M') -> (M => M'') -> (M' => N) -> (M'' => N) -> type.\n%mode dia +X1 +X2 -X3 -X4.\n\n- : dia \n     (Dleft  : M => Mleft)\n     (Dright : M => Mright)\n     Dleftmiddle\n     Drightmiddle\n     <- ==>-tot M D==>middle\n     <- tri D==>middle Dleft  Dleftmiddle\n     <- tri D==>middle Dright Drightmiddle.\n\n%{ \nBecause we call both <tt>==>-tot</tt> and <tt>tri</tt>, \nwe need to maintain all the assumptions of both of them.  \nThis is the block <tt>=>&==>b</tt> extended with the theorem cases for\n<tt>decide</tt> and <tt>==>-tot</tt> (a.k.a.\n<tt>==>-totb</tt> extended with a parallel reduction assumption).\nTwelf verifies the world subsumption showing that \n<tt>==>-tot</tt> and <tt>tri</tt> remain true under such extensions of \nthe context.\n}%\n\n%block diab : block \n\t       {x : trm} \n\t       {prx : x => x}\n\t       {nlx : notlam x} \n\t       {cdx : x ==> x}\n\t       {_ : decide x (lam-or-not/not nlx)}\n\t       {_ : ==>-tot x cdx}.\n\n%worlds (diab) (dia _ _ _ _).\n%total {} (dia _ _ _ _).\n\n%{ == Other properties of complete development == \n\nTo complete the development of complete development, we can prove two other simple lemmas.\n\n=== Soundness of complete development wrt parallel reduction === \n\nFirst, every complete development reduction is a parallel reduction: \nwe simply forget the proof of the side condition on the application rule.\n\n}%\n\nsound : E ==> E' -> E => E' -> type.\n%mode sound +X1 -X2.\n\n- : sound (==>/beta Dn Dm) (=>/beta Dn' Dm')\n     <- sound Dn Dn'\n     <- ({x} {nlx : notlam x} \n\t   { cdx : x ==> x} { prx : x => x} \n\t   {_ : sound cdx prx}\n\t   sound (Dm  x nlx cdx) (Dm' x prx)).\n\n- : sound (==>/app _ Dn Dm) (=>/app Dn' Dm')\n     <- sound Dm Dm'\n     <- sound Dn Dn'.\n\n- : sound (==>/lam Dm) (=>/lam Dm')\n     <- ({x} {nlx : notlam x} \n\t   { cdx : x ==> x} { prx : x => x} \n\t   {_ : sound cdx prx}\n\t   sound (Dm  x nlx cdx) (Dm' x prx)).\n\n%{ For this theorem, we need both complete development and parallel reduction,\nas well as a theorem case, so we extend <tt>=>&==>b</tt> as follows:\n}%\n\n%block soundb : block \n\t\t {x : trm} {nlx : notlam x} \n\t\t {cdx : x ==> x} \n\t\t {prx : x => x} \n\t\t {_ : sound cdx prx}.\n%worlds (soundb) (sound _ _).\n%total D (sound D _).\n\n%{ === Complete development is deterministic === \n\nFinally, we can show that complete development is derministic.\n\n}%\n\nid : trm -> trm -> type.\nrefl : id E E.\n\nid-app-cong : id E1 E1' -> id E2 E2' -> id (app E1 E2) (app E1' E2') -> type.\n%mode id-app-cong +X1 +X2 -X3.\n\n- : id-app-cong refl refl refl.\n\n%worlds (trmb) (id-app-cong _ _ _).\n%total {} (id-app-cong _ _ _).\n\nid-lam-cong : ({x : trm} id (E x) (E' x)) -> id (lam E) (lam E') -> type.\n%mode id-lam-cong +X1 -X3.\n\n- : id-lam-cong _ refl.\n\n%worlds (trmb) (id-lam-cong _ _).\n%total {} (id-lam-cong _ _).\n\nid-func : ({x : trm} id (E x) (E' x)) \n\t   -> id E1 E1' \n\t   -> id (E E1) (E' E1') -> type.\n%mode id-func +X1 +X2 -X3.\n\n- : id-func ([_] refl) refl refl.\n\n%worlds (trmb) (id-func _ _ _).\n%total {} (id-func _  _ _).\n\n==>-det : E ==> E' -> E ==> E'' -> id E' E'' -> type.\n%mode ==>-det +X1 +X2 -X3.\n\n- : ==>-det D D refl.\n\n- : ==>-det (==>/beta D1 D2) (==>/beta D1' D2') Id\n     <- ==>-det D1 D1' Id1\n     <- ({x} {nlx} {cdx} ==>-det (D2 x nlx cdx) (D2' x nlx cdx) (Id2 x))\n     <- id-func Id2 Id1 Id.\n\n- : ==>-det (==>/lam D) (==>/lam D') Id'\n     <- ({x} {nlx} {cdx} ==>-det (D x nlx cdx) (D' x nlx cdx) (Id x))\n     <- id-lam-cong Id Id'.\n\n- : ==>-det (==>/app Dnl D2 D1) (==>/app Dnl' D2' D1') Id\n     <- ==>-det D1 D1' Id1\n     <- ==>-det D2 D2' Id2\n     <- id-app-cong Id1 Id2 Id.\n\n%{\n\nTwelf rules out the off-diagonal cases for us.  For example, an <tt>app</tt> vs. <tt>beta</tt> \ncase would have a contradictory derivation of <tt>notlam (lam _)</tt> as an argument to <tt>==>/app</tt>.\n\n}% \n\n%worlds (==>b) (==>-det _ _ _).\n%total D (==>-det D _ _).\n\n%{\n{{case study}}\n}%"
          },
          "sha1": "8kvmwmj0bly011x39sl8gdka00z36ob"
        }
      },
      {
        "title": "Classical S5",
        "ns": 0,
        "id": 1735,
        "revision": {
          "id": 4402,
          "parentid": 3242,
          "timestamp": "2007-03-20T07:34:07Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "minor": null,
          "comment": "case study",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 25782,
            "#text": "This [[case studies|case study]] concerns the formalization of the [[modal logic]] '''Classical S5''' in the particular way it is done in ''[http://www.cs.cmu.edu/~tom7/papers/csl05-19-distributed.pdf Distributed Control Flow with Classical Modal Logic]'' (Murphy, Harper, Crary; CSL 2005). The natural deduction calculus '''C5''' is a nonstandard variation on the \"obvious\" classical S5 natural deduction which we chose for its operational interpretation, so that it can be used as a programming language. In the Twelf code below we prove that that C5 is equivalent to the \"obvious\" S5 by proving it equivalent to a standard [[admissibility of cut|cut-free]] sequent calculus for classical S5.\n\nTwelf excels for this kind of proof. The only difficulty is that the most natural definition of falsehood assumptions leads to a third-order relation, which Twelf's termination checker did not support at the time this code was developed. Instead, we have an explicit substitution theorem for such assumptions.\n\n== Natural deduction ==\n\n<twelf>\n%% Classical Judgmental S5\n%% Tom Murphy VII\n%% Thanks: Frank Pfenning and Jason Reed\n%%  8 Apr 2004\n\nworld : type.                           %name world W w.\nprop : type.                            %name prop A.\n\n\n%%% Natural deduction\n\n% truth assumptions and conclusions\n@ : prop -> world -> type.              %name @ N.\n%infix none 1 @.\n% falsehood (continuation) assumptions\n* : prop -> world -> type.              %name * X.\n%infix none 1 *.\n</twelf>\n\nWe have two judgments: ''A true @ W'' and ''A false * W''. We abbreviate these to <tt>A @ W</tt> and <tt>A * W</tt>.\n\n<twelf>\n% Implication\n=> : prop -> prop -> prop.\n%infix right 8 =>.\n=>I : (A @ W -> B @ W) -> (A => B @ W).\n=>E : (A => B @ W) -> A @ W -> B @ W.\n</twelf>\n\nThis is an [[intrinsic encoding]]: Derivations of well-formedness play the role of proof terms in the logic.\n\n<twelf>\n% Necessity\n! : prop -> prop.\n%prefix 9 !.\n!I : ({o:world} A @ o) -> ! A @ W.\n!E : ! A @ W -> A @ W.\n!G : ! A @ W' -> ! A @ W.\n\n% Possibility\n? : prop -> prop.\n%prefix 9 ?.\n?I : A @ W -> ? A @ W.\n?E : ? A @ W -> ({o:world} A @ o -> C @ W) -> C @ W.\n?G : ? A @ W' -> ? A @ W.\n</twelf>\n\nThere are two modal connectives: <math>\\Box A</math>, written <tt>!A</tt> and <math>\\Diamond A</math>, written <tt>?A</tt>. These two connectives are expressed in a non-standard way. The introduction and elimination forms all take place at the same world, and we give mobility forms <tt>!G</tt> and <tt>?G</tt> that allow us to move modal terms from world to world.\n\n<twelf>\n% Conjunction\n& : prop -> prop -> prop.\n%infix none 9 &.\n&I : A @ W -> B @ W -> (A & B @ W).\n&E1 : (A & B @ W) -> A @ W.\n&E2 : (A & B @ W) -> B @ W.\n\n% Falsehood\n_|_ : prop.\n_|_E : _|_ @ W -> C @ W'.\n\n% Structural Rules\n\nletcc : (A * W -> A @ W) -> \n             A @ W.\n\nthrow :     A @ W ->\n        (A * W -> C @ W').\n\n</twelf>\n\nThe calculus is classical, which we achieve by including <tt>letcc</tt> (which binds the current continuation) and <tt>throw</tt> (which throws an expression, perhaps remotely, to a continuation). There are no terms of falsehood type, except for variables <tt>u</tt> bound by <tt>letcc</tt>. Those are not represented explicitly because we use [[higher-order abstract syntax]].\n\n<twelf>\n% here : world.\n</twelf>\n\nIn order for some propositions to exist, we may wish to declare some world constant. Otherwise, our metatheorems may be vacuously true due to empty quantification. Alternatively, we choose to prove our metatheorems with respect to a (LF level) [[regular world]] where (object language) hypothetical worlds may occur in the context. See the declaration of <tt>blockw</tt> below.\n\n== Sequent calculus ==\n\n<twelf>\n%%% Sequent calculus\n\ntrue  : prop -> world -> type.       %name true T t.\nfalse : prop -> world -> type.       %name false F f.\n\n# : type.\n</twelf>\n\nSequents in the sequent calculus are represented by the judgment <tt>#</tt>, read as \"contradiction.\" Sequents are derived in a context with <tt>true</tt> and <tt>false</tt> assumptions. For instance, the initial sequent says that if A is both true and false at the same world, then a contradiction arises:\n\n<twelf>\n% initial sequent\ncontra : true A W -> false A W -> #.\n\n% arrow\n=>T : \n      (false A W -> #)    ->    (true B W -> #)    ->\n            (true (A => B) W -> #).\n=>F :\n      (true A W -> false B W -> #) ->\n        (false (A => B) W -> #).\n\n\n% box\n!T :\n      (true A W' -> #) ->\n      (true (! A) W -> #).\n!F :\n      ({w:world} false A w -> #) ->\n      (false (! A) W -> #).\n\n% dia\n?T :\n      ({w:world} true A w -> #) ->\n      (true (? A) W -> #).\n?F :\n      (false A W' -> #) ->\n      (false (? A) W -> #).\n</twelf>\n\nUnlike the natural deduction, this presentation of the {{box}} and {{dia}} connectives is completely standard.\n\n<twelf>\n% conjunction\n&T :\n      (true A W -> true B W -> #) ->\n        (true (A & B) W -> #).\n&F :\n      (false A W -> #)   ->   (false B W -> #) ->\n             (false (A & B) W -> #).                                 \n\n% falsehood\n\n_|_T : true _|_ W -> #.\n</twelf>\n\n== Cut elimination ==\n\n<twelf>\n% admissibility of excluded middle (cut)\n\nxm : {A:prop} {W:world} (true A W -> #) -> (false A W -> #) -> # -> type.\n%mode xm +A +W +D +E -F.\n\n</twelf>\n\nCut elimination for a classical sequent calculus is the law of the excluded middle: If in some ambient context, the assumption that <tt>A</tt> is true is contradictory, and the assumption that <tt>A</tt> is false is also contradictory, then the ambient context is also contradictory. The proof proceeds mostly like [[cut elimination|cut elimination for intuitionistic logic]].\n\n<twelf>\n% initial cuts\nxt_init : xm A W ([xt] contra xt D) ([xf] E xf) (E D).\nxf_init : xm A W ([xt] D xt) ([xf] contra E xf) (D E).\n\n% unused assumptions\nxt_unused : xm A W ([x1] contra DT DF) E (contra DT DF).\nxf_unused : xm A W D ([x1] contra ET EF) (contra ET EF).\n\n% falsehood. actually falsehood is trivial because a principal\n% cut is impossible, and the \"commutative\" cases aren't even inductive.\nxd_ct_|_ : xm A W ([at] _|_T DD) _ (_|_T DD).\nxe_ct_|_ : xm A W _ ([af] _|_T EE) (_|_T EE).\n\n% commutative cases.\n% note that we need to consider each rule in both D and E, so\n% there are four cases for each connective.\n\n% implication\nxd_ct=> : xm A W ([at : true A W] =>T \n                  ([cf : false C W'] D1 at cf) \n                  ([dt : true D W'] D2 at dt) DD) ([af] E af)\n               (=>T ([cf : false C W'] F1 cf) ([dt : true D W'] F2 dt) DD)\n           <- ({cf : false C W'} xm A W ([at] D1 at cf) E (F1 cf))\n           <- ({dt : true D W'}  xm A W ([at] D2 at dt) E (F2 dt)).\n\nxe_ct=> : xm A W ([at] DD at) ([af : false A W] =>T \n                               ([cf : false C W'] E1 af cf)\n                               ([dt : true D W'] E2 af dt) EE)\n               (=>T ([cf] F1 cf) ([dt] F2 dt) EE)\n           <- ({cf : false C W'} xm A W DD ([af] E1 af cf) (F1 cf))\n           <- ({dt : true D W'}  xm A W DD ([af] E2 af dt) (F2 dt)).\n\nxd_cf=> : xm A W ([at : true A W] =>F\n                  ([ct : true C W'] [df : false D W'] D' at ct df) DD)\n               ([af : false A W] E af)\n               (=>F ([ct : true C W'][df : false D W'] F ct df) DD)\n           <- ({ct : true C W'} {df : false D W'}\n                 xm A W ([at] D' at ct df) E (F ct df)).\n\nxe_cf=> : xm A W ([at : true A W] DD at)\n               ([af : false A W] =>F\n                  ([ct : true C W'] [df : false D W'] E' af ct df) EE)\n               (=>F ([ct : true C W'][df : false D W'] F ct df) EE)\n           <- ({ct : true C W'} {df : false D W'}\n                 xm A W DD ([af] E' af ct df) (F ct df)).\n\n% box\nxd_ct! : xm A W ([at : true A W] !T ([bt : true B W'] D1 at bt) DD)\n                ([af] E af)\n                (!T ([bt : true B W'] F1 bt) DD)\n          <- ({bt : true B W'} xm A W ([at] D1 at bt) E (F1 bt)).\n\nxe_ct! : xm A W ([at] D at) \n                ([af : false A W] !T ([bt : true B W'] E1 af bt) EE)\n                (!T ([bt : true B W'] F1 bt) EE)\n          <- ({bt : true B W'} xm A W D ([af] E1 af bt) (F1 bt)).\n\nxd_cf! : xm A W ([at : true A W] !F ([w][bf : false B w] D1 at w bf) DD)\n                ([af] E af)\n                (!F ([w][bf] F1 w bf) DD)\n          <- ({w : world}{bf : false B w}\n                xm A W ([at] D1 at w bf) E (F1 w bf)).\n\nxe_cf! : xm A W ([at] D at)\n                ([af] !F ([w][bf : false B w] E1 af w bf) EE)\n                (!F ([w][bf] F1 w bf) EE)\n          <- ({w}{bf} xm A W D ([af] E1 af w bf) (F1 w bf)).\n\n% dia\nxd_ct? : xm A W ([at : true A W] ?T ([w][bt] D1 at w bt) DD)\n                ([af] E af)\n                (?T ([w][bt] F1 w bt) DD)\n          <- ({w}{bt} xm A W ([at] D1 at w bt) ([af] E af) (F1 w bt)).\n\nxe_ct? : xm A W ([at] D at)\n                ([af] ?T ([w][bt] E1 af w bt) EE)\n                (?T ([w][bt] F1 w bt) EE)\n          <- ({w}{bt} xm A W ([at] D at) ([af] E1 af w bt) (F1 w bt)).\n\nxd_cf? : xm A W ([at] ?F ([bf : false B W'] D1 at bf) DD)\n                ([af] E af)\n                (?F ([bf] F1 bf) DD)\n          <- ({bf} xm A W ([at] D1 at bf) ([af] E af) (F1 bf)).\n\nxe_cf? : xm A W ([at] D at)\n                ([af] ?F ([bf : false B W'] E1 af bf) EE)\n                (?F ([bf] F1 bf) EE)\n          <- ({bf} xm A W ([at] D at) ([af] E1 af bf) (F1 bf)).\n\n% conjunction\nxd_ct& : xm A W ([at] &T ([ct][dt] D1 at ct dt) DD)\n                ([af] E af)\n                (&T ([ct][dt] F1 ct dt) DD)\n          <- ({ct}{dt} xm A W ([at] D1 at ct dt) ([af] E af) (F1 ct dt)).\n\nxe_ct& : xm A W ([at] D at)\n                ([af] &T ([ct][dt] E1 af ct dt) EE)\n                (&T ([ct][dt] F1 ct dt) EE)\n          <- ({ct}{dt} xm A W ([at] D at) ([af] E1 af ct dt) (F1 ct dt)).\n\nxd_cf& : xm A W ([at] &F ([cf] D1 at cf) ([df] D2 at df) DD)\n                ([af] E af)\n                (&F ([cf] F1 cf) ([df] F2 df) DD)\n          <- ({cf} xm A W ([at] D1 at cf) ([af] E af) (F1 cf))\n          <- ({df} xm A W ([at] D2 at df) ([af] E af) (F2 df)).\n\nxe_cf& : xm A W ([at] D at)\n                ([af] &F ([cf] E1 af cf) ([df] E2 af df) EE)\n                (&F ([cf] F1 cf) ([df] F2 df) EE)\n          <- ({cf} xm A W ([at] D at) ([af] E1 af cf) (F1 cf))\n          <- ({df} xm A W ([at] D at) ([af] E2 af df) (F2 df)).\n\n\n% principal cuts. there is one case for each connective;\n% a use of the true  rule on A in D, and\n% a use of the false rule on A in E.\n\n% implication\nx_=> : xm (A => B) W\n          ([it : true  (A => B) W] =>T ([af : false A W] D1 it af)\n                                       ([bt : true  B W] D2 it bt) it)\n          ([if : false (A => B) W] =>F ([at : true  A W]\n                                        [bf : false B W] E1 if at bf) if)\n          F\n        <- ({at : true A W} {bf : false B W}\n            xm (A => B) W ([it] =>T ([af : false A W] D1 it af) \n                                    ([bt] D2 it bt) it)\n                          ([if] E1 if at bf) (E1' at bf))\n        <- ({af : false A W}\n            xm (A => B) W ([it] D1 it af)\n                          ([if] =>F ([at][bf] E1 if at bf) if) (D1' af))\n        <- ({bt : true B W}\n            xm (A => B) W ([it] D2 it bt)\n                          ([if] =>F ([at][bf] E1 if at bf) if) (D2' bt))\n        <- ({bf : false B W}\n            xm A W ([at : true A W] E1' at bf) \n\t           ([af : false A W] D1' af) (F' bf))\n        <- xm B W ([bt] D2' bt) ([bf] F' bf) F.\n\n% box\nx_! : xm (! A) W ([nt] !T ([at : true A W'] D1 nt at) nt)\n                 ([nf] !F ([w][af : false A w] E1 nf w af) nf)\n                 F\n       <- ({w : world}{af : false A w}\n           xm (! A) W ([nt] !T ([at] D1 nt at) nt) \n\t              ([nf] E1 nf w af) (E1' w af))\n       <- ({at : true A W'}\n           xm (! A) W ([nt] D1 nt at) \n\t              ([nf] !F ([w][af] E1 nf w af) nf) (D1' at))\n       <- xm A W' ([at : true A W'] D1' at) \n\t          ([af : false A W'] E1' W' af) F.\n\n% dia\n\nx_? : xm (? A) W ([nt] ?T ([w][at] D1 nt w at) nt)\n                 ([nf] ?F ([af] E1 nf af) nf)\n                 F\n       <- ({w : world}{at : true A w}\n           xm (? A) W ([nt] D1 nt w at) \n\t              ([nf] ?F ([af] E1 nf af) nf) (D1' w at))\n       <- ({af : false A W'}\n           xm (? A) W ([nt] ?T ([w][at] D1 nt w at) nt) \n\t              ([nf] E1 nf af) (E1' af))\n       <- xm A W' ([at : true A W'] D1' W' at) ([af] E1' af) F.\n\n% conjunction\n\nx_& : xm (A & B) W ([&t] &T ([at][bt] D1 &t at bt) &t)\n                   ([&f] &F ([af] E1 &f af) ([bf] E2 &f bf) &f)\n                   F\n       <- ({at}{bt} xm (A & B) W ([&t] D1 &t at bt) \n                                 ([&f] &F ([af] E1 &f af) \n\t\t\t\t          ([bf] E2 &f bf) &f)\n                                 (D1' at bt))\n       <- ({af} xm (A & B) W ([&t] &T ([at][bt] D1 &t at bt) &t)\n                             ([&f] E1 &f af)\n                             (E1' af))\n       <- ({bf} xm (A & B) W ([&t] &T ([at][bt] D1 &t at bt) &t)\n                             ([&f] E2 &f bf)\n                             (E2' bf))\n       <- ({bt} xm A W ([at] D1' at bt) ([af] E1' af) (D1'' bt))\n       <- (xm B W ([bt] D1'' bt) ([bf] E2' bf) F).\n\n\n%block blockw : block {w : world}.\n%block blockt : some {A : prop} {W : world} block {tt : true  A W}.\n%block blockf : some {A : prop} {W : world} block {ff : false A W}.\n\n%worlds (blockw | blockt | blockf) (xm A W D E F).\n\n%total {A [D E]} (xm A W D E F).\n</twelf>\n\n== Natural deduction to sequent calculus ==\n\nThe admissibility of excluded middle allows us to straightforwardly translate natural deduction proofs to sequent calculus proofs. The theorem we prove is that if Γ;Δ {{vdash}} A @ W then Γ # A * W, Δ. Operationally, we can think of this as follows: if we have a program of type ''A'', then we can pass the result of that program to a continuation expecting ''A'' to get a contradiction.\n\n<twelf>\n%%% Translation from natural deduction to sequent calculus.\n\n% G;D |- A @ W    then   G # D,A * W\nndseq : A @ W -> (false A W -> #) -> type.\n%mode ndseq +D -F.\n\n% conjunction \n\nns-&I : ndseq (&I D1 D2) (&F F1 F2)\n         <- ndseq D1 F1\n         <- ndseq D2 F2.\n\nns-&E1 : ndseq (&E1 (D1 : A & B @ W))\n          ([af] F af)\n          <- ndseq D1 ([&f] F2 &f)\n          <- ({af} xm (A & B) W ([&t] &T ([at][bt] contra at af) &t) \n\t\t                ([&f] F2 &f) (F af)).\n\nns-&E2 : ndseq (&E2 (D1 : A & B @ W))\n          ([bf] F bf)\n          <- ndseq D1 ([&f] F2 &f)\n          <- ({bf} xm (A & B) W ([&t] &T ([at][bt] contra bt bf) &t) \n\t\t                ([&f] F2 &f) (F bf)).\n\n\n% falsehood\n\nns-_|_E : ndseq (_|_E (D1 : _|_ @ W))\n\t        ([af] F af)\n\t        <- ndseq D1 ([_|_f] F2 _|_f)\n\t\t<- ({af} xm (_|_) W ([_|_t] _|_T _|_t)\n\t\t                    ([_|_f] F2 _|_f) (F af)).\n\n% implication\n\nns-=>I : ndseq (=>I ([a : A @ W] D a))\n               ([=>f : false (A => B) W] \n\t\t=>F ([at : true A W][bf : false B W] F at bf) =>f)\n          <- ({a : A @ W}{at : true A W}\n              ndseq a ([af] contra at af) -> \n\n              ndseq (D a) ([bf] F at bf)).\n\nns-=>E : ndseq (=>E D1 D2)\n               ([bf] F bf)\n          <- ndseq D1 ([if] F1 if)\n          <- ndseq D2 ([af] F2 af)\n          <- ({bf} xm (A => B) W \n                ([it] =>T ([af] F2 af) ([bt] contra bt bf) it)\n                ([if] F1 if) (F bf)).\n\n% box\n\nns-!I : ndseq (!I [w] D1 w) (!F [w][af : false A w] F w af)\n         <- ({w} ndseq (D1 w) (F w)).\n\nns-!E : ndseq (!E D1) ([af] F af)\n         <- ndseq D1 ([!f] F1 !f)\n         <- ({af} xm (! A) W ([!t] !T ([at] contra at af) !t) \n                             ([!f] F1 !f) (F af)).\n\nns-!G : ndseq (!G D1) ([!f] F !f)\n         <- ndseq D1 ([!f'] F1 !f')\n         <- ({!f} xm (! A) W' \n               ([!t' : true (! A) W'] \n                  !F ([w'' : world][af'' : false A w''] \n                      (!T ([at'' : true A w''] contra at'' af'') !t')) !f)\n               ([!f' : false (! A) W'] F1 !f')\n               (F !f)).\n\n% dia\n\nns-?I : ndseq (?I D) ([?f] ?F ([af] F af) ?f)\n         <- ndseq D ([af] F af).\n\nns-?E : ndseq (?E D1 ([w : world][a : A @ w] D2 w a)) \n\t      ([cf : false C W] F cf)\n         <- ndseq D1 ([?f] F1 ?f)\n         <- ({w' : world}{a : A @ w'}{at : true A w'} \n               % another use of our block\n               ndseq a ([af] contra at af) ->\n               ndseq (D2 w' a) ([cf] F2 w' at cf))\n         <- ({cf : false C W} \n               xm (? A) W ([?t] ?T ([w][a] F2 w a cf) ?t)\n                          ([?f] F1 ?f) (F cf)).\n\nns-?G : ndseq (?G D) ([?f : false (? A) W] F ?f)\n         <- ndseq D ([?f' : false (? A) W'] F1 ?f')\n         <- ({?f : false (? A) W}\n               xm (? A) W'\n               ([?t'] ?T ([w''][at''] ?F ([af''] contra at'' af'') ?f) ?t')\n               ([?f'] F1 ?f')\n               (F ?f)).\n\n% we need a way of connecting nd continuation assumptions \n% with sequent false assumptions \ncontfalse : A * W -> false A W -> type.\n%mode contfalse +D -F.\n\n% note contraction: F in output uses af twice\nns-letcc : ndseq (letcc ([ac] D ac)) ([af] F af af)\n            <- ({ac : A * W} {af : false A W}\n                  contfalse ac af ->\n                  ndseq (D ac) (F af)).\n\n% note weakening: [cf'] is unused.\nns-throw : ndseq (throw D K) ([cf'] F AF)\n            <- ndseq D ([af] F af)\n            <- contfalse K AF.\n\n%block blockh : some {A:prop} {W:world}\n               block {a : A @ W} {at : true A W} \n\t\t     {_ : ndseq a ([af] contra at af)}.\n\n%block block* : some {A:prop} {W:world}\n               block {ac : A * W} {af : false A W} {_ : contfalse ac af}.\n\n%worlds (blockw | blockh | block*) (contfalse D F).\n%worlds (blockw | blockh | block*) (ndseq D F).\n\n%total D (contfalse D F).\n%total D (ndseq D F).\n</twelf>\n\n== Continuation substitution ==\n\nWe must prove a substitution theorem for falsehood assumptions, because we did not use the most [[higher-order abstract syntax]] encoding for them. Nonetheless, the theorem is interesting. It says that if we have a term ''M'' with a hypothesis for a (true) term of type ''A'', and we have a term ''N'' with a hypothesis for a (false) continuation expecting type ''A'', then our substitution operation can substitute M into N to satisfy the hypothesis. ''M'' must be well-typed at all types and all worlds.\n<!-- explanation could be better, but it is pretty subtle... -->\n\n<twelf>\n%% Continuation Substitution (excluded middle) for natural deduction\n\n% if   G,x:A@W; D |- M : *\n% and  G; D,u:A@W |- N : B\n% then G; D       |- [[ x.M/u ]] N : B\n\nxs : ({c}{w} A @ W -> c @ w) ->\n     (A * W -> B @ W') ->\n         (B @ W') -> type.                %name xs U.\n%mode xs +D +E -F.\n\n% trick: for any term closed wrt the continuation assumption,\n%   substitution is the identity. This keeps us from having to\n%   treat the case of @ variables, since they are always closed\n%   wrt * variables. Without this trick, world subsumption forces\n%   cases of xs to infect any later theorem that uses it!\n\nxs-closed : xs D ([a*] E) E.\n\n% falsehood\n\nxs-_|_E : xs D ([u] _|_E (EE u)) (_|_E EE')\n\t   <- xs D EE EE'.\n\n% conjunction\n\nxs-&I : xs D ([u] &I (EA u) (EB u)) (&I F1 F2)\n         <- xs D EA F1\n         <- xs D EB F2.\n\nxs-&E1 : xs D ([u] &E1 (E u)) (&E1 F)\n\t  <- xs D E F.\n\nxs-&E2 : xs D ([u] &E2 (E u)) (&E2 F)\n\t  <- xs D E F.\n\n% implication\n\nxs-=>I : xs D ([u] =>I ([aw : A @ W] E aw u)) (=>I ([aw] F aw))\n\t  <- ({aw : A @ W} xs D (E aw) (F aw)).\n\nxs-=>E : xs D ([u] =>E (DF u) (DA u)) (=>E FF FA)\n\t  <- xs D DF FF\n\t  <- xs D DA FA.\n\n% box\n\n\nxs-!I : xs D ([u : A * W] !I ([w] E u w)) (!I ([w] F w))\n\t <- ({w : world} xs D ([u] E u w) (F w)).\n\n\nxs-!G : xs D ([u] !G (E u)) (!G F)\n\t <- xs D E F.\n\nxs-!E : xs D ([u] !E (E u)) (!E F)\n\t <- xs D E F.\n\n% possibility\n\nxs-?E : xs D ([u] (?E (E1 u) ([w][a] E2 w a u))) (?E F1 ([w][a] F2 w a))\n\t <- xs D E1 F1\n\t <- ({w:world}{aw: A @ w} \n\t       xs D (E2 w aw) (F2 w aw)).\n\nxs-?I : xs D ([u] ?I (E u)) (?I F)\n\t <- xs D E F.\n\nxs-?G : xs D ([u] ?G (E u)) (?G F)\n\t <- xs D E F.\n\nxs-letcc : xs D ([u] letcc ([v] E v u)) (letcc ([v] F v))\n\t <- ({v : B * W'} xs D (E v) (F v)).\n\n% throw to different cont\nxs-throwmiss : xs D ([u] throw (E u) V) (throw F V)\n\t <- xs D E F.\n\n% when reaching the throw, pass the term we're throwing\n% to D instead.\nxs-throwhit  : xs D ([u] throw (E u) u) (D B W' F)\n\t\t<- xs D E F.\n\n% world and totality decls come after seqnd, which uses xs.\n% they infect each other somewhat, but the worlds decls for\n% xs are not substantially different than if it is checked\n% alone (there are just some extra unrelated additions)\n</twelf>\n\n== Sequent calculus to natural deduction ==\n\nWith substitution defined, we can now translate sequent calculus proofs back into C5 natural deduction. The theorem we prove is that if Γ # Δ then ∀C. ∀ω. Γ; Δ {{vdash}} C @ ω. \n\n<twelf>\n%%% Translation from Sequent Calculus to Natural Deduction\n\n%       G # D     then   G ; D |- M : * \nseqnd :   #         -> ({a}{w} a @ w) -> type.  %name seqnd S.\ntruend :  true A W  -> A @ W -> type.           %name truend T t.\nfalsend : false A W -> A * W -> type.           %name falsend F f.\n%mode seqnd +D -F.\n%mode truend +D -F.\n%mode falsend +D -F.\n\n\nsn-contra : seqnd (contra AT AF) ([c : prop][w : world] throw A AC)\n             <- truend AT A\n             <- falsend AF AC.\n\n% For each connective, the T side is easy -- it just corresponds to\n% the elimination rule. The F side requires the \"excluded substitution\"\n% theorem above, and is often quite tricky.\n\n% falsehood\n\nsn-_|_T : seqnd (_|_T FT) ([c][w] _|_E FT') <- truend FT FT'.\n\n% conjunction\n\nsn-&T : seqnd (&T ([at][bt] D at bt) T&) ([c][w] F (&E1 N&) (&E2 N&) c w)\n         <- ({at}{a} \n\t\ttruend at a ->\n             {bt}{b} \n\t\ttruend bt b ->\n             seqnd (D at bt) ([c][w] F a b c w))\n         <- truend T& N&.\n\nsn-&F : seqnd (&F ([af] D1 af) ([bf] D2 bf) (F& : false (A & B) W))\n\t      FF\n\t <- falsend F& N&\n\t <- ({af}{a*} falsend af a* ->\n             seqnd (D1 af) ([c][w] F1 a* c w))\n         <- ({bf}{b*} falsend bf b* ->\n             seqnd (D2 bf) ([c][w] F2 b* c w))\n         <- ({cc}{ww}{b : B @ W}\n\t     xs ([c][w] [a] throw (&I a b) N&)\n\t        ([a*] F1 a* cc ww)\n\t        (F1' b cc ww))\n\t <- ({cc : prop}{ww}\n\t     xs ([c][w] [b] F1' b c w)\n\t        ([b*] F2 b* cc ww)\n\t        (FF cc ww)).\n\n% implication\n\n% actually, implication is not just the elim rule, because\n% classical implication is phrased differently.\n\nsn-=>T : seqnd (=>T ([af : false A W] D1 af) ([bt] D2 bt) \n\t\t    (T=> : true (A => B) W))\n\t       FF\n\t  <- truend T=> N=>\n\t  <- ({af}{a*} falsend af a* ->\n\t      seqnd (D1 af) ([c][w] F1 a* c w))\n\t  <- ({bt}{b} \n\t\ttruend bt b ->\n              seqnd (D2 bt) ([c][w] F2 b c w))\n\t  <- ({cc}{ww}\n\t\txs ([c][w] [a] (F2 (=>E N=> a) c w))\n\t\t   ([a*] F1 a* cc ww)\n\t\t   (FF cc ww)).\n</twelf>\n\nThere are two ways to translate the <tt>=&gt;F</tt> rule; we can avoid using <tt>letcc</tt> if we like. We give both, taking advantage of the fact that LF relations need not be deterministic functions.\n<twelf>\n% letcc-free version\n% u : A=>B |- throw \\x:A . [[ c:B. throw \\unused:A.c to u / ... ]](IH) to u\nsn-=>F : seqnd (=>F ([at : true A W][bf : false B W] D at bf) F=>)\n\t       ([c][w] throw (=>I [a] FZ a B W) N=> )\n\t  <- falsend F=> N=>\n\t  <- ({at}{a}  \n\t\ttruend  at a  ->\n              {bf}{b*} falsend bf b* ->\n\t      seqnd (D at bf) ([c][w] F1 a b* c w))\n\t  <- ({a : A @ W}\n\t      {cc}{ww}\n\t\txs ([c][w] [b] throw (=>I [a-unused : A @ W] b) N=>)\n\t\t   ([b*] F1 a b* cc ww)\n\t\t   (FZ a cc ww)).\n\t\t\n\n% also include simpler letcc version\n% u : A=>B |- throw (\\x:A . letcc v : b* in (IH) end) to u\nsn-=>F-letcc : \n        seqnd (=>F ([at : true A W][bf : false B W] D at bf) F=>)\n\t      ([c][w] throw (=>I [a] letcc [b*] F1 a b* B W) N=>)\n\t  <- falsend F=> N=>\n\t  <- ({at}{a}  \n\t\ttruend  at a  ->\n              {bf}{b*} falsend bf b* ->\n\t      seqnd (D at bf) ([c][w] F1 a b* c w)).\n\n% box\n\nsn-!T : seqnd (!T ([at' : true A W'] D at') T!) ([c][w] F (!E (!G N!)) c w)\n\t <- ({at'}{a'} \n\t       truend at' a' ->\n\t     seqnd (D at') ([c][w] F a' c w))\n\t <- truend T! N!.\n\n% this is the only necessary letcc in the proof\n% u : []A * w |- throw (box w'. letcc v:A*w' in (IH) end) to u\nsn-!F : seqnd (!F ([w' : world][af : false A w'] D w' af) F!)\n\t      ([c][w] (throw (!I [w'] letcc ([a*'] F w' a*' A w')) N!))\n\t <- falsend F! N!\n\t <- ({w' : world}{af' : false A w'}{a*' : A * w'} \n\t       falsend af' a*' ->\n             seqnd (D w' af') ([c][w] F w' a*' c w)).\n\n% dia\n\n% x : ?A@w |- let dia <y,w'> = get<w>x in IH end\nsn-?T : seqnd (?T ([w'][at] D w' at) T?)\n\t ([c][w] ?E (?G N?) ([w'][a'] F w' a' c w))\n\t <- truend T? N?\n\t <- ({w'}{at : true A w'}{a' : A @ w'}\n\t       truend at a' ->\n             seqnd (D w' at) ([c][w] F w' a' c w)).\n\nsn-?F : seqnd (?F ([af'] D af') F?)\n\t FF\n\t <- falsend F? N?\n\t <- ({af' : false A W'}{a*' : A * W'}\n\t       falsend af' a*' ->\n             seqnd (D af') ([c][w] F1 a*' c w))\n\t <- ({cc}{ww}\n\t       xs ([c][w] [a'] (throw (?G (?I a')) N?))\n\t          ([a*'] F1 a*' cc ww)\n\t          (FF cc ww)).\n</twelf>\n\nFinally, we can declare the [[%worlds|worlds]] for our metatheorems and ask Twelf to check them:\n\n<twelf>\n\n% for xs\n%block blocku : some {A : prop} {W : world}\n\t\tblock {u : A * W}.\n\n%block blocka : some {A : prop} {W : world}\n\t\tblock {u : A @ W}.\n\n\n% for seqnd\n%block blocknt : some {A:prop} {W:world}\n                 block {at:true A W} {a:A @ W} \n\t\t  {t:truend at a}.\n%block blocknf : some {A:prop} {W:world}\n                 block {af:false A W} {a:A * W} {t:falsend af a}.\n\n%block blockp : block {a:prop}.\n\n%worlds (blockw | blocka | blocknt | blocknf | blocku | blockp) \n     (xs D E F) (seqnd D F) (truend D F) (falsend D F).\n\n%total E (xs D E F).\n\n%total (D T F) (seqnd D FF) (truend T N) (falsend F M).\n</twelf>\n\n<twelflink>All code from this case study</twelflink>. <twelflink check=\"true\">Twelf's output from this case study</twelflink>.\n\n[[Category:Twelf code]]\n{{case study}}"
          },
          "sha1": "4yfbluwub5wzy7nwto563jl2dlyn36p"
        }
      },
      {
        "title": "Compatibility lemma",
        "ns": 0,
        "id": 1790,
        "redirect": {
          "@title": "Respects lemma",
          "#text": null
        },
        "revision": {
          "id": 3276,
          "timestamp": "2006-11-02T19:06:28Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "comment": "redirect",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 28,
            "#text": "#REDIRECT [[respects lemma]]"
          },
          "sha1": "kvmdo2ffecn1utifv3zaxijpmmxr6xs"
        }
      },
      {
        "title": "Compositional bijection",
        "ns": 0,
        "id": 1960,
        "redirect": {
          "@title": "Adequacy",
          "#text": null
        },
        "revision": {
          "id": 4486,
          "timestamp": "2007-03-20T22:08:26Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "comment": "Redirecting to [[Adequacy]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 22,
            "#text": "#REDIRECT [[adequacy]]"
          },
          "sha1": "iquasw0k1z4qtwon0vy8uc5fwubis6k"
        }
      },
      {
        "title": "Computation and Deduction 2009",
        "ns": 0,
        "id": 2176,
        "revision": {
          "id": 5999,
          "parentid": 5997,
          "timestamp": "2009-04-29T19:16:12Z",
          "contributor": {
            "username": "Crary",
            "id": 13
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 1738,
            "#text": "These are notes for Computation and Deduction 2009.\n\n[[Computation and Deduction 2009/20090204 | Code from February 4.]]  Homework: complete the progress proof.\n\n[[Computation and Deduction 2009/20090209 | Code from February 9.]]  Homework: complete the preservation proof.\n\n[http://www.cs.cmu.edu/~cmartens/canonical.pdf Writeup of the material on canonical forms LF presented on February 11.]\n\n[[Computation and Deduction 2009/20090223 | Code from February 23.]]\n\n[[Computation and Deduction 2009/20090203 | Code from March 2.]]\n\n[[Computation and Deduction 2009/20090304 | Code from March 4.]]  Homework: complete the proof of the subst lemma.\n\n[[Computation and Deduction 2009/20090316 | Code from March 16.]]  Homework: complete the trans/ifz and trans/app cases.  ([[Computation and Deduction 2009/20090316-sol | Incomplete solution.]])\n\n[[Computation and Deduction 2009/20090318 | Code from March 18.]]\n\n[[Computation and Deduction 2009/20090325 | Code from March 25.]]\n\n[[Computation and Deduction 2009/20090330 | Code from March 30.]]\n\n[[Computation and Deduction 2009/20090401 | Code from April 1.]]\n\n[[Computation and Deduction 2009/20090406 | Code from April 6.]]\n\n[[Computation and Deduction 2009/20090408 | Code from April 8.]]\n\n[[Computation and Deduction 2009/20090413 | Code from April 13.]]\n\n[[Computation and Deduction 2009/20090415 | Code from April 15.]]\n\nProject ideas from 15-851 1997: [http://www.cs.cmu.edu/~fp/courses/97-comp-ded/projects.html]\n\n[[Computation and Deduction 2009/20090420 | Code from April 20.]]\n\n[[Computation and Deduction 2009/20090422 | Code from April 22.]]\n\n[[Computation and Deduction 2009/20090427 | Code from April 27.]]\n\n[[Computation and Deduction 2009/20090429 | Code from April 29.]]"
          },
          "sha1": "9tm5rleosk26tq1276hkjwpsy3ae7qk"
        }
      },
      {
        "title": "Computation and Deduction 2009/20090203",
        "ns": 0,
        "id": 2190,
        "revision": {
          "id": 5926,
          "timestamp": "2009-03-04T17:45:56Z",
          "contributor": {
            "username": "Crary",
            "id": 13
          },
          "comment": "New page: %{ Code from class, March 2. }%  ttp : type. %name ttp T.  tnum : ttp. tnot : ttp -> ttp. tprod : ttp -> ttp -> ttp.  texp : type. %name texp E. tval : type. %name tval V.  tlet : tval -> ...",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 3476,
            "#text": "%{ Code from class, March 2. }%\n\nttp : type. %name ttp T.\n\ntnum : ttp.\ntnot : ttp -> ttp.\ntprod : ttp -> ttp -> ttp.\n\ntexp : type. %name texp E.\ntval : type. %name tval V.\n\ntlet : tval -> (tval -> texp) -> texp.\ntpi1 : tval -> (tval -> texp) -> texp.\ntpi2 : tval -> (tval -> texp) -> texp.\ntifz : tval -> texp -> (tval -> texp) -> texp.\ntapp : tval -> tval -> texp.\n\ntz : tval.\nts : tval -> tval.\ntpair : tval -> tval -> tval.\ntlam : ttp -> (tval -> texp) -> tval.\n\ntof : tval -> ttp -> type.\ntwf : texp -> type.\n\ntof/z : tof tz tnum.\n\ntof/s : tof (ts V) tnum\n\t <- tof V tnum.\n\ntof/pair : tof (tpair V1 V2) (tprod T1 T2)\n\t    <- tof V1 T1\n\t    <- tof V2 T2.\n\ntof/lam : tof (tlam T ([x] E x)) (tnot T)\n\t   <- ({x} tof x T -> twf (E x)).\n\ntwf/let : twf (tlet V ([x] E x))\n\t   <- tof V T\n\t   <- ({x} tof x T -> twf (E x)).\n\ntwf/pi1 : twf (tpi1 V ([x] E x))\n\t   <- tof V (tprod T1 T2)\n\t   <- ({x} tof x T1 -> twf (E x)).\n\ntwf/pi2 : twf (tpi2 V ([x] E x))\n\t   <- tof V (tprod T1 T2)\n\t   <- ({x} tof x T2 -> twf (E x)).\n\ntwf/ifz : twf (tifz V E0 ([x] E1 x))\n\t   <- tof V tnum\n\t   <- twf E0\n\t   <- ({x} tof x tnum -> twf (E1 x)).\n\ntwf/app : twf (tapp V1 V2)\n\t   <- tof V1 (tnot T)\n\t   <- tof V2 T.\n\nttrans : tp -> ttp -> type.\n\nttrans/num : ttrans num tnum.\n\nttrans/arr : ttrans (arr T1 T2) (tnot (tprod T1' (tnot T2')))\n\t      <- ttrans T1 T1'\n\t      <- ttrans T2 T2'.\n\nsuspend : ttp -> tval -> tval\n        = [t] [v] (tlam (tnot t) ([f] tapp f v)).\n\ntrans : term -> tp -> tval -> type.\n\ntrans/z : trans z num (suspend tnum tz).\n\ntrans/s : trans (s E) num (tlam (tnot tnum) ([f] tapp V (tlam tnum ([x] tapp f (ts x)))))\n\t   <- trans E num V.\n\ntrans/ifz : trans (ifz E E0 ([x] E1 x)) T\n\t     (tlam (tnot T')\n\t\t([f] tapp V (tlam tnum ([y] tifz y (tapp V0 f)\n\t\t\t\t\t  ([y'] tlet (tlam (tnot tnum) ([g] tapp g y'))\n\t\t\t\t\t     ([x'] tapp (V1 x') f))))))\n\t     <- ttrans T T'\n\t     <- trans E num V\n\t     <- trans E0 T V0\n\t     <- ({x} {x'} trans x num x' -> trans (E1 x) T (V1 x')).\n\ntrans/lam : trans (lam T1 ([x] E x)) (arr T1 T2)\n             (suspend (tnot (tprod T1' (tnot T2')))\n\t              (tlam (tprod T1' (tnot T2'))\n\t\t\t       ([y] tpi1 y\n\t\t\t\t  ([y'] (tpi2 y\n\t\t\t\t\t   ([g] tlet (tlam (tnot T1') ([w] tapp w y'))\n\t\t\t\t\t      ([x'] tapp (V x') g)))))))\n\t     <- ttrans T1 T1'\n\t     <- ttrans T2 T2'\n\t     <- ({x} {x'} trans x T1 x' -> trans (E x) T2 (V x')).\n\ntrans/app : trans (app E1 E2) T2\n             (tlam (tnot T2') \n                ([f] tapp V1\n                   (tlam (tnot (tprod T1' (tnot T2')))\n                      ([x1] tapp V2 (tlam T1' ([x2] tapp x1 (tpair x2 f)))))))\n             <- ttrans T1 T1'\n             <- ttrans T2 T2'\n             <- trans E1 (arr T1 T2) V1\n             <- trans E2 T1 V2.\n\ntof/suspend : tof (suspend T V) (tnot (tnot T))\n               <- tof V T\n            = [D : tof V T] (tof/lam ([x] [d : tof x (tnot T)] (twf/app D d))).\n\ncorrect : trans E T V -> ttrans T T' -> tof V (tnot (tnot T')) -> type.\n%mode correct +D1 -D2 -D3.\ncorrect' : trans E T V -> ttrans T T' -> tof V (tnot (tnot T')) -> type.\n%mode correct' +D1 +D2 -D3.\n\n\n- : correct trans/z ttrans/num (tof/suspend tof/z).\n\n%block transbind : some {T : tp} {T' : ttp} {DTT : ttrans T T'}\n                    block\n                    {x : term} {dx : of x T}\n                    {x' : tval} {dx' : tof x' (tnot (tnot T'))}\n                    {dt : trans x T x'}\n                    {thm : correct dt DTT dx'}.\n\n\n\n%worlds (transbind) (correct _ _ _).\n%total D (correct D _ _)."
          },
          "sha1": "d404y5jysoudtf9rgnb6mruk9m8mm9y"
        }
      },
      {
        "title": "Computation and Deduction 2009/20090204",
        "ns": 0,
        "id": 2178,
        "revision": {
          "id": 5866,
          "timestamp": "2009-02-09T18:26:47Z",
          "contributor": {
            "ip": "128.237.253.162"
          },
          "comment": "New page: %{Code from class, February 4}%  tp : type.  %name tp T.  num : tp. arr : tp -> tp -> tp.  %worlds () (tp).  term : type.  %name term E.  z : term. s : term -> term. ifz : term -> term -> ...",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 2945,
            "#text": "%{Code from class, February 4}%\n\ntp : type.  %name tp T.\n\nnum : tp.\narr : tp -> tp -> tp.\n\n%worlds () (tp).\n\nterm : type.  %name term E.\n\nz : term.\ns : term -> term.\nifz : term -> term -> (term -> term) -> term.\nlam : tp -> (term -> term) -> term.\napp : term -> term -> term.\n\n%block var : block {x:term}.\n%worlds (var) (term).\n\nof : term -> tp -> type.\n\nof/z : of z num.\n\nof/s : of (s N) num\n        <- of N num.\n\nof/ifz : of (ifz E E0 ([x] E1 x)) T\n          <- of E num\n          <- of E0 T\n          <- ({x} of x num -> of (E1 x) T).\n\nof/lam : of (lam T ([x] E x)) (arr T T')\n          <- ({x} of x T -> of (E x) T').\n\nof/app : of (app E1 E2) T'\n          <- of E1 (arr T T')\n          <- of E2 T.\n\n%block stupid : some {x:term} {t:tp} block {d:of x t}.\n%block bind : some {T:tp} block {x:term} {d : of x T}.\n%worlds (bind) (of _ _).\n\nvalue : term -> type.\n\nvalue/z : value z.\n\nvalue/s : value (s E)\n           <- value E.\n\nvalue/lam : value (lam T E).\n\n%worlds () (value _).\n\n\n\nstep : term -> term -> type.\n\nstep/s : step (s E) (s E')\n          <- step E E'.\n\nstep/ifz/arg : step (ifz E E0 ([x] E1 x)) (ifz E' E0 E1)\n                <- step E E'.\n\nstep/ifz/z : step (ifz z E0 E1) E0.\n\nstep/ifz/s : step (ifz (s E) E0 ([x] E1 x)) (E1 E)\n              <- value E.\n\nstep/app/fn : step (app E1 E2) (app E1' E2)\n\t       <- step E1 E1'.\n\nstep/app/arg : step (app E1 E2) (app E1 E2')\n\t\t<- value E1\n\t\t<- step E2 E2'.\n\nstep/app/beta : step (app (lam T ([x] E1 x)) E2) (E1 E2)\n\t\t <- value E2.\n\n%worlds () (step _ _).\n\n\nunstuck : term -> type.\nunstuck/val : unstuck E\n\t       <- value E.\n\nunstuck/step : unstuck E\n\t\t<- step E E'.\n\nprogress-s : unstuck E -> unstuck (s E) -> type.\n%mode progress-s +X1 -X2.\n\n- : progress-s (unstuck/val (D : value E)) (unstuck/val (value/s D)).\n\n- : progress-s (unstuck/step (D : step E E')) (unstuck/step (step/s D)).\n\n%worlds () (progress-s _ _).\n%total {} (progress-s _ _).\n\nprogress-ifz : of E num -> unstuck E -> {E0:term} {E1:term -> term} unstuck (ifz E E0 E1) -> type.\n%mode progress-ifz +D1 +D2 +E0 +E1 -D3.\n\n- : progress-ifz _ (unstuck/step (D : step E E')) E0 E1 (unstuck/step (step/ifz/arg D)).\n\n- : progress-ifz \n     (Dof : of z num)\n     (unstuck/val (value/z))\n     E0 E1\n     (unstuck/step step/ifz/z).\n\n- : progress-ifz\n     (Dof : of (s E) num)\n     (unstuck/val (value/s (Dval : value E)))\n     E0 E1\n     (unstuck/step (step/ifz/s Dval)).\n\n%worlds () (progress-ifz _ _ _ _ _).\n%total {} (progress-ifz _ _ _ _ _).\n\nprogress : of E T -> unstuck E -> type.\n%mode progress +D -D'.\n\n- : progress of/z (unstuck/val value/z).\n\n- : progress (of/s (D : of E num)) D''\n     <- progress D (D' : unstuck E)\n     <- progress-s D' (D'' : unstuck (s E)).\n\n- : progress \n     (of/ifz\n\t(D1 : {x} of x num -> of (E1 x) T)\n\t(D0 : of E0 T)\n\t(D : of E num))\n     D''\n     <- progress D (D' : unstuck E)\n     <- progress-ifz D  D' E0 E1 (D'' : unstuck (ifz E E0 E1)).\n\n%worlds () (progress _ _).\n%total D (progress D _)."
          },
          "sha1": "q5uml1xja61we3oqkmhw0nbo1skqhg9"
        }
      },
      {
        "title": "Computation and Deduction 2009/20090209",
        "ns": 0,
        "id": 2180,
        "revision": {
          "id": 5876,
          "parentid": 5875,
          "timestamp": "2009-02-11T01:44:17Z",
          "contributor": {
            "username": "Crary",
            "id": 13
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 4528,
            "#text": "%{ Code from class, February 9 }%\n\n%% MinML language\n\ntp : type.\n\nnum : tp.\narr : tp -> tp -> tp.\n\n%worlds () (tp).\n\nterm : type.\n\nz : term.\ns : term -> term.\nifz : term -> term -> (term -> term) -> term.\nlam : tp -> (term -> term) -> term.\napp : term -> term -> term.\n\n%block var : block {x:term}.\n%worlds (var) (term).\n\nof : term -> tp -> type.\n\nof/z : of z num.\n\nof/s : of (s E) num\n        <- of E num.\n\nof/ifz : of (ifz En E0 ([x] Es x)) T\n          <- of En num\n          <- of E0 T\n          <- ({x : term} of x num -> of (Es x) T).\n\nof/lam : of (lam T1 ([x] E2 x)) (arr T1 T2)\n          <- ({x : term} of x T1 -> of (E2 x) T2).\n\nof/app : of (app E1 E2) T\n          <- of E1 (arr T2 T)\n          <- of E2 T2.\n\n\n%block stupid : some {x:term} {t:tp} block {d:of x t}.\n%block bind : some {T:tp} block {x:term} {d : of x T}.\n%worlds (bind) (of _ _).\n\n%% Here we are using subordination.\n%% It indicates when \n%% You can see the transitive closure using Print.subord\n%% Non-subordination is what is really importing\n%% term is not subordinate to tp so a world made of terms might as well\n%% be the empty world as far as a tp is concerned.\n\n%% Similarly of is not subordinate to term and of is not subordinate to tp.\n%% So the of assumption in bind drops out as far as term is concerned.\n\nvalue : term -> type.\n\nval/z : value z.\n\nval/s : value (s E)\n         <- value E.\n\nval/lam : value (lam T ([x] E x)).\n\n%worlds () (value _).\n\nstep : term -> term -> type.\n\nstep/s : step (s E) (s E')\n          <- step E E'.\n\nstep/ifz/arg : step (ifz En E0 ([x] Es x)) (ifz En' E0 ([x] Es x))\n                <- step En En'.\n\nstep/ifz/z : step (ifz z E0 ([x] Es x)) E0.\n\nstep/ifz/s : step (ifz (s E) E0 ([x] Es x)) (Es E)\n              <- value E.\n\nstep/app/fn : step (app E1 E2) (app E1' E2)\n               <- step E1 E1'.\n\nstep/app/arg : step (app E1 E2) (app E1 E2')\n                <- value E1\n                <- step E2 E2'.\n\nstep/app/beta : step (app (lam T2 ([x] (E x))) E2) (E E2)\n                 <- value E2.\n\n%worlds () (step _ _).\n\n%% Progress\n%% If |- e : \\tau then either value e or \\exists e'. e \\stepsto e'\n\nunstuck : term -> type.\n\nunstuck/val : unstuck E\n               <- value E.\n\nunstuck/step : unstuck E\n                <- step E E'.\n\n%worlds () (unstuck _).\n\nprogress-s : unstuck E -> unstuck (s E) -> type.\n%mode progress-s +D1 -D2.\n\n- : progress-s (unstuck/val Dval) (unstuck/val (val/s Dval)).\n\n- : progress-s (unstuck/step Dstep) (unstuck/step (step/s Dstep)).\n\n%worlds () (progress-s _ _).\n%total {} (progress-s _ _).\n\nprogress-ifz : of E num -> unstuck E -> {E0} {E1} unstuck (ifz E E0 E1) -> type.\n%mode progress-ifz +D1 +D2 +E0 +E1 -D3.\n\n- : progress-ifz _ (unstuck/step Dstep) _ _ (unstuck/step (step/ifz/arg Dstep)).\n\n- : progress-ifz of/z (unstuck/val val/z) _ _ (unstuck/step step/ifz/z).\n\n- : progress-ifz (of/s Dof) (unstuck/val (val/s Dval)) _ _ (unstuck/step (step/ifz/s Dval)).\n\n%worlds () (progress-ifz _ _ _ _ _).\n%total D (progress-ifz D _ _ _ _).\n\nprogress-app : of E (arr T1 T2) -> unstuck E -> unstuck E1 -> unstuck (app E E1) -> type.\n%mode progress-app +D1 +D2 +D3 -D4.\n\n- : progress-app _ (unstuck/step Dstep) _ (unstuck/step (step/app/fn Dstep)).\n\n- : progress-app _ (unstuck/val Dval) (unstuck/step Dstep) (unstuck/step (step/app/arg Dstep Dval)).\n\n- : progress-app (of/lam _) (unstuck/val val/lam) (unstuck/val Dval) (unstuck/step (step/app/beta Dval)).\n\n%worlds () (progress-app _ _ _ _).\n%total D (progress-app D _ _ _).\n\nprogress : of E T -> unstuck E -> type.\n%mode progress +D1 -D2.\n\n- : progress of/z (unstuck/val val/z).\n\n- : progress (of/s Dof) Dunstuck'\n     <- progress Dof Dunstuck\n     <- progress-s Dunstuck Dunstuck'.\n\n- : progress\n     (of/ifz\n        DofBody\n        DofE0\n        DofE)\n     Dunstuck'\n     <- progress DofE Dunstuck\n     <- progress-ifz DofE Dunstuck _ _ Dunstuck'.\n\n- : progress\n     (of/app\n        DofE1\n        DofE)\n     Dunstuck'\n     <- progress DofE Dunstuck\n     <- progress DofE1 Dunstuck1\n     <- progress-app DofE Dunstuck Dunstuck1 Dunstuck'.\n\n- : progress\n     (of/lam _)\n     (unstuck/val val/lam).\n\n%worlds () (progress _ _).\n%total D (progress D _).\n\n%% preservation\npreservation : of E T -> step E E' -> of E' T -> type.\n%mode preservation +D1 +D2 -D3.\n\n- : preservation (of/s D1) (step/s Dstep) (of/s D1')\n     <- preservation D1 Dstep D1'.\n\n- : preservation (of/ifz Dbody D0 of/z) step/ifz/z D0.\n\n- : preservation (of/ifz Dbody D0 (of/s Dn)) (step/ifz/s _) (Dbody _ Dn).\n\n%worlds () (preservation _ _ _).\n%total D (preservation _ D _)."
          },
          "sha1": "72otr22wcrp7wl8bswoegusrlsrcpjb"
        }
      },
      {
        "title": "Computation and Deduction 2009/20090223",
        "ns": 0,
        "id": 2185,
        "revision": {
          "id": 5905,
          "timestamp": "2009-02-23T21:43:33Z",
          "contributor": {
            "username": "Crary",
            "id": 13
          },
          "comment": "New page: %{ Code from class, February 23. }%  ttp : type. %name ttp T.  tnum : ttp. tnot : ttp -> ttp. tprod : ttp -> ttp -> ttp.  texp : type. %name texp E. tval : type. %name tval V.  tlet : tval...",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 2289,
            "#text": "%{ Code from class, February 23. }%\n\nttp : type. %name ttp T.\n\ntnum : ttp.\ntnot : ttp -> ttp.\ntprod : ttp -> ttp -> ttp.\n\ntexp : type. %name texp E.\ntval : type. %name tval V.\n\ntlet : tval -> (tval -> texp) -> texp.\ntpi1 : tval -> (tval -> texp) -> texp.\ntpi2 : tval -> (tval -> texp) -> texp.\ntifz : tval -> texp -> (tval -> texp) -> texp.\ntapp : tval -> tval -> texp.\n\ntz : tval.\nts : tval -> tval.\ntpair : tval -> tval -> tval.\ntlam : ttp -> (tval -> texp) -> tval.\n\ntof : tval -> ttp -> type.\ntwf : texp -> type.\n\ntof/z : tof tz tnum.\n\ntof/s : tof (ts V) tnum\n\t <- tof V tnum.\n\ntof/pair : tof (tpair V1 V2) (tprod T1 T2)\n\t    <- tof V1 T1\n\t    <- tof V2 T2.\n\ntof/lam : tof (tlam T ([x] E x)) (tnot T)\n\t   <- ({x} tof x T -> twf (E x)).\n\ntwf/let : twf (tlet V ([x] E x))\n\t   <- tof V T\n\t   <- ({x} tof x T -> twf (E x)).\n\ntwf/pi1 : twf (tpi1 V ([x] E x))\n\t   <- tof V (tprod T1 T2)\n\t   <- ({x} tof x T1 -> twf (E x)).\n\ntwf/pi2 : twf (tpi2 V ([x] E x))\n\t   <- tof V (tprod T1 T2)\n\t   <- ({x} tof x T2 -> twf (E x)).\n\ntwf/ifz : twf (tifz V E0 ([x] E1 x))\n\t   <- tof V tnum\n\t   <- twf E0\n\t   <- ({x} tof x tnum -> twf (E1 x)).\n\ntwf/app : twf (tapp V1 V2)\n\t   <- tof V1 (tnot T)\n\t   <- tof V2 T.\n\nttrans : tp -> ttp -> type.\n\nttrans/num : ttrans num tnum.\n\nttrans/arr : ttrans (arr T1 T2) (tnot (tprod T1' (tnot T2')))\n\t      <- ttrans T1 T1'\n\t      <- ttrans T2 T2'.\n\ntrans : term -> tp -> tval -> type.\n\ntrans/z : trans z num (tlam (tnot tnum) ([f] tapp f tz)).\n\ntrans/s : trans (s E) num (tlam (tnot tnum) ([f] tapp V (tlam tnum ([x] tapp f (ts x)))))\n\t   <- trans E num V.\n\ntrans/ifz : trans (ifz E E0 ([x] E1 x)) T\n\t     (tlam (tnot T')\n\t\t([f] tapp V (tlam tnum ([y] tifz y (tapp V0 f)\n\t\t\t\t\t  ([y'] tlet (tlam (tnot tnum) ([g] tapp g y'))\n\t\t\t\t\t     ([x'] tapp (V1 x') f))))))\n\t     <- ttrans T T'\n\t     <- trans E num V\n\t     <- trans E0 T V0\n\t     <- ({x} {x'} trans x num x' -> trans (E1 x) T (V1 x')).\n\ntrans/lam : trans (lam T1 ([x] E x)) (arr T1 T2)\n\t     (tlam (tnot (tnot (tprod T1' (tnot T2'))))\n\t\t([f] tapp f (tlam (tprod T1' (tnot T2'))\n\t\t\t       ([y] tpi1 y\n\t\t\t\t  ([y'] (tpi2 y\n\t\t\t\t\t   ([g] tlet (tlam (tnot T1') ([w] tapp w y'))\n\t\t\t\t\t      ([x'] tapp (V x') g))))))))\n\t     <- ttrans T1 T1'\n\t     <- ttrans T2 T2'\n\t     <- ({x} {x'} trans x T1 x' -> trans (E x) T2 (V x'))."
          },
          "sha1": "fdse7j9sp97ouzzjdxr8pgbx0v5qs1i"
        }
      },
      {
        "title": "Computation and Deduction 2009/20090304",
        "ns": 0,
        "id": 2191,
        "revision": {
          "id": 5930,
          "parentid": 5928,
          "timestamp": "2009-03-05T05:41:26Z",
          "contributor": {
            "username": "William Lovas",
            "id": 11
          },
          "minor": null,
          "comment": "header explanation",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 3894,
            "#text": "%{\nCode from class, March 4.\n\nTranslates lambda calculus into combinator calculus to illustrate non-trivial worlds.\n\n== Syntax ==\n\n}%\n\n% lambda calculus\n\nterm : type.                    %name term M x.\n\napp : term -> term -> term.\nlam : (term -> term) -> term.\n\n%block term-block : block {x:term}.\n%worlds (term-block) (term).\n\n% combinator calculus\n\ncomb : type.                    %name comb A y.\n\ns : comb.\nk : comb.\ni : comb.\ncapp : comb -> comb -> comb.\n\n%block comb-block : block {y:comb}.\n%worlds (comb-block) (comb).\n\n%{\n\n== Translation ==\n\n}%\n\n% bracket abstraction\n\nbracket : (comb -> comb) -> comb -> type.\n%mode bracket +A -A'.\n\nbracket/var : bracket ([y] y) i.\n\nbracket/i : bracket ([y] i) (capp k i).\nbracket/k : bracket ([y] k) (capp k k).\nbracket/s : bracket ([y] s) (capp k s).\n\nbracket/app : bracket ([y] capp (A y) (B y)) (capp (capp s A') B')\n               <- bracket ([y] A y) A'\n               <- bracket ([y] B y) B'.\n\n%block bracket-block : block {y:comb} {bracket/y:bracket ([z] y) (capp k y)}.\n\n%worlds (bracket-block) (bracket _ _).\n%total A (bracket A _).\n\n\n% translation\n\ntranslate : term -> comb -> type.\n%mode translate +M -A.\n\ntranslate/app : translate (app M N) (capp A B)\n                 <- translate M A\n                 <- translate N B.\n\ntranslate/lam : translate (lam ([x] M x)) A'\n                 <- ({x} {y} bracket ([z] y) (capp k y)\n                            -> translate x y\n                            -> translate (M x) (A y))\n                 <- bracket ([y] A y) A'.\n\n%block translate-block\n        : block {x:term} {y:comb}\n                {bracket/y: bracket ([z] y) (capp k y)}\n                {translate/x: translate x y}.\n%worlds (translate-block) (translate _ _).\n%total M (translate M _).\n\n%{\n\n== Equational theory ==\n\nLambda term equality was discussed only briefly.  Combinator equality was presented for the <tt>subst</tt> lemma, below.\n\n}%\n\n% lambda term equality\n\nteq : term -> term -> type.\n\n% beta\nteq/beta : teq (app (lam ([x] M x)) N) (M N).\n\n% extensionality (eta)\nteq/ext : teq M M'\n           <- ({x:term} teq (app M x) (app M' x)).\n\n% compatibilities\nteq/app : teq (app M N) (app M' N')\n           <- teq M M'\n           <- teq N N'.\n\nteq/lam : teq (lam ([x] M x)) (lam ([x] M' x))\n           <- ({x:term} teq (M x) (M' x)).\n\n% equivalence\nteq/refl : teq M M.\n\nteq/symm : teq M M'\n            <- teq M' M.\n\nteq/trans : teq M M'\n             <- teq M N\n             <- teq N M'.\n\n%worlds (term-block) (teq _ _).\n\n\n% combinator equality\n\nceq : comb -> comb -> type.\n\n% betas\nceq/i : ceq (capp i A) A.\nceq/k : ceq (capp (capp k A) B) A.\nceq/s : ceq (capp (capp (capp s A) B) C) (capp (capp A C) (capp B C)).\n\n% extensionality\nceq/ext : ceq A A'\n           <- ({y:comb} ceq (capp A y) (capp A' y)).\n\n% compatibility\nceq/app : ceq (capp A B) (capp A' B')\n           <- ceq A A'\n           <- ceq B B'.\n\n% equivalence\nceq/refl : ceq A A.\n\nceq/symm : ceq A A'\n            <- ceq A' A.\n\nceq/trans : ceq A A'\n             <- ceq A B\n             <- ceq B A'.\n\n%worlds (comb-block) (ceq _ _).\n\n\n\n%{\n\n== Correctness of the translation ==\n\n}%\n\n% substitution lemma\n\nsubst : bracket ([y] A y) A' -> {C:comb} ceq (capp A' C) (A C) -> type.\n%mode subst +Dbrack +C -Dceq.\n\n- : subst (bracket/var : bracket ([y] y) i)\n          C\n          (ceq/i : ceq (capp i C) C).\n\n- : subst (bracket/i : bracket ([y] i) (capp k i))\n          C\n          (ceq/k : ceq (capp (capp k i) C) i).\n\n- : subst (bracket/k : bracket ([y] k) (capp k k))\n          C\n          (ceq/k : ceq (capp (capp k k) C) k).\n\n- : subst (bracket/s : bracket ([y] s) (capp k s))\n          C\n          (ceq/k : ceq (capp (capp k s) C) s).\n\n%block subst-block : block {y:comb}\n                           {bracket/y: bracket ([z] y) (capp k y)}\n                           {thm-subst: {C:comb} subst bracket/y C ceq/k}.\n%worlds (subst-block) (subst _ _ _).\n%total D (subst D _ _)."
          },
          "sha1": "dmb9yp82plztsrwsf9aa9t8eg7a7zmf"
        }
      },
      {
        "title": "Computation and Deduction 2009/20090304-support",
        "ns": 0,
        "id": 2189,
        "revision": {
          "id": 5923,
          "timestamp": "2009-03-04T17:14:43Z",
          "contributor": {
            "username": "William Lovas",
            "id": 11
          },
          "comment": "added support code",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 653,
            "#text": "%{\n\nSupport code for March 4 guest lecture on worlds-checking and combinators.\n\n}%\n\n% combinator equality\n\nceq : comb -> comb -> type.\n\n% betas\nceq/i : ceq (capp i A) A.\nceq/k : ceq (capp (capp k A) B) A.\nceq/s : ceq (capp (capp (capp s A) B) C) (capp (capp A C) (capp B C)).\n\n% extensionality\nceq/ext : ceq A A'\n           <- ({y:comb} ceq (capp A y) (capp A' y)).\n\n% compatibility\nceq/app : ceq (capp A B) (capp A' B')\n           <- ceq A A'\n           <- ceq B B'.\n\n% equivalence\nceq/refl : ceq A A.\n\nceq/symm : ceq A A'\n            <- ceq A' A.\n\nceq/trans : ceq A A'\n             <- ceq A B\n             <- ceq B A'.\n\n%worlds (comb-block) (ceq _ _)."
          },
          "sha1": "gn6unji8mu4f3542eq7vo65r31s5ei4"
        }
      },
      {
        "title": "Computation and Deduction 2009/20090316",
        "ns": 0,
        "id": 2197,
        "revision": {
          "id": 5943,
          "timestamp": "2009-03-17T20:17:43Z",
          "contributor": {
            "username": "Crary",
            "id": 13
          },
          "comment": "Created page with '%{ Code from class, March 16. }%  ttp : type. %name ttp T.  tnum : ttp. tnot : ttp -> ttp. tprod : ttp -> ttp -> ttp.  texp : type. %name texp E. tval : type. %name tval V.  tlet...'",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 4395,
            "#text": "%{ Code from class, March 16. }%\n\nttp : type. %name ttp T.\n\ntnum : ttp.\ntnot : ttp -> ttp.\ntprod : ttp -> ttp -> ttp.\n\ntexp : type. %name texp E.\ntval : type. %name tval V.\n\ntlet : tval -> (tval -> texp) -> texp.\ntpi1 : tval -> (tval -> texp) -> texp.\ntpi2 : tval -> (tval -> texp) -> texp.\ntifz : tval -> texp -> (tval -> texp) -> texp.\ntapp : tval -> tval -> texp.\n\ntz : tval.\nts : tval -> tval.\ntpair : tval -> tval -> tval.\ntlam : ttp -> (tval -> texp) -> tval.\n\ntof : tval -> ttp -> type.\ntwf : texp -> type.\n\ntof/z : tof tz tnum.\n\ntof/s : tof (ts V) tnum\n\t <- tof V tnum.\n\ntof/pair : tof (tpair V1 V2) (tprod T1 T2)\n\t    <- tof V1 T1\n\t    <- tof V2 T2.\n\ntof/lam : tof (tlam T ([x] E x)) (tnot T)\n\t   <- ({x} tof x T -> twf (E x)).\n\ntwf/let : twf (tlet V ([x] E x))\n\t   <- tof V T\n\t   <- ({x} tof x T -> twf (E x)).\n\ntwf/pi1 : twf (tpi1 V ([x] E x))\n\t   <- tof V (tprod T1 T2)\n\t   <- ({x} tof x T1 -> twf (E x)).\n\ntwf/pi2 : twf (tpi2 V ([x] E x))\n\t   <- tof V (tprod T1 T2)\n\t   <- ({x} tof x T2 -> twf (E x)).\n\ntwf/ifz : twf (tifz V E0 ([x] E1 x))\n\t   <- tof V tnum\n\t   <- twf E0\n\t   <- ({x} tof x tnum -> twf (E1 x)).\n\ntwf/app : twf (tapp V1 V2)\n\t   <- tof V1 (tnot T)\n\t   <- tof V2 T.\n\nttrans : tp -> ttp -> type.\n\nttrans/num : ttrans num tnum.\n\nttrans/arr : ttrans (arr T1 T2) (tnot (tprod T1' (tnot T2')))\n\t      <- ttrans T1 T1'\n\t      <- ttrans T2 T2'.\n\nsuspend : ttp -> tval -> tval\n        = [t] [v] (tlam (tnot t) ([f] tapp f v)).\n\ntrans : term -> tp -> tval -> type.\n\ntrans/z : trans z num (suspend tnum tz).\n\ntrans/s : trans (s E) num (tlam (tnot tnum) ([f] tapp V (tlam tnum ([x] tapp f (ts x)))))\n\t   <- trans E num V.\n\ntrans/ifz : trans (ifz E E0 ([x] E1 x)) T\n\t     (tlam (tnot T')\n\t\t([f] tapp V (tlam tnum ([y] tifz y (tapp V0 f)\n\t\t\t\t\t  ([y'] tlet (tlam (tnot tnum) ([g] tapp g y'))\n\t\t\t\t\t     ([x'] tapp (V1 x') f))))))\n\t     <- ttrans T T'\n\t     <- trans E num V\n\t     <- trans E0 T V0\n\t     <- ({x} {x'} trans x num x' -> trans (E1 x) T (V1 x')).\n\ntrans/lam : trans (lam T1 ([x] E x)) (arr T1 T2)\n             (suspend (tnot (tprod T1' (tnot T2')))\n\t              (tlam (tprod T1' (tnot T2'))\n\t\t\t       ([y] tpi1 y\n\t\t\t\t  ([y'] (tpi2 y\n\t\t\t\t\t   ([g] tlet (suspend T1' y')\n\t\t\t\t\t      ([x'] tapp (V x') g)))))))\n\t     <- ttrans T1 T1'\n\t     <- ttrans T2 T2'\n\t     <- ({x} {x'} trans x T1 x' -> trans (E x) T2 (V x')).\n\ntrans/app : trans (app E1 E2) T2\n             (tlam (tnot T2') \n                ([f] tapp V1\n                   (tlam (tnot (tprod T1' (tnot T2')))\n                      ([x1] tapp V2 (tlam T1' ([x2] tapp x1 (tpair x2 f)))))))\n             <- ttrans T1 T1'\n             <- ttrans T2 T2'\n             <- trans E1 (arr T1 T2) V1\n             <- trans E2 T1 V2.\n\ntof/suspend : tof (suspend T V) (tnot (tnot T))\n               <- tof V T\n            = [D : tof V T] (tof/lam ([x] [d : tof x (tnot T)] (twf/app D d))).\n\n\ncorrect : trans E T V -> ttrans T T' -> tof V (tnot (tnot T')) -> type.\n%mode correct +D1 -D2 -D3.\n\ncorrect' : trans E T V -> ttrans T T' -> tof V (tnot (tnot T')) -> type.\n%mode correct' +D1 +D2 -D3.\n\n- : correct trans/z ttrans/num (tof/suspend tof/z).\n\n- : correct \n     (trans/s \n\t(D : trans E num V))\n     ttrans/num \n     (tof/lam \n\t([f] [df:tof f (tnot tnum)] \n\t   twf/app \n\t   (tof/lam ([x] [dx:tof x tnum] (twf/app (tof/s dx) df))) \n\t   D'))\n     <- correct' D ttrans/num (D': tof V (tnot (tnot tnum))).\n\n- : correct \n     (trans/lam \n\t(D3: ({x} {x'} trans x T1 x' -> trans (E x) T2 (V x')))\n\t(D2: ttrans T2 T2')\n\t(D1: ttrans T1 T1'))\n     (ttrans/arr D2 D1)\n     (tof/suspend \n\t(tof/lam \n\t   ([y] [dy:tof y (tprod T1' (tnot T2'))] \n\t      twf/pi1 \n\t      ([y'][dy': tof y' T1']  \n\t\t twf/pi2 \n\t\t ([g][dg:tof g (tnot T2')] \n\t\t    (twf/let \n\t\t       ([x'] [dx':tof x' (tnot (tnot T1'))] \n\t\t\t  twf/app \n\t\t\t  dg \n\t\t\t  (DV x' dx'))\n\t\t       (tof/suspend dy'))) \n\t\t dy)\n\t      dy)))\n     <- ({x} {x'} {dx': tof x' (tnot (tnot T1'))}  \n\t   {dt: trans x T1 x'}\n\t   correct dt D1 dx' \n\t   -> correct' (D3 x x' dt) D2 (DV x' dx' : tof (V x') (tnot (tnot T2')))).\n\n\n%block transbind : some {T : tp} {T' : ttp} {DTT : ttrans T T'}\n                    block\n                    {x : term} \n                    {x' : tval} {dx' : tof x' (tnot (tnot T'))}\n                    {dt : trans x T x'}\n                    {thm : correct dt DTT dx'}.\n\n\n%worlds (transbind) (correct _ _ _) (correct' _ _ _).\n%total (D D') (correct D _ _) (correct' D' _ _)."
          },
          "sha1": "aez16nmsu3nkx4rxwgqa8vdj682r75z"
        }
      },
      {
        "title": "Computation and Deduction 2009/20090318",
        "ns": 0,
        "id": 2198,
        "revision": {
          "id": 5949,
          "timestamp": "2009-03-23T16:52:31Z",
          "contributor": {
            "username": "Crary",
            "id": 13
          },
          "comment": "Created page with '%{ Code from class, March 18. }%  ttp : type. %name ttp T.  tnum : ttp. tnot : ttp -> ttp. tprod : ttp -> ttp -> ttp.  texp : type. %name texp E. tval : type. %name tval V.  tlet...'",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 7253,
            "#text": "%{ Code from class, March 18. }%\n\nttp : type. %name ttp T.\n\ntnum : ttp.\ntnot : ttp -> ttp.\ntprod : ttp -> ttp -> ttp.\n\ntexp : type. %name texp E.\ntval : type. %name tval V.\n\ntlet : tval -> (tval -> texp) -> texp.\ntpi1 : tval -> (tval -> texp) -> texp.\ntpi2 : tval -> (tval -> texp) -> texp.\ntifz : tval -> texp -> (tval -> texp) -> texp.\ntapp : tval -> tval -> texp.\n\ntz : tval.\nts : tval -> tval.\ntpair : tval -> tval -> tval.\ntlam : ttp -> (tval -> texp) -> tval.\n\ntof : tval -> ttp -> type.\ntwf : texp -> type.\n\ntof/z : tof tz tnum.\n\ntof/s : tof (ts V) tnum\n <- tof V tnum.\n\ntof/pair : tof (tpair V1 V2) (tprod T1 T2)\n    <- tof V1 T1\n    <- tof V2 T2.\n\ntof/lam : tof (tlam T ([x] E x)) (tnot T)\n   <- ({x} tof x T -> twf (E x)).\n\ntwf/let : twf (tlet V ([x] E x))\n   <- tof V T\n   <- ({x} tof x T -> twf (E x)).\n\ntwf/pi1 : twf (tpi1 V ([x] E x))\n   <- tof V (tprod T1 T2)\n   <- ({x} tof x T1 -> twf (E x)).\n\ntwf/pi2 : twf (tpi2 V ([x] E x))\n   <- tof V (tprod T1 T2)\n   <- ({x} tof x T2 -> twf (E x)).\n\ntwf/ifz : twf (tifz V E0 ([x] E1 x))\n   <- tof V tnum\n   <- twf E0\n   <- ({x} tof x tnum -> twf (E1 x)).\n\ntwf/app : twf (tapp V1 V2)\n   <- tof V1 (tnot T)\n   <- tof V2 T.\n\nttrans : tp -> ttp -> type.\n\nttrans/num : ttrans num tnum.\n\nttrans/arr : ttrans (arr T1 T2) (tnot (tprod T1' (tnot T2')))\n      <- ttrans T1 T1'\n      <- ttrans T2 T2'.\n\nsuspend : ttp -> tval -> tval\n        = [t] [v] (tlam (tnot t) ([f] tapp f v)).\n\ntrans : term -> tp -> tval -> type.\n\ntrans/z : trans z num (suspend tnum tz).\n\ntrans/s : trans (s E) num (tlam (tnot tnum) ([f] tapp V (tlam tnum ([x] tapp f (ts x)))))\n   <- trans E num V.\n\ntrans/ifz : trans (ifz E E0 ([x] E1 x)) T\n     (tlam (tnot T')\n\t\t   ([f] tapp V (tlam tnum ([y] tifz y (tapp V0 f)\n\t\t\t\t\t\t\t\t     ([y'] tlet (tlam (tnot tnum) ([g] tapp g y'))\n\t\t\t\t\t\t\t\t\t       ([x'] tapp (V1 x') f))))))\n     <- ttrans T T'\n     <- trans E num V\n     <- trans E0 T V0\n     <- ({x} {x'} trans x num x' -> trans (E1 x) T (V1 x')).\n\ntrans/lam : trans (lam T1 ([x] E x)) (arr T1 T2)\n             (suspend (tnot (tprod T1' (tnot T2')))\n\t\t\t\t\t                (tlam (tprod T1' (tnot T2'))\n\t\t\t\t\t\t\t\t\t\t         ([y] tpi1 y\n\t\t\t\t\t\t\t\t\t\t\t\t    ([y'] (tpi2 y\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   ([g] tlet (suspend T1' y')\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t      ([x'] tapp (V x') g)))))))\n     <- ttrans T1 T1'\n     <- ttrans T2 T2'\n     <- ({x} {x'} trans x T1 x' -> trans (E x) T2 (V x')).\n\ntrans/app : trans (app E1 E2) T2\n             (tlam (tnot T2') \n                ([f] tapp V1\n                   (tlam (tnot (tprod T1' (tnot T2')))\n                      ([x1] tapp V2 (tlam T1' ([x2] tapp x1 (tpair x2 f)))))))\n             <- ttrans T1 T1'\n             <- ttrans T2 T2'\n             <- trans E1 (arr T1 T2) V1\n             <- trans E2 T1 V2.\n\ntof/suspend : tof (suspend T V) (tnot (tnot T))\n               <- tof V T\n            = [D : tof V T] (tof/lam ([x] [d : tof x (tnot T)] (twf/app D d))).\n\nttp-eq : ttp -> ttp -> type.\n\nttp-eq/i : ttp-eq T T.\n\nttrans-fun : ttrans T T' -> ttrans T T'' -> ttp-eq T' T'' -> type.\n%mode ttrans-fun +D1 +D2 -D3.\n\n\n\n%worlds () (ttrans-fun _ _ _).\n%trustme %total D (ttrans-fun D _ _).\n\ntof-resp : ttp-eq T T' -> tof V T -> tof V T' -> type.\n%mode tof-resp +D1 +D2 -D3.\n\ntof-resp/i : tof-resp ttp-eq/i D D.\n\n%block tbind : some {T : ttp} block {x : tval} {d : tof x T}.\n%worlds (tbind) (tof-resp _ _ _).\n\n%total {} (tof-resp _ _ _).\n\nttp-resp : {T : ttp -> ttp} ttp-eq T1 T2 -> ttp-eq (T T1) (T T2) -> type.\n%mode ttp-resp +D1 +D2 -D3.\n\n- : ttp-resp T ttp-eq/i ttp-eq/i.\n\n%worlds () (ttp-resp _ _ _).\n%total {} (ttp-resp _ _ _).\n\ncorrect : trans E T V -> ttrans T T' -> tof V (tnot (tnot T')) -> type.\n%mode correct +D1 -D2 -D3.\n\ncorrect' : trans E T V -> ttrans T T' -> tof V (tnot (tnot T')) -> type.\n%mode correct' +D1 +D2 -D3.\n\n- : correct'\n\t (DtransE : trans E T V)\n\t (DtransT : ttrans T T')\n\t DofV'\n\t <- correct DtransE \n\t\t(DtransT' : ttrans T T'')\n\t\t(DofV : tof V (tnot (tnot T'')))\n\t <- ttrans-fun DtransT' DtransT (Deq : ttp-eq T'' T')\n\t <- ttp-resp ([t] (tnot (tnot t))) Deq (Deq' : ttp-eq (tnot (tnot T'')) (tnot (tnot T')))\n\t <- tof-resp Deq' DofV (DofV' : tof V (tnot (tnot T'))).\n\n- : correct trans/z ttrans/num (tof/suspend tof/z).\n\n- : correct \n     (trans/s \n\t  (D : trans E num V))\n     ttrans/num \n     (tof/lam \n\t  ([f] [df:tof f (tnot tnum)] \n\t      twf/app \n\t\t     (tof/lam ([x] [dx:tof x tnum] (twf/app (tof/s dx) df))) \n\t\t\t    D'))\n     <- correct' D ttrans/num (D': tof V (tnot (tnot tnum))).\n\n- : correct\n     (trans/ifz\n\t\t(DtransE1 : {x} {x'} trans x num x' -> trans (E1 x) T (V1 x'))\n\t\t(DtransE0 : trans E0 T V0)\n\t\t(DtransE : trans E num V)\n\t\t(DtransT : ttrans T T'))\n     DtransT\n     (tof/lam\n\t\t([f] [df:tof f (tnot T')]\n\t\t      twf/app\n\t\t      (tof/lam\n\t\t\t\t       ([x] [dx:tof x tnum]\n\t\t\t\t\t\t   twf/ifz\n\t\t\t\t\t\t   ([y'] [dy':tof y' tnum]\n\t\t\t\t\t\t\t      twf/let\n\t\t\t\t\t\t\t      ([x'] [dx':tof x' (tnot (tnot tnum))]\n\t\t\t\t\t\t\t\t\t        twf/app\n\t\t\t\t\t\t\t\t\t        df\n\t\t\t\t\t\t\t\t\t        (DofV1 x' dx'))\n\t\t\t\t\t\t\t      (tof/lam\n\t\t\t\t\t\t\t\t\t        ([g] [dg:tof g (tnot tnum)]\n\t\t\t\t\t\t\t\t\t\t\t     twf/app dy' dg)))\n\t\t\t\t\t\t   (twf/app df DofV0)\n\t\t\t\t\t\t   dx))\n\t\t      DofV))\n     <- correct' DtransE ttrans/num (DofV : tof V (tnot (tnot tnum)))\n     <- correct' DtransE0 DtransT (DofV0 : tof V0 (tnot (tnot T')))\n\t <- ({x} {x'} {dx' : tof x' (tnot (tnot tnum))}\n\t\t   {dt : trans x num x'}\n\t\t   correct dt ttrans/num dx'\n\t\t   -> correct' (DtransE1 x x' dt) DtransT (DofV1 x' dx' : tof (V1 x') (tnot (tnot T')))).\n\n- : correct \n     (trans/lam \n\t  (D3: ({x} {x'} trans x T1 x' -> trans (E x) T2 (V x')))\n\t  (D2: ttrans T2 T2')\n\t  (D1: ttrans T1 T1'))\n     (ttrans/arr D2 D1)\n     (tof/suspend \n\t  (tof/lam \n\t      ([y] [dy:tof y (tprod T1' (tnot T2'))] \n\t\t         twf/pi1 \n\t\t\t\t       ([y'][dy': tof y' T1']  \n\t\t\t\t\t\t twf/pi2 \n\t\t\t\t\t\t  ([g][dg:tof g (tnot T2')] \n\t\t\t\t\t\t       (twf/let \n\t\t\t\t\t\t\t\t       ([x'] [dx':tof x' (tnot (tnot T1'))] \n\t\t\t\t\t\t\t\t\t\t  twf/app \n\t\t\t\t\t\t\t\t\t\t    dg \n\t\t\t\t\t\t\t\t\t\t\t  (DV x' dx'))\n\t\t\t\t\t\t\t\t\t          (tof/suspend dy'))) \n\t\t\t\t\t\t   dy)\n\t\t\t\t\t         dy)))\n     <- ({x} {x'} {dx': tof x' (tnot (tnot T1'))}  \n\t\t\t    {dt: trans x T1 x'}\n\t\t\t\t   correct dt D1 dx' \n\t\t\t\t      -> correct' (D3 x x' dt) D2 (DV x' dx' : tof (V x') (tnot (tnot T2')))).\n\n- : correct\n     (trans/app\n\t\t(DtransE2 : trans E2 T1 V2)\n\t\t(DtransE1 : trans E1 (arr T1 T2) V1)\n\t\t(DtransT2 : ttrans T2 T2')\n\t\t(DtransT1 : ttrans T1 T1'))\n     DtransT2\n     (tof/lam\n\t\t([f] [df:tof f (tnot T2')]\n\t\t      twf/app\n\t\t      (tof/lam\n\t\t\t\t       ([x1] [dx1:tof x1 (tnot (tprod T1' (tnot T2')))]\n\t\t\t\t\t\t   twf/app\n\t\t\t\t\t\t   (tof/lam\n\t\t\t\t\t\t\t      ([x2] [dx2:tof x2 T1']\n\t\t\t\t\t\t\t\t\t        twf/app\n\t\t\t\t\t\t\t\t\t        (tof/pair df dx2)\n\t\t\t\t\t\t\t\t\t        dx1))\n\t\t\t\t\t\t   DofV2))\n\t\t      DofV1))\n     <- correct' DtransE1 (ttrans/arr DtransT2 DtransT1)\n\t\t(DofV1 : tof V1 (tnot (tnot (tnot (tprod T1' (tnot T2'))))))\n     <- correct' DtransE2 DtransT1\n\t\t(DofV2 : tof V2 (tnot (tnot T1'))).\n\n%block transbind : some {T : tp} {T' : ttp} {DTT : ttrans T T'}\n                    block\n                    {x : term} \n                    {x' : tval} {dx' : tof x' (tnot (tnot T'))}\n                    {dt : trans x T x'}\n                    {thm : correct dt DTT dx'}.\n\n\n%worlds (transbind) (correct _ _ _) (correct' _ _ _).\n%total (D D') (correct D _ _) (correct' D' _ _)."
          },
          "sha1": "7u7wgyj45dzuir8uobynf5002rg4ku2"
        }
      },
      {
        "title": "Computation and Deduction 2009/20090325",
        "ns": 0,
        "id": 2199,
        "revision": {
          "id": 5959,
          "timestamp": "2009-03-26T17:07:40Z",
          "contributor": {
            "username": "Crary",
            "id": 13
          },
          "comment": "Created page with '%{ Code from class, March 25. }%  tp : type.  tensor : tp -> tp -> tp. 1 : tp. with : tp -> tp -> tp. top : tp. plus : tp -> tp -> tp. 0 : tp.  exp : type.  tens : exp -> exp -> ...'",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 2386,
            "#text": "%{ Code from class, March 25. }%\n\ntp : type.\n\ntensor : tp -> tp -> tp.\n1 : tp.\nwith : tp -> tp -> tp.\ntop : tp.\nplus : tp -> tp -> tp.\n0 : tp.\n\nexp : type.\n\ntens : exp -> exp -> exp.\nlett : exp -> (exp -> exp -> exp) -> exp.\npair : exp -> exp -> exp.\npi1  : exp -> exp.\npi2  : exp -> exp.\nstar : exp.\nlets : exp -> exp -> exp.\nunit : exp.\nin1  : exp -> exp.\nin2  : exp -> exp.\ncase : exp -> (exp -> exp) -> (exp -> exp) -> exp.\nabort : exp -> exp.\n\nlinear : (exp -> exp) -> type.\n\nof : exp -> tp -> type.\n\n\nlinear/tens1 : linear ([x] tens (M x) N)\n\t<- linear ([x] M x).\n\nlinear/tens2 : linear ([x] tens M (N x))\n\t<- linear ([x] N x).\n\nof/tens : of (tens M N) (tensor A B)\n\t<- of M A\n\t<- of N B.\n\nlinear/lett1 : linear ([z] lett (M z) ([x] [y] N x y))\n\t<- linear ([x] M x).\n\nlinear/lett2 : linear ([z] lett M ([x] [y] N z x y))\n\t<- ({x} {y} linear ([z] N z x y)).\n\nof/lett : of (lett M ([x] [y] N x y))  C\n\t<- of M (tensor A B)\n\t<- ({x:exp} of x A -> {y:exp} of y B -> of (N x y) C)\n\t<- ({y:exp} linear ([x] N x y))\n\t<- ({x:exp} linear ([y] N x y)).\n\nlinear/pair : linear ([x] pair (M x) (N x))\n\t<- linear ([x] M x)\n\t<- linear ([x] N x).\n\nof/pair : of (pair M N) (with A B)\n\t<- of M A\n\t<- of N B.\n\nlinear/pi1 : linear ([x] pi1 (M x))\n\t<- linear ([x] M x).\n\nlinear/pi2 : linear ([x] pi2 (M x))\n\t<- linear ([x] M x).\n\nof/pi1 : of (pi1 M) A\n\t<- of M (with A B).\n\nof/pi2 : of (pi2 M) B\n\t<- of M (with A B).\n\nof/star : of star 1.\n\nlinear/lets1 : linear ([x] lets (M x) N)\n\t<- linear ([x] M x).\n\nlinear/lets2 : linear ([x] lets M (N x))\n\t<- linear ([x] N x).\n\nof/lets : of (lets M N) C\n\t<- of M 1\n\t<- of N C.\n\nlinear/unit : linear ([x] unit).\n\nof/unit : of unit top.\n\nlinear/in1 : linear ([x] in1 (M x))\n\t<- linear ([x] M x).\n\nlinear/in2 : linear ([x] in2 (M x))\n\t<- linear ([x] M x).\n\nof/in1 : of (in1 M) (plus A B)\n\t<- of M A.\n\nof/in2 : of (in2 M) (plus A B)\n\t<- of M B.\n\nlinear/case1 : linear ([z] case (M z) ([x] N x) ([x] O x))\n\t<- linear ([z] M z).\n\nlinear/case2 : linear ([z] case M ([x] N z x) ([x] O z x))\n\t<- ({x:exp} linear ([z] N z x))\n\t<- ({x:exp} linear ([z] O z x)).\n\nof/case : of (case M ([x] N x) ([x] O x)) C\n\t<- of M (plus A B)\n\t<- ({x} of x A -> of (N x) C)\n\t<- ({x} of x B -> of (O x) C)\n\t<- linear ([x] N x)\n\t<- linear ([x] O x).\n\nlinear/abort1 : linear ([x] abort (M x))\n\t<- linear ([x] M x).\n\nlinear/abort2 : linear ([x] abort M).\n\nof/abort : of (abort M) C\n\t<- of M 0."
          },
          "sha1": "md61zo6gg943sizuxs23li89uo287m3"
        }
      },
      {
        "title": "Computation and Deduction 2009/20090330",
        "ns": 0,
        "id": 2200,
        "revision": {
          "id": 5961,
          "timestamp": "2009-04-01T15:45:47Z",
          "contributor": {
            "username": "Crary",
            "id": 13
          },
          "comment": "Created page with '%{ Code from class, March 30. }%  tp : type.  tensor : tp -> tp -> tp. 1 : tp. with : tp -> tp -> tp. top : tp. plus : tp -> tp -> tp. 0 : tp. lolli : tp -> tp -> tp. ! : tp -> t...'",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 4569,
            "#text": "%{ Code from class, March 30. }%\n\ntp : type.\n\ntensor : tp -> tp -> tp.\n1 : tp.\nwith : tp -> tp -> tp.\ntop : tp.\nplus : tp -> tp -> tp.\n0 : tp.\nlolli : tp -> tp -> tp.\n! : tp -> tp.\n\nexp : type.\n\ntens : exp -> exp -> exp.\nlett : exp -> (exp -> exp -> exp) -> exp.\npair : exp -> exp -> exp.\npi1  : exp -> exp.\npi2  : exp -> exp.\nstar : exp.\nlets : exp -> exp -> exp.\nunit : exp.\nin1  : exp -> exp.\nin2  : exp -> exp.\ncase : exp -> (exp -> exp) -> (exp -> exp) -> exp.\nabort : exp -> exp.\nlam : tp -> (exp -> exp) -> exp.\napp : exp -> exp -> exp.\nbang : exp -> exp.\nletb : exp -> (exp -> exp) -> exp.\n\nlinear : (exp -> exp) -> type.\n\nof : exp -> tp -> type.\n\n\nlinear/tens1 : linear ([x] tens (M x) N)\n\t<- linear ([x] M x).\n\nlinear/tens2 : linear ([x] tens M (N x))\n\t<- linear ([x] N x).\n\nof/tens : of (tens M N) (tensor A B)\n\t<- of M A\n\t<- of N B.\n\nlinear/lett1 : linear ([z] lett (M z) ([x] [y] N x y))\n\t<- linear ([x] M x).\n\nlinear/lett2 : linear ([z] lett M ([x] [y] N z x y))\n\t<- ({x} {y} linear ([z] N z x y)).\n\nof/lett : of (lett M ([x] [y] N x y))  C\n\t<- of M (tensor A B)\n\t<- ({x:exp} of x A -> {y:exp} of y B -> of (N x y) C)\n\t<- ({y:exp} linear ([x] N x y))\n\t<- ({x:exp} linear ([y] N x y)).\n\nlinear/pair : linear ([x] pair (M x) (N x))\n\t<- linear ([x] M x)\n\t<- linear ([x] N x).\n\nof/pair : of (pair M N) (with A B)\n\t<- of M A\n\t<- of N B.\n\nlinear/pi1 : linear ([x] pi1 (M x))\n\t<- linear ([x] M x).\n\nlinear/pi2 : linear ([x] pi2 (M x))\n\t<- linear ([x] M x).\n\nof/pi1 : of (pi1 M) A\n\t<- of M (with A B).\n\nof/pi2 : of (pi2 M) B\n\t<- of M (with A B).\n\nof/star : of star 1.\n\nlinear/lets1 : linear ([x] lets (M x) N)\n\t<- linear ([x] M x).\n\nlinear/lets2 : linear ([x] lets M (N x))\n\t<- linear ([x] N x).\n\nof/lets : of (lets M N) C\n\t<- of M 1\n\t<- of N C.\n\nlinear/unit : linear ([x] unit).\n\nof/unit : of unit top.\n\nlinear/in1 : linear ([x] in1 (M x))\n\t<- linear ([x] M x).\n\nlinear/in2 : linear ([x] in2 (M x))\n\t<- linear ([x] M x).\n\nof/in1 : of (in1 M) (plus A B)\n\t<- of M A.\n\nof/in2 : of (in2 M) (plus A B)\n\t<- of M B.\n\nlinear/case1 : linear ([z] case (M z) ([x] N x) ([x] O x))\n\t<- linear ([z] M z).\n\nlinear/case2 : linear ([z] case M ([x] N z x) ([x] O z x))\n\t<- ({x:exp} linear ([z] N z x))\n\t<- ({x:exp} linear ([z] O z x)).\n\nof/case : of (case M ([x] N x) ([x] O x)) C\n\t<- of M (plus A B)\n\t<- ({x} of x A -> of (N x) C)\n\t<- ({x} of x B -> of (O x) C)\n\t<- linear ([x] N x)\n\t<- linear ([x] O x).\n\nlinear/abort1 : linear ([x] abort (M x))\n\t<- linear ([x] M x).\n\nlinear/abort2 : linear ([x] abort M).\n\nof/abort : of (abort M) C\n\t<- of M 0.\n\nlinear/lam : linear ([x] (lam A ([y] (M x y))))\n\t      <- ({y:exp} linear ([x] (M x y))).\n\nof/lam : of (lam A ([x] M x)) (lolli A B)\n\t  <- ({x} (of x A) -> of (M x) B)\n\t  <- linear ([x] M x).\n\nlinear/app1 : linear ([x] (app (M x) N))\n\t       <- linear ([x] M x).\n\nlinear/app2 : linear ([x] (app M (N x)))\n\t       <- linear ([x] N x).\n\nof/app : of (app M N) B\n\t  <- of M (lolli A B)\n\t  <- of N A.\n\nof/bang : of (bang M) (! A)\n\t   <- of M A.\n\nlinear/letb1 : linear ([x] (letb (M x) ([y] (N y))))\n\t\t<- linear ([x] M x).\n\nlinear/letb2 : linear ([x] (letb M ([y] N x y)))\n\t\t<- ({y:exp} linear ([x] N x y)).\n\nof/letb : of (letb M ([x] N x)) C\n\t   <- of M (! A)\n\t   <- ({x:exp} (of x A) -> of (N x) C).\n\nreduce : exp -> exp -> type.\n\nreduce/lam : reduce (lam A ([x] M x)) (lam A ([x] N x))\n\t      <- ({x} reduce (M x) (N x)).\n\nreduce/app1 : reduce (app M N) (app M' N)\n\t       <- reduce M M'.\n\nreduce/app2 : reduce (app M N) (app M N')\n\t       <- reduce N N'.\n\nreduce/beta : reduce (app (lam A ([x] M x)) N) (M N).\n\nsrl : ({x} (of x A) -> of (M x) B) -> linear ([x] M x) -> ({x} reduce (M x) (M' x)) -> linear ([x] M' x) -> type.\n\n\nsr : of M A -> reduce M M' -> of M' A -> type.\n%mode sr +D1 +D2 -D3.\n\n- : sr\n     (of/app (DofN : of N A) (DofM : of M (lolli A B)))\n     (reduce/app1 (Dreduce : reduce M M'))\n     (of/app DofN DofM')\n     <- sr DofM Dreduce (DofM' : of M' (lolli A B)).\n\n- : sr\n     (of/app (DofN : of N A) (DofM : of M (lolli A B)))\n     (reduce/app2 (Dreduce : reduce N N'))\n     (of/app DofN' DofM)\n     <- sr DofN Dreduce (DofN' : of N' A).\n\n- : sr \n     (of/app (DofN : of N A) (of/lam _ (DofM : {x} (of x A) -> of (M x) B)))\n     reduce/beta\n     (DofM N DofN).\n\n- : sr\n     (of/lam\n\t(Dlinear : linear ([x] M x))\n\t(DofM : {x} (of x A) -> of (M x) B))\n     (reduce/lam (Dreduce : {x} reduce (M x) (N x)))\n     (of/lam\n\t_\n\tDofN)\n     <- ({x} {dx: of x A}\n\t   sr (DofM x dx) (Dreduce x) (DofN x dx : of (N x) B)).\n\n%block bind : some {A:tp} block {x:exp} {dx : of x A}.\n%worlds (bind) (sr _ _ _).\n%total D1 (sr _ D1 _)."
          },
          "sha1": "jf6mdhfa2123o388zsplewydvqkmbr4"
        }
      },
      {
        "title": "Computation and Deduction 2009/20090401",
        "ns": 0,
        "id": 2201,
        "revision": {
          "id": 5963,
          "timestamp": "2009-04-01T19:38:34Z",
          "contributor": {
            "username": "Crary",
            "id": 13
          },
          "comment": "Created page with '%{ Code from class, April 1. }%  tp : type.  %name tp A.  tensor : tp -> tp -> tp. 1 : tp. with : tp -> tp -> tp. top : tp. plus : tp -> tp -> tp. 0 : tp. lolli : tp -> tp -> tp....'",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 5785,
            "#text": "%{ Code from class, April 1. }%\n\ntp : type.  %name tp A.\n\ntensor : tp -> tp -> tp.\n1 : tp.\nwith : tp -> tp -> tp.\ntop : tp.\nplus : tp -> tp -> tp.\n0 : tp.\nlolli : tp -> tp -> tp.\n! : tp -> tp.\n\nexp : type.  %name exp M x.\n\ntens : exp -> exp -> exp.\nlett : exp -> (exp -> exp -> exp) -> exp.\npair : exp -> exp -> exp.\npi1  : exp -> exp.\npi2  : exp -> exp.\nstar : exp.\nlets : exp -> exp -> exp.\nunit : exp.\nin1  : exp -> exp.\nin2  : exp -> exp.\ncase : exp -> (exp -> exp) -> (exp -> exp) -> exp.\nabort : exp -> exp.\nlam : tp -> (exp -> exp) -> exp.\napp : exp -> exp -> exp.\nbang : exp -> exp.\nletb : exp -> (exp -> exp) -> exp.\n\nlinear : (exp -> exp) -> type.\nof : exp -> tp -> type.\n\nlinear/tens1 : linear ([x] tens (M x) N)\n\t\t<- linear ([x] M x).\n\nlinear/tens2 : linear ([x] tens M (N x))\n\t\t<- linear ([x] N x).\n\nof/tens : of (tens M N) (tensor A B)\n\t   <- of M A\n\t   <- of N B.\n\nlinear/lett1 : linear ([z] lett (M z) ([x] [y] N x y))\n\t\t<- linear ([x] M x).\n\nlinear/lett2 : linear ([z] lett M ([x] [y] N z x y))\n\t\t<- ({x} {y} linear ([z] N z x y)).\n\nof/lett : of (lett M ([x] [y] N x y)) C\n\t   <- of M (tensor A B)\n\t   <- ({x:exp} of x A -> {y:exp} of y B -> of (N x y) C)\n\t   <- ({y:exp} linear ([x] N x y))\n\t   <- ({x:exp} linear ([y] N x y)).\n\nlinear/pair : linear ([x] pair (M x) (N x))\n\t       <- linear ([x] M x)\n\t       <- linear ([x] N x).\n\nof/pair : of (pair M N) (with A B)\n\t   <- of M A\n\t   <- of N B.\n\nlinear/pi1 : linear ([x] pi1 (M x))\n\t      <- linear ([x] M x).\n\nlinear/pi2 : linear ([x] pi2 (M x))\n\t      <- linear ([x] M x).\n\nof/pi1 : of (pi1 M) A\n\t  <- of M (with A B).\n\nof/pi2 : of (pi1 M) B\n\t  <- of M (with A B).\n\nof/star : of star 1.\n\nlinear/lets1 : linear ([x] lets (M x) N)\n\t\t<- linear ([x] M x).\n\nlinear/lets2 : linear ([x] lets M (N x))\n\t\t<- linear ([x] N x).\n\nof/lets : of (lets M N) C\n\t   <- of M 1\n\t   <- of N C.\n\nlinear/unit : linear ([x] unit).\n\nof/unit : of unit top.\n\nlinear/in1 : linear ([x] in1 (M x))\n\t      <- linear ([x] M x).\n\nlinear/in2 : linear ([x] in2 (M x))\n\t      <- linear ([x] M x).\n\nof/in1 : of (in1 M) (plus A B)\n\t  <- of M A.\n\nof/in2 : of (in2 M) (plus A B)\n\t  <- of M B.\n\nlinear/case1 : linear ([z] case (M z) ([x] N x) ([x] O x))\n\t\t<- linear ([z] M z).\n\nlinear/case2 : linear ([z] case M ([x] N z x) ([x] O z x))\n\t\t<- ({x:exp} linear ([z] N z x))\n\t\t<- ({x:exp} linear ([z] O z x)).\n\nof/case : of (case M ([x] N x) ([x] O x)) C\n\t   <- of M (plus A B)\n\t   <- ({x} of x A -> of (N x) C)\n\t   <- ({x} of x B -> of (O x)C)\n\t   <- linear ([x] N x)\n\t   <- linear ([x] O x).\n\nlinear/abort1 : linear ([x] abort (M x))\n\t\t <- linear ([x] M x).\n\nlinear/abort2 : linear ([x] abort M).\n\nof/abort : of (abort M) C\n\t    <- of M O.\n\nlinear/lam : linear ([x] (lam A ([y] (M x y))))\n\t  <- {y:exp} linear ([x] M x y).\n\nof/lam : of (lam A ([x] M x)) (lolli A B)\n\t  <- ({x} (of x A) -> of (M x) B)\n\t  <- linear ([x] M x).\n\nlinear/app1 : linear ([x] (app (M x) N))\n\t       <- linear ([x] M x).\n\nlinear/app2 : linear ([x] (app M (N x)))\n\t       <- linear ([x] N x).\n\nof/app : of (app M N) B\n\t  <- of M (lolli A B)\n\t  <- of N A.\n\nof/bang : of (bang M) (! A)\n\t   <- of M A.\n\nlinear/letb1 : linear ([x] (letb (M x) ([y] (N y))))\n\t\t<- linear ([x] M x).\n\nlinear/letb2 : linear ([x] (letb M ([y] N x y)))\n\t\t<- ({y} linear ([x] N x y)).\n\nof/letb : of (letb M ([x] N x)) C\n\t   <- of M (! A)\n\t   <- ({x} (of x A) -> of (N x) C).\n\n\nreduce : exp -> exp -> type.\n\nreduce/lam : reduce (lam A ([x] M x)) (lam A ([x] N x))\n\t      <- ({x} reduce (M x) (N x)).\n\nreduce/app1 : reduce (app M N) (app M' N)\n\t       <- reduce M M'.\n\nreduce/app2 : reduce (app M N) (app M N')\n\t       <- reduce N N'.\n\nreduce/beta : reduce (app (lam A ([x] M x)) N) (M N).\n\n%block block : block {x:exp}.\n%block bind : some {A:tp} block {x:exp} {d : of x A}.\n\nexp-eq : exp -> exp -> type.\nexp-eq/i : exp-eq M M.\n\nreduce-closed : ({x:exp} reduce M (N x)) -> ({x:exp} exp-eq (N x) N') -> type.\n%mode reduce-closed +D -D'.\n\n%worlds (block) (reduce-closed _ _).\n%trustme %total D (reduce-closed D _).\n\nsrl : ({x} (of x A) -> of (M x) B) -> linear ([x] M x) -> ({x} reduce (M x) (M' x)) -> linear ([x] M' x) -> type.\n%mode srl +D1 +D2 +D3 -D4.\n\n- : srl\n     ([x] [d:of x A] of/lam _ (Dof x d : {y} of y B -> of (M x y) C))\n     (linear/lam (Dlinear : {y} linear ([x] M x y)))\n     ([x] reduce/lam (Dreduce x : {y} reduce (M x y) (N x y)))\n     (linear/lam ([y] Dlinear' y))\n     <- ({y} {dy:of y B} srl ([x] [dx:of x A] Dof x dx y dy) (Dlinear y) ([x] Dreduce x y)\n\t   (Dlinear' y : linear ([x] N x y))).\n\n- : srl\n     ([x] [d:of x A] of/app _ (Dof x d : of (M x) (lolli B C)))\n     (linear/app1 (Dlinear : linear ([x] M x)))\n     ([x] reduce/app1 (Dreduce x : reduce (M x) (M' x)))\n     (linear/app1 Dlinear')\n   <- srl Dof Dlinear Dreduce (Dlinear' : linear ([x] M' x)).\n\n- : srl\n     _\n     (linear/app2 (Dlinear : linear ([x] N x)))\n     ([x] reduce/app1 (Dreduce x : reduce M (M' x)))\n     _.\n\n%worlds (bind) (srl _ _ _ _).\n%total D (srl _ _ D _).\n\nsr : of M A -> reduce M M' -> of M' A -> type.\n%mode sr +D1 +D2 -D3.\n\n- : sr\n     (of/app (DofN : of N A) (DofM : of M (lolli A B)))\n     (reduce/app1 (Dreduce : reduce M M'))\n     (of/app DofN DofM')\n     <- sr DofM Dreduce (DofM' : of M' (lolli A B)).\n\n- : sr\n     (of/app (DofN : of N A) (DofM : of M (lolli A B)))\n     (reduce/app2 (Dreduce : reduce N N'))\n     (of/app DofN' DofM)\n     <- sr DofN Dreduce (DofN' : of N' A).\n\n- : sr\n     (of/app (DofN : of N A) (of/lam _ (DofM : {x} (of x A) -> of (M x) B)))\n     reduce/beta\n     (DofM N DofN).\n\n- : sr\n     (of/lam\n\t(Dlinear : linear ([x] M x))\n\t(DofM : {x} (of x A) -> of (M x) B))\n     (reduce/lam (Dreduce : {x} reduce (M x) (N x)))\n     (of/lam\n\t_\n\tDofN)\n     <- ({x} {dx:of x A}\n\t   sr (DofM x dx) (Dreduce x) (DofN x dx : of (N x) B)).\n\n%worlds (bind) (sr _ _ _).\n%total D1 (sr _ D1 _)."
          },
          "sha1": "9e5s86azmhfndxpd99xtm5vr1frlytz"
        }
      },
      {
        "title": "Computation and Deduction 2009/20090406",
        "ns": 0,
        "id": 2202,
        "revision": {
          "id": 5965,
          "timestamp": "2009-04-07T18:33:14Z",
          "contributor": {
            "username": "Crary",
            "id": 13
          },
          "comment": "Created page with '%{ Code from class, April 6. }%  tp : type.  %name tp A.  tensor : tp -> tp -> tp. 1 : tp. with : tp -> tp -> tp. top : tp. plus : tp -> tp -> tp. 0 : tp. lolli : tp -> tp -> tp....'",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 7370,
            "#text": "%{ Code from class, April 6. }%\n\ntp : type.  %name tp A.\n\ntensor : tp -> tp -> tp.\n1 : tp.\nwith : tp -> tp -> tp.\ntop : tp.\nplus : tp -> tp -> tp.\n0 : tp.\nlolli : tp -> tp -> tp.\n! : tp -> tp.\n\nexp : type.  %name exp M x.\n\ntens : exp -> exp -> exp.\nlett : exp -> (exp -> exp -> exp) -> exp.\npair : exp -> exp -> exp.\npi1  : exp -> exp.\npi2  : exp -> exp.\nstar : exp.\nlets : exp -> exp -> exp.\nunit : exp.\nin1  : exp -> exp.\nin2  : exp -> exp.\ncase : exp -> (exp -> exp) -> (exp -> exp) -> exp.\nabort : exp -> exp.\nlam : tp -> (exp -> exp) -> exp.\napp : exp -> exp -> exp.\nbang : exp -> exp.\nletb : exp -> (exp -> exp) -> exp.\n\nlinear : (exp -> exp) -> type.\nof : exp -> tp -> type.\n\nlinear/var : linear ([x] x).\n\nlinear/tens1 : linear ([x] tens (M x) N)\n\t\t<- linear ([x] M x).\n\nlinear/tens2 : linear ([x] tens M (N x))\n\t\t<- linear ([x] N x).\n\nof/tens : of (tens M N) (tensor A B)\n\t   <- of M A\n\t   <- of N B.\n\nlinear/lett1 : linear ([z] lett (M z) ([x] [y] N x y))\n\t\t<- linear ([x] M x).\n\nlinear/lett2 : linear ([z] lett M ([x] [y] N z x y))\n\t\t<- ({x} {y} linear ([z] N z x y)).\n\nof/lett : of (lett M ([x] [y] N x y)) C\n\t   <- of M (tensor A B)\n\t   <- ({x:exp} of x A -> {y:exp} of y B -> of (N x y) C)\n\t   <- ({y:exp} linear ([x] N x y))\n\t   <- ({x:exp} linear ([y] N x y)).\n\nlinear/pair : linear ([x] pair (M x) (N x))\n\t       <- linear ([x] M x)\n\t       <- linear ([x] N x).\n\nof/pair : of (pair M N) (with A B)\n\t   <- of M A\n\t   <- of N B.\n\nlinear/pi1 : linear ([x] pi1 (M x))\n\t      <- linear ([x] M x).\n\nlinear/pi2 : linear ([x] pi2 (M x))\n\t      <- linear ([x] M x).\n\nof/pi1 : of (pi1 M) A\n\t  <- of M (with A B).\n\nof/pi2 : of (pi1 M) B\n\t  <- of M (with A B).\n\nof/star : of star 1.\n\nlinear/lets1 : linear ([x] lets (M x) N)\n\t\t<- linear ([x] M x).\n\nlinear/lets2 : linear ([x] lets M (N x))\n\t\t<- linear ([x] N x).\n\nof/lets : of (lets M N) C\n\t   <- of M 1\n\t   <- of N C.\n\nlinear/unit : linear ([x] unit).\n\nof/unit : of unit top.\n\nlinear/in1 : linear ([x] in1 (M x))\n\t      <- linear ([x] M x).\n\nlinear/in2 : linear ([x] in2 (M x))\n\t      <- linear ([x] M x).\n\nof/in1 : of (in1 M) (plus A B)\n\t  <- of M A.\n\nof/in2 : of (in2 M) (plus A B)\n\t  <- of M B.\n\nlinear/case1 : linear ([z] case (M z) ([x] N x) ([x] O x))\n\t\t<- linear ([z] M z).\n\nlinear/case2 : linear ([z] case M ([x] N z x) ([x] O z x))\n\t\t<- ({x:exp} linear ([z] N z x))\n\t\t<- ({x:exp} linear ([z] O z x)).\n\nof/case : of (case M ([x] N x) ([x] O x)) C\n\t   <- of M (plus A B)\n\t   <- ({x} of x A -> of (N x) C)\n\t   <- ({x} of x B -> of (O x)C)\n\t   <- linear ([x] N x)\n\t   <- linear ([x] O x).\n\nlinear/abort1 : linear ([x] abort (M x))\n\t\t <- linear ([x] M x).\n\nlinear/abort2 : linear ([x] abort M).\n\nof/abort : of (abort M) C\n\t    <- of M O.\n\nlinear/lam : linear ([x] (lam A ([y] (M x y))))\n\t  <- {y:exp} linear ([x] M x y).\n\nof/lam : of (lam A ([x] M x)) (lolli A B)\n\t  <- ({x} (of x A) -> of (M x) B)\n\t  <- linear ([x] M x).\n\nlinear/app1 : linear ([x] (app (M x) N))\n\t       <- linear ([x] M x).\n\nlinear/app2 : linear ([x] (app M (N x)))\n\t       <- linear ([x] N x).\n\nof/app : of (app M N) B\n\t  <- of M (lolli A B)\n\t  <- of N A.\n\nof/bang : of (bang M) (! A)\n\t   <- of M A.\n\nlinear/letb1 : linear ([x] (letb (M x) ([y] (N y))))\n\t\t<- linear ([x] M x).\n\nlinear/letb2 : linear ([x] (letb M ([y] N x y)))\n\t\t<- ({y} linear ([x] N x y)).\n\nof/letb : of (letb M ([x] N x)) C\n\t   <- of M (! A)\n\t   <- ({x} (of x A) -> of (N x) C).\n\n\nreduce : exp -> exp -> type.\n\nreduce/lam : reduce (lam A ([x] M x)) (lam A ([x] N x))\n\t      <- ({x} reduce (M x) (N x)).\n\nreduce/app1 : reduce (app M N) (app M' N)\n\t       <- reduce M M'.\n\nreduce/app2 : reduce (app M N) (app M N')\n\t       <- reduce N N'.\n\nreduce/beta : reduce (app (lam A ([x] M x)) N) (M N).\n\n%block block : block {x:exp}.\n%block bind : some {A:tp} block {x:exp} {d : of x A}.\n\nexp-eq : exp -> exp -> type.\nexp-eq/i : exp-eq M M.\n\nexp-compat: {M : exp -> exp} exp-eq N N' -> exp-eq (M N) (M N') -> type.\n%mode exp-compat +I +I1 -O.\n \n- : exp-compat M _ exp-eq/i.\n\n%worlds (block) (exp-compat _ _ _).\n%total {} (exp-compat _ _ _). \n\nlinear-resp: ({x:exp} exp-eq (M x) (N x) ) -> linear M -> linear N -> type.\n%mode linear-resp +I +I2 -O.\n\n-: linear-resp _ D D.\n  \n%worlds (block) (linear-resp _ _ _).\n%total {} (linear-resp _ _ _). \n\nreduce-closed : ({x:exp} reduce M (N x)) -> ({x:exp} exp-eq N' (N x) ) -> type.\n%mode reduce-closed +D -D'.\n\n%worlds (block) (reduce-closed _ _).\n%trustme %total D (reduce-closed D _).\n\nlinear-compose: linear ([x] M x) -> linear ([y] N y) -> linear ([y] M (N y)) -> type.\n%mode linear-compose +I +I1 -O.\n\n-: linear-compose linear/var D D.\n\n-: linear-compose linear/unit _ linear/unit.\n\n-: linear-compose (linear/app1 (D1 :linear ([x] M1 x)) ) (D2:linear ([y] N y)) \n    (linear/app1 D)\n    <- linear-compose D1 D2 (D: linear ([y] M1 (N y))).\n\n%worlds (block) (linear-compose _ _ _).\n%total (R) (linear-compose R _ _).\n\n\nsrl : ({x} (of x A) -> of (M x) B) -> linear ([x] M x) -> ({x} reduce (M x) (M' x)) -> linear ([x] M' x) -> type.\n%mode srl +D1 +D2 +D3 -D4.\n\n- : srl\n     ([x] [d:of x A] of/lam (DDD x) (Dof x d : {y} of y B -> of (M x y) C))\n     (linear/lam (Dlinear : {y} linear ([x] M x y)))\n     ([x] reduce/lam (Dreduce x : {y} reduce (M x y) (N x y)))\n     (linear/lam ([y] Dlinear' y))\n     <- ({y} {dy:of y B} srl ([x] [dx:of x A] Dof x dx y dy) (Dlinear y) ([x] Dreduce x y)\n\t   (Dlinear' y : linear ([x] N x y))).\n\n- : srl\n     ([x] [d:of x A] of/app _ (Dof x d : of (M x) (lolli B C)))\n     (linear/app1 (Dlinear : linear ([x] M x)))\n     ([x] reduce/app1 (Dreduce x : reduce (M x) (M' x)))\n     (linear/app1 Dlinear')\n   <- srl Dof Dlinear Dreduce (Dlinear' : linear ([x] M' x)).\n\n- : srl\n     _\n     (linear/app2 (Dlinear : linear ([x] N x)))\n     ([x] reduce/app1 (Dreduce x : reduce M (M' x)))\n     Dlinear'\n     <- reduce-closed Dreduce (Deq: {x} exp-eq  M'' (M' x)  )\n     <- ({x} exp-compat ([z] app z (N x)) (Deq x) (Deq' x : exp-eq (app M'' (N x) ) (app (M' x) (N x))))\n     <- linear-resp Deq' (linear/app2 Dlinear) (Dlinear' : linear ([x] app (M' x) (N x))).\n\n- : srl \n     _\n     (linear/app1 (linear/lam (Dlinear:{y} linear ([x] M x y))))\n     ([x] reduce/beta)\n     (Dlinear _).\n\n-: srl\n    ([x][d:of x A] of/app _ (of/lam (Dlinear' x : linear ([y] M y)) _ ))\n    (linear/app2 (Dlinear : linear ([x] N x) ))\n    ([x] reduce/beta)\n    Dlinear''\n    <- linear-compose (Dlinear' unit) Dlinear (Dlinear'' : linear ([x] M (N x))).\n\n%worlds (bind) (srl _ _ _ _).\n%trustme %total D (srl _ _ D _).\n\nsr : of M A -> reduce M M' -> of M' A -> type.\n%mode sr +D1 +D2 -D3.\n\n- : sr\n     (of/app (DofN : of N A) (DofM : of M (lolli A B)))\n     (reduce/app1 (Dreduce : reduce M M'))\n     (of/app DofN DofM')\n     <- sr DofM Dreduce (DofM' : of M' (lolli A B)).\n\n- : sr\n     (of/app (DofN : of N A) (DofM : of M (lolli A B)))\n     (reduce/app2 (Dreduce : reduce N N'))\n     (of/app DofN' DofM)\n     <- sr DofN Dreduce (DofN' : of N' A).\n\n- : sr\n     (of/app (DofN : of N A) (of/lam _ (DofM : {x} (of x A) -> of (M x) B)))\n     reduce/beta\n     (DofM N DofN).\n\n- : sr\n     (of/lam\n\t(Dlinear : linear ([x] M x))\n\t(DofM : {x} (of x A) -> of (M x) B))\n     (reduce/lam (Dreduce : {x} reduce (M x) (N x)))\n     (of/lam\n\tDlinear'\n\tDofN)\n     <- ({x} {dx:of x A}\n\t   sr (DofM x dx) (Dreduce x) (DofN x dx : of (N x) B))\n     <- srl DofM Dlinear Dreduce (Dlinear': linear ([x] N x)).\n\n%worlds (bind) (sr _ _ _).\n%total D1 (sr _ D1 _)."
          },
          "sha1": "9qo9tr32oc3s8lhek23bkjc4pr5bumz"
        }
      },
      {
        "title": "Computation and Deduction 2009/20090408",
        "ns": 0,
        "id": 2203,
        "revision": {
          "id": 5967,
          "timestamp": "2009-04-11T20:10:51Z",
          "contributor": {
            "username": "Crary",
            "id": 13
          },
          "comment": "Created page with '%{ Code from class, April 8. }%  tp : type.  %name tp A.  tensor : tp -> tp -> tp. 1 : tp. with : tp -> tp -> tp. top : tp. plus : tp -> tp -> tp. 0 : tp. lolli : tp -> tp -> tp....'",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 11393,
            "#text": "%{ Code from class, April 8. }%\n\ntp : type.  %name tp A.\n\ntensor : tp -> tp -> tp.\n1 : tp.\nwith : tp -> tp -> tp.\ntop : tp.\nplus : tp -> tp -> tp.\n0 : tp.\nlolli : tp -> tp -> tp.\n! : tp -> tp.\n\nexp : type.  %name exp M x.\n\ntens : exp -> exp -> exp.\nlett : exp -> (exp -> exp -> exp) -> exp.\npair : exp -> exp -> exp.\npi1  : exp -> exp.\npi2  : exp -> exp.\nstar : exp.\nlets : exp -> exp -> exp.\nunit : exp.\nin1  : exp -> exp.\nin2  : exp -> exp.\ncase : exp -> (exp -> exp) -> (exp -> exp) -> exp.\nabort : exp -> exp.\nlam : tp -> (exp -> exp) -> exp.\napp : exp -> exp -> exp.\nbang : exp -> exp.\nletb : exp -> (exp -> exp) -> exp.\n\nlinear : (exp -> exp) -> type.\nof : exp -> tp -> type.\n\nlinear/var : linear ([x] x).\n\nlinear/tens1 : linear ([x] tens (M x) N)\n\t\t<- linear ([x] M x).\n\nlinear/tens2 : linear ([x] tens M (N x))\n\t\t<- linear ([x] N x).\n\nof/tens : of (tens M N) (tensor A B)\n\t   <- of M A\n\t   <- of N B.\n\nlinear/lett1 : linear ([z] lett (M z) ([x] [y] N x y))\n\t\t<- linear ([x] M x).\n\nlinear/lett2 : linear ([z] lett M ([x] [y] N z x y))\n\t\t<- ({x} {y} linear ([z] N z x y)).\n\nof/lett : of (lett M ([x] [y] N x y)) C\n\t   <- of M (tensor A B)\n\t   <- ({x:exp} of x A -> {y:exp} of y B -> of (N x y) C)\n\t   <- ({y:exp} linear ([x] N x y))\n\t   <- ({x:exp} linear ([y] N x y)).\n\nlinear/pair : linear ([x] pair (M x) (N x))\n\t       <- linear ([x] M x)\n\t       <- linear ([x] N x).\n\nof/pair : of (pair M N) (with A B)\n\t   <- of M A\n\t   <- of N B.\n\nlinear/pi1 : linear ([x] pi1 (M x))\n\t      <- linear ([x] M x).\n\nlinear/pi2 : linear ([x] pi2 (M x))\n\t      <- linear ([x] M x).\n\nof/pi1 : of (pi1 M) A\n\t  <- of M (with A B).\n\nof/pi2 : of (pi1 M) B\n\t  <- of M (with A B).\n\nof/star : of star 1.\n\nlinear/lets1 : linear ([x] lets (M x) N)\n\t\t<- linear ([x] M x).\n\nlinear/lets2 : linear ([x] lets M (N x))\n\t\t<- linear ([x] N x).\n\nof/lets : of (lets M N) C\n\t   <- of M 1\n\t   <- of N C.\n\nlinear/unit : linear ([x] unit).\n\nof/unit : of unit top.\n\nlinear/in1 : linear ([x] in1 (M x))\n\t      <- linear ([x] M x).\n\nlinear/in2 : linear ([x] in2 (M x))\n\t      <- linear ([x] M x).\n\nof/in1 : of (in1 M) (plus A B)\n\t  <- of M A.\n\nof/in2 : of (in2 M) (plus A B)\n\t  <- of M B.\n\nlinear/case1 : linear ([z] case (M z) ([x] N x) ([x] O x))\n\t\t<- linear ([z] M z).\n\nlinear/case2 : linear ([z] case M ([x] N z x) ([x] O z x))\n\t\t<- ({x:exp} linear ([z] N z x))\n\t\t<- ({x:exp} linear ([z] O z x)).\n\nof/case : of (case M ([x] N x) ([x] O x)) C\n\t   <- of M (plus A B)\n\t   <- ({x} of x A -> of (N x) C)\n\t   <- ({x} of x B -> of (O x)C)\n\t   <- linear ([x] N x)\n\t   <- linear ([x] O x).\n\nlinear/abort1 : linear ([x] abort (M x))\n\t\t <- linear ([x] M x).\n\nlinear/abort2 : linear ([x] abort M).\n\nof/abort : of (abort M) C\n\t    <- of M O.\n\nlinear/lam : linear ([x] (lam A ([y] (M x y))))\n\t  <- {y:exp} linear ([x] M x y).\n\nof/lam : of (lam A ([x] M x)) (lolli A B)\n\t  <- ({x} (of x A) -> of (M x) B)\n\t  <- linear ([x] M x).\n\nlinear/app1 : linear ([x] (app (M x) N))\n\t       <- linear ([x] M x).\n\nlinear/app2 : linear ([x] (app M (N x)))\n\t       <- linear ([x] N x).\n\nof/app : of (app M N) B\n\t  <- of M (lolli A B)\n\t  <- of N A.\n\nof/bang : of (bang M) (! A)\n\t   <- of M A.\n\nlinear/letb1 : linear ([x] (letb (M x) ([y] (N y))))\n\t\t<- linear ([x] M x).\n\nlinear/letb2 : linear ([x] (letb M ([y] N x y)))\n\t\t<- ({y} linear ([x] N x y)).\n\nof/letb : of (letb M ([x] N x)) C\n\t   <- of M (! A)\n\t   <- ({x} (of x A) -> of (N x) C).\n\n\nreduce : exp -> exp -> type.\n\nreduce/lam : reduce (lam A ([x] M x)) (lam A ([x] N x))\n\t      <- ({x} reduce (M x) (N x)).\n\nreduce/app1 : reduce (app M N) (app M' N)\n\t       <- reduce M M'.\n\nreduce/app2 : reduce (app M N) (app M N')\n\t       <- reduce N N'.\n\nreduce/beta : reduce (app (lam A ([x] M x)) N) (M N).\n\n%block block : block {x:exp}.\n%block bind : some {A:tp} block {x:exp} {d : of x A}.\n\nexp-eq : exp -> exp -> type.\nexp-eq/i : exp-eq M M.\n\nexp-compat: {M : exp -> exp} exp-eq N N' -> exp-eq (M N) (M N') -> type.\n%mode exp-compat +I +I1 -O.\n \n- : exp-compat M _ exp-eq/i.\n\n%worlds (block) (exp-compat _ _ _).\n%total {} (exp-compat _ _ _). \n\n\nlam-compat: ({x:exp} exp-eq (N x) (N' x)) -> exp-eq (lam A N) (lam A N') -> type.\n%mode +{N:exp -> exp} +{N':exp -> exp} +{A:tp} +{D1:{x:exp} exp-eq (N x) (N' x)}\n   -{D2:exp-eq (lam A ([x:exp] N x)) (lam A ([x:exp] N' x))} (lam-compat D1 D2).\n\n-: lam-compat ([x] exp-eq/i) exp-eq/i.\n\n%worlds (block) (lam-compat _ _).\n%total {} (lam-compat _ _).\n\nlinear-resp: ({x:exp} exp-eq (M x) (N x) ) -> linear M -> linear N -> type.\n%mode linear-resp +I +I2 -O.\n\n-: linear-resp _ D D.\n  \n%worlds (block) (linear-resp _ _ _).\n%total {} (linear-resp _ _ _). \n\nreduce-closed : ({x:exp} reduce M (N x)) -> ({x:exp} exp-eq N' (N x) ) -> type.\n%mode reduce-closed +D -D'.\n\n-: reduce-closed ([x] reduce/app1 (Dreduce x : reduce M1 (N1 x)) ) Deq'\n\t<- reduce-closed Dreduce (Deq : {x} exp-eq N1' (N1 x))\n\t<- ({x} exp-compat ([y] app y M2) (Deq x) (Deq' x : exp-eq (app N1' M2) (app (N1 x) M2))).\n\n-: reduce-closed ([x] reduce/app2 (Dreduce x :reduce M2 (N2 x))) Deq'\n\t<- reduce-closed Dreduce (Deq : {x} exp-eq N2' (N2 x))\n\t<- ({x} exp-compat ([y] app M1 y) (Deq x) (Deq' x : exp-eq (app M1 N2') (app M1 (N2 x)))).\n\n-: reduce-closed ([x] reduce/lam (Dreduce x : {y} reduce (M y) (N x y))) Deq'\n\t<- ({y} reduce-closed ([x] Dreduce x y) ([x] Deq x y: exp-eq (N' y) (N x y)))\n\t<- ({x} lam-compat ([y] Deq x y) (Deq' x : exp-eq (lam A ([y] (N' y))) (lam A ([y] (N x y))))).\n\n-: reduce-closed ([x] reduce/beta : reduce (app (lam A ([y] M y)) N) (M N)) ([x] exp-eq/i).\n\n%worlds (block) (reduce-closed _ _).\n%total D (reduce-closed D _).\n\n\nlinear-compose: linear ([x] M x) -> linear ([y] N y) -> linear ([y] M (N y)) -> type.\n%mode linear-compose +I +I1 -O.\n\n-: linear-compose linear/var D D.\n\n-: linear-compose linear/unit _ linear/unit.\n\n-: linear-compose (linear/app1 (D1 :linear ([x] M1 x)) ) (D2:linear ([y] N y)) \n    (linear/app1 D)\n    <- linear-compose D1 D2 (D: linear ([y] M1 (N y))).\n\n-: linear-compose (linear/app2 (D1 :linear ([x] M1 x)) ) (D2 : linear ([y] N y))\n\t(linear/app2 D) \n    <- linear-compose D1 D2 D.\n-: linear-compose (linear/tens1 (D1 : linear ([x] M1 x))) \n\t\t(D2 : linear ([y] N y))   \n\t\t(linear/tens1 D) \n    <- linear-compose D1 D2 D.\n-: linear-compose (linear/tens2 (D1 : linear ([x] M1 x))) \n\t\t(D2 : linear ([y] N y))   \n\t\t(linear/tens2 D) \n    <- linear-compose D1 D2 D.\n-: linear-compose (linear/lett1 (D1 : linear ([x] M1 x))) \n\t\t(D2 : linear ([y] N y))\n\t\t(linear/lett1 D)\n    <- linear-compose D1 D2 D.\n-: linear-compose (linear/lett2 (D1 : {x} {y} linear ([z] M1 x y z)))\n\t\t(D2 : linear ([k] N k))\n\t\t(linear/lett2 D )\n    <- ({x} {y} linear-compose (D1 x y) D2 (D x y)).\n\n-: linear-compose (linear/pair (X1 : linear ([x] M1 x)) (X2 : linear ([y] M2 y)))\n D1\n \t(linear/pair A B)\n    <- linear-compose X1 D1 A\n    <- linear-compose X2 D1 B.\n-: linear-compose (linear/pi1 (D1 : linear ([x] M1 x)))\n\tD2\n\t(linear/pi1 D)\n\t<- linear-compose D1 D2 D.\n-: linear-compose (linear/pi2 (D1 : linear ([x] M1 x)))\n\tD2\n\t(linear/pi2 D)\n\t<- linear-compose D1 D2 D.\n-: linear-compose (linear/lets1 (D1 : linear ([x] M1 x)))\n\tD2\n\t(linear/lets1 D)\n\t<- linear-compose D1 D2 D.\n-: linear-compose (linear/lets2 (D1 : linear ([x] M1 x)))\n\tD2\n\t(linear/lets2 D)\n\t<- linear-compose D1 D2 D.\n-: linear-compose (linear/in1 (D1 : linear ([x] M1 x)))\n\tD2\n\t(linear/in1 D)\n\t<- linear-compose D1 D2 D.\n-: linear-compose (linear/in2 (D1 : linear ([x] M1 x)))\n\tD2\n\t(linear/in2 D)\n\t<- linear-compose D1 D2 D.\n-: linear-compose (linear/case1 (D1 : linear ([x] M1 x)))\n\tD2\n\t(linear/case1 D)\n\t<- linear-compose D1 D2 D.\n\n-: linear-compose (linear/case2 ([x] D1 x) ([x] D2 x)) D3 (linear/case2 D4 D5)\n\t<- ({x} linear-compose (D1 x) D3 (D4 x))\n\t<- ({x} linear-compose (D2 x) D3 (D5 x)).\n\n-: linear-compose (linear/abort1 (D1 : linear ([x] M1 x)))\n\tD2\n\t(linear/abort1 D)\n\t<- linear-compose D1 D2 D.\n\n-: linear-compose (linear/abort2) _ linear/abort2.\n\n-: linear-compose (linear/lam ([y] X1 y)) X2 (linear/lam D)\n\t<- ({x} linear-compose (X1 x) X2 (D x)).\n\n-: linear-compose (linear/letb1 (D1 : linear ([x] M1 x)))\n\tD2\n\t(linear/letb1 D)\n\t<- linear-compose D1 D2 D.\n-: linear-compose (linear/letb2 ([y] X1 y)) X2 (linear/letb2 D)\n\t<- ({x} linear-compose (X1 x) X2 (D x)).\n\n%worlds (block) (linear-compose _ _ _).\n%total (R) (linear-compose R _ _).\n\n\nsrl : ({x} (of x A) -> of (M x) B) -> linear ([x] M x) -> ({x} reduce (M x) (M' x)) -> linear ([x] M' x) -> type.\n%mode srl +D1 +D2 +D3 -D4.\n\n- : srl\n     ([x] [d:of x A] of/lam (DDD x) (Dof x d : {y} of y B -> of (M x y) C))\n     (linear/lam (Dlinear : {y} linear ([x] M x y)))\n     ([x] reduce/lam (Dreduce x : {y} reduce (M x y) (N x y)))\n     (linear/lam ([y] Dlinear' y))\n     <- ({y} {dy:of y B} srl ([x] [dx:of x A] Dof x dx y dy) (Dlinear y) ([x] Dreduce x y)\n\t   (Dlinear' y : linear ([x] N x y))).\n\n- : srl\n     ([x] [d:of x A] of/app _ (Dof x d : of (M x) (lolli B C)))\n     (linear/app1 (Dlinear : linear ([x] M x)))\n     ([x] reduce/app1 (Dreduce x : reduce (M x) (M' x)))\n     (linear/app1 Dlinear')\n   <- srl Dof Dlinear Dreduce (Dlinear' : linear ([x] M' x)).\n\n- : srl\n     _\n     (linear/app2 (Dlinear : linear ([x] N x)))\n     ([x] reduce/app1 (Dreduce x : reduce M (M' x)))\n     Dlinear'\n     <- reduce-closed Dreduce (Deq: {x} exp-eq  M'' (M' x)  )\n     <- ({x} exp-compat ([z] app z (N x)) (Deq x) (Deq' x : exp-eq (app M'' (N x) ) (app (M' x) (N x))))\n     <- linear-resp Deq' (linear/app2 Dlinear) (Dlinear' : linear ([x] app (M' x) (N x))).\n\n- : srl \n     _\n     (linear/app1 (linear/lam (Dlinear:{y} linear ([x] M x y))))\n     ([x] reduce/beta)\n     (Dlinear _).\n\n-: srl\n    ([x][d:of x A] of/app _ (of/lam (Dlinear' x : linear ([y] M y)) _ ))\n    (linear/app2 (Dlinear : linear ([x] N x) ))\n    ([x] reduce/beta)\n    Dlinear''\n    <- linear-compose (Dlinear' unit) Dlinear (Dlinear'' : linear ([x] M (N x))).\n\n-: srl\n    ([x] [d : of x A] of/app (Dof x d : of (N x) B) _)\n    (linear/app2 (Dlinear : linear ([x] N x)))\n    ([x] reduce/app2 (Dreduce x : reduce (N x) (N' x)))\n    (linear/app2 Dlinear')\n    <- srl Dof Dlinear Dreduce (Dlinear' : linear ([x] N' x)).\n\n-: srl \n    _\n    (linear/app1 (Dlinear : linear ([x] M x)))\n    ([x] reduce/app2 (Dreduce x : reduce N (N' x)))\n    Dlinear'\n    <- reduce-closed Dreduce (Deq : {x} exp-eq N'' (N' x))\n    <- ({x} exp-compat ([z] app (M x) z) (Deq x) (Deq' x : exp-eq (app (M x) N'') (app (M x) (N' x))))\n    <- linear-resp Deq' (linear/app1 Dlinear) (Dlinear' : linear ([x] app (M x) (N' x))).\n\n%worlds (bind) (srl _ _ _ _).\n%total D (srl _ _ D _).\n\n\nsr : of M A -> reduce M M' -> of M' A -> type.\n%mode sr +D1 +D2 -D3.\n\n- : sr\n     (of/app (DofN : of N A) (DofM : of M (lolli A B)))\n     (reduce/app1 (Dreduce : reduce M M'))\n     (of/app DofN DofM')\n     <- sr DofM Dreduce (DofM' : of M' (lolli A B)).\n\n- : sr\n     (of/app (DofN : of N A) (DofM : of M (lolli A B)))\n     (reduce/app2 (Dreduce : reduce N N'))\n     (of/app DofN' DofM)\n     <- sr DofN Dreduce (DofN' : of N' A).\n\n- : sr\n     (of/app (DofN : of N A) (of/lam _ (DofM : {x} (of x A) -> of (M x) B)))\n     reduce/beta\n     (DofM N DofN).\n\n- : sr\n     (of/lam\n\t(Dlinear : linear ([x] M x))\n\t(DofM : {x} (of x A) -> of (M x) B))\n     (reduce/lam (Dreduce : {x} reduce (M x) (N x)))\n     (of/lam\n\tDlinear'\n\tDofN)\n     <- ({x} {dx:of x A}\n\t   sr (DofM x dx) (Dreduce x) (DofN x dx : of (N x) B))\n     <- srl DofM Dlinear Dreduce (Dlinear': linear ([x] N x)).\n\n%worlds (bind) (sr _ _ _).\n%total D1 (sr _ D1 _)."
          },
          "sha1": "qqzvaq7dumrqnmbh4509qbkyf8gnemf"
        }
      },
      {
        "title": "Computation and Deduction 2009/20090413",
        "ns": 0,
        "id": 2204,
        "revision": {
          "id": 5969,
          "timestamp": "2009-04-15T03:48:56Z",
          "contributor": {
            "username": "Crary",
            "id": 13
          },
          "comment": "Created page with '%{ Code from class, April 13. }%  tp : type. %name tp T.  exp : type. %name exp E x.  o : tp. arr : tp -> tp -> tp.  p : exp. lam : tp ->  (exp -> exp) -> exp. app : exp -> exp -...'",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 1492,
            "#text": "%{ Code from class, April 13. }%\n\ntp : type. %name tp T.\n\nexp : type. %name exp E x.\n\no : tp.\narr : tp -> tp -> tp.\n\np : exp.\nlam : tp ->  (exp -> exp) -> exp.\napp : exp -> exp -> exp.\n\n%% - : (exp -> tp) -> type.\n\nof : exp -> tp -> type.\n\nof/p : of p o.\nof/lam : of (lam T ([x] E x)) (arr T T')\n\t  <- ({x} of x T -> of (E x) T').\nof/app : of (app E1 E2) T'\n\t  <- of E1 (arr T T')\n\t  <- of E2 T.\n\n%block bind : some {T : tp} block {x :exp} {dx : of x T}.\n\nsubst : ({x} of x T1 -> of (E1 x) T2) -> of E2 T1 -> of (E1 E2) T2 -> type.\n%mode subst +D1 +D2 -D3.\n\n%% - : subst D1 D2 (D1 _ D2).\n\n- : subst ([x] [d : of x T1] d) (D2 : of E2 T1) D2.\n\n- : subst ([x] [d : of x T1] D1) _ D1.\n\n- : subst \n     ([x] [d : of x T1]\n\tof/app\n\t(D12 x d : of (E12 x) T2)\n\t(D11 x d : of (E11 x) (arr T2 T3)))\n     (D2 : of E2 T1)\n     (of/app D12' D11')\n     <- subst D11 D2 (D11' : of (E11 E2) (arr T2 T3))\n     <- subst D12 D2 (D12' : of (E12 E2) T2).\n\n- : subst\n     ([x] [dx : of x T1] of/lam (D1 x dx : {y} of y T2 -> of (E1 x y) T3))\n     (D2 : of E2 T1)\n     (of/lam D)\n     <- ({y} {dy : of y T2}\n\t   subst ([x] [dx] D1 x dx y dy) D2 (D y dy : of (E1 E2 y) T3)).\n\n\n%worlds (bind) (subst _ _ _).\n%total D (subst D _ _).\n\nctx : type. %name ctx G.\nnil : ctx.\ncons : ctx -> exp -> tp -> ctx.\n\nofe : ctx -> exp -> tp -> type.\n\nofe/p : ofe G p o.\n\nofe/app : ofe G (app E1 E2) T'\n\t   <- ofe G E1 (arr T T')\n\t   <- ofe G E2 T.\n\nofe/lam : ofe G (lam T ([x] E x)) (arr T T')\n\t   <- ({x} ofe (cons G x T) (E x) T')."
          },
          "sha1": "hphgat8g9z2ma16752k3f2agmw74yd8"
        }
      },
      {
        "title": "Computation and Deduction 2009/20090415",
        "ns": 0,
        "id": 2205,
        "revision": {
          "id": 5971,
          "timestamp": "2009-04-15T21:12:49Z",
          "contributor": {
            "username": "Crary",
            "id": 13
          },
          "comment": "Created page with '%{ Code from class, April 15. }%  nat : type. %name nat N.  0 : nat. s : nat -> nat.  lt : nat -> nat -> type.  lt/0 : lt 0 (s N).  lt/s : lt (s M) (s N) \t<- lt M N.  tp : type. ...'",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 3441,
            "#text": "%{ Code from class, April 15. }%\n\nnat : type. %name nat N.\n\n0 : nat.\ns : nat -> nat.\n\nlt : nat -> nat -> type.\n\nlt/0 : lt 0 (s N).\n\nlt/s : lt (s M) (s N)\n\t<- lt M N.\n\ntp : type. %name tp T.\n\nexp : type. %name exp E x.\n\no : tp.\narr : tp -> tp -> tp.\n\np : exp.\nlam : tp ->  (exp -> exp) -> exp.\napp : exp -> exp -> exp.\n\n%% - : (exp -> tp) -> type.\n\nof : exp -> tp -> type.\n\nof/p : of p o.\nof/lam : of (lam T ([x] E x)) (arr T T')\n\t  <- ({x} of x T -> of (E x) T').\nof/app : of (app E1 E2) T'\n\t  <- of E1 (arr T T')\n\t  <- of E2 T.\n\n%block bind : some {T : tp} block {x :exp} {dx : of x T}.\n\nsubst : ({x} of x T1 -> of (E1 x) T2) -> of E2 T1 -> of (E1 E2) T2 -> type.\n%mode subst +D1 +D2 -D3.\n\n%% - : subst D1 D2 (D1 _ D2).\n\n- : subst ([x] [d : of x T1] d) (D2 : of E2 T1) D2.\n\n- : subst ([x] [d : of x T1] D1) _ D1.\n\n- : subst \n     ([x] [d : of x T1]\n\tof/app\n\t(D12 x d : of (E12 x) T2)\n\t(D11 x d : of (E11 x) (arr T2 T3)))\n     (D2 : of E2 T1)\n     (of/app D12' D11')\n     <- subst D11 D2 (D11' : of (E11 E2) (arr T2 T3))\n     <- subst D12 D2 (D12' : of (E12 E2) T2).\n\n- : subst\n     ([x] [dx : of x T1] of/lam (D1 x dx : {y} of y T2 -> of (E1 x y) T3))\n     (D2 : of E2 T1)\n     (of/lam D)\n     <- ({y} {dy : of y T2}\n\t   subst ([x] [dx] D1 x dx y dy) D2 (D y dy : of (E1 E2 y) T3)).\n\n\n%worlds (bind) (subst _ _ _).\n%total D (subst D _ _).\n\nctx : type. %name ctx G.\nnil : ctx.\ncons : ctx -> exp -> tp -> ctx.\n\nappend : ctx -> ctx -> ctx -> type.\n\nappend/nil : append G nil G.\n\nappend/cons : append G1 (cons G2 X T) (cons G X T)\n\t       <- append G1 G2 G.\n\nlookup : ctx -> exp -> tp -> type.\n\nlookup/hit : lookup (cons G X T) X T.\n\nlookup/miss : lookup (cons G X' T') X T\n\t       <- lookup G X T.\n\nofe : ctx -> exp -> tp -> type.\n\nofe/closed : ofe G E T\n\t      <- of E T.\n\nofe/var : ofe G X T\n\t   <- lookup G X T.\n\nofe/p : ofe G p o = ofe/closed of/p.\n\nofe/app : ofe G (app E1 E2) T'\n\t   <- ofe G E1 (arr T T')\n\t   <- ofe G E2 T.\n\nofe/lam : ofe G (lam T ([x] E x)) (arr T T')\n\t   <- ({x} ofe (cons G x T) (E x) T').\n\nisvar : exp -> nat -> type.\n\n%block ovar : some {I : nat} block {x : exp} {d : isvar x I}.\n\nprecedes : exp -> exp -> type.\n\nprecedes/i : precedes X Y\n\t      <- isvar X I\n\t      <- isvar Y J\n\t      <- lt I J.\n\nbounded : ctx -> exp -> type.\n\nbounded/nil : bounded nil X\n\t       <- isvar X _.\n\nbounded/cons : bounded (cons G X T) Y\n\t\t<- bounded G X\n\t\t<- precedes X Y.\n\nordered : ctx -> type.\n\nordered/nil : ordered nil.\n\nordered/cons : ordered (cons G X T)\n\t\t<- bounded G X.\n\n\nesubst : ({x} append (cons G1 x A) G2 (G x))\n\t  -> append G1 G2 G'\n\t  -> ({x} isvar x I -> ordered (G x))\n\t  -> ofe G1 N A\n\t  -> ({x} ofe (G x) (M x) B)\n%% \n\t  -> ofe G' (M N) B -> type.\n\n%mode esubst +D1 +D2 +D3 +D4 +D5 -D6.\n\n- : esubst\n     (Dappend : ({x} append (cons G1 x A) G2 (G x)))\n     (Dappend' : append G1 G2 G')\n     (Dordered : ({x} isvar x I -> ordered (G x)))\n     (DofeN : ofe G1 N A)\n     ([x] ofe/closed (DofM x : of (M x) B))\n     (ofe/closed (DofM N)).\n\n%{\n- : esubst\n     (Dappend : ({x} append (cons G1 x A) G2 (G x)))\n     (Dappend' : append G1 G2 G')\n     (Dordered : ({x} isvar x I -> ordered (G x)))\n     (DofeN : ofe G1 N A)\n     ([x] ofe/lam (DofeM x : {y} ofe (cons (G x) y B) (M x y) C))\n     _\n     <- ({y} {dy : isvar y J} \n\t   esubst ([x] append/cons (Dappend x))\n\t   (append/cons Dappend')\n\t   (ordered/cons (_ : bounded (G x) y))\n\t   _ _ _).\n}%\n\t\n\n%worlds (bind) (esubst _ _ _ _ _ _).\n%total D (esubst _ _ _ _ D _)."
          },
          "sha1": "hpo5nisafo55wcc5qlg5mkdm9ptq4xu"
        }
      },
      {
        "title": "Computation and Deduction 2009/20090420",
        "ns": 0,
        "id": 2208,
        "revision": {
          "id": 5983,
          "timestamp": "2009-04-20T20:51:44Z",
          "contributor": {
            "username": "Crary",
            "id": 13
          },
          "comment": "Created page with '%{ Code from class, April 20. }%  nat : type. %name nat N.  0 : nat. s : nat -> nat.  lt : nat -> nat -> type.  lt/0 : lt 0 (s N).  lt/s : lt (s M) (s N) \t<- lt M N.  lt-succ : {...'",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 5579,
            "#text": "%{ Code from class, April 20. }%\n\nnat : type. %name nat N.\n\n0 : nat.\ns : nat -> nat.\n\nlt : nat -> nat -> type.\n\nlt/0 : lt 0 (s N).\n\nlt/s : lt (s M) (s N)\n\t<- lt M N.\n\nlt-succ : {N : nat} lt N (s N) -> type.\n%mode lt-succ +N -D.\n\n%worlds () (lt-succ _ _).\n%trustme %total N (lt-succ N _).\n\ntp : type. %name tp T.\n\nexp : type. %name exp E x.\n\no : tp.\narr : tp -> tp -> tp.\n\np : exp.\nlam : tp ->  (exp -> exp) -> exp.\napp : exp -> exp -> exp.\n\n%% - : (exp -> tp) -> type.\n\ntp-eq : tp -> tp -> type.\n\ntp-eq/i : tp-eq A A.\n\nof : exp -> tp -> type.\n\nof/p : of p o.\nof/lam : of (lam T ([x] E x)) (arr T T')\n\t  <- ({x} of x T -> of (E x) T').\nof/app : of (app E1 E2) T'\n\t  <- of E1 (arr T T')\n\t  <- of E2 T.\n\n%block bind : some {T : tp} block {x :exp} {dx : of x T}.\n\nsubst : ({x} of x T1 -> of (E1 x) T2) -> of E2 T1 -> of (E1 E2) T2 -> type.\n%mode subst +D1 +D2 -D3.\n\n%% - : subst D1 D2 (D1 _ D2).\n\n- : subst ([x] [d : of x T1] d) (D2 : of E2 T1) D2.\n\n- : subst ([x] [d : of x T1] D1) _ D1.\n\n- : subst \n     ([x] [d : of x T1]\n\tof/app\n\t(D12 x d : of (E12 x) T2)\n\t(D11 x d : of (E11 x) (arr T2 T3)))\n     (D2 : of E2 T1)\n     (of/app D12' D11')\n     <- subst D11 D2 (D11' : of (E11 E2) (arr T2 T3))\n     <- subst D12 D2 (D12' : of (E12 E2) T2).\n\n- : subst\n     ([x] [dx : of x T1] of/lam (D1 x dx : {y} of y T2 -> of (E1 x y) T3))\n     (D2 : of E2 T1)\n     (of/lam D)\n     <- ({y} {dy : of y T2}\n\t   subst ([x] [dx] D1 x dx y dy) D2 (D y dy : of (E1 E2 y) T3)).\n\n\n%worlds (bind) (subst _ _ _).\n%total D (subst D _ _).\n\nctx : type. %name ctx G.\nnil : ctx.\ncons : ctx -> exp -> tp -> ctx.\n\nappend : ctx -> ctx -> ctx -> type.\n\nappend/nil : append G nil G.\n\nappend/cons : append G1 (cons G2 X T) (cons G X T)\n\t       <- append G1 G2 G.\n\nlookup : ctx -> exp -> tp -> type.\n\nlookup/hit : lookup (cons G X T) X T.\n\nlookup/miss : lookup (cons G X' T') X T\n\t       <- lookup G X T.\n\nofe : ctx -> exp -> tp -> type.\n\nofe/closed : ofe G E T\n\t      <- of E T.\n\nofe/var : ofe G X T\n\t   <- lookup G X T.\n\nofe/p : ofe G p o = ofe/closed of/p.\n\nofe/app : ofe G (app E1 E2) T'\n\t   <- ofe G E1 (arr T T')\n\t   <- ofe G E2 T.\n\nofe/lam : ofe G (lam T ([x] E x)) (arr T T')\n\t   <- ({x} ofe (cons G x T) (E x) T').\n\nisvar : exp -> nat -> type.\n\n%block ovar : some {I : nat} block {x : exp} {d : isvar x I}.\n\nprecedes : exp -> exp -> type.\n\nprecedes/i : precedes X Y\n\t      <- isvar X I\n\t      <- isvar Y J\n\t      <- lt I J.\n\nbounded : ctx -> exp -> type.\n\nbounded/nil : bounded nil X\n\t       <- isvar X _.\n\nbounded/cons : bounded (cons G X T) Y\n\t\t<- bounded G X\n\t\t<- precedes X Y.\n\nordered : ctx -> type.\n\nordered/nil : ordered nil.\n\nordered/cons : ordered (cons G X T)\n\t\t<- bounded G X.\n\nofe-resp : tp-eq A A' -> ofe G M A -> ofe G M A' -> type.\n%mode ofe-resp +D1 +D2 -D3.\n\n- : ofe-resp _ D D.\n\n%worlds (ovar | bind) (ofe-resp _ _ _).\n%total {} (ofe-resp _ _ _).\n\nbounded-isvar : bounded G X -> isvar X I -> type.\n%mode bounded-isvar +D1 -D2.\n\n- : bounded-isvar (bounded/nil D) D.\n\n- : bounded-isvar (bounded/cons (precedes/i _ D _) _) D.\n\n%worlds (ovar | bind) (bounded-isvar _ _).\n%total {} (bounded-isvar _ _).\n\n\nordered-extend : ordered G -> ({x} isvar x I -> bounded G x) -> type.\n%mode ordered-extend +D1 -D2.\n\n- : ordered-extend ordered/nil ([x] [dx : isvar x 0] bounded/nil dx).\n\n- : ordered-extend \n\t(ordered/cons (Dbounded : bounded G Y))\n\t([x] [dx : isvar x (s J)] \n\t\tbounded/cons\n\t\t(precedes/i Dlt dx Disvar)\n\t\tDbounded)\n\t<- bounded-isvar Dbounded (Disvar : isvar Y J)\n\t<- lt-succ J (Dlt : lt J (s J)).\n\n%worlds (ovar | bind) (ordered-extend _ _).\n%total {} (ordered-extend _ _).\n\nofe-weaken : append G1 G2 G -> ofe G1 M A -> ofe G M A -> type.\n%mode ofe-weaken +D1 +D2 -D3.\n\n%worlds (ovar | bind) (ofe-weaken _ _ _).\n%trustme %total {} (ofe-weaken _ _ _).\n\n\nappend-lookup-eq : ({x} append (cons G1 x A) G2 (G x))\n\t-> ({x} isvar x I -> ordered (G x))\n\t-> ({x} lookup (G x) x B)\n\t-> (tp-eq A B)\n\t-> type.\n%mode append-lookup-eq +D1 +D2 +D3 -D.\n\n%worlds (bind | ovar) (append-lookup-eq _ _ _ _).\n%trustme %total D (append-lookup-eq D _ _ _).\n\nesubst : ({x} append (cons G1 x A) G2 (G x))\n\t  -> append G1 G2 G'\n\t  -> ({x} isvar x I -> ordered (G x))\n\t  -> ofe G1 N A\n\t  -> ({x} ofe (G x) (M x) B)\n%% \n\t  -> ofe G' (M N) B -> type.\n\n%mode esubst +D1 +D2 +D3 +D4 +D5 -D6.\n\n- : esubst\n     (Dappend : ({x} append (cons G1 x A) G2 (G x)))\n     (Dappend' : append G1 G2 G')\n     (Dordered : ({x} isvar x I -> ordered (G x)))\n     (DofeN : ofe G1 N A)\n     ([x] ofe/closed (DofM x : of (M x) B))\n     (ofe/closed (DofM N)).\n\n- : esubst\n\t(Dappend : ({x} append (cons G1 x A) G2 (G x)))\n\t(Dappend' : append G1 G2 G')\n\t(Dordered : ({x} isvar x I -> ordered (G x)))\n\t(DofeN : ofe G1 N A)\n\t([x] ofe/var (Dlookup x : lookup (G x) x B))\n\tDofeN''\n\t<- ofe-weaken Dappend' DofeN (DofeN' : ofe G' N A)\n\t<- append-lookup-eq Dappend Dordered Dlookup \n\t\t(Deq : tp-eq A B)\n\t<- ofe-resp Deq DofeN' (DofeN'' : ofe G' N B).\n\n- : esubst\n     (Dappend : ({x} append (cons G1 x A) G2 (G x)))\n     (Dappend' : append G1 G2 G')\n     (Dordered : ({x} isvar x I -> ordered (G x)))\n     (DofeN : ofe G1 N A)\n     ([x] ofe/lam (DofeM x : {y} ofe (cons (G x) y B) (M x y) C))\n     (ofe/lam Dofe)\n\t <- ({x} {dx : isvar x I} ordered-extend (Dordered x dx) \n\t \t\t(Dbounded x dx : {y} isvar y J -> bounded (G x) y))\n     <- ({y} {dy : isvar y J} \n\t\tesubst ([x] append/cons (Dappend x))\n\t\t(append/cons Dappend')\n\t\t([x] [dx : isvar x I] \n\t\t\tordered/cons (Dbounded x dx y dy: bounded (G x) y))\n\t\tDofeN\n\t\t([x] DofeM x y)\n\t\t(Dofe y : ofe (cons G' y B) (M N y) C)).\n\n\n%worlds (bind | ovar) (esubst _ _ _ _ _ _).\n%total D (esubst _ _ _ _ D _)."
          },
          "sha1": "4ws5a7xmhh0zbfzss2pd7j09rxow7gn"
        }
      },
      {
        "title": "Computation and Deduction 2009/20090422",
        "ns": 0,
        "id": 2210,
        "revision": {
          "id": 5986,
          "timestamp": "2009-04-22T19:38:05Z",
          "contributor": {
            "username": "Crary",
            "id": 13
          },
          "comment": "Created page with '%{ Code from class, April 22. }%  false : type.  nat : type. %name nat N.  0 : nat. s : nat -> nat.  lt : nat -> nat -> type.  lt/0 : lt 0 (s N).  lt/s : lt (s M) (s N) \t<- lt M ...'",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 7953,
            "#text": "%{ Code from class, April 22. }%\n\nfalse : type.\n\nnat : type. %name nat N.\n\n0 : nat.\ns : nat -> nat.\n\nlt : nat -> nat -> type.\n\nlt/0 : lt 0 (s N).\n\nlt/s : lt (s M) (s N)\n\t<- lt M N.\n\nlt-succ : {N : nat} lt N (s N) -> type.\n%mode lt-succ +N -D.\n\n%worlds () (lt-succ _ _).\n%trustme %total N (lt-succ N _).\n\ntp : type. %name tp T.\n\nexp : type. %name exp E x.\n\no : tp.\narr : tp -> tp -> tp.\n\np : exp.\nlam : tp ->  (exp -> exp) -> exp.\napp : exp -> exp -> exp.\n\n%% - : (exp -> tp) -> type.\n\ntp-eq : tp -> tp -> type.\n\ntp-eq/i : tp-eq A A.\n\nof : exp -> tp -> type.\n\nof/p : of p o.\nof/lam : of (lam T ([x] E x)) (arr T T')\n\t  <- ({x} of x T -> of (E x) T').\nof/app : of (app E1 E2) T'\n\t  <- of E1 (arr T T')\n\t  <- of E2 T.\n\n%block bind : some {T : tp} block {x :exp} {dx : of x T}.\n\nsubst : ({x} of x T1 -> of (E1 x) T2) -> of E2 T1 -> of (E1 E2) T2 -> type.\n%mode subst +D1 +D2 -D3.\n\n%% - : subst D1 D2 (D1 _ D2).\n\n- : subst ([x] [d : of x T1] d) (D2 : of E2 T1) D2.\n\n- : subst ([x] [d : of x T1] D1) _ D1.\n\n- : subst \n     ([x] [d : of x T1]\n\tof/app\n\t(D12 x d : of (E12 x) T2)\n\t(D11 x d : of (E11 x) (arr T2 T3)))\n     (D2 : of E2 T1)\n     (of/app D12' D11')\n     <- subst D11 D2 (D11' : of (E11 E2) (arr T2 T3))\n     <- subst D12 D2 (D12' : of (E12 E2) T2).\n\n- : subst\n     ([x] [dx : of x T1] of/lam (D1 x dx : {y} of y T2 -> of (E1 x y) T3))\n     (D2 : of E2 T1)\n     (of/lam D)\n     <- ({y} {dy : of y T2}\n\t   subst ([x] [dx] D1 x dx y dy) D2 (D y dy : of (E1 E2 y) T3)).\n\n\n%worlds (bind) (subst _ _ _).\n%total D (subst D _ _).\n\nctx : type. %name ctx G.\nnil : ctx.\ncons : ctx -> exp -> tp -> ctx.\n\nappend : ctx -> ctx -> ctx -> type.\n\nappend/nil : append G nil G.\n\nappend/cons : append G1 (cons G2 X T) (cons G X T)\n\t       <- append G1 G2 G.\n\nlookup : ctx -> exp -> tp -> type.\n\nlookup/hit : lookup (cons G X T) X T.\n\nlookup/miss : lookup (cons G X' T') X T\n\t       <- lookup G X T.\n\nofe : ctx -> exp -> tp -> type.\n\nofe/closed : ofe G E T\n\t      <- of E T.\n\nofe/var : ofe G X T\n\t   <- lookup G X T.\n\nofe/p : ofe G p o = ofe/closed of/p.\n\nofe/app : ofe G (app E1 E2) T'\n\t   <- ofe G E1 (arr T T')\n\t   <- ofe G E2 T.\n\nofe/lam : ofe G (lam T ([x] E x)) (arr T T')\n\t   <- ({x} ofe (cons G x T) (E x) T').\n\nisvar : exp -> nat -> type.\n\n%block ovar : some {I : nat} block {x : exp} {d : isvar x I}.\n\nprecedes : exp -> exp -> type.\n\nprecedes/i : precedes X Y\n\t      <- isvar X I\n\t      <- isvar Y J\n\t      <- lt I J.\n\nbounded : ctx -> exp -> type.\n\nbounded/nil : bounded nil X\n\t       <- isvar X _.\n\nbounded/cons : bounded (cons G X T) Y\n\t\t<- bounded G X\n\t\t<- precedes X Y.\n\nordered : ctx -> type.\n\nordered/nil : ordered nil.\n\nordered/cons : ordered (cons G X T)\n\t\t<- bounded G X.\n\nofe-resp : tp-eq A A' -> ofe G M A -> ofe G M A' -> type.\n%mode ofe-resp +D1 +D2 -D3.\n\n- : ofe-resp _ D D.\n\n%worlds (ovar | bind) (ofe-resp _ _ _).\n%total {} (ofe-resp _ _ _).\n\nbounded-isvar : bounded G X -> isvar X I -> type.\n%mode bounded-isvar +D1 -D2.\n\n- : bounded-isvar (bounded/nil D) D.\n\n- : bounded-isvar (bounded/cons (precedes/i _ D _) _) D.\n\n%worlds (ovar | bind) (bounded-isvar _ _).\n%total {} (bounded-isvar _ _).\n\n\nordered-extend : ordered G -> ({x} isvar x I -> bounded G x) -> type.\n%mode ordered-extend +D1 -D2.\n\n- : ordered-extend ordered/nil ([x] [dx : isvar x 0] bounded/nil dx).\n\n- : ordered-extend \n\t(ordered/cons (Dbounded : bounded G Y))\n\t([x] [dx : isvar x (s J)] \n\t\tbounded/cons\n\t\t(precedes/i Dlt dx Disvar)\n\t\tDbounded)\n\t<- bounded-isvar Dbounded (Disvar : isvar Y J)\n\t<- lt-succ J (Dlt : lt J (s J)).\n\n%worlds (ovar | bind) (ordered-extend _ _).\n%total {} (ordered-extend _ _).\n\nofe-weaken : append G1 G2 G -> ofe G1 M A -> ofe G M A -> type.\n%mode ofe-weaken +D1 +D2 -D3.\n\n%worlds (ovar | bind) (ofe-weaken _ _ _).\n%trustme %total {} (ofe-weaken _ _ _).\n\nbounded-ordered : bounded G X -> ordered G -> type.\n%mode bounded-ordered +D1 -D2.\n\n%worlds (ovar | bind) (bounded-ordered _ _).\n%trustme %total {} (bounded-ordered _ _).\n\nbounded-increase : bounded G X -> precedes X Y -> bounded G Y -> type.\n%mode bounded-increase +D1 +D2 -D3.\n\n%worlds (ovar | bind) (bounded-increase _ _ _).\n%trustme %total {} (bounded-increase _ _ _).\n\nlt-irreflex : lt N N -> false -> type.\n%mode lt-irreflex +X1 -X2.\n%worlds (bind | ovar) (lt-irreflex _ _).\n%trustme %total {} (lt-irreflex _ _).\n\n\nprecedes-contra : precedes X X -> false -> type.\n%mode precedes-contra +D1 -D2.\n\n- : precedes-contra (precedes/i (Dlt : lt I I) (Disvar : isvar X I) Disvar) DFalse\n     <- lt-irreflex Dlt DFalse.\n\n%worlds (bind | ovar) (precedes-contra _ _).\n%total {} (precedes-contra _ _).\n\nbounded-lookup-contra : bounded G X -> lookup G X A -> false -> type.\n%mode bounded-lookup-contra +D1 +D2 -D3.\n\n- : bounded-lookup-contra\n     (bounded/cons (Dprecedes : precedes Y X) (Dbounded : bounded G Y))\n     (lookup/miss (Dlookup : lookup G X A))\n     DFalse\n     <- bounded-increase Dbounded Dprecedes (Dbounded' : bounded G X)\n     <- bounded-lookup-contra Dbounded' Dlookup DFalse.\n\n- : bounded-lookup-contra\n     (bounded/cons (Dprecedes : precedes X X) _)\n     (lookup/hit)\n     DFalse\n     <- precedes-contra Dprecedes DFalse.\n\n%worlds (ovar | bind) (bounded-lookup-contra _ _ _).\n%total D (bounded-lookup-contra _ D _).\n\nfalse-implies-tp-eq : false -> {A} {B} tp-eq A B -> type.\n%mode false-implies-tp-eq +X1 +X2 +X3 -X4.\n%worlds (bind | ovar) (false-implies-tp-eq _ _ _ _).\n%total {} (false-implies-tp-eq _ _ _ _).\n\nappend-lookup-eq : ({x} append (cons G1 x A) G2 (G x))\n\t-> ({x} isvar x I -> ordered (G x))\n\t-> ({x} lookup (G x) x B)\n\t-> (tp-eq A B)\n\t-> type.\n%mode append-lookup-eq +D1 +D2 +D3 -D.\n\n- : append-lookup-eq _ _ ([x] lookup/hit) tp-eq/i.\n\n- : append-lookup-eq\n     ([x] append/cons (Dappend x : append (cons G1 x A) G2 (G x)))\n     ([x] [dx : isvar x I] ordered/cons (Dbounded x dx : bounded (G x) Y))\n     ([x] lookup/miss (Dlookup x : lookup (G x) x B))\n     Deq\n     <- ({x} {dx : isvar x I} bounded-ordered (Dbounded x dx) (Dordered x dx : ordered (G x)))\n     <- append-lookup-eq Dappend Dordered Dlookup (Deq : tp-eq A B).\n\n- : append-lookup-eq\n     ([x] append/nil)\n     ([x] [dx : isvar x I] ordered/cons (Dbounded x dx : bounded G1 x))\n     ([x] lookup/miss (Dlookup x : lookup G1 x B))\n     Deq\n     <- ({x} {dx} bounded-lookup-contra (Dbounded x dx) (Dlookup x) DFalse)\n     <- false-implies-tp-eq DFalse _ _ Deq.\n\n%worlds (bind | ovar) (append-lookup-eq _ _ _ _).\n%total D (append-lookup-eq D _ _ _).\n\nesubst : ({x} append (cons G1 x A) G2 (G x))\n\t  -> append G1 G2 G'\n\t  -> ({x} isvar x I -> ordered (G x))\n\t  -> ofe G1 N A\n\t  -> ({x} ofe (G x) (M x) B)\n%% \n\t  -> ofe G' (M N) B -> type.\n\n%mode esubst +D1 +D2 +D3 +D4 +D5 -D6.\n\n- : esubst\n     (Dappend : ({x} append (cons G1 x A) G2 (G x)))\n     (Dappend' : append G1 G2 G')\n     (Dordered : ({x} isvar x I -> ordered (G x)))\n     (DofeN : ofe G1 N A)\n     ([x] ofe/closed (DofM x : of (M x) B))\n     (ofe/closed (DofM N)).\n\n- : esubst\n\t(Dappend : ({x} append (cons G1 x A) G2 (G x)))\n\t(Dappend' : append G1 G2 G')\n\t(Dordered : ({x} isvar x I -> ordered (G x)))\n\t(DofeN : ofe G1 N A)\n\t([x] ofe/var (Dlookup x : lookup (G x) x B))\n\tDofeN''\n\t<- ofe-weaken Dappend' DofeN (DofeN' : ofe G' N A)\n\t<- append-lookup-eq Dappend Dordered Dlookup \n\t\t(Deq : tp-eq A B)\n\t<- ofe-resp Deq DofeN' (DofeN'' : ofe G' N B).\n\n- : esubst\n     (Dappend : ({x} append (cons G1 x A) G2 (G x)))\n     (Dappend' : append G1 G2 G')\n     (Dordered : ({x} isvar x I -> ordered (G x)))\n     (DofeN : ofe G1 N A)\n     ([x] ofe/lam (DofeM x : {y} ofe (cons (G x) y B) (M x y) C))\n     (ofe/lam Dofe)\n\t <- ({x} {dx : isvar x I} ordered-extend (Dordered x dx) \n\t \t\t(Dbounded x dx : {y} isvar y J -> bounded (G x) y))\n     <- ({y} {dy : isvar y J} \n\t\tesubst ([x] append/cons (Dappend x))\n\t\t(append/cons Dappend')\n\t\t([x] [dx : isvar x I] \n\t\t\tordered/cons (Dbounded x dx y dy: bounded (G x) y))\n\t\tDofeN\n\t\t([x] DofeM x y)\n\t\t(Dofe y : ofe (cons G' y B) (M N y) C)).\n\n\n\n\n%worlds (bind | ovar) (esubst _ _ _ _ _ _).\n%total D (esubst _ _ _ _ D _)."
          },
          "sha1": "q2x4x3yu1ho7sg40945vvfogg0ij7qg"
        }
      },
      {
        "title": "Computation and Deduction 2009/20090427",
        "ns": 0,
        "id": 2212,
        "revision": {
          "id": 5998,
          "timestamp": "2009-04-29T16:10:18Z",
          "contributor": {
            "username": "Crary",
            "id": 13
          },
          "comment": "Created page with '%{ Code from class, April 27. }%  false : type.  nat : type. %name nat N.  0 : nat. s : nat -> nat.  lt : nat -> nat -> type.  lt/0 : lt 0 (s N).  lt/s : lt (s M) (s N) \t<- lt M ...'",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 12851,
            "#text": "%{ Code from class, April 27. }%\n\nfalse : type.\n\nnat : type. %name nat N.\n\n0 : nat.\ns : nat -> nat.\n\nlt : nat -> nat -> type.\n\nlt/0 : lt 0 (s N).\n\nlt/s : lt (s M) (s N)\n\t<- lt M N.\n\nlt-succ : {N : nat} lt N (s N) -> type.\n%mode lt-succ +N -D.\n\n%worlds () (lt-succ _ _).\n%trustme %total N (lt-succ N _).\n\ntp : type. %name tp T.\n\nexp : type. %name exp E x.\n\no : tp.\narr : tp -> tp -> tp.\n\np : exp.\nlam : tp ->  (exp -> exp) -> exp.\napp : exp -> exp -> exp.\n\n%% - : (exp -> tp) -> type.\n\ntp-eq : tp -> tp -> type.\n\ntp-eq/i : tp-eq A A.\n\nof : exp -> tp -> type.\n\nof/p : of p o.\nof/lam : of (lam T ([x] E x)) (arr T T')\n\t  <- ({x} of x T -> of (E x) T').\nof/app : of (app E1 E2) T'\n\t  <- of E1 (arr T T')\n\t  <- of E2 T.\n\n%block bind : some {T : tp} block {x :exp} {dx : of x T}.\n\nsubst : ({x} of x T1 -> of (E1 x) T2) -> of E2 T1 -> of (E1 E2) T2 -> type.\n%mode subst +D1 +D2 -D3.\n\n%% - : subst D1 D2 (D1 _ D2).\n\n- : subst ([x] [d : of x T1] d) (D2 : of E2 T1) D2.\n\n- : subst ([x] [d : of x T1] D1) _ D1.\n\n- : subst \n     ([x] [d : of x T1]\n\tof/app\n\t(D12 x d : of (E12 x) T2)\n\t(D11 x d : of (E11 x) (arr T2 T3)))\n     (D2 : of E2 T1)\n     (of/app D12' D11')\n     <- subst D11 D2 (D11' : of (E11 E2) (arr T2 T3))\n     <- subst D12 D2 (D12' : of (E12 E2) T2).\n\n- : subst\n     ([x] [dx : of x T1] of/lam (D1 x dx : {y} of y T2 -> of (E1 x y) T3))\n     (D2 : of E2 T1)\n     (of/lam D)\n     <- ({y} {dy : of y T2}\n\t   subst ([x] [dx] D1 x dx y dy) D2 (D y dy : of (E1 E2 y) T3)).\n\n\n%worlds (bind) (subst _ _ _).\n%total D (subst D _ _).\n\nctx : type. %name ctx G.\nnil : ctx.\ncons : ctx -> exp -> tp -> ctx.\n\nappend : ctx -> ctx -> ctx -> type.\n\nappend/nil : append G nil G.\n\nappend/cons : append G1 (cons G2 X T) (cons G X T)\n\t       <- append G1 G2 G.\n\nlookup : ctx -> exp -> tp -> type.\n\nlookup/hit : lookup (cons G X T) X T.\n\nlookup/miss : lookup (cons G X' T') X T\n\t       <- lookup G X T.\n\nofe : ctx -> exp -> tp -> type.\n\nofe/closed : ofe G E T\n\t      <- of E T.\n\nofe/var : ofe G X T\n\t   <- lookup G X T.\n\nofe/p : ofe G p o = ofe/closed of/p.\n\nofe/app : ofe G (app E1 E2) T'\n\t   <- ofe G E1 (arr T T')\n\t   <- ofe G E2 T.\n\nofe/lam : ofe G (lam T ([x] E x)) (arr T T')\n\t   <- ({x} ofe (cons G x T) (E x) T').\n\nisvar : exp -> nat -> type.\n\n- : (isvar _ _ -> isvar _ _) -> type.\n\n%block ovar : some {I : nat} block {x : exp} {d : isvar x I}.\n\nprecedes : exp -> exp -> type.\n\nprecedes/i : precedes X Y\n\t      <- isvar X I\n\t      <- isvar Y J\n\t      <- lt I J.\n\nbounded : ctx -> exp -> type.\n\nbounded/nil : bounded nil X\n\t       <- isvar X _.\n\nbounded/cons : bounded (cons G X T) Y\n\t\t<- bounded G X\n\t\t<- precedes X Y.\n\nordered : ctx -> type.\n\nordered/nil : ordered nil.\n\nordered/cons : ordered (cons G X T)\n\t\t<- bounded G X.\n\nofe-resp : tp-eq A A' -> ofe G M A -> ofe G M A' -> type.\n%mode ofe-resp +D1 +D2 -D3.\n\n- : ofe-resp _ D D.\n\n%worlds (ovar | bind) (ofe-resp _ _ _).\n%total {} (ofe-resp _ _ _).\n\nbounded-isvar : bounded G X -> isvar X I -> type.\n%mode bounded-isvar +D1 -D2.\n\n- : bounded-isvar (bounded/nil D) D.\n\n- : bounded-isvar (bounded/cons (precedes/i _ D _) _) D.\n\n%worlds (ovar | bind) (bounded-isvar _ _).\n%total {} (bounded-isvar _ _).\n\n\nordered-extend : ordered G -> ({x} isvar x I -> bounded G x) -> type.\n%mode ordered-extend +D1 -D2.\n\n- : ordered-extend ordered/nil ([x] [dx : isvar x 0] bounded/nil dx).\n\n- : ordered-extend \n\t(ordered/cons (Dbounded : bounded G Y))\n\t([x] [dx : isvar x (s J)] \n\t\tbounded/cons\n\t\t(precedes/i Dlt dx Disvar)\n\t\tDbounded)\n\t<- bounded-isvar Dbounded (Disvar : isvar Y J)\n\t<- lt-succ J (Dlt : lt J (s J)).\n\n%worlds (ovar | bind) (ordered-extend _ _).\n%total {} (ordered-extend _ _).\n\nofe-weaken : append G1 G2 G -> ofe G1 M A -> ofe G M A -> type.\n%mode ofe-weaken +D1 +D2 -D3.\n\n%worlds (ovar | bind) (ofe-weaken _ _ _).\n%trustme %total {} (ofe-weaken _ _ _).\n\nbounded-ordered : bounded G X -> ordered G -> type.\n%mode bounded-ordered +D1 -D2.\n\n%worlds (ovar | bind) (bounded-ordered _ _).\n%trustme %total {} (bounded-ordered _ _).\n\nbounded-increase : bounded G X -> precedes X Y -> bounded G Y -> type.\n%mode bounded-increase +D1 +D2 -D3.\n\n%worlds (ovar | bind) (bounded-increase _ _ _).\n%trustme %total {} (bounded-increase _ _ _).\n\nlt-irreflex : lt N N -> false -> type.\n%mode lt-irreflex +X1 -X2.\n%worlds (bind | ovar) (lt-irreflex _ _).\n%trustme %total {} (lt-irreflex _ _).\n\n\nprecedes-contra : precedes X X -> false -> type.\n%mode precedes-contra +D1 -D2.\n\n- : precedes-contra (precedes/i (Dlt : lt I I) (Disvar : isvar X I) Disvar) DFalse\n     <- lt-irreflex Dlt DFalse.\n\n%worlds (bind | ovar) (precedes-contra _ _).\n%total {} (precedes-contra _ _).\n\nbounded-lookup-contra : bounded G X -> lookup G X A -> false -> type.\n%mode bounded-lookup-contra +D1 +D2 -D3.\n\n- : bounded-lookup-contra\n     (bounded/cons (Dprecedes : precedes Y X) (Dbounded : bounded G Y))\n     (lookup/miss (Dlookup : lookup G X A))\n     DFalse\n     <- bounded-increase Dbounded Dprecedes (Dbounded' : bounded G X)\n     <- bounded-lookup-contra Dbounded' Dlookup DFalse.\n\n- : bounded-lookup-contra\n     (bounded/cons (Dprecedes : precedes X X) _)\n     (lookup/hit)\n     DFalse\n     <- precedes-contra Dprecedes DFalse.\n\n%worlds (ovar | bind) (bounded-lookup-contra _ _ _).\n%total D (bounded-lookup-contra _ D _).\n\nfalse-implies-tp-eq : false -> {A} {B} tp-eq A B -> type.\n%mode false-implies-tp-eq +X1 +X2 +X3 -X4.\n%worlds (bind | ovar) (false-implies-tp-eq _ _ _ _).\n%total {} (false-implies-tp-eq _ _ _ _).\n\nfalse-implies-ofe : false -> {G} {M} {A} ofe G M A -> type.\n%mode false-implies-ofe +X1 +X2 +X3 +X4 -X5.\n%worlds (bind | ovar) (false-implies-ofe _ _ _ _ _).\n%total {} (false-implies-ofe _ _ _ _ _).\n\nappend-lookup-eq : ({x} append (cons G1 x A) G2 (G x))\n\t-> ({x} isvar x I -> ordered (G x))\n\t-> ({x} lookup (G x) x B)\n\t-> (tp-eq A B)\n\t-> type.\n%mode append-lookup-eq +D1 +D2 +D3 -D.\n\n- : append-lookup-eq _ _ ([x] lookup/hit) tp-eq/i.\n\n- : append-lookup-eq\n     ([x] append/cons (Dappend x : append (cons G1 x A) G2 (G x)))\n     ([x] [dx : isvar x I] ordered/cons (Dbounded x dx : bounded (G x) Y))\n     ([x] lookup/miss (Dlookup x : lookup (G x) x B))\n     Deq\n     <- ({x} {dx : isvar x I} bounded-ordered (Dbounded x dx) (Dordered x dx : ordered (G x)))\n     <- append-lookup-eq Dappend Dordered Dlookup (Deq : tp-eq A B).\n\n- : append-lookup-eq\n     ([x] append/nil)\n     ([x] [dx : isvar x I] ordered/cons (Dbounded x dx : bounded G1 x))\n     ([x] lookup/miss (Dlookup x : lookup G1 x B))\n     Deq\n     <- ({x} {dx} bounded-lookup-contra (Dbounded x dx) (Dlookup x) DFalse)\n     <- false-implies-tp-eq DFalse _ _ Deq.\n\n%worlds (bind | ovar) (append-lookup-eq _ _ _ _).\n%total D (append-lookup-eq D _ _ _).\n\nlookup-pdv : ({x} append (cons G1 x A) G2 (G x))\n\t      -> append G1 G2 G'\n\t      -> ({x} isvar x I -> ordered (G x)) %% Needed?\n\t      -> ({x} lookup (G x) Y B)\n\t      -> lookup G' Y B\n\t      -> type.\n%mode lookup-pdv +D1 +D2 +D3 +D4 -D5.\n\n%worlds (bind | ovar) (lookup-pdv _ _ _ _ _).\n%trustme %total {} (lookup-pdv _ _ _ _ _).\n\nlookup-ordered : ordered G\n\t\t  -> lookup G X A\n\t\t  -> isvar X I\n\t\t  -> type.\n%mode lookup-ordered +D1 +D2 -D3.\n\n%worlds (bind | ovar) (lookup-ordered _ _ _).\n%trustme %total {} (lookup-ordered _ _ _).\n\nlam-isvar-contra : isvar (lam A M) _\n\t\t    -> false\n\t\t    -> type.\n%mode lam-isvar-contra +D1 -D2.\n\n%worlds (bind | ovar) (lam-isvar-contra _ _).\n%total {} (lam-isvar-contra _ _).\n\napp-isvar-contra : isvar (app N M) _\n\t\t    -> false\n\t\t    -> type.\n%mode app-isvar-contra +D1 -D2.\n\n%worlds (bind | ovar) (app-isvar-contra _ _).\n%total {} (app-isvar-contra _ _).\n\n\nesubst : ({x} append (cons G1 x A) G2 (G x))\n\t  -> append G1 G2 G'\n\t  -> ({x} isvar x I -> ordered (G x))\n\t  -> ofe G1 N A\n\t  -> ({x} ofe (G x) (M x) B)\n%% \n\t  -> ofe G' (M N) B -> type.\n\n%mode esubst +D1 +D2 +D3 +D4 +D5 -D6.\n\n- : esubst\n     (Dappend : ({x} append (cons G1 x A) G2 (G x)))\n     (Dappend' : append G1 G2 G')\n     (Dordered : ({x} isvar x I -> ordered (G x)))\n     (DofeN : ofe G1 N A)\n     ([x] ofe/closed (DofM x : of (M x) B))\n     (ofe/closed (DofM N)).\n\n- : esubst\n\t(Dappend : ({x} append (cons G1 x A) G2 (G x)))\n\t(Dappend' : append G1 G2 G')\n\t(Dordered : ({x} isvar x I -> ordered (G x)))\n\t(DofeN : ofe G1 N A)\n\t([x] ofe/var (Dlookup x : lookup (G x) x B))\n\tDofeN''\n\t<- ofe-weaken Dappend' DofeN (DofeN' : ofe G' N A)\n\t<- append-lookup-eq Dappend Dordered Dlookup \n\t\t(Deq : tp-eq A B)\n\t<- ofe-resp Deq DofeN' (DofeN'' : ofe G' N B).\n\n- : esubst\n\t(Dappend : ({x} append (cons G1 x A) G2 (G x)))\n\t(Dappend' : append G1 G2 G')\n\t(Dordered : ({x} isvar x I -> ordered (G x)))\n\t(DofeN : ofe G1 N A)\n\t([x] ofe/var (Dlookup x : lookup (G x) Y B))\n        (ofe/var Dlookup')\n     <- lookup-pdv Dappend Dappend' Dordered Dlookup\n\t(Dlookup' : lookup G' Y B).\n\n- : esubst\n\t(Dappend : ({x} append (cons G1 x A) G2 (G x)))\n\t(Dappend' : append G1 G2 G')\n\t(Dordered : ({x} isvar x I -> ordered (G x)))\n\t(DofeN : ofe G1 N A)\n\t([x] ofe/var (Dlookup x : lookup (G x) (lam C (M x)) B))\n        Dofe\n     <- ({x} {dx : isvar x I}\n\t   lookup-ordered (Dordered x dx) (Dlookup x)\n\t   (Disvar x dx : isvar (lam C (M x)) J))\n     <- ({x} {dx : isvar x I} lam-isvar-contra (Disvar x dx) Dfalse)\n     <- false-implies-ofe Dfalse _ _ _ Dofe.\n\n- : esubst\n\t(Dappend : ({x} append (cons G1 x A) G2 (G x)))\n\t(Dappend' : append G1 G2 G')\n\t(Dordered : ({x} isvar x I -> ordered (G x)))\n\t(DofeN : ofe G1 N A)\n\t([x] ofe/var (Dlookup x : lookup (G x) (app (M' x) (M x)) B))\n        Dofe\n     <- ({x} {dx : isvar x I}\n\t   lookup-ordered (Dordered x dx) (Dlookup x)\n\t   (Disvar x dx : isvar (app (M' x) (M x)) J))\n     <- ({x} {dx : isvar x I} app-isvar-contra (Disvar x dx) Dfalse)\n     <- false-implies-ofe Dfalse _ _ _ Dofe.\n\n- : esubst\n     (Dappend : ({x} append (cons G1 x A) G2 (G x)))\n     (Dappend' : append G1 G2 G')\n     (Dordered : ({x} isvar x I -> ordered (G x)))\n     (DofeN : ofe G1 N A)\n     ([x] ofe/lam (DofeM x : {y} ofe (cons (G x) y B) (M x y) C))\n     (ofe/lam Dofe)\n\t <- ({x} {dx : isvar x I} ordered-extend (Dordered x dx) \n\t \t\t(Dbounded x dx : {y} isvar y J -> bounded (G x) y))\n     <- ({y} {dy : isvar y J} \n\t\tesubst ([x] append/cons (Dappend x))\n\t\t(append/cons Dappend')\n\t\t([x] [dx : isvar x I] \n\t\t\tordered/cons (Dbounded x dx y dy: bounded (G x) y))\n\t\tDofeN\n\t\t([x] DofeM x y)\n\t\t(Dofe y : ofe (cons G' y B) (M N y) C)).\n\n\n\n\n%worlds (bind | ovar) (esubst _ _ _ _ _ _).\n%trustme %total D (esubst _ _ _ _ D _).\n\nofi : ctx -> exp -> tp -> type.\n\nofi/nil : ofi nil M A\n\t   <- of M A.\n\nofi/cons : ofi (cons G X A) M B\n\t    <- ((of X A) -> ofi G M B).\n\n%block of-block : some {X:exp} {A:tp} block {dx : of X A}.\n\nofi-app : ofi G E1 (arr T T')\n\t   -> ofi G E2 T\n\t   -> ofi G (app E1 E2) T'\n\t   -> type.\n%mode ofi-app +D1 +D2 -D3.\n\n- : ofi-app\n     (ofi/nil (Dof1 : of E1 (arr T T')))\n     (ofi/nil (Dof2 : of E2 T))\n     (ofi/nil (of/app Dof2 Dof1)).\n\n- : ofi-app\n     (ofi/cons (Dof1 : of X A -> ofi G E1 (arr T T')))\n     (ofi/cons (Dof2 : of X A -> ofi G E2 T))\n     (ofi/cons Dof)\n     <- ({d : of X A} ofi-app (Dof1 d) (Dof2 d) (Dof d : ofi G (app E1 E2) T')).\n\n%worlds (bind | of-block | ovar) (ofi-app _ _ _).\n%total D (ofi-app D _ _).\n\nofe-implies-ofi : ofe G M A\n\t\t   -> ofi G M A\n\t\t   -> type.\n%mode ofe-implies-ofi +D1 -D2.\n\n- : ofe-implies-ofi\n     (ofe/app (Dof2 : ofe G E2 T) (Dof1 : ofe G E1 (arr T T')))\n     Dofi\n     <- ofe-implies-ofi Dof1 Dofi1\n     <- ofe-implies-ofi Dof2 Dofi2\n     <- ofi-app Dofi1 Dofi2 (Dofi : ofi G (app E1 E2) T').\n\n%worlds (bind | ovar) (ofe-implies-ofi _ _).\n%trustme %total D (ofe-implies-ofi D _).\n\nofe-implies-of : ofe nil M A\n\t\t  -> of M A\n\t\t  -> type.\n%mode ofe-implies-of +D1 -D2.\n\n- : ofe-implies-of\n     (Dofe : ofe nil M A)\n     Dof\n     <- ofe-implies-ofi Dofe (ofi/nil (Dof : of M A)).\n\n%worlds (bind) (ofe-implies-of _ _).\n%total {} (ofe-implies-of _ _).\n\ncut-of : {M}\n\t  ({x} of x A -> of (M x) B)\n\t  -> ({x} lookup (G x) x A)\n\t  -> ({x} ofe (G x) (M x) B)\n\t  -> type.\n%mode cut-of +D1 +D2 +D3 -D4.\n\n%worlds (bind | ovar) (cut-of _ _ _ _).\n%trustme %total {} (cut-of _ _ _ _).\n\nof1-implies-ofe : ({x} of x A -> of (M x) B)\n\t\t   -> ({x} ofe (cons nil x A) (M x) B)\n\t\t   -> type.\n%mode of1-implies-ofe +D1 -D2.\n\n- : of1-implies-ofe\n     (Dof : {x} of x A -> of (M x) B)\n     Dofe\n     <- cut-of M Dof ([x] lookup/hit) (Dofe : {x} ofe (cons nil x A) (M x) B).\n\n%worlds (bind) (of1-implies-ofe _ _).\n%total {} (of1-implies-ofe _ _).\n\nsubst : ({x} of x T1 -> of (E1 x) T2)\n\t -> of E2 T1\n\t -> of (E1 E2) T2\n\t -> type.\n%mode subst +D1 +D2 -D3.\n\n- : subst\n     (Dof1 : {x} of x T1 -> of (E1 x) T2)\n     (Dof2 : of E2 T1)\n     Dof\n     <- of1-implies-ofe Dof1 (Dofe1 : {x} ofe (cons nil x T1) (E1 x) T2)\n     <- esubst\n\t([x] append/nil)\n\tappend/nil\n\t([x] [dx : isvar x 0] ordered/cons (bounded/nil dx))\n\t(ofe/closed Dof2)\n\tDofe1\n\t(Dofe : ofe nil (E1 E2) T2)\n     <- ofe-implies-of Dofe (Dof : of (E1 E2) T2).\n\n%worlds (bind) (subst _ _ _).\n%total {} (subst _ _ _)."
          },
          "sha1": "9xxxzgracj5fkz1lt7fndhkgk3g24zq"
        }
      },
      {
        "title": "Computation and Deduction 2009/20090429",
        "ns": 0,
        "id": 2213,
        "revision": {
          "id": 6000,
          "timestamp": "2009-04-29T19:16:22Z",
          "contributor": {
            "username": "Crary",
            "id": 13
          },
          "comment": "Created page with '%{ Code from class, April 29. }%  false : type.  nat : type. %name nat N.  0 : nat. s : nat -> nat.  lt : nat -> nat -> type.  lt/0 : lt 0 (s N).  lt/s : lt (s M) (s N) \t<- lt M ...'",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 15550,
            "#text": "%{ Code from class, April 29. }%\n\nfalse : type.\n\nnat : type. %name nat N.\n\n0 : nat.\ns : nat -> nat.\n\nlt : nat -> nat -> type.\n\nlt/0 : lt 0 (s N).\n\nlt/s : lt (s M) (s N)\n\t<- lt M N.\n\nlt-succ : {N : nat} lt N (s N) -> type.\n%mode lt-succ +N -D.\n\n%worlds () (lt-succ _ _).\n%trustme %total N (lt-succ N _).\n\ntp : type. %name tp T.\n\nexp : type. %name exp E x.\n\no : tp.\narr : tp -> tp -> tp.\n\np : exp.\nlam : tp ->  (exp -> exp) -> exp.\napp : exp -> exp -> exp.\n\n%% - : (exp -> tp) -> type.\n\ntp-eq : tp -> tp -> type.\n\ntp-eq/i : tp-eq A A.\n\nof : exp -> tp -> type.\n\nof/p : of p o.\nof/lam : of (lam T ([x] E x)) (arr T T')\n\t  <- ({x} of x T -> of (E x) T').\nof/app : of (app E1 E2) T'\n\t  <- of E1 (arr T T')\n\t  <- of E2 T.\n\n%block bind : some {T : tp} block {x :exp} {dx : of x T}.\n\nsubst : ({x} of x T1 -> of (E1 x) T2) -> of E2 T1 -> of (E1 E2) T2 -> type.\n%mode subst +D1 +D2 -D3.\n\n%% - : subst D1 D2 (D1 _ D2).\n\n- : subst ([x] [d : of x T1] d) (D2 : of E2 T1) D2.\n\n- : subst ([x] [d : of x T1] D1) _ D1.\n\n- : subst \n     ([x] [d : of x T1]\n\tof/app\n\t(D12 x d : of (E12 x) T2)\n\t(D11 x d : of (E11 x) (arr T2 T3)))\n     (D2 : of E2 T1)\n     (of/app D12' D11')\n     <- subst D11 D2 (D11' : of (E11 E2) (arr T2 T3))\n     <- subst D12 D2 (D12' : of (E12 E2) T2).\n\n- : subst\n     ([x] [dx : of x T1] of/lam (D1 x dx : {y} of y T2 -> of (E1 x y) T3))\n     (D2 : of E2 T1)\n     (of/lam D)\n     <- ({y} {dy : of y T2}\n\t   subst ([x] [dx] D1 x dx y dy) D2 (D y dy : of (E1 E2 y) T3)).\n\n\n%worlds (bind) (subst _ _ _).\n%total D (subst D _ _).\n\nctx : type. %name ctx G.\nnil : ctx.\ncons : ctx -> exp -> tp -> ctx.\n\nappend : ctx -> ctx -> ctx -> type.\n\nappend/nil : append G nil G.\n\nappend/cons : append G1 (cons G2 X T) (cons G X T)\n\t       <- append G1 G2 G.\n\nlookup : ctx -> exp -> tp -> type.\n\nlookup/hit : lookup (cons G X T) X T.\n\nlookup/miss : lookup (cons G X' T') X T\n\t       <- lookup G X T.\n\nofe : ctx -> exp -> tp -> type.\n\nofe/closed : ofe G E T\n\t      <- of E T.\n\nofe/var : ofe G X T\n\t   <- lookup G X T.\n\nofe/p : ofe G p o = ofe/closed of/p.\n\nofe/app : ofe G (app E1 E2) T'\n\t   <- ofe G E1 (arr T T')\n\t   <- ofe G E2 T.\n\nofe/lam : ofe G (lam T ([x] E x)) (arr T T')\n\t   <- ({x} ofe (cons G x T) (E x) T').\n\nisvar : exp -> nat -> type.\n\n- : (isvar _ _ -> isvar _ _) -> type.\n\n%block ovar : some {I : nat} block {x : exp} {d : isvar x I}.\n\nprecedes : exp -> exp -> type.\n\nprecedes/i : precedes X Y\n\t      <- isvar X I\n\t      <- isvar Y J\n\t      <- lt I J.\n\nbounded : ctx -> exp -> type.\n\nbounded/nil : bounded nil X\n\t       <- isvar X _.\n\nbounded/cons : bounded (cons G X T) Y\n\t\t<- bounded G X\n\t\t<- precedes X Y.\n\nordered : ctx -> type.\n\nordered/nil : ordered nil.\n\nordered/cons : ordered (cons G X T)\n\t\t<- bounded G X.\n\nofe-resp : tp-eq A A' -> ofe G M A -> ofe G M A' -> type.\n%mode ofe-resp +D1 +D2 -D3.\n\n- : ofe-resp _ D D.\n\n%worlds (ovar | bind) (ofe-resp _ _ _).\n%total {} (ofe-resp _ _ _).\n\nbounded-isvar : bounded G X -> isvar X I -> type.\n%mode bounded-isvar +D1 -D2.\n\n- : bounded-isvar (bounded/nil D) D.\n\n- : bounded-isvar (bounded/cons (precedes/i _ D _) _) D.\n\n%worlds (ovar | bind) (bounded-isvar _ _).\n%total {} (bounded-isvar _ _).\n\n\nordered-extend : ordered G -> ({x} isvar x I -> bounded G x) -> type.\n%mode ordered-extend +D1 -D2.\n\n- : ordered-extend ordered/nil ([x] [dx : isvar x 0] bounded/nil dx).\n\n- : ordered-extend \n\t(ordered/cons (Dbounded : bounded G Y))\n\t([x] [dx : isvar x (s J)] \n\t\tbounded/cons\n\t\t(precedes/i Dlt dx Disvar)\n\t\tDbounded)\n\t<- bounded-isvar Dbounded (Disvar : isvar Y J)\n\t<- lt-succ J (Dlt : lt J (s J)).\n\n%worlds (ovar | bind) (ordered-extend _ _).\n%total {} (ordered-extend _ _).\n\nofe-weaken : append G1 G2 G -> ofe G1 M A -> ofe G M A -> type.\n%mode ofe-weaken +D1 +D2 -D3.\n\n%worlds (ovar | bind) (ofe-weaken _ _ _).\n%trustme %total {} (ofe-weaken _ _ _).\n\nbounded-ordered : bounded G X -> ordered G -> type.\n%mode bounded-ordered +D1 -D2.\n\n%worlds (ovar | bind) (bounded-ordered _ _).\n%trustme %total {} (bounded-ordered _ _).\n\nbounded-increase : bounded G X -> precedes X Y -> bounded G Y -> type.\n%mode bounded-increase +D1 +D2 -D3.\n\n%worlds (ovar | bind) (bounded-increase _ _ _).\n%trustme %total {} (bounded-increase _ _ _).\n\nlt-irreflex : lt N N -> false -> type.\n%mode lt-irreflex +X1 -X2.\n%worlds (bind | ovar) (lt-irreflex _ _).\n%trustme %total {} (lt-irreflex _ _).\n\n\nprecedes-contra : precedes X X -> false -> type.\n%mode precedes-contra +D1 -D2.\n\n- : precedes-contra (precedes/i (Dlt : lt I I) (Disvar : isvar X I) Disvar) DFalse\n     <- lt-irreflex Dlt DFalse.\n\n%worlds (bind | ovar) (precedes-contra _ _).\n%total {} (precedes-contra _ _).\n\nbounded-lookup-contra : bounded G X -> lookup G X A -> false -> type.\n%mode bounded-lookup-contra +D1 +D2 -D3.\n\n- : bounded-lookup-contra\n     (bounded/cons (Dprecedes : precedes Y X) (Dbounded : bounded G Y))\n     (lookup/miss (Dlookup : lookup G X A))\n     DFalse\n     <- bounded-increase Dbounded Dprecedes (Dbounded' : bounded G X)\n     <- bounded-lookup-contra Dbounded' Dlookup DFalse.\n\n- : bounded-lookup-contra\n     (bounded/cons (Dprecedes : precedes X X) _)\n     (lookup/hit)\n     DFalse\n     <- precedes-contra Dprecedes DFalse.\n\n%worlds (ovar | bind) (bounded-lookup-contra _ _ _).\n%total D (bounded-lookup-contra _ D _).\n\nfalse-implies-tp-eq : false -> {A} {B} tp-eq A B -> type.\n%mode false-implies-tp-eq +X1 +X2 +X3 -X4.\n%worlds (bind | ovar) (false-implies-tp-eq _ _ _ _).\n%total {} (false-implies-tp-eq _ _ _ _).\n\nfalse-implies-ofe : false -> {G} {M} {A} ofe G M A -> type.\n%mode false-implies-ofe +X1 +X2 +X3 +X4 -X5.\n%worlds (bind | ovar) (false-implies-ofe _ _ _ _ _).\n%total {} (false-implies-ofe _ _ _ _ _).\n\nappend-lookup-eq : ({x} append (cons G1 x A) G2 (G x))\n\t-> ({x} isvar x I -> ordered (G x))\n\t-> ({x} lookup (G x) x B)\n\t-> (tp-eq A B)\n\t-> type.\n%mode append-lookup-eq +D1 +D2 +D3 -D.\n\n- : append-lookup-eq _ _ ([x] lookup/hit) tp-eq/i.\n\n- : append-lookup-eq\n     ([x] append/cons (Dappend x : append (cons G1 x A) G2 (G x)))\n     ([x] [dx : isvar x I] ordered/cons (Dbounded x dx : bounded (G x) Y))\n     ([x] lookup/miss (Dlookup x : lookup (G x) x B))\n     Deq\n     <- ({x} {dx : isvar x I} bounded-ordered (Dbounded x dx) (Dordered x dx : ordered (G x)))\n     <- append-lookup-eq Dappend Dordered Dlookup (Deq : tp-eq A B).\n\n- : append-lookup-eq\n     ([x] append/nil)\n     ([x] [dx : isvar x I] ordered/cons (Dbounded x dx : bounded G1 x))\n     ([x] lookup/miss (Dlookup x : lookup G1 x B))\n     Deq\n     <- ({x} {dx} bounded-lookup-contra (Dbounded x dx) (Dlookup x) DFalse)\n     <- false-implies-tp-eq DFalse _ _ Deq.\n\n%worlds (bind | ovar) (append-lookup-eq _ _ _ _).\n%total D (append-lookup-eq D _ _ _).\n\nlookup-pdv : ({x} append (cons G1 x A) G2 (G x))\n\t      -> append G1 G2 G'\n\t      -> ({x} isvar x I -> ordered (G x)) %% Needed?\n\t      -> ({x} lookup (G x) Y B)\n\t      -> lookup G' Y B\n\t      -> type.\n%mode lookup-pdv +D1 +D2 +D3 +D4 -D5.\n\n%worlds (bind | ovar) (lookup-pdv _ _ _ _ _).\n%trustme %total {} (lookup-pdv _ _ _ _ _).\n\nlookup-ordered : ordered G\n\t\t  -> lookup G X A\n\t\t  -> isvar X I\n\t\t  -> type.\n%mode lookup-ordered +D1 +D2 -D3.\n\n%worlds (bind | ovar) (lookup-ordered _ _ _).\n%trustme %total {} (lookup-ordered _ _ _).\n\nlam-isvar-contra : isvar (lam A M) _\n\t\t    -> false\n\t\t    -> type.\n%mode lam-isvar-contra +D1 -D2.\n\n%worlds (bind | ovar) (lam-isvar-contra _ _).\n%total {} (lam-isvar-contra _ _).\n\napp-isvar-contra : isvar (app N M) _\n\t\t    -> false\n\t\t    -> type.\n%mode app-isvar-contra +D1 -D2.\n\n%worlds (bind | ovar) (app-isvar-contra _ _).\n%total {} (app-isvar-contra _ _).\n\n\nesubst : ({x} append (cons G1 x A) G2 (G x))\n\t  -> append G1 G2 G'\n\t  -> ({x} isvar x I -> ordered (G x))\n\t  -> ofe G1 N A\n\t  -> ({x} ofe (G x) (M x) B)\n%% \n\t  -> ofe G' (M N) B -> type.\n\n%mode esubst +D1 +D2 +D3 +D4 +D5 -D6.\n\n- : esubst\n     (Dappend : ({x} append (cons G1 x A) G2 (G x)))\n     (Dappend' : append G1 G2 G')\n     (Dordered : ({x} isvar x I -> ordered (G x)))\n     (DofeN : ofe G1 N A)\n     ([x] ofe/closed (DofM x : of (M x) B))\n     (ofe/closed (DofM N)).\n\n- : esubst\n\t(Dappend : ({x} append (cons G1 x A) G2 (G x)))\n\t(Dappend' : append G1 G2 G')\n\t(Dordered : ({x} isvar x I -> ordered (G x)))\n\t(DofeN : ofe G1 N A)\n\t([x] ofe/var (Dlookup x : lookup (G x) x B))\n\tDofeN''\n\t<- ofe-weaken Dappend' DofeN (DofeN' : ofe G' N A)\n\t<- append-lookup-eq Dappend Dordered Dlookup \n\t\t(Deq : tp-eq A B)\n\t<- ofe-resp Deq DofeN' (DofeN'' : ofe G' N B).\n\n- : esubst\n\t(Dappend : ({x} append (cons G1 x A) G2 (G x)))\n\t(Dappend' : append G1 G2 G')\n\t(Dordered : ({x} isvar x I -> ordered (G x)))\n\t(DofeN : ofe G1 N A)\n\t([x] ofe/var (Dlookup x : lookup (G x) Y B))\n        (ofe/var Dlookup')\n     <- lookup-pdv Dappend Dappend' Dordered Dlookup\n\t(Dlookup' : lookup G' Y B).\n\n- : esubst\n\t(Dappend : ({x} append (cons G1 x A) G2 (G x)))\n\t(Dappend' : append G1 G2 G')\n\t(Dordered : ({x} isvar x I -> ordered (G x)))\n\t(DofeN : ofe G1 N A)\n\t([x] ofe/var (Dlookup x : lookup (G x) (lam C (M x)) B))\n        Dofe\n     <- ({x} {dx : isvar x I}\n\t   lookup-ordered (Dordered x dx) (Dlookup x)\n\t   (Disvar x dx : isvar (lam C (M x)) J))\n     <- ({x} {dx : isvar x I} lam-isvar-contra (Disvar x dx) Dfalse)\n     <- false-implies-ofe Dfalse _ _ _ Dofe.\n\n- : esubst\n\t(Dappend : ({x} append (cons G1 x A) G2 (G x)))\n\t(Dappend' : append G1 G2 G')\n\t(Dordered : ({x} isvar x I -> ordered (G x)))\n\t(DofeN : ofe G1 N A)\n\t([x] ofe/var (Dlookup x : lookup (G x) (app (M' x) (M x)) B))\n        Dofe\n     <- ({x} {dx : isvar x I}\n\t   lookup-ordered (Dordered x dx) (Dlookup x)\n\t   (Disvar x dx : isvar (app (M' x) (M x)) J))\n     <- ({x} {dx : isvar x I} app-isvar-contra (Disvar x dx) Dfalse)\n     <- false-implies-ofe Dfalse _ _ _ Dofe.\n\n- : esubst\n     (Dappend : ({x} append (cons G1 x A) G2 (G x)))\n     (Dappend' : append G1 G2 G')\n     (Dordered : ({x} isvar x I -> ordered (G x)))\n     (DofeN : ofe G1 N A)\n     ([x] ofe/lam (DofeM x : {y} ofe (cons (G x) y B) (M x y) C))\n     (ofe/lam Dofe)\n\t <- ({x} {dx : isvar x I} ordered-extend (Dordered x dx) \n\t \t\t(Dbounded x dx : {y} isvar y J -> bounded (G x) y))\n     <- ({y} {dy : isvar y J} \n\t\tesubst ([x] append/cons (Dappend x))\n\t\t(append/cons Dappend')\n\t\t([x] [dx : isvar x I] \n\t\t\tordered/cons (Dbounded x dx y dy: bounded (G x) y))\n\t\tDofeN\n\t\t([x] DofeM x y)\n\t\t(Dofe y : ofe (cons G' y B) (M N y) C)).\n\n%worlds (bind | ovar) (esubst _ _ _ _ _ _).\n%trustme %total D (esubst _ _ _ _ D _).\n\nofi : ctx -> exp -> tp -> type.\n\nofi/nil : ofi nil M A\n\t   <- of M A.\n\nofi/cons : ofi (cons G X A) M B\n\t    <- ((of X A) -> ofi G M B).\n\n%block of-block : some {X:exp} {A:tp} block {dx : of X A}.\n\nofi-app : ofi G E1 (arr T T')\n\t   -> ofi G E2 T\n\t   -> ofi G (app E1 E2) T'\n\t   -> type.\n%mode ofi-app +D1 +D2 -D3.\n\n- : ofi-app\n     (ofi/nil (Dof1 : of E1 (arr T T')))\n     (ofi/nil (Dof2 : of E2 T))\n     (ofi/nil (of/app Dof2 Dof1)).\n\n- : ofi-app\n     (ofi/cons (Dof1 : of X A -> ofi G E1 (arr T T')))\n     (ofi/cons (Dof2 : of X A -> ofi G E2 T))\n     (ofi/cons Dof)\n     <- ({d : of X A} ofi-app (Dof1 d) (Dof2 d) (Dof d : ofi G (app E1 E2) T')).\n\n%worlds (bind | of-block | ovar) (ofi-app _ _ _).\n%total D (ofi-app D _ _).\n\nofe-implies-ofi : ofe G M A\n\t\t   -> ofi G M A\n\t\t   -> type.\n%mode ofe-implies-ofi +D1 -D2.\n\n- : ofe-implies-ofi\n     (ofe/app (Dof2 : ofe G E2 T) (Dof1 : ofe G E1 (arr T T')))\n     Dofi\n     <- ofe-implies-ofi Dof1 Dofi1\n     <- ofe-implies-ofi Dof2 Dofi2\n     <- ofi-app Dofi1 Dofi2 (Dofi : ofi G (app E1 E2) T').\n\n%worlds (bind | ovar) (ofe-implies-ofi _ _).\n%trustme %total D (ofe-implies-ofi D _).\n\nofe-implies-of : ofe nil M A\n\t\t  -> of M A\n\t\t  -> type.\n%mode ofe-implies-of +D1 -D2.\n\n- : ofe-implies-of\n     (Dofe : ofe nil M A)\n     Dof\n     <- ofe-implies-ofi Dofe (ofi/nil (Dof : of M A)).\n\n%worlds (bind) (ofe-implies-of _ _).\n%total {} (ofe-implies-of _ _).\n\ncut-of : {M}\n\t  ({x} of x A -> of (M x) B)\n\t  -> ({x} lookup (G x) x A)\n\t  -> ({x} ofe (G x) (M x) B)\n\t  -> type.\n%mode cut-of +D1 +D2 +D3 -D4.\n\ncut-ofe : {M}\n\t   ({x} of x A -> ofe (G x) (M x) B)\n\t  -> ({x} lookup (G x) x A)\n\t  -> ({x} ofe (G x) (M x) B)\n\t  -> type.\n%mode cut-ofe +D1 +D2 +D3 -D4.\n\n- : cut-ofe\n     ([x] lam B ([y] M x y))\n     ([x] [dx:of x A] ofe/lam (Dofe x dx : {y} ofe (cons (G x) y B) (M x y) C))\n     (Dlookup : {x} lookup (G x) x A)\n     ([x] ofe/lam ([y] Dofe' x y))\n     <- ({y} cut-ofe ([x] M x y)\n\t   ([x] [dx : of x A] Dofe x dx y)\n\t   ([x] lookup/miss (Dlookup x))\n\t   ([x] Dofe' x y : ofe (cons (G x) y B) (M x y) C)).\n\n- : cut-ofe\n     ([x] app (M x) (N x))\n     ([x] [dx : of x A] ofe/app (Dof2 x dx) (Dof1 x dx))\n     Dlookup\n     ([x] ofe/app (Dofe2 x) (Dofe1 x))\n     <- cut-ofe M Dof1 Dlookup Dofe1\n     <- cut-ofe N Dof2 Dlookup Dofe2.\n\n- : cut-ofe\n     _\n     ([x] [dx : of x A] ofe/var (Dlookup x : lookup (G x) (Y x) B))\n     _\n     ([x] ofe/var (Dlookup x)).\n\n- : cut-of\n     ([x] app (M x) (N x))\n     ([x] [dx : of x A] of/app (Dof2 x dx) (Dof1 x dx))\n     Dlookup\n     ([x] ofe/app (Dofe2 x) (Dofe1 x))\n     <- cut-of M Dof1 Dlookup Dofe1\n     <- cut-of N Dof2 Dlookup Dofe2.\n\n- : cut-ofe\n     M\n     ([x] [dx : of x A] ofe/closed (Dof x dx : of (M x) B))\n     (Dlookup : {x} lookup (G x) x A)\n     Dofe\n     <- cut-of M Dof Dlookup (Dofe : {x} ofe (G x) (M x) B).\n\n- : cut-of\n     ([x] lam B ([y] M x y))\n     ([x] [dx:of x A] of/lam (Dof x dx : {y} of y B -> of (M x y) C))\n     (Dlookup : {x} lookup (G x) x A)\n     ([x] ofe/lam ([y] Dofe' x y))\n     <- ({x} {dx : of x A}\n\t   cut-of ([y] M x y) ([y] [dy: of y B] Dof x dx y dy) ([y] lookup/hit : lookup (cons (G x) y B) y B)\n\t   (Dofe x dx : {y} ofe (cons (G x) y B) (M x y) C))\n     <- ({y} cut-ofe ([x] M x y)\n\t   ([x] [dx : of x A] Dofe x dx y)\n\t   ([x] lookup/miss (Dlookup x))\n\t   ([x] Dofe' x y : ofe (cons (G x) y B) (M x y) C)).\n\n- : cut-of\n     _\n     ([x] [d:of x A] d)\n     (Dlookup : {x} lookup (G x) x A)\n     ([x] ofe/var (Dlookup x)).\n\n- : cut-of\n     _\n     ([x] [d:of x A] Dof : of M B)\n     _\n     ([x] ofe/closed Dof).\n\n%block var : block {x : exp}.\n\n%worlds (bind | var) (cut-of _ _ _ _) (cut-ofe _ _ _ _).\n%total (M1 M2) (cut-of M1 _ _ _) (cut-ofe M2 _ _ _).\n\nof1-implies-ofe : ({x} of x A -> of (M x) B)\n\t\t   -> ({x} ofe (cons nil x A) (M x) B)\n\t\t   -> type.\n%mode of1-implies-ofe +D1 -D2.\n\n- : of1-implies-ofe\n     (Dof : {x} of x A -> of (M x) B)\n     Dofe\n     <- cut-of M Dof ([x] lookup/hit) (Dofe : {x} ofe (cons nil x A) (M x) B).\n\n%worlds (bind) (of1-implies-ofe _ _).\n%total {} (of1-implies-ofe _ _).\n\nof2-implies-ofe : ({x} of x A -> {y} of y B -> of (M x y) C)\n\t\t   -> ({x} {y} ofe (cons (cons nil x A) y B) (M x y) C)\n\t\t   -> type.\n%mode of2-implies-ofe +D1 -D2.\n\n- : of2-implies-ofe\n     (Dof : {x} of x A -> {y} of y B -> of (M x y) C)\n     Dofe'\n     <- ({x} {dx : of x A} cut-of ([y] M x y) ([y] [dy : of y B] (Dof x dx y dy)) ([y] lookup/hit)\n\t   (Dofe x dx : {y} ofe (cons (cons nil x A) y B) (M x y) C))\n     <- ({y} cut-ofe ([x] M x y) ([x] [dx : of x A] Dofe x dx y) ([x] lookup/miss lookup/hit)\n\t   ([x] Dofe' x y : ofe (cons (cons nil x A) y B) (M x y) C)).\n\n%worlds (bind) (of2-implies-ofe _ _).\n%total {} (of2-implies-ofe _ _).\n\nsubst : ({x} of x T1 -> of (E1 x) T2)\n\t -> of E2 T1\n\t -> of (E1 E2) T2\n\t -> type.\n%mode subst +D1 +D2 -D3.\n\n- : subst\n     (Dof1 : {x} of x T1 -> of (E1 x) T2)\n     (Dof2 : of E2 T1)\n     Dof\n     <- of1-implies-ofe Dof1 (Dofe1 : {x} ofe (cons nil x T1) (E1 x) T2)\n     <- esubst\n\t([x] append/nil)\n\tappend/nil\n\t([x] [dx : isvar x 0] ordered/cons (bounded/nil dx))\n\t(ofe/closed Dof2)\n\tDofe1\n\t(Dofe : ofe nil (E1 E2) T2)\n     <- ofe-implies-of Dofe (Dof : of (E1 E2) T2).\n\n%worlds (bind) (subst _ _ _).\n%total {} (subst _ _ _)."
          },
          "sha1": "r3ynsjah7a6eqk2pknst8zp2xv6kfn4"
        }
      },
      {
        "title": "Computation and Deduction 2009/Test Page 1",
        "ns": 0,
        "id": 2177,
        "revision": {
          "id": 5860,
          "parentid": 5859,
          "timestamp": "2009-02-04T22:49:09Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 70,
            "#text": "\n\n%{ Notes }%\n\nnat : type.\nz: nat.\ns: nat -> nat.\n\nplus : nat -> type."
          },
          "sha1": "e66laadjunogr8tjksv44dsbyfn27hz"
        }
      },
      {
        "title": "Concrete representation",
        "ns": 0,
        "id": 2007,
        "revision": {
          "id": 7956,
          "parentid": 5059,
          "timestamp": "2013-09-02T20:57:22Z",
          "contributor": {
            "ip": "82.69.27.23"
          },
          "comment": "typo",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 30432,
            "#text": "%{ The use of [[higher-order abstract syntax]], using Twelf's binding structure\nto represent binding structure in an encoded language,\nis one of the more unique and convenient\naspects of using Twelf. However, the fundamental nature of the binding \nstructure has been troubling to some, because it is not obvious that \neverything you might ever want to do to a lambda term is doable within the \nframework of HOAS. \n\nOne way to deal with this question is to show that there is a bijection between\nHOAS terms in Twelf and some '''concrete representation''' of terms with bound \nvariables. \nIn that case, any arbitrary operation on the concrete representation can be \nrelated\nto an operation in the HOAS representation by translating the HOAS term into\nconcrete form, performing the operation on the concrete term, and translating \nit back into HOAS. That said, we do not know of any practical proof that has \nrequired this technique.\n\nThe technique of de Bruijn indices, described fully\n[[w:de Bruijn index|on Wikipedia]], is a popular technique\nfor concretely representing binding structures.\nThis page describes a bijection between closed de Bruijn indices and closed \nHOAS terms, and proves that bijection correct. \nWe will use a modified version of de Bruijn indices - it was easier to \nstart counting from 0, whereas true de Bruijn indices count from 1. The \nbijection is defined using two relations, <tt>exp-->db</tt> and \n<tt>db-->exp</tt>. We prove the bijection is correct in four steps:\n\n# <tt>exp-->db</tt> is a total and unique relation between HOAS to de Bruijn terms, and can therefore be thought of as the function ''e2d''.\n# <tt>db-->exp</tt> is a total and unique relation between de Bruijn terms to HOAS, and can therefore be thought of as the function ''d2e''.\n# For all closed de Bruijn terms E, ''d2e''(''e2d'' E) = E\n# For all closed HOAS terms E, ''e2d'' (''d2e'' E) = E\n\nWe do not prove that the \nbijection is an isomorphism - both HOAS and de Bruijn indices have a built-in\nnotion of \"substitution,\" and a proof of isomorphism would require us to\ndefine substitution on our de Bruijn terms and show that substitution behaves\nthe same way in the de Bruijn representation as it does in the HOAS \nrepresentation.\n\nThis encoding makes heavy use of [[intrinsic encoding]] in representing\nde Bruijn terms, both to ensure\nwell-formedness of all terms and to encode a [[structural metric]] directly\ninto the type of a de Bruijn term. The proof could also be done with\n[[extrinsic encoding]] by having a separate well-formedness judgment for\nde Bruijn terms and a separate judgment relating a de Bruijn term to the\nstructural metric it corresponds to, but in this example the intrinsic \napproach made the proofs simpler.\n}% %{ }%\n\n%{ == Preliminaries == }%\n\n%{ We will need the ability to use [[reasoning from false]] at one place \nto avoid a spurious case that [[coverage checking]] does not deal with\ncorrectly, and as is the case with many examples, we will utilize\n[[natural numbers]] extensively.. }%  \n\nuninhabited : type.\n%freeze uninhabited.\n\nnat : type.\nz : nat.\ns : nat -> nat.\n\nid-nat : nat -> nat -> type.\nid-nat/refl : id-nat N N.\n\n%{ We will also need a less-than relation on numbers. For reasons that will\nbecome clear, we will also need to define an [[identity]] on less-than \nderivations. Finally, we define <tt>lt12</tt>, which allows us to take\ntwo numbers N < M and case analyze on whether (s N) = M or (s N) < M. }%\n\nlt : nat -> nat -> type.\nlt/z : lt z (s N).\nlt/s : lt (s N1) (s N2) <- lt N1 N2.\n\nid-lt : lt N M -> lt N' M' -> type.\nid-lt/refl : id-lt L L.\n\nlt12 : nat -> nat -> type.\nlt12/1 : lt12 N (s N).\nlt12/2 : lt12 N (s M) <- lt N M.\n\n%{ Finally, we define two helper functions <tt>lt+</tt>, which produces\na derivation M < (N + 1) from a derivation of M < N, and <tt>lts</tt>, which\nproduces a derivation of N < (s N) from any natural number N. Most\nof the tedious reasoning required for this example is about trivial \nproperties of these two helper functions; it is hidden here but\ncan be revealed by clicking on the source code link at the top of the page. }%\n\nlt+ : lt M N -> lt M (s N) -> type.\n%mode lt+ +D -D2.\nlt+/z : lt+ lt/z lt/z.\nlt+/s : lt+ (lt/s LT1) (lt/s LT2) <- lt+ LT1 LT2.\n%worlds() (lt+ _ _).\n%total T (lt+ T _).\n\nlts : {N} lt N (s N) -> type.\n%mode lts +N -LT.\nlts/z : lts z lt/z.\nlts/s : lts (s N) (lt/s D) <- lts N D.\n%worlds () (lts _ _).\n%total T (lts T _).\n\n%{| hidden=true }%\n\nlt+-irrev : {L1: lt N1 N2} lt+ L1 L2 -> {L1': lt N1 N2} lt+ L1' L2 -> type.\n%mode lt+-irrev +L1 +L2 +L1' -L3.\n- : lt+-irrev lt/z lt+/z lt/z lt+/z.\n- : lt+-irrev (lt/s L1) (lt+/s L1+) (lt/s L2) (lt+/s L2+)\n     <- lt+-irrev L1 L1+ L2 L2+.\n%worlds () (lt+-irrev _ _ _ _).\n%total T (lt+-irrev T _ _ _).\n\n\ncan-lts : {N}{LT: lt N (s N)} lts N LT -> type.\n%mode can-lts +N +LT -LTS.\n- : can-lts z _ lts/z.\n- : can-lts (s N) (lt/s LT) (lts/s LTS) <- can-lts N LT LTS.\n%worlds () (can-lts _ _ _).\n%total T (can-lts T _ _).\n\ncan-lt+ : {LT: lt M N}{LT': lt M (s N)} lt+ LT LT' -> type.\n%mode can-lt+ +LT +LT' -LT+.\n- : can-lt+ lt/z lt/z lt+/z.\n- : can-lt+ (lt/s LT) (lt/s LT') (lt+/s LT+) <- can-lt+ LT LT' LT+.\n%worlds () (can-lt+ _ _ _).\n%total T (can-lt+ T _ _).\n\nlt-s-cong : id-lt L1 L1' -> id-lt (lt/s L1) (lt/s L1') -> type.\n%mode lt-s-cong +ID1 -ID2.\n- : lt-s-cong id-lt/refl id-lt/refl.\n%worlds () (lt-s-cong _ _).\n%total {} (lt-s-cong _ _).\n\nlt+-uniq : id-lt L1 L2 -> lt+ L1 L1' -> lt+ L2 L2' -> id-lt L1' L2' -> type.\n%mode lt+-uniq +ID +L1 +L2 -ID2.\n- : lt+-uniq id-lt/refl lt+/z lt+/z id-lt/refl.\n- : lt+-uniq id-lt/refl (lt+/s LT+1) (lt+/s LT+2) ID\n     <- lt+-uniq id-lt/refl LT+1 LT+2 ID2\n     <- lt-s-cong ID2 ID.\n%worlds () (lt+-uniq _ _ _ _).\n%total T (lt+-uniq _ T _ _).\n\nlts-uniq : id-nat N1 N2 -> lts N1 L1 -> lts N2 L2 -> id-lt L1 L2 -> type.\n%mode lts-uniq +ID +L1 +L2 -ID2.\n- : lts-uniq id-nat/refl lts/z lts/z id-lt/refl.\n- : lts-uniq id-nat/refl (lts/s LT1) (lts/s LT2) ID\n     <- lts-uniq id-nat/refl LT1 LT2 ID1\n     <- lt-s-cong ID1 ID.\n%worlds () (lts-uniq _ _ _ _).\n%total T (lts-uniq _ T _ _).\n\n\nlt-opt-s : lt12 N M -> lt12 (s N) (s M) -> type.\n%mode lt-opt-s +D -D2.\nlt-opt-s/1 : lt-opt-s lt12/1 lt12/1.\nlt-opt-s/2 : lt-opt-s (lt12/2 LT) (lt12/2 (lt/s LT)).\n%worlds () (lt-opt-s _ _).\n%total {} (lt-opt-s _ _).\n\nlt-opt : lt N M -> lt12 N M -> type.\n%mode lt-opt +D -D2.\nlt-opt/z1 : lt-opt lt/z lt12/1.\nlt-opt/z2 : lt-opt lt/z (lt12/2 lt/z).\nlt-opt/s : lt-opt (lt/s LT) LT12'\n\t    <- lt-opt LT LT12\n\t    <- lt-opt-s LT12 LT12'.\n%worlds () (lt-opt _ _).\n%total T (lt-opt T _).\n\nlt-opt-succ1 : {LT: lt N (s N)} lt-opt LT lt12/1 -> type.\n%mode lt-opt-succ1 +LT -LTO.\n- : lt-opt-succ1 lt/z lt-opt/z1.\n- : lt-opt-succ1 (lt/s LT) (lt-opt/s lt-opt-s/1 LTS)\n     <- lt-opt-succ1 LT LTS.\n%worlds () (lt-opt-succ1 _ _).\n%total T (lt-opt-succ1 T _).\n\nlt-opt-succ2 : lt+ LT LT' -> lt-opt LT' (lt12/2 LT) -> type.\n%mode lt-opt-succ2 +LT -LT0.\n- : lt-opt-succ2 lt+/z lt-opt/z2.\n- : lt-opt-succ2 (lt+/s LT+) (lt-opt/s lt-opt-s/2 LTO)\n     <- lt-opt-succ2 LT+ LTO.\n%worlds () (lt-opt-succ2 _ _).\n%total T (lt-opt-succ2 T _).\n\nlt-opt2-s-uniq : id-lt LT1 LT1' \n\t\t  -> lt-opt-s (lt12/2 LT1) (lt12/2 LT2)\n\t\t  -> lt-opt-s (lt12/2 LT1') (lt12/2 LT2')\n\t\t  -> id-lt LT2 LT2' -> type.\n%mode lt-opt2-s-uniq +ID +D1 +D2 -ID2.\n- : lt-opt2-s-uniq id-lt/refl lt-opt-s/2 lt-opt-s/2 id-lt/refl.\n%worlds () (lt-opt2-s-uniq _ _ _ _).\n%total {} (lt-opt2-s-uniq _ _ _ _).\n\nlt-opt2-uniq : id-lt LT1 LT1' \n\t\t-> lt-opt LT1 (lt12/2 LT2) \n\t\t-> lt-opt LT1' (lt12/2 LT2')\n\t\t-> id-lt LT2 LT2' -> type.\n%mode lt-opt2-uniq +ID1 +L1 +L2 -ID2.\n- : lt-opt2-uniq id-lt/refl lt-opt/z2 lt-opt/z2 id-lt/refl.\n- : lt-opt2-uniq id-lt/refl (lt-opt/s LS L) (lt-opt/s LS' L') ID\n     <- lt-opt2-uniq id-lt/refl L L' ID1\n     <- lt-opt2-s-uniq ID1 LS LS' ID.\n%worlds () (lt-opt2-uniq _ _ _ _).\n%total T (lt-opt2-uniq _ T _ _).\n\nlt-opt-excl : lt-opt LT lt12/1 -> lt-opt LT (lt12/2 L) -> uninhabited -> type.\n%mode lt-opt-excl +D1 +D2 -D3.\n- : lt-opt-excl (lt-opt/s LS L) (lt-opt/s LS' L') X\n     <- lt-opt-excl L L' X.\n%worlds () (lt-opt-excl _ _ _).\n%total T (lt-opt-excl T _ _).\n\n\n%{ == HOAS lambda terms == }%\n\n%{ The representation of the untyped lambda calculus is extremely simple in\nhigher-order abstract syntax; we also define congruence lemmas for lam and app.\n\nWhat is interesting is the <tt>[[%block]]</tt> \ndeclaration of <tt>blocksimple</tt>. This is a standard way of looking at the\nLF context when we are using HOAS lambda terms, but it is not the one we will \nuse in most cases. }%\n\nexp : type.\nlam : (exp -> exp) -> exp.\napp : exp -> exp -> exp.\n\n%block blocksimple : block {v: exp}.\n\nid-exp : exp -> exp -> type.\nid-exp/refl : id-exp E E.\n\nid-lam-cong : ({v} id-exp (E v) (E' v)) \n\t\t-> id-exp (lam E) (lam E') -> type.\n- : id-lam-cong ([v] id-exp/refl) id-exp/refl.\n%mode id-lam-cong +I1 -I.\n%worlds (blocksimple) (id-lam-cong _ _).\n%total {} (id-lam-cong _ _).\n\nid-app-cong : id-exp E1 E1' \n\t\t-> id-exp E2 E2'\n\t\t-> id-exp (app E1 E2) (app E1' E2') -> type.\n- : id-app-cong id-exp/refl id-exp/refl id-exp/refl.\n%mode id-app-cong +I1 +I2 -I.\n%worlds (blocksimple) (id-app-cong _ _ _).\n%total {} (id-app-cong _ _ _).\n\n%{ The problem with <tt>blocksimple</tt> is that we will need, crucially, to \nbe able to know when something is a variable (as opposed to an application or a \nlambda term). The world <tt>blockvar</tt> achieves this by requiring that\nall variables be accompanied by a judgment <tt>isvar v</tt>; because these\njudgments cannot be defined, they can only be introduced as hypothetical\njudgments, so having (isvar E) ensures that E is a variable. }%\n\nisvar : exp -> type.\n%block blockvar : block {v}{iv: isvar v}.\n\n%{ However, we will need one more block declaration to be able to do everything\nwe need. In particular, the block <tt>blockvar</tt> is not enough to ensure that \nwe always will be able to determine whether an open lambda term is a lambda, an\napplication, or a variable. In order to do this, we need a specialized block \ndeclaration <tt>blockcases</tt> that specifies that whenever I add a variable \nto the context, I add it along with a <tt>isvar</tt> hypothesis and a \n<tt>can-case</tt> hypothesis. \n\nThe definition of <tt>fake</tt> is a bit of a hack - we need to allow\n<tt>can-case</tt> to depend on <tt>can-case</tt> or we will run afoul of\nTwelf's [[autofreeze]] feature. If you are running this proof on your\nown computer, try deleting the line to see Twelf's error message. }%\n\ncase : exp -> type.\ncase/lam : case (lam [x] E x).\ncase/app : case (app E1 E2).\ncase/var : isvar V -> case V.\n\ncan-case : {E} case E -> type.\nfake : can-case E C -> can-case E C -> type.\n- : fake E F <- ({d:can-case X Y} can-case X' Y').\n\n%block blockcases : block {v}{iv: isvar v}{d: can-case v (case/var iv)}.\n\ncan-case/lam : can-case (lam [x] E x) (case/lam).\ncan-case/app : can-case (app E1 E2) (case/app) .\n%mode can-case +E -C.\n%worlds (blockcases) (can-case _ _).\n%total T (can-case T _). \n\n%{ == de Bruijn lambda terms == }%\n\n%{ === Structural metric: Trees === }%\n\n%{ In order for the totality proof for the de Bruijn to HOAS translation to go\nthrough, we will need to show that there is a metric by which <tt>unbind</tt>\ndoes not change the size of a term. \n\nBecause Twelf does not relate the sizes of bound variables and the free \nvariables <tt>unbind</tt> replaces them with in any way, in order to achieve\nthis we relate de Bruijn terms to an abstract tree representation;\nthen, we can use that tree representation as the [[structural metric]] to\nprove termination for the de Bruijn to HOAS translation. }%\n\netree : type.\netree/lam : etree -> etree.\netree/app : etree -> etree -> etree.\netree/var : etree.\n\nid-etree : etree -> etree -> type.\nid-etree/refl : id-etree E E.\n\nid-etree/app-cong : id-etree E1 E1'\n\t\t     -> id-etree E2 E2' \n\t\t     -> id-etree (etree/app E1 E2) (etree/app E1' E2') -> type.\n%mode id-etree/app-cong +ID +ID2 -ID'.\n- : id-etree/app-cong id-etree/refl id-etree/refl id-etree/refl.\n%worlds () (id-etree/app-cong _ _ _).\n%total {} (id-etree/app-cong _ _ _).\n\nid-etree/lam-cong : id-etree E E' \n\t\t     -> id-etree (etree/lam E) (etree/lam E') -> type.\n%mode id-etree/lam-cong +ID -ID'.\n- : id-etree/lam-cong id-etree/refl id-etree/refl.\n%worlds () (id-etree/lam-cong _ _).\n%total {} (id-etree/lam-cong _ _).\n\n%{ === Encoding terms === }%\n\n%{ We choose an [[intrinsic encoding]] of de Bruijn terms so that every term\nthat passes the LF type checker is well-formed - in particular, a term\nwith <tt>exp^ N</tt> is a well-formed de Bruijn term inside of N lambdas.\nAn earlier version of this encoding had a separate well-formedness judgment; \nthe upshot of this encoding was that a lot of complexity got rephrased\nin terms of simple reasoning about relations like <tt>lt+</tt>. \n\nThe structural metric is made a part of the intrinsic in order to simplify\nlater proofs. }%\n\nexp^  : nat -> etree -> type.\nlam^  : exp^ (s N) Et -> exp^ N (etree/lam Et).\napp^  : exp^ N Et1 -> exp^ N Et2 -> exp^ N (etree/app Et1 Et2).\nfvar^ : {x: exp} isvar x -> exp^ N etree/var.\nbvar^ : {n: nat} lt n M -> exp^ M etree/var.\n\n%{ We will think of de Bruijn terms in two different ways depending on whether\nwe are thinking in terms of a closed world or a world described by \n<tt>blockvar</tt>. Recall that\nin a closed world (i.e. an empty LF context) we cannot form anything with\ntype <tt>isvar V</tt>, so in an empty context we cannot form a term with\n<tt>fvar^</tt>. The <tt>fvar^</tt> constructor is what allows us to link\nHOAS terms and de Bruijn terms, by incorporating variables from the\nHOAS representation directly inside of a de Bruijn term.\n\nWe also define identity and congruence on de Bruijn terms. }%\n\nid-exp^ : exp^ N E1 -> exp^ M E2 -> type.\nid-exp^/refl : id-exp^ E E.\n\nid-bvar^-cong : id-nat N N'\n\t\t -> id-lt LT LT'\n\t\t -> id-exp^ (bvar^ N LT) (bvar^ N' LT') -> type.\n- : id-bvar^-cong id-nat/refl id-lt/refl id-exp^/refl.\n%mode id-bvar^-cong +D1 +D2 -D^.\n%worlds (blockvar) (id-bvar^-cong _ _ _).\n%total {} (id-bvar^-cong _ _ _).\n\nid-app^-cong : id-exp^ E1 E1' \n\t\t-> id-exp^ E2 E2' \n\t\t-> id-exp^ (app^ E1 E2) (app^ E1' E2') -> type.\n- : id-app^-cong id-exp^/refl id-exp^/refl id-exp^/refl.\n%mode id-app^-cong +D1 +D -D2.\n%worlds (blockvar) (id-app^-cong _ _ _).\n%total {} (id-app^-cong _ _ _).\n\nid-lam^-cong : id-exp^ E E' -> id-exp^ (lam^ E) (lam^ E') -> type.\n- : id-lam^-cong id-exp^/refl id-exp^/refl.\n%mode id-lam^-cong +D1 -D2.\n%worlds (blockvar) (id-lam^-cong _ _).\n%total {} (id-lam^-cong _ _).\n\n%{ === Binding and unbinding === }%\n\n%{ The key operations on de Bruijn terms are a binding and unbinding \noperation - essentially, bind takes a free (HOAS) variable and makes it\na different free (de Bruijn) variable. \nBy way of an example, if we have <math>x,y \\vdash (\\lambda 1 x) y</math>,\nthen binding <math>x</math> will result in \n<math>y \\vdash (\\lambda 1 2) y</math>, and binding <math>y</math> will \nresult in <math>x \\vdash (\\lambda 1 x) 1</math>.\n\nUnfortunately, the structural metric ends up being included in both\n<tt>bind</tt> and <tt>unbind</tt>, which complicates the otherwise relatively\nsimple judgments significantly. }%\n\nbind : ({v} isvar v -> exp^ N Et) -> exp^ (s N) Et -> type.\n%mode bind +E1 -E.\n\nbind/match : bind ([v][iv] fvar^ v iv) (bvar^ N LT)\n\t\t   <- lts N LT.\n\nbind/fvar : bind ([v][iv] fvar^ X V) (fvar^ X V).\n\nbind/bvar : bind ([v][iv] bvar^ M LT) (bvar^ M LT') \n\t\t  <- lt+ LT LT'.\n\nbind/app : bind ([v][iv] app^ (E1 v iv) (E2 v iv)) (app^ E1' E2') \n\t\t <- bind ([v][iv] E1 v iv) E1'\n\t\t <- bind ([v][iv] E2 v iv) E2'.\n\nbind/lam : bind ([v][iv] lam^ (E v iv)) (lam^ E') \n\t\t <- bind ([v][iv] E v iv) E'.\n\n%worlds (blockvar) (bind _ _).\n%total T (bind T _).\n\n%{ }%\n\nunbind-bvar : lt12 M (s N) -> ({v} isvar v -> exp^ N etree/var) -> type.\n%mode unbind-bvar +LT -E .\n\nunbind-bvar/match : unbind-bvar lt12/1 ([v][iv] fvar^ v iv).\n\nunbind-bvar/nomatch : unbind-bvar (lt12/2 LT) ([v][iv] bvar^ M LT).\n\n%worlds (blockvar) (unbind-bvar _ _).\n%total {} (unbind-bvar _ _).\n\nunbind : exp^ (s N) Et -> ({v} isvar v -> exp^ N Et) -> type.\n%mode unbind +E1 -E2.\n\nunbind/fvar : unbind (fvar^ V' IV') ([v][iv] fvar^ V' IV').\n\nunbind/bvar : unbind (bvar^ M LT) ([v][iv] E v iv) \n\t\t   <- lt-opt LT LT12 \n\t\t   <- unbind-bvar LT12 ([v][iv] E v iv).\n\nunbind/app : unbind (app^ E1 E2) ([v][iv] app^ (E1' v iv) (E2' v iv))\n\t\t  <- unbind E1 ([v][iv] E1' v iv)\n\t\t  <- unbind E2 ([v][iv] E2' v iv).\n\nunbind/lam : unbind (lam^ E1) ([v][iv] lam^ (E1' v iv))\n\t\t  <- unbind E1 ([v][iv] E1' v iv).\n\n%worlds (blockvar) (unbind _ _).\n%total T (unbind T _).\n\n%{ === Properties of bind and unbind === }%\n\n%{ Now we will show that bind and unbind are inverses of each other,\nwhich mirrors the proof we will eventually prove about the <tt>exp->db</tt>\nand <tt>db->exp</tt> being inverses of each other. In particular, in \n<tt>unbind-uniq</tt> we need to use [[reasoning from false]] along with a\nspecial lemma. \n\nThe theorem statements were difficult to get correct, but the proofs are\nrelatively straightforward and are omitted (they are present in the full\nsource code for this page). }%\n\nbind-uniq : ({v}{iv:isvar v} id-exp^ (Ea v iv) (Ea' v iv))\n\t\t  -> bind Ea Eb\n\t\t  -> bind Ea' Eb'\n\t\t  -> id-exp^ Eb Eb' -> type.\n%mode bind-uniq +I1 +B1 +B2 -I2. %{}%\n\nunbind-uniq : id-exp^ Ea Ea'\n\t\t   -> unbind Ea Eb\n\t\t   -> unbind Ea' Eb'\n\t\t   -> ({v}{iv: isvar v} id-exp^ (Eb v iv) (Eb' v iv)) -> type.\n%mode unbind-uniq +I1 +U1 +U2 -I2. %{}%\n\nbind-unbind : bind ([v] E^ v) E^'\n\t      -> unbind E^' ([v] E^ v) -> type.\n%mode bind-unbind +B -U. %{}%\n\nunbind-bind : unbind E^ ([v] E^' v)\n\t      -> bind ([v] E^' v) E^ -> type.\n%mode unbind-bind +U -B. %{|hidden=true}% \n\n% Cases for bind-uniq\n- : bind-uniq ([v][iv] id-exp^/refl) bind/fvar bind/fvar \n     id-exp^/refl.\n- : bind-uniq ([v][iv] id-exp^/refl) (bind/bvar LT+) \n     (bind/bvar LT+') ID\n     <- lt+-uniq id-lt/refl LT+ LT+' ID+\n     <- id-bvar^-cong id-nat/refl ID+ ID.\n- : bind-uniq ([v][iv] id-exp^/refl) (bind/match LTS) \n     (bind/match LTS') ID\n     <- lts-uniq id-nat/refl LTS LTS' IDS\n     <- id-bvar^-cong id-nat/refl IDS ID.\n- : bind-uniq ([v][iv] id-exp^/refl) \n     (bind/app F2 F1) (bind/app F2' F1') ID\n     <- bind-uniq ([v][iv] id-exp^/refl) F1 F1' ID1\n     <- bind-uniq ([v][iv] id-exp^/refl) F2 F2' ID2\n     <- id-app^-cong ID1 ID2 ID.\n- : bind-uniq ([v][iv] id-exp^/refl) \n     (bind/lam F1) (bind/lam F1') ID\n     <- bind-uniq ([v][iv] id-exp^/refl) F1 F1' ID1\n     <- id-lam^-cong ID1 ID.\n%worlds (blockvar) (bind-uniq _ _ _ _).\n%total T (bind-uniq _ T _ _).\n\n% Cases for unbind-uniq\nlem : {Eb: {v} isvar v -> exp^ N Et} {Eb': {v} isvar v -> exp^ N Et} \n       uninhabited \n       -> ({v}{iv: isvar v} id-exp^ (Eb v iv: exp^ N Et) (Eb' v iv: exp^ N Et)) \n       -> type.\n%mode lem +Eb +Eb' +X -D.\n%worlds (blockvar) (lem _ _ _ _). \n%total {} (lem _ _ _ _).\n\n- : unbind-uniq id-exp^/refl unbind/fvar unbind/fvar \n     ([v][iv] id-exp^/refl).\n- : unbind-uniq id-exp^/refl  % Spurious case\n     (unbind/bvar unbind-bvar/match A)\n     (unbind/bvar unbind-bvar/nomatch B) ID\n     <- lt-opt-excl A B X\n     <- lem _ _ X ID.\n- : unbind-uniq id-exp^/refl  % Spurious case\n     (unbind/bvar unbind-bvar/nomatch A)\n     (unbind/bvar unbind-bvar/match B) ID\n     <- lt-opt-excl B A X\n     <- lem _ _ X ID.\n- : unbind-uniq id-exp^/refl\n     (unbind/bvar unbind-bvar/match A)\n     (unbind/bvar unbind-bvar/match B)\n\t([v][iv] id-exp^/refl).\n- : unbind-uniq id-exp^/refl\n     (unbind/bvar unbind-bvar/nomatch (Opt1: lt-opt LT (lt12/2 LT2)))\n     (unbind/bvar unbind-bvar/nomatch (Opt2: lt-opt LT (lt12/2 LT2')))\n     ID\n     <- lt-opt2-uniq id-lt/refl Opt1 Opt2 ID1\n     <- {v}{iv: isvar v} id-bvar^-cong id-nat/refl ID1 (ID v iv).\n- : unbind-uniq id-exp^/refl \n     (unbind/app E2 E1) \n     (unbind/app E2' E1') ID\n     <- unbind-uniq id-exp^/refl E1 E1' ID1\n     <- unbind-uniq id-exp^/refl E2 E2' ID2\n     <- {v}{iv: isvar v} id-app^-cong (ID1 v iv) (ID2 v iv) (ID v iv).\n- : unbind-uniq id-exp^/refl\n     (unbind/lam E) (unbind/lam E') ID\n     <- unbind-uniq id-exp^/refl E E' ID1\n     <- {v}{iv: isvar v} id-lam^-cong (ID1 v iv) (ID v iv).\n%worlds (blockvar) (unbind-uniq _ _ _ _).\n%total T (unbind-uniq _ T _ _). \n\n% Cases for bind-unbind\n- : bind-unbind bind/fvar unbind/fvar.\n- : bind-unbind (bind/match (LTS: lts N LT)) \n     (unbind/bvar unbind-bvar/match Opt)\n     <- lt-opt-succ1 LT Opt.\n- : bind-unbind (bind/bvar (LT+: lt+ LT LT')) \n     (unbind/bvar unbind-bvar/nomatch Opt)\n     <- lt-opt-succ2 LT+ Opt.\n- : bind-unbind (bind/app B2 B1) (unbind/app U2 U1)\n     <- bind-unbind B1 U1\n     <- bind-unbind B2 U2.\n- : bind-unbind (bind/lam B) (unbind/lam U)\n     <- bind-unbind B U.\n\n%worlds (blockvar) (bind-unbind _ _).\n%total T (bind-unbind T _). \n\n% Cases for unbind-bind\n- : unbind-bind unbind/fvar bind/fvar.\n- : unbind-bind (unbind/bvar unbind-bvar/match Opt) (bind/match LTS)\n     <- can-lts _ _ LTS.\n- : unbind-bind \n     (unbind/bvar unbind-bvar/nomatch (Opt: lt-opt LT' (lt12/2 LT))) \n     (bind/bvar LT+)\n     <- can-lt+ LT LT' LT+.\n- : unbind-bind (unbind/app U2 U1) (bind/app B2 B1)\n     <- unbind-bind U1 B1\n     <- unbind-bind U2 B2.\n- : unbind-bind (unbind/lam U) (bind/lam B)\n     <- unbind-bind U B.\n\n%worlds (blockvar) (unbind-bind _ _).\n%total T (unbind-bind T _).  %{}%\n\n\n%{ == Relating HOAS and de Bruijn representations == }%\n\n%{ This is the penultimate section. What we want to prove, ultimately, is\na bijection between ''closed'' HOAS terms and ''closed'' de Bruijn terms;\nhowever, in order to get there we will prove a bijection between open\nHOAS terms and open de Bruijn terms, which is the subject of this section.\nDoing so requires reasoning with the structural metric, using the complex\n<tt>blockcases</tt> block description, and generally making a mess. The\ntheorem about closed terms in the next session will be simpler, but will use \nthe more complex lemmas from this section. }%\n\n%{ === HOAS to de Bruijn === }%\n\n%{ It is here that we will need to use the <tt>blockcases</tt> block description\ndiscussed above; even though it makes the translation more complicated, we\ndirectly prove the translation total in order to avoid writing a ton\nof [[effectiveness lemmas]]; the uniqueness of this translation is simple,\nbut dependent on the effectiveness of <tt>bind</tt>. }%\n\nexp->db : {E} case E -> {Et} exp^ z Et -> type.\n%mode exp->db +E +C -Et -E^.\n\nexp->db/var : exp->db _ (case/var IV) etree/var (fvar^ V IV).\nexp->db/lam : exp->db (lam ([v] E2 v)) case/lam (etree/lam Et) (lam^ E^')\n\t       <- ({v}{iv: isvar v} can-case v (case/var iv) ->\n\t\t     can-case (E2 v) (CASE v iv))\n\t       <- ({v}{iv: isvar v} can-case v (case/var iv) ->\n\t\t     exp->db (E2 v) (CASE v iv) Et (E^'' v iv))\n\t       <- bind E^'' E^'.\nexp->db/app : exp->db (app E1 E2) case/app (etree/app Et1 Et2) (app^ E1' E2')\n\t       <- can-case E1 CASE1\n\t       <- can-case E2 CASE2\n\t       <- exp->db E1 CASE1 Et1 E1'\n\t       <- exp->db E2 CASE2 Et2 E2'.\n\n%worlds (blockcases) (exp->db _ _ _ _).\n%total T (exp->db T _ _ _). %{}%\n\nuniq->db : exp->db E2 C Et E^ \n\t    -> exp->db E2 C Et' E^' \n\t    -> id-etree Et Et'\n\t    -> id-exp^ E^ E^' -> type.\n%mode uniq->db +E1 +E2 -ID1 -ID2.\n\n- : uniq->db exp->db/var exp->db/var id-etree/refl id-exp^/refl.\n- : uniq->db (exp->db/lam F T C) (exp->db/lam F' T' C') IDe ID^\n     <- ({v}{iv: isvar v}{c: can-case v (case/var iv)}\n\t   uniq->db (T v iv c) (T' v iv c) IDe1 (ID^1 v iv))\n     <- bind-uniq ID^1 F F' ID^2\n     <- id-etree/lam-cong IDe1 IDe\n     <- id-lam^-cong ID^2 ID^.\n- : uniq->db (exp->db/app T2 T1 C2 C1) (exp->db/app T2' T1' C2' C1') IDe ID^\n     <- uniq->db T1 T1' IDe1 ID^1\n     <- uniq->db T2 T2' IDe2 ID^2\n     <- id-etree/app-cong IDe1 IDe2 IDe\n     <- id-app^-cong ID^1 ID^2 ID^.\n\n%worlds (blockcases) (uniq->db _ _ _ _).\n%total T (uniq->db T _ _ _).\n\n%{ === de Bruijn to HOAS === }%\n\n%{ It is here that we will need to use the <tt>etree</tt> [[structural metric]]\nto provide a usable termination argument for <tt>db->exp</tt>. }%\n\ndb->exp : {Et} exp^ z Et -> {E} case E -> type.\n%mode db->exp +ET +E^ -E -C.\n\ndb->exp/fvar : db->exp etree/var (fvar^ V IV) V (case/var IV).\ndb->exp/lam : db->exp (etree/lam ET) (lam^ E^) (lam E) case/lam\n\t       <- unbind E^ E^'\n\t       <- {v}{iv: isvar v} can-case v (case/var iv)\n\t\t  -> db->exp ET (E^' v iv) (E v) _.\ndb->exp/app : db->exp (etree/app ET1 ET2) (app^ E1^ E2^) (app E1 E2) case/app\n\t       <- db->exp ET1 E1^ E1 _\n\t       <- db->exp ET2 E2^ E2 _.\n\n%worlds (blockcases) (db->exp _ _ _ _).\n%total T (db->exp T _ _ _). %{}%\n\nuniq->exp : id-exp^ E^ E^'\n\t     -> db->exp ET E^ E C\n\t     -> db->exp ET' E^' E' C'\n\t     -> id-exp E E' -> type.\n%mode uniq->exp +ID1 +E1 +E2 -ID.\n\n- : uniq->exp id-exp^/refl db->exp/fvar db->exp/fvar id-exp/refl.\n- : uniq->exp id-exp^/refl \n     (db->exp/lam ([v][iv][c: can-case v (case/var iv)] T v iv c) UB) \n     (db->exp/lam ([v][iv][c: can-case v (case/var iv)] T' v iv c) UB') ID\n     <- unbind-uniq id-exp^/refl UB UB' \n\t(ID1: {v:exp} {iv:isvar v} id-exp^ (E v iv) (E' v iv))\n     <- ({v}{iv:isvar v}{c: can-case v (case/var iv)}\n\t   uniq->exp (ID1 v iv) (T v iv c) (T' v iv c) (ID2 v))\n     <- id-lam-cong ID2 ID.\n- : uniq->exp id-exp^/refl (db->exp/app T2 T1) (db->exp/app T2' T1') ID\n     <- uniq->exp id-exp^/refl T1 T1' ID1\n     <- uniq->exp id-exp^/refl T2 T2' ID2\n     <- id-app-cong ID1 ID2 ID.\n\n%worlds (blockcases) (uniq->exp _ _ _ _).\n%total T (uniq->exp _ T _ _).\n\n\n%{ === Composition: HOAS -> de Bruijn -> HOAS === }%\n\ninverseEDE : exp->db E C Et E^ -> db->exp Et E^ E C -> type.\n%mode inverseEDE +ED -DE.\n\n- : inverseEDE exp->db/var db->exp/fvar.\n- : inverseEDE (exp->db/lam B T C) (db->exp/lam T' U)\n     <- bind-unbind B U\n     <- {v}{iv:isvar v}{c:can-case v (case/var iv)}\n\tinverseEDE (T v iv c) (T' v iv c).\n- : inverseEDE (exp->db/app T2 T1 C2 C1) (db->exp/app T2' T1')\n     <- inverseEDE T1 T1'\n     <- inverseEDE T2 T2'.\n\n%worlds (blockcases) (inverseEDE _ _).\n%total T (inverseEDE T _). %{}%\n\n%{ === Composition: de Bruijn -> HOAS -> de Bruijn === }%\n\n%{ We need one last trick in order to make this proof go through in the\nopposite direction; we will need an effectiveness lemma on top of an\neffectiveness lemma! (Effectiveness lemmas can get out of control sometimes.) }%\n\ncan-can-case : {C: case E} can-case E C -> type.\nfake : type.\n- : fake <- (can-can-case E V -> can-can-case E' V').\n%block blockcancases\n   : block {v}{iv:isvar v}{c:can-case v (case/var iv)}\n      {cc:can-can-case (case/var iv) c}.\n- : can-can-case case/app can-case/app.\n- : can-can-case case/lam can-case/lam.\n%mode can-can-case +C -CC.\n%worlds (blockcancases) (can-can-case _ _).\n%total {} (can-can-case _ _). \n\n%{ With our slightly absurd effectiveness effectiveness lemma in tow, we can\ncomplete the proof that composition in the other direction is the identity. }%\n\ninverseDED : db->exp Et E^ E C -> exp->db E C Et E^ -> type.\n%mode inverseDED +DE -ED.\n\n- : inverseDED db->exp/fvar exp->db/var.\n- : inverseDED (db->exp/lam (T:{v}{iv:isvar v}{c} \n\t\t\t\t db->exp Et (E^ v iv) (E v) (Case v iv)) U) \n     (exp->db/lam B T' C)\n     <- unbind-bind U B\n     <- ({v}{iv:isvar v}{c:can-case v (case/var iv)}\n\t   can-can-case (case/var iv) c \n\t   -> inverseDED (T v iv c) (T' v iv c))\n     <- ({v}{iv:isvar v}{c:can-case v (case/var iv)}\n\t   can-can-case (case/var iv) c\n\t   -> can-can-case _ (C v iv c)).\n- : inverseDED (db->exp/app T2 T1) (exp->db/app T2' T1' C2 C1)\n     <- inverseDED T1 T1'\n     <- inverseDED T2 T2'\n     <- can-can-case _ C1\n     <- can-can-case _ C2.\n\n%worlds (blockcancases) (inverseDED _ _).   \n%total T (inverseDED T _). %{}%\n\n%{ == Wrapping up == }%\n\n%{ The one step that remains is to perform the above four steps for a\nsimpler theorem statement in a closed world, since ultimately what we \nwant is a theorem about closed terms anyway. These theorems would likely\nbe less useful in practice than the ones already proven because the \nclosed world assumption makes them less general, but they more concisely\nstate what was done. }%\n\n%{* <tt>exp-->db</tt> is a total and unique relation between HOAS to de Bruijn terms, and can therefore be thought of as the function ''e2d''. }%\n\nexp-->db : exp -> exp^ z Et -> type.\nexp-->db/ : exp-->db E E^ \n\t     <- can-case E (C: case E)\n\t     <- exp->db E C Et (E^: exp^ z Et).\n%mode exp-->db +E -E^.\n%worlds () (exp-->db _ _).\n%total {} (exp-->db _ _).\n\nuniq-->db : exp-->db E E1 -> exp-->db E E2 -> id-exp^ E1 E2 -> type.\n- : uniq-->db (exp-->db/ ED C) (exp-->db/ ED' C') ID\n     <- uniq->db ED ED' _ ID.\n%mode uniq-->db +E +E' -ID.\n%worlds () (uniq-->db _ _ _).\n%total {} (uniq-->db _ _ _).\n\n%{* <tt>db-->exp</tt> is a total and unique relation between de Bruijn terms to HOAS, and can therefore be thought of as the function ''d2e''. }%\n\ndb-->exp : exp^ z Et -> exp -> type.\ndb-->exp/ : db-->exp E^ E\n\t     <- db->exp Et E^ E _.\n%mode db-->exp +E^ -E.\n%worlds () (db-->exp _ _).\n%total {} (db-->exp _ _).\n\nuniq-->exp : db-->exp E E1 -> db-->exp E E2 -> id-exp E1 E2 -> type.\n- : uniq-->exp (db-->exp/ DE) (db-->exp/ DE') ID\n     <- uniq->exp id-exp^/refl DE DE' ID.\n%mode uniq-->exp +E +E' -ID.\n%worlds () (uniq-->exp _ _ _).\n%total {} (uniq-->exp _ _ _).\n\n%{* For all closed de Bruijn terms E, ''d2e''(''e2d'' E) = E.}%\n\ndb-->exp-->db : db-->exp E^ E -> exp-->db E E^ -> type.\n- : db-->exp-->db (db-->exp/ DE) (exp-->db/ ED C)\n     <- inverseDED DE (ED: exp->db E Case Et E^) \n     <- can-can-case Case C.\n%mode db-->exp-->db +DE -ED.\n%worlds () (db-->exp-->db _ _).\n%total {} (db-->exp-->db _ _).\n\n%{* For all closed HOAS terms E, ''e2d'' (''d2e'' E) = E.}%\n\nexp-->db-->exp : exp-->db E E^ -> db-->exp E^ E -> type.\n- : exp-->db-->exp (exp-->db/ ED C) (db-->exp/ DE)\n     <- inverseEDE ED DE.\n%mode exp-->db-->exp +ED -DE.\n%worlds () (exp-->db-->exp _ _).\n%total {} (exp-->db-->exp _ _). %{}%\n\n\n%{ == Examples == }%\n\n%{ It's also a good idea to run a <tt>[[%query]]</tt> on some examples as \na sanity check. First, we translate the Church numeral \"4,\" <math>\\lambda f.\\lambda x.f(f(f(f x)))</math> from a\nHOAS to a de Bruijn index representation. |check=decl}%\n\n%query 1 * exp-->db \n   (lam [f] lam [x] app f (app f (app f (app f x)))) DB.\n\n%{ Next, we translate the Church boolean operator \"Not,\" <math>\\lambda p . p (\\lambda x . \\lambda y . y) (\\lambda x . \\lambda y . x)</math> from a \nBruijn index to a HOAS representation. |check=decl}%\n\n%query 1 * db-->exp \n   (lam^ (app^ (app^ \n     (bvar^ z lt/z) \n     (lam^ (lam^ (bvar^ z lt/z))))\n     (lam^ (lam^ (bvar^ (s z) (lt/s lt/z)))))) HOAS."
          },
          "sha1": "ltrvfb8891kzed2fbytc0y6z0ga37uu"
        }
      },
      {
        "title": "Concrete representations",
        "ns": 0,
        "id": 2010,
        "redirect": {
          "@title": "Concrete representation",
          "#text": null
        },
        "revision": {
          "id": 4893,
          "timestamp": "2007-10-04T15:22:09Z",
          "contributor": {
            "ip": "128.2.223.28"
          },
          "comment": "redirect",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 37,
            "#text": "#REDIRECT [[Concrete representation]]"
          },
          "sha1": "1t4td5cmruk0doef2z1fah8bynw1biu"
        }
      },
      {
        "title": "Congruence lemma",
        "ns": 0,
        "id": 1788,
        "redirect": {
          "@title": "Respects lemma",
          "#text": null
        },
        "revision": {
          "id": 3258,
          "timestamp": "2006-11-01T15:53:06Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "comment": "[[Congruence lemma]] moved to [[Respects lemma]]: congruence lemmas are a particular mode of use of respects lemmas",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 28,
            "#text": "#REDIRECT [[Respects lemma]]"
          },
          "sha1": "mv4t94do770qopwnz5smkbbw3qpa5js"
        }
      },
      {
        "title": "Congruence lemmas",
        "ns": 0,
        "id": 1740,
        "redirect": {
          "@title": "Respects lemma",
          "#text": null
        },
        "revision": {
          "id": 3327,
          "parentid": 2972,
          "timestamp": "2006-11-12T16:17:00Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "Redirecting to [[Respects lemma]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 28,
            "#text": "#REDIRECT [[Respects lemma]]"
          },
          "sha1": "mv4t94do770qopwnz5smkbbw3qpa5js"
        }
      },
      {
        "title": "Congruence relation",
        "ns": 0,
        "id": 1935,
        "revision": {
          "id": 4366,
          "timestamp": "2007-03-19T23:23:17Z",
          "contributor": {
            "username": "William Lovas",
            "id": 11
          },
          "comment": "New page: A congruence relation on a language is an [[equivalence relation]] that is compatible with the term constructors of that language.  Consider the untyped lambda-calculus:  <math>e ::= x \\mi...",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 693,
            "#text": "A congruence relation on a language is an [[equivalence relation]] that is compatible with the term constructors of that language.\n\nConsider the untyped lambda-calculus:\n\n<math>e ::= x \\mid \\lambda x.\\, e \\mid e_1\\ e_2</math>\n\nA congruence relation <math>\\texttt{}e_1 = e_2</math> must be closed under the equivalence rules,\n\n<math>\n  {\\; \\over e = e} \\mbox{refl} \\qquad\n  { e_1 = e_2 \\over e_2 = e_1 } \\mbox{symm} \\qquad\n  { e_1 = e_2 \\qquad e_2 = e_3 \\over e_1 = e_3 } \\mbox{trans},\n</math>\n\nand the compatibility rules,\n\n<math>\n  {\\; \\over x = x} \\qquad\n  { e_1 = e_2 \\over \\lambda x.\\, e_1 = \\lambda x.\\, e_2 } \\qquad\n  { e_1 = e_1' \\qquad e_2 = e_2' \\over e_1\\ e_2 = e_1'\\ e_2' }.\n</math>"
          },
          "sha1": "thkpck0wcqpds7nxcffopmybjni53of"
        }
      },
      {
        "title": "Constraint domain",
        "ns": 0,
        "id": 1795,
        "revision": {
          "id": 6105,
          "parentid": 3813,
          "timestamp": "2010-09-01T21:45:57Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "Fix twelftag bugs",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 3788,
            "#text": "A '''constraint domain''', also called a '''Twelf(X) extension''', is an extension to Twelf that allow users to work easily with an object, such as the integers, that can be tedious or inefficient to explicitly formalize within Twelf. Constraint domains are introduced with the <tt>[[%use]]</tt> declaration.\n\nYou should never use [[constraint domains and coverage checking]] in the same signature, but they are useful when using Twelf as a logic programming system or when reasoning ''in'' an [[object language]]. This document shows brief examples of each of the constraint domains, which are treated more formally in the chapter on {{guide|chapter=6|section=32|title=constraint domains}}.\n\n== Rational numbers with equality: <tt>%use equality/rationals</tt> ==\n\nThe rational numbers with equality add a new type family, <tt>rational</tt>, and operators for rational addition, subtraction, multiplication, and negation.\n\n<twelf import=\"er\" check=decl>\n%use equality/rationals.\n</twelf>\n\nThe rational numbers are automatically simplified by Twelf\n<twelf import=\"er\" check=decl>\nmynum = 1/4 + ~ 9/2.\n</twelf>\n\nBecause of this automatic simplification, equality is not actually added by the <tt>%use</tt> declaration, becuase it can be introduced the same way [[identity]] is introduced for any other type family in Twelf.\n\n<twelf import=\"er\">\neq : rational -> rational -> type.\neq/is : eq X X.\n</twelf>\n\n\n\n\n== Rational numbers with inequality: <tt>%use inequality/rationals</tt> ==\n\nThis declaration introduces everything introduced by <tt>%use equality/rationals</tt>, as well as ways to check for \n\n<twelf import=\"ir\" check=decl>\n%use inequality/rationals.\n</twelf>\n\nInequality relations can be used like normal goals, as they are in the next example, even though the User's Guide explains that their internal behavior is different than other goals.\n\n<twelf import=\"ir\" check=true>\nmore-than-two : rational -> rational -> type.\nmore-than-two/i : more-than-two R1 R2\n                   <- R1 + R2 > 2.\n</twelf>\n\n\n\n\n== Integers with equality: <tt>%use equality/integers</tt> ==\n\nThe introduction of integers with equality looks similar to the introduction of rationals with equality, but with a different type family, <tt>integer</tt>.\n\n<twelf import=\"ie\" check=decl>\n%use equality/integers.\n</twelf>\n\n\n\n\n== Integers with inequality: <tt>%use inequality/integers</tt> ==\n\nThe introduction of integers with inequality is a good bit shorter than the introduction of rationals with inequality, because Twelf can take advantage of the facts like <tt>X + 1 > Y</tt> iff <tt>X >= Y</tt>.\n\n<twelf import=\"ii\" check=decl>\n%use inequality/integers.\n</twelf>\n\n\n\n\n== Strings: <tt>%use equality/strings</tt> ==\n\nThis constraint domain allows Twelf to include strings of characters.\n\n<twelf import=\"str\" check=decl>\n%use equality/strings.\n</twelf>\n\nLike the other constriant domains, using the operators automatically simplifies the operators away. The only one provided is concatenation, <tt>++</tt>, which is shown below:\n\n<twelf import=\"str\" check=decl>\nmystring = \"Hello\" ++ \" \" ++ \"World\" ++ \"!\".\n</twelf>\n\n\n\n\n== 32-bit integers: <tt>%use word32.</tt> ==\n\nThe <tt>word32</tt> extension behaves very differently than the others - operators are relations, not functions, and so Twelf does not simplify their application away.\n\n<twelf import=\"w32\" check=decl>\n%use word32.\n</twelf>\n\nBehind the scenes, using the <tt>word32</tt> extension adds axioms to the signature like <tt>3+15</tt> shown in the below example. The <tt>prove+</tt> relations that are defined act like [[effectiveness lemmas]] for these relations.\n\n<twelf import=\"w32\" check=decl>\nmyproof = 3+15.\n\n%solve _ : prove+ 92 _ 105 _.\n</twelf>\n\n\n== See also ==\n* <tt>[[%use]]</tt>\n* {{guide|chapter=6|section=32|title=Constraint domains}}"
          },
          "sha1": "oyhrhq7rpm058misw6p73p41ozoylup"
        }
      },
      {
        "title": "Constraint domains",
        "ns": 0,
        "id": 1798,
        "redirect": {
          "@title": "Constraint domain",
          "#text": null
        },
        "revision": {
          "id": 3297,
          "timestamp": "2006-11-03T21:07:03Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "comment": "[[Constraint domains]] moved to [[Constraint domain]]: using singular when possible for article titles",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 31,
            "#text": "#REDIRECT [[Constraint domain]]"
          },
          "sha1": "em8tt0ypj63kq71ab2j61h889jbu40j"
        }
      },
      {
        "title": "Constraint domains and coverage checking",
        "ns": 0,
        "id": 1791,
        "revision": {
          "id": 8151,
          "parentid": 8150,
          "timestamp": "2016-07-24T13:45:40Z",
          "contributor": {
            "username": "Boyland",
            "id": 17
          },
          "minor": null,
          "comment": "Reverted edits by [[Special:Contributions/Ashabcmg5e9|Ashabcmg5e9]] ([[User talk:Ashabcmg5e9|talk]]) to last revision by [[User:Rsimmons|Rsimmons]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 3450,
            "#text": "::''You should not attach any particular significance to the fact that Twelf returns OK (or raises an uncaught exception, or starts playing the theme music to M*A*S*H...) on a signature that mentions a constraint domain and also tries to prove coverage or totality metatheorems.'' - Kevin Watkins\n\nIt is tempting to try to use [[constraint domains]] to do seemingly innocent helpful things. However, at the present time, constraint domains should be seen as completely incompatible with features that Twelf uses to prove [[metatheorems]], such as <tt>[[%mode]]</tt>, <tt>[[%covers]]</tt>, and <tt>[[%total]]</tt>. \n\nOne particular way that this error happens is when users attempt to formalize a language with exceptions, and want to index their language with strings.\n\n<twelf discard=true>\n%use equality/strings. \n\nexp : type.\nerror : string -> exp.\n</twelf>\n\nThis should be avoided at all costs in favor of explicitly defining a type of error messages ''within'' the signature.\n\n<twelf discard=true>\nerrormessage : type.\n\nbad-value : errormessage.\ntype-error : errormessage. \n% ...etc...\n\nexp : type.\nerror : errormessage -> exp.\n</twelf>\n\n== Example: apparent unsoundness with constraint domains ==\n\nThe essential problem is that the interaction between constraint domains and the Twelf\ncoverage checker is not well defined. Take the following example:\n\n<twelf>\n%use word32. \n\nexp : type.\n\nx : word32 -> exp.\ny : exp.\nz : exp.\n\nq : exp -> exp -> type.\n%mode q +A1 -A2. \n\nq/y : q y y.\n\nq/z : q z z.\n</twelf>\n\nTwelf appears to allow us to prove that, for any input in the first position, <tt>q</tt> will always run\nsuccessfully and return an output in the second position.\n\n<twelf name=\"fork\" check=decl>\n%worlds () (q _ _). \n%total T (q T _).  \n</twelf>\n\nHowever, Twelf's assertion of totality here is completely bogus, which we can see if we try to run\nq as a logic program with <tt>(x 5)</tt> in the first position.\n\n<twelf include=fork check=decl>\n%solve _ : q (x 5) _.\n</twelf>\n\n=== Analysis ===\n\n{{needs|copy editing}}\n\nOne way of looking at the problem above is that the above proof isn't quite a proof of what it seems to be a proof of. The <tt>[[%worlds]]</tt> statement for the above theorem is empty, which means that one way to state the theorem theorem is \"if the only things that exist in the things that were explicitly defined in the signature.\" This is a closed-world assumption. Because the identifier <tt>5</tt> never was explicitly defined in the signature, but was implicitly introduced by the <tt>%use word32</tt> declaration, then the metatheorem above is true - if we're not allowed use any object of type <tt>word32</tt>, the we can't feed\n<tt>q</tt> any input that will allow it to fail.\n\nIf we modify our worlds declaration to specify that there may be some <tt>word32</tt>s around&mdash;because there ''are'' some \n<tt>word32</tt>s around, there are <math>2^{32}</math> of them!&mdash;then the theorem fails as it should.\n\n<twelf check=decl>\n%block some-word32s : block {x: word32}.\n\n%worlds (some-word32s) (q _ _).\n%total T (q T _).\n</twelf>\n\nHowever, as there is no account for exactly what <tt>%use</tt> ''does'' to the signature, it is very difficult to be certain, when we are using constraint domains, that we have proven the theorems we think we have proven. This is precisely\nwhy constraint domains and metatheorem declarations like <tt>%covers</tt> and <tt>%total</tt> should never be used in the same signature."
          },
          "sha1": "rfusle5btov891e4826h325e0ravkgd"
        }
      },
      {
        "title": "ConstructiveSemantics",
        "ns": 0,
        "id": 2233,
        "revision": {
          "id": 6196,
          "parentid": 6195,
          "timestamp": "2010-12-06T23:37:31Z",
          "contributor": {
            "username": "Jcreed",
            "id": 9
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 3530,
            "#text": "A little proof of cut eliminiation for the logic FF in an unpublished paper by Reed and Pfenning.\n\n<twelf check=\"true\">\n% Termination metric\n\nlo : type.\nhi : type.\n* : lo.\ns : lo -> hi.\n\n% Syntax\n\nt+ : type. % \"terms\" that go in positive atoms\nt- : type. %name t- T. % \"terms\" that go in negative atoms\np : type. % positive props\no : type. % negative props\ni : type. % worlds, frames\n\n% Propositions\nimp : p -> o -> o.\ntop : o.\ns- : t- -> o.\ns+ : t+ -> p.\nv : o -> p.\n\n% Stub terms to make coverage nontrivial\nt+/ : t+.\nt-/ : t-.\n\n% Judgments\nj : type. %name j J.\n/lfoc : o -> t- -> j.\n/rinv : o -> j.\n/rfoc : p -> j.\npf : j -> type.\n%abbrev lfoc = [A][T] pf (/lfoc A T).\n%abbrev rinv = [A] pf (/rinv A).\n%abbrev rfoc = [B] pf (/rfoc B).\n\n<= : t- -> t- -> type.\nhyp : p -> type.\n\n% Stub judgment to make coverage nontrivial\nrefl : <= T T.\n\n% Inference Rules\ns+R : hyp (s+ T) -> rfoc (s+ T).\ns-L : <= T T0 -> lfoc (s- T) T0.\nvR : rinv A -> rfoc (v A).\nvL : lfoc A T -> (hyp (v A) -> rinv (s- T)).\ntopR : rinv top.\nimpR : rinv (imp B A) <- (hyp B -> rinv A).\nimpL : lfoc (imp B A) T <- rfoc B <- lfoc A T.\n\n% Theorems\n\ntrans : <= T1 T2 -> <= T2 T3 -> <= T1 T3 -> type.\nmono/rinv : <= T1 T2 -> rinv (s- T1) -> rinv (s- T2) -> type.\nmono/lfoc : <= T1 T2 -> lfoc A T1 -> lfoc A T2 -> type.\n\ncut/rfoc : {B} hi -> rfoc B -> (hyp B -> pf J) -> pf J -> type.\ncut/rinv : {A} hi -> rinv A -> (hyp (v A) -> pf J) -> pf J -> type.\ncut/pc : {A} lo -> rinv A -> lfoc A T -> rinv (s- T) -> type.\n\n% mono/rinv proof\nmono/rinv/ : mono/rinv LE (vL LF H) (vL LF' H) <- mono/lfoc LE LF LF'.\n\n% mono/lfoc proof\nmono/lfoc/impL : mono/lfoc LE (impL LF RF) (impL LF' RF)\n\t      <- mono/lfoc LE LF LF'.\nmono/lfoc/s- : mono/lfoc LE (s-L LE') (s-L LE'')\n\t    <- trans LE' LE LE''.\n\n% cut/rfoc proof\ncut/rfoc/v : cut/rfoc (v A) TM (vR RI) PF1 PF2 \n\t      <- cut/rinv A TM RI PF1 PF2.\ncut/rfoc/s+ : cut/rfoc (s+ T) TM (s+R H) PF (PF H).\n\n% cut/pc proof\ncut/pc/imp : cut/pc (imp B A) TM (impR RI) (impL LF RF) RI''\n\t      <- cut/rfoc B (s TM) RF RI RI'\n\t      <- cut/pc A TM RI' LF RI''.\ncut/pc/s- : cut/pc (s- T) TM IN (s-L LE) OUT <- mono/rinv LE IN OUT.\n\n% cut/rinv proof\ncut/rinv/impL : cut/rinv A TM RI ([x] impL (LF x) (RF x)) (impL LF' RF')\n\t\t <- cut/rinv A TM RI LF LF'\n\t\t <- cut/rinv A TM RI RF RF'.\ncut/rinv/impR : cut/rinv A TM RI ([x] impR ([y] D x y)) (impR Y)\n\t\t <- {y} cut/rinv A TM RI ([x] D x y) (Y y).\ncut/rinv/s-L : cut/rinv A TM RI ([x] s-L D) (s-L D).\ncut/rinv/vL/hit : cut/rinv A (s TM) RI ([x] vL (LF x) x) Y\n\t\t   <- cut/rinv A (s TM) RI LF Z\n\t\t   <- cut/pc A TM RI Z Y.\ncut/rinv/vL/miss : cut/rinv A TM RI ([x] vL (LF x) H) (vL LF' H)\n\t\t    <- cut/rinv A TM RI LF LF'.\ncut/rinv/vR : cut/rinv A TM RI ([x] vR (RI0 x)) (vR RI0')\n\t\t <- cut/rinv A TM RI RI0 RI0'.\n\ncut/rinv/s+R : cut/rinv A TM RI ([x] s+R H) (s+R H).\ncut/rinv/topR : cut/rinv A TM RI ([x] topR) topR.\n\n\n% Checks\n%block b : some {P : p} block {x : hyp P}.\n%mode \n (trans +A +B -C)\n (mono/rinv +A +B -C)\n (mono/lfoc +A +B -C).\n%mode \n (cut/rfoc +A +B +C +D -E)\n (cut/rinv +A +B +C +D -E)\n (cut/pc   +A +B +C +D -E).\n%worlds (b) \n (trans _ _ _)\n (mono/rinv _ _ _)\n (mono/lfoc _ _ _).\n%worlds (b) \n(cut/rfoc _ _ _ _ _)\n(cut/rinv _ _ _ _ _)\n(cut/pc   _ _ _ _ _).\n\n% Assume structure relation is transitive\n%trustme %total LE1 (trans LE1 LE2 LE3).\n\n%total (RI1 LF1) \n (mono/rinv LE RI1 RI2)\n (mono/lfoc LE' LF1 LF2).\n\n%total \n{(B A A') (N1 N2 N3) [(RF RI RI' ) (PFRF1 PFRI1 LF )]} \n(cut/rfoc B N1 RF PFRF1 PFRF2)\n(cut/rinv A N2 RI PFRI1 PFRI2)\n(cut/pc A' N3 RI' LF RI'').\n</twelf>"
          },
          "sha1": "lojbbzq2ybsb73fwolhe3oz0252pubw"
        }
      },
      {
        "title": "Converting between implicit and explicit parameters",
        "ns": 0,
        "id": 1674,
        "revision": {
          "id": 4131,
          "parentid": 4130,
          "timestamp": "2007-03-15T17:56:07Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "comment": "whoops this one didn't need it",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 3211,
            "#text": "When declaring a type family or constant, the Twelf programmer often has a choice between [[implicit and explicit parameters]] for some arguments. There is no reason to fret over this choice, for there is an easy technique for '''converting between implicit and explicit parameters'''.\n\nSuppose we have a language defined as follows:\n\n<twelf>\n\nexp : type.\ntyp : type.\nof  : exp -> typ -> type.\n\n0 : exp.\n1 : exp.\nbit : typ.\nvoid : typ.\nof1 : of 1 bit.\nof0 : of 0 bit.\n\n</twelf>\n\nWe wish to define a translation between type derivations in this language, as a part of a source to source translation. The implicit and explicit versions are as follows:\n\n<twelf noinclude=\"true\">\n\n%% implicit version\ntranslate-i : of M A -> of M' A -> type.\n%mode translate-i +D -D'.\n\n%% explicit version\ntranslate-e : {m : exp}{a : typ} {m' : exp}\n              of m a -> of m' a -> type.\n%mode translate-e +M +A -M' +D -D'.\n\n</twelf>\n\n== Defining explicit in terms of implicit ==\n\nSuppose we choose the implicit version and implement it, but later decide we prefer the explicit version. We can then define the explicit version in terms of the implicit one by simply leaving out arguments:\n\n<twelf>\n\n% implicit version\ntranslate-i : of M A -> of M' A -> type.\n%mode translate-i +D -D'.\n\ntranslate-i1 : translate-i of1 of0.\ntranslate-i0 : translate-i of0 of1.\n\n\n% explicit version\ntranslate-e : {m : exp}{a : typ} {m' : exp}\n              of m a -> of m' a -> type.\n%mode translate-e +M +A -M' +D -D'.\n\ntranslate-e/i : translate-e M A M' D D' <- translate-i D D'.\n\n%worlds () (translate-i _ _) (translate-e _ _ _ _ _).\n%total D (translate-i D _).\n\n%total D (translate-e _ _ _ D _).\n\n</twelf>\n\n== Defining implicit in terms of explicit ==\n\nSuppose we define the explicit version, and then choose to define the implicit version in terms of the explicit:\n\n<twelf>\n\n% explicit version\ntranslate2-e : {m : exp}{a : typ} {m' : exp}\n               of m a -> of m' a -> type.\n%mode translate2-e +M +A -M' +D -D'.\n\ntranslate2-e1 : translate2-e 1 bit 0 of1 of0.\ntranslate2-e1 : translate2-e 0 bit 1 of0 of1.\n\n% implicit version\ntranslate2-i : of M A -> of M' A -> type.\n%mode translate2-i +D -D'.\n\ntranslate2-i/e : translate2-i D D' <- translate2-e _ _ _ D D'.\n\n%worlds () (translate2-i _ _) (translate2-e _ _ _ _ _).\n\n%total D (translate2-e _ _ _ D _).\n%total D (translate2-i D _).\n\n</twelf>\n\nTwelf is able to deduce via its term reconstruction algorithm what M, M' and A are, so this is [[%mode|well-moded]].\n\n== Using annotations ==\n\nSometimes Twelf's term reconstruction algorithm is not powerful enough to automatically recover explicit parameters from implicit ones.{{discuss|Annotation example}} In general, one may use type annotations to get access to the implicit parameters to a relation. For example, we may write the <tt>translate2-i/e</tt> constant above as:\n\n<twelf noinclude=\"true\">\ntranslate2-i/e : translate2-i (D : of M A) D' <- translate2-e M A M' D D'.\n</twelf>\n\nHere we have access to the implicit inputs <tt>M</tt> and <tt>A</tt>, gleaned from the dependent type of <tt>D</tt>.\n\n<twelflink>All code for this tutorial</twelflink>.\n<twelflink check=\"true\">Twelf's output for this tutorial</twelflink>.\n\n{{stub tutorial}}"
          },
          "sha1": "6w7eusky58oyd3lhqlmqhqekpjtyr3g"
        }
      },
      {
        "title": "Correctness of mergesort",
        "ns": 0,
        "id": 2009,
        "revision": {
          "id": 4925,
          "parentid": 4924,
          "timestamp": "2007-10-11T01:34:58Z",
          "contributor": {
            "username": "DanielKLee",
            "id": 5
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 27002,
            "#text": "%{\nThis is an extended example of a proof of correctness of mergesort for lists without duplicates. In particular, it is an example of showing that an implementation of sorting (mergesort) matches up with a declarative definition that relates a list to its sort (i.e. the sorted list is a permutation of the unsorted list). \n}%\n\n\n%{\n=== Definitions ===\n\n==== Declarative definitions ====\n\nWe must first define natural numbers, lists of natural numbers, comparison on natural numbers, and what it means for one list to be the sorted version of another.\n}%\n\nnat : type.\n\nz : nat.\ns : nat -> nat.\n\n\n\nnat-less\t: nat -> nat -> type.\n\nnat-less/z\t: nat-less z (s _).\n\nnat-less/s\t: nat-less (s N) (s N')\n\t\t   <- nat-less N N'. \n\n\nnat-list\t: type. \n\nnat-list/nil\t: nat-list.\n\nnat-list/cons\t: nat -> nat-list -> nat-list. \n\n\n\nnat-list-head-less\t: nat -> nat-list -> type. \n\nnat-list-head-less/nil\t: nat-list-head-less N nat-list/nil. \n\nnat-list-head-less/cons\t: nat-list-head-less N (nat-list/cons N' _)\n\t\t\t   <- nat-less N N'. \n\n\nnat-list-sorted\t: nat-list -> type. \n\nnat-list-sorted/nil\t: nat-list-sorted nat-list/nil.\n\nnat-list-sorted/cons\t: nat-list-sorted (nat-list/cons N NL)\n\t\t\t   <- nat-list-head-less N NL\n\t\t\t   <- nat-list-sorted NL. \n\n\n\nin-nat-list\t: nat -> nat-list -> type. \n\nin-nat-list/hit\t: in-nat-list N (nat-list/cons N NL).\n\nin-nat-list/miss: in-nat-list N (nat-list/cons N' NL)\n\t\t   <- in-nat-list N NL. \n\nall-in-nat-list\t: nat-list -> nat-list -> type. \n\nall-in-nat-list/nil\t: all-in-nat-list nat-list/nil NL. \n\nall-in-nat-list/cons\t: all-in-nat-list (nat-list/cons N NL) NL'\n\t\t\t   <- in-nat-list N NL'\n\t\t\t   <- all-in-nat-list NL NL'. \n\n\n%{\nFor the purposes of this proof, we use a set-theoretic extensional definition of permutation, where two lists are permutations of each other if they contain the same set of elements. This is only a proper definition of permutation if we assume both lists contain no duplicates. This invariant is baked into both our definition of sorted and our definition of mergesort. \n}%\n\nnat-list-permute\t: nat-list -> nat-list -> type. \n\nnat-list-permute/i\t: nat-list-permute NL NL'\n\t\t\t   <- all-in-nat-list NL NL'\n\t\t\t   <- all-in-nat-list NL' NL. \n\n\n\nnat-list-declarative-sort\t: nat-list -> nat-list -> type. \n\nnat-list-declarative-sort/i\t: nat-list-declarative-sort NL NL'\n\t\t\t\t   <- nat-list-permute NL NL'\n\t\t\t\t   <- nat-list-sorted NL'.\n\n%{\n==== Definitions used to define mergesort ====\n}%\n\nsplit\t: nat-list -> nat-list -> nat-list -> type. \n\nsplit/nil\t: split nat-list/nil nat-list/nil nat-list/nil.\n\nsplit/1\t\t: split (nat-list/cons N nat-list/nil) (nat-list/cons N nat-list/nil) \n\t\t   nat-list/nil.\n\nsplit/cons\t: split (nat-list/cons N (nat-list/cons N' NL))\n\t\t   (nat-list/cons N NL1)\n\t\t   (nat-list/cons N' NL2)\n\t\t   <- split NL NL1 NL2.\n\n\nmerge\t: nat-list -> nat-list -> nat-list -> type. \n\nmerge/nil-1\t: merge nat-list/nil N N. \n\nmerge/nil-2\t: merge (nat-list/cons N NL) nat-list/nil (nat-list/cons N NL). \n\nmerge/cons-1\t: merge (nat-list/cons N1 NL1)\n\t\t   (nat-list/cons N2 NL2) \n\t\t   (nat-list/cons N1 NL)\n\t\t   <- nat-less N1 N2\n\t\t   <- merge NL1 (nat-list/cons N2 NL2) NL.\n\nmerge/cons-2\t: merge (nat-list/cons N1 NL1)\n\t\t   (nat-list/cons N2 NL2) \n\t\t   (nat-list/cons N2 NL)\n\t\t   <- nat-less N2 N1\n\t\t   <- merge NL2 (nat-list/cons N1 NL1) NL.\n\nmergesort\t: nat-list -> nat-list -> type. \n\nmergesort/nil\t: mergesort nat-list/nil nat-list/nil. \n\nmergesort/1\t: mergesort (nat-list/cons N nat-list/nil) \n\t\t   (nat-list/cons N nat-list/nil). \n\nmergesort/cons\t: mergesort NL1 NL2\n\t\t   <- split NL1 NLA NLB\n\t\t   <- mergesort NLA NLA'\n\t\t   <- mergesort NLB NLB'\n\t\t   <- merge NLA' NLB' NL2. \n\n%{ === Helper definitions used in proofs  === \n\n<tt>all-in-2 N1 N2 N3</tt> is a judgment that holds when all the elements in <tt>N1</tt> are in the union of <tt>N1</tt> and <tt>N2</tt>/\n\n}%\n\n% all-in-2 N1 N2 N3, everything in N1 is either in N2 or N3\n\nall-in-2\t:  nat-list -> nat-list -> nat-list -> type. \n\nall-in-2/nil\t: all-in-2 nat-list/nil NL1 NL2. \n\nall-in-2/cons-1\t: all-in-2 (nat-list/cons N NL) NL1 NL2\n\t\t   <- in-nat-list N NL1\n\t\t   <- all-in-2 NL NL1 NL2.\n\nall-in-2/cons-2\t: all-in-2 (nat-list/cons N NL) NL1 NL2\n\t\t   <- in-nat-list N NL2\n\t\t   <- all-in-2 NL NL1 NL2.\n\n%{ === Proof that mergesort returns a sorted result === }%\n\nnat-less-trans\t: nat-less N1 N2\n\t\t   -> nat-less N2 N3\n\t\t   -> nat-less N1 N3\n\t\t   -> type.\n%mode nat-less-trans +D1 +D2 -D3.\n\n-\t: nat-less-trans nat-less/z D1 nat-less/z.\n\n-\t: nat-less-trans (nat-less/s D1) (nat-less/s D2) (nat-less/s D3)\n\t   <- nat-less-trans D1 D2 D3.\n\n%worlds () (nat-less-trans _ _ _).\n%total (D1) (nat-less-trans D1 _ _). \n\n\n\nmerge-head-less\t: nat-list-head-less N NL\n\t\t   -> nat-less N N'\n\t\t   -> merge NL (nat-list/cons N' NL') NL''\n\t\t   -> nat-list-head-less N NL''\n\t\t   -> type.\n%mode merge-head-less +D1 +D2 +D3 -D4.\n\n\n-\t: merge-head-less _ DL merge/nil-1 (nat-list-head-less/cons DL).\n\n-\t: merge-head-less _ DL (merge/cons-2 _ _)\n\t   (nat-list-head-less/cons DL).\n\n-\t: merge-head-less (nat-list-head-less/cons DL) _\n\t   (merge/cons-1 _ _)\n\t   (nat-list-head-less/cons DL). \n\n\n%worlds () (merge-head-less _ _  _ _).\n%total (D1) (merge-head-less _ _ D1 _).\n\n\nmerge-sorted\t: nat-list-sorted NL1\n\t\t   -> nat-list-sorted NL2\n\t\t   -> merge NL1 NL2 NL3\n\t\t   -> nat-list-sorted NL3\n\t\t   -> type.\n%mode merge-sorted +D1 +D2 +D3 -D4.\n\n-\t: merge-sorted _ D1 merge/nil-1 D1.\n\n-\t: merge-sorted D1 _ merge/nil-2 D1.\n\n-\t: merge-sorted (nat-list-sorted/cons D1 DHL) D2 \n\t   (merge/cons-1 DM DL)\n\t   (nat-list-sorted/cons DS DHL')\n\t   <- merge-head-less DHL DL DM DHL'\n\t   <- merge-sorted D1 D2 DM DS.\n\n-\t: merge-sorted D2 (nat-list-sorted/cons D1 DHL)\n\t   (merge/cons-2 DM DL)\n\t   (nat-list-sorted/cons DS DHL')\n\t   <- merge-head-less DHL DL DM DHL'\n\t   <- merge-sorted D1 D2 DM DS.\n\n%worlds () (merge-sorted _ _ _ _).\n%total (D1) (merge-sorted _ _ D1 _).\n\n\nmergesort-sorted\t: mergesort NL NL'\n\t\t\t   -> nat-list-sorted NL'\n\t\t\t   -> type.\n%mode mergesort-sorted +D1 -D2.\n\n-\t: mergesort-sorted mergesort/nil nat-list-sorted/nil.\n\n-\t: mergesort-sorted mergesort/1 (nat-list-sorted/cons nat-list-sorted/nil nat-list-head-less/nil).\n\n-\t: mergesort-sorted (mergesort/cons DM D2 D1 _) DS\n\t   <- mergesort-sorted D1 DS1\n\t   <- mergesort-sorted D2 DS2\n\t   <- merge-sorted DS1 DS2 DM DS.\n\n%worlds () (mergesort-sorted _ _). \n%total (D1) (mergesort-sorted D1 _).\n\n\n\n%{ === Proof that mergesort returns a permutation of the input === }%\n\nall-in-2-wkn-l\t: {N}\n\t\t   all-in-2 NL NA NB\n\t\t   -> all-in-2 NL (nat-list/cons N NA) NB\n\t\t   -> type. \n%mode all-in-2-wkn-l +D1 +D2 -D3.\n\n-\t: all-in-2-wkn-l _ all-in-2/nil all-in-2/nil.\n\n-\t: all-in-2-wkn-l _ (all-in-2/cons-1 DHL DIN)\n\t   (all-in-2/cons-1 DHL' (in-nat-list/miss DIN))\n\t   <- all-in-2-wkn-l _ DHL DHL'. \n\n-\t: all-in-2-wkn-l _ (all-in-2/cons-2 DHL DIN)\n\t   (all-in-2/cons-2 DHL' DIN)\n\t   <- all-in-2-wkn-l _ DHL DHL'. \n\n%worlds () (all-in-2-wkn-l _ _ _).\n%total (D1) (all-in-2-wkn-l _ D1 _). \n\n\n\nall-in-2-wkn-r\t: {N}\n\t\t   all-in-2 NL NA NB\n\t\t   -> all-in-2 NL NA (nat-list/cons N NB)\n\t\t   -> type. \n%mode all-in-2-wkn-r +D1 +D2 -D3.\n\n\n-\t: all-in-2-wkn-r _ all-in-2/nil all-in-2/nil.\n\n-\t: all-in-2-wkn-r _ (all-in-2/cons-2 DHL DIN)\n\t   (all-in-2/cons-2 DHL' (in-nat-list/miss DIN))\n\t   <- all-in-2-wkn-r _ DHL DHL'. \n\n-\t: all-in-2-wkn-r _ (all-in-2/cons-1 DHL DIN)\n\t   (all-in-2/cons-1 DHL' DIN)\n\t   <- all-in-2-wkn-r _ DHL DHL'. \n\n%worlds () (all-in-2-wkn-r _ _ _).\n%total (D1) (all-in-2-wkn-r _ D1 _). \n\n\n\n\nsplit-all-in-2\t: split NL NA NB\n\t\t   -> all-in-2 NL NA NB\n\t\t   -> type. \n%mode split-all-in-2 +D1 -D2.\n\n-\t: split-all-in-2 split/nil all-in-2/nil.\n\n-\t: split-all-in-2 split/1 \n\t   (all-in-2/cons-1 all-in-2/nil in-nat-list/hit).\n\n-\t: split-all-in-2 (split/cons DS1)\n\t   (all-in-2/cons-1 \n\t      (all-in-2/cons-2 DS1''' in-nat-list/hit) in-nat-list/hit)\n\t   <- split-all-in-2 DS1 DS1'\n\t   <- all-in-2-wkn-l _ DS1' DS1''\n\t   <- all-in-2-wkn-r _ DS1'' DS1'''.\n\n%worlds () (split-all-in-2 _ _).\n%total (D1) (split-all-in-2 D1 _). \n\n\nall-in-nat-list-wkn\t: {N}\n\t\t\t   all-in-nat-list NL NL'\n\t\t\t   -> all-in-nat-list NL (nat-list/cons N NL')\n\t\t\t   -> type. \n%mode all-in-nat-list-wkn +D1 +D2 -D3.\n\n-\t: all-in-nat-list-wkn _ all-in-nat-list/nil all-in-nat-list/nil.\n\n-\t: all-in-nat-list-wkn _ (all-in-nat-list/cons DAS DIN)\n\t   (all-in-nat-list/cons DAS' (in-nat-list/miss DIN))\n\t   <- all-in-nat-list-wkn _ DAS DAS'.\n\n%worlds () (all-in-nat-list-wkn _ _ _). \n%total (D1) (all-in-nat-list-wkn _ D1 _). \n\n\nall-in-nat-list-refl\t: {NL}\n\t\t\t   all-in-nat-list NL NL\n\t\t\t   -> type. \n%mode all-in-nat-list-refl +D1 -D2. \n\n-\t: all-in-nat-list-refl _ all-in-nat-list/nil.\n\n-\t: all-in-nat-list-refl (nat-list/cons _ NL)\n\t   (all-in-nat-list/cons DHL' in-nat-list/hit)\n\t   <- all-in-nat-list-refl NL DHL\n\t   <- all-in-nat-list-wkn _ DHL DHL'.\n\n%worlds () (all-in-nat-list-refl _ _).\n%total (D1) (all-in-nat-list-refl D1 _). \n\n\nmerge-all-in\t: merge NLA NLB NL\n\t\t   -> all-in-nat-list NLA NL\n\t\t   -> all-in-nat-list NLB NL\n\t\t   -> type.\n%mode merge-all-in +D1 -D2 -D3.\n\n-\t: merge-all-in merge/nil-1 all-in-nat-list/nil D1\n\t   <- all-in-nat-list-refl _ D1.\n\n-\t: merge-all-in merge/nil-2 D1 all-in-nat-list/nil\n\t   <- all-in-nat-list-refl _ D1. \n\n-\t: merge-all-in (merge/cons-1 DM1 DL)\n\t   (all-in-nat-list/cons DHL1' in-nat-list/hit)\n\t   DHL2'\n\t   <- merge-all-in DM1 DHL1 DHL2\n\t   <- all-in-nat-list-wkn _ DHL1 DHL1'\n\t   <- all-in-nat-list-wkn _ DHL2 DHL2'. \n\n-\t: merge-all-in (merge/cons-2 DM1 DL)\n\t   DHL1'\n\t   (all-in-nat-list/cons DHL2' in-nat-list/hit)\n\t   <- merge-all-in DM1 DHL2 DHL1\n\t   <- all-in-nat-list-wkn _ DHL1 DHL1'\n\t   <- all-in-nat-list-wkn _ DHL2 DHL2'. \n\n\n%worlds () (merge-all-in _ _ _). \n%total (D1) (merge-all-in D1 _ _). \n\n\n\nin-nat-list-trans\t: in-nat-list N NL\n\t\t\t   -> all-in-nat-list NL NL'\n\t\t\t   -> in-nat-list N NL'\n\t\t\t   -> type. \n%mode in-nat-list-trans +D1 +D2 -D3. \n\n-\t: in-nat-list-trans in-nat-list/hit\n\t   (all-in-nat-list/cons _ D1) D1.\n\n-\t: in-nat-list-trans (in-nat-list/miss D1)\n\t   (all-in-nat-list/cons D _)\n\t   D1'\n\t   <- in-nat-list-trans D1 D D1'.\n\n%worlds () (in-nat-list-trans _ _ _). \n%total (D1) (in-nat-list-trans D1 _ _). \n\n\nall-in-2-trans\t: all-in-2 NL NA NB\n\t\t   -> all-in-nat-list NA NL'\n\t\t   -> all-in-nat-list NB NL'\n\t\t   -> all-in-nat-list NL NL'\n\t\t   -> type. \n%mode all-in-2-trans +D1 +D2 +D3 -D4. \n\n-\t: all-in-2-trans all-in-2/nil _ _ all-in-nat-list/nil.\n\n-\t: all-in-2-trans (all-in-2/cons-1 DHL DIN) \n\t   DA DB\n\t   (all-in-nat-list/cons DHL' DIN')\n\t   <- all-in-2-trans DHL DA DB DHL'\n\t   <- in-nat-list-trans DIN DA DIN'.\n\n-\t: all-in-2-trans (all-in-2/cons-2 DHL DIN) \n\t   DA DB\n\t   (all-in-nat-list/cons DHL' DIN')\n\t   <- all-in-2-trans DHL DA DB DHL'\n\t   <- in-nat-list-trans DIN DB DIN'.\n\n%worlds () (all-in-2-trans _ _ _ _).\n%total (D1) (all-in-2-trans D1 _ _ _). \n\n\nall-in-2-trans-a\t: all-in-2 NL NA NB\n\t\t\t   -> all-in-nat-list NA NA'\n\t\t\t   -> all-in-nat-list NB NB'\n\t\t\t   -> all-in-2 NL NA' NB'\n\t\t\t   -> type. \n%mode all-in-2-trans-a +D1 +D2 +D3 -D4. \n\n-\t: all-in-2-trans-a all-in-2/nil _ _ all-in-2/nil.\n\n-\t: all-in-2-trans-a (all-in-2/cons-1 DHL DIN) \n\t   DA DB\n\t   (all-in-2/cons-1 DHL' DIN')\n\t   <- all-in-2-trans-a DHL DA DB DHL'\n\t   <- in-nat-list-trans DIN DA DIN'.\n\n-\t: all-in-2-trans-a (all-in-2/cons-2 DHL DIN) \n\t   DA DB\n\t   (all-in-2/cons-2 DHL' DIN')\n\t   <- all-in-2-trans-a DHL DA DB DHL'\n\t   <- in-nat-list-trans DIN DB DIN'.\n\n%worlds () (all-in-2-trans-a _ _ _ _).\n%total (D1) (all-in-2-trans-a D1 _ _ _). \n\n\n\nmergesort-all-in\t: mergesort NL1 NL2\n\t\t\t   -> all-in-nat-list NL1 NL2\n\t\t\t   -> type. \n%mode mergesort-all-in +D1 -D2. \n\n-\t: mergesort-all-in mergesort/nil all-in-nat-list/nil.\n\n-\t: mergesort-all-in mergesort/1 (all-in-nat-list/cons all-in-nat-list/nil in-nat-list/hit).\n\n-\t: mergesort-all-in (mergesort/cons Dmerge Dms2 Dms1 Dsplit)\n\t   DHLtwo''\n\t   <- split-all-in-2 Dsplit \n\t      (DHLtwo : all-in-2 NL NA NB)\n\t   <- mergesort-all-in Dms1 \n\t      (DHL1  : all-in-nat-list NA NA')\n\t   <- mergesort-all-in Dms2 DHL2\n\t   <- merge-all-in Dmerge DHL3 DHL4\n\t   <- all-in-2-trans-a DHLtwo DHL1 DHL2 DHLtwo'\n\t   <- all-in-2-trans DHLtwo' DHL3 DHL4 DHLtwo''.\n\n%worlds () (mergesort-all-in _ _).\n%total (D1) (mergesort-all-in D1 _).\n\n\n\nall-in-2-refl-r\t: {NL} {NL'}\n\t\t   all-in-2 NL NL' NL\n\t\t   -> type. \n%mode all-in-2-refl-r +D1 +D2 -D3.\n\n-\t: all-in-2-refl-r _ _ all-in-2/nil.\n\n-\t: all-in-2-refl-r (nat-list/cons N NL) _ \n\t   (all-in-2/cons-2 DHL' in-nat-list/hit)\n\t   <- all-in-2-refl-r NL _ DHL\n\t   <- all-in-2-wkn-r _ DHL DHL'.\n\n%worlds () (all-in-2-refl-r _ _ _).\n%total (D1) (all-in-2-refl-r D1 _ _). \n\n\n\nall-in-2-refl-l\t: {NL} {NL'}\n\t\t   all-in-2 NL NL NL'\n\t\t   -> type. \n%mode all-in-2-refl-l +D1 +D2 -D3.\n\n-\t: all-in-2-refl-l _ _ all-in-2/nil.\n\n-\t: all-in-2-refl-l (nat-list/cons N NL) _ \n\t   (all-in-2/cons-1 DHL' in-nat-list/hit)\n\t   <- all-in-2-refl-l NL _ DHL\n\t   <- all-in-2-wkn-l _ DHL DHL'.\n\n%worlds () (all-in-2-refl-l _ _ _).\n%total (D1) (all-in-2-refl-l D1 _ _). \n\n\nall-in-2-sym\t: all-in-2 NL NA NB\n\t\t   -> all-in-2 NL NB NA\n\t\t   -> type. \n%mode all-in-2-sym +D1 -D2. \n\n-\t: all-in-2-sym all-in-2/nil all-in-2/nil. \n\n-\t: all-in-2-sym (all-in-2/cons-1 DHL DIN) \n\t   (all-in-2/cons-2 DHL' DIN)\n\t   <- all-in-2-sym DHL DHL'.\n\n-\t: all-in-2-sym (all-in-2/cons-2 DHL DIN) \n\t   (all-in-2/cons-1 DHL' DIN)\n\t   <- all-in-2-sym DHL DHL'.\n\n%worlds () (all-in-2-sym _ _).\n%total (D1) (all-in-2-sym D1 _).\n\n\n\nmerge-all-in-2\t: merge NA NB NL\n\t\t   -> all-in-2 NL NA NB\n\t\t   -> type. \n%mode merge-all-in-2 +D1 -D2. \n\n-\t: merge-all-in-2 merge/nil-1  D1\n\t   <- all-in-2-refl-r  _ _ D1.\n\n-\t: merge-all-in-2 merge/nil-2  D1\n\t   <- all-in-2-refl-l  _ _ D1.\n\n-\t: merge-all-in-2 (merge/cons-1 DM _)\n\t   (all-in-2/cons-1 DHL' in-nat-list/hit)\n\t   <- merge-all-in-2 DM DHL\n\t   <- all-in-2-wkn-l _ DHL DHL'. \n\n-\t: merge-all-in-2 (merge/cons-2 DM _)\n\t   (all-in-2/cons-2 DHL'' in-nat-list/hit)\n\t   <- merge-all-in-2 DM DHL\n\t   <- all-in-2-wkn-l _ DHL DHL'\n\t   <- all-in-2-sym DHL' DHL''. \n\n%worlds () (merge-all-in-2 _ _). \n%total (D1) (merge-all-in-2 D1 _). \n\n\n\nsplit-all-in\t: split NL NLA NLB\n\t\t   -> all-in-nat-list NLA NL\n\t\t   -> all-in-nat-list NLB NL\n\t\t   -> type.\n%mode split-all-in +D1 -D2 -D3.\n\n-\t: split-all-in split/nil all-in-nat-list/nil all-in-nat-list/nil.\n\n-\t: split-all-in split/1 (all-in-nat-list/cons all-in-nat-list/nil in-nat-list/hit) all-in-nat-list/nil. \n\n-\t: split-all-in (split/cons DS)\n\t   (all-in-nat-list/cons DHL'' in-nat-list/hit)\n\t   (all-in-nat-list/cons DBL'' (in-nat-list/miss in-nat-list/hit))\n\t   <- split-all-in DS DHL DBL\n\t   <- all-in-nat-list-wkn _ DHL DHL'\n\t   <- all-in-nat-list-wkn _ DHL' DHL''\n\t   <- all-in-nat-list-wkn _ DBL DBL'\n\t   <- all-in-nat-list-wkn _ DBL' DBL''.\n\n%worlds () (split-all-in _ _ _).\n%total (D1) (split-all-in D1 _ _). \n\n\n\nmergesort-all-in-r\t: mergesort NLA NLB\n\t\t\t   -> all-in-nat-list NLB NLA\n\t\t\t   -> type. \n%mode mergesort-all-in-r +D1 -D2.\n\n-\t: mergesort-all-in-r mergesort/nil all-in-nat-list/nil.\n\n-\t: mergesort-all-in-r mergesort/1 (all-in-nat-list/cons all-in-nat-list/nil in-nat-list/hit).\n\n-\t: mergesort-all-in-r (mergesort/cons Dmerge Dms2 Dms1 Dsplit)\n\t   DHLtwo''\n\t   <- merge-all-in-2 Dmerge\n\t      (DHLtwo : all-in-2 NL NA NB)\n\t   <- mergesort-all-in-r Dms1 \n\t      (DHL1  : all-in-nat-list NA NA')\n\t   <- mergesort-all-in-r Dms2 DHL2\n\t   <- split-all-in Dsplit DHL3 DHL4\n\t   <- all-in-2-trans-a DHLtwo DHL1 DHL2 DHLtwo'\n\t   <- all-in-2-trans DHLtwo' DHL3 DHL4 DHLtwo''.\n\n%worlds () (mergesort-all-in-r _ _). \n%total (D1) (mergesort-all-in-r D1 _). \n\n\n\nmergesort-permute\t: mergesort N1 N2\n\t\t\t   -> nat-list-permute N1 N2\n\t\t\t   -> type.\n%mode mergesort-permute +D1 -D2. \n\n-\t: mergesort-permute D1 (nat-list-permute/i DB DA)\n\t   <- mergesort-all-in D1 DA\n\t   <- mergesort-all-in-r D1 DB. \n\n%worlds () (mergesort-permute _ _).\n%total {} (mergesort-permute _ _).\n\n\n%{ === Final result === \nShowing the final result merely requires composing the two big intermediate results, namely that mergesort produces a sorted output and that mergesort's output is a permutation of the input.\n\n}%\n\nmergesort-correct\t: mergesort N1 N2\n\t\t\t   -> nat-list-declarative-sort N1 N2\n\t\t\t   -> type. \n%mode mergesort-correct +D1 -D2.\n\n-\t: mergesort-correct D1 (nat-list-declarative-sort/i Dsorted Dpermute)\n\t   <- mergesort-permute D1 Dpermute\n\t   <- mergesort-sorted D1 Dsorted.\n\n%worlds () (mergesort-correct _ _).\n%total {} (mergesort-correct _ _). \n\n\n%{\n\n----\n\n== Equivalence of definitions of permutations ==\n\nWe can also show that <tt>nat-list-permute</tt> under the right constraints (implied by <tt>nat-list-sorted</tt> is equivalent to a definition of permutations as a composition of swaps.\n\nNote: Maybe this should be its own article?\n\n}%\n\n\nall-in-nat-list-trans\t: all-in-nat-list N1 N2\n\t\t\t   -> all-in-nat-list N2 N3\n\t\t\t   -> all-in-nat-list N1 N3\n\t\t\t   -> type. \n%mode all-in-nat-list-trans +D1 +D2 -D3. \n\n-\t: all-in-nat-list-trans all-in-nat-list/nil _ all-in-nat-list/nil.\n\n-\t: all-in-nat-list-trans (all-in-nat-list/cons D2 D1) D3\n\t   (all-in-nat-list/cons D5 D4)\n\t   <- in-nat-list-trans D1 D3 D4\n\t   <- all-in-nat-list-trans D2 D3 D5.\n\n%worlds () (all-in-nat-list-trans _ _ _).\n%total (D1) (all-in-nat-list-trans D1 _ _). \n\n\n\nnat-list-permutes\t: nat-list -> nat-list -> type. \n\nnat-list-permutes/nil\t: nat-list-permutes nat-list/nil nat-list/nil.\n\nnat-list-permutes/cons\t: nat-list-permutes (nat-list/cons N1 NL)\n\t\t\t   (nat-list/cons N1 NL')\n\t\t\t   <- nat-list-permutes NL NL'.\n\nnat-list-permutes/swap\t: nat-list-permutes \n\t\t\t   (nat-list/cons N1 (nat-list/cons N2 NL))\n\t\t\t   (nat-list/cons N2 (nat-list/cons N1 NL)).\n\nnat-list-permutes/trans\t: nat-list-permutes N1 N3\n\t\t\t   <- nat-list-permutes N1 N2\n\t\t\t   <- nat-list-permutes N2 N3.\n\n\n\nnat-list-permutes-all-in: nat-list-permutes N1 N2\n\t\t\t   -> all-in-nat-list N1 N2\n\t\t\t   -> type. \n%mode nat-list-permutes-all-in +D1 -D2.\n\n-\t: nat-list-permutes-all-in nat-list-permutes/nil\n\t   all-in-nat-list/nil.\n\n-\t: nat-list-permutes-all-in (nat-list-permutes/cons D1)\n\t   (all-in-nat-list/cons D2' in-nat-list/hit)\n\t   <- nat-list-permutes-all-in D1 D2\n\t   <- all-in-nat-list-wkn _ D2 D2'.\n\n-\t: nat-list-permutes-all-in nat-list-permutes/swap\n\t   (all-in-nat-list/cons \n\t      (all-in-nat-list/cons D1'' in-nat-list/hit)\n\t      (in-nat-list/miss in-nat-list/hit))\n\t   <- all-in-nat-list-refl _ D1\n\t   <- all-in-nat-list-wkn _ D1 D1'\n\t   <- all-in-nat-list-wkn _ D1' D1''.\n\n-\t: nat-list-permutes-all-in (nat-list-permutes/trans D2 D1) D3'\n\t   <- nat-list-permutes-all-in D1 D1'\n\t   <- nat-list-permutes-all-in D2 D2'\n\t   <- all-in-nat-list-trans D1' D2' D3'. \n\n%worlds () (nat-list-permutes-all-in _ _).\n%total (D1) (nat-list-permutes-all-in D1 _). \n\nnat-neq\t: nat -> nat -> type.\n\nnat-neq/l\t: nat-neq N1 N2\n\t\t   <- nat-less N1 N2.\nnat-neq/r\t: nat-neq N1 N2\n\t\t   <- nat-less N2 N1.  \n\nnin-nat-list\t: nat -> nat-list -> type.\n\nnin-nat-list/nil\t: nin-nat-list N1 nat-list/nil.\n\nnin-nat-list/cons\t: nin-nat-list N1 (nat-list/cons N2 NL)\n\t\t\t   <- nat-neq N1 N2\n\t\t\t   <- nin-nat-list N1 NL.\n\nnat-list-no-dups\t: nat-list -> type. \n\nnat-list-no-dups/nil\t: nat-list-no-dups nat-list/nil.\n\nnat-list-no-dups/cons\t: nat-list-no-dups (nat-list/cons N1 NL)\n\t\t\t   <- nin-nat-list N1 NL\n\t\t\t   <- nat-list-no-dups NL.\n\n\nnat-list-permutes-refl\t: {NL} nat-list-permutes NL NL\n\t\t\t   -> type.\n%mode nat-list-permutes-refl +D1 -D2.\n\n-\t: nat-list-permutes-refl nat-list/nil nat-list-permutes/nil.\n\n-\t: nat-list-permutes-refl (nat-list/cons _ NL)\n\t   (nat-list-permutes/cons D1)\n\t   <- nat-list-permutes-refl NL D1. \n\n%worlds () (nat-list-permutes-refl _ _).\n%total (D1) (nat-list-permutes-refl D1 _).\n\n\n\nnat-list-permutes-sym\t: nat-list-permutes N1 N2\n\t\t\t   -> nat-list-permutes N2 N1\n\t\t\t   -> type.\n%mode nat-list-permutes-sym +D1 -D2.\n\n-\t: nat-list-permutes-sym nat-list-permutes/nil nat-list-permutes/nil.\n\n-\t: nat-list-permutes-sym (nat-list-permutes/cons D1)\n\t   (nat-list-permutes/cons D1')\n\t   <- nat-list-permutes-sym D1 D1'.\n\n-\t: nat-list-permutes-sym nat-list-permutes/swap nat-list-permutes/swap. \n\n-\t: nat-list-permutes-sym (nat-list-permutes/trans D2 D1)\n\t   (nat-list-permutes/trans D1' D2')\n\t   <- nat-list-permutes-sym D1 D1'\n\t   <- nat-list-permutes-sym D2 D2'.\n\n%worlds () (nat-list-permutes-sym _ _).\n%total (D1) (nat-list-permutes-sym D1 _).\n\n\nnat-list-permutes-swap-head-2\t: nat-list-permutes  NN\n\t\t\t\t   (nat-list/cons N1 (nat-list/cons N2 NL))\n\t\t\t\t   -> nat-list-permutes \n\t\t\t\t      NN\n\t\t\t\t      (nat-list/cons N2 (nat-list/cons N1 NL))\n\t\t\t\t   -> type. \n%mode nat-list-permutes-swap-head-2 +D1 -D4.\n\n-\t: nat-list-permutes-swap-head-2 D1 \n\t   (nat-list-permutes/trans nat-list-permutes/swap D1).\n\n%worlds () (nat-list-permutes-swap-head-2 _ _).\n%total {} (nat-list-permutes-swap-head-2 _ _).\n\n\n\nin-nat-list-permutes\t: in-nat-list N1 NL\n\t\t\t   -> nat-list-permutes NL (nat-list/cons N1 NL')\n\t\t\t   -> type. \n%mode in-nat-list-permutes +D1 -D2. \n\n-\t: in-nat-list-permutes in-nat-list/hit D1\n\t   <- nat-list-permutes-refl _ D1.\n\n-\t: in-nat-list-permutes \n\t   (in-nat-list/miss (D1 : in-nat-list N (nat-list/cons N2 NL)))\n\t   DP\n\t   <- in-nat-list-permutes D1 \n\t      (DL : nat-list-permutes (nat-list/cons N2 NL) \n\t\t     (nat-list/cons N NL'))\n\t   <- nat-list-permutes-swap-head-2 (nat-list-permutes/cons DL) DP.\n\n%worlds () (in-nat-list-permutes _ _).\n%total (D1) (in-nat-list-permutes D1 _). \n\n\n\nnin-nat-list-permutes\t: nin-nat-list N1 NL\n\t\t\t   -> nat-list-permutes NL NL'\n\t\t\t   -> nin-nat-list N1 NL'\n\t\t\t   -> type.\n%mode nin-nat-list-permutes +D1 +D2 -D3.\n\n-\t: nin-nat-list-permutes _ nat-list-permutes/nil nin-nat-list/nil.\n\n-\t: nin-nat-list-permutes (nin-nat-list/cons D1 Dneq)\n\t   (nat-list-permutes/cons D2)\n\t   (nin-nat-list/cons D1' Dneq)\n\t   <- nin-nat-list-permutes D1 D2 D1'.\n\n-\t: nin-nat-list-permutes \n\t   (nin-nat-list/cons (nin-nat-list/cons D1 Dneq2) Dneq1)\n\t   nat-list-permutes/swap\n\t   (nin-nat-list/cons (nin-nat-list/cons D1 Dneq1) Dneq2).\n\n-\t: nin-nat-list-permutes D1 (nat-list-permutes/trans D3 D2) \n\t   D1''\n\t   <- nin-nat-list-permutes D1 D2 D1'\n\t   <- nin-nat-list-permutes D1' D3 D1''.\n\n%worlds () (nin-nat-list-permutes _ _ _). \n%total (D1) (nin-nat-list-permutes _ D1 _).\n\n\nnat-neq-sym\t: nat-neq N1 N2\n\t\t   -> nat-neq N2 N1\n\t\t   -> type.\n%mode nat-neq-sym +D1 -D2.\n\n-\t: nat-neq-sym (nat-neq/l D1) (nat-neq/r D1).\n\n-\t: nat-neq-sym (nat-neq/r D1) (nat-neq/l D1).\n\n%worlds () (nat-neq-sym _ _).\n%total {} (nat-neq-sym _ _).\n\n\nno-dups-permutes\t: nat-list-no-dups N1 \n\t\t\t   -> nat-list-permutes N1 N2\n\t\t\t   -> nat-list-no-dups N2\n\t\t\t   -> type.\n%mode no-dups-permutes +D1 +D2 -D3.\n\n-\t: no-dups-permutes _ nat-list-permutes/nil nat-list-no-dups/nil.\n\n-\t: no-dups-permutes (nat-list-no-dups/cons D2 D1)\n\t   (nat-list-permutes/cons D3) \n\t   (nat-list-no-dups/cons D2' D1')\n\t   <- nin-nat-list-permutes D1 D3 D1'\n\t   <- no-dups-permutes D2 D3 D2'.\n\n-\t: no-dups-permutes \n\t   (nat-list-no-dups/cons \n\t      (nat-list-no-dups/cons D3 DninB)\n\t      (nin-nat-list/cons DninA DneqA1))\n\t   nat-list-permutes/swap \n\t   (nat-list-no-dups/cons \n\t      (nat-list-no-dups/cons D3 DninA)\n\t      (nin-nat-list/cons DninB DneqA1'))\n\t   <- nat-neq-sym DneqA1 DneqA1'.\n\n-\t: no-dups-permutes D1 (nat-list-permutes/trans D3 D2) D1''\n\t   <- no-dups-permutes D1 D2 D1'\n\t   <- no-dups-permutes D1' D3 D1''.\n\n%worlds () (no-dups-permutes _ _ _).\n%total (D1) (no-dups-permutes _ D1 _).\n\n\nnat-list-length\t: nat-list -> nat -> type.\n\nnat-list-length/z\t: nat-list-length nat-list/nil z.\n\nnat-list-length/s\t: nat-list-length (nat-list/cons _ NL) (s N)\n\t\t\t   <- nat-list-length NL N.\n\n\npermutes-length\t: nat-list-length NL N\n\t\t   -> nat-list-permutes NL NL'\n\t\t   -> nat-list-length NL' N\n\t\t   -> type.\n%mode permutes-length +D1 +D2 -D3.\n\n-\t: permutes-length _ nat-list-permutes/nil nat-list-length/z.\n\n-\t: permutes-length (nat-list-length/s D1)\n\t   (nat-list-permutes/cons D2)\n\t   (nat-list-length/s D3)\n\t   <- permutes-length D1 D2 D3.\n\n-\t: permutes-length (nat-list-length/s (nat-list-length/s D1))\n\t   nat-list-permutes/swap\n\t   (nat-list-length/s (nat-list-length/s D1)).\n\n-\t: permutes-length D1 (nat-list-permutes/trans D3 D2) \n\t   D3'\n\t   <- permutes-length D1 D2 D1'\n\t   <- permutes-length D1' D3 D3'.\n\n%worlds () (permutes-length _ _ _).\n%total (D1) (permutes-length _ D1 _).\n\n\n\nuninhabited\t: type.\n\nnat-less-irrefl\t: nat-less N1 N1\n\t\t   -> uninhabited\n\t\t   -> type.\n%mode nat-less-irrefl +D1 -D3.\n\n-\t: nat-less-irrefl (nat-less/s D1) DU\n\t   <- nat-less-irrefl D1 DU.\n\n%worlds () (nat-less-irrefl _ _).\n%total (D1) (nat-less-irrefl D1 _).\n\nnat-neq-irrefl\t: nat-neq N1 N1\n\t\t   -> uninhabited\n\t\t   -> type.\n%mode nat-neq-irrefl +D1 -D2.\n\n-\t: nat-neq-irrefl (nat-neq/l D1) DU\n\t   <- nat-less-irrefl D1 DU.\n\n-\t: nat-neq-irrefl (nat-neq/r D1) DU\n\t   <- nat-less-irrefl D1 DU.\n\n%worlds () (nat-neq-irrefl _ _).\n%total {} (nat-neq-irrefl _ _).\n\n\nuninhabited-in-nat-list\t: {N1}{NL}\n\t\t\t   uninhabited\n\t\t\t   -> in-nat-list N1 NL\n\t\t\t   -> type.\n%mode uninhabited-in-nat-list +D1 +D2 +D3 -D4.\n\n%worlds () (uninhabited-in-nat-list _ _ _ _).\n%total {} (uninhabited-in-nat-list _ _ _ _).\n\nin-nat-list-strengthen\t: nat-neq N1 NA\n\t\t\t   -> in-nat-list NA (nat-list/cons N1 NL')\n\t\t\t   -> in-nat-list NA NL'\n\t\t\t   -> type.\n%mode in-nat-list-strengthen +D1 +D2 -D4.\n\n-\t: in-nat-list-strengthen _ (in-nat-list/miss D1) D1.\n\n-\t: in-nat-list-strengthen D1 in-nat-list/hit D1'\n\t   <- nat-neq-irrefl D1 DU\n\t   <- uninhabited-in-nat-list _ _ DU D1'.\n\n%worlds () (in-nat-list-strengthen _ _ _).\n%total (D1) (in-nat-list-strengthen _ D1 _). \n\nall-in-strengthen\t: nin-nat-list N1 NL\n\t\t\t   -> all-in-nat-list NL (nat-list/cons N1 NL')\n\t\t\t   -> all-in-nat-list NL NL'\n\t\t\t   -> type. \n%mode all-in-strengthen +D1 +D2 -D3.\n\n-\t: all-in-strengthen _ all-in-nat-list/nil all-in-nat-list/nil.\n\n-\t: all-in-strengthen (nin-nat-list/cons D1 Dneq)\n\t   (all-in-nat-list/cons DB DA)\n\t   (all-in-nat-list/cons DB' DA')\n\t   <- all-in-strengthen D1 DB DB'\n\t   <- in-nat-list-strengthen Dneq DA DA'.\n\n%worlds () (all-in-strengthen _ _ _).\n%total (D1) (all-in-strengthen _ D1 _).\n\n\n\nall-in-no-dups-permutes\t: {N}\n\t\t\t   nat-list-no-dups NL\n \t\t\t   -> nat-list-length NL N\n \t\t\t   -> nat-list-length NL' N\n\t\t\t   -> all-in-nat-list NL NL'\n\t\t\t   -> nat-list-permutes NL NL'\n\t\t\t   -> type.\n%mode all-in-no-dups-permutes +N +D1 +D2 +D3 +D4 -D5.\n\n-\t: all-in-no-dups-permutes _ _ _ _ all-in-nat-list/nil\n\t   nat-list-permutes/nil.\n\n-\t: all-in-no-dups-permutes \n\t   _\n\t   (nat-list-no-dups/cons D1 DNINN)\n\t   (nat-list-length/s Dl1)\n\t   DN\n\t   (all-in-nat-list/cons (DA : all-in-nat-list NL NL') DIN)\n\t   (nat-list-permutes/trans DP' (nat-list-permutes/cons DPP))\n\t   <- in-nat-list-permutes DIN \n\t      (DP : nat-list-permutes NL' (nat-list/cons N1 NL''))\n \t   <- nat-list-permutes-all-in DP \n\t      (DIN' : all-in-nat-list NL' (nat-list/cons N1 NL''))\n\t   <- permutes-length DN\n\t      DP (nat-list-length/s D3')\n\t   <- all-in-nat-list-trans DA DIN' DIN''\n \t   <- all-in-strengthen DNINN DIN'' DIN'''\n\t   <- all-in-no-dups-permutes _ D1 Dl1 D3' DIN''' DPP\n \t   <- nat-list-permutes-sym DP DP'.\n\n%worlds () (all-in-no-dups-permutes _ _ _ _ _ _). \n%total (D1) (all-in-no-dups-permutes D1 _ _ _ _ _).\n\n%{\n\nTODO: Finish commentary on the proof. \n\n{{stub}}\n}%"
          },
          "sha1": "f6tl522w9cu33o1pbwnfhlq1xzx36gf"
        }
      },
      {
        "title": "Coverage checking",
        "ns": 0,
        "id": 1966,
        "revision": {
          "id": 6507,
          "parentid": 6506,
          "timestamp": "2012-01-08T15:31:54Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "minor": null,
          "comment": "Reverted edits by [[Special:Contributions/User 6a58815ca3b629c|User 6a58815ca3b629c]] ([[User talk:User 6a58815ca3b629c|talk]]) to last revision by [[User:Rsimmons|Rsimmons]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 3469,
            "#text": "'''Coverage checking''' is used to describe two analyses that Twelf needs to perform in order to verify [[totality assertions]]. \n\nThe first analysis, for '''input coverage''', is performed by both <tt>[[%total]]</tt> and <tt>[[%covers]]</tt> declarations and resembles exhaustiveness checking in a language like ML. \n\nThe second analysis, '''output coverage''', is performed only by <tt>[[%total]]</tt> to ensure that the outputs of subgoals are sufficiently general.  Output coverage consists of a check for incorrect constant pattern-matching and a check for [[output freeness]] violations.  \n\nWe will use the common example of [[natural numbers]] for this example:\n\n<twelf import=\"nat\">\nnat: type.\n\nz: nat.\ns: nat -> nat.\n\n</twelf>\n\n== Input coverage ==\n\nInput coverage is similar to exhaustiveness checking in ML, in that it ensures that your relation is prepared to accept any input that is thrown at it. We would run afoul of the input coverage checker if we tried to run a <tt>%covers</tt> or <tt>%total</tt> declaration on the relation <tt>half</tt> that halves a natural number but is undefined on odd numbers. Another example of input coverage checking can be seen at the page on <tt>[[%covers]]</tt>.\n\n<twelf import=\"nat\" export=\"one\">\nhalf : nat -> nat -> type.\n%mode half +N1 -N2. \n\nhalf/z : half z z.\nhalf/s : half (s (s N)) (s M)\n          <- half N M.\n\n%worlds () (half _ _).\n</twelf>\n\n<twelf import=\"one\" check=decl discard=true>\n%total N (half N _).\n</twelf>\n\n== Output coverage ==\n\nOutput coverage ensures that your relation is prepared to deal with any possible term that it might be output by a [[subgoal]]. Output coverage does not have quite so obvious a counterpart in functional languages like ML; the reason is that Twelf differentiates between case-analyzing outputs and case-analyzing inputs, whereas in ML there is just one case construct.  \n\n=== Output constant pattern-matching ===\n\nSay we attempted to fix <tt>half</tt> by defining <tt>half</tt> of 1 to be 0 by adding the case <tt>half/1</tt> shown below:\n\n<twelf import=\"nat\" export=\"two\">\nhalf : nat -> nat -> type.\n%mode half +N1 -N2.\n\nhalf/z : half z z.\nhalf/1 : half (s z) z\n          <- half z z.\nhalf/s : half (s (s N)) (s M)\n          <- half N M.\n\n%worlds () (half _ _).\n</twelf>\n\nFor pedagogical purposes, we have given the constant <tt>half/1</tt> an unnecessary extra premise that <tt>half z z </tt>.  Thus, the case <tt>half/1</tt> expects the \"output\" of the subgoal <tt>&lt;- half z z</tt> to be <tt>z</tt>; inspecting the program, this is a true fact, but Twelf is not capable of verifying this and complains accordingly.\n\n<twelf import=\"two\" check=decl>\n%total N (half N _).\n</twelf>\n\nIn this case, we can fix the problem in one of two ways. First, we can remove the subgoal entirely:\n\n<twelf discard=true>\nhalf/1 : half (s z) z.\n</twelf>\n\nAlternatively, we can rewrite the subgoal, leaving the output a free variable:\n\n<twelf discard=true>\nhalf/1 : half (s z) N\n          <- half z N.\n</twelf>\n\nIn many circumstances when the output coverage checker rejects a totality assertion that should, in fact, be true, a standard technique [[output factoring]] can deal with the problem.\n\n=== Output freeness === \n\nThe other part of output coverage checking is [[output freeness]] checking; see its page for a definition and examples.\n\n== See also ==\n\n* {{guide|section=52|chapter=9|title=Coverage}}\n* [[Output freeness]]\n* [[Debugging coverage errors]]\n* [[Output factoring]]"
          },
          "sha1": "t3t5xzge23ipde0znzbl3kc7g5pdko0"
        }
      },
      {
        "title": "Cut",
        "ns": 0,
        "id": 1786,
        "redirect": {
          "@title": "Admissibility of cut",
          "#text": null
        },
        "revision": {
          "id": 3247,
          "timestamp": "2006-10-30T20:00:09Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "comment": "might as well take this too",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 34,
            "#text": "#REDIRECT [[admissibility of cut]]"
          },
          "sha1": "nfg567gep1jjtaznxcdcf8hi9hx0svd"
        }
      },
      {
        "title": "Cut elimination",
        "ns": 0,
        "id": 1785,
        "redirect": {
          "@title": "Admissibility of cut",
          "#text": null
        },
        "revision": {
          "id": 3246,
          "timestamp": "2006-10-30T19:59:53Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "comment": "other common name",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 34,
            "#text": "#REDIRECT [[admissibility of cut]]"
          },
          "sha1": "nfg567gep1jjtaznxcdcf8hi9hx0svd"
        }
      },
      {
        "title": "Debugging coverage errors",
        "ns": 0,
        "id": 1913,
        "revision": {
          "id": 6493,
          "parentid": 5158,
          "timestamp": "2011-11-02T18:52:38Z",
          "contributor": {
            "username": "Sully",
            "id": 87
          },
          "comment": "Fix to not use deprecated TwelfTags that produce warnings",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 15658,
            "#text": "This page lists techniques for debugging [[input coverage]] and [[output coverage]] errors.\n\n== Debugging input coverage errors by adding type annotations ==\n\n=== Motivating example ===\n\nAs a motivating example, we define a simple subtyping relation on the types of a programming language.  The language includes integers, floating point numbers, and functions.  We consider <tt>int</tt> to be a subtype of <tt>float</tt>, and we give the usual contravariant rule for functions:\n\n<twelf>\ntp    : type.\nint   : tp.\nfloat : tp.\narrow : tp -> tp -> tp.\n\nsub       : tp -> tp -> type.\nsub-ii    : sub int int.\nsub-ff    : sub float float.\nsub-if    : sub int float.\nsub-arrow : sub (arrow T S) (arrow T' S')\n\t     <- sub T' T\n\t     <- sub S S'.\n</twelf>\n\nLet's prove that this subtyping relation is transitive.  When writing Twelf code, it's sometimes convenient to just blaze ahead with a proof without thinking to hard about what you're doing, and then think about what's going on only if Twelf reports an error.  So a first proof attempt might look like this:\n\n<twelf>\nsub-trans : sub T1 T2 -> sub T2 T3 -> sub T1 T3 -> type.\n%mode sub-trans +X1 +X2 -X3.\n\n- : sub-trans (D : sub T T) (D' : sub T T) D.\n- : sub-trans sub-ii sub-if sub-if.\n- : sub-trans sub-if sub-ff sub-if.\n\n-arrow : sub-trans \n         (sub-arrow DS DT)\n         (sub-arrow DS' DT')\n         (sub-arrow DS'' DT'')\n         <- sub-trans DT DT' DT''\n         <- sub-trans DS DS' DS''.\n\n</twelf>\n\nWe let our fingers do the proving and came up with the straightforward inductive proof.  Each case type checks.  Does it work?\n\n<twelf check=\"decl\" discard=true>\n%worlds () (sub-trans _ _ _).\n%total D (sub-trans D _ _).\n</twelf>\n\nTwelf reports an input coverage error: we didn't cover the case for <tt>sub-arrow</tt> against <tt>sub-arrow</tt>.  \nWe think: \"But I wrote a case for <tt>sub-arrow</tt> against <tt>sub-arrow</tt> right up there!  What do you mean I didn't cover it?!\"\n\n=== Debugging technique === \n\nWhat Twelf is saying is that we didn't cover the '''general''' case for <tt>sub-arrow</tt> against <tt>sub-arrow</tt>.  That is, the inferred type of the constant <tt>-arrow</tt> must be less general than required.   One way to figure out the problem is to read the type of the constant:\n<twelf check=\"decl\" export=\"branch\">\n-arrow : sub-trans \n         (sub-arrow DS DT)\n         (sub-arrow DS' DT')\n         (sub-arrow DS'' DT'')\n         <- sub-trans DT DT' DT''\n         <- sub-trans DS DS' DS''.\n</twelf>\nAs you can see, the type that Twelf inferred has the '''same''' type <tt>X4</tt> as all three types related by <tt>DT</tt> and <tt>DT'</tt>.  Because Twelf unified these parameters, <tt>-arrow</tt> doesn't cover the whole space that we think it does.  \n\nNow, we have to figure out why Twelf inferred this type.  What mistake did we actually make?  One good way to figure this out is to start adding type annotations giving the constants fully general types.  By doing so, we can turn a coverage error into a type error on the constant.  \n\nFor example, let's annotate this constant more carefully with what we expect the inputs to be:\n<twelf check=\"decl\" import=\"branch\" export=\"branch\">\n-arrow : sub-trans \n         (sub-arrow (DS : sub S1 S2) (DT : sub T2 T1))\n         (sub-arrow (DS' : sub S2 S3) (DT' : sub T3 T2))\n         (sub-arrow DS'' DT'')\n         <- sub-trans DT DT' DT''\n         <- sub-trans DS DS' DS''.\n</twelf>\n\nThis causes Twelf to report a type error, so we know we're on the right track—the constant doesn't cover what we want it to.\n\nWe can make this type error more comprehensible by removing some of the constraints.  Specifically, we can take out the return term to remove some of the constraints on <tt>DT''</tt>:\n<twelf check=\"decl\" export=\"branch2\">\n-arrow : sub-trans \n         (sub-arrow (DS : sub S1 S2) (DT : sub T2 T1))\n         (sub-arrow (DS' : sub S2 S3) (DT' : sub T3 T2))\n         _\n         <- sub-trans DT DT' DT''\n         <- sub-trans DS DS' DS''.\n</twelf>\nAh ha!  Twelf is pointing us to the first premise, as saying that because <tt>DT</tt> has type <tt>sub T2 T1</tt>, the second argument <tt>DT'</tt> needs to have type <tt>sub T1 X1</tt> for some <tt>X1</tt>; but we wrote a term with type <tt>sub T3 T2</tt>.  If we annotate the constant enough that Twelf knows that <tt>T1</tt> and <tt>T3</tt> are supposed to be different, this is reported as a type error.  Otherwise, Twelf unifies these two, coming up with a valid type for the constant; but because this type doesn't cover the part of the relation that we thought it did, we get an input coverage error.  \n\nAs you may have figured out already, the problem is that the first recursive call should swap the two arguments:\n<twelf check=\"decl\" export=\"branch3\">\n-arrow : sub-trans \n         (sub-arrow (DS : sub S1 S2) (DT : sub T2 T1))\n         (sub-arrow (DS' : sub S2 S3) (DT' : sub T3 T2))\n         (sub-arrow DS'' DT'')\n         <- sub-trans DT' DT DT''\n         <- sub-trans DS DS' DS''.\n</twelf>\n\nIn this example, this \"fix\" itself creates some termination trouble; see the article on [[mutual induction]] for a completed proof.  But the broken proof illustrates a useful technique for coverage checking.  \n\n=== A Messy Example ===\n\nIn the previous example, adding types to some variables caused a coverage error to be converted into a type error.\nBut a complex case may have many many variables.  Coverage errors can be very hard to find in this case.\nIn the following situation (from [[User:Boyland|me=John Boyland]]), it is shown how to leverage the Twelf server to do most\nof the work.  Suppose (and this happened to me), one has a coverage error that \"should\" have been covered by the following horrendous case:\n<pre>\n- : wk-is/L ES \n       (access/read\n          (ready/ (read (lit (object/ O)) F) TL1 L1 A))\n       ML NFL XTL XSF FE ESG WA XPK XSM NHBP\n       (incorrectly-synchronized/W \n          (eval-seq/+ ESN \n             (fulleval/ _ (lit (object/ O')) TL1N L1 \n                (eRead ML' NFL' TL1N K>Z) TL1N TU1N))\n          (eval-seq-get/ (eval-seq-includes/> ESI'))\n          (eval-seq-get/ eval-seq-includes/=) WA'\n          (access/read\n             (ready/ (read (lit (object/ O)) F) TL1N L1 A))\n          NHB')\n    <- no-know-eval-seq-exists ES _ (no-know-state/ NM NTS) ESN ESM\n        (state-match/ MM TSM)\n    <- eval-seq-get-respects-match ESG ESM _ _ _ (eval-seq-get/ ESI') FEM\n    <- mem-lookup-respects-match ML MM _ ML' (objs-match/ NFM _ _)\n    <- no-know-mem-lookup-implies-no-know-contents ML' NM (no-know-objs/ NNF _ _)\n    <- normal-fields-lookup-respects-match NFL NFM _ NFL'\n    <- no-know-normal-fields-lookup-implies-no-know-contents NFL' NNF Z=W\n    <- threads-lookup-respects-match TL1 TSM _ TL1N\n    <- no-know-threads-lookup-implies-no-know-contents TL1N NTS Z=K\n    <- set`member-respects-eq (set`lookup/= nat`eq/) Z=K Z=W K>Z\n    <- threads`update-total TU1N\n    <- hb-potential?-respects-match NHBP ESM NHBP'\n    <- not-hb-potential-realized NHBP' _ (non-sw2-fulleval/ non-synch2-atomic/read) NHB'\n    <- wk-is/L2 WA TSM WA'.\n</pre>\nNow, even if the contents meant anything to you (just pretend...), typing in the types of all those variables is impractical.\nInstead, we replace the output with a new (or underscore) variable and terminate the case:\n<pre>\n- : wk-is/L ES \n       (access/read\n          (ready/ (read (lit (object/ O)) F) TL1 L1 A))\n       ML NFL XTL XSF FE ESG WA XPK XSM NHBP _.\n</pre>\nThen, we submit this to the server, which (of course) will complain that the output is not necessarily ground.  But with chatter set to 3, it '''also''' outputs the types of all the variables, including the implicit ones.  Then these can be copied into the buffer\n(after removing <tt>%</tt><i>name</i><tt>%</tt> types if you have any):\n<pre>\n- :  {X1} {N1:nat} {X2:map} {X3} {N2:nat} {O:nat} {F:nat} {X4}\n      {X5} {X6:lock-contents} {N3:nat} {N4:nat} {X7} {X8:term exprk}\n      {N5:nat} {X9:map} {X10} {X11:map} {X12} {N6:nat}\n      {X14} {ES:eval-seq X1 N1 (state/ X2 X3)} {X15}\n      {X16:term exprk -> term exprk}\n      {TL1:threads`lookup X3 N2 (thread/ X15 (X16 (read (lit (object/ O)) F)))}\n      {L1:loc* exprk exprk ([x:term exprk] X16 x)}\n      {A:atomic-lhs* exprk (read (lit (object/ O)) F)}\n      {ML:lookup X2 O (objs/ X4 X5 X6)}\n      {NFL:normal-fields`lookup X4 F (normal-contents/ N3 N4)}\n      {XTL:threads`lookup X3 N2 (thread/ X7 X8)} {XSF:not-member X7 N3}\n      {FE:fulleval X1 N5 (state/ X9 X10) (state/ X11 X12)}\n      {ESG:eval-seq-get* X1 N5 N1 (state/ X2 X3) (state/ X9 X10)\n              (state/ X11 X12) ES N6 FE}\n      {WA:access* writek X10 N5 O F} {XPK:process-knowledge X12 N5 X14}\n      {XSM:set`lookup X14 N3 unit/}\n      {NHBP:hb-potential?* X1 N1 (state/ X2 X3) ES N6 N2 false}\nwk-is/L ES \n       (access/read\n          (ready/ (read (lit (object/ O)) F) TL1 L1 A))\n       ML NFL XTL XSF FE ESG WA XPK XSM NHBP\n       (incorrectly-synchronized/W \n          (eval-seq/+ ESN \n             (fulleval/ _ (lit (object/ O')) TL1N L1 \n                (eRead ML' NFL' TL1N K>Z) TL1N TU1N))\n          (eval-seq-get/ (eval-seq-includes/> ESI'))\n          (eval-seq-get/ eval-seq-includes/=) WA'\n          (access/read\n             (ready/ (read (lit (object/ O)) F) TL1N L1 A))\n          NHB')\n    <- no-know-eval-seq-exists ES _ (no-know-state/ NM NTS) ESN ESM\n        (state-match/ MM TSM)\n    <- eval-seq-get-respects-match ESG ESM _ _ _ (eval-seq-get/ ESI') FEM\n    <- mem-lookup-respects-match ML MM _ ML' (objs-match/ NFM _ _)\n    <- no-know-mem-lookup-implies-no-know-contents ML' NM (no-know-objs/ NNF _ _)\n    <- normal-fields-lookup-respects-match NFL NFM _ NFL'\n    <- no-know-normal-fields-lookup-implies-no-know-contents NFL' NNF Z=W\n    <- threads-lookup-respects-match TL1 TSM _ TL1N\n    <- no-know-threads-lookup-implies-no-know-contents TL1N NTS Z=K\n    <- set`member-respects-eq (set`lookup/= nat`eq/) Z=K Z=W K>Z\n    <- threads`update-total TU1N\n    <- hb-potential?-respects-match NHBP ESM NHBP'\n    <- not-hb-potential-realized NHBP' _ (non-sw2-fulleval/ non-synch2-atomic/read) NHB'\n    <- wk-is/L2 WA TSM WA'.\n</pre>\nNow, we get new errors because the variables only occurring in the body of the proof may depend on the explicitly typed ones, and the type inference engine does not do this.  To solve this, use Control-C Control-L to highlight the unbound variables, and then list them all (with unspecified type) right after the other variables.  Don't list one twice!  You can use Control-C Control after adding a few to see what remains.  Eventually one has\n<pre>\n- : {X1} {N1:nat} {X2:map} {X3} {N2:nat} {O:nat} {F:nat} {X4}\n      {X5} {X6:lock-contents} {N3:nat} {N4:nat} {X7} {X8:term exprk}\n      {N5:nat} {X9:map} {X10} {X11:map} {X12} {N6:nat}\n      {X14} {ES:eval-seq X1 N1 (state/ X2 X3)} {X15}\n      {X16:term exprk -> term exprk}\n      {TL1:threads`lookup X3 N2 (thread/ X15 (X16 (read (lit (object/ O)) F)))}\n      {L1:loc* exprk exprk ([x:term exprk] X16 x)}\n      {A:atomic-lhs* exprk (read (lit (object/ O)) F)}\n      {ML:lookup X2 O (objs/ X4 X5 X6)}\n      {NFL:normal-fields`lookup X4 F (normal-contents/ N3 N4)}\n      {XTL:threads`lookup X3 N2 (thread/ X7 X8)} {XSF:not-member X7 N3}\n      {FE:fulleval X1 N5 (state/ X9 X10) (state/ X11 X12)}\n      {ESG:eval-seq-get* X1 N5 N1 (state/ X2 X3) (state/ X9 X10)\n              (state/ X11 X12) ES N6 FE}\n      {WA:access* writek X10 N5 O F} {XPK:process-knowledge X12 N5 X14}\n      {XSM:set`lookup X14 N3 unit/}\n      {NHBP:hb-potential?* X1 N1 (state/ X2 X3) ES N6 N2 false}\n      {ESN} {O'} {TL1N} {ML'} {NFL'} {K>Z} {ESI'} {WA'} {TU1N} {NHB'}\n        {NM} {NTS} {ESM} {MM} {TSM} {NFM} {NNF} {Z=W} {Z=K} {NHBP'}\nwk-is/L ES \n       (access/read\n          (ready/ (read (lit (object/ O)) F) TL1 L1 A))\n       ML NFL XTL XSF FE ESG WA XPK XSM NHBP\n       (incorrectly-synchronized/W \n          (eval-seq/+ ESN \n             (fulleval/ _ (lit (object/ O')) TL1N L1 \n                (eRead ML' NFL' TL1N K>Z) TL1N TU1N))\n          (eval-seq-get/ (eval-seq-includes/> ESI'))\n          (eval-seq-get/ eval-seq-includes/=) WA'\n          (access/read\n             (ready/ (read (lit (object/ O)) F) TL1N L1 A))\n          NHB')\n    <- no-know-eval-seq-exists ES _ (no-know-state/ NM NTS) ESN ESM\n        (state-match/ MM TSM)\n    <- eval-seq-get-respects-match ESG ESM _ _ _ (eval-seq-get/ ESI') FEM\n    <- mem-lookup-respects-match ML MM _ ML' (objs-match/ NFM _ _)\n    <- no-know-mem-lookup-implies-no-know-contents ML' NM (no-know-objs/ NNF _ _)\n    <- normal-fields-lookup-respects-match NFL NFM _ NFL'\n    <- no-know-normal-fields-lookup-implies-no-know-contents NFL' NNF Z=W\n    <- threads-lookup-respects-match TL1 TSM _ TL1N\n    <- no-know-threads-lookup-implies-no-know-contents TL1N NTS Z=K\n    <- set`member-respects-eq (set`lookup/= nat`eq/) Z=K Z=W K>Z\n    <- threads`update-total TU1N\n    <- hb-potential?-respects-match NHBP ESM NHBP'\n    <- not-hb-potential-realized NHBP' _ (non-sw2-fulleval/ non-synch2-atomic/read) NHB'\n    <- wk-is/L2 WA TSM WA'.\n</pre>\nNow when you check the declaration (Control-C Control-D), the coverage error will occur as a type error.  Here it shows up that <tt>WA</tt> is constrained too much.  \n\nThe details are irrelevant except to show that even (especially!) long proofs can use this technique.\n\n=== Summary ===\n\nIf you encounter an input coverage error on a case you thought you covered, the problem is most likely that the constant you wrote has a less general type than you think.  It can be helpful to read the type of constant, looking for variables that Twelf unified.  Additionally, you can start introducing type annotations on the inputs to prevent Twelf from unifying the implicit parameters; this turns the input coverage error into a type error on the constant itself.  If you comment out parts of the constant, such as outputs or later premises, you can find the exact premise that causes the type error, and get Twelf to give a more specific error message.  This will help you figure out what mistake you made.\n\n== Unusual Situations ==\n\nThe input coverage checker has limitations.  This section describes some of them.\nYou won't encounter these symptoms unless you are using higher-order judgments.\n\n=== Nontermination ===\n\nOccasionally, the input coverage checker does not terminate.  If chatter is set to six, you see the infinite loop progressing.\nOtherwise, it simply hangs.  This happens sporadically when the input coverage checker attempts to split\non a variable of higher-order  (functional) type.  It usually happens when there is a coverage error.  Use chatter 6\nto determine where the problem is.\n\n=== Inactive Splits ===\n\nOccasionally, the coverage checker \"refuses\" to split on a variable (i.e. enumerate its cases) even\nthough doing so would determine that there are no cases to consider, in other words that\ncoverage is not needed.  In this case the coverage checker will try other variables until it runs out\nof candidates and gives up yielding (often) a long list of unhandled cases.  This symptom can be\nverified by setting chatter to 7 in which the message \"Inactive Split\" is echoed.  An inactive split\nis a split that will not be chosen because one of its cases causes unification to fail with\nunsolved constraints.\n\nThis situation can be solved by preventing unification of the higher-order terms (e.g., <tt>(F X) = (G X)</tt>)\nthrough the introduction of a trivial (syntactic) equality predicate.  Make sure that this predicate is\nlisted <em>before</em> the variable that needs to be split in your meta-theorem.  Otherwise,\nthe coverage checker will split the equality predicate and re-introduce the problem.\n\n{{tutorial}}"
          },
          "sha1": "bi6zpvwfue4xl7rykhcumiatqe5oieh"
        }
      },
      {
        "title": "Deductive system",
        "ns": 0,
        "id": 1831,
        "redirect": {
          "@title": "Object logic",
          "#text": null
        },
        "revision": {
          "id": 4527,
          "parentid": 3467,
          "timestamp": "2007-03-21T01:38:12Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "path compression",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 26,
            "#text": "#REDIRECT [[Object logic]]"
          },
          "sha1": "1fwvtiynfl5gq4yjr7cnv2ufnzotunb"
        }
      },
      {
        "title": "Deductive systems",
        "ns": 0,
        "id": 1830,
        "redirect": {
          "@title": "Object logic",
          "#text": null
        },
        "revision": {
          "id": 4526,
          "parentid": 3466,
          "timestamp": "2007-03-21T01:37:54Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "path compression",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 26,
            "#text": "#REDIRECT [[Object logic]]"
          },
          "sha1": "1fwvtiynfl5gq4yjr7cnv2ufnzotunb"
        }
      },
      {
        "title": "Deep equality",
        "ns": 0,
        "id": 1517,
        "redirect": {
          "@title": "Equality",
          "#text": null
        },
        "revision": {
          "id": 2018,
          "timestamp": "2006-09-28T00:52:20Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 22,
            "#text": "#REDIRECT [[Equality]]"
          },
          "sha1": "1evo9trxxsh7ggeo11ch1cqy7ro4l3c"
        }
      },
      {
        "title": "Define declaration",
        "ns": 0,
        "id": 1715,
        "revision": {
          "id": 4842,
          "parentid": 4828,
          "timestamp": "2007-09-27T04:15:05Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "minor": null,
          "comment": "Reverted edits by [[Special:Contributions/209.200.38.173|209.200.38.173]] ([[User_talk:209.200.38.173|Talk]]); changed back to last version by [[User:128.2.203.136|128.2.203.136]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 1091,
            "#text": "''The name of this article should be %define. There's a quirk of Unicode that causes this to not behave correctly.''\n\nThe '''<tt>%define</tt>''' declaration allows the outputs of a successful <tt>[[%solve]]</tt> declaration to be bound to a name which can be used later on in the context.\n\n== Example ==\n\nGiven a standard declaration of natural numbers and plus with a few constants defined:\n\n<twelf>\nnat : type.\n\nz : nat. \ns : nat -> nat.\n\nn0 = z.\nn1 = s n0. \nn2 = s n1. \nn3 = s n2. \nn4 = s n3. \n\n\n\nplus : nat -> nat -> nat -> type.\n%mode plus +N1 +N2 -N3.\n\nplus/z : plus z N N.\n\nplus/s : plus (s N1) N2 (s N3) \n          <- plus N1 N2 N3.\n</twelf>\n\nWe can use <tt>%define</tt> to define the natural number representing 7 by adding three and four. Note that we don't care about the proof witness in this particular case, just the output of the relation, so we put an underscore instead of an identifier to the left of the colon:\n\n<twelf check=\"decl\">\n%define n7 = N\n%solve _ : plus n4 n3 N.\n</twelf>\n\n== See also ==\n* {{guide|chapter=3|section=10|title=Definitions}}\n\n{{keyword|key=define}}"
          },
          "sha1": "95xfdbecy8d9e25iu6msazj3n01m140"
        }
      },
      {
        "title": "Dense lexicographical orderings",
        "ns": 0,
        "id": 1687,
        "redirect": {
          "@title": "Lexicographical orderings with density",
          "#text": null
        },
        "revision": {
          "id": 2609,
          "timestamp": "2006-10-11T21:15:53Z",
          "contributor": {
            "username": "DanielKLee",
            "id": 5
          },
          "comment": "Redirecting to [[Lexicographical orderings with density]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 52,
            "#text": "#REDIRECT [[Lexicographical orderings with density]]"
          },
          "sha1": "fv2reo151d55tf70bc987hw5jxer387"
        }
      },
      {
        "title": "Dependent type",
        "ns": 0,
        "id": 1955,
        "redirect": {
          "@title": "Dependent types",
          "#text": null
        },
        "revision": {
          "id": 4468,
          "timestamp": "2007-03-20T21:06:58Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "Redirecting to [[Dependent types]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 29,
            "#text": "#REDIRECT [[Dependent types]]"
          },
          "sha1": "ffg87r4gl0wm5gr8t25uwosdb40ht6x"
        }
      },
      {
        "title": "Dependent types",
        "ns": 0,
        "id": 1930,
        "revision": {
          "id": 4531,
          "parentid": 4530,
          "timestamp": "2007-03-21T01:48:23Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "minor": null,
          "comment": "fix interwiki",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 395,
            "#text": "A language with '''dependent types''' has types which can mention the terms they classify. For example, [[LF]] is a dependently typed language because LF types can mention LF terms. \n\n\n== See also ==\n\n* [[LF]] \n* [[w:Dependent types|Dependent types]] at Wikipedia\n* Chapter 2 of [http://www.cis.upenn.edu/~bcpierce/attapl/main.html Advanced Topics in Types and Programming Languages]\n\n\n\n{{stub}}"
          },
          "sha1": "p8lwqxx4yrfn6nvvgnyrcu8o8ky849t"
        }
      },
      {
        "title": "Deterministic declaration",
        "ns": 0,
        "id": 1872,
        "revision": {
          "id": 6098,
          "parentid": 4808,
          "timestamp": "2010-09-01T19:42:11Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "updates",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 2831,
            "#text": "The '''<tt>%determinstic</tt>''' declaration influences the way [[logic programming]] behaves in Twelf. If a type family is deterministic, then once Twelf finds a single solution through logic programming search it cannot backtrack to find different solutions.\n\n== Example: Tree search ==\n\n[[Image:Smalltree.svg|thumb|right|250px|Graphical representation of the tree <tt>testtree</tt> used in this example.]]\nWe define a tree with labeled nodes, and a distinguished tree <tt>testtree</tt> \n<twelf>\nlabel : type.\na : label.\nb : label.\nc : label.\nd : label.\n\ntree : type.\nnode : tree -> tree -> tree.\nleaf : label -> tree.\n\ntesttree = node (node (leaf a) (leaf b)) (node (leaf c) (leaf d)).\n</twelf>\n\n=== Searching for a leaf ===\n\nWe also define a judgment, <tt>findlabel</tt>, that looks for a label at leaves of the tree. Because Twelf tries to use the first-defined rule first, the operational behavior of this is to search for the leftmost node, then to backtrack and find the next-to-leftmost node, etc.\n\n<twelf>\nfindlabel : tree -> label -> type.\nfindlabel/leaf : findlabel (leaf L) L.\nfindlabel/left : findlabel (node T1 T2) L\n                  <- findlabel T1 L.\nfindlabel/right : findlabel (node T1 T2) L\n                  <- findlabel T2 L.\n</twelf>\n\nIf <tt>findlabel</tt> is not declared deterministic, all four solutions can be returned, but with <tt>findlabel</tt> declared deterministic only one will be found.\n\n<twelf check=decl discard=true>\n%query 4 * findlabel testtree L.\n</twelf>\n\n<twelf check=decl discard=true>\n%deterministic findlabel.\n%query 1 * findlabel testtree L.\n</twelf>\n\n\n=== Causing search to fail ===\n\nWhen using '''<tt>%deterministic</tt>''', [[finite failure]] no longer means that no derivation can be found, becuase the deterministic search may put constraints on later results that causes them to fail. Take the <tt>searchfor</tt> predicate, which first looks up a label with <tt>findlabel</tt> and then checks to see if it is equal to some other label.\n\n<twelf>\neq : label -> label -> type.\neq/refl : eq L L.\n\nsearchfor : tree -> label -> type.\n- : searchfor T L\n     <- findlabel T L'\n     <- eq L L'.\n</twelf>\n\nUsing <tt>searchfor</tt> to look for <tt>c</tt> in our test tree will cause backtracking, because <tt>findlabel</tt> first make <tt>L'<tt> equal to <tt>a</tt>, then <tt>b</tt>, then <tt>c</tt>.\n\n<twelf check=decl discard=true>\n%query 1 * P : searchfor testtree c.\n</twelf>\n\nIf <tt>findlabel</tt> is deterministic, then the same search will make <tt>L'</tt> equal <tt>a</tt>, and will then be unable to backtrack.\n\n<twelf check=decl discard=true>\n%deterministic findlabel.\n%query 1 * P : searchfor testtree c.\n</twelf>\n\n== See also ==\n\n* {{guide|title=Deterministic Type Families|chapter=5|section=30}}\n* [[w:Cut (logic programming)|Cut]] on Wikipedia\n\n{{keyword|key=deterministic}}"
          },
          "sha1": "beacqhatwi5sqdw0rand2imhldaok9p"
        }
      },
      {
        "title": "Developers",
        "ns": 0,
        "id": 1514,
        "redirect": {
          "@title": "About The Twelf Project",
          "#text": null
        },
        "revision": {
          "id": 2009,
          "parentid": 2007,
          "timestamp": "2006-09-27T22:45:00Z",
          "contributor": {
            "username": "DanielKLee",
            "id": 5
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 37,
            "#text": "#REDIRECT [[About_The_Twelf_Project]]"
          },
          "sha1": "joe4zz4wwvr57rhmwfxjz5nctbgiwvx"
        }
      },
      {
        "title": "Division over the natural numbers",
        "ns": 0,
        "id": 1506,
        "revision": {
          "id": 4951,
          "parentid": 4940,
          "timestamp": "2007-10-12T14:09:01Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "minor": null,
          "comment": "Reverted edits by [[Special:Contributions/208.122.34.234|208.122.34.234]] ([[User_talk:208.122.34.234|Talk]]); changed back to last version by [[User:Rsimmons|Rsimmons]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 7544,
            "#text": "This is a [[case studies|case study]] about '''division over the natural numbers'''. A number of arithmetic operations over the natural numbers will be defined, including division. The ultimate goal is to prove properties normally associated with division hold. Twelf muscles flexed in this study include [[reasoning from false]] and using the [[%reduces]] directive to use strong induction in a proof.\n\nFirst the \"false\" type and natural numbers are defined.\n<twelf>uninhabited : type.\n%freeze uninhabited.\n\n\n\nnat : type.\n\nnat/z\t: nat.\nnat/s\t: nat -> nat.</twelf>\n\nRelations about arithmetic over the natural numbers are defined in the standard way. \n\n<twelf>\nnat-plus : nat -> nat -> nat -> type.\n\nnat-plus/z\t: nat-plus nat/z N N.\n\nnat-plus/s\t: nat-plus (nat/s N1) N2 (nat/s N3)\n\t\t   <- nat-plus N1 N2 N3.\n\n\n\nnat-mult : nat -> nat -> nat -> type.\n\nnat-mult/z      : nat-mult nat/z N nat/z.\n\nnat-mult/s      : nat-mult (nat/s N1) N2 N3'\n                   <- nat-plus N2 N3 N3'\n                   <- nat-mult N1 N2 N3.\n\n\n\nnat-less : nat -> nat -> type.\n\nnat-less/z\t: nat-less nat/z (nat/s _).\n\nnat-less/s\t: nat-less (nat/s N1) (nat/s N2)\n\t\t   <- nat-less N1 N2. \n\n\n\nnat-leq\t: nat -> nat -> type.\n\nnat-leq/z\t: nat-leq nat/z _.\n\nnat-leq/s\t: nat-leq (nat/s N1) (nat/s N2)\n\t\t   <- nat-leq N1 N2.\n\n\n\nnat-compare : nat -> nat -> type.\n\nnat-compare/less\t: nat-compare N1 N2\n\t\t\t   <- nat-less N1 N2.\n\nnat-compare/leq\t\t: nat-compare N1 N2\n\t\t\t   <- nat-leq N2 N1.\n\n\n\n% nat-divmod DIVIDEND DIVISOR QUOTIENT REMAINDER\n\nnat-divmod\t: nat -> nat -> nat -> nat -> type.\n\nnat-divmod/base\t: nat-divmod N1 N2 nat/z N1\n\t\t   <- nat-less N1 N2.\n\nnat-divmod/rec\t: nat-divmod N1 N2 (nat/s N3) N4\n\t\t   <- nat-divmod N1' N2 N3 N4\n\t\t   <- nat-plus N2 N1' N1.\n</twelf>\n\nSome basic properties about arithmetic.\n\n<twelf>\nnat-leq-plus\t: nat-leq N1 N2\n\t\t   -> nat-plus N1 _ N2\n\t\t   -> type.\n%mode nat-leq-plus +D1 -D2.\n\n-\t: nat-leq-plus nat-leq/z nat-plus/z.\n\n-\t: nat-leq-plus (nat-leq/s DLQ) (nat-plus/s DNP)\n\t   <- nat-leq-plus DLQ DNP.\n\n%worlds () (nat-leq-plus _ _).\n%total {D1} (nat-leq-plus D1 _).\n\n\n\nnat-compare-resp-s\t: nat-compare N1 N2\n\t\t\t   -> nat-compare (nat/s N1) (nat/s N2)\n\t\t\t   -> type.\n%mode nat-compare-resp-s +D1 -D2.\n\n-\t: nat-compare-resp-s (nat-compare/less DL) \n\t   (nat-compare/less (nat-less/s DL)).\n\n-\t: nat-compare-resp-s (nat-compare/leq DLQ) \n\t   (nat-compare/leq (nat-leq/s DLQ)).\n\n%worlds () (nat-compare-resp-s _ _).\n%total {} (nat-compare-resp-s _ _).\n\n\n\ncan-nat-compare\t: {N1}{N2}\n\t\t   nat-compare N1 N2\n\t\t   -> type.\n%mode can-nat-compare +D1 +D2 -D3.\n\n-\t: can-nat-compare _ _ (nat-compare/less nat-less/z).\n\n-\t: can-nat-compare _ _ (nat-compare/leq nat-leq/z).\n\n-\t: can-nat-compare (nat/s N1) (nat/s N2) DC'\n\t   <- can-nat-compare N1 N2 DC\n\t   <- nat-compare-resp-s DC DC'.\n\n%worlds () (can-nat-compare _ _ _).\n%total {D1} (can-nat-compare D1 _ _).\n\n\n\ncan-nat-plus : {N1} {N2}\n                nat-plus N1 N2 N3\n                -> type.\n%mode can-nat-plus +D1 +D2 -D3.\n\n-       : can-nat-plus _ _ nat-plus/z.\n\n-       : can-nat-plus _ _ (nat-plus/s DP)\n           <- can-nat-plus _ _ DP.\n\n%worlds () (can-nat-plus _ _ _).\n%total (D1) (can-nat-plus D1 _ _).\n\n\n\nnat-plus-assoc : nat-plus N1 N2 N12\n                  -> nat-plus N2 N3 N23\n                  -> nat-plus N1 N23 N123\n                  -> nat-plus N12 N3 N123\n                  -> type.\n%mode nat-plus-assoc +D1 +D2 +D3 -D4.\n\n-       : nat-plus-assoc nat-plus/z DP nat-plus/z DP.\n\n-       : nat-plus-assoc (nat-plus/s DP1) DP2 (nat-plus/s DP3) (nat-plus/s DP4)\n           <- nat-plus-assoc DP1 DP2 DP3 DP4.\n\n%worlds () (nat-plus-assoc _ _ _ _).\n%total (D1) (nat-plus-assoc D1 _ _ _).\n</twelf>\n\nThe first proof about division: The remainder is less than the divisor!\n\n<twelf>nat-divmod-mod-less\t: nat-divmod N1 N2 N3 N4\n\t\t\t   -> nat-less N4 N2\n\t\t\t   -> type. \n%mode nat-divmod-mod-less +D1 -D2.\n\n-\t: nat-divmod-mod-less (nat-divmod/base DL) DL.\n\n-\t: nat-divmod-mod-less (nat-divmod/rec _ DDM) DL\n\t   <- nat-divmod-mod-less DDM DL.\n\n%worlds () (nat-divmod-mod-less _ _).\n%total {D1} (nat-divmod-mod-less D1 _).\n</twelf>\n\nDivision by zero does not happen.\n\n<twelf>nat-divmod-z-uninhabited\t: nat-divmod N1 nat/z N3 N4\n\t\t\t\t   -> uninhabited\n\t\t\t\t   -> type.\n%mode nat-divmod-z-uninhabited +D1 -D2.\n\n-\t: nat-divmod-z-uninhabited (nat-divmod/rec nat-plus/z DDM) DU\n\t   <- nat-divmod-z-uninhabited DDM DU.\n\n%worlds () (nat-divmod-z-uninhabited _ _).\n%total {D1} (nat-divmod-z-uninhabited D1 _).\n</twelf>\n\nThe following theorem uses the <tt>%reduces</tt> directive to verify that if a non-zero number is added to <tt>N2</tt>, then the result is strictly larger than <tt>N2</tt> in the sub-term sense. This is powerful information, because Twelf verifies well-founded inductions over sub-term orderings. \n\n<twelf>\nnat-plus-reduces-s\t: {N2}{N3}\n\t\t\t   nat-plus (nat/s N1) N2 N3\n\t\t\t   -> type.\n%mode nat-plus-reduces-s +D1 +D2 +D3.\n\n-\t: nat-plus-reduces-s _ _ (nat-plus/s nat-plus/z).\n\n-\t: nat-plus-reduces-s _ _ (nat-plus/s DL)\n\t   <- nat-plus-reduces-s _ _ DL.\n\n%worlds () (nat-plus-reduces-s _ _ _).\n%reduces N2 < N3 (nat-plus-reduces-s N2 N3 _).\n%total {D1} (nat-plus-reduces-s _ _ D1).\n</twelf>\n\n\nThe highlight of this example. Division is possible for any dividend as long as the divisor is non-zero. This proof is by induction over the dividend, which does get smaller as inductive calls are made. However, because Twelf can not figure this out on its own, calls to nat-plus-reduces-s are required so that this proof passes the totality checker.\n\n<twelf>\ncan-nat-divmod*\t: {N1}\n\t\t   nat-compare N1 (nat/s N2)\n\t\t   -> nat-divmod N1 (nat/s N2) N3 N4\n\t\t   -> type.\n%mode can-nat-divmod* +D1 +D2 -D3.\n\n-\t: can-nat-divmod* _ (nat-compare/less DL) (nat-divmod/base DL).\n\n-\t: can-nat-divmod* N1 (nat-compare/leq DLQ) (nat-divmod/rec DP DDM)\n\t   <- nat-leq-plus DLQ DP\n\t   <- nat-plus-reduces-s N1' N1 DP\n\t   <- can-nat-compare N1' (nat/s N2) DC\n\t   <- can-nat-divmod* N1' DC DDM.\n\n%worlds () (can-nat-divmod* _ _ _).\n%total {D1} (can-nat-divmod* D1 _ _).\n\n\n\ncan-nat-divmod\t: {N1}{N2}\n\t\t   nat-divmod N1 (nat/s N2) N3 N4\n\t\t   -> type.\n%mode can-nat-divmod +D1 +D2 -D3.\n\n-\t: can-nat-divmod N1 N2 DDM\n\t   <- can-nat-compare N1 (nat/s N2) DC\n\t   <- can-nat-divmod* N1 DC DDM.\n\n%worlds () (can-nat-divmod _ _ _).\n%total {} (can-nat-divmod _ _ _).</twelf>\n\nIt is also useful to know the definition of division is correct with respect to multiplication.\n\n<twelf check=\"true\">\nnat-divmod-correct : nat-divmod N1 N2 N3 N4\n                      -> nat-mult N3 N2 N3'\n                      -> nat-plus N3' N4 N1\n                      -> type.\n%mode nat-divmod-correct +D1 -D2 -D3.\n\n-       : nat-divmod-correct (nat-divmod/base _) nat-mult/z nat-plus/z.\n\n-       : nat-divmod-correct (nat-divmod/rec DP DD) (nat-mult/s DM DP'') DP'''\n           <- nat-divmod-correct DD DM DP'\n           <- can-nat-plus N2 N3' DP''\n           <- nat-plus-assoc DP'' DP' DP DP'''.\n\n%worlds () (nat-divmod-correct _ _ _).\n%total (D1) (nat-divmod-correct D1 _ _).\n</twelf>\n\nIn the above code, the division algorithm for natural numbers was defined. A few interesting properties about this judgment were proven. The first is that the remainder computed is strictly less than the divisor. The second is that the judgment is not inhabited when the divisor is zero. The third is an [[effectiveness lemma]] which shows that this judgment is inhabited for any dividend and any divisor greater than zero. Finally, the division relation was shown to be correct with respect to multiplication.\n\n{{case study}}\n[[Category:Twelf code]]"
          },
          "sha1": "1vnxd5t0x8qqgaatukgmjf71w06fm4i"
        }
      },
      {
        "title": "Documentation",
        "ns": 0,
        "id": 1416,
        "revision": {
          "id": 8009,
          "parentid": 8008,
          "timestamp": "2016-01-15T17:36:41Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "Old documentation sources, including the old User's Guide, are now apparently lost and gone forever.",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 3252,
            "#text": "== Learn Twelf on the wiki ==\n\n<!-- in general, this section should be kept consistent with the main page -->\n\n* Read the [[introductions to Twelf]] first.\n* The [[tutorials]] explain common Twelf tricks and techniques.\n* The [[glossary]] defines Twelf terminology.\n* The [[case studies]] present interesting applications of Twelf.\n* Have a question? [[Ask Twelf Elf]]!\n<!-- left off of the main page for now because it's not ready for primetime -->\n* The [[Twelf style guide]] discusses some best practices. There are also some suggested [[naming conventions]].\n\n== Reference ==\n\n* The Twelf [[User's Guide]] is the basic reference manual for Twelf.  \n* Active Twelf users should subscribe to the [[mailing lists]].\n* The [[Bibliography of LF|LF bibliography]] lists research papers about LF and Twelf.\n* Read about [[research projects using Twelf]].\n\n== External documentation ==\n\nBesides information on this wiki, there have been a number of papers and tutorials explaining how to use Twelf for various purposes, as well as commentary on using Twelf.\n\n=== Tutorials ===\n\n* Andrew Appel's [http://www.cs.princeton.edu/~appel/twelf-tutorial/ Hints on Proving Theorems in Twelf] describes a particular methodology for using Twelf that is rather different than the strategy of proving [[metatheorems]] that predominates on this wiki (i.e. \"the particular strange way they do it at Princeton\").\n* John Boyland's [http://cs.nju.edu.cn/boyland/proof/using-twelf.html Using Twelf to Prove Type Theorems] is a tutorial and experience report (he has also published a number of [http://cs.nju.edu.cn/boyland/proof/ Twelf signatures]).\n* Dan Licata and Bob Harper have written a survey article called [http://www.cs.cmu.edu/~drl/pubs/hl06mechanizing/hl06mechanizing.pdf Mechanizing Metatheory in a Logical Framework].  This paper provides a more formal introduction to the modern way of thinking about LF and Twelf than this wiki does.  \n* Alberto Momigliano's [http://www.cs.nott.ac.uk/types06/slides/am.pdf A Practical Approach to Co-induction in Twelf] describes a technique for encoding Twelf-unfriendly co-inductive proofs as Twelf-friendly induction proofs (slides from a talk at TYPES 2006).\n* Susmit Sarkar has notes from a mini-course, [http://www.cl.cam.ac.uk/~ss726/twelf/ Mechanizing Metatheory in Twelf], at the University of Cambridge.\n* John Altidor's Twelf Tutorial [http://jgaltidor.github.io/typetheory_paper.pdf Report] and [http://jgaltidor.github.io/twelf_slides.pdf Presentation] are accessible without a strong background in programming language foundations.\n\n=== Experience reports and commentary ===\n\n* [[poplmark:The POPLmark Challenge|The POPLmark Challenge]] has a page on [[poplmark:Twelf|Twelf]] and commentary on the POPLmark [[poplmark:submission from Carnegie Mellon|submission from Carnegie Mellon]] that uses Twelf.\n* Andrew Appel and Xavier Leroy's [http://www.inria.fr/rrrt/rr-5914.html A list-machine benchmark for mechanized metatheory] serves as both a tutorial and an experience report on using Twelf to prove theroems about compilers.\n\n== Other ==\n\nIs there some form of documentation that should be on this wiki but isn't? Add it to [[The Twelf Project:To do]] list or [[The_Twelf_Project:Contributing|contribute]] it."
          },
          "sha1": "fg2t0zrnd90hrmtyy9q1zxz670dbarn"
        }
      },
      {
        "title": "Double-negation translation",
        "ns": 0,
        "id": 2083,
        "revision": {
          "id": 5379,
          "timestamp": "2008-09-14T13:28:53Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "comment": "New page: %{  == Intuitionistic logic ==  }%  iprop : type.  %name iprop A'.  itop : iprop. iand : iprop -> iprop -> iprop. ibot : iprop. ior  : iprop -> iprop -> iprop. iimp : iprop -> iprop -> ipr...",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 19933,
            "#text": "%{\n\n== Intuitionistic logic ==\n\n}%\n\niprop : type.  %name iprop A'.\n\nitop : iprop.\niand : iprop -> iprop -> iprop.\nibot : iprop.\nior  : iprop -> iprop -> iprop.\niimp : iprop -> iprop -> iprop.\n\n%block ipb : block {X : iprop}.\n%worlds (ipb) (iprop).\n\nitrue : iprop -> type.\n\nimt : itrue itop.\nipair : itrue A -> itrue B -> itrue (iand A B).\nifst : itrue (iand A B) -> itrue A.\nisnd : itrue (iand A B) -> itrue B.\niabort : itrue ibot -> itrue C.\niinl  : itrue A -> itrue (ior A B). \niinr  : itrue B -> itrue (ior A B). \nicase : itrue (ior A B) -> (itrue A -> itrue C) ->  (itrue B -> itrue C) -> itrue C.\nilam  : (itrue A -> itrue B) -> itrue (iimp A B).\niapp  : itrue (iimp A B) -> itrue A -> itrue B.\n\ninot : iprop -> iprop = [A] iimp A ibot.\nidn : iprop -> iprop = [A] (inot (inot A)).\n\ndni : itrue A -> itrue (idn A) =\n [x : itrue A] (ilam [y : itrue (inot A)] (iapp y x)).\n\ntne : itrue (idn (inot A)) -> itrue (inot A) =\n [x3 : itrue (inot (inot (inot A)))] \n   ilam [x : itrue A] \n     iapp x3 (ilam [y : itrue (inot A)] (iapp y x)).\n\ndistdnand : itrue (idn (iand A B)) -> itrue (iand (idn A) (idn B)) =\n [f] (ipair \n\t(ilam [x : itrue (inot A)] iapp f (ilam [p] iapp x (ifst p)))\n\t(ilam [x : itrue (inot B)] iapp f (ilam [p] iapp x (isnd p)))\n\t).\n\ndnebot : itrue (idn ibot) -> itrue ibot = [x] iapp x (ilam [x] x).\n%abbrev dnetop : itrue (idn itop) -> itrue itop = [x] imt.\n\ndistdnimp : itrue (idn (iimp A B)) -> itrue (iimp (idn A) (idn B)) =\n [f] (ilam [x : itrue (idn A)] \n\t(ilam [y : itrue (inot B)] \n\t   iapp f \n\t   (ilam [g : itrue (iimp A B)]\n\t      iapp x (ilam [z : itrue A] iapp y (iapp g z))))). \n\n%block itb : some {A : iprop} block {D : itrue A}.\n%worlds (ipb | itb) (itrue _). \n\n\n%{\n\n== Classical logic ==\n\n}%\n\nprop : type.  %name prop A.\n\ntop : prop.\nand : prop -> prop -> prop.\nbot : prop.\nor  : prop -> prop -> prop.\nimp : prop -> prop -> prop.\nnbot : prop.\nnot : prop -> prop.\n\n%block pb : block {X : prop}.\n%worlds (pb) (prop).\n\nconc : type.\ntrue  : prop -> conc. %prefix 2 true.\nfalse : prop -> conc. %prefix 2 false.\ncontra : conc. \n\n>> : conc -> type.  %prefix 3 >>.\n\nmt : >> true top.\npair : >> true A -> >> true B -> >> true (and A B).\nfst : >> true (and A B) -> >> true A.\nsnd : >> true (and A B) -> >> true B.\nabort : >> true bot -> >> J.\ninl  : >> true A -> >> true (or A B). \ninr  : >> true B -> >> true (or A B). \ncase : >> true (or A B) -> (>> true A -> >> J) ->  (>> true B -> >> J) -> >> J.\nlam  : (>> true A -> >> true B) -> >> true (imp A B).\napp  : >> true (imp A B) -> >> true A -> >> true B.\n\n%% anything follows from contradiction\ncabort : >> contra -> >> J.\n\n%% negative bottom\nnboti : >> contra -> >> true nbot.\nnbote : >> true nbot -> >> contra.\n\n%% falsehood\ncont  : (>> true A -> >> contra) -> >> false A.\nthrow : >> false A -> >> true A -> >> contra.\n\n%% negation\nnoti    : >> false A -> >> true (not A).\nnotcase : >> true (not A) -> (>> false A -> >> J) -> >> J.                                       %% because not should be positive\n\n%% letcc\nletcc : (>> false A -> >> contra) -> >> true A.\n\n%block tb : some {A : prop} block {D : >> true A}.\n%block fb : some {A : prop} block {D : >> false A}.\n%worlds (pb | tb | fb) (>> _).\n\niff  : prop -> prop -> prop = [A] [B] (and (imp A B) (imp B A)).\niffi : (>> true A -> >> true B) -> (>> true B -> >> true A) -> (>> true (iff A B)) \n = [E1] [E2] (pair (lam E1) (lam E2)).\niffel : (>> true (iff A B)) -> (>> true A -> >> true B) \n = [E1] [E2] (app (fst E1) E2).\niffer : (>> true (iff A B)) -> (>> true B -> >> true A) \n = [E1] [E2] (app (snd E1) E2).\n\ncdni : >> true A -> >> true (not (not A)) =\n[x] (noti (cont [nx] (notcase nx [f] throw f x))).\n\ncdne : >> true (not (not A)) -> >> true A =\n[x] notcase x ([f] letcc [u] throw f (noti u)).\n\nnotimpbot : >> true (iff A B) -> >> true (iff (not A) (imp B bot)) =\n[c] (iffi \n       ([x] notcase x ([f] (lam [y] (cabort (throw f (iffer c y))))))\n       ([x] noti (cont [y] abort (app x (iffel c y))))).\n\nnotimpbot2 : >> true (iff (not (not A)) (imp (imp A bot) bot)) =\nnotimpbot (notimpbot (iffi ([x] x) ([x] x))).\n   \n%{\n\n== Double-negation translation ==\n\nThis is essentially the \n[http://en.wikipedia.org/wiki/G%C3%B6del%E2%80%93Gentzen_negative_translation Godel-Gentzen Negtive Translation].\nIt differs only by De Morgan laws that are provable intuitionistically.  \n}%\n\n* : prop -> iprop -> type.\n%mode * +A -A'.\n\n*/top : * top itop.\n*/and : * (and A B) (iand A' B')\n\t <- * A A'\n\t <- * B B'.\n*/bot : * bot ibot.\n*/or : * (or A B) (inot (inot (ior A' B')))\n\t <- * A A'\n\t <- * B B'.\n*/imp : * (imp A B) (iimp A' B')\n\t <- * A A'\n\t <- * B B'.\n*/nbot : * nbot ibot.\n*/not  : * (not A) (inot A')\n\t  <- * A A'.\n\n%block *b : block {X : prop} {X' : iprop} {_ : * X (inot (inot X'))}.\n%worlds (*b) (* _ _).\n%total A (* A _).\n%unique * +A -1A'.\n\n*tot : {A} * A A' -> type.\n%mode *tot +A -D*.\n\n%block *totb : block {X : prop} {X' : iprop} {D* : * X (idn X')} {_ : *tot X D*}.\n%worlds (*totb) (*tot _ _).\n%trustme %total {} (*tot _ _).  %% verified by %total above\n\nid-iprop : iprop -> iprop -> type.\nid-iprop/refl : id-iprop A A.\n\nid-iprop-not-cong : id-iprop A' B' -> id-iprop (inot A') (inot B') -> type.\n%mode id-iprop-not-cong +X1 -X2.\n- : id-iprop-not-cong _ id-iprop/refl.\n%worlds (ipb) (id-iprop-not-cong _ _).\n%total {} (id-iprop-not-cong _ _).\n\n*unique : * A A' -> * A B' -> id-iprop A' B' -> type.\n%mode *unique +X1 +X2 -X3.\n%worlds (*b) (*unique _ _ _).\n%trustme %total {} (*unique _ _ _). %% verified by %unique above\n\nitrue-respects-id : itrue A -> id-iprop A' A -> itrue A' -> type.\n%mode itrue-respects-id +X1 +X2 -X3.\n- : itrue-respects-id D _ D.\n%worlds (itb | ipb) (itrue-respects-id _ _ _).\n%total {} (itrue-respects-id _ _ _).\n\n%{\n\n=== Double-negation elimination for the target of the translation ===\n\n}%\n\ndne : * A A' -> (itrue (inot (inot A')) -> itrue A') -> type.\n%mode dne +X1 -X2.\n\n- : dne (*/and D*2 D*1) ([x] ipair (E1 (ifst (distdnand x))) (E2 (isnd (distdnand x))))\n     <- dne D*1 E1\n     <- dne D*2 E2.\n- : dne */top ([x] imt).\n- : dne (*/or _ _) [x] (tne x).\n- : dne */bot  ([x] (dnebot x)).\n- : dne */nbot  ([x] (dnebot x)).\n- : dne (*/imp D*2 D*1) \n     ([x] (ilam [y] E2 (iapp (distdnimp x) (dni y))))\n     <- dne D*2 E2.\n- : dne (*/not D*) tne \n     <- dne D* E.\n\n%block dneb : block {X : prop} {X' : iprop} {dx : * X (idn X')}\n\t       {_ : dne dx tne}.\n\n%worlds (dneb | itb) (dne _ _).\n%total D (dne D _).\n\n%{\n\n== Soundness ==\n\n}%\n\nsound/true : >> true A -> * A A' -> itrue A' -> type.\n%mode sound/true +X1 +X2 -X3.\n\nsound/false : >> false A -> * A A' -> itrue (iimp A' ibot) -> type.\n%mode sound/false +X1 +X2 -X3.\n\nsound/contra : >> contra -> itrue ibot -> type.\n%mode sound/contra +X1 -X3.\n\n%% true\n\n- : sound/true mt */top imt.\n- : sound/true (pair E1 E2) (*/and D*2 D*1) (ipair E1' E2')\n     <- sound/true E1 D*1 E1'\n     <- sound/true E2 D*2 E2'.\n- : sound/true (fst (E : >> true (and A1 A2))) D*1 (ifst E')\n     <- *tot A2 D*2\n     <- sound/true E (*/and D*2 D*1) E'.\n- : sound/true (snd (E : >> true (and A1 A2))) D*2 (isnd E')\n     <- *tot A1 D*1\n     <- sound/true E (*/and D*2 D*1) E'.\n- : sound/true ((abort E) : >> true C) D* (iabort E')\n     <- sound/true E */bot E'.\n- : sound/true ((inl E) : >> true (or A1 A2)) (*/or D*2 D*1) (dni (iinl E'))\n     <- sound/true E D*1 E'.\n- : sound/true ((inr E) : >> true (or A1 A2)) (*/or D*2 D*1) (dni (iinr E'))\n     <- sound/true E D*2 E'.\n- : sound/true (case (E : >> true (or A B)) E1 E2) D* \n     (Edne (ilam [f : itrue (inot C')] \n\t      iapp E' (ilam [x : itrue (ior A' B')]\n\t\t\t (icase x \n\t\t\t    ([x1] iapp f (E1' x1)) \n\t\t\t    ([x2] iapp f (E2' x2))))))\n     <- *tot A D*A\n     <- *tot B D*B\n     <- sound/true E (*/or D*B D*A) E'\n     <- ({x : >> true A} {x' : itrue A'} \n\t   {_ : {A''} {D* : * A A''} {Did} {E''}\n\t\t sound/true x D* E''\n\t\t <- *unique D* D*A Did\n\t\t <- itrue-respects-id x' Did E''}\n\t   sound/true (E1 x) D* (E1' x'))\n     <- ({x : >> true B} {x' : itrue B'} \n\t   {_ : {A''} {D* : * B A''} {Did} {E''}\n\t\t sound/true x D* E''\n\t\t <- *unique D* D*B Did\n\t\t <- itrue-respects-id x' Did E''}\n\t   sound/true (E2 x) D* (E2' x'))\n     <- dne D* Edne.\n- : sound/true ((lam E) : >> true (imp A B)) (*/imp D* D*A) (ilam E')\n     <- ({x : >> true A} {x' : itrue A'} \n\t   {_ : {A''} {D* : * A A''} {Did} {E''}\n\t\t sound/true x D* E''\n\t\t <- *unique D* D*A Did\n\t\t <- itrue-respects-id x' Did E''}\n\t   sound/true (E x) D* (E' x')).\n- : sound/true (app E1 E2) D*B (iapp E1' E2')\n     <- *tot A D*A\n     <- sound/true E1 (*/imp D*B D*A) E1'\n     <- sound/true  E2 D*A E2'.\n- : sound/true ((cabort E) : >> true C) D* (iabort E')\n     <- sound/contra E E'.\n- : sound/true ((nboti E) : >> true nbot) */nbot (iabort E')\n     <- sound/contra E E'.\n- : sound/true ((noti E) : >> true (not A)) (*/not D*) E'\n     <- sound/false E D* E'.\n- : sound/true (notcase E1 E2) D*C (E2' E1')\n     <- *tot A D*A \n     <- sound/true E1 (*/not (D*A : * A A')) E1'\n     <- ({x : >> false A} {x' : itrue (inot A')} \n\t   {_ : {A'' : iprop} {D* : * A A''} \n\t\t {Did : id-iprop A'' A'}\n\t\t {Did' : id-iprop (inot A'') (inot A')}\n\t\t {E'' : itrue (inot A'')}\n\t\t sound/false x D* E''\n\t\t <- *unique D* D*A Did\n\t\t <- id-iprop-not-cong Did Did'\n\t\t <- itrue-respects-id x' Did' E''}\n\t   sound/true (E2 x) D*C (E2' x')).\n- : sound/true ((letcc E) : >> true A) D*A (Edne (ilam E'))\n     <- ({x : >> false A} {x' : itrue (inot A')}  \n\t   {_ : {A'' : iprop} {D* : * A A''} \n\t\t {Did : id-iprop A'' A'}\n\t\t {Did' : id-iprop (inot A'') (inot A')}\n\t\t {E'' : itrue (inot A'')}\n\t\t sound/false x D* E''\n\t\t <- *unique D* D*A Did\n\t\t <- id-iprop-not-cong Did Did'\n\t\t <- itrue-respects-id x' Did' E''}\n\t   sound/contra (E x) (E' x'))\n     <- dne D*A Edne.\n\n%% false\n\n- : sound/false ((cont E) : >> false A) D*A (ilam E')\n     <-  ({x : >> true A} {x' : itrue A'} \n\t    {_ : {A''} {D* : * A A''} {Did} {E''}\n\t\t  sound/true x D* E''\n\t\t  <- *unique D* D*A Did\n\t\t  <- itrue-respects-id x' Did E''}\n\t    sound/contra (E x) (E' x')).\n- : sound/false (cabort E) D* (iabort E')\n     <- sound/contra E E'.\n- : sound/false (case (E : >> true (or A B)) E1 E2) D* \n     (ilam [c : itrue C]\n\tiapp E' (ilam [x]\n\t\t   (icase x \n\t\t      ([x1] iapp (E1' x1) c) \n\t\t      ([x2] iapp (E2' x2) c))))\n     <- *tot _ D*A\n     <- *tot _ D*B\n     <- sound/true E (*/or D*B D*A) E'\n     <- ({x : >> true A} {x' : itrue A'} \n\t   {_ : {A''} {D* : * A A''} {Did} {E''}\n\t\t sound/true x D* E''\n\t\t <- *unique D* D*A Did\n\t\t <- itrue-respects-id x' Did E''}\n\t   sound/false (E1 x) D* (E1' x'))\n     <- ({x : >> true B} {x' : itrue B'} \n\t   {_ : {A''} {D* : * B A''} {Did} {E''}\n\t\t sound/true x D* E''\n\t\t <- *unique D* D*B Did\n\t\t <- itrue-respects-id x' Did E''}\n\t   sound/false (E2 x) D* (E2' x')).\n- : sound/false ((abort E) : >> false C) D* (iabort E')\n     <- sound/true E */bot E'.\n- : sound/false (notcase E1 E2) D*C (E2' E1')\n     <- *tot _ D*A\n     <- sound/true E1 (*/not (D*A : * A A')) E1'\n     <- ({x : >> false A} {x' : itrue (inot A')}  \n\t   {_ : {A'' : iprop} {D* : * A A''} \n\t\t {Did : id-iprop A'' A'}\n\t\t {Did' : id-iprop (inot A'') (inot A')}\n\t\t {E'' : itrue (inot A'')}\n\t\t sound/false x D* E''\n\t\t <- *unique D* D*A Did\n\t\t <- id-iprop-not-cong Did Did'\n\t\t <- itrue-respects-id x' Did' E''}\n\t   sound/false (E2 x) D*C (E2' x')).\n\n%% contra \n\n- : sound/contra (throw E1 E2) (iapp E1' E2')\n     <- *tot _ D*\n     <- sound/true E2 D* E2'\n     <- sound/false E1 D* E1'.\n- : sound/contra (nbote E) E'\n     <- sound/true E */nbot E'.\n- : sound/contra (case E E1 E2) \n     (iapp E' (ilam [x] (icase x E1' E2')))\n     <- *tot _ D*A\n     <- *tot _ D*B\n     <- sound/true E (*/or D*B D*A) E'\n     <- ({x : >> true A} {x' : itrue A'} \n\t   {_ : {A''} {D* : * A A''} {Did} {E''}\n\t\t sound/true x D* E''\n\t\t <- *unique D* D*A Did\n\t\t <- itrue-respects-id x' Did E''}\n\t   sound/contra (E1 x) (E1' x'))\n     <- ({x : >> true B} {x' : itrue B'}\n\t   {_ : {A''} {D* : * B A''} {Did} {E''}\n\t\t sound/true x D* E''\n\t\t <- *unique D* D*B Did\n\t\t <- itrue-respects-id x' Did E''}\n\t   sound/contra (E2 x) (E2' x')).\n- : sound/contra (abort E) (iabort E')\n     <- sound/true E */bot E'.\n- : sound/contra (cabort E) E'\n     <- sound/contra E E'.\n- : sound/contra (notcase E1 E2) (E2' E1')\n     <- *tot _ D*A\n     <- sound/true E1 (*/not (D*A : * A A')) E1'\n     <- ({x : >> false A} {x' : itrue (inot A')}\n\t   {_ : {A'' : iprop} {D* : * A A''} \n\t\t {Did : id-iprop A'' A'}\n\t\t {Did' : id-iprop (inot A'') (inot A')}\n\t\t {E'' : itrue (inot A'')}\n\t\t sound/false x D* E''\n\t\t <- *unique D* D*A Did\n\t\t <- id-iprop-not-cong Did Did'\n\t\t <- itrue-respects-id x' Did' E''}\n\t   sound/contra (E2 x) (E2' x')).\n\n%% uses a fancy variable case:\n%block soundtb : some {A : prop} {A' : iprop} {Dx : * A A'}\n\t\t block {x : >> true A} {x' : itrue A'} \n\t\t  {_ : {A''} {D* : * A A''} {Did} {E''}\n\t\t\tsound/true x D* E''\n\t\t\t<- *unique D* Dx Did\n\t\t\t<- itrue-respects-id x' Did E''}.\n%block soundfb : some {A : prop} {A' : iprop} {Dx : * A A'}\n\t\t block {x : >> false A} {x' : itrue (inot A')} \n\t\t  {_ : {A'' : iprop} {D* : * A A''} \n\t\t\t{Did : id-iprop A'' A'}\n\t\t\t{Did' : id-iprop (inot A'') (inot A')}\n\t\t\t{E'' : itrue (inot A'')}\n\t\t\tsound/false x D* E''\n\t\t\t<- *unique D* Dx Did\n\t\t\t<- id-iprop-not-cong Did Did'\n\t\t\t<- itrue-respects-id x' Did' E''}.\n%block soundpb : block {X : prop} {X' : iprop} {dx : * X (idn X')}\n\t\t  {_ : dne dx tne}\n\t\t  {_ : *tot X dx}.\n\n%worlds (soundpb | soundtb | soundfb) (sound/true _ _ _) (sound/true _ _ _) (sound/false _ _ _) (sound/false _ _ _) (sound/contra _ _).\n%total (D1 D4 D2 D5 D3) (sound/true D4 _ _) (sound/true D1 _ _) (sound/false D5 _ _) (sound/false D2 _ _) (sound/contra D3 _).\n\n\n%{\n\n== Completeness ==\n\n=== Inclusion ===\n\nInclude intuitionistic props into classical.  We need to define another\ntranslation because * is not total with the reverse mode (it doesn't\ntranslate atoms).\n\n}%\n\n*i : prop -> iprop -> type.\n%mode *i -A +A'.\n\n*i/top : *i top itop.\n*i/and : *i (and A B) (iand A' B')\n\t <- *i A A'\n\t <- *i B B'.\n*i/bot : *i bot ibot.\n*i/or : *i (or A B) (ior A' B')\n\t <- *i A A'\n\t <- *i B B'.\n*i/imp : *i (imp A B) (iimp A' B')\n\t <- *i A A'\n\t <- *i B B'.\n\n%block *ib : block {X : prop} {X' : iprop} {_ : *i X X'}.\n%worlds (*ib) (*i _ _).\n%total A (*i _ A).\n%unique *i -1A +A'. \n\n*itot : {A'} *i A A' -> type.\n%mode *itot +A -D*i.\n\n%block *itotb : block {X : prop} {X' : iprop} \n\t\t {D*i : *i X X'} {_ : *itot X' D*i}.\n%worlds (*itotb | fb | pb) (*itot _ _).\n%trustme %total {} (*itot _ _).  %% verified by %total above\n\nid-prop : prop -> prop -> type.\nid-prop/refl : id-prop A A.\n\n*iunique : *i A A' -> *i B A' -> id-prop A B -> type.\n%mode *iunique +X1 +X2 -X3.\n%worlds (*ib | fb | pb) (*iunique _ _ _).\n%trustme %total {} (*iunique _ _ _). %% verified by %unique above\n\ntrue-respects-id : >> true A -> id-prop A' A -> >> true A' -> type.\n%mode true-respects-id +X1 +X2 -X3.\n- : true-respects-id D _ D.\n%worlds (tb | fb | pb) (true-respects-id _ _ _).\n%total {} (true-respects-id _ _ _).\n\n%{\n\n=== Intuitionistic truth implies classical truth ===\n\nThe arguments are in a funny order because I copied from soundness. =)\n\n}%\n\nincl :  >> true A -> *i A A' -> itrue A' -> type.\n%mode incl -X1 +X2 +X3.\n\n- : incl mt *i/top imt.\n- : incl (pair E1 E2) (*i/and D*2 D*1) (ipair E1' E2')\n     <- incl E1 D*1 E1'\n     <- incl E2 D*2 E2'.\n- : incl (fst E) D*1 (ifst (E' : itrue (iand A1 A2)))\n     <- *itot A2 D*2\n     <- incl E (*i/and D*2 D*1) E'.\n- : incl (snd (E : >> true (and A1 A2))) D*2 (isnd E')\n     <- *itot _ D*1\n     <- incl E (*i/and D*2 D*1) E'.\n- : incl ((abort E) : >> true C) D* (iabort E')\n     <- incl E *i/bot E'.\n- : incl ((inl E) : >> true (or A1 A2)) (*i/or D*2 D*1) (iinl E')\n     <- incl E D*1 E'.\n- : incl ((inr E) : >> true (or A1 A2)) (*i/or D*2 D*1) (iinr E')\n     <- incl E D*2 E'.\n- : incl (case (E : >> true (or A B)) E1 E2) D* (icase E' E1' E2')\n     <- *itot _ D*A\n     <- *itot _ D*B\n     <- incl E (*i/or D*B D*A) E'\n     <- ({x : >> true A} {x' : itrue A'} \n\t   {_ : {A-2} {D*' : *i A-2 A'} {Did : id-prop A-2 A} {E : >> true A-2}\n\t\t      incl E D*' x'\n\t\t      <- *iunique D*' D*A Did\n\t\t      <- true-respects-id x Did E\n\t\t       }\n\t   incl (E1 x) D* (E1' x'))\n     <- ({x : >> true B} {x' : itrue B'} \n\t   {_ : {B-2} {D*' : *i B-2 B'} {Did : id-prop B-2 B} {E : >> true B-2}\n\t\t      incl E D*' x'\n\t\t      <- *iunique D*' D*B Did\n\t\t      <- true-respects-id x Did E\n\t\t      }\n\t   incl (E2 x) D* (E2' x')).\n- : incl ((lam E) : >> true (imp A B)) (*i/imp D* D*A) (ilam E')\n     <- ({x : >> true A} {x' : itrue A'} \n\t   {_ : {A-2} {D*' : *i A-2 A'} {Did : id-prop A-2 A} {E : >> true A-2}\n\t\t      incl E D*' x'\n\t\t      <- *iunique D*' D*A Did\n\t\t      <- true-respects-id x Did E\n\t\t\t}\n\t   incl (E x) D* (E' x')).\n- : incl (app E1 E2) D*B (iapp E1' E2')\n     <- *itot A D*A\n     <- incl E1 (*i/imp D*B D*A) E1'\n     <- incl  E2 D*A E2'.\n\n%block inclb : some {A} {A'} {D* : *i A A'}\n\t\tblock {x : >> true A} {x' : itrue A'} \n\t\t{_ : {A-2} {D*' : *i A-2 A'} {Did : id-prop A-2 A} {E : >> true A-2}\n\t\t      incl E D*' x'\n\t\t      <- *iunique D*' D* Did\n\t\t      <- true-respects-id x Did E\n\t\t      }.\n%worlds (inclb | fb | *itotb) (incl _ _ _). \n%total D (incl _ _ D).\n\n%{\n\n=== Round-tripping the two translations is classically equivalent ===\n\n}%\n\nequiv : * A A' -> *i A'' A' -> >> true (iff A A'') -> type.\n%mode equiv +X1 +X2 -X3.\n\n- : equiv D D' (iffi ([x] x) ([x] x)).\n- : equiv (*/and D*2 D*1) (*i/and D*2' D*1') \n     (iffi \n\t([x] (pair (iffel E1 (fst x)) (iffel E2 (snd x))))\n\t([x] (pair (iffer E1 (fst x)) (iffer E2 (snd x)))))\n     <- equiv D*1 D*1' E1\n     <- equiv D*2 D*2' E2.\n- : equiv (*/or D*2 D*1) (*i/imp *i/bot (*i/imp *i/bot (*i/or D*2' D*1')))\n     (iffi\n\t([x] (iffel notimpbot2\n\t\t(cdni \n\t\t   (case x \n\t\t      ([x1] (inl (iffel E1 x1)))\n\t\t      ([x2] (inr (iffel E2 x2)))))))\n \t([x] (case (cdne (iffer notimpbot2 x))\n\t\t([x1] (inl (iffer E1 x1))) ([x2] (inr (iffer E2 x2))))))\n     <- equiv D*1 D*1' E1\n     <- equiv D*2 D*2' E2.\n- : equiv (*/imp D*2 D*1) (*i/imp D*2' D*1') \n     (iffi \n\t([f : >> true (imp A1 A2)] (lam [x : >> true B1] (iffel E2 (app f (iffer E1 x)))))\n\t([f : >> true (imp B1 B2)] (lam [x : >> true A1] (iffer E2 (app f (iffel E1 x))))))\n     <- equiv D*1 D*1' (E1 : >> true (iff A1 B1))\n     <- equiv D*2 D*2' (E2 : >> true (iff A2 B2)).\n- : equiv */nbot *i/bot (iffi ([x] (cabort (nbote x))) ([x] abort x)).\n- : equiv (*/not D*) (*i/imp *i/bot D*') \n     (iffi\n\t([x] (lam [y] (cabort (notcase x [u] throw u (iffer E y)))))\n\t([x] (noti (cont [y] (abort (app x (iffel E y)))))))\n     <- equiv D* D*' E.\n\n%block equivb : block {X : prop} {X' : iprop} \n\t\t {d*i : *i X X'}\n\t\t {d*  : * X (inot (inot X'))}\n\t\t {_   : equiv d* (*i/imp *i/bot (*i/imp *i/bot d*i)) \n\t\t\t (iffi \n\t\t\t    ([x : >> true X] (iffel notimpbot2 (cdni x)))\n\t\t\t    ([x : >> true (imp (imp X bot) bot)]\n\t\t\t       (cdne (iffer notimpbot2 x))))\n\t\t\t    }.\n\n%worlds (equivb | tb | fb) (equiv _ _ _).\n%total D (equiv D _ _).\n\n%{\n\n=== If A* is intuitionistically true, then A is classically true ===\n\n}%\n\ncomp : itrue A' -> * A A' -> >> true A -> type.\n%mode comp +X1 +X2 -X3. \n\n- : comp (E' : itrue A') D* (iffer Eiff E)\n     <- *itot A' D*i\n     <- incl E D*i E'\n     <- equiv D* D*i Eiff.\n\n%block comp-pb : block {X : prop} {X' : iprop} \n\t\t {d*i : *i X X'}\n\t\t {d*  : * X (inot (inot X'))}\n\t\t {_   : equiv d* (*i/imp *i/bot (*i/imp *i/bot d*i)) \n\t\t\t (iffi \n\t\t\t    ([x : >> true X] (iffel notimpbot2 (cdni x)))\n\t\t\t    ([x : >> true (imp (imp X bot) bot)]\n\t\t\t       (cdne (iffer notimpbot2 x))))\n\t\t\t    }\n\t\t  {_ : *itot X' d*i}.\n\n%worlds (comp-pb | inclb | fb) (comp _ _ _).\n%total E1 (comp E1 _ _).\n\ncomp/false : itrue (iimp A' ibot) -> * A A' -> >> false A -> type.\n%mode comp/false +X1 +X2 -X3.\n\n- : comp/false E D* (cont [x] (notcase E' [u] throw u x))\n     <- comp E (*/not D*)  E'.\n\n%worlds (comp-pb | inclb | fb) (comp/false _ _ _).\n%total {} (comp/false _ _ _).\n\ncomp/contra : itrue ibot -> >> contra -> type.\n%mode comp/contra +X1 -X3.\n\n- : comp/contra E (nbote E')\n     <- comp E */nbot  E'.\n\n%worlds (comp-pb | inclb | fb) (comp/contra _ _).\n%total {} (comp/contra _ _)."
          },
          "sha1": "e8xomnrvkyeqnlonmudty9umrklew6o"
        }
      },
      {
        "title": "Download",
        "ns": 0,
        "id": 1391,
        "revision": {
          "id": 8012,
          "parentid": 6236,
          "timestamp": "2016-01-17T18:59:49Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "plparty--",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 4063,
            "#text": "The current version of Twelf is 1.7.1. You can also [[Twelf Live|try Twelf live]] in your browser.\n\n* [http://twelf.org/releases/twelf-src-1.7.1.tar.gz twelf-src-1.7.1.tar.gz] - Source distribution, can be built with MLton or SML/NJ\n* [http://twelf.org/releases/twelf-linux-1.7.1.tar.gz twelf-linux-1.7.1.tar.gz] - Pre-built distribution for Linux\n* [http://twelf.org/releases/twelf-osx-1.7.1.dmg twelf-osx-1.7.1.dmg] - Pre-built distribution for OSX\n* (Working on it) - Pre-built distribution for Windows\n\n== Installation instructions ==\n\n==== Pre-compiled versions ====\n\nIf you download the pre-compiled Linux or Windows versions of Twelf, simply run the installer (on Windows) or unpack the tarball wherever you want to put the distribution (on Linux), and the skip to the instructions for setting up Emacs below.\n\n==== Installing with SML/NJ ====\n\nYou will need to have the Standard ML of New Jersey software on your computer. This can be obtained from the [http://www.smlnj.org SML/NJ website]. Additionally, you will need the standard unix-style Make tools. These come with basically any Linux distribution. Windows users should check out the [http://www.cygwin.com Cygwin Project] to install those tools under Windows. Once you have these things set up, Twelf can be built by running the following commands:\n\n<pre>$ cd twelf\n$ make smlnj</pre>\n\n==== Installing with MLton ====\n\nYou will need to have the MLton compiler installed on your system. This can be obtained from the [http://mlton.org/ MLton website]. Using Twelf with MLton has not been tested on Windows. On Linux, Twelf can be built by running the following commands:\n\n<pre>$ cd twelf\n$ make mlton</pre>\n\n==== Setting up Emacs ====\n\nA piece of information about using [[Twelf with Emacs]] is printed out by the installation script (and can be found in the disk image for the OSX distribution), telling you to add two lines somewhere in your <tt>.emacs</tt> file. If you don't have a <tt>.emacs</tt> file in your home directory, you can create one and add these two lines.\n\nIf you put Twelf in the directory <tt>/somewhere/twelf/</tt> then you should add these lines (just replace <tt>somewhere</tt> with wherever you built Twelf).\n\n<code>(setq twelf-root \"/somewhere/twelf/\")\n(load (concat twelf-root \"emacs/twelf-init.el\"))</code>\n\nWhen using the Windows installer, the default directory is <tt>C:\\Program Files\\Twelf</tt>, so \n\n<code>(setq twelf-root \"C:\\\\Program Files\\\\Twelf\\\\\")\n(load (concat twelf-root \"emacs\\\\twelf-init.el\"))</code>\n\n== Other ways of getting Twelf ==\n\n==== Twelf Night(ly) ====\n\nThe [http://twelf.plparty.org/builds Twelf Night(ly)] system is regularly updated with OSX and Linux binary distributions, and includes the output of an extensive test suite. Before you download from Twelf Night(ly), check the log messages and make sure nothing seems out of the ordinary. If anything seems wrong, or if the Windows binary is out of date, contact [[User:Rsimmons|Rob]] who maintains the system.\n\n==== Twelf Subversion ====\n<!-- If you change this subheading's title, make sure you also change the articles that link to this section specifically:\n\n* Holes in metatheorems\n\n-->\n\nSubversion comes installed on most Linux systems and Mac OS X systems, and can be obtained from [http://subversion.tigris.org/ subversion.tigris.org] for other operating systems, including Windows. If subversion is installed, the development version of Twelf (which is not guaranteed to be stable, but which usually is in practice) can be checked out by executing the following command at a command line:\n\n<pre>$ svn co https://svn.concert.cs.cmu.edu/twelf/trunk twelf</pre>\n\nThese commands will download all of the Twelf source code into a directory called \"twelf\" inside of the directory you are in when you execute the commands listed in the installation instructions.\n\n==== Older versions of Twelf ====\n\nLinks to older software versions are available from the [[revision history]] page, but use of any version earlier than 1.7.0, especially when working with metatheorems, is highly discouraged."
          },
          "sha1": "d3n77aiepim24btlhqcb7szo4b3nemi"
        }
      },
      {
        "title": "Editing Summer school 2008:Alternate typed arithmetic expressions with sums",
        "ns": 0,
        "id": 2079,
        "redirect": {
          "@title": "Summer school 2008:Alternate typed arithmetic expressions with sums",
          "#text": null
        },
        "revision": {
          "id": 5353,
          "timestamp": "2008-07-24T00:54:51Z",
          "contributor": {
            "username": "Cmartens",
            "id": 35
          },
          "comment": "[[Editing Summer school 2008:Alternate typed arithmetic expressions with sums]] moved to [[Summer school 2008:Alternate typed arithmetic expressions with sums]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 81,
            "#text": "#REDIRECT [[Summer school 2008:Alternate typed arithmetic expressions with sums]]"
          },
          "sha1": "gudlg44fyutsg1jcdtbib8xtb7nre8g"
        }
      },
      {
        "title": "Effectiveness",
        "ns": 0,
        "id": 2030,
        "redirect": {
          "@title": "Effectiveness lemma",
          "#text": null
        },
        "revision": {
          "id": 5030,
          "timestamp": "2007-11-14T19:15:15Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "comment": "redir to [[effectiveness lemma]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 33,
            "#text": "#REDIRECT [[effectiveness lemma]]"
          },
          "sha1": "5n7ampozlcbe5sffw5atk9uo7alx22v"
        }
      },
      {
        "title": "Effectiveness lemma",
        "ns": 0,
        "id": 1477,
        "revision": {
          "id": 6107,
          "parentid": 4848,
          "timestamp": "2010-09-01T21:48:37Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "Fix twelftag bugs",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 5391,
            "#text": "We use the term '''effectiveness lemma''' for a lemma that explicitly proves a [[totality assertion]] for an LF type family using another LF type family.  \n\nThere are two reasons to prove an effectiveness lemma:\n# A type family may satisfy a totality assertion but not be written in such a way that Twelf can verify its totality automatically with a [[%total]] declaration.  For example, justifying the induction might require an [[structural metrics|explicit termination metric]], or knowing that the type family covers all possible inputs might require some sophisticated reasoning (such as [[reasoning from false]]).\n# As an artifact of the way totality checking works, it is sometimes necessary to prove an effectiveness lemma even when Twelf has already verified the corresponding [[%total]] declaration.  \n\nWe discuss these motivations in more detail after presenting an example effectiveness lemma.\n\n==Example effectiveness lemma==\n\nConsider the relation that negates a bit:\n\n<twelf>\nbit : type.\nbit/0 : bit.\nbit/1 : bit.\n \nbit-flip : bit -> bit -> type.\n \nbit-flip/01 : bit-flip bit/0 bit/1.\nbit-flip/10 : bit-flip bit/1 bit/0.\n</twelf>\n\nWe can ask Twelf to prove the following totality assertion:\n\n: For all <tt>B : bit</tt>, there exists a <tt>B' : bit</tt> and <tt>D : bit-flip B B'</tt>.\n\nas follows:\n\n<twelf check=\"true\">\n%mode bit-flip +B -B'.\n%worlds () (bit-flip _ _).\n%total {} (bit-flip _ _).\n</twelf>\n\nHowever, we can also prove the totality relation explicitly as an effectiveness lemma <tt>can-bit-flip</tt>:\n\n<twelf check=\"true\">\ncan-bit-flip : {B:bit}\n                bit-flip B B'\n                -> type.\n%mode can-bit-flip +D1 -D2.\n\n- : can-bit-flip bit/0 bit-flip/01.\n\n- : can-bit-flip bit/1 bit-flip/10.\n\n%worlds () (can-bit-flip _ _).\n%total {} (can-bit-flip _ _).\n</twelf>\n\nWhen processing the <tt>%total</tt>, Twelf verifies the following totality assertion:\n: For all <tt>B : bit</tt>, there exists a <tt>B' : bit</tt> and <tt>D : bit-flip B B'</tt> and a <tt>D' : can-bit-flip B D</tt>.\n\n==Motivating scenario==\n\nThis particular example is clearly not motivated by the first consideration mentioned above, as Twelf was able to prove the totality assertion directly.  For such an example, see the tutorial on [[structural metrics|explicit termination metrics]].\n\nHowever, this effectiveness lemma is motivated by the second consideration, as the following example demonstrates.  Consider a programming language that includes primitive bits and a negation operation on them:\n<twelf>\ntp     : type.\ntp/bit : tp.\n\ntm  : type.\nbt  : bit -> tm.\nneg : tm -> tm.\n\nof : tm -> tp -> type.\nof-bt : of (bt _) tp/bit.\nof-neg : of (neg E) tp/bit\n          <- of E tp/bit.\n\neval     : tm -> tm -> type.\neval-bt  : eval (bt B) (bt B).\neval-neg : eval (neg E) (bt B')\n             <- eval E (bt B)\n             <- bit-flip B B'.\n</twelf>\nWe elide the parts of the language that are not relevant to this example.\n\nFor simplicity, assume the language is manifestly terminating, so the progress theorem can be proved by a simple inductive argument that shows that all terms evaluate to a value:\n\n<twelf discard=true>\nprogress : of E T -> eval E V -> type.\n%mode progress +D1 -D2.\n%worlds () (progress _ _).\n</twelf>\n<twelf hidden=true>\nprogress : of E T -> eval E V -> type.\n%mode progress +D1 -D2.\n</twelf>\n\nNow, consider the case of progress for <tt>of-neg</tt>:\n\n<twelf check=decl discard=true>\n- : {Dflip : bit-flip B B'}\n     progress \n     (of-neg (Dof : of E tp/bit)) \n     (eval-neg Dflip DevalE)\n     <- progress Dof (DevalE : eval E (bt B)).\n</twelf>\n\nBy induction, we come up with a derivation <tt>DevalE</tt>, which, by the value inversion lemma, must result in a value of the form <tt>(bt B)</tt>.  To finish the case, we need a derivation <tt>Dflip : bit-flip B X1</tt> for some <tt>B':bit</tt>.  \n\nYou might think that this case should be accepted as is.  After all, the totality assertion proved by the above <tt>%total</tt> shows that such a <tt>Dflip</tt> must exist.  \n\nUnfortunately, the current Twelf implementation rejects this case as ill-moded.  In logic programming terms, variables bound in braces like <tt>{Dflip}</tt> are treated as unification variables, so they must be filled in by unification if they are not already part of an input term.  On the other hand, [[subgoal]]s, which are the premises that are searched for using logic programming, must be written with an <tt>-></tt>.  This means that there is no way to '''name''' the derivation resulting from the appeal to the totality assertion for <tt>plus</tt>.  In metatheorem terms, this means that we cannot appeal to the totality assertion for a type family to come up with a derivation of the type family itself, only the output indices of the family.  \n\nThe work-around is to prove the effectiveness lemma.  Using the above effectiveness lemma, we can finish this case as follows:\n\n<twelf check=decl>\n- : progress \n     (of-neg (Dof : of E tp/bit)) \n     (eval-neg Dflip DevalE)\n     <- progress Dof (DevalE : eval E (bt B))\n     <- can-bit-flip B Dflip.\n</twelf>\n\nBecause the derivation of <tt> bit-flip B B'</tt> is an index to <tt>can-flip-bit</tt>, the case is mode-correct.\n\nThis limitation of Twelf could conceivably be addressed in a future release.  For now, it is straightforward to work around it using effectiveness lemmas to prove totality assertions explicitly.\n\n{{tutorial}}"
          },
          "sha1": "5eqx9rdn3x2j07hih5qwaiktxo7snbb"
        }
      },
      {
        "title": "Effectiveness lemmas",
        "ns": 0,
        "id": 1643,
        "redirect": {
          "@title": "Effectiveness lemma",
          "#text": null
        },
        "revision": {
          "id": 2296,
          "timestamp": "2006-09-30T18:12:17Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "redir plural",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 33,
            "#text": "#REDIRECT [[Effectiveness lemma]]"
          },
          "sha1": "99nojybs6ln1rluzbmfe6e4y351iid3"
        }
      },
      {
        "title": "Equality",
        "ns": 0,
        "id": 1474,
        "revision": {
          "id": 6108,
          "parentid": 4196,
          "timestamp": "2010-09-02T01:27:49Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 7822,
            "#text": "In many circumstances, it is necessary to represent '''equality''' of LF terms as a relation.  \n\nOne such circumstance is when we wish to prove a [[uniqueness lemma]] showing that an object-language judgement determines some outputs uniquely.  For example, consider the [[Proving metatheorems:Representing the judgements of the natural numbers|addition judgement on natural numbers]].  To state this uniqueness lemma, we must define a judgement <tt>eq N N'</tt> representing equality of natural numbers.  Then the theorem is stated as follows:\n<twelf discard=true>\nplus-unique : plus N1 N2 N3 \n              -> plus N1 N2 N3' \n              -> eq N3 N3'\n              -> type.\n%mode plus-unique +D1 +D2 -D3.\n%worlds () (plus-unique _ _ _).\n</twelf>\nThat is, any two <tt>plus</tt> derivations for the same summands have the same sum.  \n\nIn general, equality of LF terms corresponds to syntactic equality of object-language syntax encoded with a first-order representation, and to α-equivalance of object-language terms encoded with a higher-order representation.  Consequently, equality is used in a variety of theorems and proofs (see the tutorials on [[uniqueness lemma]]s, [[strengthening]] lemmas, and explicit [[canonical forms lemma]]s for example applications).  \n\nThe purpose of this article is to answer the following question: how should we internalize equality of LF terms as an LF type family?\n\n== Running example: A tree structure ==\n\nAs a running example, we use a simple tree structure:\n\n<twelf>\ntree: type.\n\nleaf: tree.\nnode: tree -> tree -> tree.\n</twelf>\n\n== Identity ==\n\nThe simplest way to represent equality of LF terms is with an ''identity type family''.  An identity type family represents a binary relation; it is defined by one constant expressing reflexivity.  For example:\n\n<twelf>\nid-tree : tree -> tree -> type.\nid-tree/refl : id-tree T T.\n</twelf>\n\nWith this definition, the type <tt>id T T'</tt> is inhabited exactly when <tt>T</tt> and <tt>T'</tt> are in fact the same LF term. \n\nVarious properties of <tt>id</tt> are admissible:\n* Identity is symmetric and transitive.  For example, we can prove the following metatheorems:\n<twelf>\nid-tree-sym : id-tree T1 T2\n            -> id-tree T2 T1\n            -> type.\n%mode id-tree-sym +X1 -X2.\n- : id-tree-sym id-tree/refl id-tree/refl.\n%worlds () (id-tree-sym _ _).\n%total {} (id-tree-sym _ _).\n\nid-tree-trans : id-tree T1 T2\n              -> id-tree T2 T3\n              -> id-tree T1 T3\n              -> type.\n%mode id-tree-trans +X1 +X2 -X3.\n- : id-tree-trans id-tree/refl id-tree/refl id-tree/refl.\n%worlds () (id-tree-trans _ _ _).\n%total {} (id-tree-trans _ _ _).\n</twelf>\n\n* Identity is a congruence: equality of subterms entails equality of subterms. For example, we can prove the following metatheorem: \n<twelf>\nid-tree-node-cong : id-tree T1 T1'\n                  -> id-tree T2 T2'\n                  -> id-tree (node T1 T2) (node T1' T2')\n                  -> type.\n%mode id-tree-node-cong +X1 +X2 -X3.\n- : id-tree-node-cong id-tree/refl id-tree/refl id-tree/refl.\n%worlds () (id-tree-node-cong _ _ _).\n%total {} (id-tree-node-cong _ _ _).\n</twelf>\n\n* Identity is invertible: equality of a constructed term entails equality of constructed terms.  For example, we can prove the following metatheorem:\n<twelf>\nid-tree-node-inv : id-tree (node T1 T2) (node T1' T2')\n                  -> id-tree T1 T1'\n                  -> id-tree T2 T2'\n                  -> type.\n%mode id-tree-node-inv +X1 -X2 -X3.\n- : id-tree-node-inv id-tree/refl id-tree/refl id-tree/refl.\n%worlds () (id-tree-node-inv _ _ _).\n%total {} (id-tree-node-inv _ _ _).\n</twelf>\n\n* Other relations respect equality, in the sense that we can replace equals for equals.  For example, if we have a height relation on trees, then we will be able to prove the following metatheorem:\n<twelf hidden=true>nat : type.</twelf>\n<twelf>\nheight : tree -> nat -> type.\n\nheight-respects-id : height T N\n                    -> id-tree T T' \n                    -> height T N'\n                    -> type.\n%mode height-respects-id +X1 +X2 -X3.\n%worlds () (height-respects-id _ _ _).\n</twelf>\n\nEach of these proofs is a one-liner: the only possible identity derivations are reflexivity, so all the trees involved are equal, and thus reflexivity derives the result.  The tutorial on [[respects lemma]]s presents other examples of these metatheorems.  \n\n== Alternative definition of equality: More primitive rules ==\n\nNow, if symmetry, transitivity, congruence, and invertibility are all admissible, you might consider other sets of primitive rules.  For example, we could give a definition of equality by induction on the structure of the tree:\n\n<twelf>\neq-tree : tree -> tree -> type.\n\neq-leaf : eq-tree leaf leaf.\neq-node : eq-tree (node T1 T2) (node T1' T2')\n            <- eq-tree  T1 T1'\n            <- eq-tree  T2 T2'.\n</twelf>\n\nThis definition is sometimes called ''deep equality'', as it analyzes the structure of the term.  In contrast, identity is sometimes called ''shallow equality''.  \n\nWe could add to this definition by making the equivalence relation axioms primitive as well:\n<twelf>\neq-refl : eq-tree T T.\neq-sym : eq-tree T1 T2 \n          <- eq-tree T2 T1.\neq-trans : eq-tree  T1 T3\n            <- eq-tree T1 T2\n            <- eq-tree T2 T3.\n</twelf>\n\nWe could even make the inversion principles primitive:\n<twelf>\neq-node-inv-1 : eq-tree T1 T1'\n                 <- eq-tree (node T1 T2) (node T1' T2').\neq-node-inv-2 : eq-tree T2 T2'\n                 <- eq-tree (node T1 T2) (node T1' T2').\n</twelf>\n\n== Which definition to use ==\n\nThe type families <tt>id</tt> and <tt>eq</tt> (with any of the extensions) define the same binary relation on trees.  So is there any reason to prefer one set of primitive rules to another?\n\nYes!  In either case, we must prove that other type families such as <tt>height</tt> respect equality.  For identity, these proofs are trivial, as case-analyzing the identity derivation immediately shows that the related terms are syntactically equal.  When equality is defined by additional primitive rules, these proofs require inductive arguments.  Put another way, identity gives you the strongest inductive hypothesis when reasoning ''from'' equality, which we do often to prove respects lemmas.  Of course, the cost is that you must show that the other rules are admissible; but as we saw above, these proofs are one-liners.\n\nOn the other hand, an inductive characterization like <tt>eq</tt> is useful if you are defining not equality but some other [[equivalence relation]].  \n\n== Identity at multiple types ==\n\nIn general, it is necessary to define identity types not just for one type, but for all types that appear in the syntax.  For example, for trees that store natural numbers at the nodes, we would define:\n\n<twelf>\nnat : type.\nz : nat.\ns : nat -> nat.\n\ntree : type.\nleaf : tree.\nnode : tree -> nat -> tree -> tree.\n\nid-tree : tree -> tree -> type.\nid-tree/refl : id-tree T T.\n\nid-nat : nat -> nat -> type.\nid-nat/refl : id-nat T T.\n</twelf>\n\nProperties analogous to before are admissible, but the theorems for <tt>tree</tt> will have premises referring to <tt>id-nat</tt>.  For example:\n\n<twelf check=true>\nid-tree-node-cong : id-tree T1 T1'\n                  -> id-tree T2 T2'\n                  -> id-nat N N'\n                  -> id-tree (node T1 N T2) (node T1' N' T2')\n                  -> type.\n%mode id-tree-node-cong +X1 +X2 +X3 -X4.\n- : id-tree-node-cong _ _ _ id-tree/refl.\n%worlds () (id-tree-node-cong _ _ _ _).\n%total {} (id-tree-node-cong _ _ _ _).\n</twelf>\n\n== Other tutorials using equality ==\n\nSee the tutorial on [[respects lemma]]s for more detail on them.  The tutorials on [[uniqueness lemma]]s, [[strengthening]] lemmas, and explicit [[canonical forms lemma]]s show example applications of equality.\n\n{{tutorial}}"
          },
          "sha1": "4pyu9uaqn03ujwzvm8fj5vz7rjtlwr8"
        }
      },
      {
        "title": "Equivalence relation",
        "ns": 0,
        "id": 1681,
        "revision": {
          "id": 4194,
          "parentid": 2552,
          "timestamp": "2007-03-16T03:09:39Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 2384,
            "#text": "We represent many equivalence relations in Twelf.  The page on [[equality]] discusses how to represent syntactic equality of LF terms as an LF type family.  This page presents examples of other equivalence relations.  \n\n== Example: trees with unordered children ==\n\nGenerally we think of trees as having \"left\" and \"right\" subtrees, but imagine we wish to ignore that distinction, so that two trees are equal if they have the same colored root and their subtrees are equal, but we don't insist that the \"first\" or \"left\" subtree of one tree is equal to the first subtree of the other tree. In this notion of equality, the following two trees would be equal.\n\n<twelf>\ntree: type.\n\nleaf: tree.\nnode: tree -> tree -> tree.\n\ntree1 : tree = (node leaf (node leaf leaf)).\ntree2 : tree = (node (node leaf leaf) leaf).\n</twelf>\n\nWe define a notion of equality that is compatible with this definition:\n\n<twelf>\neq-rot-tree : tree -> tree -> type.\n\neq-rot-tree/node : eq-rot-tree leaf leaf.\n\neq-rot-tree/match : eq-rot-tree (node T1 T2) (node T1' T2')\n                     <- eq-rot-tree T1 T1'\n                     <- eq-rot-tree T2 T2'.\n\neq-rot-tree/swap : eq-rot-tree (node T1 T2) (node T2' T1')\n                    <- eq-rot-tree T1 T1'\n                    <- eq-rot-tree T2 T2'.\n\n%query 2 * eq-rot-tree tree1 tree2.\n</twelf>\n\n== Equality by canonical representative ==\n\nEquality by canonical representative is another approach to equality by means of an equivalence relation. A total, deterministic relation is defined that reduces every term to its canonical form, and the equivalence relation consideres two terms equivalent if they have identical canonical forms.\n\n=== Example: canonical representatives for trees with unordered children ===\n\nThe previous definition for equality over trees is unsatisfying in certian ways, for instance, there are two ways to prove that the tree <tt>(node leaf leaf)</tt> is equivalent to <tt>(node leaf leaf)</tt>, one that uses the rule <tt>eq-rot-tree/match</tt> and one that uses the rule <tt>eq-rot-tree/swap</tt>. We could define the canonical representative for every to be a tree where the left child was \"bigger\" than the right according to some metric, and then two trees could be compared for equality by seeing if their canonical representatives are identical.\n\n{{needs|An example of this is not put together; one would be nice.}}\n\n{{stub}}"
          },
          "sha1": "7ymtol3k0t2uccs2ss5pvkkdrw777nf"
        }
      },
      {
        "title": "Equivalence relations",
        "ns": 0,
        "id": 1676,
        "redirect": {
          "@title": "Equality",
          "#text": null
        },
        "revision": {
          "id": 2513,
          "timestamp": "2006-10-09T21:00:39Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "Equality has been refactored to a point where this is appropriate",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 22,
            "#text": "#REDIRECT [[Equality]]"
          },
          "sha1": "1evo9trxxsh7ggeo11ch1cqy7ro4l3c"
        }
      },
      {
        "title": "Error messages",
        "ns": 0,
        "id": 1801,
        "revision": {
          "id": 6078,
          "parentid": 4667,
          "timestamp": "2010-06-14T16:52:56Z",
          "contributor": {
            "username": "Boyland",
            "id": 17
          },
          "comment": "sorted and added signature error",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 4444,
            "#text": "This page lists many '''error messages''' that may be encountered using Twelf.  The explanations given below are not a complete but will hopefully be helpful when using Twelf as described in this wiki.\n\n;'''Ambiguous reconstruction''' \n:This error may indicate not passing enough “parameters” to a theorem.\n\n;'''Definition violation'''\n:This error happens sporadically when doing line-by-line (Control-C Control-D) interactions.  Try loading the whole file instead. It also happens when you write a theorem or relation abbreviation and don't declare it as an abbreviation.\n\n;'''Expected ... to be moded'''\n:Modes are necessary for termination and totality checking. See [[%mode]].\n\n;'''Expected type family, found object constant'''\n:This can occur when you define a judgment but forget \"-> type\". (Have you read [[judgments as types]]?)\n\n;'''Free variable clash'''\n: When you write a pattern and give names to the variables then Twelf won't let two user-named variables to be unified.  If they end up the same thing, it usually means your theorem is mixing up the variables and would not be as general as it appears in the pattern.  \n\n;'''Freezing violation ...'''\n:The metatheory features freeze type families, making it illegal to extend them. See [[%freeze]].\n\n;'''Left-hand side of arrow must be a type'''\n:This often happens when passing too many “parameters” to a theorem.\n\n; '''No mode declaration for XXX'''\n: If a theorem includes a relation in its proof (rather than a theorem ''about'' the relation) you get this error, assuming you haven't declared modes on your relation. The location of the offending relation may a variable declaration where the variable isn't used: <tt>{T:plus X Y Z}</tt> converts into a an arrow type <tt>plus X Y Z -></tt> if <tt>T</tt> isn't used.\n\n;Omitted term has ambiguous hyperkind\n:This only happens in pathological cases, see [[ambiguous hyperkind]].\n\n;Occurrence of variable ... in output (-) argument not necessarily ground\n:Twelf expects that in [[mode checking]], all things declared to be outputs (-) are completely determined by inputs to the relation or the outputs of [[subgoals]], and gives this error when that assumption is violated. See <tt>[[%mode]]</tt>.\n\n;Occurrence of variable ... in input (+) argument not necessarily ground\n:Twelf expects that in [[mode checking]], when a [[subgoal]] is used, then all things declared to be inputs (+) of the subgoal are entirely determined by inputs to the relation, and gives this error when that assumption is violated. See <tt>[[%mode]]</tt>.\n\n;'''Signature error: Global signature size 20000 exceeded'''\n:You have loaded and reloaded so many signatures that the maximum number has been exceeded.\n:You can reset or restart the Twelf server to start with a clean slate. If you frequently get the error, or if you are proving a very large system and need more (and your computer has sufficient memory), you can change the maximum in the file <tt>src/global/global.sml</tt> from the default (19999) to something larger.\n\n;'''Termination violation: no order assigned for ...'''\n:This happens when you are trying to run a <tt>[[%terminates]]</tt> or <tt>[[%total]]</tt> directive on a type family that calls on a ''different'' type family for which you have not established termination/totality. Go back and make sure that that the previous type family has its termination behavior/totality established. \n\n;'''Totality: Output of subgoal not covered'''\n:There is an [[output coverage]] error within a proof case.  You may need to use [[output factoring]].\n\n;'''Typing ambiguous -- unresolved constraints'''\n:This is often caused by an overuse of wild cards (underscores), which can cause the [[unification]] algorithm to fail. Another common cause is superfluous or missing arguments.\n\n;'''Undeclared identifier''' \n:This error often happens when misspelling the name of something, or when trying to use a variable that doesn't start with a capital letter.\n\n;World violation\n:This can occur when you make use of a theorem (perhaps inductively) in a non-empty context.  Try using <tt>[[%block]]</tt>.  Also, see [[substitution lemma]] for several examples.\n\nIn general, trying to find the exact cause of the error in a long proof may require binary search (ending the proof early and seeing at what point the error changes from \"output not ground\" to the error in question).\n\n{{needs|a more complete list of errors and better explanations}}"
          },
          "sha1": "9gfe3lydkmeiutpfc1xmw5xi27n91c8"
        }
      },
      {
        "title": "Eta-equivalence",
        "ns": 0,
        "id": 1934,
        "revision": {
          "id": 4659,
          "parentid": 4374,
          "timestamp": "2007-03-26T04:57:27Z",
          "contributor": {
            "username": "William Lovas",
            "id": 11
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 1300,
            "#text": "'''Eta-equivalence''' (η-equivalence) is a notion of proof equivalence in natural deduction logics with introduction and elimination forms.  Roughly, it says that any proof of a proposition is equivalent to one which introduces the proposition's principal connective.  It is a form of extensional equivalence.\n\nConsider the simply-typed lambda-calculus with arrow types.\n\n<math>A ::= a \\mid A_1 \\rightarrow A_2</math>\n\n<math>e ::= x \\mid \\lambda x{:}A.\\, e \\mid e_1\\ e_2</math>\n\nEta-equivalence for terms <math>\\texttt{}e : A \\rightarrow B</math> is the least [[congruence relation]] <math>\\texttt{}e_1 =_\\eta e_2</math> closed under the <math>\\texttt{}\\eta</math> axiom:\n\n<math>{(x \\not\\in \\mathit{FV}(e)) \\over \\lambda x{:}A.\\, e\\ x =_\\eta e} \\eta</math>\n\nIn logics and typed calculi, eta-equivalence is usually oriented to the left yielding a notion of ''eta-expansion''.  For example:\n\n<math>e : A \\rightarrow B \\Longrightarrow_\\eta \\lambda x{:}A.\\, e\\ x</math>\n\nEta-expansion transforms an arbitrary proof of a proposition into a proof that introduces the proposition's principal connective.  A term with no sub-terms that can be eta-expanded without introducing [[beta-equivalence|beta-redexes]] is said to be ''eta-long''.  Being eta-long is one aspect of being [[canonical forms|canonical]]."
          },
          "sha1": "gmeihe46w0nwujnnm6vrwnacxovipph"
        }
      },
      {
        "title": "Eta-expansion",
        "ns": 0,
        "id": 1959,
        "redirect": {
          "@title": "Eta-equivalence",
          "#text": null
        },
        "revision": {
          "id": 4484,
          "timestamp": "2007-03-20T22:02:25Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "comment": "Redirecting to [[Eta-equivalence]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 29,
            "#text": "#REDIRECT [[eta-equivalence]]"
          },
          "sha1": "a9w1vryj3un3fz8rm2wk88oujhwgdhu"
        }
      },
      {
        "title": "Eta-long",
        "ns": 0,
        "id": 1961,
        "redirect": {
          "@title": "Eta-equivalence",
          "#text": null
        },
        "revision": {
          "id": 4490,
          "parentid": 4487,
          "timestamp": "2007-03-20T22:11:45Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "comment": "Redirecting to [[Eta-equivalence]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 29,
            "#text": "#REDIRECT [[eta-equivalence]]"
          },
          "sha1": "a9w1vryj3un3fz8rm2wk88oujhwgdhu"
        }
      },
      {
        "title": "Eta-long form",
        "ns": 0,
        "id": 1923,
        "redirect": {
          "@title": "Eta-equivalence",
          "#text": null
        },
        "revision": {
          "id": 4318,
          "timestamp": "2007-03-19T21:41:08Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "comment": "Redirecting to [[Eta-equivalence]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 29,
            "#text": "#REDIRECT [[eta-equivalence]]"
          },
          "sha1": "a9w1vryj3un3fz8rm2wk88oujhwgdhu"
        }
      },
      {
        "title": "Evaluation contexts",
        "ns": 0,
        "id": 2086,
        "revision": {
          "id": 5398,
          "parentid": 5397,
          "timestamp": "2008-10-13T22:34:43Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 2234,
            "#text": "%{ \n\n== Evaluation contexts, intrinsically typed ==\n\nTwelf verifies\n# Preservation \n# Progress\n# Determinacy of factoring/step (using [[%unique]])\n\n}%\n\ntp : type.\nb : tp.\narr : tp -> tp -> tp.\n\ntm : tp -> type.\nval : tp -> type.\n\napp : tm (arr A B) -> tm A -> tm B.\nret : val A -> tm A.\nlam : (val A -> tm B) -> val (arr A B).\n\n%block tmb : some {A : tp} block {x : val A}.\n%worlds (tmb) (tm _) (val _).\n\nec : (tm A -> tm C) -> type.\nec/var  : ec ([x] x).\nec/app1 : ec ([x] app (E x) M)\n\t   <- ec E.\nec/app2 : ec ([x] app (ret V) (E x))\n\t   <- ec E.\n\nredex  : tm A -> type.\n%mode redex +X1.\nredex/beta : redex (app (ret V1) (ret V2)).\n\nfactored : tm A -> type.\nf/val : factored (ret V).\nf/ec  : factored (E M0)\n\t <- ec E\n\t <- redex M0.\n\nfactorapp : factored M1 -> factored M2 -> factored (app M1 M2) -> type.\n%mode factorapp +X1 +X2 -X3.\n\n- : factorapp\n     f/val\n     f/val \n     (f/ec redex/beta ec/var).\n\n- : factorapp\n     (f/ec (Dred0 : redex M0) (Dec : ec E))\n     (_ : factored M2)\n     (f/ec Dred0 (ec/app1 Dec)).\n\n- : factorapp\n     f/val\n     (f/ec (Dred0 : redex M0) (Dec : ec E))\n     (f/ec Dred0 (ec/app2 Dec)).\n\n%worlds () (factorapp _ _ _).\n%total {} (factorapp _ _ _).\n%unique factorapp +X1 +X2 -1X3.\n\nfactor : {M : tm A} factored M -> type.\n%mode factor +X1 -X2.\nfactor/val : factor (ret V) (f/val).\nfactor/app : factor (app E1 E2) F\n\t      <- factor E1 F1\n\t      <- factor E2 F2\n\t      <- factorapp F1 F2 F.\n%worlds () (factor _ _).\n%total M (factor M _).\n%unique factor +X1 -1X2.\n\nresult  : (tm A) -> type.\ndone    : result (ret V).\nstepped : tm A -> result (M : tm A).\n\ncontract : redex (M : tm A) -> tm A -> type.\n%mode contract +X1 -X2.\n\n- : contract (redex/beta : redex (app (ret (lam M)) (ret V))) (M V).\n\n%worlds () (contract _ _).\n%total {} (contract _ _).\n%unique contract +X1 -1X2.\n\nstepf : factored (M : tm A) -> result M -> type.\n%mode stepf +X1 -X2.\n\n- : stepf f/val done.\n- : stepf (f/ec Dr (Dec : ec E)) (stepped (E Mred))\n     <- contract Dr Mred.\n\n%worlds () (stepf _ _).\n%total {} (stepf _ _).\n%unique stepf +X1 -1X2.\n\nstep : {M : tm A} result M -> type.\n%mode step +X1 -X2.\n\nstep/i : step M M'\n\t  <- factor M F\n\t  <- stepf F M'.\n\n%worlds () (step _ _).\n%total {} (step _ _).\n%unique step +X1 -1X2."
          },
          "sha1": "4me2mm4co49plapwfcl5xdw66kyxdsr"
        }
      },
      {
        "title": "Exchange",
        "ns": 0,
        "id": 1494,
        "redirect": {
          "@title": "Exchange lemma",
          "#text": null
        },
        "revision": {
          "id": 1895,
          "timestamp": "2006-09-24T23:50:30Z",
          "contributor": {
            "username": "DanielKLee",
            "id": 5
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 28,
            "#text": "#REDIRECT [[Exchange lemma]]"
          },
          "sha1": "n0div6hrdz8jh2o1e13d5qpsijo0ycy"
        }
      },
      {
        "title": "Exchange lemma",
        "ns": 0,
        "id": 1495,
        "revision": {
          "id": 4873,
          "parentid": 4450,
          "timestamp": "2007-10-03T17:42:39Z",
          "contributor": {
            "username": "Ccasin",
            "id": 25
          },
          "minor": null,
          "comment": "typo",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 2614,
            "#text": "'''Exchange''' is the property of a hypothetical judgment that if Γ, A, B {{vdash}} J, then Γ, B, A {{vdash}} J (assuming A and B are independent hypotheses).  \n\nOften, we represent an an object-language hypothetical judgement by [[higher-order judgements|using LF binding to model hypotheses]].  When a judgement is represented in such a fashion, exchange comes \"for free\" from the LF representation.  In particular, we can exchange hypotheses by re-arranging the order of the lambdas in a derivation.\n\nFor example, consider the following simply typed λ-calculus:\n\n<twelf>\n%% Syntax\n\ntp : type.\n \ntp/unit  : tp.\ntp/arrow : tp -> tp -> tp.\n \nexp : type.\n \nexp/unit : exp.\nexp/lam  : tp -> (exp -> exp) -> exp.\nexp/app  : exp -> exp -> exp.\n\n\n%% Typing \n\nof : exp -> tp -> type.\n \nof/unit : of exp/unit tp/unit.\n \nof/lam  : of (exp/lam T E) (tp/arrow T T')\n           <- ({x:exp} of x T\n                -> of (E x) T').\n \nof/app  : of (exp/app E1 E2) T'\n           <- of E2 T\n           <- of E1 (tp/arrow T T').\n</twelf> \n\nObject-language typing is a hypothetical judgement; we represent it using LF variables to model hypotheses (see {{proving|title=Representing the judgements of the STLC}} for more discussion of this representation). \n\nWe can prove exchange for this judgement as follows:\n<twelf check=\"true\">\nexchange : ({x:exp}{dx:of x T}{y:exp}{dy:of y T'} of (E x y) T'')\n            -> ({y:exp}{dy:of y T'}{x:exp}{dx:of x T} of (E x y) T'')\n            -> type.\n%mode exchange +D1 -D2.\n\n- : exchange ([x][dx:of x T][y][dy:of y T'] D1 x dx y dy) \n             ([y][dy:of y T'][x][dx:of x T] D1 x dx y dy).\n\n%block of-block : some {T:tp} block {x:exp}{dx:of x T}.\n%worlds (of-block) (exchange _ _).\n%total {} (exchange _ _).\n</twelf>\n\nThe proof simply permutes the LF lambdas.\n\nIn practice, it is rare for exchange to be proven and used as a metatheorem. Instead, exchange is inlined by  manipulating LF lambdas in the appropriate way. \n\nIt is common to use exchange in an inductive case for a constant with a higher-order premise.\nFor example, in the [[substitution lemma]] article, exchange is used in the next-to-last case in the section [[Substitution lemma#Substitution lemmas with a \"var\" rule | Substitution lemmas with a \"var\" rule]]. The exchange property is used there when <tt>x</tt>, <tt>dx</tt> and <tt>y</tt>, <tt>dy</tt> must be re-ordered to fit the correct sub-goal:\n\n<twelf>- : subst D1 ([x][dx] of/lam ([y][dy] D2 x dx y dy)) (of/lam D2')\n     <- ({y}{dy} subst D1 ([x][dx] D2 x dx y dy) (D2' y dy))</twelf>\n\n== See also ==\n\n* [[Weakening lemma]]\n* [[Substitution lemma]]\n\n{{tutorial}}"
          },
          "sha1": "ku5wy5k2zmva3ge3chs8bwwq52z8d07"
        }
      },
      {
        "title": "Explicit context",
        "ns": 0,
        "id": 1924,
        "revision": {
          "id": 4810,
          "parentid": 4799,
          "timestamp": "2007-09-26T12:31:33Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "rv vandal",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 1507,
            "#text": "'''Explicit contexts''' are an alternative technique for encoding an [[object language]]. Standard practice is to use [[higher-order judgment]]s in order to implicitly use the [[LF]] context as the context for the object language semantics. While this affords many benefits, there are a number of proof techniques (such as [[hereditary substitution]] for [[dependent types|dependently typed languages]]) which require isolating an entry in the middle of the object language context. This is not possible in general using [[higher-order judgment]]s for languages whose context does not admit exchange. \n\nIt is possible to prove such theorems in an encoding of the object language semantics with an explicit reconstruction of the context. In order to maximally enjoy the benefits of [[higher-order judgment]]s, standard practice is to use the explicit context system only as necessary, and prove theorems that convert derivations from the implicit and explicit systems. \n\nThis technique was used in the code associated with [http://www.cs.cmu.edu/~dklee/papers/tslf.tgz Towards a Mechanized Metatheory of Standard ML]. \n\nAlthough explicit contexts are the most general technique for proving theorems that mention entries in the middle of contexts that do not admit exchange, very often there are tricks to avoid using explicit contexts. A section of the page on [[Substitution_lemma#Substitution_lemmas_with_dependent_types_.5BAdvanced_topic.5D|substitution lemmas]] illustrates one such technique. \n\n{{stub}}"
          },
          "sha1": "sn0wbfbbr4xnsf3sbzhkygnd9p8554n"
        }
      },
      {
        "title": "Explicit parameter",
        "ns": 0,
        "id": 1694,
        "redirect": {
          "@title": "Implicit and explicit parameters",
          "#text": null
        },
        "revision": {
          "id": 2676,
          "timestamp": "2006-10-12T04:56:15Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "Redirecting to [[Implicit and explicit parameters]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 46,
            "#text": "#REDIRECT [[Implicit and explicit parameters]]"
          },
          "sha1": "29fzo91l1eqb19n37srxe3ofqodcffg"
        }
      },
      {
        "title": "Extrinsic encoding",
        "ns": 0,
        "id": 1956,
        "redirect": {
          "@title": "Intrinsic and extrinsic encodings",
          "#text": null
        },
        "revision": {
          "id": 4469,
          "timestamp": "2007-03-20T21:07:34Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "Redirecting to [[Intrinsic and extrinsic encodings]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 47,
            "#text": "#REDIRECT [[Intrinsic and extrinsic encodings]]"
          },
          "sha1": "2t6p3b99vdruksv3j3zepw2olaogiy5"
        }
      },
      {
        "title": "Factoring",
        "ns": 0,
        "id": 1418,
        "redirect": {
          "@title": "Output factoring",
          "#text": null
        },
        "revision": {
          "id": 1487,
          "timestamp": "2006-09-03T05:10:20Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "[[Factoring]] moved to [[Output factoring]]: More specific title",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 30,
            "#text": "#REDIRECT [[Output factoring]]"
          },
          "sha1": "50xexw567t4k9c4n7p0pnwrp0hg4wr0"
        }
      },
      {
        "title": "First-order encodings",
        "ns": 0,
        "id": 2088,
        "revision": {
          "id": 5413,
          "timestamp": "2008-11-01T02:43:29Z",
          "contributor": {
            "username": "Twilson",
            "id": 15
          },
          "comment": "New page: A Twelf source file consists of a collection of ''declarations'', each of which is either * a ''type declaration'', in which a new type family is introduced (and named), * a ''value declar...",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 24657,
            "#text": "A Twelf source file consists of a collection of ''declarations'', each of which is either\n* a ''type declaration'', in which a new type family is introduced (and named),\n* a ''value declaration'', in which a new ''value constructor'' is introduced and given a type,\n* a ''signature check'', in which Twelf is asked to check a particular property of the type and value declarations given up to that point (collectively called the ''signature''), or\n* another kind of directive that changes the behavior of Twelf in some way.\nSignature checks and directives are indicated with keywords beginning with the '<tt>%</tt>' symbol, such as &nbsp;<tt>%mode</tt>,&nbsp; <tt>%worlds</tt>,&nbsp; <tt>%total</tt>,&nbsp; <tt>%name</tt>,&nbsp; etc., and comments are started with either '<tt>%&nbsp;</tt>' or '<tt>%%</tt>'.  Comments and judicious use of white space make source files more intelligible to readers.  We will have more to say about what we mean by type ''families'' in the next section, but, first, we look at some simpler data types.\n\nAs a first example, consider these declarations\n<twelf>\n% Days of the week\nday : type.\n\nsunday    : day.\nmonday    : day.\ntuesday   : day.\nwednesday : day.\nthursday  : day.\nfriday    : day.\nsaturday  : day.\n</twelf>\nThe keyword <tt>type</tt> in the first (type) declaration indicates that <tt>day</tt> is a new type, and, having made this declaration, the following seven (value) declarations introduce elements of this type.  These seven elements can also be viewed as ''nullary'' constructors, i.e., as operations that take an empty list of arguments and produce an element of type <tt>day</tt>.  This is a finite data type, but the same principle works for infinite types with unary and binary constructors (and, indeed, constructors of any arity):\n<twelf>\n% Natural numbers in \"unary\" form\nnat : type.\n\n0 : nat.            % zero element\ns : nat -> nat.     % unary successor operator\n\n\n% Natural number lists\nnat_list : type.\n\nnil  : nat_list.                       % empty list\ncons : nat -> nat_list -> nat_list.    % (cons N L) is the list whose first element is N and the rest of whose elements is L\n\n\n% Binary trees labelled with nats\nnat_tree : type.\n\nempty : nat_tree.                                    % empty tree\nnode  : nat -> nat_tree -> nat_tree -> nat_tree.     % (node N L R) is the tree with label N, left subtree L, and right subtree R.\n</twelf>\nIn each of these three data structure definitions, the first declaration is a type declaration, and the following two are value declarations.\nAs with types in ML, the infix arrow, which associates to the right, indicates a \"functional\" type.  However, there is no computation here, just the declaration of types and constructors.  These declarations may be compared with the following ML definitions:\n<pre>datatype day      = sunday | monday | tuesday | wednesday | thursday | friday | saturday;\ndatatype nat      = 0 | s of nat;                                (* s    : nat -> nat                            *)\ndatatype nat_list = nil | cons of nat * nat_list;                (* cons : nat * nat_list -> nat_list            *)\ndatatype nat_tree = empty | node of nat * nat_tree * nat_tree;   (* node : nat * nat_tree * nat_tree -> nat_tree *)\n</pre>\nOne difference here is that Twelf has no built-in product type, so term constructors with arity two or greater, like <tt>cons</tt> (arity 2) and <tt>node</tt> (arity 3), have to be treated as curried higher-order functions.  The elements of type <tt>nat</tt>, in both Twelf and ML, are:\n* <tt>0</tt>,\n* <tt>s 0</tt>,\n* <tt>s (s 0)</tt>,\n* <tt>s (s (s 0))</tt>,\nand so on; in fact, every element of <tt>nat</tt> results from applying the constructor <tt>s</tt> zero or more times to the constant (or nullary operator) <tt>0</tt>.  In this way, each natural number has a unique representative as an element of type <tt>nat</tt>, and each element of type <tt>nat</tt> corresponds to a unique natural number; this is the sense in which we say that we have represented the natural numbers in Twelf.\nSome of the elements of Twelf's type <tt>nat_list</tt>, with their ML counterparts, are:\n* <tt>nil</tt> &nbsp;&nbsp;(ML: <tt>nil</tt>),\n* <tt>cons 0 nil</tt> &nbsp;&nbsp;(ML: <tt>cons(0, nil)</tt>),\n* <tt>cons (s 0) (cons (s (s 0)) nil)</tt> &nbsp;&nbsp;(ML: <tt>cons(s 0, cons(s (s 0), nil))</tt>),\n* <tt>cons (s (s 0)) (cons (s 0) (cons 0 nil))</tt> &nbsp;&nbsp;(ML: <tt>cons(s (s 0), cons(s 0, cons(0, nil)))</tt>);\nthese correspond to the lists <tt>[]</tt>, <tt>[0]</tt>, <tt>[1,2]</tt>, and <tt>[2,1,0]</tt>, respectively.\nFinally, here are some elements of Twelf's type <tt>nat_tree</tt> (what are the corresponding ML terms?):\n* <tt>empty</tt>,\n* <tt>node 0 empty empty</tt>,\n* <tt>node (s 0) (node (s (s 0)) empty empty) empty</tt>, and\n* <tt>node (s (s 0)) (node 0 empty empty) (node (s 0) empty empty)</tt>.\nIn a similar way, any signature determines some types and elements of those types.\n\nTwelf also has a definition facility, whereby we can introduce new identifiers to stand for already existing elements.  For example, we could introduce the identifiers <tt>zero</tt>, <tt>one</tt>, <tt>two</tt>, etc., to stand for the corresponding elements of type <tt>nat</tt>:\n<twelf>\nzero  = 0 : nat.\none   = s zero : nat.    % or: one   = s 0 : nat.\ntwo   = s one : nat.     % or: two   = s (s 0) : nat.\nthree = s two : nat.     % or: three = s (s (s 0)) : nat.\nfour  = s three : nat.   % or: four  = s (s (s (s 0))) : nat.  etc.\n</twelf>\n\n== Type families ==\n\nThe type <tt>nat_list</tt> from the previous subsection has as elements ''all'' lists of natural numbers, of all lengths.  However, we can refine this type, replacing it with an infinite collection of types {L<sub>0</sub>, L<sub>1</sub>, L<sub>2</sub>, ...}, where for each natural number ''n'', the type L<sub>''n''</sub> consists of all natural number lists ''of length n''.  Thus L<sub>0</sub> has only the element <tt>nil</tt>; L<sub>1</sub> contains exactly the one-element lists <tt>cons 0 nil</tt>,&nbsp; <tt>cons (s 0) nil</tt>,&nbsp; <tt>cons (s (s 0)) nil</tt>,&nbsp; etc.; L<sub>2</sub> contains exactly the two-element lists, and so on, and the <tt>cons</tt> operator becomes an infinite family of operators {<tt>cons</tt><sub>0</sub> : <tt>nat</tt> &rarr; L<sub>0</sub> &rarr; L<sub>1</sub>, <tt>cons</tt><sub>1</sub> : <tt>nat</tt> &rarr; L<sub>1</sub> &rarr; L<sub>2</sub>, <tt>cons</tt><sub>2</sub> : <tt>nat</tt> &rarr; L<sub>2</sub> &rarr; L<sub>3</sub>, ...}.  This is how we could define each of these types and operations separately in Twelf:\n<twelf discard=\"true\">\nnat_list0 : type.   % L_0:  lists of length 0\nnat_list1 : type.   % L_1:  lists of length 1\nnat_list2 : type.   % L_2:  lists of length 2\nnat_list3 : type.   % L_3:  lists of length 3\n\nnil : nat_list0.\n\ncons0 : nat -> nat_list0 -> nat_list1.\ncons1 : nat -> nat_list1 -> nat_list2.\ncons2 : nat -> nat_list2 -> nat_list3.\n</twelf>\nNow, the list [0, 1, 2] would be represented as <tt>cons2 0 (cons1 (s 0) (cons0 (s (s 0)) nil))</tt>, and this term and its subterms would have types as follows:\n* <tt>cons2 0 (cons1 (s 0) (cons0 (s (s 0)) nil))</tt> : <tt>nat_list3</tt>,\n* <tt>cons1 (s 0) (cons0 (s (s 0)) nil)</tt> : <tt>nat_list2</tt>,\n* <tt>cons0 (s (s 0)) nil</tt> : <tt>nat_list1</tt>, and\n* <tt>nil</tt> : <tt>nat_list0</tt>.\nNow each natural number list and <tt>cons</tt> operator comes (via its type) with an explicit length.  This refinement of the type gives us extra information, but it can get very tedious, depending on how far we need to carry it out.  Moreover, however far out we go, we will still only have a finite number of types and operations (the signature being finite), so we will not have represented all possible natural number lists.\n\nThis is where type families come in.  The index we are using to refine the list type is a natural number, but we have already defined a natural number type in Twelf, so let's use it to define this entire infinite family of types in one go:\n<twelf discard=\"true\">\n% Natural number lists, indexed by length (a natural number)\nnat_list : nat -> type.                                        % subsumes nat_list0, nat_list1, nat_list2, ...\n\nnil : nat_list 0.\ncons : {N:nat} nat -> nat_list N -> nat_list (s N).            % subsumes cons0, cons1, cons2, ....\n</twelf>\nThus, we are representing the family {L<sub>0</sub>, L<sub>1</sub>, L<sub>2</sub>, ...} as a kind of function that takes a natural number ''n'' and gives the type L<sub>''n''</sub>.  We say that <tt>nat_list</tt> is a ''family'' of types, indexed by elements of <tt>nat</tt>.  Once this declaration is made, an infinite number of types come into existence, one for each element of <tt>nat</tt>:\n* <tt>nat_list 0</tt>,\n* <tt>nat_list (s 0)</tt>,\n* <tt>nat_list (s (s 0))</tt>,\nand so on.  Similarly, we are representing the family {<tt>cons</tt><sub>0</sub> : <tt>nat</tt> &rarr; L<sub>0</sub> &rarr; L<sub>1</sub>, <tt>cons</tt><sub>1</sub> : <tt>nat</tt> &rarr; L<sub>1</sub> &rarr; L<sub>2</sub>, <tt>cons</tt><sub>2</sub> : <tt>nat</tt> &rarr; L<sub>2</sub> &rarr; L<sub>3</sub>, ...} as a kind of function that takes a natural number ''n'' and gives the associated operation of type <tt>nat</tt> &rarr; L<sub>''n''</sub> &rarr; L<sub>''n''+1</sub>.  The prefix <tt>{N:nat}</tt> in the declaration for <tt>cons</tt> above can be thought of both as a universal quantifier and as an additional argument to <tt>cons</tt> on which the rest of its type depends.  Thus, this declaration can be read, \"for every element <tt>N</tt> of type <tt>nat</tt>, <tt>cons</tt> applied to <tt>N</tt> is an operator of type <tt>nat -> nat_list&nbsp;N -> nat_list&nbsp;(s&nbsp;N)</tt>.  In particular,\n* <tt>cons 0 : nat -> nat_list 0 -> nat_list (s 0)</tt>,\n* <tt>cons (s 0) : nat -> nat_list (s 0) -> nat_list (s (s 0))</tt>,\n* <tt>cons (s (s 0)) : nat -> nat_list (s (s 0)) -> nat_list (s (s (s 0)))</tt>,\nand so on.  Thus, just as <tt>nat_list</tt> is a ''type'' family indexed by elements of the type <tt>nat</tt>, so <tt>cons</tt> is a ''value'' family indexed by elements of type <tt>nat</tt>, with the type dependent on what natural-number index <tt>cons</tt> is applied to.  With these declarations, the list [0, 1, 2] would be represented as\n <tt>cons (s (s 0)) 0 (cons (s 0) (s 0) (cons 0 (s (s 0)) nil))</tt>.\n(Compare this to <tt>cons2 0 (cons1 (s 0) (cons0 (s (s 0)) nil))</tt> above.)  We have thus effectively \"internalized\" our previous \"external\" family of types and operators, and extended it to all natural numbers.\n\nLet's examine this universal quantification more closely.  The general form of a universally quantified type is <tt>{X:t} P(X)</tt>, where <tt>t</tt> is a type, called the index type, and <tt>P(X)</tt> is a type expression, called the body of the type, which has zero or more occurrences of the value variable <tt>X</tt>.  The actual variable used in the quantification is immaterial:  the type <tt>{X:t} P(X)</tt> is the same as the type <tt>{N:t} P(N)</tt>.  In the type of <tt>cons</tt> above, the type <tt>t</tt> is <tt>nat</tt>, the value variable is <tt>N</tt>, and the body is <tt>nat -> nat_list&nbsp;N -> nat_list&nbsp;(s&nbsp;N)</tt>.  Twelf only allows value variables in quantifications; it does not allow type variables or quantifications of the form <tt>{T:type}</tt>, which would require type variables.\n\nSo, what are the elements of the <tt>t</tt>-indexed type family <tt>{X:t} P(X)</tt>?  As suggested above, they are <tt>t</tt>-indexed ''value families'', where the value at a particular index <tt>v</tt> of the value family has the type that is at the same index <tt>v</tt> of the type family, namely <tt>P(v)</tt>.  Thus, they are functions <tt>f</tt> whose domain is <tt>t</tt> and are such that <tt>f v : P(v)</tt> for any value <tt>v:t</tt>, i.e., functions whose result type depends (uniformly) on which value they are given as input.\n\nNow, it may turn out that <tt>P(X)</tt> doesn't actually have any occurrences of <tt>X</tt>, in which case the body doesn't depend on the value of the index and is thus the same for all indices.  Let's call this common type <tt>p</tt>.  Then, elements of <tt>{X:t}&nbsp;P(X)</tt> are just functions from <tt>t</tt> to <tt>p</tt>, i.e., elements of the type <tt>t -> p</tt>.  This shows that universally quantified types subsume ordinary function types, and indeed, Twelf treats the function type <tt>A -> B</tt> as an abbreviation for the quantified type <tt>{X:A} B</tt>, where <tt>X</tt> is a value variable that doesn't occur in <tt>B</tt>.  Thus, the actual type of <tt>cons</tt> above is\n cons : {N:nat} {M:nat} {L:nat_list N} nat_list (s N),\nwhere the value variables <tt>M</tt> and <tt>L</tt> were chosen arbitrarily.\n\nJust like universal quantifiers, type families can be iterated.  For example, if we had a type declaration\n iter : {N:nat} nat_list N -> type.\nthen we could introduce types with prefixes such as <tt>{N:nat} {L:nat_list N} {I:iter N L}</tt> ....  It may not seem so now, but such deeply nested quantifier prefixes are quite common and useful, and it is not unusual for a type constructor to have a dozen or more quantifiers in its type.  As you might imagine, however, it can get very tedious to supply all of these arguments every time the constructor is used, especially since they can, in most instances, be inferred from the context.  Fortunately, Twelf has a mechanism by which these prefixes can be omitted from both the type declarations of the constructors and from the uses of the constructors in terms.  For example, we could have left out the quantifier in the definition of <tt>cons</tt>:\n<twelf>\n% Natural number lists, indexed by length (a natural number)\nnat_list : nat -> type.\n\nnil : nat_list 0.\ncons : nat -> nat_list N -> nat_list (s N).\n</twelf>\nNow, the value variable <tt>N</tt> in <tt>cons</tt> is ''free'' (i.e., not quantified), so Twelf automatically tries to infer the appropriate quantifier.  It can do so in this case, since <tt>N</tt> is being used as an argument to <tt>nat_list</tt>, which expects to be applied to a <tt>nat</tt>, so Twelf infers the quantifier <tt>{N:nat}</tt> for <tt>N</tt>.  Also, the second occurrence of <tt>N</tt> in the type is consistent, since the type of <tt>s</tt> is <tt>nat -> nat</tt>, so the type of <tt>s N</tt> is <tt>nat</tt>, which again is what <tt>nat_list</tt> expects.  With this abbreviated declaration, the list [0,1,2] would be represented by\n cons 0 (cons 1 (cons 2 nil)),\njust as it was before we refined <tt>nat_list</tt> into a type family indexed by length.  Twelf is automatically supplying the correct first arguments to each instance of <tt>cons</tt>, using the following reasoning.  The type of <tt>nil</tt> is <tt>nat_list 0</tt>, so the missing argument of <tt>cons</tt> in <tt>cons 2 nil</tt> must be <tt>0</tt>, the type of this expression being <tt>nat_list (s 0)</tt>.  But then the missing argument in the middle instance of <tt>cons</tt> has to be <tt>s 0</tt>, making the type of the expression <tt>cons 1 (cons 2 nil)</tt> be <tt>nat_list (s 0)</tt>.  Finally, that means that the missing argument in the first instance of <tt>cons</tt> has to be <tt>s (s 0)</tt>, and so the complete term can be reconstructed.  As we shall see, this kind of reconstruction is the rule, rather than the exception, and it makes working with Twelf much easier that it would without it.\n\n== Representing relations and functions ==\n\nA crucial feature of Twelf is that we can use it to represent not only data structures but also the logic we use to reason about them.  Ordinary predicate logic is built up from primitive predicates and relations using logical connectives such as \"and\", \"or\", and \"implies\", and quantifiers such as \"for all\" and \"there exists\".  In Twelf, we us a computational interpretation of logic based on the so-called \"Propositions as Types\" principle, meaning that we represent statements in our logic as types (or type families), and proofs of these statements as elements of the associated types.  This has two important consequences:  (1) the logic and reasoning methods we can use are somewhat restricted (technically, we are restricted to the &forall;&exist; fragment, and our reasoning must be ''Intuitionistic'' or ''constructive'', about which we will have more to say later), and (2) propositions, being types, are themselves data structures that can therefore be reasoned about in Twelf, allowing us to iterate the process of representation and reasoning to any desired level.\n\nA relation, R, among objects from sets A<sub>1</sub>, ..., A<sub>n</sub> is usually taken to be a subset of the cartesian product:  R ⊂ A<sub>1</sub> Χ ... Χ A<sub>n</sub>.  The elements of this cartesian product are tuples &lsaquo;a<sub>1</sub>, ..., a<sub>n</sub>&rsaquo;, where each a<sub>i</sub> is an element of A<sub>i</sub>.  The idea is that the subset R collects together all of the tuples that stand in the relation, thus providing a set-theoretic counterpart to the informal relation.  Unfortunately, the type theory underlying Twelf cannot directly represent general subsets, and, as we have noted above, it doesn't have products either.  But what we ''can'' do is, in some ways, even better: we represent the relation R between A<sub>1</sub>, ..., A<sub>n</sub> as a type family\n R : A<sub>1</sub> -> ... -> A<sub>n</sub> -> type.\nNow, for every tuple &lsaquo;a<sub>1</sub>, ..., a<sub>n</sub>&rsaquo;, there is a type <tt>R a<sub>1</sub> ... a<sub>n</sub></tt>, and we take this to be the type of ''evidence'' for the relationship between a<sub>1</sub>, ..., a<sub>n</sub> according to <tt>R</tt>.  If this type has at least one element (and in practice it will then have exactly one element), then, there being evidence for the relationship, we say that the elements a<sub>1</sub>, ..., a<sub>n</sub> are related by R.  On the other hand, if this type is empty, i.e., it has no elements, then the indicated relationship does not hold.  To repeat, a relation is represented as a type family, and each instance of the relation is not just true or false but a separate ''type'' whose elements represent ''evidence'' of its truth.  The absence of such evidence means that the particular instance does not hold.\n\nLet's look at some examples.  Recall the type <tt>day</tt> with elements <tt>sunday</tt>, <tt>monday</tt>, ..., <tt>saturday</tt>, and consider the \"next day\" relation that a relates a day with the following day.  Here is how we represent this relation in Twelf:\n<twelf>\n% Next-day relation on day\nnext_day : day -> day -> type.\n\nnext_day_sun : next_day sunday monday.\nnext_day_mon : next_day monday tuesday.\nnext_day_tue : next_day tuesday wednesday.\nnext_day_wed : next_day wednesday thursday.\nnext_day_thu : next_day thursday friday.\nnext_day_fri : next_day friday saturday.\nnext_day_sat : next_day saturday sunday.\n</twelf>\nThe <tt>next_day</tt> relation is a binary relation on <tt>day</tt> and is therefore represented as a type family doubly indexed by <tt>day</tt>.  The next seven declarations introduce elements that stand for the evidence that specific instances of the \"next day\" relation hold (their names were chosen to be mnemonic but could be any identifiers).  Thus, these seven pairs of days stand in the relation and no others do.\n\nGiven this relation, we can define another relation, called <tt>dat</tt> (\"day after tomorrow\"), that relates each day with the day two days later:\n\n<twelf discard=\"true\">\n% Day after tomorrow relation on day\ndat : day -> day -> type.\n\ndat_def : {D1:day}{D2:day}{D3:day} next_day D1 D2 -> next_day D2 D3 -> dat D1 D3.\n</twelf>\nLogically, the declaration of <tt>dat_def</tt> can be read, \"for all days <tt>D1</tt>, <tt>D2</tt>, and <tt>D3</tt>, if the day after <tt>D1</tt> is <tt>D2</tt>, and the day after <tt>D2</tt> is <tt>D3</tt>, then the day two days after <tt>D1</tt> is <tt>D3</tt>.\"  In terms of evidence, <tt>dat_def</tt> is a constructor that, given any days <tt>D1</tt>, <tt>D2</tt>, and <tt>D3</tt>, along with evidence for <tt>next_day D1 D2</tt> and <tt>next_day D2 D3</tt>, represents evidence for <tt>dat D1 D3</tt>.  For example, we have\n dat_def sunday monday tuesday next_day_sun next_day_mon : dat sunday tuesday.\nThat is, Tuesday is two days after Sunday, according to these definitions, because there exists evidence for <tt>dat sunday tuesday</tt>, namely the element to the left of the colon above; this element is well-typed, since <tt>dat_def</tt> is being applied correctly to five arguments, with\n* <tt>sunday : day</tt> (so that <tt>D1</tt> is instantiated to <tt>sunday</tt>),\n* <tt>monday : day</tt> (so that <tt>D2</tt> is instantiated to <tt>monday</tt>),\n* <tt>tuesday : day</tt> (so that <tt>D3</tt> is istantiated to <tt>tuesday</tt>),\n* <tt>next_day_sun : next_day sunday monday</tt> (i.e., <tt>next_day D1 D2</tt>), and\n* <tt>next_day_mon : next_day monday tuesday</tt> (i.e., <tt>next_day D2 D3</tt>),\nthe whole term thus having type <tt>dat sunday tuesday</tt> (i.e., <tt>dat D1 D3</tt>).  In this way, the only pairs of days in the <tt>dat</tt> relation are those pairs where the second day is two days after the first.\n\nJust as we observed at the end of the previous section, the three quantifiers in the declaration of <tt>dat_def</tt> above can be omitted:\n<twelf>\n% Day after tomorrow relation on day\ndat : day -> day -> type.\n\ndat_def : next_day D1 D2 -> next_day D2 D3 -> dat D1 D3.\n</twelf>\nBecause the declarations of <tt>next_day</tt> and <tt>dat</tt> show that both constructors expect to be applied to two arguments of type <tt>day</tt>, Twelf can reconstruct the quantifiers for <tt>D1</tt>, <tt>D2</tt>, and <tt>D3</tt> automatically.  Furthermore, we can define the identifier <tt>dat_sunday</tt> to stand for the evidence that Tuesday is two days after Sunday as follows:\n<twelf>\ndat_sunday = dat_def next_day_sun next_day_mon : dat sunday tuesday.\n</twelf>\nwhere the first three arguments of <tt>dat_def</tt> corresponding to the omitted quantifiers can be reconstructed from the types of <tt>next_day_sun</tt> and <tt>next_day_mon</tt>.  From this point on, we will engage in the standard practice in Twelf of omitting quantifiers whenever possible, relying on term reconstruction to supply them automatically.\n\nFinally, a word about '''functions'''.  Although we've encoded <tt>next_day</tt> and <tt>dat</tt> as relations, they are in fact (the graphs of) functions.  That is, there exist functions ''f'' and ''g'' such that for all elements ''d''<sub>1</sub> and ''d''<sub>2</sub> of type <tt>day</tt>, ''f''(''d''<sub>1</sub>) = ''d''<sub>2</sub> if and only if <tt>next_day </tt>''d''<sub>1</sub> ''d''<sub>2</sub>, and ''g''(''d''<sub>1</sub>) = ''d''<sub>2</sub> if and only if <tt>dat </tt>''d''<sub>1</sub> ''d''<sub>2</sub>.  Relations that arise from functions in this way are special; we call them ''functional''.  To make this more precise, let's take <tt>next_day</tt> as an example.  If we designate the first argument of <tt>next_day</tt> as an ''input'' argument and the second argument as an ''output'' argument, then this relation has the property that, for any possible combination of input arguments, there is exactly one combination of output arguments for which the relation holds, i.e., the associated type is non-empty&mdash;or, as we say in a more positive way, ''inhabited''.  The same is true if we designate the first argument of <tt>dat</tt> as input and its second argument as output.  In fact, the same is true if we designate the second arguments of <tt>next_day</tt> and <tt>dat</tt> as inputs and their first arguments as outputs.  These latter designations would correspond to the inverse functions \"previous day\" and \"two days ago\".  We will see in a later section how we can designate certain arguments of relations as inputs and outputs and have Twelf verify that the relations are functional according to these designations.\n\nHere is a link to a <twelflink>file containing the Twelf declarations</twelflink> given so far, where, in the case of <tt>cons</tt> and <tt>dat_def</tt>, we have chosen the versions that omitted the quantifiers.  Let's look at <twelflink check=\"true\">Twelf's output</twelflink> for these declarations.  As Twelf checks each declaration for type-correctness, it echoes the declaration in its output, including any reconstructed quantifiers, as you can see in the declarations of <tt>cons</tt> and <tt>dat_def</tt>.  Notice that a couple of identifiers (<tt>nil</tt> and <tt>cons</tt>) were declared more than once; in this case, Twelf remembers only the last declaration for each identifier, silently replacing any previous declarations."
          },
          "sha1": "5h5ycp7z9ml33h5bqpcugft6apstu9z"
        }
      },
      {
        "title": "Fixity declaration",
        "ns": 0,
        "id": 1654,
        "revision": {
          "id": 5456,
          "parentid": 3345,
          "timestamp": "2008-11-17T23:21:17Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 774,
            "#text": "The '''<tt>%infix</tt>''', '''<tt>%prefix</tt>''' and '''<tt>%postfix</tt>''' declarations assign '''fixity''' and precedence to constants for the purpose of parsing (they have no meaning in the logic). \n\n{{needs|a description of the syntax}}\n\n'''''Higher''''' numbers bind '''''tighter,''''' and the pretty printer only prints out necessary information. Hence the following example:\n<twelf>\na : type.\nb : a.\nc : a.\nd : a.\n\n+ : a -> a -> a. %infix left 1 +.\n* : a -> a -> a. %infix left 2 *.\n</twelf>\n<twelf check=decl>\nx : a = (b + c) * d. %% The parenthesis are necessary here\ny : a = b + (c * d). %% This means the same thing as b + c * d.\n</twelf>\n\n\n== See also ==\n* {{guide|chapter=3|section=11|title=Operator Declaration}}\n\n{{keyword|key=Fixity declaration}}\n\n{{stub}}"
          },
          "sha1": "22di3vskicivczrtmd3tocy2wfdla30"
        }
      },
      {
        "title": "Focusing",
        "ns": 0,
        "id": 2047,
        "revision": {
          "id": 7983,
          "parentid": 7978,
          "timestamp": "2014-01-22T19:16:09Z",
          "contributor": {
            "ip": "199.108.69.249"
          },
          "comment": "Fix the failure of adequacy pointed out by Fabien Renaud by adding a side condition to ^L",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 50372,
            "#text": "%{ Focusing for polarized logic and focalization (the completeness of focusing). This proof has been de-unicoded by a sed [https://github.com/robsimmons/agda-lib/blob/lambdatown/sedforwiki script],\nthe original is [https://github.com/robsimmons/agda-lib/blob/lambdatown/Polar.elf here]. \n| hidden=true }%\n\nsmall: type. \nbig: type.\ns: small.\nb: small -> big.\n\n%{ == Syntax == }%\n\npol: type. %name pol P.\n+: pol.\n-: pol.\n\n%{ We define propositions in an environment with free atoms. }%\natom: pol -> type. %name atom Q q.\n%block atom+: block {Q+: atom +}.\n%block atom-: block {Q-: atom -}.\n\ntyp: pol -> type. %name typ A.\nc: atom P -> typ P.\n\ndn: typ - -> typ +.\nbot: typ +.\n\\/: typ + -> typ + -> typ +. %infix none 5 \\/.\ntop+: typ +.\n*: typ + -> typ + -> typ +. %infix none 5 *.\n\nup: typ + -> typ -.\n=>: typ + -> typ - -> typ -. %infix none 5 =>.\ntop-: typ -.\n/\\: typ - -> typ - -> typ -. %infix none 5 /\\.\n\n%{ Succedents are things that come to the right of the turnstile. }%\nsuc: type. %name suc Suc jmt.\ninv: typ - -> suc. %postfix 3 inv.\ntrue: typ + -> suc. %postfix 3 true.\nsusp: typ - -> suc. %postfix 3 susp. \n\n%{ Right-stable judgments are ones that are either positive or suspended. }%\nstable: suc -> type. %name stable St.\nsp: stable (A+ true).\nsn: stable (A- susp).\n\n%{ An inversion context <tt><nowiki>Inv</nowiki></tt> is a list of positive propositions. }%\npos: type. %name pos Inv.\n#: pos.\n,: typ + -> pos -> pos. %infix right 3 ,.\n\n\n%{ == Sequent calculus == }%\n\nseqform: type. %name seqform Form.\nexp: seqform -> type. %name exp E z.\n\nrfoc: typ + -> seqform. \n%abbrev value: typ + -> type = [A+] exp (rfoc A+).\n\nleftform: type.\nhasleft: leftform -> suc -> seqform.\n\nininv: pos -> leftform.\n%abbrev term: pos -> suc -> type = [Inv][U] exp (hasleft (ininv Inv) U).\n\ninfoc: typ - -> leftform.\n%abbrev spine: typ - -> suc -> type = [A-][U] exp (hasleft (infoc A-) U).\n\nhyp: typ - -> type. %name hyp X x.\n%block nprop : some {A-: typ -} block {x: hyp A-}.\n%block aprop : some {Q+: atom +} block {z: value (c Q+)}.\n%block pprop : some {A+: typ +} block {z: value A+}.\n%worlds (atom+ | atom- | nprop) (hyp _).\n\n%block gamma_suspnormal = (atom+ | atom- | nprop | aprop). % World for cut\n%block gamma = (atom+ | atom- | nprop | pprop).            % World for identity\n\nsuspnormal: suc -> type.\nsnn: suspnormal (A- inv).\nsnp: suspnormal (A+ true).\nsna: suspnormal ((c Q-) susp).\n\nsuspstable: suc -> type.\nss: stable U -> suspnormal U -> suspstable U.\n\nsuspnormalF: seqform -> type.\nsnr: suspnormalF (rfoc A+).\nsnl: suspnormalF (hasleft _ U) <- suspnormal U. \n\n%{ ==== Values ==== }%\n\n%{\n<tt><nowiki>V ::= z | thunk N | inl V | inr V | ⟨⟩+ | ⟨V1,V2⟩+</nowiki></tt> \n\nThe rule <tt><nowiki>id+</nowiki></tt> corresponding to the proof term <tt><nowiki>z</nowiki></tt> comes for free\nfrom LF.  \n}%\n\ndnR: term # (A- inv) -> value (dn A-).\n\\/R1: value A+ -> value (A+ \\/ B+).\n\\/R2: value B+ -> value (A+ \\/ B+).\ntop+R: value top+.\n*R: value A+ -> value B+ -> value (A+ * B+).\n\n%{ ==== Terms ==== }%\n\n%{ \n<tt><nowiki>M ::= ret V | x &bull; Sp | ⟨z⟩.N | x.N | abort | [N1, N2] | ⟨⟩.N | ×N | ⟨N⟩ | {N} | &lambda;N | ⟨⟩- | ⟨N1,N2⟩-</nowiki></tt> \n}%\n\nfocR: value A+ -> term # (A+ true).\nfocL: stable Suc -> hyp A- -> spine A- Suc -> term # Suc.\n&eta;+: (value (c Q+) -> term Inv Suc) -> term (c Q+ , Inv) Suc.\ndnL: (hyp A- -> term Inv Suc) -> term (dn A- , Inv) Suc.\nbotL: term (bot , Inv) Suc.\n\\/L: term (A+ , Inv) Suc -> term (B+ , Inv) Suc -> term (A+ \\/ B+ , Inv) Suc.\ntop+L: term Inv Suc -> term (top+ , Inv) Suc.\n*L: term (A+ , B+ , Inv) Suc -> term (A+ * B+ , Inv) Suc.\n&eta;-: term # ((c Q-) susp) -> term # ((c Q-) inv).\nupR: term # (A+ true) -> term # (up A+ inv).\n=>R: term (A+ , #) (B- inv) -> term # (A+ => B- inv).\ntop-R: term # (top- inv).\n/\\R: term # (A- inv) -> term # (B- inv) -> term # (A- /\\ B- inv).\n\n%{ ==== Spines ==== }%\n\n%{ \n<tt><nowiki>Sp ::= nil | pm N | V;Sp | &pi;1;Sp | &pi;2;Sp</nowiki></tt> \n}%\n\nid-: spine A- (A- susp).\nupL: stable Suc -> term (A+ , #) Suc -> spine (up A+) Suc.\n=>L: value A+ -> spine B- Suc -> spine (A+ => B-) Suc.\n/\\L1: spine A- Suc -> spine (A- /\\ B-) Suc.\n/\\L2: spine B- Suc -> spine (A- /\\ B-) Suc.\n\n%{ ==== Negative focal substitution ==== }%\n\n%{ Our encoding gives us positive focal substitution for free - it's\nvery natural to describe suspended propsitions <tt><nowiki>⟨A+⟩</nowiki></tt> in the\nhypothetical context as variables of type <tt><nowiki>rfoc A+</nowiki></tt>, which is\nadequate and gives us the <tt><nowiki>id+</nowiki></tt> rule for free. By chosing a more\ntraditional way of describing negative suspended propositions (instead\nof the complicated encoding that gives us <tt><nowiki>id-</nowiki></tt> for free), we have\nforced ourselves to prove a theorem, negative focal substitution, that\nwe could have avoided. The partial \"NoNil\" development avoids proving\nsubst-. }%\n\nsubst-: stable U \n  -> exp (hasleft L (A- susp)) \n  -> spine A- U\n  -> exp (hasleft L U) \n  -> type.\n%mode subst- +Pf +E +Sp -Sp'.\n\n/: subst- Pf (focL _ X Sp0) Sp (focL Pf X Sp0')\n    <- subst- Pf Sp0 Sp Sp0'. \n/: subst- Pf (&eta;+ [z] N z) Sp (&eta;+ [z] N' z)\n    <- {z} subst- Pf (N z) Sp (N' z).\n/: subst- Pf (dnL [x] N x) Sp (dnL [x] N' x)\n    <- {x} subst- Pf (N x) Sp (N' x).\n/: subst- Pf botL Sp botL.\n/: subst- Pf (\\/L N1 N2) Sp (\\/L N1' N2')\n    <- subst- Pf N1 Sp N1'\n    <- subst- Pf N2 Sp N2'.\n/: subst- Pf (top+L N) Sp (top+L N')\n    <- subst- Pf N Sp N'.\n/: subst- Pf (*L N) Sp (*L N')\n    <- subst- Pf N Sp N'.\n\n/: subst- Pf id- Sp Sp.\n/: subst- Pf (upL _ N) Sp (upL Pf N')\n    <- subst- Pf N Sp N'.\n/: subst- Pf (=>L V Sp0) Sp (=>L V Sp0')\n    <- subst- Pf Sp0 Sp Sp0'.\n/: subst- Pf (/\\L1 Sp0) Sp (/\\L1 Sp0')\n    <- subst- Pf Sp0 Sp Sp0'.\n/: subst- Pf (/\\L2 Sp0) Sp (/\\L2 Sp0')\n    <- subst- Pf Sp0 Sp Sp0'.\n\n%worlds (gamma) (subst- _ _ _ _).\n%total E (subst- _ E _ _).\n\n\n%{ == Cut admissibility == }%\n\n%{ Cut admissibility has a couple of mutually inductive theorems, but\nno more than is absolutely necessary given the syntactic classes we're\ndealing with. Furthermore, the different theorems we use neatly sort\nout the informal division of cases that we are used to dealing with\nwhen proving cut admissibility theorems. The \"principal\" substitutions\ncapture the principal cuts:\n\n* <tt><nowiki>V &bull; Ni</nowiki></tt> - positive cut formula, and\n* <tt><nowiki>N &bull; Sp</nowiki></tt> - negative cut formula. }%\n\ncut+: {A+} small \n  -> suspnormal U\n  -> value A+ \n  -> term (A+ , Inv) U\n  -> term Inv U\n  -> type.\n\ncut-: {A-} small\n  -> suspstable U\n  -> term # (A- inv)\n  -> spine A- U\n  -> term # U\n  -> type.\n\n%mode cut+ +A +S +Pf +V +N -N'.\n%mode cut- +A +S +Pf +N +Sp -N'.\n\n%{ The \"rightist\" substitution <tt><nowiki>[[N/x]]E</nowiki></tt> captures all right\ncommutative cuts. Each inductive call within this group decreases the\nsize of the expression E that we are substituting into. }%\n\nrsubst:  {A-} big\n  -> suspnormalF Form\n  -> term # (A- inv) \n  -> (hyp A- -> exp Form)\n  -> exp Form \n  -> type.\n\n%mode rsubst  +A +S +Pf +N +E -E'.\n\n%{ The \"leftist\" substitution <tt><nowiki><<E>>N</nowiki></tt> captures all left commutative\ncuts.  Each inductive call within this group decreases the size of the\nexpression E that we are substituting in, hence \"leftist.\" }%\n\nlsubst: {A+} big \n  -> suspstable U\n  -> exp (hasleft L (A+ true))\n  -> term (A+ , #) U\n  -> exp (hasleft L U) \n  -> type.\n\n%mode lsubst +A +S +Pf +E +N -E'.\n\n%{ ==== Principal substitution/cuts ==== }%\n\n%{ <tt><nowiki>(V &bull; N) = N' </nowiki></tt> }%\n\n/: cut+ (c Q+) S _ X (&eta;+ [z] N z) (N X).\n\n/: cut+ (dn A-) s Pf (dnR M) (dnL N) N'\n  <- rsubst A- (b s) (snl Pf) M N (N': term Inv U).\n\n/: cut+ (A+ \\/ B+) S Pf (\\/R1 V) (\\/L N1 N2) N'\n  <- cut+ A+ S Pf V N1 (N': term Inv U).\n\n/: cut+ (A+ \\/ B+) S Pf (\\/R2 V) (\\/L N1 N2) N'\n  <- cut+ B+ S Pf V N2 (N': term Inv U).\n\n/: cut+ top+ S Pf top+R (top+L N) N.\n\n/: cut+ (A+ * B+) S Pf (*R V1 V2) (*L N) N'\n  <- cut+ A+ S Pf V1 N (NB: term (B+ , Inv) U)\n  <- cut+ B+ S Pf V2 NB (N': term Inv U).\n\n%{ <tt><nowiki>(M &bull; Sp) = N' </nowiki></tt> }%\n\n/: cut- (c Q-) S Pf (&eta;- N) id- N.\n\n/: cut- (up A+) s Pf (upR N) (upL _ M) N'\n    <- lsubst A+ (b s) Pf N M N'.\n\n/: cut- (A+ => B-) S (ss Pf1 Pf2) (=>R N) (=>L V Sp) N'\n  <- cut+ A+ S snn V N (NB: term # (B- inv))\n  <- cut- B- S (ss Pf1 Pf2) NB Sp (N': term # U).\n\n/: cut- (A- /\\ B-) S Pf (/\\R N1 N2) (/\\L1 Sp) N'\n  <- cut- A- S Pf N1 Sp (N': term # U).\n\n/: cut- (A- /\\ B-) S Pf (/\\R N1 N2) (/\\L2 Sp) N'\n  <- cut- B- S Pf N2 Sp (N': term # U).\n\n%{ ==== Rightist substitution (right commutative cuts) ==== }%\n\n%{ <tt><nowiki>[[M/x]]V = V' </nowiki></tt> }%\n\n/: rsubst A- S snr M ([x] V) (V: value (c Q+)).\n\n/: rsubst A- S snr M ([x] dnR (N x)) (dnR N')\n  <- rsubst A- S (snl snn) M ([x] N x) (N': term # (C- inv)).\n\n/: rsubst A- S snr M ([x] \\/R1 (V x)) (\\/R1 V')\n  <- rsubst A- S snr M ([x] V x) (V': value C1+).\n\n/: rsubst A- S snr M ([x] \\/R2 (V x)) (\\/R2 V')\n  <- rsubst A- S snr M ([x] V x) (V': value C2+).\n\n/: rsubst A- S snr M ([x] top+R) top+R.\n\n/: rsubst A- S snr M ([x] *R (V1 x) (V2 x)) (*R V1' V2')\n  <- rsubst A- S snr M ([x] V1 x) (V1': value C1+)\n  <- rsubst A- S snr M ([x] V2 x) (V2': value C2+).\n\n%{ <tt><nowiki>[[M/x]]N = N' </nowiki></tt> }%\n\n% Entering principal substitution (cut-)\n/: rsubst A- (b s) (snl Pf) M ([x] focR (V x)) (focR V')\n  <- rsubst A- (b s) snr M ([x] V x) V'.\n\n/: rsubst A- (b s) (snl Pf) M ([x] focL Pf' x (Sp x)) N'\n  <- rsubst A- (b s) (snl Pf) M ([x] Sp x) (Sp': spine A- U)\n  <- cut- A- s (ss Pf' Pf) M Sp' (N': term # U).\n\n/: rsubst A- S (snl Pf) M ([x] focL Pf' X' (Sp x)) (focL Pf' X' Sp')\n  <- rsubst A- S (snl Pf) M ([x] Sp x) (Sp': spine B- U).\n\n/: rsubst A- S (snl Pf) M ([x] &eta;+ [z] N x z) (&eta;+ [z] N' z)\n  <- ({z: value (c Q+)} rsubst A- S (snl Pf) M ([x] N x z) (N' z: term Inv U)).\n\n/: rsubst A- S (snl Pf) M ([x] dnL [x'] N x x') (dnL [x'] N' x')\n  <- ({x': hyp B-} rsubst A- S (snl Pf) M ([x] N x x') (N' x': term Inv U)).\n\n/: rsubst A- S (snl Pf) M ([x] botL) botL.\n\n/: rsubst A- S (snl Pf) M ([x] \\/L (N1 x) (N2 x)) (\\/L N1' N2')\n  <- rsubst A- S (snl Pf) M ([x] N1 x) (N1': term (B1 , Inv) U)\n  <- rsubst A- S (snl Pf) M ([x] N2 x) (N2': term (B2 , Inv) U).\n\n/: rsubst A- S (snl Pf) M ([x] top+L (N x)) (top+L N')\n  <- rsubst A- S (snl Pf) M ([x] N x) (N': term Inv U).\n\n/: rsubst A- S (snl Pf) M ([x] *L (N x)) (*L N')\n  <- rsubst A- S (snl Pf) M ([x] N x) (N': term (A+ , B+ , Inv) U).\n\n/: rsubst A- S (snl snn) M ([x] &eta;- (N x)) (&eta;- N')\n  <- rsubst A- S (snl sna) M ([x] N x) (N': term # ((c Q-) susp)).\n\n/: rsubst A- S (snl snn) M ([x] upR (N x)) (upR N')\n  <- rsubst A- S (snl snp) M ([x] N x) (N': term # (C+ true)).\n\n/: rsubst A- S (snl snn) M ([x] =>R (N x)) (=>R N')\n  <- rsubst A- S (snl snn) M ([x] N x) (N': term (C1+ , #) (C2- inv)).\n\n/: rsubst A- S (snl snn) M ([x] top-R) top-R.\n\n/: rsubst A- S (snl snn) M ([x] /\\R (N1 x) (N2 x)) (/\\R N1' N2')\n  <- rsubst A- S (snl snn) M ([x] N1 x) (N1': term # (C1- inv))\n  <- rsubst A- S (snl snn) M ([x] N2 x) (N2': term # (C2- inv)).\n\n%{ <tt><nowiki>[[M/x]]Sp = Sp' </nowiki></tt> }%\n\n/: rsubst A- S (snl sna) M ([x] id-) id-.\n\n/: rsubst A- S (snl Pf) M ([x] upL Pf' (N x)) (upL Pf' N')\n  <- rsubst A- S (snl Pf) M ([x] N x) (N': term (B+ , #) U).\n\n/: rsubst A- S (snl Pf) M ([x] =>L (V x) (Sp x)) (=>L V' Sp')\n  <- rsubst A- S snr M ([x] V x) (V': value B1+)\n  <- rsubst A- S (snl Pf) M ([x] Sp x) (Sp': spine B2- U).\n\n/: rsubst A- S (snl Pf) M ([x] /\\L1 (Sp x)) (/\\L1 Sp')\n  <- rsubst A- S (snl Pf) M ([x] Sp x) (Sp': spine B1- U).\n\n/: rsubst A- S (snl Pf) M ([x] /\\L2 (Sp x)) (/\\L2 Sp')\n  <- rsubst A- S (snl Pf) M ([x] Sp x) (Sp': spine B2- U).\n\n%{ ==== Leftist substitution (left commutative cuts) ==== }%\n\n%{ <tt><nowiki><<M>>N = M' </nowiki></tt> }%\n\n% Entering principal substitution (cut+)\n/: lsubst A+ (b s) (ss Pf Pf') (focR V) N N'\n  <- cut+ A+ s Pf' V N N'.\n\n/: lsubst A+ S (ss Pf Pf') (focL _ X Sp) N (focL Pf X Sp')\n  <- lsubst A+ S (ss Pf Pf') Sp N (Sp': spine B- U).\n\n/: lsubst A+ S Pf (&eta;+ [z] M z) N (&eta;+ [z] M' z)\n  <- ({z: value (c Q+)} lsubst A+ S Pf (M z) N (M' z: term Inv U)).\n\n/: lsubst A+ S (ss Pf Pf') (dnL [x'] M x') N (dnL [x'] M' x')\n  <- ({x': hyp B-} lsubst A+ S (ss Pf Pf') (M x') N (M' x': term Inv U)).\n\n/: lsubst A+ S Pf botL N botL.\n\n/: lsubst A+ S Pf (\\/L M1 M2) N (\\/L M1' M2')\n  <- lsubst A+ S Pf M1 N (M1': term (B1+ , Inv) U)\n  <- lsubst A+ S Pf M2 N (M2': term (B2+ , Inv) U).\n\n/: lsubst A+ S Pf (top+L M) N (top+L M')\n  <- lsubst A+ S Pf M N (M': term Inv U).\n\n/: lsubst A+ S Pf (*L M) N (*L M')\n  <- lsubst A+ S Pf M N (M': term (B1+ , B2+ , Inv) U).\n\n%{ <tt><nowiki><<Sp>>N = Sp' </nowiki></tt> }%\n\n/: lsubst A+ S (ss Pf Pf') (upL _ M) N (upL Pf M')\n  <- lsubst A+ S (ss Pf Pf') M N (M': term (B+ , #) U).\n\n/: lsubst A+ S Pf (=>L V Sp) N (=>L V Sp')\n  <- lsubst A+ S Pf Sp N (Sp': spine B2- U).\n\n/: lsubst A+ S Pf (/\\L1 Sp) N (/\\L1 Sp')\n  <- lsubst A+ S Pf Sp N (Sp': spine B1- U).\n\n/: lsubst A+ S Pf (/\\L2 Sp) N (/\\L2 Sp')\n  <- lsubst A+ S Pf Sp N (Sp': spine B2- U).\n\n%{ ==== Wrap-up ==== }%\n\n%worlds (gamma_suspnormal)\n  (cut+ _ _ _ _ _ _)\n  (cut- _ _ _ _ _ _)\n  (rsubst _ _ _ _ _ _ )\n  (lsubst _ _ _ _ _ _).\n\n%{ With the exception of the \"big/small\" metric that allows the\nleftist and rightist substitutions to call principal substitutions at\nthe same type, this is the usual induction metric for structrual cut\nelimination arguments. }%\n\n%total \n  {(A1 A2 A3 A4) \n   {(S1 S2 S3 S4)\n    [(V N- MR EL) \n     (N+ S ER NL)]}}\n  (cut+   A1 S1 _ V  N+ _)\n  (cut-   A2 S2 _ N- S  _)\n  (rsubst A3 S3 _ MR ER _)\n  (lsubst A4 S4 _ EL NL _).\n\n%{ The following simpler induction metric also works, emphasizing that\nthe \"derivation\" metric matters not at all in the principal cases,\nthat the rightist substitutions are structurally inductive over the\nsecond given derivation (the \"right\" derivation) and that the leftist\nsubstitutions are structurally inductive over the first given\nderivation (the \"left\" derivation). }%\n\n%total \n  {(A1 A2 A3 A4) \n   {(S1 S2 S3 S4)\n     (S1 S2 ER EL)}}\n  (cut-   A1 S1 _ _  _  _)\n  (cut+   A2 S2 _ _  _  _)\n  (rsubst A3 S3 _ _  ER _)\n  (lsubst A4 S4 _ EL _  _).\n\n%{ == Expansion == }%\n\nexpand+: {A+} (value A+ -> term Inv U) -> term (A+ , Inv) U -> type.\nexpand-: {A-} term # (A- susp) -> term # (A- inv) -> type.\n\n%mode expand+ +A+ +N -Ni.\n%mode expand- +A- +Sp -N.\n\n%{ <tt><nowiki>&eta;(z.N) = N' </nowiki></tt> }%\n\n/: expand+ (c Q+) ([z: value (c Q+)] N z) (&eta;+ [z: value (c Q+)] N z).\n\n/: expand+ (dn A-) ([z: value (dn A-)] N z) (dnL [x: hyp A-] N (dnR (N' x)))\n  <- ({x: hyp A-} expand- A- (focL sn x id-) (N' x: term # (A- inv))).\n\n/: expand+ bot ([z: value bot] N z) botL.\n\n/: expand+ (A+ \\/ B+) ([z: value (A+ \\/ B+)] N z) (\\/L N1 N2)\n  <- expand+ A+ ([z1: value A+] N (\\/R1 z1)) (N1: term (A+ , Inv) U)\n  <- expand+ B+ ([z2: value B+] N (\\/R2 z2)) (N2: term (B+ , Inv) U).\n\n/: expand+ top+ ([z: value top+] N z) (top+L (N top+R)).\n\n/: expand+ (A+ * B+) ([z: value (A+ * B+)] N z) (*L N2)\n  <- ({z1: value A+} \n       expand+ B+ ([z2: value B+] N (*R z1 z2)) (N1 z1: term (B+ , Inv) U))\n  <- expand+ A+ ([z1: value A+] N1 z1) (N2: term (A+ , B+ , Inv) U).\n\n%{ <tt><nowiki>&eta;(s.N) = N' </nowiki></tt> }%\n\n/: expand- (c Q-) N (&eta;- N). \n\n/: expand- (up A+) N (upR N</nowiki></tt>)\n  <- expand+ A+ ([z: value A+] focR z) (N': term (A+ , #) (A+ true))\n  <- subst- sp N (upL sp N') (N</nowiki></tt>: term # (A+ true)).\n\n/: expand- (A+ => B-) N (=>R N3)\n  <- ({z: value A+} subst- sn N (=>L z id-) (N1 z: term # (B- susp)))\n  <- ({z: value A+} expand- B- (N1 z) (N2 z: term # (B- inv)))\n  <- expand+ A+ N2 (N3: term (A+ , #) (B- inv)).\n\n/: expand- top- N top-R.\n\n/: expand- (A- /\\ B-) N (/\\R N1' N2')\n  <- subst- sn N (/\\L1 id-) (N1: term # (A- susp))\n  <- expand- A- N1 (N1': term # (A- inv))\n  <- subst- sn N (/\\L2 id-) (N2: term # (B- susp))\n  <- expand- B- N2 (N2': term # (B- inv)).\n\n%worlds (gamma) (expand+ _ _ _) (expand- _ _ _).\n%total (A+ A-) (expand+ A+ _ _) (expand- A- _ _).\n\n%{ Identity is a corollary, though we'll only use it at the very end\nwhen we prove the identity principle for the unfocused sequent\ncalculus: }%\n\nidentity-: (hyp A- -> term # (A- inv)) -> type.\n%mode +{A-} -{N: hyp A- -> term # (A- inv)} identity- N.\n\n/: identity- N\n  <- ({x: hyp A-} expand- A- (focL sn x id-) (N x: term # (A- inv))).\n\n%worlds (gamma) (identity- _).\n%total [] (identity- _).       \n\nidentity+: term (A+ , #) (A+ true) -> type.\n%mode +{A+} -{N: term (A+ , #) (A+ true)} identity+ N.\n\n/: identity+ N\n  <- expand+ A+ ([z: value A+] focR z) (N: term (A+ , #) (A+ true)).\n\n%worlds (gamma) (identity+ _).\n%total [] (identity+ _).       \n\n\n%{ == Unfocused admissibility == }%\n\n%{ The key lemmas for establishing the completeness of the focused\nsequent calculus are the \"unfocused admissibility\" lemmas, which\nestablish that the normal rules of the sequent calculus are usable in\nthe context of the focused calculus.\n\nThese lemmas are all provable by use of the cut and identity\nprinciples; while the proofs are hardly straightforward, they share \na certain high-level structure. }%\n\n%{ ==== Initial rules ==== }%\n\nadm-initsusp-: (hyp (c Q) -> term # (c Q susp)) -> type.\n%mode +{Q} -{N: hyp (c Q) -> term # (c Q susp)} adm-initsusp- N.\n\n/: adm-initsusp- ([x: hyp (c Q)] focL sn x id-).\n\n%worlds (gamma_suspnormal) (adm-initsusp- _).\n%total [] (adm-initsusp- _).\n\nadm-init-: (hyp (c Q) -> term # (dn (c Q) true)) -> type.\n%mode +{Q} -{N: hyp (c Q) -> term # (dn (c Q) true)} adm-init- N. \n\n/: adm-init- ([x: hyp (c Q)] focR (dnR (&eta;- (focL sn x id-)))).\n\n%worlds (gamma_suspnormal) (adm-init- _).\n%total [] (adm-init- _).\n\nadm-initsusp+: (value (c Q) -> term # (c Q true)) -> type.\n%mode +{Q} -{N: value (c Q) -> term # (c Q true)} adm-initsusp+ N.\n\n/: adm-initsusp+ ([z: value (c Q)] focR z).\n\n%worlds (gamma_suspnormal) (adm-initsusp+ _).\n%total [] (adm-initsusp+ _).\n\nadm-init+: (hyp (up (c Q)) -> term # (c Q true)) -> type.\n%mode +{Q} -{N: hyp (up (c Q)) -> term # (c Q true)} adm-init+ N. \n\n/: adm-init+ ([x: hyp (up (c Q))] focL sp x (upL sp (&eta;+ [z] focR z))).\n\n%worlds (gamma_suspnormal) (adm-init+ _).\n%total [] (adm-init+ _).\n\n%{ ==== Disjunction ==== }%\n\nadm-botL: stable U -> (hyp (up bot) -> term # U) -> type.\n%mode adm-botL +Pf -N'.\n\n/: adm-botL Pf ([x: hyp (up bot)] focL Pf x (upL Pf botL)).\n\n%worlds (gamma_suspnormal) (adm-botL _ _).\n%total [] (adm-botL _ _).\n\nadm-\\/R1: term # (A+ true)\n       -> term # ((A+ \\/ B+) true)\n       -> type.\n%mode +{A+} +{B+} +{N1} -{N': term # ((A+ \\/ B+) true)} adm-\\/R1 N1 N'.\n\n/: adm-\\/R1 (N1: term # (A+ true)) N'\n  <- expand+ A+ ([z: value A+] focR (\\/R1 z))\n       (NId1: term (A+ , #) ((A+ \\/ B+) true))\n  <- lsubst A+ (b s) (ss sp snp) N1 NId1 (N': term # ((A+ \\/ B+) true)).\n\n%worlds (gamma_suspnormal) (adm-\\/R1 _ _).\n%total [] (adm-\\/R1 _ _).\n\nadm-\\/R2: term # (B+ true)\n       -> term # (A+ \\/ B+ true)\n       -> type.\n%mode +{A+} +{B+} +{N2} -{N': term # ((A+ \\/ B+) true)} adm-\\/R2 N2 N'.\n\n/: adm-\\/R2 (N2: term # (B+ true)) N'\n  <- expand+ B+ ([z: value B+] focR (\\/R2 z))\n       (NId2: term (B+ , #) ((A+ \\/ B+) true))\n  <- lsubst B+ (b s) (ss sp snp) N2 NId2 (N': term # ((A+ \\/ B+) true)).\n\n%worlds (gamma_suspnormal) (adm-\\/R2 _ _).\n%total [] (adm-\\/R2 _ _).\n\nadm-\\/L: suspstable U\n      -> (hyp (up A+) -> term # U)\n      -> (hyp (up B+) -> term # U)\n      -> (hyp (up (A+ \\/ B+)) -> term # U)\n      -> type.\n%mode adm-\\/L +Pf +N1 +N2 -N'.\n\n/: adm-\\/L (ss Pf Pf') (N1: hyp (up A+) -> term # U) \n     (N2: hyp (up B+) -> term # U) ([x: hyp (up (A+ \\/ B+))] focL Pf x (upL Pf N'))\n  <- expand+ A+ ([z1: value A+] focR (\\/R1 (dnR (upR (focR z1))))) \n       (NId1: term (A+ , #) (dn (up A+) \\/ dn (up B+) true))\n  <- expand+ B+ ([z2: value B+] focR (\\/R2 (dnR (upR (focR z2))))) \n       (NId2: term (B+ , #) (dn (up A+) \\/ dn (up B+) true))\n  <- lsubst (dn (up A+) \\/ dn (up B+)) (b s) (ss Pf Pf') \n       (\\/L NId1 NId2)\n       (\\/L (dnL N1) (dnL N2))\n       (N': term (A+ \\/ B+ , #) U).\n\n%worlds (gamma_suspnormal) (adm-\\/L _ _ _ _).\n%total [] (adm-\\/L _ _ _ _).\n    \n\n%{ ==== Positive conjunction ==== }%\n\nadm-top+R: term # (top+ true) -> type.\n%mode adm-top+R -N'.\n\n/: adm-top+R (focR top+R).\n\n%worlds (gamma_suspnormal) (adm-top+R _).\n%total [] (adm-top+R _).\n\nadm-top+L: stable U\n       -> term # U\n       -> (hyp (up top+) -> term # U)\n       -> type.\n%mode adm-top+L +Pf +N1 -N.\n\n/: adm-top+L Pf N1 ([x: hyp (up top+)] focL Pf x (upL Pf (top+L N1))).\n\n%worlds (gamma_suspnormal) (adm-top+L _ _ _).\n%total [] (adm-top+L _ _ _).\n\nadm-*R: term # (A+ true) \n        -> term # (B+ true) \n        -> term # (A+ * B+ true)\n        -> type.\n%mode adm-*R +N1 +N2 -N.\n\n/: adm-*R (N1: term # (A+ true)) (N2: term # (B+ true)) N'\n  <- ({v2: value B+}\n       expand+ A+ ([v1: value A+] (focR (*R v1 v2))) \n         (NIdB v2: term (A+ , #) (A+ * B+ true)))\n  <- ({x: hyp (up A+)}\n       expand+ B+ ([z2: value B+] focL sp x (upL sp (NIdB z2))) \n         (NId x: term (B+ , #) (A+ * B+ true)))\n  <- ({x: hyp (up A+)}\n       lsubst B+ (b s) (ss sp snp) N2 (NId x)\n         (NA x: term # (A+ * B+ true)))\n  <- rsubst (up A+) (b s) (snl snp) (upR N1) ([x: hyp (up A+)] NA x) N'.\n\n%worlds (gamma_suspnormal) (adm-*R _ _ _).\n%total [] (adm-*R _ _ _).\n\nadm-*L: suspstable U\n        -> (hyp (up A+) -> hyp (up B+) -> term # U) \n        -> (hyp (up (A+ * B+)) -> term # U)\n        -> type.\n%mode adm-*L +Pf +N1 -N.\n\n/: adm-*L (ss Pf Pf') (N1: hyp (up A+) -> hyp (up B+) -> term # U) \n     ([x: hyp (up (A+ * B+))] focL Pf x (upL Pf N'))\n  <- ({z1: value A+}\n       expand+ B+ \n         ([z2: value B+] focR (*R (dnR (upR (focR z1))) (dnR (upR (focR z2)))))\n         (NIdA z1: term (B+ , #) (dn (up A+) * dn (up B+) true)))\n  <- expand+ A+ ([z1: value A+] NIdA z1)\n       (NId: term (A+ , B+ , #) (dn (up A+) * dn (up B+) true))\n  <- lsubst (dn (up A+) * dn (up B+)) (b s) (ss Pf Pf') (*L NId)\n       (*L (dnL [x1: hyp (up A+)] dnL [x2: hyp (up B+)] N1 x1 x2))\n       (N': term (A+ * B+ , #) U).\n\n%worlds (gamma_suspnormal) (adm-*L _ _ _).\n%total [] (adm-*L _ _ _).\n\n%{ ==== Implication ==== }%\n\nadm-=>R: (hyp (up A+) -> term # (dn B- true))\n       -> term # (dn (A+ => B-) true)\n       -> type.\n%mode adm-=>R +N1 -N.\n\n/: adm-=>R (N1: hyp (up A+) -> term # (dn B- true)) (focR (dnR N'))\n  <- ({x: hyp (dn (up A+) => up (dn B-))}\n      {z: value A+}\n       expand- B- \n         (focL sn x (=>L (dnR (upR (focR z))) \n           (upL sn (dnL [x': hyp B-] focL sn x' id-))))\n         (NIdA x z: term # (B- inv))) \n  <- ({x: hyp (dn (up A+) => up (dn B-))}\n       expand+ A+ ([z: value A+] (NIdA x z)) \n         (NId x: term (A+ , #) (B- inv)))\n  <- rsubst (dn (up A+) => up (dn B-)) (b s) (snl snn) \n       (=>R (dnL [x1: hyp (up A+)] upR (N1 x1))) \n       ([x: hyp (dn (up A+) => up (dn B-))] =>R (NId x))\n       (N': term # (A+ => B- inv)).\n\n%worlds (gamma_suspnormal) (adm-=>R _ _).\n%total [] (adm-=>R _ _).\n\nadm-=>L: suspstable U\n       -> term # (A+ true)\n       -> (hyp B- -> term # U)\n       -> (hyp (A+ => B-) -> term # U)\n       -> type.\n%mode adm-=>L +Pf +N1 +N2 -N'.\n\n/: adm-=>L (ss Pf Pf') (N1: term # (A+ true)) (N2: hyp B- -> term # U) N'\n  <- ({x: hyp (A+ => B-)}\n      {z: value A+}\n       expand- B- (focL sn x (=>L z id-))\n         (NIdB x z: term # (B- inv)))\n  <- ({x: hyp (A+ => B-)}\n       expand+ A+ ([z: value A+] focR (dnR (NIdB x z)))\n         (NId x: term (A+ , #) (dn B- true)))\n  <- ({x: hyp (A+ => B-)}\n       lsubst A+ (b s) (ss sp snp) N1 (NId x)\n         (NB x: term # (dn B- true)))\n  <- ({x: hyp (A+ => B-)}\n       lsubst (dn B-) (b s) (ss Pf Pf') (NB x) (dnL [x2: hyp B-] N2 x2) \n         (N' x: term # U)).\n\n%worlds (gamma_suspnormal) (adm-=>L _ _ _ _).\n%total [] (adm-=>L _ _ _ _).\n\n%{ ==== Negative conjunction ==== }%\n\nadm-top-R: term # (dn top- true) -> type.\n%mode adm-top-R -N'.\n\n/: adm-top-R (focR (dnR top-R)).\n\n%worlds (gamma_suspnormal) (adm-top-R _).\n%total [] (adm-top-R _).\n\nadm-/\\R: term # (dn A- true)\n        -> term # (dn B- true)\n        -> term # (dn (A- /\\ B-) true)\n        -> type.\n%mode adm-/\\R +N1 +N2 -N'.\n\n/: adm-/\\R N1 N2 (focR (dnR N'))\n  <- ({x: hyp (up (dn A-) /\\ up (dn B-))}\n       expand- A- (focL sn x (/\\L1 (upL sn (dnL [y] focL sn y id-))))\n         (NId1 x: term # (A- inv)))\n  <- ({x: hyp (up (dn A-) /\\ up (dn B-))}\n       expand- B- (focL sn x (/\\L2 (upL sn (dnL [y] focL sn y id-))))\n         (NId2 x: term # (B- inv)))\n  <- rsubst (up (dn A-) /\\ up (dn B-)) (b s) (snl snn) \n       (/\\R (upR N1) (upR N2)) \n       ([x: hyp (up (dn A-) /\\ up (dn B-))] /\\R (NId1 x) (NId2 x)) \n       (N': term # (A- /\\ B- inv)).\n\n%worlds (gamma_suspnormal) (adm-/\\R _ _ _).\n%total [] (adm-/\\R _ _ _).\n\nadm-/\\L1: suspnormal U\n         -> (hyp A- -> term # U)\n         -> (hyp (A- /\\ B-) -> term # U)\n         -> type.\n%mode +{A-} +{B-} +{U} +{Pf} +{N1} -{N': hyp (A- /\\ B-) -> term # U} \n  adm-/\\L1 Pf N1 N'.\n\n/: adm-/\\L1 Pf (N1: hyp A- -> term # U) N'\n  <- ({x: hyp (A- /\\ B-)}\n       expand- A- (focL sn x (/\\L1 id-))\n         (NId x: term # (A- inv)))\n  <- ({x: hyp (A- /\\ B-)}\n       rsubst A- (b s) (snl Pf) (NId x) N1 \n       (N' x: term # U)).\n\n%worlds (gamma_suspnormal) (adm-/\\L1 _ _ _).\n%total [] (adm-/\\L1 _ _ _).\n\nadm-/\\L2: suspnormal U\n         -> (hyp B- -> term # U)\n         -> (hyp (A- /\\ B-) -> term # U)\n         -> type.\n%mode +{A-} +{B-} +{U} +{Pf} +{N2} -{N': hyp (A- /\\ B-) -> term # U} \n  adm-/\\L2 Pf N2 N'.\n\n/: adm-/\\L2 Pf (N2: hyp B- -> term # U) N'\n  <- ({x: hyp (A- /\\ B-)}\n       expand- B- (focL sn x (/\\L2 id-))\n         (NId x: term # (B- inv)))\n  <- ({x: hyp (A- /\\ B-)}\n       rsubst B- (b s) (snl Pf) (NId x) N2 \n       (N' x: term # U)).\n\n%worlds (gamma_suspnormal) (adm-/\\L2 _ _ _).\n%total [] (adm-/\\L2 _ _ _).\n\n\n%{ == Unfocused system == }%\n\n%{ ==== Syntax ==== }%\n\nprop: type. %name prop P.\na: atom P -> prop.\nff: prop.\nor: prop -> prop -> prop. \ntt: prop.\nand: prop -> prop -> prop.\nimp: prop -> prop -> prop.\n\nprops: type. %name props Psi.\n##: props.\n;: prop -> props -> props. %infix right 3 ;.\n\n%{ ==== Erasure ==== }%\n\n%{ The judgment <tt><nowiki>t P A</nowiki></tt> relates unpolarized propositions <tt><nowiki>P</nowiki></tt> and\npolarized propositions <tt><nowiki>A</nowiki></tt>. The judgment can be effectively run as\nan erasure function from polarized to unpolarized propositions. }%\n\nt: typ P -> prop -> type. %name t Trans.\n\ntQ: t (c Q) (a Q).\n\ntup: t A+ P -> t (up A+) P. \ntbot: t bot ff.\nt\\/: t A+ P1 -> t B+ P2 -> t (A+ \\/ B+) (or P1 P2).\nttop+: t top+ tt.\nt*: t A+ P1 -> t B+ P2 -> t (A+ * B+) (and P1 P2).\n\ntdn: t A- P -> t (dn A-) P.\nt=>: t A+ P1 -> t B- P2 -> t (A+ => B-) (imp P1 P2).\nttop-: t top- tt.\nt/\\: t A- P1 -> t B- P2 -> t (A- /\\ B-) (and P1 P2).\n\n%mode t +A -P.\n%worlds (atom+ | atom-) (t _ _).\n%total A (t A _).\n\ntInv: pos -> props -> type. %name tInv TransInv.\nt#: tInv # ##.\nt,: t A+ P -> tInv Inv Psi -> tInv (A+ , Inv) (P ; Psi).\n\n%mode tInv +A -P.\n%worlds (gamma) (tInv _ _).\n%total Inv (tInv Inv _).\n\ntU: suc -> prop -> type. %name tU TransU.\ntp: tU (A+ true) P <- t A+ P.\ntn: tU (A- inv) P <- t A- P.\nta: tU ((c Q-) susp) (a Q-). \n\ntseq: seqform -> props -> prop -> type.\ntV: tseq (rfoc A+) ## P <- t A+ P.\ntN: tseq (hasleft (ininv Inv) U) Psi Q <- tU U Q <- tInv Inv Psi.\ntS: tseq (hasleft (infoc A-) U) (P ; ##) Q <- tU U Q <- t A- P.\n\n%{ ==== Shift removal ==== }%\n\n%{ There may be a more elegant way to do this, but the last missing\npiece of our unfocused admissibility lemma - the last thing we need to\nknow about the polarized calculus - is that if we need to prove (or\nuse) a deeply-shifted proposition, then it suffices to prove (or use)\na non-deeply-shifted proposition that erases to the same thing. }%\n\nnot-doubleshifted: typ Pol -> type.\nndQ:   not-doubleshifted (c Q).\nndQ+:  not-doubleshifted (dn (c Q)).\nndQ-:  not-doubleshifted (up (c Q)).\nndbot+:  not-doubleshifted bot.\nndbot-:  not-doubleshifted (up bot). \nnd\\/+:  not-doubleshifted (A+ \\/ B+).\nnd\\/-:  not-doubleshifted (up (A+ \\/ B+)). \nndtop++: not-doubleshifted top+.\nndtop+-: not-doubleshifted (up top+). \nnd*+: not-doubleshifted (A+ * B+).\nnd*-: not-doubleshifted (up (A+ * B+)).\nnd=>+:  not-doubleshifted (dn (A+ => B-)).\nnd=>-:  not-doubleshifted (A+ => B-).\nndtop-+: not-doubleshifted (dn top-).\nndtop--: not-doubleshifted top-.\nnd/\\+: not-doubleshifted (dn (A- /\\ B-)).\nnd/\\-: not-doubleshifted (A- /\\ B-).\n\nrshifty: t A P \n     -> t A' P\n     -> not-doubleshifted A' \n     -> (term # (A' true) \n         -> term # (A true))\n     -> type.\n\n%mode rshifty +T -T' -ND -N.\n\n/: rshifty (tdn (tup T)) T' ND ([n] (focR (dnR (upR (N n)))))\n  <- rshifty T T' ND N.\n/: rshifty tQ tQ ndQ ([n] n).\n/: rshifty tbot tbot ndbot+ ([n] n).\n/: rshifty (t\\/ T1 T2) (t\\/ T1 T2) nd\\/+ ([n] n).\n/: rshifty ttop+ ttop+ ndtop++ ([n] n).\n/: rshifty (t* T1 T2) (t* T1 T2) nd*+ ([n] n).\n/: rshifty (tdn tQ) (tdn tQ) ndQ+ ([n] n).\n/: rshifty (tdn (t=> T1 T2)) (tdn (t=> T1 T2)) nd=>+ ([n] n).\n/: rshifty (tdn ttop-) (tdn ttop-) ndtop-+ ([n] n).\n/: rshifty (tdn (t/\\ T1 T2)) (tdn (t/\\ T1 T2)) nd/\\+ ([n] n).\n\n%worlds (gamma_suspnormal) (rshifty _ _ _ _).\n%total T (rshifty T _ _ _).\n\nlshifty: t A P\n     -> t A' P\n     -> not-doubleshifted A'\n     -> ({U} stable U\n         -> (hyp A' -> term # U)\n         -> (hyp A -> term # U))\n     -> type.\n%mode lshifty +T -T' -ND -N.\n\n/: lshifty (tup (tdn T)) T' ND ([u][pf][n][x] focL pf x (upL pf (dnL (N u pf n))))\n  <- lshifty T T' ND N.\n/: lshifty (tup tQ) (tup tQ) ndQ- ([u][pf][n] n).\n/: lshifty (tup tbot) (tup tbot) ndbot- ([u][pf][n] n).\n/: lshifty (tup (t\\/ T1 T2)) (tup (t\\/ T1 T2)) nd\\/- ([u][pf][n] n).\n/: lshifty (tup ttop+) (tup ttop+) ndtop+- ([u][pf][n] n).\n/: lshifty (tup (t* T1 T2)) (tup (t* T1 T2)) nd*- ([u][pf][n] n).\n/: lshifty tQ tQ ndQ ([u][pf][n] n).\n/: lshifty (t=> T1 T2) (t=> T1 T2) nd=>- ([u][pf][n] n).\n/: lshifty ttop- ttop- ndtop-- ([u][pf][n] n).\n/: lshifty (t/\\ T1 T2) (t/\\ T1 T2) nd/\\- ([u][pf][n] n).\n\n%worlds (gamma_suspnormal) (lshifty _ _ _ _).\n%total T (lshifty T _ _ _).\n\n\n%{ ==== Sequent rules ==== }%\n\nleft: prop -> type. %name left H. \nright: prop -> type. %name right D.\nright': props -> prop -> type. %name right' D.\n%block h: some {P} block {h: left P}.\n\ninit: left (a Q) -> right (a Q).\n\nffL: left ff -> right P.\n\norR1: right P1 -> right (or P1 P2).\n\norR2: right P2 -> right (or P1 P2).\n\norL: (left P1 -> right Q) \n     -> (left P2 -> right Q)\n     -> (left (or P1 P2) -> right Q).\n\nttR: right tt.\n\nandR: right P1 -> right P2 -> right (and P1 P2).\n\nandL1: (left P1 -> right Q)\n       -> (left (and P1 P2) -> right Q).\n\nandL2: (left P2 -> right Q)\n       -> (left (and P1 P2) -> right Q).\n\nimpR: (left P1 -> right P2)\n      -> right (imp P1 P2).\n\nimpL: right P1\n      -> (left P2 -> right Q)\n      -> (left (imp P1 P2) -> right Q).\n\nnil: right P -> right' ## P.\n\ncons: (left P -> right' Psi Q) -> right' (P ; Psi) Q.\n\n%{ Syntactic identity on derivations is used for completeness -- it\nkeeps the derivation size the same when we do case analysis. }%\n\nid: right P -> right P -> type.\nrefl: id D D.\n\n\n%{ == De-focalization (soundness) == }%\n\n%{ Soundness is established in a context where each polarized \nhypothesis is mapped to its erasure. }%\n\nsoundhyp: hyp A- -> t A- P -> left P -> type.\n%block soundhyps: some {A-}{P}{T: t A- P} \n  block {x: hyp A-}{h: left P}{_: soundhyp x T h}.\n\nsoundsusp: value (c Q+) -> left (a Q+) -> type.\n%block soundsusps: some {Q+}\n  block {z: value (c Q+)}{h: left (a Q+)}{_: soundsusp z h}.\n\n%block soundctx = (atom+ | atom- | soundhyps | soundsusps).\n\n%mode +{A-} -{P} +{X: hyp A-} -{T: t A- P} -{H: left P} soundhyp X T H.\n%worlds (soundctx) (soundhyp _ _ _).\n%total [] (soundhyp _ _ _).\n\n%mode +{Q+} +{Z: value (c Q+)} -{H: left (a Q+)} soundsusp Z H.\n%worlds (soundctx) (soundsusp _ _).\n%total [] (soundsusp _ _).\n\nsound: exp Form -> tseq Form Psi P -> right' Psi P -> type.\n%mode sound +E +T -D.\n\n/: sound (Z: value (c Q+)) (tV tQ) (nil (init H))\n  <- soundsusp Z H.\n\n/: sound (dnR N) (tV (tdn T)) (nil D)\n  <- sound N (tN t# (tn T)) (nil D).\n\n/: sound (\\/R1 V) (tV (t\\/ T1 _)) (nil (orR1 D))\n  <- sound V (tV T1) (nil D).\n\n/: sound (\\/R2 V) (tV (t\\/ _ T2)) (nil (orR2 D))\n  <- sound V (tV T2) (nil D).\n\n/: sound top+R (tV ttop+) (nil ttR).\n\n/: sound (*R V1 V2) (tV (t* T1 T2)) (nil (andR D1 D2))\n  <- sound V1 (tV T1) (nil D1)\n  <- sound V2 (tV T2) (nil D2).\n\n/: sound (focR V) (tN t# (tp T)) D\n  <- sound V (tV T) D.\n\n/: sound (focL _ X Sp) (tN t# (TCQ: tU U Q)) (nil (D H))\n  <- soundhyp X (TAP: t A- P) (H: left P)\n  <- sound Sp (tS TAP TCQ) (cons [x: left P] (nil (D x: right Q))).\n\n/: sound (&eta;+ [z: value (c Q+)] N z) (tN (t, tQ TInv) TCQ) (cons D)\n  <- ({z: value (c Q+)}{h: left (a Q+)} \n       soundsusp z h ->\n         sound (N z) (tN TInv TCQ) (D h: right' Psi Q)).\n\n/: sound (dnL [x: hyp A-] N x) (tN (t, (tdn T) TInv) TCQ) (cons D)\n  <- ({x: hyp A-}{h: left P}\n       soundhyp x T h ->\n         sound (N x) (tN TInv TCQ) (D h: right' Psi Q)).\n\nsound-ffL: {Psi} left ff \n           -> right' Psi Q -> type.\n/: sound-ffL _ H (nil (ffL H)).\n/: sound-ffL _ H (cons D) \n  <- {h} sound-ffL _ H (D h).\n%mode +{Psi} +{Q} +{H: left ff} -{D: right' Psi Q} sound-ffL Psi H D.\n%worlds (atom+ | atom- | h) (sound-ffL _ _ _). \n%total Psi (sound-ffL Psi _ _).\n\n/: sound botL (tN TInv TCQ) (cons D)\n  <- ({h: left ff} sound-ffL _ h (D h)).\n\nsound-orL: {Psi} left (or P1 P2)\n        -> (left P1 -> right' Psi Q)\n        -> (left P2 -> right' Psi Q)\n        -> right' Psi Q -> type.\n/: sound-orL _ H ([h1] nil (D1 h1)) ([h2] nil (D2 h2)) (nil (orL D1 D2 H)).\n/: sound-orL _ H ([h1] cons (D1 h1)) ([h2] cons (D2 h2)) (cons D) \n  <- {h} sound-orL _ H ([h1] D1 h1 h) ([h2] D2 h2 h) (D h).\n%mode sound-orL +Psi +H +D1 +D2 -D.\n%worlds (atom+ | atom- | h) (sound-orL _ _ _ _ _). \n%total Psi (sound-orL Psi _ _ _ _).\n\n/: sound (\\/L N1 N2) (tN (t, (t\\/ T1 T2) TInv) TCQ) (cons D)\n  <- sound N1 (tN (t, T1 TInv) TCQ) (cons (D1: left P1 -> right' Psi Q))\n  <- sound N2 (tN (t, T2 TInv) TCQ) (cons (D2: left P2 -> right' Psi Q))\n  <- ({h: left (or P1 P2)} sound-orL _ h D1 D2 (D h)).\n\n/: sound (top+L N) (tN (t, ttop+ TInv) TCQ) (cons [h: left tt] D)\n  <- sound N (tN TInv TCQ) (D: right' Psi Q).\n\nsound-andL: {Psi} left (and P1 P2)\n         -> (left P1 -> left P2 -> right' Psi Q)\n         -> right' Psi Q -> type.\n/: sound-andL _ H ([h1] [h2] nil (D1 h1 h2)) \n     (nil (andL1 ([h1] andL2 ([h2] D1 h1 h2) H) H)).\n/: sound-andL _ H ([h1] [h2] cons (D1 h1 h2)) (cons D) \n  <- {h} sound-andL _ H ([h1] [h2] D1 h1 h2 h) (D h).\n%mode sound-andL +Psi +H +D1 -D.\n%worlds (atom+ | atom- | h) (sound-andL _ _ _ _).\n%total Psi (sound-andL Psi _ _ _).\n\n/: sound (*L N) (tN (t, (t* T1 T2) TInv) TCQ) (cons D)\n  <- sound N (tN (t, T1 (t, T2 TInv)) TCQ) (cons [h1] cons [h2] D1 h1 h2)\n  <- ({h: left (and P1 P2)} sound-andL _ h D1 (D h: right' Psi Q)).\n\n/: sound (&eta;- N) (tN t# (tn tQ)) (nil D)\n  <- sound N (tN t# ta) (nil D).\n\n/: sound (upR N) (tN t# (tn (tup T))) (nil D)\n  <- sound N (tN t# (tp T)) (nil D).\n\n/: sound (=>R N) (tN t# (tn (t=> T1 T2))) (nil (impR D))\n  <- sound N (tN (t, T1 t#) (tn T2)) (cons [h: left P1] (nil (D h: right P2))).\n\n/: sound top-R (tN t# (tn ttop-)) (nil ttR).\n\n/: sound (/\\R N1 N2) (tN t# (tn (t/\\ T1 T2))) (nil (andR D1 D2))\n  <- sound N1 (tN t# (tn T1)) (nil D1)\n  <- sound N2 (tN t# (tn T2)) (nil D2).\n\n/: sound id- (tS tQ ta) (cons [h] nil (init h)).\n\n/: sound (upL _ N) (tS (tup T1) TCQ) D\n  <- sound N (tN (t, T1 t#) TCQ) (D: right' (P ; ##) Q).\n\n/: sound (=>L V Sp) (tS (t=> T1 T2) TCQ) (cons [h] nil (impL D1 D2 h))\n  <- sound V (tV T1) (nil (D1: right P1))\n  <- sound Sp (tS T2 TCQ) (cons [h: left P2] nil (D2 h: right Q)).\n\n/: sound (/\\L1 Sp) (tS (t/\\ T1 T2) TCQ) \n     (cons [h: left (and P1 P2)] nil (andL1 D h)) \n  <- sound Sp (tS T1 TCQ) (cons [h1: left P1] nil (D h1: right Q)).\n\n/: sound (/\\L2 Sp) (tS (t/\\ T1 T2) TCQ) \n     (cons [h: left (and P1 P2)] nil (andL2 D h)) \n  <- sound Sp (tS T2 TCQ) (cons [h2: left P2] nil (D h2: right Q)).\n\n%worlds (soundctx) (sound _ _ _).\n%total (E) (sound E _ _).\n\n\n%{ == Focalization (completeness) == }%\n\n%{ Completeness is established in a context where each erased\nhypothesis is mapped to some polarization. This is the almost same,\ntype-wise, as the context for soundness, but the computational\ninterpretation runs the opposite way 'round. }%\n\ncompletehyp_res: typ Pol -> type.\ncn: hyp A- -> completehyp_res (A-).\nca: value (c Q+) -> completehyp_res (c Q+). \n\ncompletehyp: left P -> t A P -> completehyp_res A -> type.\n%block completehypn: some {A-: typ -}{P}{T: t A- P} \n  block {x: hyp A-}{h: left P}{_: completehyp h T (cn x)}.\n%block completehypa: some {Q+: atom +}{P}{T: t (c Q+) P} \n  block {z: value (c Q+)}{h: left P}{_: completehyp h T (ca z)}.\n\n%block completectx = (gamma_suspnormal | completehypn | completehypa).\n\n\ntransnormal: tU U P -> suspnormal U -> type.\n%mode transnormal +T -Pf.\n\n/: transnormal (tp _) snp.\n/: transnormal (tn _) snn.\n/: transnormal ta sna.\n\n%worlds (atom+ | atom-) (transnormal _ _).\n%total [] (transnormal _ _).\n\n%mode completehyp +H -T -X.\n%worlds (completectx) (completehyp _ _ _).\n%total [] (completehyp _ _ _).\n\ncomplete: stable U -> right P -> tU U P -> term # U -> type.\n%mode complete +S +D +T -N.\n\n\n%{ ==== Initial rules ==== }%\n\ncomp-init-susp: \n  not-doubleshifted A'\n  -> t A' (a Q)\n  -> (hyp A' -> term # (c Q susp))\n  -> type.\n \n/: comp-init-susp _ tQ M\n  <- adm-initsusp- M.\n\n%mode comp-init-susp +ND +TH' -E.\n%worlds (completectx) (comp-init-susp _ _ _). \n%total [] (comp-init-susp _ _ _).\n\n/: complete Pf (init H) ta (NS _ sn M X)\n  <- completehyp H (TH: t A (a Q)) (cn (X: hyp A))\n  <- lshifty TH (TH': t A' (a Q)) \n       (ND: not-doubleshifted A') \n       (NS: {U} stable U -> (hyp A' -> term # U) -> (hyp A -> term # U))\n  <- comp-init-susp ND TH' M.\n\ncomp-init-case: \n   not-doubleshifted Aleft'\n   -> t Aleft' (a Q)\n   -> not-doubleshifted Aright'\n   -> t Aright' (a Q)\n   -> (hyp Aleft' -> term # (Aright' true))\n   -> type.\n%mode comp-init-case +NDH +TH' +ND +T' -M.\n\n/: comp-init-case ndQ tQ ndQ+ (tdn tQ) M <- adm-init- M.\n\n/: comp-init-case ndQ- (tup tQ) ndQ tQ M <- adm-init+ M.\n\n%worlds (completectx) (comp-init-case _ _ _ _ _).\n%total [] (comp-init-case _ _ _ _ _).\n\ncomp-init:\n  t Aleft (a Q)\n  -> completehyp_res Aleft\n  -> not-doubleshifted Aright'\n  -> t Aright' (a Q)\n  -> term # (Aright' true)\n  -> type.\n\n/: comp-init tQ (ca Z) ndQ tQ (M Z)\n  <- adm-initsusp+ M.\n\n/: comp-init TH (cn X) ND T' (NS _ sp M X)\n  <- lshifty TH (TH': t Aleft' (a Q))\n       (NDH: not-doubleshifted Aleft')\n       (NS: {U} stable U -> (hyp Aleft' -> term # U)\n                         -> (hyp Aleft -> term # U))\n  <- comp-init-case NDH TH' ND T' M.\n\n%mode comp-init +TH +HypRes +NDright +T' -M.\n%worlds (completectx) (comp-init _ _ _ _ _).\n%total [] (comp-init _ _ _ _ _).\n  \n/: complete Pf (init H) (tp (T: t Aright (a Q))) (NSright M)\n  <- rshifty T (T': t Aright' (a Q)) \n       (NDright: not-doubleshifted Aright') \n       (NSright: term # (Aright' true) -> term # (Aright true))\n  <- completehyp H (TH: t Aleft (a Q)) (HypRes: completehyp_res Aleft)\n  <- comp-init TH HypRes NDright T' M.\n\n%{ ==== Disjunction ==== }%\n\ncomp-ffL: stable U \n  -> not-doubleshifted A' \n  -> t A' ff\n  -> (hyp A' -> term # U) -> type.\n/: comp-ffL Pf ndbot- (tup tbot) M <- adm-botL Pf M.\n%mode comp-ffL +Pf +ND +T -M.\n%worlds (completectx) (comp-ffL _ _ _ _).\n%total [] (comp-ffL _ _ _ _).\n\n/: complete Pf (ffL H) T (NS _ Pf M X)\n  <- completehyp H (TH: t A ff) (cn (X: hyp A))\n  <- lshifty TH (TH': t A' ff) \n       (ND: not-doubleshifted A') \n       (NS: {U} stable U -> (hyp A' -> term # U) -> (hyp A -> term # U))\n  <- comp-ffL Pf ND TH' M.\n\ncomp-orR1: {D: right (or P1 P2)} id D (orR1 D1)\n  -> not-doubleshifted A'\n  -> t A' (or P1 P2)\n  -> term # (A' true)\n  -> type.\n%mode comp-orR1 +D +Id +ND +T -M.\n/: comp-orR1 (orR1 D1) refl nd\\/+ (t\\/ (T1: t A+ P1) (T2: t B+ P2)) M\n  <- complete sp D1 (tp T1) (N1: term # (A+ true))\n  <- adm-\\/R1 N1 (M: term # (A+ \\/ B+ true)).\n\n/: complete Pf (orR1 D1) (tp T) (NS M)\n  <- rshifty T (T': t A' (or P1 P2)) \n       (ND: not-doubleshifted A') \n       (NS: term # (A' true) -> term # (A true))\n  <- comp-orR1 (orR1 D1) refl ND T' M.\n\ncomp-orR2: {D: right (or P1 P2)} id D (orR2 D2)\n  -> not-doubleshifted A'\n  -> t A' (or P1 P2)\n  -> term # (A' true)\n  -> type.\n%mode comp-orR2 +D +Id +ND +T' -M.\n/: comp-orR2 (orR2 D2) refl nd\\/+ (t\\/ (T1: t A+ P1) (T2: t B+ P2)) M\n  <- complete sp D2 (tp T2) (N2: term # (B+ true))\n  <- adm-\\/R2 N2 (M: term # (A+ \\/ B+ true)).\n\n/: complete Pf (orR2 D2) (tp T) (NS M)\n  <- rshifty T (T': t A' (or P1 P2)) \n       (ND: not-doubleshifted A') \n       (NS: term # (A' true) -> term # (A true))\n  <- comp-orR2 (orR2 D2) refl ND T' M.\n\ncomp-orL: stable U \n  -> {D: right Q} id D (orL D1 D2 (H: left (or P1 P2))) \n  -> not-doubleshifted A' \n  -> t A' (or P1 P2)\n  -> tU U Q\n  -> (hyp A' -> term # U) \n  -> type.\n%mode comp-orL +Pf +D +Id +ND +TH +T -M.\n/: comp-orL Pf (orL D1 D2 H) refl nd\\/- (tup (t\\/ T1 T2)) T M\n  <- ({x1: hyp (up B1+)} {h1: left P1} \n       completehyp h1 (tup T1) (cn x1) ->\n         complete Pf (D1 h1) T (N1 x1: term # U))\n  <- ({x2: hyp (up B2+)} {h2: left P2} \n       completehyp h2 (tup T2) (cn x2) ->\n         complete Pf (D2 h2) T (N2 x2: term # U))\n  <- transnormal T Pf'\n  <- adm-\\/L (ss Pf Pf') N1 N2 (M: hyp (up (B1+ \\/ B2+)) -> term # U).\n\n/: complete Pf (orL D1 D2 H) (T: tU U Q) (NS _ Pf M X)\n  <- completehyp H (TH: t A (or P1 P2)) (cn (X: hyp A))\n  <- lshifty TH TH' ND NS\n  <- comp-orL Pf (orL D1 D2 H) refl ND TH' T M.\n\n%{ ==== Conjunction ==== }%\n\ncomp-ttR: {D: right tt} id D ttR\n  -> not-doubleshifted A'\n  -> t A' tt\n  -> term # (A' true)\n  -> type.\n/: comp-ttR ttR refl ndtop++ ttop+ M\n  <- adm-top+R M.\n/: comp-ttR ttR refl ndtop-+ (tdn ttop-) M\n  <- adm-top-R M.\n%mode comp-ttR +D +Id +ND +T' -M.\n%worlds (completectx) (comp-ttR _ _ _ _ _).\n%total [] (comp-ttR _ _ _ _ _).\n\n/: complete Pf ttR (tp T) (NS M)\n  <- rshifty T (T': t A' tt)\n       (ND: not-doubleshifted A')\n       (NS: term # (A' true) -> term # (A true))\n  <- comp-ttR ttR refl ND T' M.\n\ncomp-andR: {D: right (and P1 P2)} id D (andR D1 D2)\n  -> not-doubleshifted A'\n  -> t A' (and P1 P2)\n  -> term # (A' true)\n  -> type.\n%mode comp-andR +D +Id +ND +T' -M.\n/: comp-andR (andR D1 D2) refl nd*+ (t* (T1: t A+ P1) (T2: t B+ P2)) M\n  <- complete sp D1 (tp T1) (N1: term # (A+ true))\n  <- complete sp D2 (tp T2) (N2: term # (B+ true))\n  <- adm-*R N1 N2 M.\n/: comp-andR (andR D1 D2) refl nd/\\+ (tdn (t/\\ (T1: t A- P1) (T2: t B- P2))) M\n  <- complete sp D1 (tp (tdn T1)) (N1: term # (dn A- true))\n  <- complete sp D2 (tp (tdn T2)) (N2: term # (dn B- true))\n  <- adm-/\\R N1 N2 M.\n\n/: complete Pf (andR D1 D2) (tp T) (NS M)\n  <- rshifty T (T': t A' (and P1 P2))\n       (ND: not-doubleshifted A')\n       (NS: term # (A' true) -> term # (A true))\n  <- comp-andR (andR D1 D2) refl ND T' M.\n\ncomp-andL1: stable U\n  -> {D: right Q} id D (andL1 D1 (H: left (and P1 P2)))\n  -> not-doubleshifted A'\n  -> t A' (and P1 P2)\n  -> tU U Q\n  -> (hyp A' -> term # U)\n  -> type.\n%mode comp-andL1 +Pf +D +Id +ND +TH' +T -M.\n/: comp-andL1 Pf (andL1 D1 H) refl nd*- \n      (tup (t* (T1: t A+ P1) (T2: t B+ P2))) T M\n  <- ({x: hyp (up A+)} {h: left P1}\n       completehyp h (tup T1) (cn x) ->\n         complete Pf (D1 h) T (N1 x: term # U))\n  <- transnormal T Pf'\n  <- adm-*L (ss Pf Pf') ([x][y] N1 x) M.\n/: comp-andL1 Pf (andL1 D1 H) refl nd/\\- (t/\\ (T1: t A- P1) (T2: t B- P2)) T M\n  <- ({x: hyp A-} {h: left P1}\n       completehyp h T1 (cn x) ->\n         complete Pf (D1 h) T (N1 x: term # U))\n  <- transnormal T Pf'\n  <- adm-/\\L1 Pf' N1 M.\n\n/: complete Pf (andL1 D1 H) (T: tU U Q) (NS _ Pf M X)\n  <- completehyp H (TH: t A (and P1 P2)) (cn (X: hyp A))\n  <- lshifty TH TH' ND NS\n  <- comp-andL1 Pf (andL1 D1 H) refl ND TH' T M.\n\ncomp-andL2: stable U\n  -> {D: right Q} id D (andL2 D1 (H: left (and P1 P2)))\n  -> not-doubleshifted A'\n  -> t A' (and P1 P2)\n  -> tU U Q\n  -> (hyp A' -> term # U)\n  -> type.\n%mode comp-andL2 +Pf +D +Id +ND +TH' +T -M.\n/: comp-andL2 Pf (andL2 D2 H) refl nd*- \n      (tup (t* (T1: t A+ P1) (T2: t B+ P2))) T M\n  <- ({x: hyp (up B+)} {h: left P2}\n       completehyp h (tup T2) (cn x) ->\n         complete Pf (D2 h) T (N2 x: term # U))\n  <- transnormal T Pf'\n  <- adm-*L (ss Pf Pf') ([x][y] N2 y) M.\n/: comp-andL2 Pf (andL2 D2 H) refl nd/\\- (t/\\ (T1: t A- P1) (T2: t B- P2)) T M\n  <- ({x: hyp B-} {h: left P2}\n       completehyp h T2 (cn x) ->\n         complete Pf (D2 h) T (N2 x: term # U))\n  <- transnormal T Pf'\n  <- adm-/\\L2 Pf' N2 M.\n\n/: complete Pf (andL2 D2 H) (T: tU U Q) (NS _ Pf M X)\n  <- completehyp H (TH: t A (and P1 P2)) (cn (X: hyp A))\n  <- lshifty TH TH' ND NS\n  <- comp-andL2 Pf (andL2 D2 H) refl ND TH' T M.\n\n%{ ==== Implication ==== }%\n\ncomp-impR: {D: right (imp P1 P2)} id D (impR D1)\n  -> not-doubleshifted A'\n  -> t A' (imp P1 P2)\n  -> term # (A' true)\n  -> type.\n%mode comp-impR +D +Id +ND +T' -M.\n/: comp-impR (impR D1) refl nd=>+ (tdn (t=> (T1: t A+ P1) (T2: t B- P2))) M\n  <- ({x: hyp (up A+)} {h: left P1}\n       completehyp h (tup T1) (cn x) ->\n         complete sp (D1 h) (tp (tdn T2)) (N1 x))\n  <- adm-=>R N1 M.\n\n/: complete Pf (impR D1) (tp T) (NS M)\n  <- rshifty T (T': t A' (imp P1 P2))\n       (ND: not-doubleshifted A')\n       (NS: term # (A' true) -> term # (A true))\n  <- comp-impR (impR D1) refl ND T' M.\n\ncomp-impL: stable U\n  -> {D: right Q} id D (impL D1 D2 (H: left (imp P1 P2)))\n  -> not-doubleshifted A'\n  -> t A' (imp P1 P2)\n  -> tU U Q\n  -> (hyp A' -> term # U)\n  -> type.\n%mode comp-impL +Pf +D +Id +ND +TH' +T -M.\n/: comp-impL Pf (impL D1 D2 _) refl nd=>- (t=> (T1: t A+ P1) (T2: t B- P2)) T M\n  <- complete sp D1 (tp T1) (N1: term # (A+ true))\n  <- ({x: hyp B-} {h: left P2}\n       completehyp h T2 (cn x) ->\n         complete Pf (D2 h) T (N2 x))\n  <- transnormal T Pf'\n  <- adm-=>L (ss Pf Pf') N1 N2 M.\n\n/: complete Pf (impL D1 D2 H) T (NS _ Pf M X)\n  <- completehyp H (TH: t A (imp P1 P2)) (cn (X: hyp A))\n  <- lshifty TH TH' ND NS\n  <- comp-impL Pf (impL D1 D2 H) refl ND TH' T M.\n\n%worlds (completectx) \n  (comp-orR1 _ _ _ _ _)\n  (comp-orR2 _ _ _ _ _)\n  (comp-orL _ _ _ _ _ _ _)\n  (comp-andR _ _ _ _ _)\n  (comp-andL1 _ _ _ _ _ _ _)\n  (comp-andL2 _ _ _ _ _ _ _)\n  (comp-impR _ _ _ _ _)\n  (comp-impL _ _ _ _ _ _ _)\n  (complete _ _ _ _).\n%total (D D1 D2 D3 D4 D5 D6 D7 D8) \n  (comp-orR1 D1 _ _ _ _)\n  (comp-orR2 D2 _ _ _ _)\n  (comp-orL _ D3 _ _ _ _ _)\n  (comp-andR D4 _ _ _ _)\n  (comp-andL1 _ D5 _ _ _ _ _)\n  (comp-andL2 _ D6 _ _ _ _ _)\n  (comp-impR D7 _ _ _ _)\n  (comp-impL _ D8 _ _ _ _ _)\n  (complete _ D _ _).\n\n\n\n%{ == Inheriting the focused calculus's metatheory == }%\n\n%{ We need the existance of some polarization strategy; we intentionally pick\na middling, undistinghished sort of translation that translates everything as\na negative proposition. It will work great on hereditary Harrop formulas and\nnot so good if you have lots of disjunction and positive propositions; the only\ninteresting thing about it is that it's results are reminiscent of Howe's \nsemi-focused lax logic.. }%\n\npolarize: {P} t (A-: typ -) P -> type.\n%mode polarize +P -T. \n\n/: polarize (a Q) tQ.\n/: polarize (a Q) (tup tQ).\n/: polarize ff (tup tbot).\n/: polarize (or P1 P2) (tup (t\\/ (tdn T1) (tdn T2)))\n  <- polarize P1 T1\n  <- polarize P2 T2.\n/: polarize tt ttop-.\n/: polarize (and P1 P2) (t/\\ T1 T2)\n  <- polarize P1 T1\n  <- polarize P2 T2.\n/: polarize (imp P1 P2) (t=> (tdn T1) T2)\n  <- polarize P1 T1\n  <- polarize P2 T2.\n\n%worlds (atom+ | atom-) (polarize _ _).\n%total P (polarize P _).\n\n%block translate: some {A}{P}{TH: t A P} \n  block {x: hyp A}{h: left P}{_: soundhyp x TH h}{_: completehyp h TH (cn x)}.\n\nunfocused-cut: right P -> (left P -> right Q) -> right Q -> type.\n%mode unfocused-cut +D +E -F.\n\n/: unfocused-cut (D: right P) (E: left P -> right Q) F\n  <- polarize P (TP: t A- P)\n  <- complete sp D (tp (tdn TP)) (M: term # ((dn A-) true))\n  <- polarize Q (TQ: t C- Q)\n  <- ({x: hyp A-}{h: left P}\n       completehyp h TP (cn x) ->\n         complete sp (E h) (tp (tdn TQ)) (N x: term # (dn C- true)))\n  <- lsubst _ (b s) (ss sp snp) M (dnL N) N'\n  <- sound N' (tN t# (tp (tdn TQ))) (nil (F: right Q)).\n     \n%worlds (translate) (unfocused-cut _ _ _).\n%total [] (unfocused-cut _ _ _).\n\nunfocused-identity: (left P -> right P) -> type.\n%mode +{P} -{D: left P -> right P} unfocused-identity D.\n\n/: unfocused-identity D\n  <- polarize P (TP: t A- P)\n  <- identity- (N: hyp A- -> term # (A- inv))\n  <- ({x: hyp A-}{h: left P}\n       soundhyp x TP h ->\n         sound (N x) (tN t# (tn TP)) (nil (D h: right P))).\n\n%worlds (translate) (unfocused-identity _).\n%total [] (unfocused-identity _).\n\n\n%{ == Running the theorems == }%\n\n%{ Here are two unfocused derivations of (p /\\ q) => (r /\\ s) => (p /\\ t). }%\n\nd1: {P}{p: atom P}{q: atom P}{r: atom P}{s: atom P} \n   right (imp (and (a p) (a q))\n           (imp (and (a r) (a s))\n             (and (a p) (a r))))\n  = [P][p][q][r][s]\n      impR [h1: left (and (a p) (a q))]\n        impR [h2: left (and (a r) (a s))]\n          andR\n            (andL1 ([h1': left (a p)] init h1') h1)\n            (andL1 ([h2': left (a r)] init h2') h2).\n\nd2: {P}{p: atom P}{q: atom P}{r: atom P}{s: atom P} \n   right (imp (and (a p) (a q))\n           (imp (and (a r) (a s))\n             (and (a p) (a r))))\n  = [P][p][q][r][s]\n      impR [h1: left (and (a p) (a q))]\n        impR [h2: left (and (a r) (a s))]\n          andL1 ([h1': left (a p)] \n            andR\n              (andL2 ([_] (andL2 ([_] (init h1')) h1)) h1)\n              (andL1 ([h2': left (a r)] init h2') h2)) \n            h1.\n\n%{ Here are three different polarizations. }%\n\n%solve t-: {p}{q}{r}{s} t (dn(c p /\\ c q) => (dn(c r /\\ c s) => (c p /\\ c r))) _.\n%solve t+: {p}{q}{r}{s} t ((c p * c q) => ((c r * c s) => up(c p * c r))) _.\n%solve te: {p}{q}{r}{s} t (dn(up(c p) /\\ up(c q))\n                            => up(dn(dn(up(c r) /\\ up(c s)) \n                                   => up(dn(up(c p) /\\ up(c r)))))) _.\n\n%{ Under the same \"good\" polarization, different derivations translate to a\nsingle unique proof. | check=decl }%\n\n%query 1 * {p}{q}{r}{s} complete _ (d1 - p q r s) (tp (tdn (t- p q r s))) \n  (N p q r s).\n%query 1 * {p}{q}{r}{s} complete _ (d2 - p q r s) (tp (tdn (t- p q r s))) \n  (N p q r s).\n\n%{ Different polarizations may lead to very differently shaped derivations. \n| check=decl }%\n\n%query 1 * {p}{q}{r}{s} complete _ (d2 + p q r s) \n  (tp (tdn (t+ p q r s))) \n  (N p q r s).\n%query 1 * {p}{q}{r}{s} complete _ (d2 + p q r s) \n  (tp (tdn (te p q r s))) \n  (N p q r s)."
          },
          "sha1": "8g5fkxpoxjgay7d89stnbfvekcnsqak"
        }
      },
      {
        "title": "Freeze",
        "ns": 0,
        "id": 1916,
        "redirect": {
          "@title": "%freeze",
          "#text": null
        },
        "revision": {
          "id": 4284,
          "timestamp": "2007-03-17T22:16:20Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "Redirecting to [[%freeze]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 21,
            "#text": "#REDIRECT [[%freeze]]"
          },
          "sha1": "865e3pbjqyv9fu4qm2j34zk62ncx4qi"
        }
      },
      {
        "title": "Frozen",
        "ns": 0,
        "id": 1964,
        "redirect": {
          "@title": "%freeze",
          "#text": null
        },
        "revision": {
          "id": 4493,
          "timestamp": "2007-03-20T22:14:42Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "comment": "Redirecting to [[%freeze]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 20,
            "#text": "#REDIRECT[[%freeze]]"
          },
          "sha1": "k8fmckm16fwuqhcx6txfi4enb4a2ayf"
        }
      },
      {
        "title": "Function",
        "ns": 0,
        "id": 1480,
        "revision": {
          "id": 2538,
          "parentid": 1880,
          "timestamp": "2006-10-10T14:04:35Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "minor": null,
          "comment": "[[Function (relation)]] moved to [[Function]]: no need for dab",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 192,
            "#text": "A [[relation]] behaves like a '''function''' if a [[uniqueness lemma]] and an [[effectiveness lemma]] can be proven assuming a particular set of positions in the relation are inputs.\n\n{{stub}}"
          },
          "sha1": "94sxbxrxyq1785057k93ru0rf2i306s"
        }
      },
      {
        "title": "Function (relation)",
        "ns": 0,
        "id": 1679,
        "redirect": {
          "@title": "Function",
          "#text": null
        },
        "revision": {
          "id": 2539,
          "timestamp": "2006-10-10T14:04:35Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "comment": "[[Function (relation)]] moved to [[Function]]: no need for dab",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 22,
            "#text": "#REDIRECT [[Function]]"
          },
          "sha1": "8bscsdc04uec2qsp66ehazaenf8i421"
        }
      },
      {
        "title": "General Description of Twelf",
        "ns": 0,
        "id": 1756,
        "redirect": {
          "@title": "General description of Twelf",
          "#text": null
        },
        "revision": {
          "id": 3076,
          "timestamp": "2006-10-23T20:03:58Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "comment": "[[General Description of Twelf]] moved to [[General description of Twelf]]: fine by me, but use lowercase in titles so that they can be inlined in sentences",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 42,
            "#text": "#REDIRECT [[General description of Twelf]]"
          },
          "sha1": "ov5pakkbtrpuvcm48w7n0plzn7qoopb"
        }
      },
      {
        "title": "General description of Twelf",
        "ns": 0,
        "id": 1636,
        "revision": {
          "id": 6081,
          "parentid": 6080,
          "timestamp": "2010-08-05T14:59:13Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 2816,
            "#text": "''This quick introduction to Twelf is aimed at people without any specific technical background. If you want more information, you can find it on the [[documentation]] page.''\n\n[[Image:ServerOK.png|thumb|''Using Twelf with the Emacs text editor.'' The red, blue, and black text at the top is Twelf code, and the black text at the bottom is the output from the Twelf program reading the code.]]'''Twelf''' is a piece of computer software, and it is also a computer language understood by the Twelf software. This is a common ambiguity in computer systems - you can \"install Java on your computer\" (Java, a piece of computer software), or you can \"write programs in Java for work\" (Java, the computer language that is understood and interpreted by the software).\n\nC code and Java code describe programs, HTML code describes graphical web pages, and Twelf code describes ''logical systems.'' Logical systems are sometimes strange to think about, because the only logical system that most people have used is basic arithmetic (addition, subtraction, division, etc.), or maybe set theory if they're particularly ambitious. Most people that use Twelf aren’t interested in using it to do basic arithmetic, because there are a great deal more interesting logical systems than just the ones that we learn about in high school. \n\nThe reason someone might want to use Twelf code to describe a logical system is that once they’ve described it, they can write more Twelf code that uses that logical system. You could use Twelf to write out a statement about basic arithmetic (for instance, “if a + b = c, then b + a = c”), and then use Twelf to write out a justification of why that statement is true (i.e. a ''proof''). When you do so, Twelf will check your proof, making sure that what you said actually is true! \n\nTwelf is by no means the only program you can use to do this sort of thing. ACL2, AUTOMATH, Coq, HOL, HOL Light, LEGO, Isabelle, MetaPRL, NuPRL PVS, and TPS are just a few (!) of the systems that will let you define logical systems and prove things with them. A lot of really amazing work is done using these different systems: one project at the University of Pittsburgh is using HOL Light to check a proof of the Kepler conjecture [http://code.google.com/p/flyspeck/], and The Economist wrote an article about it [http://www.economist.com/science/displayStory.cfm?story_id=3809661] (unfortunately, it is no longer freely available).\n\nBut here’s where, for people that use Twelf, it gets interesting: it turns out that while basic arithmetic, set theory, and interesting logics are logical systems, ''programming languages'' are also logical systems - and Twelf has a couple of unique features that make it a great tool to use when the logical systems you are working with are programming languages..."
          },
          "sha1": "6f1vyaxpxlztysz1uwvtr2nw5d6uzc9"
        }
      },
      {
        "title": "Glossary",
        "ns": 0,
        "id": 1497,
        "revision": {
          "id": 4969,
          "parentid": 4961,
          "timestamp": "2007-10-13T13:23:55Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "minor": null,
          "comment": "Reverted edits by [[Special:Contributions/129.123.104.8|129.123.104.8]] ([[User_talk:129.123.104.8|Talk]]); changed back to last version by [[User:Rsimmons|Rsimmons]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 2011,
            "#text": "This '''glossary''' should include most of the unfamiliar concepts that someone with an undergraduate-level understanding of type theory would encounter in the process of learning to use Twelf. Some of these links point to extensive tutorials, but in those cases the first paragraph or two should include a definition of the concept.\n\nFeel free to add new glossary entries to the list below.  If you encounter a piece of terminology or jargon you haven't seen and it isn't here already, or if a link doesn't answer your question, let us know on the [[Talk:Glossary|talk page]].\n\n{{keyword|nocat=}}\n\n* [[Adequacy]]\n* [[Alpha-equivalence]] (i.e. \"<math>\\alpha</math>-equivalence\")\n* [[Beta-equivalence]] (i.e. \"<math>\\beta</math>-equivalence\")\n* [[Canonical form]]\n* [[Canonical forms lemma]]\n* [[Compatibility lemma]]\n* [[Congruence relation]]\n* [[Congruence lemma]]\n* [[Constraint domain]]\n* [[Coverage checking]]\n* [[Effectiveness lemma]]\n* [[Equality]]\n* [[Equivalence relation]]\n* [[Eta-equivalence]] (i.e. \"<math>\\eta</math>-equivalence\")\n* [[Eta-long form]] (i.e. \"<math>\\eta</math>-long form\")\n* [[Exchange lemma]]\n* [[Explicit parameter]]\n* [[Explicit context]]\n* [[Intrinsic and extrinsic encodings|Extrinsic encoding]]\n* [[Function]]\n* [[Ground]]\n* [[Higher-order abstract syntax]]\n* [[Higher-order judgement]]\n* [[Hereditary substitution]]\n* [[Hypothetical judgment]]\n* [[Implicit parameter]]\n* [[Intrinsic and extrinsic encodings|Intrinsic encoding]]\n* [[Judgment]]\n* [[Judgments as types]]\n* [[LF]]\n* [[Logic programming]]\n* [[Meta-logic]]\n* [[Metatheorem]]\n* [[%mode|Mode checking]]\n* [[Object logic]]\n* [[Relation]]\n* [[Regular worlds]]\n* [[Respects lemma]]\n* [[Substitution lemma]]\n* [[Subordination]]\n* [[Tabled logic programming]]\n* [[Tactical theorem proving]]\n* [[Theorem prover]]\n* [[Totality assertion]]\n* [[%total|Totality checking]]\n* [[Type family]]\n* [[Twelf signature]]\n* [[Unification]]\n* [[Uniqueness lemma]]\n* [[Weakening lemma]]\n* [[%worlds|World checking]]\n* [[World subsumption]]"
          },
          "sha1": "pbc3untiuu195kkbzjhml73y4qwn4fg"
        }
      },
      {
        "title": "Ground",
        "ns": 0,
        "id": 1865,
        "revision": {
          "id": 3767,
          "parentid": 3761,
          "timestamp": "2007-02-26T15:47:00Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "minor": null,
          "comment": "spacing",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 1043,
            "#text": "A term is '''ground''' if it does not contain any existential ([[unification]]) variables. For example, we can make the following [[%solve|queries]] on <tt>[[natural numbers|plus]]</tt>:\n\n<twelf hidden=\"true\">\nnat: type.\nz: nat.\ns: nat -> nat.\nplus: nat -> nat -> nat -> type.\nplus-z: plus z N N.\nplus-s: plus (s N1) N2 (s N3)\n     <- plus N1 N2 N3.\n</twelf><twelf discard=\"true\" check=\"decl\">\n%mode plus +M +N -O.\n%solve D1 : plus (s z) (s (s z)) X.\n%solve D2 : plus (s z) (s Y) (s (s z)).\n</twelf>\n\nIn the query for <tt>D1</tt>, the first two arguments to <tt>plus</tt> are ground. The third is not; it is an existential variable. This is the typical situation: that the input arguments are ground and the output is an unconstrained existential variable. A [[%total]] declaration for <tt>plus</tt> guarantees that such queries will always succeed. However, we can still issue queries like the second, where the middle argument is not ground. In this case, the query does succeed, but the totality declaration does not guarantee that it will."
          },
          "sha1": "o5w7p3g5ncod31o2cckkjzs5arhznr2"
        }
      },
      {
        "title": "HOAS nat bijection",
        "ns": 0,
        "id": 2032,
        "revision": {
          "id": 5729,
          "parentid": 5728,
          "timestamp": "2009-01-12T06:04:18Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 252103,
            "#text": "%{ = Bijection from HOAS to natural numbers = }%\n    \n%{ == Preliminaries == }%\n\n%{\nThis file shows a simple HOAS term type and a mapping from these\nterms to the natural numbers.  It depends on John Boyland's\nlibrary signatures, in particular void, bool, nat and natpair.\n\nSuch mappings are useful so that the library signatures\nfor set and map can be used to form sets or maps using the\nHOAS terms as keys.\n\nThe mapping is proved total, deterministic, onto and one2one in\nfour separate metatheorems.  (The actual relation itself is not\nproved total or deterministic directly.).  Thus the mapping is\na bijection.\n\nThis file is a proof of concept that this sort of mapping can be done \nand more importantly, proved correct, in Twelf.  The HOAS terms themselves\nare uninteresting.  The purpose in doing these proofs is to help me\n(John Boyland) write a general package to generate such mappings and \ntheir proofs.\n\nIn writing the proofs, I am greatly indebted to Rob Simmons who took\nup my challenge to write bijections involving HOAS terms.  However,\nI go against his explicit advice in using the \"%theorem\" syntax\nextensively which I find much more clear that the \"preferred\" Twelf\nway of purity.\n}%\n\n\n%{| hidden=true }%\n\n%%%% Imports\n\n%%%%%% Proposed Twelf Standard Library\n%%%%%% John Boyland\n%%%%%% You may freely use, modify and distribute this file without restrictions.\n\n% This file includes some simple types that should\n% be standardized.  Here is my proposal.\n\n\n\n\n%%%% Structure\n\n\n\n%%% The uninhabited type\n\n\nvoid   :   type.\n\n\n%freeze void.\n\n\n\n\n%%% The uninteresting type\n\n\nunit : type.\n\n\nunit/ : unit.\n\n\n%freeze unit.\n\n\n\n%%% The three-way comparison type\n\n\ncomp : type.\n\n\nless    : comp.\n\ngreater : comp.\n\nequal   : comp.\n\n\n%freeze comp.\n\n%%%%% bool.elf\n%%%%% Boolean literals\n%%%%% John Boyland\n\n\n%%%% Definitions\n\n\n\nbool : type.\n\n\ntrue : bool.\n\nfalse : bool.\n\n\n%freeze bool.\n\n\n\neq : bool -> bool -> type.\n\n\neq/ : eq B B.\n\n\n\nne : bool -> bool -> type.\n\n\nne/TF : ne true false.\n\nne/FT : ne false true.\n\n\n\neq? : bool -> bool -> bool -> type.\n\n\neq?/yes : eq? B B true.\n\neq?/no : eq? B1 B2 false\n    <- ne B1 B2.\n\n\n\n\n%%%% Theorems\n\n\n\n%%% theorems about eq\n\n\n%theorem false-implies-eq :\n\tforall* {X1} {X2}\n\tforall {F:void}\n\texists {E:eq X1 X2}\n\ttrue.\n\n%worlds () (false-implies-eq _ _).\n%total { } (false-implies-eq _ _).\n\n\n%theorem meta-eq :\n\tforall {X1} {X2} {E:eq X1 X2}\n\ttrue.\n\n- : meta-eq _ _ eq/.\n\n%worlds () (meta-eq _ _ _).\n%total { } (meta-eq _ _ _).\n%reduces X = Y (meta-eq X Y _).\n\n\t\n%theorem eq-reflexive : \n\tforall {X} \n\texists {E:eq X X} \n\ttrue.\n\n- : eq-reflexive _ eq/.\n\n%worlds () (eq-reflexive _ _).\n%total { } (eq-reflexive _ _).\n\n\n%theorem eq-symmetric : \n\tforall* {X} {Y}\n\tforall {E:eq X Y}\n\texists {F:eq Y X}\n\ttrue.\n\n- : eq-symmetric (eq/) (eq/).\n\n%worlds () (eq-symmetric _ _).\n%total { } (eq-symmetric _ _).\n\n\n%theorem eq-transitive : \n\tforall* {X} {Y} {Z}\n\tforall {E1:eq X Y} {E2:eq Y Z}\n\texists {F:eq X Z}\n\ttrue.\n\n- : eq-transitive (eq/) (eq/) (eq/).\n\n%worlds () (eq-transitive _ _ _).\n%total { } (eq-transitive _ _ _).\n\n\n\n%%% theorems about ne\n\n\n%theorem false-implies-ne :\n\tforall* {X1} {X2}\n\tforall {F:void}\n\texists {G:ne X1 X2}\n\ttrue.\n\n%worlds () (false-implies-ne _ _).\n%total { } (false-implies-ne _ _).\n\n\n%theorem ne-respects-eq :\n\tforall* {X1} {X2} {Y1} {Y2}\n\tforall {D1:ne X1 X2} {E1:eq X1 Y1} {E2:eq X2 Y2}\n\texists {D2:ne Y1 Y2}\n\ttrue.\n\n- : ne-respects-eq X1<>X2 eq/ eq/ X1<>X2.\n\n%worlds () (ne-respects-eq _ _ _ _).\n%total { } (ne-respects-eq _ _ _ _).\n\n\n%theorem ne-anti-reflexive :\n\tforall* {B}\n\tforall {R:ne B B}\n\texists {F:void}\n\ttrue.\n\n%worlds () (ne-anti-reflexive _ _).\n%total { } (ne-anti-reflexive _ _).\n\n\n%theorem ne-symmetric :\n\tforall* {B1} {B2}\n\tforall {R1:ne B1 B2}\n\texists {R2:ne B2 B1}\n\ttrue.\n\n- : ne-symmetric ne/TF ne/FT.\n\n- : ne-symmetric ne/FT ne/TF.\n\n%worlds () (ne-symmetric _ _).\n%total { } (ne-symmetric _ _).\n\n\n%theorem eq-ne-implies-false :\n\tforall* {B1} {B2}\n\tforall {D1:eq B1 B2} {D2:ne B1 B2}\n\texists {F:void}\n\ttrue.\n\n%worlds () (eq-ne-implies-false _ _ _).\n%total { } (eq-ne-implies-false _ _ _).\n\n\n\n%%% theorems about eq?\n\n\n%theorem eq?-total* :\n\tforall {B1} {B2}\n\texists {B} {EQ?:eq? B1 B2 B}\n\ttrue.\n\n- : eq?-total* true true _ (eq?/yes).\n\n- : eq?-total* false false _ (eq?/yes).\n\t\n- : eq?-total* true false _ (eq?/no ne/TF).\n\n- : eq?-total* false true _ (eq?/no ne/FT).\n\n\n%worlds () (eq?-total* _ _ _ _).\n%total { } (eq?-total* _ _ _ _).\n\n\n%abbrev eq?-total = eq?-total* _ _ _.\n%abbrev bool`bool = bool.\n%abbrev bool`true = true.\n%abbrev bool`false = false.\n%abbrev bool`eq = eq.\n%abbrev bool`eq/ = eq/.\n%abbrev bool`ne = ne.\n%abbrev bool`ne/TF = ne/TF.\n%abbrev bool`ne/FT = ne/FT.\n%abbrev bool`eq? = eq?.\n%abbrev bool`eq?/yes = eq?/yes.\n%abbrev bool`eq?/no = eq?/no.\n%abbrev bool`false-implies-eq = false-implies-eq.\n%abbrev bool`meta-eq = meta-eq.\n%abbrev bool`eq-reflexive = eq-reflexive.\n%abbrev bool`eq-symmetric = eq-symmetric.\n%abbrev bool`eq-transitive = eq-transitive.\n%abbrev bool`false-implies-ne = false-implies-ne.\n%abbrev bool`ne-respects-eq = ne-respects-eq.\n%abbrev bool`ne-anti-reflexive = ne-anti-reflexive.\n%abbrev bool`ne-symmetric = ne-symmetric.\n%abbrev bool`eq-ne-implies-false = eq-ne-implies-false.\n%abbrev bool`eq?-total* = eq?-total*.\n%abbrev bool`eq?-total = eq?-total.\n\n%%%%% Natural numbers\n%%%%% John Boyland\n%%%%% Anyone may use, copy or modify this software without restriction\n\n%%%%% This file requires std.elf\n\n% The natural numbers signature comes in several pieces,\n% all of which are concatenated in nat.elf:\n%    - nat-base.elf (basic definitions, relations and operations)\n%    - nat-comp.elf (composed orders: ge, ne)\n%    - nat-inv.elf (inverse operation: minus)\n%    - nat-less.elf (inverse orders: lt, le)\n%    - nat-inv-comp.elf (theorems about minus and composed relations)\n%    - nat-inv-less.elf (theorems about minus and inverse orders)\n%    - nat-divrem.elf (quotient/remainder operation)\n%    - nat-minmax-elf (min/max operations)\n% With the exception of the nat-inv-XXX.elf files,\n% all later files depend on (require) only the nat-base.elf file.\n% The nat-inv-XXX.elf files depend also on nat-inv.elf and nat-XXX.elf.\n\n\n% The theorems in this signature mostly fall into the following groups:\n%   false-implies-XXX: one can derive XXX after a contradiction\n%   XXX-respects-eq: one can substitute equal terms in a relation XXX\n%   XXX-total: effectiveness lemma for XXX\n%   XXX-deterministic: uniqueness lemma for XXX\n%   XXX-reflexive, XXX-symmetric, XXX-transitive: properties of an equivalence\n%   XXX-anti-reflexive, XXX-anti-symmetric: properties of a partial order\n%   XXX-commutative, XXX-associative: properties of a binary operation\n%   XXX-left/right-distributes-over-YYY: distribution theorem\n%   XXX-left/right-factors-over-YYY: converse of distribution theorem\n%   XXX-left/right-preserves-ORD: If X ORD Y then we can apply Z to both sides\n%   XXX-left/right-cancels: cancellation property of binary operator XXX\n%   XXX-left/right-cancels-ORD: cancellation property w.r.t. order ORD\n%   XXX-contradiction: case where XXX can never happen\n%   XXX-implies-YYY: if XXX is true, we show YYY is true\n%   TTT-converse: converse of theorem TTT\n% Additionally there are varieties of theorems with star appended to the name.\n% These versions of the theorems typically require more inputs.\n\n\n\n\n%%%%% nat-base.elf\n%%%%% Basic definitions, operations and theorems\n%%%%% This file is part of the nat.elf signature\n\n\n%%%% Definitions\n\n\n%%% Natural numbers:\n\n\nnat : type.\t\t\t\t%name nat N.\n\n\nz : nat.\n\ns : nat -> nat.\n\n%freeze nat.\n\n\n%%% Operations on natural numbers\n\n\nplus : nat -> nat -> nat -> type.\n\n\nplus/z : plus z Y Y.\n\nplus/s : plus (s X) Y (s Z)\n    <- plus X Y Z.\n\n\n\ntimes : nat -> nat -> nat -> type.\n\n\ntimes/z : times z X z.\n\ntimes/s : times (s X) Y Z\n    <- plus T Y Z\n    <- times X Y T.\n\n\n\neq : nat -> nat -> type.\n\n\neq/ : eq N N.\n\n\n\ngt : nat -> nat -> type.\n\n\ngt/1 : gt (s M) M.\n\ngt/> : gt (s M) N\n     <- gt M N.\n\n\n\n%%% Using the conditional for natural numbers\n\n\ncompare : nat -> nat -> comp -> type.\n\n\ncompare/= : compare N N equal.\n\ncompare/< : compare M N less <- gt N M.\n\ncompare/> : compare M N greater <- gt M N.\n\n\n\n\n%%%% Theorems\n\n\n\n%%% Theorems about eq\n\n\n%reduces X = Y (eq X Y).\n\n\n%theorem meta-eq : forall {M} {N} {E:eq M N} true.\n\n- : meta-eq N N eq/.\n\n%worlds () (meta-eq _ _ _).\n%total {} (meta-eq _ _ _).\n%reduces X = Y (meta-eq X Y _).\n\n\n%theorem false-implies-eq :\n\tforall* {M} {N}\n\tforall {P:void}\n        exists {Q:eq M N}\n\ttrue.\n\n%worlds () (false-implies-eq _  M=N).\n%total {} (false-implies-eq _ _).\n\n\t\t    \n%theorem eq-symmetric : forall* {M:nat} {N:nat}\n\tforall {E:eq M N}\n\texists {F:eq N M}\n\ttrue.\n\n- : eq-symmetric (eq/) (eq/).\n\n%worlds () (eq-symmetric M>N  N>M).\n%total {} (eq-symmetric _ _).\n\n\n%theorem eq-transitive : \n\tforall* {M:nat} {N:nat} {P:nat}\n\tforall {E1:eq M N} {E2:eq N P}\n\texists {F:eq M P}\n\ttrue.\n\n- : eq-transitive (eq/) (eq/) (eq/).\n\n%worlds () (eq-transitive M>N N>P  M>P).\n%total {} (eq-transitive _ _ _).\n\n\n%theorem succ-deterministic : \n\tforall* {N1:nat} {N2:nat}\n        forall {E:eq N1 N2}\n        exists {F:eq (s N1) (s N2)}\n        true.\n\n- : succ-deterministic eq/ eq/.\n\n%worlds () (succ-deterministic N1=N2  N1+1=N2+1).\n%total {} (succ-deterministic E _).\n\n\n%theorem succ-cancels : \n\tforall*  {N1:nat} {N2:nat}\n        forall {E:eq (s N1) (s N2)}\n        exists {F:eq N1 N2}\n        true.\n\n- : succ-cancels eq/ eq/.\n\n%worlds () (succ-cancels N1+1=N2+1  N1=N2).\n%total {} (succ-cancels E _).\n\n\n%theorem eq-contradiction : \n\tforall* {N}\n        forall {E:eq z (s N)}\n        exists {F:void}\n\ttrue.\n\n%worlds () (eq-contradiction ZERO=N+1  _).\n%total {} (eq-contradiction _ _).\n\n\n\n%%% Theorems about gt\n\n\n%reduces M < N (gt N M).\n\n\n%% If we want to prove the termination of a theorem using gt,\n%% we need the gt relation lifted to the meta level:\n\n%theorem meta-gt : forall {M} {N} {G:gt M N} true.\n\n- : meta-gt (s M) M (gt/1).\n\n- : meta-gt (s M) N (gt/> G)\n    <- meta-gt M N G.\n\n%worlds () (meta-gt _ _ _).\n%total M (meta-gt M _ _).\n%reduces M < N (meta-gt N M _).\n\n\n%theorem false-implies-gt :\n\tforall* {M} {N}\n\tforall {P:void}\n        exists {Q:gt M N}\n\ttrue.\n\n%worlds () (false-implies-gt _  M>N).\n%total {} (false-implies-gt _ _).\n\n\t\t    \n%theorem gt-respects-eq : \n\tforall* {M1:nat} {M2:nat} {N1:nat} {N2:nat}\n        forall {P:gt M1 N1} {E1:eq M1 M2} {E2:eq N1 N2}\n        exists {Q:gt M2 N2}\n\ttrue.\n\n- : gt-respects-eq M1>N1 eq/ eq/ M1>N1.\n\n%worlds () (gt-respects-eq M1>N1 M1=M2 N1=N2  M2>N2).\n%total {} (gt-respects-eq _ _ _ _).\n\n\n%theorem succ-implies-gt  : \n\tforall* {X} {X'}\n\tforall {E:eq X (s X')}\n\texists {G:gt X X'}\n\ttrue.\n\n- : succ-implies-gt eq/ gt/1.\n\n%worlds () (succ-implies-gt X=sX'  X>X').\n%total {} (succ-implies-gt _ _).\n\n\n%theorem succ-implies-gt-zero: \n        forall {M}\n        exists {G:gt (s M) z}\n\ttrue.\n\n- : succ-implies-gt-zero z gt/1.\n\n- : succ-implies-gt-zero (s M) (gt/> SM>0)\n    <- succ-implies-gt-zero M SM>0.\n\n%worlds () (succ-implies-gt-zero M  SM>0).\n%total M (succ-implies-gt-zero M _).\n\n\n%theorem succ-preserves-gt:     \n        forall* {M} {N}\n        forall {G1:gt M N}\n\texists {G2:gt (s M) (s N)}\n\ttrue.\n\n- : succ-preserves-gt gt/1 gt/1.\n\n- : succ-preserves-gt (gt/> M>N) (gt/> SM>SN)\n    <- succ-preserves-gt M>N SM>SN.\n\n%worlds () (succ-preserves-gt M>N  SM>SN).\n%total G1 (succ-preserves-gt G1 _).\n\n\n%theorem succ-preserves-gt-converse:\n        forall* {M} {N}\n\tforall {G1:gt (s M) (s N)}\n        exists {G2:gt M N}\n\ttrue.\n\n- : succ-preserves-gt-converse gt/1 gt/1.\n\n- : succ-preserves-gt-converse (gt/> SM>SN) (gt/> M>N)\n    <- succ-preserves-gt-converse SM>SN M>N.\n\n%worlds () (succ-preserves-gt-converse SM>SN  M>N).\n%total G1 (succ-preserves-gt-converse G1 _).\n\n\n%theorem gt-implies-positive :\n        forall* {M} {N} \n        forall {G:gt M N} \n        exists {M'} {E:eq M (s M')}\n        true.\n\n- : gt-implies-positive gt/1 M eq/.\n\n- : gt-implies-positive (gt/> (G:gt M N)) M eq/.\n\n%worlds () (gt-implies-positive M>N  M' M=sM').\n%total {} (gt-implies-positive _ _ _).\n\n\n%theorem gt-anti-reflexive* :\n        forall {M}\n               {G:gt M M}\n        exists {F:void}\n        true.\n\n- : gt-anti-reflexive* (s M) (G:gt (s M) (s M)) F\n     <- succ-preserves-gt-converse G G'\n     <- gt-anti-reflexive* M G' F.\n\n%worlds () (gt-anti-reflexive* M M>M  _).\n%total M (gt-anti-reflexive* M _ _).\n\n\n%abbrev gt-anti-reflexive = gt-anti-reflexive* _.\n\n\n%theorem gt-transitive : \n\tforall* {M} {N} {P}\n        forall {G1:gt M N} {G2:gt N P}\n        exists {G3:gt M P}\n        true.\n\n- : gt-transitive gt/1 G (gt/> G).\n\n- : gt-transitive (gt/> M>N) N>P (gt/> M>P)\n    <- gt-transitive M>N N>P M>P.\n\n%worlds () (gt-transitive M>N N>P  M>P).\n%total (G1) (gt-transitive G1 _ _).\n\n\n%theorem gt-anti-symmetric :\n        forall* {M} {N}\n\tforall {G1:gt M N} {G2:gt N M}\n        exists {F:void}\n        true.\n\n- : gt-anti-symmetric M>N N>M F\n    <- gt-transitive M>N N>M M>M\n    <- gt-anti-reflexive M>M F.\n\n%worlds () (gt-anti-symmetric M>N N>M  _).\n%total {} (gt-anti-symmetric _ _ _).\n\n\n%theorem gt-implies-plus : \n\tforall* {M} {N}\n        forall {G:gt M N}\n        exists {D} {P:plus (s D) N M}\n        true.\n\n- : gt-implies-plus gt/1 z (plus/s plus/z).\n\n- : gt-implies-plus (gt/> M>N) (s D) (plus/s SD+N=M)\n    <- gt-implies-plus M>N D SD+N=M.\n\n%worlds () (gt-implies-plus M>N  D SD+N=M).\n%total G (gt-implies-plus G _ _).\n\n\n%theorem gt-contradiction :\n    forall* {M}\n    forall {P:gt z M}\n    exists {Q:void}\n    true.\n\n%worlds () (gt-contradiction ZERO>N  _).\n%total {} (gt-contradiction _ _).\n\n\n\n%%% Theorems about compare\n\n\n%theorem false-implies-compare :\n\tforall* {M} {N} {C}\n\tforall {P:void}\n        exists {Q:compare M N C}\n\ttrue.\n\n%worlds () (false-implies-compare _ _).\n%total {} (false-implies-compare _ _).\n\n\n%theorem succ-preserves-compare :\n\tforall* {M} {N} {C}\n\tforall {CMP:compare M N C}\n\texists {CMP':compare (s M) (s N) C}\n\ttrue.\n\n- : succ-preserves-compare compare/= compare/=.\n\n- : succ-preserves-compare (compare/< M>N) (compare/< M+1>N+1)\n    <- succ-preserves-gt M>N M+1>N+1.\n\n- : succ-preserves-compare (compare/> M>N) (compare/> M+1>N+1)\n    <- succ-preserves-gt M>N M+1>N+1.\n\n%worlds () (succ-preserves-compare _ _).\n%total {} (succ-preserves-compare _ _).\n\n\n%theorem compare-total* :\n\tforall {M} {N}\n\texists {CMP} {P:(compare M N CMP)}\n\ttrue.\n\n- : compare-total* z z equal compare/=.\n\n- : compare-total* z (s M) less (compare/< M+1>0)\n    <- succ-implies-gt-zero M M+1>0.\n\n- : compare-total* (s M) z greater (compare/> M+1>0)\n    <- succ-implies-gt-zero M M+1>0.\n\n- : compare-total* (s M) (s N) R M+1-R-N+1\n    <- compare-total* M N R M-R-N\n    <- succ-preserves-compare M-R-N M+1-R-N+1.\n\n%worlds () (compare-total* _ _ _ _).\n%total (M) (compare-total* M _ _ _).\n\n\n%abbrev compare-total = compare-total* _ _ _.\n\n\n%theorem greater-implies-gt : \n\tforall* {M} {N}\n\tforall {C:compare M N greater}\n        exists {G:gt M N}\n\ttrue.\n\n- : greater-implies-gt (compare/> G) G.\n\n%worlds () (greater-implies-gt M>N  M-gt-N).\n%total C (greater-implies-gt C _).\n\n\n%theorem less-is-reverse-greater :\n        forall* {M} {N}\n\tforall {C1:compare M N less}\n\texists {C2:compare N M greater}\n\ttrue.\n\n- : less-is-reverse-greater (compare/< G) (compare/> G).\n\n%worlds () (less-is-reverse-greater M<N  N>M).\n%total C (less-is-reverse-greater C _).\n\n\n%theorem less-implies-lt : \n\tforall* {M} {N}\n\tforall {C:compare M N less}\n\texists {G:gt N M}\n\ttrue.\n\n- : less-implies-lt (compare/< G) G.\n\n%worlds () (less-implies-lt M<N  N-gt-M).\n%total {} (less-implies-lt _ _).\n\n\n%theorem equal-implies-eq : \n\tforall* {M} {N}\n\tforall {C:compare M N equal}\n\texists {E:eq M N}\n\ttrue.\n\n- : equal-implies-eq compare/= eq/.\n\n%worlds () (equal-implies-eq M=N  M-eq-N).\n%total C (equal-implies-eq C _).\n\n\n\n%%% Theorems about plus\n\n\n%theorem false-implies-plus :\n\tforall* {M} {N} {O}\n\tforall {P:void}\n        exists {Q:plus M N O}\n\ttrue.\n\n%worlds () (false-implies-plus _ _).\n%total {} (false-implies-plus _ _).\n\n\t\t    \n%theorem plus-respects-eq : \n\tforall* {M1:nat} {M2:nat} {N1:nat} {N2:nat} {P1:nat} {P2:nat}\n        forall {P:plus M1 N1 P1} \n               {E1:eq M1 M2} {E2:eq N1 N2} {E3:eq P1 P2}\n        exists {Q:plus M2 N2 P2}\n\ttrue.\n\n- : plus-respects-eq M1+N1=P1 eq/ eq/ eq/ M1+N1=P1.\n\n%worlds () (plus-respects-eq M1+N1=P1 M1=M2 N1=N2 P1=P2  M2+N2=P2).\n%total {} (plus-respects-eq _ _ _ _ _).\n\n\n%theorem plus-total*: \n\tforall {N1:nat} {N2:nat}\n        exists {N3:nat} {P:plus N1 N2 N3}\n        true.\n\n- : plus-total* _ _ _ plus/z.\n\n- : plus-total* (s N1') N2 (s N3) (plus/s P)\n    <- plus-total* N1' N2 N3 P.\n\n%worlds () (plus-total* N1 N2  N3 N1+N2=N3).\n%total N1 (plus-total* N1 _ _ _).\n\n\n%abbrev plus-total = plus-total* _ _ _.\n\n\n%theorem plus-deterministic: \n\tforall* {N1:nat} {N1':nat} {N2:nat} {N2':nat} {N3:nat} {N3':nat}\n        forall {P:plus N1 N2 N3} {P':plus N1' N2' N3'}\n\t       {E1:eq N1 N1'} {E2:eq N2 N2'}\n        exists {E3:eq N3 N3'}\n        true.\n\n- : plus-deterministic plus/z plus/z eq/ eq/ eq/.\n\n- : plus-deterministic \n        (plus/s (P:plus N1 N2 N3)) \n        (plus/s (P':plus N1' N2' N3')) \n        E1 E2 (E:eq (s N3) (s N3'))\n     <- succ-cancels E1 E1'\n     <- plus-deterministic P P' E1' E2 E'\n     <- succ-deterministic E' E.\n\n%worlds () (plus-deterministic _ _ _ _ _).\n%total (P) (plus-deterministic P _ _ _ _).\n\n\n%theorem plus-left-identity : \n\tforall {N:nat}\n\texists {P:plus z N N}\n\ttrue.\n\n- : plus-left-identity N plus/z.\n\n%worlds () (plus-left-identity N  Z+N=N).\n%total {} (plus-left-identity _ _).\n\n\n%theorem plus-left-increase :\n\tforall* {M:nat} {N:nat} {O:nat}\n        forall {P:plus M N O}\n\texists {Q:plus (s M) N (s O)}\n\ttrue.\n\n- : plus-left-increase P (plus/s P).\n\n%worlds () (plus-left-increase M+N=O  SM+N=sO).\n%total {} (plus-left-increase _ _).\n\n\n%theorem plus-right-identity : \n\tforall {N:nat}\n\texists {P:plus N z N}\n\ttrue.\n\n- : plus-right-identity z plus/z.\n\n- : plus-right-identity (s N) (plus/s N+0=N)\n    <- plus-right-identity N N+0=N.\n\n%worlds () (plus-right-identity N  N+0=N).\n%total N (plus-right-identity N _).\n\n\n%theorem plus-right-increase : \n\tforall* {M:nat} {N:nat} {O:nat}\n\tforall {P:plus M N O}\n\texists {Q:plus M (s N) (s O)}\n\ttrue.\n\n- : plus-right-increase plus/z plus/z.\n\n- : plus-right-increase (plus/s M+N=O) (plus/s M+sN=sO)\n    <- plus-right-increase M+N=O M+sN=sO.\n\n%worlds () (plus-right-increase M+N=O  M+sN=sO).\n%total P (plus-right-increase P _).\n\n\n%theorem plus-left-decrease:\n\tforall* {M:nat} {N:nat} {O':nat}\n\tforall {P:plus (s M) N O'}\n\texists {O} {E:eq O' (s O)} {Q:plus M N O}\n\ttrue.\n\n- : plus-left-decrease (plus/s M+N=O) O eq/ M+N=O.\n\n%worlds () (plus-left-decrease SM+N=O'  O O'=sO M+N=O).\n%total {} (plus-left-decrease _ _ _ _).\n\n\n%theorem plus-right-decrease:\n\tforall* {M:nat} {N:nat} {O':nat}\n\tforall {P:plus M (s N) O'}\n\texists {O} {E:eq O' (s O)} {Q:plus M N O}\n\ttrue.\n\n- : plus-right-decrease (plus/z) N eq/ (plus/z).\n\n- : {M+sN=O: plus M (s N) O} {sM+N=O:plus (s M) N O} {sM+N=X:plus (s M) N X}\n    plus-right-decrease (plus/s M+sN=O) _ eq/ sM+N=O\n    <- plus-right-decrease M+sN=O O' O=sO' M+N=O'\n    <- plus-total sM+N=X\n    <- plus-deterministic (plus/s M+N=O') sM+N=X eq/ eq/ SO'=X\n    <- eq-transitive O=sO' SO'=X O=X\n    <- eq-symmetric O=X X=O\n    <- plus-respects-eq sM+N=X eq/ eq/ X=O sM+N=O.\n\n%worlds () (plus-right-decrease M+sN=O'  O O'=sO M+N=O).\n%total P (plus-right-decrease P _ _ _).\n\n\n%theorem plus-swap-succ:\n\tforall* {N1} {N2} {N3}\n\tforall {P:plus (s N1) N2 N3}\n\texists {P':plus N1 (s N2) N3}\n\ttrue.\n\n- : plus-swap-succ (plus/s N1+N2=N3-) N1+sN2=N3\n    <- plus-right-increase N1+N2=N3- N1+sN2=N3.\n\n%worlds () (plus-swap-succ SN1+N2=N3  N1+sN2=N3).\n%total {} (plus-swap-succ _ _).\n\n\n%theorem plus-swap-succ-converse:\n\tforall* {N1} {N2} {N3}\n\tforall {P:plus N1 (s N2) N3}\n\texists {P':plus (s N1) N2 N3}\n\ttrue.\n\n- : plus-swap-succ-converse N1+sN2=N3 SN1+N2=N3\n    <- plus-right-decrease N1+sN2=N3 N3- N3=sN3- N1+N2=N3-\n    <- eq-symmetric N3=sN3- SN3-=N3\n    <- plus-respects-eq (plus/s N1+N2=N3-) eq/ eq/ SN3-=N3 SN1+N2=N3.\n\n%worlds () (plus-swap-succ-converse N1+sN2=N3  SN1+N2=N3).\n%total {} (plus-swap-succ-converse _ _).\n\n\n%theorem plus-left-preserves-positive:\n\tforall* {N1} {N2} {N3} {N1-}\n\tforall {P:plus N1 N2 N3} {E:eq N1 (s N1-)}\n        exists {N3-} {E':eq N3 (s N3-)}\n\ttrue.\n\n- : plus-left-preserves-positive (plus/s N1-+N2=N3-) eq/ _ eq/.\n\n%worlds () (plus-left-preserves-positive N1+N2=N3 N1=sN1-  N3- N3=sN3-).\n%total {} (plus-left-preserves-positive _ _ _ _).\n\n\n%theorem plus-right-preserves-positive:\n\tforall* {N1} {N2} {N3} {N2-}\n\tforall {P:plus N1 N2 N3} {E:eq N2 (s N2-)}\n\texists {N3-} {E':eq N3 (s N3-)}\n\ttrue.\n\n- : plus-right-preserves-positive N1+N2=N3 N2=sN2- N3- N3=sN3-\n    <- plus-respects-eq N1+N2=N3 eq/ N2=sN2- eq/ N1+sN2-=N3\n    <- plus-right-decrease N1+sN2-=N3 N3- N3=sN3- _.\n\n%worlds () (plus-right-preserves-positive N1+N2=N3 N2+  N3- N3+).\n%total {} (plus-right-preserves-positive _ _ _ _).\n\n\n%theorem plus-is-zero-implies-zero :\n\tforall* {N1} {N2} {N3}\n\tforall {P:plus N1 N2 N3} {E3:eq N3 z}\n        exists {E1:eq N1 z} {E2:eq N2 z}\n\ttrue.\n\n- : plus-is-zero-implies-zero plus/z eq/ eq/ eq/.\n\n%worlds () (plus-is-zero-implies-zero X+Y=Z Z=0  X=0 Y=0).\n%total {} (plus-is-zero-implies-zero _ _ _ _).\n\n\n%theorem plus-commutative: \n\tforall* {N1} {N2} {N12}\n        forall {P:plus N1 N2 N12}\n\texists {Q:plus N2 N1 N12}\n\ttrue.\n\n- : plus-commutative (plus/z) N2+z=N2\n    <- plus-right-identity N2 N2+z=N2.\n\n- : plus-commutative (plus/s N1+N2=N3) N2+sN1=sN3\n    <- plus-commutative N1+N2=N3 N2+N1=N3\n    <- plus-right-increase N2+N1=N3 N2+sN1=sN3.\n\n%worlds () (plus-commutative N1+N2=N3  N2+N1=N3).\n%total P (plus-commutative P _).\n\n\n%theorem plus-associative :\n\tforall* {X:nat} {Y:nat} {Z:nat} {X':nat} {Z':nat}\n        forall {P1:plus X Y X'} {P2:plus X' Z Z'}\n\texists {Y':nat} {Q1:plus Y Z Y'} {Q2:plus X Y' Z'}\n\ttrue.\n\n- : plus-associative plus/z (P2:plus N2 N3 N23) N23 P2 plus/z.\n\n- : plus-associative (plus/s N1+N2=N12) (plus/s N12+N3=N123) \n                     N23 N2+N3=N23 (plus/s N1+N23=N123)\n    <- plus-associative N1+N2=N12 N12+N3=N123 N23 N2+N3=N23 N1+N23=N123.\n\n%worlds () (plus-associative _ _ _ _ _).\n%total P1 (plus-associative P1 _ _ _ _).\n\n\n%theorem plus-associative* :\n\tforall* {X1} {X2} {X12} {X3} {X23} {X123}\n        forall {OP12:plus X1 X2 X12} {OP12-3:plus X12 X3 X123} {OP23:plus X2 X3 X23}\n        exists {OP1-23:plus X1 X23 X123}\n        true.\n\n- : plus-associative* X1+X2=X3 X3+X4=X7 X2+X4=X6 X1+X6=X7\n    <- plus-associative X1+X2=X3 X3+X4=X7 Y6 X2+X4=Y6 X1+Y6=X7\n    <- plus-deterministic X2+X4=Y6 X2+X4=X6 eq/ eq/ Y6=X6\n    <- plus-respects-eq X1+Y6=X7 eq/ Y6=X6 eq/ X1+X6=X7.\n\n%worlds () (plus-associative* _ _ _ _).\n%total {} (plus-associative* _ _ _ _).\n\n\n%theorem plus-associative-converse :\n\tforall* {X1} {X2} {X4} {X6} {X7}\n\tforall {OP24:plus X2 X4 X6} {OP16:plus X1 X6 X7}\n        exists {X3} {OP12:plus X1 X2 X3} {OP34:plus X3 X4 X7}\n        true.\n\n- : plus-associative-converse X2+X4=X6 X1+X6=X7 _ X1+X2=X3 X3+X4=X7\n    <- plus-commutative X2+X4=X6 X4+X2=X6\n    <- plus-commutative X1+X6=X7 X6+X1=X7\n    <- plus-associative X4+X2=X6 X6+X1=X7 _ X2+X1=X3 X4+X3=X7\n    <- plus-commutative X2+X1=X3 X1+X2=X3\n    <- plus-commutative X4+X3=X7 X3+X4=X7.\n\n%worlds () (plus-associative-converse X2+X4=X6 X1+X6=X7 X3 X1+X2=X3 X3+X4=X7).\n%total {} (plus-associative-converse _ _ _ _ _).\n\n\n%theorem plus-associative-converse* :\n\tforall* {X1} {X2} {X3} {X4} {X6} {X7}\n\tforall {OP24:plus X2 X4 X6} {OP16:plus X1 X6 X7} {OP12:plus X1 X2 X3} \n\texists {OP34:plus X3 X4 X7}\n        true.\n\n- : plus-associative-converse* X2+X4=X6 X1+X6=X7 X1+X2=X3 X3+X4=X7\n    <- plus-associative-converse X2+X4=X6 X1+X6=X7 X3P X1+X2=X3P X3P+X4=X7\n    <- plus-deterministic X1+X2=X3P X1+X2=X3 eq/ eq/ X3P=X3\n    <- plus-respects-eq X3P+X4=X7 X3P=X3 eq/ eq/ X3+X4=X7.\n\n%worlds () (plus-associative-converse* X2+X4=X6 X1+X6=X7 X1+X2=X3  X3+X4=X7).\n%total {} (plus-associative-converse* _ _ _ _).\n\n%% The following two theorems are useful for reordering elements\n%% is a left-associative sequence of operations.\n\n%theorem plus-assoc-commutative* :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X7}\n\tforall {OP1:plus X1 X2 X3} {OP2:plus X3 X4 X7}\n               {OP3:plus X1 X4 X5} \n        exists {OP4:plus X5 X2 X7}\n\ttrue.\n\n- : plus-assoc-commutative* X1+X2=X3 X3+X4=X7 X1+X4=X5 X5+X2=X7\n    <- plus-associative X1+X2=X3 X3+X4=X7 X6 X2+X4=X6 X1+X6=X7\n    <- plus-commutative X2+X4=X6 X4+X2=X6\n    <- plus-associative-converse* X4+X2=X6 X1+X6=X7 X1+X4=X5 X5+X2=X7.\n\n%worlds () (plus-assoc-commutative* X1+X2=X3 X3+X4=X7 X1+X4=X5  X5+X2=X7).\n%total {} (plus-assoc-commutative* _ _ _ _).\n\n\n%theorem plus-assoc-commutative :\n\tforall* {X1} {X2} {X3} {X4} {X7}\n\tforall {OP1:plus X1 X2 X3} {OP2:plus X3 X4 X7}\n        exists {X5} {OP3:plus X1 X4 X5} {OP4:plus X5 X2 X7}\n\ttrue.\n\n- : plus-assoc-commutative X1+X2=X3 X3+X4=X7 X5 X1+X4=X5 X5+X2=X7\n    <- plus-associative X1+X2=X3 X3+X4=X7 X6 X2+X4=X6 X1+X6=X7\n    <- plus-commutative X2+X4=X6 X4+X2=X6\n    <- plus-associative-converse X4+X2=X6 X1+X6=X7 X5 X1+X4=X5 X5+X2=X7.\n\n%worlds () (plus-assoc-commutative X1+X2=X3 X3+X4=X7  X5 X1+X4=X5 X5+X2=X7).\n%total {} (plus-assoc-commutative _ _ _ _ _).\n\n%% The following theorem is a useful shortcut to\n%% re-associate (AB)(CD) to (AC)(BD):\n\n%theorem plus-double-associative* :\n\tforall* {A} {B} {C} {D} {A+B} {C+D} {A+C} {B+D} {X}\n\tforall {AB:plus A B A+B} {CD:plus C D C+D} {ABCD:plus A+B C+D X}\n\t       {AC:plus A C A+C} {BD:plus B D B+D} \n        exists {ACBD:plus A+C B+D X}\n\ttrue.\n\n- : plus-double-associative* X1+X2=X3 X4+X8=XC X3+XC=XF X1+X4=X5 X2+X8=XA X5+XA=XF\n    <- plus-associative X1+X2=X3 X3+XC=XF XE X2+XC=XE X1+XE=XF\n    <- plus-commutative X4+X8=XC X8+X4=XC\n    <- plus-associative-converse* X8+X4=XC X2+XC=XE X2+X8=XA XA+X4=XE\n    <- plus-commutative XA+X4=XE X4+XA=XE\n    <- plus-associative-converse* X4+XA=XE X1+XE=XF X1+X4=X5 X5+XA=XF.\n\n%worlds () (plus-double-associative* X1+X2=X3 X4+X8=XC X3+XC=XF X1+X4=X5 X2+X8=XA\n                             X5+XA=XF).\n%total {} (plus-double-associative* _ _ _ _ _ _).\n\n\n%theorem plus-double-associative :\n\tforall* {A} {B} {C} {D} {A+B} {C+D} {X}\n\tforall {AB:plus A B A+B} {CD:plus C D C+D} {ABCD:plus A+B C+D X}\n\texists {A+C} {B+D} {AC:plus A C A+C} {BD:plus B D B+D} \n               {ACBD:plus A+C B+D X}\n\ttrue.\n\n- : plus-double-associative X1+X2=X3 X4+X8=XC X3+XC=XF X5 XA X1+X4=X5 X2+X8=XA X5+XA=XF\n    <- plus-associative X1+X2=X3 X3+XC=XF XE X2+XC=XE X1+XE=XF\n    <- plus-commutative X4+X8=XC X8+X4=XC\n    <- plus-associative-converse X8+X4=XC X2+XC=XE XA X2+X8=XA XA+X4=XE\n    <- plus-commutative XA+X4=XE X4+XA=XE\n    <- plus-associative-converse X4+XA=XE X1+XE=XF X5 X1+X4=X5 X5+XA=XF.\n\n%worlds () (plus-double-associative _ _ _ _ _ _ _ _).\n%total { } (plus-double-associative _ _ _ _ _ _ _ _).\n\n%theorem plus-left-cancels : \n\tforall* {X1:nat} {X2:nat} {Y:nat} {Z:nat} {S1:nat} {S2:nat}\n        forall {P1:plus X1 Y S1} {P2:plus X2 Z S2} \n               {EX:eq X1 X2} {ES:eq S1 S2}\n\texists {F:eq Y Z}\n        true.\n\n- : plus-left-cancels plus/z plus/z eq/ eq/ eq/.\n\n- : plus-left-cancels (plus/s X+Y1=Z) (plus/s X+Y2=Z) eq/ eq/ Y1=Y2\n    <- plus-left-cancels X+Y1=Z X+Y2=Z eq/ eq/ Y1=Y2.\n\n%worlds () (plus-left-cancels X1+Y1=Z1 X2+Y2=Z2 X1=X2 Z1=Z2  Y1=Y2).\n%total P1 (plus-left-cancels P1 _ _ _ _).\n\n\n%theorem plus-right-cancels* : \n\tforall* {X:nat} {Y:nat} {Z1:nat} {Z2:nat}\n        forall {S1} {S2}\n               {P1:plus X Z1 S1} {P2:plus Y Z2 S2}\n\t       {EZ:eq Z1 Z2} {ES:eq S1 S2}\n\texists {F:eq X Y}\n        true.\n\n- : plus-right-cancels* Z Z X1+0=Z X2+0=Z eq/ eq/ X1=X2\n    <- plus-right-identity X1 X1+0=X1\n    <- plus-deterministic X1+0=X1 X1+0=Z eq/ eq/ X1=Z\n    <- plus-right-identity X2 X2+0=X2\n    <- plus-deterministic X2+0=X2 X2+0=Z eq/ eq/ X2=Z\n    <- eq-symmetric X2=Z Z=X2\n    <- eq-transitive X1=Z Z=X2 X1=X2.\n\n- : {sZ'=Z:eq (s Z') Z} {sZ'=sZ'':eq (s Z') (s Z'')}\n    plus-right-cancels* Z Z X1+sY=Z X2+sY=Z eq/ eq/ X1=X2\n    <- plus-right-decrease X1+sY=Z Z' Z=sZ' X1+Y=Z'\n    <- plus-right-decrease X2+sY=Z Z'' Z=sZ'' X2+Y=Z''\n    <- eq-symmetric Z=sZ' sZ'=Z\n    <- eq-transitive sZ'=Z Z=sZ'' sZ'=sZ''\n    <- succ-cancels sZ'=sZ'' Z'=Z''\n    <- meta-eq Z (s Z') Z=sZ'\n    <- plus-right-cancels* Z' Z'' X1+Y=Z' X2+Y=Z'' eq/ Z'=Z'' X1=X2.\n\n%worlds () (plus-right-cancels* Z1 Z2 X1+Y1=Z1 X2+Y2=Z2 Y1=Y2 Z1=Z2  X1=X2).\n%total Z (plus-right-cancels* Z _ _ _ _ _ _).\n\n\n%abbrev plus-right-cancels = plus-right-cancels* _ _.\n\n\n%theorem plus-left-preserves-gt*:\n        forall* {M} {N1} {N2} {O1} {O2}\n        forall {G1:gt N1 N2} {P1:plus M N1 O1} {P2:plus M N2 O2}\n        exists {G2:gt O1 O2}\n        true.\n\n- : plus-left-preserves-gt* N1>N2 plus/z plus/z N1>N2.\n\n- : plus-left-preserves-gt* N1>N2 (plus/s M+N1=O1) (plus/s M+N2=O2) SO1>SO2\n    <- plus-left-preserves-gt* N1>N2 M+N1=O1 M+N2=O2 O1>O2\n    <- succ-preserves-gt O1>O2 SO1>SO2.\n\n%worlds () (plus-left-preserves-gt* N1>N2 M+N1=O1 M+N2=O2  O1>O2).\n%total P1 (plus-left-preserves-gt* _ P1 _ _).\n\n\n%theorem plus-left-cancels-gt : \n        forall* {X1:nat} {X2:nat} {Y:nat} {Z:nat} {S1:nat} {S2:nat}\n        forall {P1:plus X1 Y S1} {P2:plus X2 Z S2} \n               {EX:eq X1 X2} {G1:gt S1 S2}\n\texists {G2:gt Y Z}\n        true.\n\n- : plus-left-cancels-gt plus/z plus/z eq/ G G.\n\n- : plus-left-cancels-gt (plus/s X+Y1=Z1) (plus/s X+Y2=Z2) eq/ SZ1>SZ2 Y1>Y2\n    <- succ-preserves-gt-converse SZ1>SZ2 Z1>Z2\n    <- plus-left-cancels-gt X+Y1=Z1 X+Y2=Z2 eq/ Z1>Z2 Y1>Y2.\n\n%worlds () (plus-left-cancels-gt X1+Y1=Z1 X2+Y2=Z2 X1=X2 Z1>Z2  Y1>Y2).\n%total P1 (plus-left-cancels-gt P1 _ _ _ _).\n\n\n\n%theorem plus-left-preserves-gt :\n\tforall* {X1} {X2} {X4}\n      \tforall {G:gt X2 X4}\n\texists {X3} {X5}\n               {O1:plus X1 X2 X3} {O2:plus X1 X4 X5}\n      \t       {G2:gt X3 X5}\n\ttrue.\n\n- : plus-left-preserves-gt X2>X4 X3 X5 X1+X2=A3 X1+X4=X5 X3>X5\n    <- plus-total X1+X2=A3 \n    <- plus-total X1+X4=X5\n    <- plus-left-preserves-gt* X2>X4 X1+X2=A3 X1+X4=X5 X3>X5.\n\n%worlds () (plus-left-preserves-gt X2>X4  X3 X5 X1+X2=A3 X1+X4=X5 X3>X5).\n%total {} (plus-left-preserves-gt _ _ _ _ _ _).\n\n\n%theorem plus-right-preserves-gt* :\n\tforall* {X1} {X2} {X3} {X4} {X5}\n\tforall {G1:gt X1 X2} {O1:plus X1 X3 X4} {O2:plus X2 X3 X5}\n\texists {G2:gt X4 X5}\n\ttrue.\n\n- : plus-right-preserves-gt* X1>X2 X1+X3=X4 X2+X3=X5 X4>X5\n    <- plus-commutative X1+X3=X4 X3+X1=X4\n    <- plus-commutative X2+X3=X5 X3+X2=X5\n    <- plus-left-preserves-gt* X1>X2 X3+X1=X4 X3+X2=X5 X4>X5.\n\n%worlds () (plus-right-preserves-gt* X1>X2 X1+X3=X4 X2+X3=X5  X4>X5).\n%total {} (plus-right-preserves-gt* _ _ _ _).\n\n\n%theorem plus-right-preserves-gt :\n\tforall* {X1} {X2} {X3}\n\tforall {G1:gt X1 X2} \n\texists {X4} {X5} {O1:plus X1 X3 X4} {O2:plus X2 X3 X5} {G2:gt X4 X5}\n\ttrue.\n\n- : plus-right-preserves-gt X1>X2 X4 X5 X1+X3=X4 X2+X3=X5 X4>X5\n    <- plus-total X1+X3=X4 \n    <- plus-total X2+X3=X5\n    <- plus-right-preserves-gt* X1>X2 X1+X3=X4 X2+X3=X5 X4>X5.\n%worlds () (plus-right-preserves-gt X1>X2  X4 X5 X1+X3=X4 X2+X3=X5 X4>X5).\n%total {} (plus-right-preserves-gt _ _ _ _ _ _).\n\n\n%theorem plus-preserves-gt* :\n\tforall* {X1} {X2} {X3} {Y1} {Y2} {Y3}\n\tforall {G1:gt X1 Y1} {G2:gt X2 Y2}\n               {MX:plus X1 X2 X3} {MY:plus Y1 Y2 Y3}\n        exists {G3:gt X3 Y3}\n\ttrue.\n\n- : plus-preserves-gt* X1>Y1 X2>Y2 X1+X2=X3 Y1+Y2=Y3 X3>Y3\n    <- plus-total Y1+X2=X\n    <- plus-right-preserves-gt* X1>Y1 X1+X2=X3 Y1+X2=X X3>X\n    <- plus-left-preserves-gt* X2>Y2 Y1+X2=X Y1+Y2=Y3 X>Y3\n    <- gt-transitive X3>X X>Y3 X3>Y3.\n\n%worlds () (plus-preserves-gt* X1>Y1 X2>Y2 X1+X2=X3 Y1+Y2=Y3  X3>Y3).\n%total {} (plus-preserves-gt* _ _ _ _ _).\n\n\n%theorem plus-preserves-gt :\n\tforall* {X1} {X2} {Y1} {Y2}\n\tforall {G1:gt X1 Y1} {G2:gt X2 Y2}\n\texists {X3} {Y3} {MX:plus X1 X2 X3} {MY:plus Y1 Y2 Y3} {G3:gt X3 Y3}\n\ttrue.\n\n- : plus-preserves-gt X1>Y1 X2>Y2 X3 Y3 X1+X2=X3 Y1+Y2=Y3 X3>Y3\n    <- plus-total X1+X2=X3\n    <- plus-total Y1+Y2=Y3\n    <- plus-preserves-gt* X1>Y1 X2>Y2 X1+X2=X3 Y1+Y2=Y3 X3>Y3.\n\n%worlds () (plus-preserves-gt X1>Y1 X2>Y2  X3 Y3 X1+X2=X3 Y1+Y2=Y3 X3>Y3).\n%total {} (plus-preserves-gt _ _ _ _ _ _ _).\n\n\n%theorem plus-right-cancels-gt :\n\tforall* {X1} {X2} {X3} {Y1} {Y2} {Y3}\n\tforall {OP1:plus X1 X2 X3} {OP2:plus Y1 Y2 Y3} {E2:eq X2 Y2} {G3:gt X3 Y3} \n\texists {G1:gt X1 Y1}\n\ttrue.\n\n- : plus-right-cancels-gt X1+X2=X3 Y1+Y2=Y3 X2=Y2 X3>Y3 X1>Y1\n    <- plus-commutative X1+X2=X3 X2+X1=X3\n    <- plus-commutative Y1+Y2=Y3 Y2+Y1=Y3\n    <- plus-left-cancels-gt X2+X1=X3 Y2+Y1=Y3 X2=Y2 X3>Y3 X1>Y1.\n\n%worlds () (plus-right-cancels-gt X1+X2=X3 Y1+Y2=Y3 X2=Y2 X3>Y3  X1>Y1).\n%total {} (plus-right-cancels-gt _ _ _ _ _).\n\n\n%theorem plus-implies-gt:\n        forall* {M} {N} {O} {M'}\n        forall {P:plus M N O} {E:eq M (s M')}\n        exists {G:gt O N}\n        true.\n\n- : plus-implies-gt X+Y=Z eq/ Z>Y\n    <- succ-implies-gt-zero _ X>0\n    <- plus-right-preserves-gt* X>0 X+Y=Z plus/z Z>Y.\n\n%worlds () (plus-implies-gt X+Y=Z X=sX'  Z>Y).\n%total {} (plus-implies-gt _ _ _).\n\n\n%theorem plus-gt-contradiction :\n\tforall* {M} {N} {O}\n\tforall {P:plus M N O} {G:gt M O}\n\texists {F:void}\n\ttrue.\n\n- : plus-gt-contradiction M+0=O M>O F\n    <- plus-right-identity _ M+0=M\n    <- plus-deterministic M+0=O M+0=M eq/ eq/ O=M\n    <- gt-respects-eq M>O eq/ O=M M>M\n    <- gt-anti-reflexive M>M F.\n\n- : plus-gt-contradiction M+N=O M>O F   % N > 0\n    <- plus-commutative M+N=O N+M=O\n    <- plus-implies-gt N+M=O eq/ O>M\n    <- gt-anti-symmetric M>O O>M F.\n\n%worlds () (plus-gt-contradiction M+N=O M>O  _).\n%total {} (plus-gt-contradiction _ _ _).\n\n\n\n%%% Theorems about times\n\n\n%theorem false-implies-times :\n\tforall* {M} {N} {O}\n\tforall {P:void}\n        exists {Q:times M N O}\n\ttrue.\n\n%worlds () (false-implies-times _ _).\n%total {} (false-implies-times _ _).\n\n\t\t    \n%theorem times-respects-eq: \n\tforall* {M1:nat} {M2:nat} {N1:nat} {N2:nat} {P1:nat} {P2:nat}\n        forall {P:times M1 N1 P1} \n               {E1:eq M1 M2} {E2:eq N1 N2} {E3:eq P1 P2}\n        exists {Q:times M2 N2 P2}\n\ttrue.\n\n- : times-respects-eq M1*N1=P1 eq/ eq/ eq/ M1*N1=P1.\n\n%worlds () (times-respects-eq M1*N1=P1 M1=M2 N1=N2 P1=P2  M2*N2=P2).\n%total {} (times-respects-eq _ _ _ _ _).\n\n\n%theorem times-total* : \n\tforall {N1:nat} {N2:nat}\n        exists {N3:nat} {T:times N1 N2 N3}\n\ttrue.\n\n- : times-total* z N2 z times/z.\n\n- : times-total* (s X) Y Z (times/s X*Y=Z' Z'+Y=Z)\n    <- times-total* X Y Z' X*Y=Z'\n    <- plus-total Z'+Y=Z.\n\n%worlds () (times-total* N1 N2  N3 N1*N2=N3).\n%total (N1) (times-total* N1 _ _ _).\n\n\n%abbrev times-total = times-total* _ _ _.\n\n\n%theorem times-deterministic :\n        forall* {N1:nat} {N1':nat} {N2:nat} {N2':nat} {N3:nat} {N3':nat}\n        forall {P:times N1 N2 N3} {P':times N1' N2' N3'}\n               {E1:eq N1 N1'} {E2:eq N2 N2'}\n        exists {E3:eq N3 N3'}\n        true.\n\n- : times-deterministic (times/z) (times/z) eq/ eq/ eq/.\n\n- : times-deterministic (times/s X*Y=Z1 Z1+Y=Z1') \n                        (times/s X*Y=Z2 Z2+Y=Z2') eq/ eq/ Z1'=Z2'\n    <- times-deterministic X*Y=Z1 X*Y=Z2 eq/ eq/ Z1=Z2\n    <- plus-deterministic Z1+Y=Z1' Z2+Y=Z2' Z1=Z2 eq/ Z1'=Z2'.\n\n%worlds () (times-deterministic X1*Y1=Z1 X2*Y2=Z2 X1=X2 Y1=Y2  Z1=Z2).\n%total P (times-deterministic P _ _ _ _).\n\n\n%theorem times-left-identity : \n\tforall {N:nat}\n\texists {T:times (s z) N N}\n\ttrue.\n\n- : times-left-identity N (times/s (times/z) plus/z).\n\n%worlds () (times-left-identity N  ONE*N=N).\n%total {} (times-left-identity _ _).\n\n\n%theorem times-right-identity : \n\tforall {N:nat}\n\texists {T:times N (s z) N}\n\ttrue.\n\n- : times-right-identity z times/z.\n\n- : times-right-identity (s M) (times/s M*1=M M+1=sM)\n    <- times-right-identity M M*1=M\n    <- plus-right-identity M M+0=M\n    <- plus-right-increase M+0=M M+1=sM.\n\n%worlds () (times-right-identity N  N*1=N).\n%total M (times-right-identity M _).\n\n\n%theorem times-right-zero : forall {N:nat}\n        exists {T:times N z z}\n \ttrue.\n\n- : times-right-zero z times/z.\n\n- : times-right-zero (s M) (times/s M*0=0 plus/z)\n  <- times-right-zero M M*0=0.\n\n%worlds () (times-right-zero N  N*0=0).\n%total M (times-right-zero M _).\n\n\n%theorem times-preserves-positive: \n\tforall {M} {N}\n        exists {P} {T:times (s M) (s N) (s P)}\n        true.\n\n-: {T1:times M (s N) O} {P1:plus O (s N) (s P)} {P2:plus O N P}\n       times-preserves-positive M N P (times/s T1 P1)\n    <- times-total T1\n    <- plus-total P2\n    <- plus-right-increase P2 P1.\n\n%worlds () (times-preserves-positive M N  P SM*SN=SP).\n%total {} (times-preserves-positive _ _ _ _).\n\n\n%theorem times-preserves-positive*:\n        forall* {M} {N} {P} {M'} {N'}\n        forall {T:times M N P} {M+:eq M (s M')} {N+:eq N (s N')}\n        exists {P'} {P+:eq P (s P')}\n        true.\n\n- : times-preserves-positive* M*N=P M=sM' N=sN' P' P=sP'\n    <- times-respects-eq M*N=P M=sM' N=sN' eq/ (times/s M'*sN'=O' O'+sN'=P)\n    <- plus-right-decrease O'+sN'=P P' P=sP' _.\n\n%worlds () (times-preserves-positive* M*N=P M=sM' N=sN'  P' P=sP').\n%total {} (times-preserves-positive* _ _ _ _ _).\n\n\n%theorem times-positive-implies-positive :\n\tforall* {M} {N} {P} {P'}\n\tforall {T:times M N P} {P+:eq P (s P')}\n        exists {M'} {M+:eq M (s M')} {N'}  {N+:eq N (s N')}\n\ttrue.\n\n- : times-positive-implies-positive (times/s M'*N=T plus/z) \n                                    eq/ M' eq/ P' eq/.\n\n- : times-positive-implies-positive (times/s M'*N=sT' (plus/s T'+N=P'))\n                                    eq/ M' eq/ N' N=sN'\n    <- times-positive-implies-positive M'*N=sT' eq/ _ _ N' N=sN'.\n\n%worlds () (times-positive-implies-positive M*N=P P=sP'  M' M=sM' N' N=sN').\n%total T (times-positive-implies-positive T _ _ _ _ _).\n\n\n%theorem times-left-increase :\n\tforall* {M} {N} {O} {X}\n\tforall {T:times M N O} {P:plus O N X}\n        exists {U:times (s M) N X}\n\ttrue.\n\n- : times-left-increase T P (times/s T P).\n\n%worlds () (times-left-increase M*N=O O+N=X  SM*N=X).\n%total {} (times-left-increase _ _ _).\n\n\n%theorem times-right-increase : \n\tforall* {M:nat} {N:nat} {O:nat} {X:nat}\n \tforall {T:times M N O} {P:plus M O X}\n\texists {U:times M (s N) X}\n\ttrue.\n\n- : times-right-increase times/z plus/z times/z.\n\n- : {M*N=O:times M N O} {M+O=Z:plus M O Z}\n    times-right-increase (times/s M*N=O O+N=O1) (plus/s M+O1=Y)\n                         (times/s M*sN=Z Z+sN=sY)\n    <- plus-associative-converse O+N=O1 M+O1=Y Z M+O=Z Z+N=Y\n    <- times-right-increase M*N=O M+O=Z M*sN=Z\n    <- plus-right-increase Z+N=Y Z+sN=sY.\n\n%worlds () (times-right-increase M*N=O M+O=X  M*sN=X).\n%total T (times-right-increase T _ _).\n\n\n%theorem times-left-decrease :\n\tforall* {X} {Y} {Z}\n\tforall {T1:times (s X) Y Z}\n\texists {Z1} {T2:times X Y Z1} {P:plus Z1 Y Z}\n        true.\n\n- : times-left-decrease (times/s T P) _ T P.\n\n%worlds () (times-left-decrease SX*Y=Z Z1 X*Y=Z1 Z1+Y=Z).\n%total {} (times-left-decrease _ _ _ _).\n\n\n%theorem times-right-decrease :\n\tforall* {M} {N} {X}\n\tforall {T:times M (s N) X}\n        exists {O} {U:times M N O} {P:plus M O X}\n\ttrue.\n\n- : times-right-decrease times/z z times/z plus/z.\n\n- : times-right-decrease (times/s M*sN=Y Y+sN=X) O (times/s M*N=P P+N=O) SM+O=X\n    <- times-right-decrease M*sN=Y P M*N=P M+P=Y \n    <- plus-total P+N=O\n    <- plus-right-increase P+N=O P+sN=sO\n    <- plus-associative* M+P=Y Y+sN=X P+sN=sO M+sO=X\n    <- plus-swap-succ-converse M+sO=X SM+O=X.\n\n%worlds () (times-right-decrease M*sN=X  O M*N=O M+O=X).\n%total (T) (times-right-decrease T _ _ _).\n\n\n%theorem times-commutative : \n\tforall* {N1} {N2} {N3}\n        forall {T:times N1 N2 N3}\n \texists {U:times N2 N1 N3}\n\ttrue.\n\n- : times-commutative times/z T\n    <- (times-right-zero N2 T).\n\n- : {T1: times N1' N2 N3'} {P2: plus N3' N2 N3}\n               {T1c: times N2 N1' N3'} {P2c: plus N2 N3' N3}\n\t       {Tc: times N2 (s N1') N3}\n       times-commutative (times/s T1 P2) Tc\n    <- plus-commutative P2 P2c\n    <- times-commutative T1 T1c\n    <- times-right-increase T1c P2c Tc.\n\n%worlds () (times-commutative N1*N2=N3  N2*N1=N3).\n%total T (times-commutative T _).\n\n\n%theorem times-right-distributes-over-plus : \n       forall* {N1} {N2} {N3} {N12} {N123}\n       forall {P1:plus N1 N2 N12} {T1:times N12 N3 N123}\n       exists {N13} {N23} {T13:times N1 N3 N13}\n              {T23:times N2 N3 N23} {P123:plus N13 N23 N123}\n       true.\n\n- : times-right-distributes-over-plus plus/z Y*Z=YZ z YZ times/z Y*Z=YZ plus/z.\n\n- : times-right-distributes-over-plus (plus/s X+Y=XY) (times/s XY*Z=XYZ XYZ+Z=SXYZ)\n                                      SXZ YZ (times/s X*Z=XZ XZ+Z=SXZ) Y*Z=YZ\n                                      SXZ+YZ=SXYZ\n    <- times-right-distributes-over-plus X+Y=XY XY*Z=XYZ \n                                         XZ YZ X*Z=XZ Y*Z=YZ XZ+YZ=XYZ\n    <- plus-commutative XZ+YZ=XYZ YZ+XZ=XYZ\n    <- plus-associative YZ+XZ=XYZ XYZ+Z=SXYZ SXZ XZ+Z=SXZ YZ+SXZ=SXYZ\n    <- plus-commutative YZ+SXZ=SXYZ SXZ+YZ=SXYZ.\n\n%worlds () (times-right-distributes-over-plus X+Y=XY XY*Z=XYZ \n\t                                XZ YZ X*Z=XZ Y*Z=YZ XZ+YZ=XYZ).\n%total (P) (times-right-distributes-over-plus P _ _ _ _ _ _).\n\n\n\n%theorem times-right-distributes-over-plus* :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X6} {X7}\n        forall {A12:plus X1 X2 X3} {M34:times X3 X4 X7}\n               {M14:times X1 X4 X5} {M24:times X2 X4 X6}\n        exists {A56:plus X5 X6 X7}\n\ttrue.\n\n- : times-right-distributes-over-plus* X1+X2=X3 X3*X4=X7 X1*X4=X5 X2*X4=X6 X5+X6=X7\n    <- times-right-distributes-over-plus X1+X2=X3 X3*X4=X7 Y5 Y6\n                                      X1*X4=Y5 X2*X4=Y6 Y5+Y6=X7\n    <- times-deterministic X1*X4=Y5 X1*X4=X5 eq/ eq/ Y5=X5\n    <- times-deterministic X2*X4=Y6 X2*X4=X6 eq/ eq/ Y6=X6\n    <- plus-respects-eq Y5+Y6=X7 Y5=X5 Y6=X6 eq/ X5+X6=X7.\n\n%worlds () (times-right-distributes-over-plus* X1+X2=X3 X3*X4=X7 X1*X4=X5 X2*X4=X6\n                                       X5+X6=X7).\n%total {} (times-right-distributes-over-plus* _ _ _ _ _).\n\n\n%theorem times-left-distributes-over-plus* :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X6} {X7}\n        forall {A12:plus X2 X4 X6} {M34:times X1 X6 X7}\n               {M14:times X1 X2 X3} {M24:times X1 X4 X5}\n        exists {A56:plus X3 X5 X7}\n\ttrue.\n\n- : times-left-distributes-over-plus* X2+X4=X6 X1*X6=X7 X1*X2=X3 X1*X4=X5 X3+X5=X7\n    <- times-commutative X1*X6=X7 X6*X1=X7\n    <- times-commutative X1*X2=X3 X2*X1=X3\n    <- times-commutative X1*X4=X5 X4*X1=X5\n    <- times-right-distributes-over-plus* X2+X4=X6 X6*X1=X7 X2*X1=X3 X4*X1=X5\n                                       X3+X5=X7.\n\n%worlds () (times-left-distributes-over-plus* X2+X4=X6 X1*X6=X7 X1*X2=X3 X1*X4=X5\n                                     X3+X5=X7).\n%total {} (times-left-distributes-over-plus* _ _ _ _ _).\n\n\n%theorem times-left-distributes-over-plus :\n\tforall* {X1} {X2} {X4} {X6} {X7}\n        forall {A12:plus X2 X4 X6} {M34:times X1 X6 X7}\n        exists {X3} {X5} {M14:times X1 X2 X3} {M24:times X1 X4 X5}\n               {A56:plus X3 X5 X7}\n\ttrue.\n\n- : times-left-distributes-over-plus X2+X4=X6 X1*X6=X7 \n                                  X3 X5 X1*X2=X3 X1*X4=X5 X3+X5=X7\n    <- times-total X1*X2=X3\n    <- times-total X1*X4=X5\n    <- times-left-distributes-over-plus* X2+X4=X6 X1*X6=X7 X1*X2=X3 X1*X4=X5\n                                      X3+X5=X7.\n\n%worlds () (times-left-distributes-over-plus X2+X4=X6 X1*X6=X7 \n                                    X3 X5 X1*X2=X3 X1*X4=X5 X3+X5=X7).\n%total {} (times-left-distributes-over-plus _ _ _ _ _ _ _).\n\n\n%theorem times-right-factors-over-plus :\n\tforall* {X1} {X2} {X4} {X5} {X6} {X7}\n        forall {M14:times X1 X4 X5} {M24:times X2 X4 X6} {A56:plus X5 X6 X7}\n        exists {X3} {A12:plus X1 X2 X3} {M34:times X3 X4 X7}\n\ttrue.\n- : times-right-factors-over-plus X1*X4=X5 X2*X4=X6 X5+X6=X7 X3 X1+X2=X3 X3*X4=X7\n    <- plus-total X1+X2=X3\n    <- times-total X3*X4=Y7\n    <- times-right-distributes-over-plus* X1+X2=X3 X3*X4=Y7 X1*X4=X5 X2*X4=X6 \n                                       X5+X6=Y7\n    <- plus-deterministic X5+X6=Y7 X5+X6=X7 eq/ eq/ Y7=X7\n    <- times-respects-eq X3*X4=Y7 eq/ eq/ Y7=X7 X3*X4=X7.\n\n%worlds () (times-right-factors-over-plus X1*X4=X5 X2*X4=X6 X5+X6=X7\n                                 X3 X1+X2=X3 X3*X4=X7 ).\n%total {} (times-right-factors-over-plus _ _ _ _ _ _).\n\n\n%theorem times-right-factors-over-plus* :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X6} {X7}\n        forall {M14:times X1 X4 X5} {M24:times X2 X4 X6} {A56:plus X5 X6 X7}\n               {A12:plus X1 X2 X3} \n        exists {M34:times X3 X4 X7}\n\ttrue.\n\n- : times-right-factors-over-plus* X1*X4=X5 X2*X4=X6 X5+X6=X7 X1+X2=X3 X3*X4=X7\n    <- times-total X3*X4=Y7\n    <- times-right-distributes-over-plus* X1+X2=X3 X3*X4=Y7 X1*X4=X5 X2*X4=X6 \n                                       X5+X6=Y7\n    <- plus-deterministic X5+X6=Y7 X5+X6=X7 eq/ eq/ Y7=X7\n    <- times-respects-eq X3*X4=Y7 eq/ eq/ Y7=X7 X3*X4=X7.\n\n%worlds () (times-right-factors-over-plus* X1*X4=X5 X2*X4=X6 X5+X6=X7 X1+X2=X3\n                                  X3*X4=X7 ).\n%total {} (times-right-factors-over-plus* _ _ _ _ _).\n\n\n%theorem times-left-factors-over-plus :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X7}\n\tforall {M12:times X1 X2 X3} {M14:times X1 X4 X5} {A35:plus X3 X5 X7}\n        exists {X6} {A24:plus X2 X4 X6} {M16:times X1 X6 X7}\n        true.\n\n- : times-left-factors-over-plus X1*X2=X3 X1*X4=X5 X3+X5=X7 X6 X2+X4=X6 X1*X6=X7\n    <- times-commutative X1*X2=X3 X2*X1=X3\n    <- times-commutative X1*X4=X5 X4*X1=X5\n    <- times-right-factors-over-plus X2*X1=X3 X4*X1=X5 X3+X5=X7 X6 X2+X4=X6 X6*X1=X7\n    <- times-commutative X6*X1=X7 X1*X6=X7.\n\n%worlds () (times-left-factors-over-plus X1*X2=X3 X1*X4=X5 X3+X5=X7\n                                X6 X2+X4=X6 X1*X6=X7).\n%total {} (times-left-factors-over-plus _ _ _ _ _ _).\n\n\n%theorem times-left-factors-over-plus* :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X6} {X7}\n\tforall {M12:times X1 X2 X3} {M14:times X1 X4 X5} \n               {A35:plus X3 X5 X7} {A24:plus X2 X4 X6} \n        exists {M16:times X1 X6 X7}\n        true.\n\n- : times-left-factors-over-plus* X1*X2=X3 X1*X4=X5 X3+X5=X7 X2+X4=X6 \n                               X1*X6=X7\n    <- times-total X1*X6=Y7\n    <- times-left-distributes-over-plus* X2+X4=X6 X1*X6=Y7 X1*X2=X3 X1*X4=X5\n                                      X3+X5=Y7\n    <- plus-deterministic X3+X5=Y7 X3+X5=X7 eq/ eq/ Y7=X7\n    <- times-respects-eq X1*X6=Y7 eq/ eq/ Y7=X7 X1*X6=X7.\n\n%worlds () (times-left-factors-over-plus* X1*X2=X3 X1*X4=X5 X3+X5=X7 X2+X4=X6 \n                                X1*X6=X7).\n%total {} (times-left-factors-over-plus* _ _ _ _ _).\n\n\n%theorem times-associative: \n\tforall* {N1} {N2} {N3} {N12} {N123}\n \tforall {T1:times N1 N2 N12} {T12:times N12 N3 N123}\n\texists {N23} {T2:times N2 N3 N23} {T123:times N1 N23 N123}\n\ttrue.\n\n- : {T2:times N2 N3 N23}\n      times-associative times/z times/z N23 T2 times/z\n    <- times-total T2.\n-  : {T1:times N1' N2 N1'2} {P2:plus N1'2 N2 N12}\n                 {T3:times N12 N3 N123} {T4:times N2 N3 N23}\n\t\t {T5:times N1' N23 N1'23} {P6:plus N1'23 N23 N123}\n                 {T7:times N1'2 N3 N1'23}\n       times-associative (times/s T1 P2) T3 N23 T4 (times/s T5 P6)\n    <- times-right-distributes-over-plus P2 T3 N1'23 N23 T7 T4 P6\n    <- times-associative T1 T7 N23' T4' T5'\n    <- times-deterministic T4' T4 eq/ eq/ N23'=N23\n    <- times-respects-eq T5' eq/ N23'=N23 eq/ T5.\n\n%worlds () (times-associative _ _ _ _ _).\n%total T1 (times-associative T1 _ _ _ _).\n\n\n%theorem times-associative* :\n\tforall* {X1} {X2} {X12} {X3} {X23} {X123}\n        forall {OP12:times X1 X2 X12} {OP12-3:times X12 X3 X123} {OP23:times X2 X3 X23}\n        exists {OP1-23:times X1 X23 X123}\n        true.\n\n- : times-associative* X1*X2=X3 X3*X4=X7 X2*X4=X6 X1*X6=X7\n    <- times-associative X1*X2=X3 X3*X4=X7 Y6 X2*X4=Y6 X1*Y6=X7\n    <- times-deterministic X2*X4=Y6 X2*X4=X6 eq/ eq/ Y6=X6\n    <- times-respects-eq X1*Y6=X7 eq/ Y6=X6 eq/ X1*X6=X7.\n\n%worlds () (times-associative* _ _ _ _).\n%total {} (times-associative* _ _ _ _).\n\n\n%theorem times-associative-converse :\n\tforall* {X1} {X2} {X4} {X6} {X7}\n\tforall {OP24:times X2 X4 X6} {OP16:times X1 X6 X7}\n        exists {X3} {OP12:times X1 X2 X3} {OP34:times X3 X4 X7}\n        true.\n\n- : times-associative-converse X2*X4=X6 X1*X6=X7 _ X1*X2=X3 X3*X4=X7\n    <- times-commutative X2*X4=X6 X4*X2=X6\n    <- times-commutative X1*X6=X7 X6*X1=X7\n    <- times-associative X4*X2=X6 X6*X1=X7 _ X2*X1=X3 X4*X3=X7\n    <- times-commutative X2*X1=X3 X1*X2=X3\n    <- times-commutative X4*X3=X7 X3*X4=X7.\n\n%worlds () (times-associative-converse X2*X4=X6 X1*X6=X7 X3 X1*X2=X3 X3*X4=X7).\n%total {} (times-associative-converse _ _ _ _ _).\n\n\n%theorem times-associative-converse* :\n\tforall* {X1} {X2} {X3} {X4} {X6} {X7}\n\tforall {OP24:times X2 X4 X6} {OP16:times X1 X6 X7} {OP12:times X1 X2 X3} \n\texists {OP34:times X3 X4 X7}\n        true.\n\n- : times-associative-converse* X2*X4=X6 X1*X6=X7 X1*X2=X3 X3*X4=X7\n    <- times-associative-converse X2*X4=X6 X1*X6=X7 X3P X1*X2=X3P X3P*X4=X7\n    <- times-deterministic X1*X2=X3P X1*X2=X3 eq/ eq/ X3P=X3\n    <- times-respects-eq X3P*X4=X7 X3P=X3 eq/ eq/ X3*X4=X7.\n\n%worlds () (times-associative-converse* X2*X4=X6 X1*X6=X7 X1*X2=X3  X3*X4=X7).\n%total {} (times-associative-converse* _ _ _ _).\n\n\n%theorem times-assoc-commutative* :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X7}\n\tforall {OP1:times X1 X2 X3} {OP2:times X3 X4 X7}\n               {OP3:times X1 X4 X5} \n        exists {OP4:times X5 X2 X7}\n\ttrue.\n\n- : times-assoc-commutative* X1*X2=X3 X3*X4=X7 X1*X4=X5 X5*X2=X7\n    <- times-associative X1*X2=X3 X3*X4=X7 X6 X2*X4=X6 X1*X6=X7\n    <- times-commutative X2*X4=X6 X4*X2=X6\n    <- times-associative-converse* X4*X2=X6 X1*X6=X7 X1*X4=X5 X5*X2=X7.\n\n%worlds () (times-assoc-commutative* X1*X2=X3 X3*X4=X7 X1*X4=X5  X5*X2=X7).\n%total {} (times-assoc-commutative* _ _ _ _).\n\n\n%theorem times-assoc-commutative :\n\tforall* {X1} {X2} {X3} {X4} {X7}\n\tforall {OP1:times X1 X2 X3} {OP2:times X3 X4 X7}\n        exists {X5} {OP3:times X1 X4 X5} {OP4:times X5 X2 X7}\n\ttrue.\n\n- : times-assoc-commutative X1*X2=X3 X3*X4=X7 X5 X1*X4=X5 X5*X2=X7\n    <- times-associative X1*X2=X3 X3*X4=X7 X6 X2*X4=X6 X1*X6=X7\n    <- times-commutative X2*X4=X6 X4*X2=X6\n    <- times-associative-converse X4*X2=X6 X1*X6=X7 X5 X1*X4=X5 X5*X2=X7.\n\n%worlds () (times-assoc-commutative X1*X2=X3 X3*X4=X7  X5 X1*X4=X5 X5*X2=X7).\n%total {} (times-assoc-commutative _ _ _ _ _).\n\n\n%theorem times-double-associative* :\n\tforall* {A} {B} {C} {D} {A+B} {C+D} {A+C} {B+D} {X}\n\tforall {AB:times A B A+B} {CD:times C D C+D} {ABCD:times A+B C+D X}\n\t       {AC:times A C A+C} {BD:times B D B+D} \n        exists {ACBD:times A+C B+D X}\n\ttrue.\n\n- : times-double-associative* X1*X2=X3 X4*X8=XC X3*XC=XF X1*X4=X5 X2*X8=XA X5*XA=XF\n    <- times-associative X1*X2=X3 X3*XC=XF XE X2*XC=XE X1*XE=XF\n    <- times-commutative X4*X8=XC X8*X4=XC\n    <- times-associative-converse* X8*X4=XC X2*XC=XE X2*X8=XA XA*X4=XE\n    <- times-commutative XA*X4=XE X4*XA=XE\n    <- times-associative-converse* X4*XA=XE X1*XE=XF X1*X4=X5 X5*XA=XF.\n\n%worlds () (times-double-associative* X1*X2=X3 X4*X8=XC X3*XC=XF X1*X4=X5 X2*X8=XA\n                             X5*XA=XF).\n%total {} (times-double-associative* _ _ _ _ _ _).\n\n\n%theorem times-double-associative :\n\tforall* {A} {B} {C} {D} {A+B} {C+D} {X}\n\tforall {AB:times A B A+B} {CD:times C D C+D} {ABCD:times A+B C+D X}\n\texists {A+C} {B+D} {AC:times A C A+C} {BD:times B D B+D} \n               {ACBD:times A+C B+D X}\n\ttrue.\n\n- : times-double-associative X1*X2=X3 X4*X8=XC X3*XC=XF X5 XA X1*X4=X5 X2*X8=XA X5*XA=XF\n    <- times-associative X1*X2=X3 X3*XC=XF XE X2*XC=XE X1*XE=XF\n    <- times-commutative X4*X8=XC X8*X4=XC\n    <- times-associative-converse X8*X4=XC X2*XC=XE XA X2*X8=XA XA*X4=XE\n    <- times-commutative XA*X4=XE X4*XA=XE\n    <- times-associative-converse X4*XA=XE X1*XE=XF X5 X1*X4=X5 X5*XA=XF.\n\n%worlds () (times-double-associative _ _ _ _ _ _ _ _).\n%total { } (times-double-associative _ _ _ _ _ _ _ _).\n\n%theorem times-right-cancels: \n       forall* {X1} {Y1} {Z1} {X2} {Y2} {Z2} \n       forall {T1:times X1 (s Y1) Z1} {T2:times X2 (s Y2) Z2} \n              {EY:eq Y1 Y2} {EZ:eq Z1 Z2} \n       exists {EX:eq X1 X2} \n       true.\n\n- : times-right-cancels times/z times/z EY eq/ eq/.\n\n- :              {T1:times X1 (s Y1) Z1'} {P1: plus Z1' (s Y1) Z1}\n                 {T2:times X2 (s Y2) Z2'} {P2: plus Z2' (s Y2) Z2}\n                 {EY: eq Y1 Y2} {EZ: eq Z1 Z2} {EX: eq X1 X2}\n       times-right-cancels (times/s T1 P1) (times/s T2 P2) EY EZ EX'\n    <- succ-deterministic EY EY'\n    <- plus-right-cancels P1 P2 EY' EZ EZ'\n    <- times-right-cancels T1 T2 EY EZ' EX\n    <- succ-deterministic EX EX'.\n\n%worlds () (times-right-cancels X1*sY1=Z1 X2*sY2=Z2 Y1=Y2 Z1=Z2  X1=X2).\n%total T1 (times-right-cancels T1 _ _ _ _).\n\n\n%theorem times-right-cancels*: \n       forall* {X1} {Y} {Y-1} {Z1} {X2} {Z2} \n       forall {T1:times X1 Y Z1} {T2:times X2 Y Z2} \n              {EY:eq Y (s Y-1)} {EZ:eq Z1 Z2} \n       exists {EX:eq X1 X2} \n       true.\n\n- : times-right-cancels* X1*Y=Z1 X2*Y=Z2 Y+ Z1=Z2 X1=X2\n    <- times-respects-eq X1*Y=Z1 eq/ Y+ eq/ X1*Y+=Z1\n    <- times-respects-eq X2*Y=Z2 eq/ Y+ eq/ X2*Y+=Z2\n    <- times-right-cancels X1*Y+=Z1 X2*Y+=Z2 eq/ Z1=Z2 X1=X2.\n\n%worlds () (times-right-cancels* X1*Y=Z1 X2*Y=Z2 Y+ Z1=Z2  X1=X2).\n%total {} (times-right-cancels* _ _ _ _ _).\n\n\n%theorem times-right-cancels**:\n\tforall* {X1} {Y1} {Z} {X2} {Y2} {Z-}\n        forall {T1:times X1 Y1 Z} {T2:times X2 Y2 Z}\n               {EY:eq Y1 Y2} {EZ:eq Z (s Z-)}\n\texists {EX:eq X1 X2}\n\ttrue.\n\n- : times-right-cancels** X1*0=sZ X2*0=sZ eq/ eq/ X1=X2\n    <- times-right-zero _ X1*0=0\n    <- times-deterministic X1*0=0 X1*0=sZ eq/ eq/ ZERO=sZ\n    <- succ-implies-gt ZERO=sZ ZERO>sZ\n    <- gt-contradiction ZERO>sZ F\n    <- false-implies-eq F X1=X2.\n\n- : times-right-cancels** X1*Y1-=sZ X2*Y1-=sZ eq/ eq/ X1=X2\n    <- times-right-cancels X1*Y1-=sZ X2*Y1-=sZ eq/ eq/ X1=X2.\n\n%worlds () (times-right-cancels** X1*Y1=Z X2*Y2=Z Y1=Y2 Z+  X1=X2).\n%total {} (times-right-cancels** _ _ _ _ _).\n\n\n%theorem times-left-cancels : \n        forall* {X1} {Y1} {Z1} {X2} {Y2} {Z2}\n        forall {T1:times (s X1) Y1 Z1} {T2:times (s X2) Y2 Z2} \n               {E1:eq X1 X2} {E2:eq Z1 Z2} \n        exists {F:eq Y1 Y2} \n        true.\n\n- : times-left-cancels SX1*Y1=Z1 SX2*Y2=Z2 X1=X2 Z1=Z2 Y1=Y2\n    <- times-commutative SX1*Y1=Z1 Y1*sX1=Z1\n    <- times-commutative SX2*Y2=Z2 Y2*sX2=Z2\n    <- times-right-cancels Y1*sX1=Z1 Y2*sX2=Z2 X1=X2 Z1=Z2 Y1=Y2.\n\n%worlds () (times-left-cancels SX1*Y1=Z1 SX2*Y2=Z2 X1=X2 Z1=Z2  Y1=Y2).\n%total {} (times-left-cancels _ _ _ _ _).\n\n\n%theorem times-left-cancels* : \n        forall* {X} {Y1} {Z1} {X-} {Y2} {Z2}\n        forall {T1:times X Y1 Z1} {T2:times X Y2 Z2} \n               {E1:eq X (s X-)} {E2:eq Z1 Z2} \n        exists {F:eq Y1 Y2} \n        true.\n\n- : times-left-cancels* X*Y1=Z1 X*Y2=Z2 X+ Z1=Z2 Y1=Y2\n    <- times-commutative X*Y1=Z1 Y1*X=Z1\n    <- times-commutative X*Y2=Z2 Y2*X=Z2\n    <- times-right-cancels* Y1*X=Z1 Y2*X=Z2 X+ Z1=Z2 Y1=Y2.\n\n%worlds () (times-left-cancels* X*Y1=Z1 X*Y2=Z2 X+ Z1=Z2  Y1=Y2).\n%total {} (times-left-cancels* _ _ _ _ _).\n\n\n%theorem times-left-preserves-gt : \n        forall* {M} {N1} {N2} {P1} {P2}\n        forall {GN:gt N1 N2} \n               {T1:times (s M) N1 P1} {T2:times (s M) N2 P2}\n        exists {GP:gt P1 P2}\n        true.\n\n- : times-left-preserves-gt N1>N2 (times/s times/z plus/z)\n                                  (times/s times/z plus/z) N1>N2.\n\n- : times-left-preserves-gt N1>N2 (times/s (T1:times (s M) N1 X1) X1+N1=O1)\n                                  (times/s (T2:times (s M) N2 X2) X2+N2=O2)\n                            O1>O2\n    <- times-left-preserves-gt N1>N2 T1 T2 X1>X2\n    <- plus-preserves-gt* X1>X2 N1>N2 X1+N1=O1 X2+N2=O2 O1>O2.\n\n%worlds () (times-left-preserves-gt N1>N2 SM*N1=P1 SM*N2=P2  P1>P2).\n%total T1 (times-left-preserves-gt _ T1 _ _).\n\n\n%theorem times-left-preserves-gt* :\n        forall* {M} {M-} {N1} {N2} {P1} {P2}\n        forall {GN:gt N1 N2} \n               {T1:times M N1 P1} {T2:times M N2 P2} {M+:eq M (s M-)}\n        exists {GP:gt P1 P2}\n        true.\n\n- : times-left-preserves-gt* N1>N2 M*N1=P1 M*N2=P2 M+ P1>P2\n    <- times-respects-eq M*N1=P1 M+ eq/ eq/ SM-*N1=P1\n    <- times-respects-eq M*N2=P2 M+ eq/ eq/ SM-*N2=P2\n    <- times-left-preserves-gt N1>N2 SM-*N1=P1 SM-*N2=P2 P1>P2.\n\n%worlds () (times-left-preserves-gt* N1>N2 M*N1=P1 M*N2=P2 M+  P1>P2).\n%total {} (times-left-preserves-gt* _ _ _ _ _).\n\n\n%theorem times-right-preserves-gt :\n        forall* {M1} {M2} {N} {P1} {P2}\n        forall {G1:gt M1 M2} {T1:times M1 (s N) P1} {T2:times M2 (s N) P2}\n        exists {G2:gt P1 P2}\n        true.\n\n- : times-right-preserves-gt M1>M2 M1*sN=P1 M2*sN=P2 P1>P2\n    <- times-commutative M1*sN=P1 SN*M1=P1\n    <- times-commutative M2*sN=P2 SN*M2=P2\n    <- times-left-preserves-gt M1>M2 SN*M1=P1 SN*M2=P2 P1>P2.\n\n%worlds () (times-right-preserves-gt M1>M2 M1*sN=P1 M2*sN=P2  P1>P2).\n%total {} (times-right-preserves-gt _ _ _ _).\n\n\n%theorem times-right-preserves-gt* :\n        forall* {M1} {M2} {N} {N-1} {P1} {P2}\n        forall {G1:gt M1 M2} {T1:times M1 N P1} {T2:times M2 N P2}\n               {N+:eq N (s N-1)}\n        exists {G2:gt P1 P2}\n        true.\n\n- : times-right-preserves-gt* M1>M2 M1*N=P1 M2*N=P2 N=sN-1 P1>P2\n    <- times-respects-eq M1*N=P1 eq/ N=sN-1 eq/ M1*N+=P1\n    <- times-respects-eq M2*N=P2 eq/ N=sN-1 eq/ M2*N+=P2\n    <- times-right-preserves-gt M1>M2 M1*N+=P1 M2*N+=P2 P1>P2.\n\n%worlds () (times-right-preserves-gt* M1>M2 M1*N=P1 M2*N=P2 N=sN-1  P1>P2).\n%total {} (times-right-preserves-gt* _ _ _ _ _).\n\n\n%theorem times-preserves-gt : \n        forall* {M1} {N1} {P1} {M2} {N2} {P2} \n        forall {GM:gt M1 M2} {GN:gt N1 N2}\n               {T1:times M1 N1 P1} {T2:times M2 N2 P2}\n        exists {GP:gt P1 P2}\n        true.\n\n- : {0=0': eq z _}\n    times-preserves-gt (M1>M2:gt M1 M2) (N1>0:gt N1 z) (M1*N1=P1:times M1 N1 P1)\n                       M2*0=0' P1>0'\n    <- gt-implies-positive M1>M2 M1' M1=sM1'\n    <- times-respects-eq M1*N1=P1 M1=sM1' eq/ eq/ SM1'*N1=P1\n    <- times-right-zero M2 M2*0=0\n    <- times-deterministic M2*0=0 M2*0=0' eq/ eq/ 0=0'\n    <- times-right-zero (s M1') SM1'*0=0\n    <- times-left-preserves-gt N1>0 SM1'*N1=P1 SM1'*0=0 P1>0\n    <- gt-respects-eq P1>0 eq/ 0=0' P1>0'.\n\n- : times-preserves-gt M1>M2 (N1>sN2':gt N1 (s N2')) M1*N1=P1 M2*sN2'=P2 P1>P2\n    <- gt-implies-positive M1>M2 M1' M1=sM1'\n    <- times-respects-eq M1*N1=P1 M1=sM1' eq/ eq/ SM1'*N1=P1\n    <- times-total (SM1'*sN2'=PX:times (s M1') (s N2') _)\n    <- times-left-preserves-gt N1>sN2' SM1'*N1=P1 SM1'*sN2'=PX P1>PX\n    <- eq-symmetric M1=sM1' SM1'=M1\n    <- times-respects-eq SM1'*sN2'=PX SM1'=M1 eq/ eq/ M1*sN2'=PX\n    <- times-right-preserves-gt M1>M2 M1*sN2'=PX M2*sN2'=P2 PX>P2\n    <- gt-transitive P1>PX PX>P2 P1>P2.\n\n%worlds () (times-preserves-gt M1>M2 N1>N2 M1*N1=P1 M2*N2=P2  P1>P2).\n%total {} (times-preserves-gt _ _ _ _ _).\n\n\n%theorem times-right-cancels-gt : \n        forall* {X1:nat} {X2:nat} {Y1:nat} {Y2:nat} {Z1:nat} {Z2:nat}\n        forall {P1:times X1 Y1 Z1} {P2:times X2 Y2 Z2}\n               {EY:eq Y1 Y2} {G1:gt Z1 Z2}\n\texists {G2:gt X1 X2}\n        true.\n\n- : times-right-cancels-gt (times/s X1*Y=N1 N1+Y=Z1) times/z eq/ Z1>0 SX1>0\n    <- succ-implies-gt-zero _ SX1>0.\n\n- : times-right-cancels-gt (times/s X1*Y=N1 N1+Y=Z1) (times/s X2*Y=N2 N2+Y=Z2)\n                           eq/ Z1>Z2 SX1>SX2\n    <- plus-right-cancels-gt N1+Y=Z1 N2+Y=Z2 eq/ Z1>Z2 N1>N2\n    <- times-right-cancels-gt X1*Y=N1 X2*Y=N2 eq/ N1>N2 X1>X2\n    <- succ-preserves-gt X1>X2 SX1>SX2.\n\n%worlds () (times-right-cancels-gt X1*Y1=Z1 X2*Y2=Z2 Y1=Y2 Z1>Z2  X1>X2).\n%total [P1 P2] (times-right-cancels-gt P1 P2 _ _ _).\n\n\n%theorem times-left-cancels-gt : \n        forall* {X1:nat} {X2:nat} {Y1:nat} {Y2:nat} {Z1:nat} {Z2:nat}\n        forall {P1:times X1 Y1 Z1} {P2:times X2 Y2 Z2} \n               {EX:eq X1 X2} {G1:gt Z1 Z2}\n\texists {G2:gt Y1 Y2}\n        true.\n\n- : times-left-cancels-gt X1*Y1=Z1 X2*Y2=Z2 X1=X2 Z1>Z2 Y1>Y2\n    <- times-commutative X1*Y1=Z1 Y1*X1=Z1\n    <- times-commutative X2*Y2=Z2 Y2*X2=Z2\n    <- times-right-cancels-gt Y1*X1=Z1 Y2*X2=Z2 X1=X2 Z1>Z2 Y1>Y2.\n\n%worlds () (times-left-cancels-gt X1*Y1=Z1 X2*Y2=Z2 X1=X2 Z1>Z2  Y1>Y2).\n%total P1 (times-left-cancels-gt P1 _ _ _ _).\n\n\n\n\n\n%%%%% nat-inv.elf\n%%%%% Minus for natural numbers\n%%%%% This file is part of the nat.elf signature\n\n\n\n\n\n%%%% Definitions\n\n%abbrev minus = [X1] [X2] [X3] plus X3 X2 X1.\n\n\n\n\n%%%% Theorems\n\n\n%%% Theorems about minus\n\n\n%abbrev false-implies-minus = false-implies-plus.\n\n\n%theorem minus-respects-eq :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X6}\n\tforall {D:minus X1 X2 X3} {E1:eq X1 X4} {E2:eq X2 X5} {E3:eq X3 X6}\n        exists {DP:minus X4 X5 X6}\n        true.\n\n- : minus-respects-eq S eq/ eq/ eq/ S.\n\n%worlds () (minus-respects-eq _ _ _ _ _).\n%total {} (minus-respects-eq _ _ _ _ _).\n\n\n%theorem minus-deterministic :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X6}\n\tforall {S:minus X1 X2 X3} {SP:minus X4 X5 X6}\n               {E1:eq X1 X4} {E2:eq X2 X5}\n\texists {E3:eq X3 X6}\n\ttrue.\n\n- : minus-deterministic X3+X2=X1 X6+X5=X4 X1=X4 X2=X5 X3=X6\n    <- plus-right-cancels X3+X2=X1 X6+X5=X4 X2=X5 X1=X4 X3=X6.\n\n%worlds () (minus-deterministic X1-X2=X3 X4-X5=X6 X1=X4 X2=X5 X3=X6).\n%total {} (minus-deterministic _ _ _ _ _).\n\n\n%theorem plus-associates-with-minus* :\n\tforall* {X1} {X2} {X3} {X4} {X6} {X7}\n\tforall {OP1:plus X1 X2 X3} {IOP1:minus X3 X4 X7} {IOP2:minus X2 X4 X6} \n\texists {OP2:plus X1 X6 X7}\n        true.\n\n- : plus-associates-with-minus* X1+X2=X3 X7+X4=X3 X6+X4=X2 X1+X6=X7\n    <- plus-associative-converse X6+X4=X2 X1+X2=X3 X7P X1+X6=X7P X7P+X4=X3\n    <- plus-right-cancels X7P+X4=X3 X7+X4=X3 eq/ eq/ X7P=X7\n    <- plus-respects-eq X1+X6=X7P eq/ eq/ X7P=X7 X1+X6=X7.\n\n%worlds () (plus-associates-with-minus* X1+X2=X3 X3-X4=X7 X2-X4=X6 \n                               X1+X6=X7).\n%total {} (plus-associates-with-minus* _ _ _ _).\n\n\n%theorem plus-associates-with-minus-converse* :\n\tforall* {X1} {X2} {X3} {X4} {X6} {X7}\n        forall {IOP2:minus X2 X4 X6} {OP2:plus X1 X6 X7} {OP1:plus X1 X2 X3} \n\texists {IOP1:minus X3 X4 X7} \n        true.\n\n- : plus-associates-with-minus-converse* X6+X4=X2 X1+X6=X7 X1+X2=X3 X7+X4=X3\n    <- plus-associative-converse* X6+X4=X2 X1+X2=X3 X1+X6=X7 X7+X4=X3.\n\n%worlds () (plus-associates-with-minus-converse* X2-X4=X6 X1+X6=X7 X1+X2=X3 \n                                        X3-X4=X7).\n%total {} (plus-associates-with-minus-converse* _ _ _ _).\n\n\n%theorem plus-associates-with-minus-converse :\n\tforall* {X1} {X2} {X4} {X6} {X7}\n        forall {IOP2:minus X2 X4 X6} {OP2:plus X1 X6 X7} \n        exists {X3} {OP1:plus X1 X2 X3} {IOP1:minus X3 X4 X7} \n        true.\n\n- : plus-associates-with-minus-converse X6+X4=X2 X1+X6=X7 X3 X1+X2=X3 X7+X4=X3\n    <- plus-total X1+X2=X3\n    <- plus-associates-with-minus-converse* X6+X4=X2 X1+X6=X7 X1+X2=X3 X7+X4=X3.\n%worlds () (plus-associates-with-minus-converse X2-X4=X6 X1+X6=X7 \n                                       X3 X1+X2=X3 X3-X4=X7).\n%total {} (plus-associates-with-minus-converse _ _ _ _ _).\n\n\n%theorem minus-associates-from-plus* :\n\tforall* {X1} {X2} {X3} {X4} {X6} {X7}\n\tforall {IOP1:minus X1 X2 X3} {OP1:plus X3 X4 X7} {IOP2:minus X2 X4 X6}\n        exists {IOP3:minus X1 X6 X7}\n        true.\n\n- : minus-associates-from-plus* X3+X2=X1 X3+X4=X7 X6+X4=X2 X7+X6=X1\n    <- plus-commutative X6+X4=X2 X4+X6=X2\n    <- plus-associative-converse* X4+X6=X2 X3+X2=X1 X3+X4=X7 X7+X6=X1.\n\n%worlds () (minus-associates-from-plus* X1-X2=X3 X3+X4=X7 X2-X4=X6  X1-X6=X7).\n%total {} (minus-associates-from-plus* _ _ _ _).\n\n\n%theorem minus-associates-from-plus-converse* :\n\tforall* {X1} {X2} {X3} {X4} {X6} {X7} \n\tforall {IOP2:minus X2 X4 X6} {IOP3:minus X1 X6 X7} {IOP1:minus X1 X2 X3} \n        exists {OP1:plus X3 X4 X7} \n        true.\n\n- : minus-associates-from-plus-converse* X6+X4=X2 X7+X6=X1 X3+X2=X1 X3+X4=X7\n    <- plus-commutative X6+X4=X2 X4+X6=X2\n    <- plus-associative-converse X4+X6=X2 X3+X2=X1 X7P X3+X4=X7P X7P+X6=X1\n    <- plus-right-cancels X7P+X6=X1 X7+X6=X1 eq/ eq/ X7P=X7\n    <- plus-respects-eq X3+X4=X7P eq/ eq/ X7P=X7 X3+X4=X7.\n\n%worlds () (minus-associates-from-plus-converse* X2-X4=X6 X1-X6=X7 X1-X2=X3 \n                                        X3+X4=X7).\n%total {} (minus-associates-from-plus-converse* _ _ _ _).\n\n\n%theorem minus-associates-to-plus* :\n\tforall* {X1} {X2} {X3} {X4} {X6} {X7}\n\tforall {IOP1:minus X1 X2 X3} {IOP2:minus X3 X4 X7} {OP1:plus X2 X4 X6} \n        exists {IOP3:minus X1 X6 X7}\n        true.\n\n- : minus-associates-to-plus* X3+X2=X1 X7+X4=X3 X2+X4=X6 X7+X6=X1\n    <- plus-commutative X2+X4=X6 X4+X2=X6 \n    <- plus-associative* X7+X4=X3 X3+X2=X1 X4+X2=X6 X7+X6=X1.\n\n%worlds () (minus-associates-to-plus* X1-X2=X3 X3-X4=X7 X2+X4=X6  X1-X6=X7).\n%total {} (minus-associates-to-plus* _ _ _ _).\n\n\n%theorem minus-associates-to-plus :\n\tforall* {X1} {X2} {X3} {X4} {X7}\n\tforall {IOP1:minus X1 X2 X3} {IOP2:minus X3 X4 X7}\n        exists {X6} {OP1:plus X2 X4 X6} {IOP3:minus X1 X6 X7}\n        true.\n\n- : minus-associates-to-plus X3+X2=X1 X7+X4=X3 X6 X2+X4=X6 X7+X6=X1\n    <- plus-associative X7+X4=X3 X3+X2=X1 X6 X4+X2=X6 X7+X6=X1\n    <- plus-commutative X4+X2=X6 X2+X4=X6.\n\n%worlds () (minus-associates-to-plus X1-X2=X3 X3-X4=X7 X6 X2+X4=X6 X1-X6=X7).\n%total {} (minus-associates-to-plus _ _ _ _ _).\n\n\n%theorem minus-associates-to-plus-converse* :\n\tforall* {X1} {X2} {X3} {X4} {X6} {X7}\n        forall {OP1:plus X2 X4 X6} {IOP3:minus X1 X6 X7} {IOP1:minus X1 X2 X3}\n\texists {IOP2:minus X3 X4 X7} \n        true.\n\n- : minus-associates-to-plus-converse* X2+X4=X6 X7+X6=X1 X3+X2=X1 X7+X4=X3\n    <- plus-commutative X2+X4=X6 X4+X2=X6\n    <- plus-associative-converse X4+X2=X6 X7+X6=X1 X3P X7+X4=X3P X3P+X2=X1\n    <- plus-right-cancels X3P+X2=X1 X3+X2=X1 eq/ eq/ X3P=X3\n    <- plus-respects-eq X7+X4=X3P eq/ eq/ X3P=X3 X7+X4=X3.\n\n%worlds () (minus-associates-to-plus-converse* X2+X4=X6 X1-X6=X7 X1-X2=X3 \n                                      X3-X4=X7).\n%total {} (minus-associates-to-plus-converse* _ _ _ _).\n\n\n%theorem minus-associates-to-plus-converse :\n\tforall* {X1} {X2} {X4} {X6} {X7}\n        forall {OP1:plus X2 X4 X6} {IOP3:minus X1 X6 X7} \n        exists {X3} {IOP1:minus X1 X2 X3} {IOP2:minus X3 X4 X7} \n        true.\n\n- : minus-associates-to-plus-converse X2+X4=X6 X7+X6=X1 X3 X3+X2=X1 X7+X4=X3\n    <- plus-commutative X2+X4=X6 X4+X2=X6\n    <- plus-associative-converse X4+X2=X6 X7+X6=X1 X3 X7+X4=X3 X3+X2=X1.\n\n%worlds () (minus-associates-to-plus-converse X2+X4=X6 X1-X6=X7 \n                                     X3 X1-X2=X3 X3-X4=X7).\n%total {} (minus-associates-to-plus-converse _ _ _ _ _).\n\n%theorem minus-is-zero-implies-eq :\n\tforall* {N1} {N2} {N3}\n\tforall {P:minus N1 N2 N3} {E3:eq N3 z}\n        exists {E1:eq N1 N2}\n\ttrue.\n\n- : minus-is-zero-implies-eq plus/z eq/ eq/.\n\n%worlds () (minus-is-zero-implies-eq X-Y=Z Z=0  X=Y).\n%total {} (minus-is-zero-implies-eq _ _ _).\n\n\n%abbrev minus-implies-gt = plus-implies-gt.\n\n\n%theorem minus-left-cancels : \n\tforall* {X1} {X2} {X3} {X4} {X5} {X6}\n\tforall {IOP1:minus X1 X2 X3} {IOP2:minus X4 X5 X6}\n               {E1:eq X1 X4} {E3:eq X3 X6}\n\texists {E2:eq X2 X5}\n\ttrue.\n\n- : minus-left-cancels X3+X2=X1 X6+X5=X4 X1=X4 X3=X6 X2=X5\n   <- plus-left-cancels X3+X2=X1 X6+X5=X4 X3=X6 X1=X4 X2=X5.\n\n%worlds () (minus-left-cancels X1-X2=X3 X4-X5=X6 X1=X4 X3=X6 X2=X5).\n%total {} (minus-left-cancels _ _ _ _ _).\n\n\n%theorem minus-right-cancels : \n\tforall* {X1} {X2} {X3} {X4} {X5} {X6}\n\tforall {IOP1:minus X1 X2 X3} {IOP2:minus X4 X5 X6}\n               {E2:eq X2 X5} {E3:eq X3 X6}\n\texists {E1:eq X1 X4}\n\ttrue.\n\n- : minus-right-cancels X3+X2=X1 X6+X5=X4 X2=X5 X3=X6 X1=X4\n    <- plus-deterministic  X3+X2=X1 X6+X5=X4 X3=X6 X2=X5 X1=X4.\n\n%worlds () (minus-right-cancels X1-X2=X3 X4-X5=X6 X2=X5 X3=X6 X1=X4).\n%total {} (minus-right-cancels _ _ _ _ _).\n\n\n\n%theorem minus-left-inverts-gt* :\n\tforall* {X1} {X2} {X3} {X4} {X5}\n        forall {G:gt X2 X4}\n               {IOP1:minus X1 X2 X3} {IOP2:minus X1 X4 X5}\n        exists {GP:gt X5 X3}\n\ttrue.\n\n- : minus-left-inverts-gt* X2>X4 X3+X2=X1 X5+X4=X1 X5>X3\n    <- plus-total X3+X4=X7\n    <- plus-left-preserves-gt* X2>X4 X3+X2=X1 X3+X4=X7 X1>X7\n    <- plus-right-cancels-gt X5+X4=X1 X3+X4=X7 eq/ X1>X7 X5>X3.\n\n%worlds () (minus-left-inverts-gt* X2>X4 X1-X2=X3 X1-X4=X5  X5>X3).\n%total {} (minus-left-inverts-gt* _ _ _ _).\n\n\n%theorem minus-right-preserves-gt* :\n\tforall* {X1} {X2} {X3} {X4} {X5}\n        forall {G:gt X1 X2}\n               {IOP1:minus X1 X3 X4} {IOP2:minus X2 X3 X5}\n        exists {GP:gt X4 X5}\n\ttrue.\n\n- : minus-right-preserves-gt*  X1>X2 X4+X3=X1 X5+X3=X2 X4>X5\n    <- plus-right-cancels-gt X4+X3=X1 X5+X3=X2 eq/ X1>X2 X4>X5.\n\n%worlds () (minus-right-preserves-gt* X1>X2 X1-X3=X4 X2-X3=X5  X4>X5).\n%total {} (minus-right-preserves-gt* _ _ _ _).\n\n\n%theorem minus-left-cancels-inverts-gt :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X6}\n\tforall {IOP1:minus X1 X2 X3} {IOP2:minus X4 X5 X6}\n               {E:eq X1 X4} {G:gt X3 X6}\n        exists {GP:gt X5 X2}\n\ttrue.\n\n- : minus-left-cancels-inverts-gt X3+X2=X1 X6+X5=X4 X1=X4 X3>X6 X5>X2\n    <- plus-total X6+X2=X7\n    <- plus-right-preserves-gt* X3>X6 X3+X2=X1 X6+X2=X7 X1>X7\n    <- eq-symmetric X1=X4 X4=X1\n    <- plus-respects-eq X6+X5=X4 eq/ eq/ X4=X1 X6+X5=X1\n    <- plus-left-cancels-gt X6+X5=X1 X6+X2=X7 eq/ X1>X7 X5>X2.\n\n%worlds () (minus-left-cancels-inverts-gt X1-X2=X3 X4-X5=X6 X1=X4 X3>X6 \n                                   X5>X2).\n%total {} (minus-left-cancels-inverts-gt _ _ _ _ _).\n\n\n%theorem minus-right-cancels-gt :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X6}\n\tforall {IOP1:minus X1 X2 X3} {IOP2:minus X4 X5 X6}\n               {E2:eq X2 X5} {G3:gt X3 X6}\n        exists {G1:gt X1 X4}\n\ttrue.\n\n- : minus-right-cancels-gt X3+X2=X1 X6+X5=X4 X2=X5 X3>X6 X1>X4\n    <- plus-respects-eq X3+X2=X1 eq/ X2=X5 eq/ X3+X5=X1\n    <- plus-right-preserves-gt* X3>X6 X3+X5=X1 X6+X5=X4 X1>X4.\n\n%worlds () (minus-right-cancels-gt X1-X2=X3 X4-X5=X6 X2=X5 X3>X6 \n                            X1>X4).\n%total {} (minus-right-cancels-gt _ _ _ _ _).\n\n\n\n%theorem times-right-distributes-over-minus :\n\tforall* {X1} {X2} {X3} {X4} {X7}\n        forall {S12:minus X1 X2 X3} {M34:times X3 X4 X7}\n        exists {X5} {X6} {M14:times X1 X4 X5} {M24:times X2 X4 X6}\n               {S56:minus X5 X6 X7}\n\ttrue.\n\n- : times-right-distributes-over-minus X3+X2=X1 X3*X4=X7 _ _ X1*X4=X5 X2*X4=X6 \n                                   X7+X6=X5\n    <- times-total X1*X4=X5\n    <- times-right-distributes-over-plus X3+X2=X1 X1*X4=X5 _ _\n                                      X3*X4=Y7 X2*X4=X6 Y7+X6=X5\n    <- times-deterministic X3*X4=Y7 X3*X4=X7 eq/ eq/ Y7=X7\n    <- plus-respects-eq Y7+X6=X5 Y7=X7 eq/ eq/ X7+X6=X5.\n\n%worlds () (times-right-distributes-over-minus X1-X2=X3 X3*X4=X7 \n                                     X5 X6 X1*X4=X5 X2*X4=X6 X5-X6=X7).\n%total {} (times-right-distributes-over-minus _ _ _ _ _ _ _).\n\n\n\n%theorem times-right-distributes-over-minus* :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X6} {X7}\n        forall {A12:minus X1 X2 X3} {M34:times X3 X4 X7}\n               {M14:times X1 X4 X5} {M24:times X2 X4 X6}\n        exists {A56:minus X5 X6 X7}\n\ttrue.\n\n- : times-right-distributes-over-minus* X1-X2=X3 X3*X4=X7 X1*X4=X5 X2*X4=X6 X5-X6=X7\n    <- times-right-distributes-over-minus X1-X2=X3 X3*X4=X7 Y5 Y6\n                                      X1*X4=Y5 X2*X4=Y6 Y5-Y6=X7\n    <- times-deterministic X1*X4=Y5 X1*X4=X5 eq/ eq/ Y5=X5\n    <- times-deterministic X2*X4=Y6 X2*X4=X6 eq/ eq/ Y6=X6\n    <- minus-respects-eq Y5-Y6=X7 Y5=X5 Y6=X6 eq/ X5-X6=X7.\n\n%worlds () (times-right-distributes-over-minus* X1-X2=X3 X3*X4=X7 X1*X4=X5 X2*X4=X6\n                                       X5-X6=X7).\n%total {} (times-right-distributes-over-minus* _ _ _ _ _).\n\n\n%theorem times-left-distributes-over-minus* :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X6} {X7}\n        forall {A12:minus X2 X4 X6} {M34:times X1 X6 X7}\n               {M14:times X1 X2 X3} {M24:times X1 X4 X5}\n        exists {A56:minus X3 X5 X7}\n\ttrue.\n\n- : times-left-distributes-over-minus* X2-X4=X6 X1*X6=X7 X1*X2=X3 X1*X4=X5 X3-X5=X7\n    <- times-commutative X1*X6=X7 X6*X1=X7\n    <- times-commutative X1*X2=X3 X2*X1=X3\n    <- times-commutative X1*X4=X5 X4*X1=X5\n    <- times-right-distributes-over-minus* X2-X4=X6 X6*X1=X7 X2*X1=X3 X4*X1=X5\n                                       X3-X5=X7.\n\n%worlds () (times-left-distributes-over-minus* X2-X4=X6 X1*X6=X7 X1*X2=X3 X1*X4=X5\n                                     X3-X5=X7).\n%total {} (times-left-distributes-over-minus* _ _ _ _ _).\n\n\n%theorem times-left-distributes-over-minus :\n\tforall* {X1} {X2} {X4} {X6} {X7}\n        forall {A12:minus X2 X4 X6} {M34:times X1 X6 X7}\n        exists {X3} {X5} {M14:times X1 X2 X3} {M24:times X1 X4 X5}\n               {A56:minus X3 X5 X7}\n\ttrue.\n\n- : times-left-distributes-over-minus X2-X4=X6 X1*X6=X7 \n                                  X3 X5 X1*X2=X3 X1*X4=X5 X3-X5=X7\n    <- times-total X1*X2=X3\n    <- times-total X1*X4=X5\n    <- times-left-distributes-over-minus* X2-X4=X6 X1*X6=X7 X1*X2=X3 X1*X4=X5\n                                      X3-X5=X7.\n\n%worlds () (times-left-distributes-over-minus X2-X4=X6 X1*X6=X7 \n                                    X3 X5 X1*X2=X3 X1*X4=X5 X3-X5=X7).\n%total {} (times-left-distributes-over-minus _ _ _ _ _ _ _).\n\n\n%theorem times-right-factors-over-minus* :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X6} {X7}\n        forall {M14:times X1 X4 X5} {M24:times X2 X4 X6} {A56:minus X5 X6 X7}\n               {A12:minus X1 X2 X3} \n        exists {M34:times X3 X4 X7}\n\ttrue.\n\n- : times-right-factors-over-minus* X1*X4=X5 X2*X4=X6 X5-X6=X7 X1-X2=X3 X3*X4=X7\n    <- times-total X3*X4=Y7\n    <- times-right-distributes-over-minus* X1-X2=X3 X3*X4=Y7 X1*X4=X5 X2*X4=X6 \n                                       X5-X6=Y7\n    <- minus-deterministic X5-X6=Y7 X5-X6=X7 eq/ eq/ Y7=X7\n    <- times-respects-eq X3*X4=Y7 eq/ eq/ Y7=X7 X3*X4=X7.\n\n%worlds () (times-right-factors-over-minus* X1*X4=X5 X2*X4=X6 X5-X6=X7 X1-X2=X3\n                                  X3*X4=X7 ).\n%total {} (times-right-factors-over-minus* _ _ _ _ _).\n\n\n%theorem times-left-factors-over-minus* :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X6} {X7}\n\tforall {M12:times X1 X2 X3} {M14:times X1 X4 X5} \n               {A35:minus X3 X5 X7} {A24:minus X2 X4 X6} \n        exists {M16:times X1 X6 X7}\n        true.\n\n- : times-left-factors-over-minus* X1*X2=X3 X1*X4=X5 X3-X5=X7 X2-X4=X6 \n                               X1*X6=X7\n    <- times-total X1*X6=Y7\n    <- times-left-distributes-over-minus* X2-X4=X6 X1*X6=Y7 X1*X2=X3 X1*X4=X5\n                                      X3-X5=Y7\n    <- minus-deterministic X3-X5=Y7 X3-X5=X7 eq/ eq/ Y7=X7\n    <- times-respects-eq X1*X6=Y7 eq/ eq/ Y7=X7 X1*X6=X7.\n\n%worlds () (times-left-factors-over-minus* X1*X2=X3 X1*X4=X5 X3-X5=X7 X2-X4=X6 \n                                X1*X6=X7).\n%total {} (times-left-factors-over-minus* _ _ _ _ _).\n\n\n%theorem times-right-factors-over-minus :\n\tforall* {Y} {Z} {XY} {XZ} {YZ} {XYZ} {Z-}\n\tforall {TXY:times XY Z XYZ} {TY:times Y Z YZ}\n               {M:minus XYZ YZ XZ} {EZ:eq Z (s Z-)}\n        exists {X} {M':minus XY Y X} {TX:times X Z XZ}\n        true.\n\n% minus isn't total, so this is harder.\n- : times-right-factors-over-minus XY*Z=YZ Y*Z=YZ plus/z eq/ \n                                   z ZERO+Y=XY times/z\n    <- times-right-cancels* XY*Z=YZ Y*Z=YZ eq/ eq/ XY=Y\n    <- plus-respects-eq plus/z eq/ XY=Y eq/ ZERO+Y=XY.\n\n- : times-right-factors-over-minus XY*Z=XYZ Y*Z=YZ XZ+YZ=XYZ _\n                                   (s X-) X+Y=XY X*Z=XZ\n    %% we assume XZ is of the form (s XZ-)\n    <- plus-implies-gt XZ+YZ=XYZ eq/ XYZ>YZ \n    <- times-right-cancels-gt XY*Z=XYZ Y*Z=YZ eq/ XYZ>YZ XY>Y\n    <- gt-implies-plus XY>Y X- X+Y=XY\n    <- times-right-factors-over-minus* XY*Z=XYZ Y*Z=YZ XZ+YZ=XYZ X+Y=XY X*Z=XZ.\n\n%worlds () (times-right-factors-over-minus XY*Z=XYZ Y*Z=YZ XYZ-YZ=XZ Z+\n                                           X XY-Y=X X*Z=XZ).\n%total {} (times-right-factors-over-minus _ _ _ _ _ _ _).\n\n\n%theorem times-left-factors-over-minus :\n\tforall* {X} {Y} {Z} {XY} {XZ} {XYZ} {X-}\n\tforall {TXY:times X Y XY} {TXZ:times X Z XZ}\n               {M:minus XY XZ XYZ} {EX:eq X (s X-)}\n        exists {YZ} {MYZ:minus Y Z YZ} {TXYZ:times X YZ XYZ}\n        true.\n\n- : times-left-factors-over-minus X*Y=XY X*Z=XZ XY-XZ=XYZ X=sX- YZ Y-Z=YZ X*YZ=XYZ\n    <- times-commutative X*Y=XY Y*X=XY\n    <- times-commutative X*Z=XZ Z*X=XZ\n    <- times-right-factors-over-minus Y*X=XY Z*X=XZ XY-XZ=XYZ X=sX- \n                                      YZ Y-Z=YZ YZ*X=XYZ\n    <- times-commutative YZ*X=XYZ X*YZ=XYZ.\n\n%worlds () (times-left-factors-over-minus X*Y=XY X*Z=XZ XY-XZ=XYZ X=sX-\n                                    YZ Y-Z=YZ X*YZ=XYZ).\n%total {} (times-left-factors-over-minus _ _ _ _ _ _ _).\n\n\n\n\n\n%%%%% nat-comp.elf\n%%%%% Composed relations for natural numbers\n%%%%% This file is part of the nat.elf signature\n\n\n\n\n\n%%%% Definitions\n\n\n\nge : nat -> nat -> type.\n\n\nge/= : ge X Y\n    <- eq X Y.\n\nge/> : ge X Y\n    <- gt X Y.\n\n\n\n\n%%%% Theorems\n\n\n\n%%% Theorems about ge\n\n\n%theorem false-implies-ge :\n\tforall* {X1} {X2}\n\tforall {F:void}\n\texists {G:ge X1 X2}\n\ttrue.\n\n%worlds () (false-implies-ge _ _).\n%total { } (false-implies-ge _ _).\n\n\n%theorem ge-respects-eq :\n\tforall* {X1} {X2} {Y1} {Y2}\n\tforall {D1:ge X1 X2} {E1:eq X1 Y1} {E2:eq X2 Y2}\n\texists {D2:ge Y1 Y2}\n\ttrue.\n\n- : ge-respects-eq X1>=X2 eq/ eq/ X1>=X2.\n\n%worlds () (ge-respects-eq _ _ _ _).\n%total { } (ge-respects-eq _ _ _ _).\n\n%theorem ge-reflexive :\n\tforall {X}\n\texists {G:ge X X}\n\ttrue.\n\n- : ge-reflexive _ (ge/= eq/).\n\n%worlds () (ge-reflexive X  X>=X).\n%total {} (ge-reflexive _ _).\n\n\n%theorem ge-transitive:\n\tforall* {X1} {X2} {X3}\n\tforall {G1:ge X1 X2} {G2:ge X2 X3}\n\texists {G3:ge X1 X3}\n\ttrue.\n\n- : ge-transitive (ge/= eq/) (ge/= eq/) (ge/= eq/).\n\n- : ge-transitive (ge/= eq/) (ge/> X>X3) (ge/> X>X3).\n\n- : ge-transitive (ge/> X1>X) (ge/= eq/) (ge/> X1>X).\n\n- : ge-transitive (ge/> X1>X2) (ge/> X2>X3) (ge/> X1>X3)\n    <- gt-transitive X1>X2 X2>X3 X1>X3.\n\n%worlds () (ge-transitive X1>=X2 X2>=X3  X1>=X3).\n%total {} (ge-transitive _ _ _).\n\n\n%theorem ge-anti-symmetric :\n\tforall* {X1} {X2}\n\tforall {G1:ge X1 X2} {G2:ge X2 X1}\n        exists {E:eq X1 X2}\n\ttrue.\n\n- : ge-anti-symmetric (ge/= eq/) _ eq/.\n\n- : ge-anti-symmetric _ (ge/= eq/) eq/.\n\n- : ge-anti-symmetric (ge/> X1>X2) (ge/> X2>X1) X1=X2\n    <- gt-anti-symmetric X1>X2 X2>X1 F\n    <- false-implies-eq F X1=X2.\n\n%worlds () (ge-anti-symmetric X1>=X2 X2>=X1  X1=X2).\n%total {} (ge-anti-symmetric _ _ _).\n\n\n%theorem ge-transitive-gt:\n\tforall* {X1} {X2} {X3}\n\tforall {G1:ge X1 X2} {G2:gt X2 X3}\n\texists {G3:gt X1 X3}\n\ttrue.\n\n- : ge-transitive-gt (ge/= eq/) X>X3 X>X3.\n\n- : ge-transitive-gt (ge/> X1>X2) X2>X3 X1>X3\n    <- gt-transitive X1>X2 X2>X3 X1>X3.\n\n%worlds () (ge-transitive-gt X1>=X2 X2>X3  X1>X3).\n%total {} (ge-transitive-gt _ _ _).\n\n\n%theorem gt-transitive-ge:\n\tforall* {X1} {X2} {X3}\n\tforall {G1:gt X1 X2} {G2:ge X2 X3}\n\texists {G3:gt X1 X3}\n\ttrue.\n\n- : gt-transitive-ge X1>X2 (ge/= eq/) X1>X2.\n\n- : gt-transitive-ge X1>X2 (ge/> X2>X3) X1>X3\n    <- gt-transitive X1>X2 X2>X3 X1>X3.\n\n%worlds () (gt-transitive-ge X1>X2 X2>=X3  X1>X3).\n%total {} (gt-transitive-ge _ _ _).\n\n%theorem meta-ge :\n\tforall {M} {N} {G:ge M N}\n        true.\n\n- : meta-ge _ _ (ge/= eq/).\n\n- : meta-ge _ _ (ge/> M>N) \n    <- meta-gt _ _ M>N.\n\n%worlds () (meta-ge _ _ _).\n%total { } (meta-ge _ _ _).\n%reduces N <= M (meta-ge M N _).\n\n\n%theorem succ-preserves-ge :\n\tforall* {M} {N}\n\tforall {G:ge M N}\n\texists {G':ge (s M) (s N)}\n\ttrue.\n\n- : succ-preserves-ge (ge/= eq/) (ge/= eq/).\n\n- : succ-preserves-ge (ge/> N>M) (ge/> N+1>M+1)\n    <- succ-preserves-gt N>M N+1>M+1.\n\n%worlds () (succ-preserves-ge M>=N  M+1>=N+1).\n%total {} (succ-preserves-ge _ _).\n\n\n%theorem succ-preserves-ge-converse :\n\tforall* {M} {N}\n\tforall {G':ge (s M) (s N)}\n\texists {G:ge M N}\n\ttrue.\n\n- : succ-preserves-ge-converse (ge/= eq/) (ge/= eq/).\n\n- : succ-preserves-ge-converse (ge/> N+1>M+1) (ge/> N>M)\n    <- succ-preserves-gt-converse N+1>M+1 N>M.\n\n%worlds () (succ-preserves-ge-converse M+1>=N+1  M>=N).\n%total {} (succ-preserves-ge-converse _ _).\n\n\n%theorem ge-succ-implies-gt :\n\tforall* {N1} {N2}\n\tforall {G:ge N1 (s N2)}\n        exists {G':gt N1 N2}\n\ttrue.\n\n- : ge-succ-implies-gt (ge/= eq/) (gt/1).\n\n- : ge-succ-implies-gt (ge/> N1>sN2) N1>N2\n    <- gt-transitive N1>sN2 (gt/1) N1>N2.\n\n%worlds () (ge-succ-implies-gt _ _).\n%total { } (ge-succ-implies-gt _ _).\n\n\n%theorem ge-implies-succ-gt :\n\tforall* {N1} {N2}\n\tforall {G:ge N1 N2}\n\texists {G':gt (s N1) N2}\n\ttrue.\n\n- : ge-implies-succ-gt N1>=N2 N1+1>N2\n    <- succ-preserves-ge N1>=N2 N1+1>=N2+1\n    <- ge-succ-implies-gt N1+1>=N2+1 N1+1>N2.\n\n%worlds () (ge-implies-succ-gt _ _).\n%total { } (ge-implies-succ-gt _ _).\n\n\n%theorem succ-gt-implies-ge :\n\tforall* {N1} {N2}\n\tforall {G:gt (s N1) N2}\n        exists {G':ge N1 N2}\n\ttrue.\n\n- : succ-gt-implies-ge (gt/1) (ge/= eq/).\n\n- : succ-gt-implies-ge (gt/> N1>N2) (ge/> N1>N2).\n\n%worlds () (succ-gt-implies-ge _ _).\n%total { } (succ-gt-implies-ge _ _).\n\n\n%theorem gt-implies-ge-succ :\n\tforall* {N1} {N2}\n        forall {G':gt N1 N2}\n\texists {G:ge N1 (s N2)}\n\ttrue.\n\n- : gt-implies-ge-succ N1>N2 N1>=N2+1\n    <- succ-preserves-gt N1>N2 N1+1>N2+1\n    <- succ-gt-implies-ge N1+1>N2+1 N1>=N2+1.\n\n%worlds () (gt-implies-ge-succ _ _).\n%total { } (gt-implies-ge-succ _ _).\n\n\n%theorem ge-implies-plus:\n\tforall* {N1} {N2}\n\tforall {G:ge N2 N1}\n        exists {N0} {P:plus N0 N1 N2}\n        true.\n\n- : ge-implies-plus (ge/= eq/) z plus/z.\n\n- : ge-implies-plus (ge/> N2>N1) (s N0) P\n    <- gt-implies-plus N2>N1 N0 P.\n\n%worlds () (ge-implies-plus N2>=N1  N0 N0+N1=N2).\n%total { } (ge-implies-plus _ _ _).\n\n\n%theorem plus-implies-ge:\n\tforall* {N0} {N1} {N2}\n\tforall {P:plus N0 N1 N2}\n\texists {G:ge N2 N1}\n\ttrue.\n\n- : plus-implies-ge plus/z (ge/= eq/).\n\n- : plus-implies-ge P (ge/> N2>N1)\n    <- plus-implies-gt P eq/ N2>N1.\n\n%worlds () (plus-implies-ge N0+N1=N2  N2>=N1).\n%total { } (plus-implies-ge _ _).\n\n\n%theorem ge-zero-always :\n\tforall {N}\n\texists {G:ge N z}\n\ttrue.\n\n- : ge-zero-always _ N>=0\n    <- plus-right-identity _ N+0=N\n    <- plus-implies-ge N+0=N N>=0.\n\t\n%worlds () (ge-zero-always _ _).\n%total { } (ge-zero-always _ _).\n\n\n%theorem nonzero-times-implies-ge :\n\tforall* {N0} {N1} {N2}\n\tforall {P:times (s N0) N1 N2}\n\texists {G:ge N2 N1}\n\ttrue.\n\n- : nonzero-times-implies-ge (times/s _ X+N1=N2) N2>=N1\n    <- plus-implies-ge X+N1=N2 N2>=N1.\n\n%worlds () (nonzero-times-implies-ge N0*N1=N2  N2>=N1).\n%total { } (nonzero-times-implies-ge _ _).\n\n\n%theorem times-nonzero-implies-ge :\n\tforall* {N0} {N1} {N2}\n\tforall {P:times N0 (s N1) N2}\n\texists {G:ge N2 N0}\n\ttrue.\n\n- : times-nonzero-implies-ge A*B=C C>=A\n    <- times-commutative A*B=C B*A=C\n    <- nonzero-times-implies-ge B*A=C C>=A.\n\n%worlds () (times-nonzero-implies-ge _ _).\n%total { } (times-nonzero-implies-ge _ _).\n\n\n%theorem non-trivial-times-implies-much-gt* :\n\tforall* {N1} {N2} {N3}\n\tforall {D:times (s (s N1)) (s (s N2)) N3}\n        exists {G:gt N3 (s (s (s N1)))}\n\ttrue.\n\n- : non-trivial-times-implies-much-gt* \n     (times/s (times/s N1*ssN2=P1 P1+ssN2=P2) P2+ssN2=N3) N3>sssN1\n    <- times-nonzero-implies-ge N1*ssN2=P1 P1>=N1\n    <- succ-preserves-ge P1>=N1 SP1>=sN1\n    <- plus-swap-succ-converse P1+ssN2=P2 SP1+sN2=P2\n    <- plus-commutative SP1+sN2=P2 SN2+sP1=P2\n    <- plus-implies-gt SN2+sP1=P2 eq/ P2>sP1\n    <- gt-transitive-ge P2>sP1 SP1>=sN1 P2>sN1\n    <- succ-preserves-gt P2>sN1 SP2>ssN1\n    <- gt-implies-ge-succ SP2>ssN1 SP2>=sssN1\n    <- plus-commutative P2+ssN2=N3 SSN2+P2=N3\n    <- plus-swap-succ SSN2+P2=N3 SN2+sP2=N3\n    <- plus-implies-gt SN2+sP2=N3 eq/ N3>sP2\n    <- gt-transitive-ge N3>sP2 SP2>=sssN1 N3>sssN1.\n\n%worlds () (non-trivial-times-implies-much-gt* _ _).\n%total { } (non-trivial-times-implies-much-gt* _ _).\n\n\n%theorem non-trivial-times-implies-much-gt :\n\tforall* {N1} {N2} {N3}\n\tforall {D:times (s (s N1)) (s (s N2)) N3}\n        exists {G1:gt N3 (s (s (s N1)))} {G2:gt N3 (s (s (s N2)))}\n\ttrue.\n\n- : non-trivial-times-implies-much-gt T G1 G2\n    <- non-trivial-times-implies-much-gt* T G1\n    <- times-commutative T Tc\n    <- non-trivial-times-implies-much-gt* Tc G2.\n\n%worlds () (non-trivial-times-implies-much-gt _ _ _).\n%total { } (non-trivial-times-implies-much-gt _ _ _).\n\n\n\n%theorem plus-left-preserves-ge* :\n\tforall* {X1} {X2} {X3} {X4} {X5}\n        forall {G:ge X2 X4}\n               {OP1:plus X1 X2 X3} {OP2:plus X1 X4 X5}\n        exists {G2:ge X3 X5}\n\ttrue.\n\n- : plus-left-preserves-ge* (ge/= eq/) X1+X2=X3 X1+X2=X5 (ge/= X3=X5)\n    <- plus-deterministic X1+X2=X3 X1+X2=X5 eq/ eq/ X3=X5.\n\n- : plus-left-preserves-ge* (ge/> X2>X4) X1+X2=X3 X1+X4=X5 (ge/> X3>X5)\n    <- plus-left-preserves-gt* X2>X4 X1+X2=X3 X1+X4=X5 X3>X5.\n\n%worlds () (plus-left-preserves-ge* X2>=X4 X1+X2=X3 X1+X4=X5  X3>=X5).\n%total {} (plus-left-preserves-ge* _ _ _ _).\n\n\n%theorem plus-left-cancels-ge :\n\tforall* {X1} {X2} {X3} {Y1} {Y2} {Y3}\n\tforall {OP1:plus X1 X2 X3} {OP2:plus Y1 Y2 Y3} {E1:eq X1 Y1} {G3:ge X3 Y3} \n\texists {G2:ge X2 Y2}\n\ttrue.\n\n- : plus-left-cancels-ge X1+X2=X3 X1+Y2=X3 eq/ (ge/= eq/) (ge/= X2=Y2)\n    <- plus-left-cancels X1+X2=X3 X1+Y2=X3 eq/ eq/ X2=Y2.\n\n- : plus-left-cancels-ge X1+X2=X3 X1+Y2=Y3 eq/ (ge/> X3>Y3) (ge/> X2>Y2)\n    <- plus-left-cancels-gt X1+X2=X3 X1+Y2=Y3 eq/ X3>Y3 X2>Y2.\n\n%worlds () (plus-left-cancels-ge X1+X2=X3 Y1+Y2=Y3 X1=Y1 X3>=Y3  X2>=Y2).\n%total {} (plus-left-cancels-ge _ _ _ _ _).\n\n\n\n%theorem plus-left-preserves-ge :\n\tforall* {X1} {X2} {X4}\n      \tforall {G:ge X2 X4}\n\texists {X3} {X5}\n               {O1:plus X1 X2 X3} {O2:plus X1 X4 X5}\n      \t       {G2:ge X3 X5}\n\ttrue.\n\n- : plus-left-preserves-ge X2>=X4 X3 X5 X1+X2=A3 X1+X4=X5 X3>=X5\n    <- plus-total X1+X2=A3 \n    <- plus-total X1+X4=X5\n    <- plus-left-preserves-ge* X2>=X4 X1+X2=A3 X1+X4=X5 X3>=X5.\n\n%worlds () (plus-left-preserves-ge X2>=X4  X3 X5 X1+X2=A3 X1+X4=X5 X3>=X5).\n%total {} (plus-left-preserves-ge _ _ _ _ _ _).\n\n\n%theorem plus-right-preserves-ge* :\n\tforall* {X1} {X2} {X3} {X4} {X5}\n\tforall {G1:ge X1 X2} {O1:plus X1 X3 X4} {O2:plus X2 X3 X5}\n\texists {G2:ge X4 X5}\n\ttrue.\n\n- : plus-right-preserves-ge* X1>=X2 X1+X3=X4 X2+X3=X5 X4>=X5\n    <- plus-commutative X1+X3=X4 X3+X1=X4\n    <- plus-commutative X2+X3=X5 X3+X2=X5\n    <- plus-left-preserves-ge* X1>=X2 X3+X1=X4 X3+X2=X5 X4>=X5.\n\n%worlds () (plus-right-preserves-ge* X1>=X2 X1+X3=X4 X2+X3=X5  X4>=X5).\n%total {} (plus-right-preserves-ge* _ _ _ _).\n\n\n%theorem plus-right-preserves-ge :\n\tforall* {X1} {X2} {X3}\n\tforall {G1:ge X1 X2} \n\texists {X4} {X5} {O1:plus X1 X3 X4} {O2:plus X2 X3 X5} {G2:ge X4 X5}\n\ttrue.\n\n- : plus-right-preserves-ge X1>=X2 X4 X5 X1+X3=X4 X2+X3=X5 X4>=X5\n    <- plus-total X1+X3=X4 \n    <- plus-total X2+X3=X5\n    <- plus-right-preserves-ge* X1>=X2 X1+X3=X4 X2+X3=X5 X4>=X5.\n%worlds () (plus-right-preserves-ge X1>=X2  X4 X5 X1+X3=X4 X2+X3=X5 X4>=X5).\n%total {} (plus-right-preserves-ge _ _ _ _ _ _).\n\n\n%theorem plus-preserves-ge* :\n\tforall* {X1} {X2} {X3} {Y1} {Y2} {Y3}\n\tforall {G1:ge X1 Y1} {G2:ge X2 Y2}\n               {MX:plus X1 X2 X3} {MY:plus Y1 Y2 Y3}\n        exists {G3:ge X3 Y3}\n\ttrue.\n\n- : plus-preserves-ge* X1>=Y1 X2>=Y2 X1+X2=X3 Y1+Y2=Y3 X3>=Y3\n    <- plus-total Y1+X2=X\n    <- plus-right-preserves-ge* X1>=Y1 X1+X2=X3 Y1+X2=X X3>=X\n    <- plus-left-preserves-ge* X2>=Y2 Y1+X2=X Y1+Y2=Y3 X>=Y3\n    <- ge-transitive X3>=X X>=Y3 X3>=Y3.\n\n%worlds () (plus-preserves-ge* X1>=Y1 X2>=Y2 X1+X2=X3 Y1+Y2=Y3  X3>=Y3).\n%total {} (plus-preserves-ge* _ _ _ _ _).\n\n\n%theorem plus-preserves-ge :\n\tforall* {X1} {X2} {Y1} {Y2}\n\tforall {G1:ge X1 Y1} {G2:ge X2 Y2}\n\texists {X3} {Y3} {MX:plus X1 X2 X3} {MY:plus Y1 Y2 Y3} {G3:ge X3 Y3}\n\ttrue.\n\n- : plus-preserves-ge X1>=Y1 X2>=Y2 X3 Y3 X1+X2=X3 Y1+Y2=Y3 X3>=Y3\n    <- plus-total X1+X2=X3\n    <- plus-total Y1+Y2=Y3\n    <- plus-preserves-ge* X1>=Y1 X2>=Y2 X1+X2=X3 Y1+Y2=Y3 X3>=Y3.\n\n%worlds () (plus-preserves-ge X1>=Y1 X2>=Y2  X3 Y3 X1+X2=X3 Y1+Y2=Y3 X3>=Y3).\n%total {} (plus-preserves-ge _ _ _ _ _ _ _).\n\n\n%theorem plus-right-cancels-ge :\n\tforall* {X1} {X2} {X3} {Y1} {Y2} {Y3}\n\tforall {OP1:plus X1 X2 X3} {OP2:plus Y1 Y2 Y3} {E2:eq X2 Y2} {G3:ge X3 Y3} \n\texists {G1:ge X1 Y1}\n\ttrue.\n\n- : plus-right-cancels-ge X1+X2=X3 Y1+Y2=Y3 X2=Y2 X3>=Y3 X1>=Y1\n    <- plus-commutative X1+X2=X3 X2+X1=X3\n    <- plus-commutative Y1+Y2=Y3 Y2+Y1=Y3\n    <- plus-left-cancels-ge X2+X1=X3 Y2+Y1=Y3 X2=Y2 X3>=Y3 X1>=Y1.\n\n%worlds () (plus-right-cancels-ge X1+X2=X3 Y1+Y2=Y3 X2=Y2 X3>=Y3  X1>=Y1).\n%total {} (plus-right-cancels-ge _ _ _ _ _).\n\n\n% Times preserves ge only because multiplying with zero yields equality.\n%theorem times-left-preserves-ge* :\n\tforall* {X1} {X2} {X3} {X4} {X5}\n        forall {G:ge X2 X4}\n               {OP1:times X1 X2 X3} {OP2:times X1 X4 X5}\n        exists {G2:ge X3 X5}\n\ttrue.\n\n- : times-left-preserves-ge* _ times/z times/z (ge/= eq/).\n\n- : times-left-preserves-ge* (ge/= eq/) X1*X2=X3 X1*X2=X5 (ge/= X3=X5)\n    <- times-deterministic X1*X2=X3 X1*X2=X5 eq/ eq/ X3=X5.\n\n- : times-left-preserves-ge* (ge/> X2>X4) X1*X2=X3 X1*X4=X5 (ge/> X3>X5)\n    <- times-left-preserves-gt X2>X4 X1*X2=X3 X1*X4=X5 X3>X5.\n\n%worlds () (times-left-preserves-ge* X2>=X4 X1*X2=X3 X1*X4=X5  X3>=X5).\n%total {} (times-left-preserves-ge* _ _ _ _).\n\n\n\n%theorem times-left-preserves-ge :\n\tforall* {X1} {X2} {X4}\n      \tforall {G:ge X2 X4}\n\texists {X3} {X5}\n               {O1:times X1 X2 X3} {O2:times X1 X4 X5}\n      \t       {G2:ge X3 X5}\n\ttrue.\n\n- : times-left-preserves-ge X2>=X4 X3 X5 X1*X2=A3 X1*X4=X5 X3>=X5\n    <- times-total X1*X2=A3 \n    <- times-total X1*X4=X5\n    <- times-left-preserves-ge* X2>=X4 X1*X2=A3 X1*X4=X5 X3>=X5.\n\n%worlds () (times-left-preserves-ge X2>=X4  X3 X5 X1*X2=A3 X1*X4=X5 X3>=X5).\n%total {} (times-left-preserves-ge _ _ _ _ _ _).\n\n\n%theorem times-right-preserves-ge* :\n\tforall* {X1} {X2} {X3} {X4} {X5}\n\tforall {G1:ge X1 X2} {O1:times X1 X3 X4} {O2:times X2 X3 X5}\n\texists {G2:ge X4 X5}\n\ttrue.\n\n- : times-right-preserves-ge* X1>=X2 X1*X3=X4 X2*X3=X5 X4>=X5\n    <- times-commutative X1*X3=X4 X3*X1=X4\n    <- times-commutative X2*X3=X5 X3*X2=X5\n    <- times-left-preserves-ge* X1>=X2 X3*X1=X4 X3*X2=X5 X4>=X5.\n\n%worlds () (times-right-preserves-ge* X1>=X2 X1*X3=X4 X2*X3=X5  X4>=X5).\n%total {} (times-right-preserves-ge* _ _ _ _).\n\n\n%theorem times-right-preserves-ge :\n\tforall* {X1} {X2} {X3}\n\tforall {G1:ge X1 X2} \n\texists {X4} {X5} {O1:times X1 X3 X4} {O2:times X2 X3 X5} {G2:ge X4 X5}\n\ttrue.\n\n- : times-right-preserves-ge X1>=X2 X4 X5 X1*X3=X4 X2*X3=X5 X4>=X5\n    <- times-total X1*X3=X4 \n    <- times-total X2*X3=X5\n    <- times-right-preserves-ge* X1>=X2 X1*X3=X4 X2*X3=X5 X4>=X5.\n%worlds () (times-right-preserves-ge X1>=X2  X4 X5 X1*X3=X4 X2*X3=X5 X4>=X5).\n%total {} (times-right-preserves-ge _ _ _ _ _ _).\n\n\n\n\n\n\n%%%% Definitions\n\n\n\nne : nat -> nat -> type.\n\n\nne/< : ne X Y\n    <- gt Y X.\n\nne/> : ne X Y\n    <- gt X Y.\n\n\n\n\neq? : nat -> nat -> bool -> type.\n\n\neq?/yes : eq? X X true.\n\neq?/no : eq? X Y false\n    <- ne X Y.\n\n\n\n\n%%%% Theorems\n\n\n\n%%% Theorems about ne\n\n\n%theorem false-implies-ne :\n\tforall* {X1} {X2}\n\tforall {F:void}\n\texists {G:ne X1 X2}\n\ttrue.\n\n%worlds () (false-implies-ne _ _).\n%total { } (false-implies-ne _ _).\n\n\n%theorem ne-respects-eq :\n\tforall* {X1} {X2} {Y1} {Y2}\n\tforall {D1:ne X1 X2} {E1:eq X1 Y1} {E2:eq X2 Y2}\n\texists {D2:ne Y1 Y2}\n\ttrue.\n\n- : ne-respects-eq X1<>X2 eq/ eq/ X1<>X2.\n\n%worlds () (ne-respects-eq _ _ _ _).\n%total { } (ne-respects-eq _ _ _ _).\n\n%theorem ne-anti-reflexive :\n\tforall* {X}\n\tforall {R:ne X X}\n\texists {F:void}\n\ttrue.\n\n- : ne-anti-reflexive (ne/< X<X) F\n    <- gt-anti-reflexive X<X F.\n\n- : ne-anti-reflexive (ne/> X>X) F\n    <- gt-anti-reflexive X>X F.\n\n%worlds () (ne-anti-reflexive X<>X  _).\n%total {} (ne-anti-reflexive _ _).\n\n\n%theorem ne-symmetric :\n\tforall* {X} {Y}\n\tforall {R1:ne X Y}\n\texists {R2:ne Y X}\n\ttrue.\n\n- : ne-symmetric (ne/< X<Y) (ne/> X<Y).\n\n- : ne-symmetric (ne/> X>Y) (ne/< X>Y).\n\n%worlds () (ne-symmetric X<>Y  Y<>X).\n%total {} (ne-symmetric _ _).\n\n\n%theorem eq-ne-implies-false :\n\tforall* {X} {Y}\n\tforall {D1:eq X Y} {D2:ne X Y}\n\texists {F:void}\n\ttrue.\n\n- : eq-ne-implies-false eq/ X<>X F\n    <- ne-anti-reflexive X<>X F.\n\n%worlds () (eq-ne-implies-false X=Y X<>Y  _).\n%total {} (eq-ne-implies-false _ _ _).\n\n\n%theorem ge-ne-implies-gt :\n\tforall* {X} {Y}\n\tforall {D1:ge X Y} {D2:ne X Y}\n\texists {D3:gt X Y}\n\ttrue.\n\n- : ge-ne-implies-gt (ge/> X>Y) _ X>Y.\n\n- : ge-ne-implies-gt (ge/= eq/) X<>X X>X\n    <- ne-anti-reflexive X<>X F\n    <- false-implies-gt F X>X.\n\n%worlds () (ge-ne-implies-gt X>=Y X<>Y  X>Y).\n%total {} (ge-ne-implies-gt _ _ _).\n\n\n%theorem eq?-total* :\n\tforall {M} {N}\n\texists {B} {T:eq? M N B}\n\ttrue.\n\n%theorem eq?-total*/L :\n\tforall* {M} {N} {C}\n\tforall {CMP:compare M N C}\n\texists {B} {T:eq? M N B}\n\ttrue.\n\n- : eq?-total*/L compare/= true eq?/yes.\n\n- : eq?-total*/L (compare/< X<Y) false (eq?/no (ne/< X<Y)).\n\n- : eq?-total*/L (compare/> X>Y) false (eq?/no (ne/> X>Y)).\n\n%worlds () (eq?-total*/L _ _ _).\n%total { } (eq?-total*/L _ _ _).\n\n- : eq?-total* M N B T\n    <- compare-total CMP\n    <- eq?-total*/L CMP B T.\n\n%worlds () (eq?-total* _ _ _ _).\n%total { } (eq?-total* _ _ _ _).\n\n\n%abbrev eq?-total = eq?-total* _ _ _.\n\n%theorem succ-preserves-ne :\n\tforall* {M} {N}\n\tforall {D:ne M N}\n\texists {D':ne (s M) (s N)}\n\ttrue.\n\n- : succ-preserves-ne (ne/< N>M) (ne/< N+1>M+1)\n    <- succ-preserves-gt N>M N+1>M+1.\n\n- : succ-preserves-ne (ne/> N>M) (ne/> N+1>M+1)\n    <- succ-preserves-gt N>M N+1>M+1.\n\n%worlds () (succ-preserves-ne M<>N  M+1<>N+1).\n%total {} (succ-preserves-ne _ _).\n\n\n%theorem succ-preserves-ne-converse :\n\tforall* {M} {N}\n\tforall {D':ne (s M) (s N)}\n\texists {D:ne M N}\n\ttrue.\n\n- : succ-preserves-ne-converse (ne/< N+1>M+1) (ne/< N>M)\n    <- succ-preserves-gt-converse N+1>M+1 N>M.\n\n- : succ-preserves-ne-converse (ne/> N+1>M+1) (ne/> N>M)\n    <- succ-preserves-gt-converse N+1>M+1 N>M.\n\n%worlds () (succ-preserves-ne-converse M+1<>N+1  M<>N).\n%total {} (succ-preserves-ne-converse _ _).\n\n\n\n%theorem plus-left-preserves-ne* :\n\tforall* {X1} {X2} {X3} {X4} {X5}\n        forall {G:ne X2 X4}\n               {OP1:plus X1 X2 X3} {OP2:plus X1 X4 X5}\n        exists {G2:ne X3 X5}\n\ttrue.\n\n- : plus-left-preserves-ne* (ne/< X4>X2) X1+X2=X3 X1+X4=X5 (ne/< X5>X3)\n    <- plus-left-preserves-gt* X4>X2 X1+X4=X5 X1+X2=X3 X5>X3.\n\n- : plus-left-preserves-ne* (ne/> X2>X4) X1+X2=X3 X1+X4=X5 (ne/> X3>X5)\n    <- plus-left-preserves-gt* X2>X4 X1+X2=X3 X1+X4=X5 X3>X5.\n\n%worlds () (plus-left-preserves-ne* X2<>X4 X1+X2=X3 X1+X4=X5  X3<>X5).\n%total {} (plus-left-preserves-ne* _ _ _ _).\n\n\n%theorem plus-left-cancels-ne :\n\tforall* {X1} {X2} {X3} {Y1} {Y2} {Y3}\n\tforall {OP1:plus X1 X2 X3} {OP2:plus Y1 Y2 Y3} {E1:eq X1 Y1} {G3:ne X3 Y3} \n\texists {G2:ne X2 Y2}\n\ttrue.\n\n- : plus-left-cancels-ne X1+X2=X3 X1+Y2=Y3 eq/ (ne/< Y3>X3) (ne/< Y2>X2)\n    <- plus-left-cancels-gt X1+Y2=Y3 X1+X2=X3 eq/ Y3>X3 Y2>X2.\n\n- : plus-left-cancels-ne X1+X2=X3 X1+Y2=Y3 eq/ (ne/> X3>Y3) (ne/> X2>Y2)\n    <- plus-left-cancels-gt X1+X2=X3 X1+Y2=Y3 eq/ X3>Y3 X2>Y2.\n\n%worlds () (plus-left-cancels-ne X1+X2=X3 Y1+Y2=Y3 X1=Y1 X3<>Y3  X2<>Y2).\n%total {} (plus-left-cancels-ne _ _ _ _ _).\n\n\n\n%theorem plus-left-preserves-ne :\n\tforall* {X1} {X2} {X4}\n      \tforall {G:ne X2 X4}\n\texists {X3} {X5}\n               {O1:plus X1 X2 X3} {O2:plus X1 X4 X5}\n      \t       {G2:ne X3 X5}\n\ttrue.\n\n- : plus-left-preserves-ne X2<>X4 X3 X5 X1+X2=A3 X1+X4=X5 X3<>X5\n    <- plus-total X1+X2=A3 \n    <- plus-total X1+X4=X5\n    <- plus-left-preserves-ne* X2<>X4 X1+X2=A3 X1+X4=X5 X3<>X5.\n\n%worlds () (plus-left-preserves-ne X2<>X4  X3 X5 X1+X2=A3 X1+X4=X5 X3<>X5).\n%total {} (plus-left-preserves-ne _ _ _ _ _ _).\n\n\n%theorem plus-right-preserves-ne* :\n\tforall* {X1} {X2} {X3} {X4} {X5}\n\tforall {G1:ne X1 X2} {O1:plus X1 X3 X4} {O2:plus X2 X3 X5}\n\texists {G2:ne X4 X5}\n\ttrue.\n\n- : plus-right-preserves-ne* X1<>X2 X1+X3=X4 X2+X3=X5 X4<>X5\n    <- plus-commutative X1+X3=X4 X3+X1=X4\n    <- plus-commutative X2+X3=X5 X3+X2=X5\n    <- plus-left-preserves-ne* X1<>X2 X3+X1=X4 X3+X2=X5 X4<>X5.\n\n%worlds () (plus-right-preserves-ne* X1<>X2 X1+X3=X4 X2+X3=X5  X4<>X5).\n%total {} (plus-right-preserves-ne* _ _ _ _).\n\n\n%theorem plus-right-preserves-ne :\n\tforall* {X1} {X2} {X3}\n\tforall {G1:ne X1 X2} \n\texists {X4} {X5} {O1:plus X1 X3 X4} {O2:plus X2 X3 X5} {G2:ne X4 X5}\n\ttrue.\n\n- : plus-right-preserves-ne X1<>X2 X4 X5 X1+X3=X4 X2+X3=X5 X4<>X5\n    <- plus-total X1+X3=X4 \n    <- plus-total X2+X3=X5\n    <- plus-right-preserves-ne* X1<>X2 X1+X3=X4 X2+X3=X5 X4<>X5.\n%worlds () (plus-right-preserves-ne X1<>X2  X4 X5 X1+X3=X4 X2+X3=X5 X4<>X5).\n%total {} (plus-right-preserves-ne _ _ _ _ _ _).\n\n\n%theorem plus-right-cancels-ne :\n\tforall* {X1} {X2} {X3} {Y1} {Y2} {Y3}\n\tforall {OP1:plus X1 X2 X3} {OP2:plus Y1 Y2 Y3} {E2:eq X2 Y2} {G3:ne X3 Y3} \n\texists {G1:ne X1 Y1}\n\ttrue.\n\n- : plus-right-cancels-ne X1+X2=X3 Y1+Y2=Y3 X2=Y2 X3<>Y3 X1<>Y1\n    <- plus-commutative X1+X2=X3 X2+X1=X3\n    <- plus-commutative Y1+Y2=Y3 Y2+Y1=Y3\n    <- plus-left-cancels-ne X2+X1=X3 Y2+Y1=Y3 X2=Y2 X3<>Y3 X1<>Y1.\n\n%worlds () (plus-right-cancels-ne X1+X2=X3 Y1+Y2=Y3 X2=Y2 X3<>Y3  X1<>Y1).\n%total {} (plus-right-cancels-ne _ _ _ _ _).\n\n\n\n\n\n\n\n%%%%% nat-less.elf\n%%%%% Inverse relations for natural numbers\n%%%%% This file is part of the nat.elf signature\n\n\n\n\n\n\n\n\n\n\n\n%%%% Definitions\n\n\n%abbrev lt = [X] [Y] gt Y X.\n\n\n\n\n%%%% Theorems about lt\n\n\n%theorem false-implies-lt :\n\tforall* {X1} {X2}\n\tforall {F:void}\n\texists {G:lt X1 X2}\n\ttrue.\n\n%worlds () (false-implies-lt _ _).\n%total { } (false-implies-lt _ _).\n\n\n%theorem lt-respects-eq :\n\tforall* {X1} {X2} {Y1} {Y2}\n\tforall {D1:lt X1 X2} {E1:eq X1 Y1} {E2:eq X2 Y2}\n\texists {D2:lt Y1 Y2}\n\ttrue.\n\n- : lt-respects-eq X1<X2 eq/ eq/ X1<X2.\n\n%worlds () (lt-respects-eq _ _ _ _).\n%total { } (lt-respects-eq _ _ _ _).\n\n%theorem lt-anti-symmetric :\n\tforall* {X1} {X2}\n\tforall {G1:lt X1 X2} {G2:lt X2 X1}\n\texists {F:void}\n\ttrue.\n\n- : lt-anti-symmetric X2>X1 X1>X2 R\n    <- gt-anti-symmetric X1>X2 X2>X1 R.\n\n%worlds () (lt-anti-symmetric _ _ _).\n%total {} (lt-anti-symmetric _ _ _).\n\n\n%theorem lt-transitive : \n\tforall* {X1} {X2} {X3}\n\tforall {G1:lt X1 X2} {G2:lt X2 X3}\n\texists {G3:lt X1 X3}\n\ttrue.\n\n- : lt-transitive X1<X2 X2<X3 X1<X3\n    <- gt-transitive X2<X3 X1<X2 X1<X3.\n\n%worlds () (lt-transitive X1<X2 X2<X3 X1<X3).\n%total {} (lt-transitive _ _ _).\n\n\n\n\n\n\n\n%abbrev lt-anti-reflexive = gt-anti-reflexive.\n\n%theorem plus-left-preserves-lt* :\n\tforall* {X1} {X2} {X3} {X4} {X5}\n        forall {R1:lt X2 X4}\n               {OP1:plus X1 X2 X3} {OP2:plus X1 X4 X5}\n        exists {R2:lt X3 X5}\n\ttrue.\n\n- : plus-left-preserves-lt* X4>X2 X1+X2=X3 X1+X4=X5 X5>X3\n    <- plus-left-preserves-gt* X4>X2 X1+X4=X5 X1+X2=X3 X5>X3.\n\n%worlds () (plus-left-preserves-lt* X2<X4 X1+X2=X3 X1+X4=X5  X3<X5).\n%total {} (plus-left-preserves-lt* _ _ _ _).\n\n\n%theorem plus-left-cancels-lt :\n\tforall* {X1} {X2} {X3} {Y1} {Y2} {Y3}\n\tforall {OP1:plus X1 X2 X3} {OP2:plus Y1 Y2 Y3} {E1:eq X1 Y1} {R3:lt X3 Y3} \n\texists {R2:lt X2 Y2}\n\ttrue.\n\n- : plus-left-cancels-lt X1+X2=X3 X1+Y2=X3 eq/ Y3>X3 Y2>X2\n    <-  plus-left-cancels-gt X1+Y2=X3 X1+X2=X3 eq/ Y3>X3 Y2>X2.\n\n%worlds () (plus-left-cancels-lt X1+X2=X3 Y1+Y2=Y3 X1=Y1 X3<Y3  X2<Y2).\n%total {} (plus-left-cancels-lt _ _ _ _ _).\n\n\n\n%theorem plus-left-preserves-lt :\n\tforall* {X1} {X2} {X4}\n      \tforall {G:lt X2 X4}\n\texists {X3} {X5}\n               {O1:plus X1 X2 X3} {O2:plus X1 X4 X5}\n      \t       {G2:lt X3 X5}\n\ttrue.\n\n- : plus-left-preserves-lt X2<X4 X3 X5 X1+X2=A3 X1+X4=X5 X3<X5\n    <- plus-total X1+X2=A3 \n    <- plus-total X1+X4=X5\n    <- plus-left-preserves-lt* X2<X4 X1+X2=A3 X1+X4=X5 X3<X5.\n\n%worlds () (plus-left-preserves-lt X2<X4  X3 X5 X1+X2=A3 X1+X4=X5 X3<X5).\n%total {} (plus-left-preserves-lt _ _ _ _ _ _).\n\n\n%theorem plus-right-preserves-lt* :\n\tforall* {X1} {X2} {X3} {X4} {X5}\n\tforall {G1:lt X1 X2} {O1:plus X1 X3 X4} {O2:plus X2 X3 X5}\n\texists {G2:lt X4 X5}\n\ttrue.\n\n- : plus-right-preserves-lt* X1<X2 X1+X3=X4 X2+X3=X5 X4<X5\n    <- plus-commutative X1+X3=X4 X3+X1=X4\n    <- plus-commutative X2+X3=X5 X3+X2=X5\n    <- plus-left-preserves-lt* X1<X2 X3+X1=X4 X3+X2=X5 X4<X5.\n\n%worlds () (plus-right-preserves-lt* X1<X2 X1+X3=X4 X2+X3=X5  X4<X5).\n%total {} (plus-right-preserves-lt* _ _ _ _).\n\n\n%theorem plus-right-preserves-lt :\n\tforall* {X1} {X2} {X3}\n\tforall {G1:lt X1 X2} \n\texists {X4} {X5} {O1:plus X1 X3 X4} {O2:plus X2 X3 X5} {G2:lt X4 X5}\n\ttrue.\n\n- : plus-right-preserves-lt X1<X2 X4 X5 X1+X3=X4 X2+X3=X5 X4<X5\n    <- plus-total X1+X3=X4 \n    <- plus-total X2+X3=X5\n    <- plus-right-preserves-lt* X1<X2 X1+X3=X4 X2+X3=X5 X4<X5.\n%worlds () (plus-right-preserves-lt X1<X2  X4 X5 X1+X3=X4 X2+X3=X5 X4<X5).\n%total {} (plus-right-preserves-lt _ _ _ _ _ _).\n\n\n%theorem plus-preserves-lt* :\n\tforall* {X1} {X2} {X3} {Y1} {Y2} {Y3}\n\tforall {G1:lt X1 Y1} {G2:lt X2 Y2}\n               {MX:plus X1 X2 X3} {MY:plus Y1 Y2 Y3}\n        exists {G3:lt X3 Y3}\n\ttrue.\n\n- : plus-preserves-lt* X1<Y1 X2<Y2 X1+X2=X3 Y1+Y2=Y3 X3<Y3\n    <- plus-total Y1+X2=X\n    <- plus-right-preserves-lt* X1<Y1 X1+X2=X3 Y1+X2=X X3<X\n    <- plus-left-preserves-lt* X2<Y2 Y1+X2=X Y1+Y2=Y3 X<Y3\n    <- lt-transitive X3<X X<Y3 X3<Y3.\n\n%worlds () (plus-preserves-lt* X1<Y1 X2<Y2 X1+X2=X3 Y1+Y2=Y3  X3<Y3).\n%total {} (plus-preserves-lt* _ _ _ _ _).\n\n\n%theorem plus-preserves-lt :\n\tforall* {X1} {X2} {Y1} {Y2}\n\tforall {G1:lt X1 Y1} {G2:lt X2 Y2}\n\texists {X3} {Y3} {MX:plus X1 X2 X3} {MY:plus Y1 Y2 Y3} {G3:lt X3 Y3}\n\ttrue.\n\n- : plus-preserves-lt X1<Y1 X2<Y2 X3 Y3 X1+X2=X3 Y1+Y2=Y3 X3<Y3\n    <- plus-total X1+X2=X3\n    <- plus-total Y1+Y2=Y3\n    <- plus-preserves-lt* X1<Y1 X2<Y2 X1+X2=X3 Y1+Y2=Y3 X3<Y3.\n\n%worlds () (plus-preserves-lt X1<Y1 X2<Y2  X3 Y3 X1+X2=X3 Y1+Y2=Y3 X3<Y3).\n%total {} (plus-preserves-lt _ _ _ _ _ _ _).\n\n\n%theorem plus-right-cancels-lt :\n\tforall* {X1} {X2} {X3} {Y1} {Y2} {Y3}\n\tforall {OP1:plus X1 X2 X3} {OP2:plus Y1 Y2 Y3} {E2:eq X2 Y2} {G3:lt X3 Y3} \n\texists {G1:lt X1 Y1}\n\ttrue.\n\n- : plus-right-cancels-lt X1+X2=X3 Y1+Y2=Y3 X2=Y2 X3<Y3 X1<Y1\n    <- plus-commutative X1+X2=X3 X2+X1=X3\n    <- plus-commutative Y1+Y2=Y3 Y2+Y1=Y3\n    <- plus-left-cancels-lt X2+X1=X3 Y2+Y1=Y3 X2=Y2 X3<Y3 X1<Y1.\n\n%worlds () (plus-right-cancels-lt X1+X2=X3 Y1+Y2=Y3 X2=Y2 X3<Y3  X1<Y1).\n%total {} (plus-right-cancels-lt _ _ _ _ _).\n\n\n\n\n\n\n\n\n\n\n\n\n%%%% Definitions\n\n\n%abbrev le = [X] [Y] ge Y X.\n\n\n\n\n%%%% Theorems about le\n\n\n%theorem false-implies-le :\n\tforall* {X1} {X2}\n\tforall {F:void}\n\texists {G:le X1 X2}\n\ttrue.\n\n%worlds () (false-implies-le _ _).\n%total { } (false-implies-le _ _).\n\n\n%theorem le-respects-eq :\n\tforall* {X1} {X2} {Y1} {Y2}\n\tforall {D1:le X1 X2} {E1:eq X1 Y1} {E2:eq X2 Y2}\n\texists {D2:le Y1 Y2}\n\ttrue.\n\n- : le-respects-eq X1<=X2 eq/ eq/ X1<=X2.\n\n%worlds () (le-respects-eq _ _ _ _).\n%total { } (le-respects-eq _ _ _ _).\n\n%theorem le-anti-symmetric :\n\tforall* {X1} {X2}\n\tforall {G1:le X1 X2} {G2:le X2 X1}\n\texists {E3:eq X1 X2}\n\ttrue.\n\n- : le-anti-symmetric X2>=X1 X1>=X2 R\n    <- ge-anti-symmetric X1>=X2 X2>=X1 R.\n\n%worlds () (le-anti-symmetric _ _ _).\n%total {} (le-anti-symmetric _ _ _).\n\n\n%theorem le-transitive : \n\tforall* {X1} {X2} {X3}\n\tforall {G1:le X1 X2} {G2:le X2 X3}\n\texists {G3:le X1 X3}\n\ttrue.\n\n- : le-transitive X1<=X2 X2<=X3 X1<=X3\n    <- ge-transitive X2<=X3 X1<=X2 X1<=X3.\n\n%worlds () (le-transitive X1<=X2 X2<=X3 X1<=X3).\n%total {} (le-transitive _ _ _).\n\n\n\n\n\n\n\n\n%abbrev le-reflexive = ge-reflexive.\n\n%theorem le-transitive-lt:\n\tforall* {X1} {X2} {X3}\n\tforall {L1:le X1 X2} {L2:lt X2 X3}\n\texists {L3:lt X1 X3}\n\ttrue.\n- : le-transitive-lt X2>=X1 X3>X2 X3>X1\n    <- gt-transitive-ge X3>X2 X2>=X1 X3>X1.\n%worlds () (le-transitive-lt X1<=X2 X2<X3  X1<X3).\n%total {} (le-transitive-lt _ _ _).\n\n%theorem lt-transitive-le:\n\tforall* {X1} {X2} {X3}\n\tforall {L1:lt X1 X2} {L2:le X2 X3}\n\texists {L3:lt X1 X3}\n\ttrue.\n- : lt-transitive-le X2>X1 X3>=X2 X3>X1\n    <- ge-transitive-gt X3>=X2 X2>X1 X3>X1.\n%worlds () (lt-transitive-le X1<X2 X2<=X3  X1<X3).\n%total {} (lt-transitive-le _ _ _).\n\n%theorem plus-left-preserves-le* :\n\tforall* {X1} {X2} {X3} {X4} {X5}\n        forall {R1:le X2 X4}\n               {OP1:plus X1 X2 X3} {OP2:plus X1 X4 X5}\n        exists {R2:le X3 X5}\n\ttrue.\n\n- : plus-left-preserves-le* X4>=X2 X1+X2=X3 X1+X4=X5 X5>=X3\n    <- plus-left-preserves-ge* X4>=X2 X1+X4=X5 X1+X2=X3 X5>=X3.\n\n%worlds () (plus-left-preserves-le* X2<=X4 X1+X2=X3 X1+X4=X5  X3<=X5).\n%total {} (plus-left-preserves-le* _ _ _ _).\n\n\n%theorem plus-left-cancels-le :\n\tforall* {X1} {X2} {X3} {Y1} {Y2} {Y3}\n\tforall {OP1:plus X1 X2 X3} {OP2:plus Y1 Y2 Y3} {E1:eq X1 Y1} {R3:le X3 Y3} \n\texists {R2:le X2 Y2}\n\ttrue.\n\n- : plus-left-cancels-le X1+X2=X3 X1+Y2=X3 eq/ Y3>=X3 Y2>=X2\n    <-  plus-left-cancels-ge X1+Y2=X3 X1+X2=X3 eq/ Y3>=X3 Y2>=X2.\n\n%worlds () (plus-left-cancels-le X1+X2=X3 Y1+Y2=Y3 X1=Y1 X3<=Y3  X2<=Y2).\n%total {} (plus-left-cancels-le _ _ _ _ _).\n\n\n\n%theorem plus-left-preserves-le :\n\tforall* {X1} {X2} {X4}\n      \tforall {G:le X2 X4}\n\texists {X3} {X5}\n               {O1:plus X1 X2 X3} {O2:plus X1 X4 X5}\n      \t       {G2:le X3 X5}\n\ttrue.\n\n- : plus-left-preserves-le X2<=X4 X3 X5 X1+X2=A3 X1+X4=X5 X3<=X5\n    <- plus-total X1+X2=A3 \n    <- plus-total X1+X4=X5\n    <- plus-left-preserves-le* X2<=X4 X1+X2=A3 X1+X4=X5 X3<=X5.\n\n%worlds () (plus-left-preserves-le X2<=X4  X3 X5 X1+X2=A3 X1+X4=X5 X3<=X5).\n%total {} (plus-left-preserves-le _ _ _ _ _ _).\n\n\n%theorem plus-right-preserves-le* :\n\tforall* {X1} {X2} {X3} {X4} {X5}\n\tforall {G1:le X1 X2} {O1:plus X1 X3 X4} {O2:plus X2 X3 X5}\n\texists {G2:le X4 X5}\n\ttrue.\n\n- : plus-right-preserves-le* X1<=X2 X1+X3=X4 X2+X3=X5 X4<=X5\n    <- plus-commutative X1+X3=X4 X3+X1=X4\n    <- plus-commutative X2+X3=X5 X3+X2=X5\n    <- plus-left-preserves-le* X1<=X2 X3+X1=X4 X3+X2=X5 X4<=X5.\n\n%worlds () (plus-right-preserves-le* X1<=X2 X1+X3=X4 X2+X3=X5  X4<=X5).\n%total {} (plus-right-preserves-le* _ _ _ _).\n\n\n%theorem plus-right-preserves-le :\n\tforall* {X1} {X2} {X3}\n\tforall {G1:le X1 X2} \n\texists {X4} {X5} {O1:plus X1 X3 X4} {O2:plus X2 X3 X5} {G2:le X4 X5}\n\ttrue.\n\n- : plus-right-preserves-le X1<=X2 X4 X5 X1+X3=X4 X2+X3=X5 X4<=X5\n    <- plus-total X1+X3=X4 \n    <- plus-total X2+X3=X5\n    <- plus-right-preserves-le* X1<=X2 X1+X3=X4 X2+X3=X5 X4<=X5.\n%worlds () (plus-right-preserves-le X1<=X2  X4 X5 X1+X3=X4 X2+X3=X5 X4<=X5).\n%total {} (plus-right-preserves-le _ _ _ _ _ _).\n\n\n%theorem plus-preserves-le* :\n\tforall* {X1} {X2} {X3} {Y1} {Y2} {Y3}\n\tforall {G1:le X1 Y1} {G2:le X2 Y2}\n               {MX:plus X1 X2 X3} {MY:plus Y1 Y2 Y3}\n        exists {G3:le X3 Y3}\n\ttrue.\n\n- : plus-preserves-le* X1<=Y1 X2<=Y2 X1+X2=X3 Y1+Y2=Y3 X3<=Y3\n    <- plus-total Y1+X2=X\n    <- plus-right-preserves-le* X1<=Y1 X1+X2=X3 Y1+X2=X X3<=X\n    <- plus-left-preserves-le* X2<=Y2 Y1+X2=X Y1+Y2=Y3 X<=Y3\n    <- le-transitive X3<=X X<=Y3 X3<=Y3.\n\n%worlds () (plus-preserves-le* X1<=Y1 X2<=Y2 X1+X2=X3 Y1+Y2=Y3  X3<=Y3).\n%total {} (plus-preserves-le* _ _ _ _ _).\n\n\n%theorem plus-preserves-le :\n\tforall* {X1} {X2} {Y1} {Y2}\n\tforall {G1:le X1 Y1} {G2:le X2 Y2}\n\texists {X3} {Y3} {MX:plus X1 X2 X3} {MY:plus Y1 Y2 Y3} {G3:le X3 Y3}\n\ttrue.\n\n- : plus-preserves-le X1<=Y1 X2<=Y2 X3 Y3 X1+X2=X3 Y1+Y2=Y3 X3<=Y3\n    <- plus-total X1+X2=X3\n    <- plus-total Y1+Y2=Y3\n    <- plus-preserves-le* X1<=Y1 X2<=Y2 X1+X2=X3 Y1+Y2=Y3 X3<=Y3.\n\n%worlds () (plus-preserves-le X1<=Y1 X2<=Y2  X3 Y3 X1+X2=X3 Y1+Y2=Y3 X3<=Y3).\n%total {} (plus-preserves-le _ _ _ _ _ _ _).\n\n\n%theorem plus-right-cancels-le :\n\tforall* {X1} {X2} {X3} {Y1} {Y2} {Y3}\n\tforall {OP1:plus X1 X2 X3} {OP2:plus Y1 Y2 Y3} {E2:eq X2 Y2} {G3:le X3 Y3} \n\texists {G1:le X1 Y1}\n\ttrue.\n\n- : plus-right-cancels-le X1+X2=X3 Y1+Y2=Y3 X2=Y2 X3<=Y3 X1<=Y1\n    <- plus-commutative X1+X2=X3 X2+X1=X3\n    <- plus-commutative Y1+Y2=Y3 Y2+Y1=Y3\n    <- plus-left-cancels-le X2+X1=X3 Y2+Y1=Y3 X2=Y2 X3<=Y3 X1<=Y1.\n\n%worlds () (plus-right-cancels-le X1+X2=X3 Y1+Y2=Y3 X2=Y2 X3<=Y3  X1<=Y1).\n%total {} (plus-right-cancels-le _ _ _ _ _).\n\n\n%theorem times-left-preserves-le* :\n\tforall* {X1} {X2} {X3} {X4} {X5}\n        forall {R1:le X2 X4}\n               {OP1:times X1 X2 X3} {OP2:times X1 X4 X5}\n        exists {R2:le X3 X5}\n\ttrue.\n\n- : times-left-preserves-le* X4>=X2 X1*X2=X3 X1*X4=X5 X5>=X3\n    <- times-left-preserves-ge* X4>=X2 X1*X4=X5 X1*X2=X3 X5>=X3.\n\n%worlds () (times-left-preserves-le* X2<=X4 X1*X2=X3 X1*X4=X5  X3<=X5).\n%total {} (times-left-preserves-le* _ _ _ _).\n\n\n\n%theorem times-left-preserves-le :\n\tforall* {X1} {X2} {X4}\n      \tforall {G:le X2 X4}\n\texists {X3} {X5}\n               {O1:times X1 X2 X3} {O2:times X1 X4 X5}\n      \t       {G2:le X3 X5}\n\ttrue.\n\n- : times-left-preserves-le X2<=X4 X3 X5 X1*X2=A3 X1*X4=X5 X3<=X5\n    <- times-total X1*X2=A3 \n    <- times-total X1*X4=X5\n    <- times-left-preserves-le* X2<=X4 X1*X2=A3 X1*X4=X5 X3<=X5.\n\n%worlds () (times-left-preserves-le X2<=X4  X3 X5 X1*X2=A3 X1*X4=X5 X3<=X5).\n%total {} (times-left-preserves-le _ _ _ _ _ _).\n\n\n%theorem times-right-preserves-le* :\n\tforall* {X1} {X2} {X3} {X4} {X5}\n\tforall {G1:le X1 X2} {O1:times X1 X3 X4} {O2:times X2 X3 X5}\n\texists {G2:le X4 X5}\n\ttrue.\n\n- : times-right-preserves-le* X1<=X2 X1*X3=X4 X2*X3=X5 X4<=X5\n    <- times-commutative X1*X3=X4 X3*X1=X4\n    <- times-commutative X2*X3=X5 X3*X2=X5\n    <- times-left-preserves-le* X1<=X2 X3*X1=X4 X3*X2=X5 X4<=X5.\n\n%worlds () (times-right-preserves-le* X1<=X2 X1*X3=X4 X2*X3=X5  X4<=X5).\n%total {} (times-right-preserves-le* _ _ _ _).\n\n\n%theorem times-right-preserves-le :\n\tforall* {X1} {X2} {X3}\n\tforall {G1:le X1 X2} \n\texists {X4} {X5} {O1:times X1 X3 X4} {O2:times X2 X3 X5} {G2:le X4 X5}\n\ttrue.\n\n- : times-right-preserves-le X1<=X2 X4 X5 X1*X3=X4 X2*X3=X5 X4<=X5\n    <- times-total X1*X3=X4 \n    <- times-total X2*X3=X5\n    <- times-right-preserves-le* X1<=X2 X1*X3=X4 X2*X3=X5 X4<=X5.\n%worlds () (times-right-preserves-le X1<=X2  X4 X5 X1*X3=X4 X2*X3=X5 X4<=X5).\n%total {} (times-right-preserves-le _ _ _ _ _ _).\n\n\n%theorem times-preserves-le* :\n\tforall* {X1} {X2} {X3} {Y1} {Y2} {Y3}\n\tforall {G1:le X1 Y1} {G2:le X2 Y2}\n               {MX:times X1 X2 X3} {MY:times Y1 Y2 Y3}\n        exists {G3:le X3 Y3}\n\ttrue.\n\n- : times-preserves-le* X1<=Y1 X2<=Y2 X1*X2=X3 Y1*Y2=Y3 X3<=Y3\n    <- times-total Y1*X2=X\n    <- times-right-preserves-le* X1<=Y1 X1*X2=X3 Y1*X2=X X3<=X\n    <- times-left-preserves-le* X2<=Y2 Y1*X2=X Y1*Y2=Y3 X<=Y3\n    <- le-transitive X3<=X X<=Y3 X3<=Y3.\n\n%worlds () (times-preserves-le* X1<=Y1 X2<=Y2 X1*X2=X3 Y1*Y2=Y3  X3<=Y3).\n%total {} (times-preserves-le* _ _ _ _ _).\n\n\n%theorem times-preserves-le :\n\tforall* {X1} {X2} {Y1} {Y2}\n\tforall {G1:le X1 Y1} {G2:le X2 Y2}\n\texists {X3} {Y3} {MX:times X1 X2 X3} {MY:times Y1 Y2 Y3} {G3:le X3 Y3}\n\ttrue.\n\n- : times-preserves-le X1<=Y1 X2<=Y2 X3 Y3 X1*X2=X3 Y1*Y2=Y3 X3<=Y3\n    <- times-total X1*X2=X3\n    <- times-total Y1*Y2=Y3\n    <- times-preserves-le* X1<=Y1 X2<=Y2 X1*X2=X3 Y1*Y2=Y3 X3<=Y3.\n\n%worlds () (times-preserves-le X1<=Y1 X2<=Y2  X3 Y3 X1*X2=X3 Y1*Y2=Y3 X3<=Y3).\n%total {} (times-preserves-le _ _ _ _ _ _ _).\n\n\n\n\n\n\n%%%%% nat-inv-comp.elf\n%%%%% Theorems about minus and composed relations\n%%%%% This file is part of the nat.elf signature\n\n\n%%%% Theorems\n\n\n\n%%% Theorems about minus\n\n\n\n%theorem minus-left-inverts-ge* :\n\tforall* {X1} {X2} {X3} {X4} {X5}\n        forall {G:ge X2 X4}\n               {IOP1:minus X1 X2 X3} {IOP2:minus X1 X4 X5}\n        exists {GP:ge X5 X3}\n\ttrue.\n\n- : minus-left-inverts-ge* X2>=X4 X3+X2=X1 X5+X4=X1 X5>=X3\n    <- plus-total X3+X4=X7\n    <- plus-left-preserves-ge* X2>=X4 X3+X2=X1 X3+X4=X7 X1>=X7\n    <- plus-right-cancels-ge X5+X4=X1 X3+X4=X7 eq/ X1>=X7 X5>=X3.\n\n%worlds () (minus-left-inverts-ge* X2>=X4 X1-X2=X3 X1-X4=X5  X5>=X3).\n%total {} (minus-left-inverts-ge* _ _ _ _).\n\n\n%theorem minus-right-preserves-ge* :\n\tforall* {X1} {X2} {X3} {X4} {X5}\n        forall {G:ge X1 X2}\n               {IOP1:minus X1 X3 X4} {IOP2:minus X2 X3 X5}\n        exists {GP:ge X4 X5}\n\ttrue.\n\n- : minus-right-preserves-ge*  X1>=X2 X4+X3=X1 X5+X3=X2 X4>=X5\n    <- plus-right-cancels-ge X4+X3=X1 X5+X3=X2 eq/ X1>=X2 X4>=X5.\n\n%worlds () (minus-right-preserves-ge* X1>=X2 X1-X3=X4 X2-X3=X5  X4>=X5).\n%total {} (minus-right-preserves-ge* _ _ _ _).\n\n\n%theorem minus-left-cancels-inverts-ge :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X6}\n\tforall {IOP1:minus X1 X2 X3} {IOP2:minus X4 X5 X6}\n               {E:eq X1 X4} {G:ge X3 X6}\n        exists {GP:ge X5 X2}\n\ttrue.\n\n- : minus-left-cancels-inverts-ge X3+X2=X1 X6+X5=X4 X1=X4 X3>=X6 X5>=X2\n    <- plus-total X6+X2=X7\n    <- plus-right-preserves-ge* X3>=X6 X3+X2=X1 X6+X2=X7 X1>=X7\n    <- eq-symmetric X1=X4 X4=X1\n    <- plus-respects-eq X6+X5=X4 eq/ eq/ X4=X1 X6+X5=X1\n    <- plus-left-cancels-ge X6+X5=X1 X6+X2=X7 eq/ X1>=X7 X5>=X2.\n\n%worlds () (minus-left-cancels-inverts-ge X1-X2=X3 X4-X5=X6 X1=X4 X3>=X6 \n                                   X5>=X2).\n%total {} (minus-left-cancels-inverts-ge _ _ _ _ _).\n\n\n%theorem minus-right-cancels-ge :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X6}\n\tforall {IOP1:minus X1 X2 X3} {IOP2:minus X4 X5 X6}\n               {E2:eq X2 X5} {G3:ge X3 X6}\n        exists {G1:ge X1 X4}\n\ttrue.\n\n- : minus-right-cancels-ge X3+X2=X1 X6+X5=X4 X2=X5 X3>=X6 X1>=X4\n    <- plus-respects-eq X3+X2=X1 eq/ X2=X5 eq/ X3+X5=X1\n    <- plus-right-preserves-ge* X3>=X6 X3+X5=X1 X6+X5=X4 X1>=X4.\n\n%worlds () (minus-right-cancels-ge X1-X2=X3 X4-X5=X6 X2=X5 X3>=X6 \n                            X1>=X4).\n%total {} (minus-right-cancels-ge _ _ _ _ _).\n\n\n\n%theorem minus-left-preserves-ne* :\n\tforall* {X1} {X2} {X3} {X4} {X5}\n        forall {G:ne X2 X4}\n               {IOP1:minus X1 X2 X3} {IOP2:minus X1 X4 X5}\n        exists {GP:ne X3 X5}\n\ttrue.\n\n- : minus-left-preserves-ne* X2<>X4 X3+X2=X1 X5+X4=X1 X3<>X5\n    <- plus-total X3+X4=X7\n    <- plus-left-preserves-ne* X2<>X4 X3+X2=X1 X3+X4=X7 X1<>X7\n    <- plus-right-cancels-ne X5+X4=X1 X3+X4=X7 eq/ X1<>X7 X5<>X3\n    <- ne-symmetric X5<>X3 X3<>X5.\n\n%worlds () (minus-left-preserves-ne* X2<>X4 X1-X2=X3 X1-X4=X5  X3<>X5).\n%total {} (minus-left-preserves-ne* _ _ _ _).\n\n\n%theorem minus-right-preserves-ne* :\n\tforall* {X1} {X2} {X3} {X4} {X5}\n        forall {G:ne X1 X2}\n               {IOP1:minus X1 X3 X4} {IOP2:minus X2 X3 X5}\n        exists {GP:ne X4 X5}\n\ttrue.\n\n- : minus-right-preserves-ne*  X1<>X2 X4+X3=X1 X5+X3=X2 X4<>X5\n    <- plus-right-cancels-ne X4+X3=X1 X5+X3=X2 eq/ X1<>X2 X4<>X5.\n\n%worlds () (minus-right-preserves-ne* X1<>X2 X1-X3=X4 X2-X3=X5  X4<>X5).\n%total {} (minus-right-preserves-ne* _ _ _ _).\n\n\n%theorem minus-left-cancels-ne :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X6}\n\tforall {IOP1:minus X1 X2 X3} {IOP2:minus X4 X5 X6}\n               {E:eq X1 X4} {G:ne X3 X6}\n        exists {GP:ne X2 X5}\n\ttrue.\n\n- : minus-left-cancels-ne X3+X2=X1 X6+X5=X4 X1=X4 X3<>X6 X2<>X5\n    <- plus-total X6+X2=X7\n    <- plus-right-preserves-ne* X3<>X6 X3+X2=X1 X6+X2=X7 X1<>X7\n    <- eq-symmetric X1=X4 X4=X1\n    <- plus-respects-eq X6+X5=X4 eq/ eq/ X4=X1 X6+X5=X1\n    <- plus-left-cancels-ne X6+X5=X1 X6+X2=X7 eq/ X1<>X7 X5<>X2\n    <- ne-symmetric X5<>X2 X2<>X5.\n\n%worlds () (minus-left-cancels-ne X1-X2=X3 X4-X5=X6 X1=X4 X3<>X6 \n                                   X2<>X5).\n%total {} (minus-left-cancels-ne _ _ _ _ _).\n\n\n%theorem minus-right-cancels-ne :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X6}\n\tforall {IOP1:minus X1 X2 X3} {IOP2:minus X4 X5 X6}\n               {E2:eq X2 X5} {G3:ne X3 X6}\n        exists {G1:ne X1 X4}\n\ttrue.\n\n- : minus-right-cancels-ne X3+X2=X1 X6+X5=X4 X2=X5 X3<>X6 X1<>X4\n    <- plus-respects-eq X3+X2=X1 eq/ X2=X5 eq/ X3+X5=X1\n    <- plus-right-preserves-ne* X3<>X6 X3+X5=X1 X6+X5=X4 X1<>X4.\n\n%worlds () (minus-right-cancels-ne X1-X2=X3 X4-X5=X6 X2=X5 X3<>X6 \n                            X1<>X4).\n%total {} (minus-right-cancels-ne _ _ _ _ _).\n\n\n\n\n\n\n%%%%% nat-inv-less.elf\n%%%%% Theorems about minus and inverted relations\n%%%%% This file is part of the nat.elf signature\n\n\n\n\n%%%% Theorems\n\n\n\n%%% Theorems about minus\n\n\n\n%theorem minus-left-inverts-lt* :\n\tforall* {X1} {X2} {X3} {X4} {X5}\n        forall {G:lt X2 X4}\n               {IOP1:minus X1 X2 X3} {IOP2:minus X1 X4 X5}\n        exists {GP:lt X5 X3}\n\ttrue.\n\n- : minus-left-inverts-lt* X2<X4 X3+X2=X1 X5+X4=X1 X5<X3\n    <- plus-total X3+X4=X7\n    <- plus-left-preserves-lt* X2<X4 X3+X2=X1 X3+X4=X7 X1<X7\n    <- plus-right-cancels-lt X5+X4=X1 X3+X4=X7 eq/ X1<X7 X5<X3.\n\n%worlds () (minus-left-inverts-lt* X2<X4 X1-X2=X3 X1-X4=X5  X5<X3).\n%total {} (minus-left-inverts-lt* _ _ _ _).\n\n\n%theorem minus-right-preserves-lt* :\n\tforall* {X1} {X2} {X3} {X4} {X5}\n        forall {G:lt X1 X2}\n               {IOP1:minus X1 X3 X4} {IOP2:minus X2 X3 X5}\n        exists {GP:lt X4 X5}\n\ttrue.\n\n- : minus-right-preserves-lt*  X1<X2 X4+X3=X1 X5+X3=X2 X4<X5\n    <- plus-right-cancels-lt X4+X3=X1 X5+X3=X2 eq/ X1<X2 X4<X5.\n\n%worlds () (minus-right-preserves-lt* X1<X2 X1-X3=X4 X2-X3=X5  X4<X5).\n%total {} (minus-right-preserves-lt* _ _ _ _).\n\n\n%theorem minus-left-cancels-inverts-lt :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X6}\n\tforall {IOP1:minus X1 X2 X3} {IOP2:minus X4 X5 X6}\n               {E:eq X1 X4} {G:lt X3 X6}\n        exists {GP:lt X5 X2}\n\ttrue.\n\n- : minus-left-cancels-inverts-lt X3+X2=X1 X6+X5=X4 X1=X4 X3<X6 X5<X2\n    <- plus-total X6+X2=X7\n    <- plus-right-preserves-lt* X3<X6 X3+X2=X1 X6+X2=X7 X1<X7\n    <- eq-symmetric X1=X4 X4=X1\n    <- plus-respects-eq X6+X5=X4 eq/ eq/ X4=X1 X6+X5=X1\n    <- plus-left-cancels-lt X6+X5=X1 X6+X2=X7 eq/ X1<X7 X5<X2.\n\n%worlds () (minus-left-cancels-inverts-lt X1-X2=X3 X4-X5=X6 X1=X4 X3<X6 \n                                   X5<X2).\n%total {} (minus-left-cancels-inverts-lt _ _ _ _ _).\n\n\n%theorem minus-right-cancels-lt :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X6}\n\tforall {IOP1:minus X1 X2 X3} {IOP2:minus X4 X5 X6}\n               {E2:eq X2 X5} {G3:lt X3 X6}\n        exists {G1:lt X1 X4}\n\ttrue.\n\n- : minus-right-cancels-lt X3+X2=X1 X6+X5=X4 X2=X5 X3<X6 X1<X4\n    <- plus-respects-eq X3+X2=X1 eq/ X2=X5 eq/ X3+X5=X1\n    <- plus-right-preserves-lt* X3<X6 X3+X5=X1 X6+X5=X4 X1<X4.\n\n%worlds () (minus-right-cancels-lt X1-X2=X3 X4-X5=X6 X2=X5 X3<X6 \n                            X1<X4).\n%total {} (minus-right-cancels-lt _ _ _ _ _).\n\n\n\n%theorem minus-left-inverts-le* :\n\tforall* {X1} {X2} {X3} {X4} {X5}\n        forall {G:le X2 X4}\n               {IOP1:minus X1 X2 X3} {IOP2:minus X1 X4 X5}\n        exists {GP:le X5 X3}\n\ttrue.\n\n- : minus-left-inverts-le* X2<=X4 X3+X2=X1 X5+X4=X1 X5<=X3\n    <- plus-total X3+X4=X7\n    <- plus-left-preserves-le* X2<=X4 X3+X2=X1 X3+X4=X7 X1<=X7\n    <- plus-right-cancels-le X5+X4=X1 X3+X4=X7 eq/ X1<=X7 X5<=X3.\n\n%worlds () (minus-left-inverts-le* X2<=X4 X1-X2=X3 X1-X4=X5  X5<=X3).\n%total {} (minus-left-inverts-le* _ _ _ _).\n\n\n%theorem minus-right-preserves-le* :\n\tforall* {X1} {X2} {X3} {X4} {X5}\n        forall {G:le X1 X2}\n               {IOP1:minus X1 X3 X4} {IOP2:minus X2 X3 X5}\n        exists {GP:le X4 X5}\n\ttrue.\n\n- : minus-right-preserves-le*  X1<=X2 X4+X3=X1 X5+X3=X2 X4<=X5\n    <- plus-right-cancels-le X4+X3=X1 X5+X3=X2 eq/ X1<=X2 X4<=X5.\n\n%worlds () (minus-right-preserves-le* X1<=X2 X1-X3=X4 X2-X3=X5  X4<=X5).\n%total {} (minus-right-preserves-le* _ _ _ _).\n\n\n%theorem minus-left-cancels-inverts-le :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X6}\n\tforall {IOP1:minus X1 X2 X3} {IOP2:minus X4 X5 X6}\n               {E:eq X1 X4} {G:le X3 X6}\n        exists {GP:le X5 X2}\n\ttrue.\n\n- : minus-left-cancels-inverts-le X3+X2=X1 X6+X5=X4 X1=X4 X3<=X6 X5<=X2\n    <- plus-total X6+X2=X7\n    <- plus-right-preserves-le* X3<=X6 X3+X2=X1 X6+X2=X7 X1<=X7\n    <- eq-symmetric X1=X4 X4=X1\n    <- plus-respects-eq X6+X5=X4 eq/ eq/ X4=X1 X6+X5=X1\n    <- plus-left-cancels-le X6+X5=X1 X6+X2=X7 eq/ X1<=X7 X5<=X2.\n\n%worlds () (minus-left-cancels-inverts-le X1-X2=X3 X4-X5=X6 X1=X4 X3<=X6 \n                                   X5<=X2).\n%total {} (minus-left-cancels-inverts-le _ _ _ _ _).\n\n\n%theorem minus-right-cancels-le :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X6}\n\tforall {IOP1:minus X1 X2 X3} {IOP2:minus X4 X5 X6}\n               {E2:eq X2 X5} {G3:le X3 X6}\n        exists {G1:le X1 X4}\n\ttrue.\n\n- : minus-right-cancels-le X3+X2=X1 X6+X5=X4 X2=X5 X3<=X6 X1<=X4\n    <- plus-respects-eq X3+X2=X1 eq/ X2=X5 eq/ X3+X5=X1\n    <- plus-right-preserves-le* X3<=X6 X3+X5=X1 X6+X5=X4 X1<=X4.\n\n%worlds () (minus-right-cancels-le X1-X2=X3 X4-X5=X6 X2=X5 X3<=X6 \n                            X1<=X4).\n%total {} (minus-right-cancels-le _ _ _ _ _).\n\n\n\n\n\n\n%%%%% nat-divrem.elf\n%%%%% Integer quotient/remainder division\n%%%%% This file is part of the nat.elf signature\n\n\n\n%%%% Definitions\n\n\n\n%%% Division with remainder\n\n\ndivrem : nat -> nat -> nat -> nat -> type.\n\n\ndivrem/z : divrem M N z M\n    <- gt N M.\n\ndivrem/s : divrem M (s N-) (s Q) R\n    <- plus D (s N-) M\n    <- divrem D (s N-) Q R.\n\n\n\n\n%%%% Theorems\n\n\n%%% Theorems about divrem\n\n\n%theorem false-implies-divrem :\n\tforall* {M} {N} {Q} {R}\n\tforall {F:void}\n\texists {D:divrem M N Q R}\n\ttrue.\n\n%worlds () (false-implies-divrem _  M/N=Q,R).\n%total {} (false-implies-divrem _ _).\n\n\n%theorem divrem-respects-eq :\n\tforall* {M} {N} {Q} {R} {M'} {N'} {Q'} {R'}\n\tforall {D:divrem M N Q R} \n               {E1:eq M M'} {E2:eq N N'} {E3:eq Q Q'} {E4:eq R R'}\n\texists {D':divrem M' N' Q' R'}\n\ttrue.\n\n- : divrem-respects-eq D eq/ eq/ eq/ eq/ D.\n\n%worlds () (divrem-respects-eq M/N=Q,R M=M' N=N' Q=Q' R=R'  M'/N'=Q',R').\n%total {} (divrem-respects-eq _ _ _ _ _ _).\n\n\n%theorem divrem-total** :\n\tforall {M} {N-1} {C} {CMP:compare M N-1 C}\n\texists {Q} {R} {D:divrem M (s N-1) Q R}\n\ttrue.\n\n- : divrem-total** M N-1 equal CMP z M (divrem/z N>M)\n    <- equal-implies-eq CMP M=N-1\n    <- succ-implies-gt eq/ N>N-1\n    <- eq-symmetric M=N-1 N-1=M\n    <- gt-respects-eq N>N-1 eq/ N-1=M N>M.\n\n- : divrem-total** M N-1 less CMP z M (divrem/z N>M)\n    <- less-implies-lt CMP N-1>M\n    <- succ-implies-gt eq/ N>N-1\n    <- gt-transitive N>N-1 N-1>M N>M.\n\n- : divrem-total** M N-1 greater CMP (s Q) R (divrem/s D/N=Q,R D+N=M)\n    <- greater-implies-gt CMP M>N-1\n    <- gt-implies-plus M>N-1 D SD+N-1=M\n    <- plus-swap-succ SD+N-1=M D+N=M\n    <- plus-commutative D+N=M N+D=M\n    <- plus-implies-gt N+D=M eq/ M>D\n    <- meta-gt M D M>D\n    <- compare-total* D N-1 C' CMP'\n    <- divrem-total** D N-1 C' CMP' Q R D/N=Q,R.\n\n%worlds () (divrem-total** M N-1 C MCN  Q R M/N=Q,R).\n%total (M) (divrem-total** M _ _ _ _ _ _).\n\n\n%theorem divrem-total* :\n\tforall {M} {N-}\n\texists {Q} {R} {D:divrem M (s N-) Q R}\n\ttrue.\n\n- : divrem-total* M N-1 Q R M/N=Q,R\n    <- compare-total* M N-1 C CMP\n    <- divrem-total** M N-1 C CMP Q R M/N=Q,R.\n\n%worlds () (divrem-total* M N-1  Q R M/N=Q,R).\n%total {} (divrem-total* _ _ _ _ _).\n\n\n%abbrev divrem-total = divrem-total* _ _ _ _.\n\n\n%theorem divrem-deterministic :\n\tforall* {M} {N} {Q} {R} {M'} {N'} {Q'} {R'}\n\tforall {D:divrem M N Q R} {D':divrem M' N' Q' R'}\n\t       {E1:eq M M'} {E2:eq N N'}\n\texists {E3:eq Q Q'} {E4:eq R R'}\n\ttrue.\n\n- : divrem-deterministic (divrem/z _) (divrem/z _) eq/ eq/ eq/ eq/.\n\n- : divrem-deterministic (divrem/s D/N=Q,R D+N=M) (divrem/s D'/N=Q',R' D'+N=M)\n                         eq/ eq/ SQ=SQ' R=R'\n    <- plus-right-cancels D+N=M D'+N=M eq/ eq/ D=D'\n    <- divrem-deterministic D/N=Q,R  D'/N=Q',R' D=D' eq/ Q=Q' R=R'\n    <- succ-deterministic Q=Q' SQ=SQ'.\n\n%% contradiction cases:\n\n- : divrem-deterministic (divrem/z N>M) (divrem/s _ D+N=M) eq/ eq/ Q=Q' R=R'\n    <- plus-commutative D+N=M N+D=M\n    <- plus-gt-contradiction N+D=M N>M F\n    <- false-implies-eq F Q=Q'\n    <- false-implies-eq F R=R'.\n\n- : divrem-deterministic (divrem/s _ D+N=M) (divrem/z N>M) eq/ eq/ Q=Q' R=R'\n    <- plus-commutative D+N=M N+D=M\n    <- plus-gt-contradiction N+D=M N>M F\n    <- false-implies-eq F Q=Q'\n    <- false-implies-eq F R=R'.\n\n%worlds () (divrem-deterministic M/N=Q,R M'/N'=Q'/R' M=M' N=N'  Q=Q' R=R').\n%total (D) (divrem-deterministic D _ _ _ _ _).\n\n\n%theorem divrem-implies-positive :\n\tforall* {M} {N} {Q} {R}\n\tforall {D:divrem M N Q R}\n\texists {N-1} {E:eq N (s N-1)}\n\ttrue.\n\n- : divrem-implies-positive (divrem/z N>M) N-1 N=sN-1\n    <- gt-implies-positive N>M N-1 N=sN-1.\n\n- : divrem-implies-positive (divrem/s _ _) _ eq/.\n\n%worlds () (divrem-implies-positive M/N=Q,R  N-1 N=sN-1).\n%total {} (divrem-implies-positive _ _ _).\n\n\n%theorem divrem-implies-gt :\n\tforall* {M} {N} {Q} {R}\n\tforall {D:divrem M N Q R}\n\texists {G:gt N R}\n\ttrue.\n\n- : divrem-implies-gt (divrem/z N>M) N>M.\n\n- : divrem-implies-gt (divrem/s D/N=Q,R _) N>R\n    <- divrem-implies-gt D/N=Q,R N>R.\n\n%worlds () (divrem-implies-gt M/N=Q,R  N>R).\n%total D (divrem-implies-gt D _).\n\n\n%theorem divrem-contradiction :\n\tforall* {M} {N} {Q} {R} {X}\n\tforall\t{D:divrem M N Q R}\n\t\t{P:plus N X R}\n\texists\t{F:void}\n\ttrue.\n\n- : divrem-contradiction D P F\n    <- divrem-implies-gt D N>R\n    <- plus-commutative P Pc\n    <- plus-implies-ge Pc R>=N\n    <- gt-transitive-ge N>R R>=N N>N\n    <- gt-anti-reflexive N>N F.\n\n%worlds () (divrem-contradiction _ _ _).\n%total { } (divrem-contradiction _ _ _).\n   \n\n%theorem divrem-can-be-inverted :\n\tforall* {M} {N} {Q} {R}\n\tforall {D:divrem M N Q R}\n\texists {X} {T:times Q N X} {P:plus X R M}\n\ttrue.\n\n- : divrem-can-be-inverted (divrem/z _) z times/z plus/z.\n\n- : divrem-can-be-inverted (divrem/s D/N=Q,R D+N=M) \n                           X (times/s Q*N=Y Y+N=X) X+R=M\n    <- divrem-can-be-inverted D/N=Q,R Y Q*N=Y Y+R=D\n    <- plus-commutative Y+R=D R+Y=D\n    <- plus-associative R+Y=D D+N=M X Y+N=X R+X=M\n    <- plus-commutative R+X=M X+R=M.\n\n%worlds () (divrem-can-be-inverted M/N=Q,R  X Q*N=X X+R=M).\n%total (D) (divrem-can-be-inverted D _ _ _).\n\n\n%theorem div-can-be-inverted :\n\tforall* {M} {N} {Q}\n\tforall {D:divrem M N Q z}\n\texists {T:times Q N M}\n\ttrue.\n\n- : div-can-be-inverted (divrem/z _) times/z.\n\n- : div-can-be-inverted (divrem/s D/N=Q,z D+N=M) \n                        (times/s Q*N=D D+N=M)\n    <- div-can-be-inverted D/N=Q,z Q*N=D.\n\n%worlds () (div-can-be-inverted _ _).\n%total (D) (div-can-be-inverted D _).\n\n\n%theorem divrem-can-be-constructed :\n\tforall* {M} {N} {Q} {R} {X}\n\tforall {T:times Q N X} {P:plus X R M} {G:gt N R}\n        exists {D:divrem M N Q R}\n\ttrue.\n\n- : divrem-can-be-constructed (times/z) (plus/z) N>R (divrem/z N>R).\n\n- : divrem-can-be-constructed (times/s Q*N=Y Y+N=X) X+R=M N>R\n                              (divrem/s Z/N=Q,R Z+N=M)\n    <- plus-commutative Y+N=X N+Y=X\n    <- plus-associative N+Y=X X+R=M Z Y+R=Z N+Z=M\n    <- plus-commutative N+Z=M Z+N=M\n    <- divrem-can-be-constructed Q*N=Y Y+R=Z N>R Z/N=Q,R.\n\n- : divrem-can-be-constructed _ _ ZERO>R D\n    <- gt-contradiction ZERO>R F\n    <- false-implies-divrem F D.\n\n%worlds () (divrem-can-be-constructed Q*N=X X+R=M N>R  M/N=Q,R).\n%total (T) (divrem-can-be-constructed T _ _ _).\n\n\n%theorem div-can-be-constructed :\n\tforall* {M} {N} {Q}\n\tforall {T:times Q (s N) M}\n        exists {D:divrem M (s N) Q z}\n\ttrue.\n\n- : div-can-be-constructed (times/z) (divrem/z N+1>0)\n    <- succ-implies-gt-zero _ N+1>0.\n\n- : div-can-be-constructed (times/s Q*sN=D D+sN=M)\n                           (divrem/s D/sN=Q,z D+sN=M)\n    <- div-can-be-constructed Q*sN=D D/sN=Q,z.\n\n%worlds () (div-can-be-constructed _ _).\n%total (T) (div-can-be-constructed T _).\n\n\n%theorem remainder-implies-gt-quotient :\n\tforall* {M} {N} {Q} {R}\n\tforall {D:divrem M N Q (s R)}\n\texists {G:gt M Q}\n\ttrue.\n\n- : remainder-implies-gt-quotient (divrem/z _) R+1>0\n    <- succ-implies-gt-zero _ R+1>0.\n\n- : remainder-implies-gt-quotient (divrem/s D/N=Q,sR D+N=M) M>sQ\n    <- remainder-implies-gt-quotient D/N=Q,sR D>Q\n    <- gt-implies-ge-succ D>Q D>=sQ\n    <- plus-commutative D+N=M N+D=M\n    <- plus-implies-gt N+D=M eq/ M>D\n    <- gt-transitive-ge M>D D>=sQ M>sQ.\n\n%worlds () (remainder-implies-gt-quotient _ _).\n%total (D) (remainder-implies-gt-quotient D _).\n\n\n%theorem quotient-of-nonzero-is-smaller :\n\tforall* {M} {N} {Q} {R} {M-}\n\tforall {DR:divrem M (s (s N)) Q R} {EN:eq M (s M-)}\n\texists {G:gt M Q}\n\ttrue.\n\n- : quotient-of-nonzero-is-smaller _ eq/ M>0\n    <- succ-implies-gt-zero _ M>0.\n\n- : quotient-of-nonzero-is-smaller M/N=Q,R eq/ M>Q\n    <- divrem-can-be-inverted M/N=Q,R X Q*N=X X+R=M\n    <- times-right-identity _ Q*1=Q\n    <- succ-implies-gt-zero _ N->0\n    <- succ-preserves-gt N->0 N>1\n    <- times-left-preserves-gt N>1 Q*N=X Q*1=Q X>Q\n    <- plus-commutative X+R=M R+X=M\n    <- plus-implies-ge R+X=M M>=X\n    <- ge-transitive-gt M>=X X>Q M>Q.\n\n%worlds () (quotient-of-nonzero-is-smaller _ _ _).\n%total { } (quotient-of-nonzero-is-smaller _ _ _).\n\n\n%theorem quotient-is-no-greater :\n\tforall* {M} {N} {Q} {R}\n\tforall {DR:divrem M N Q R}\n\texists {ge:ge M Q}\n\ttrue.\n\n- : quotient-is-no-greater M/N=Q,R M>=Q\n    <- divrem-can-be-inverted M/N=Q,R X Q*N=X X+R=M\n    <- divrem-implies-positive M/N=Q,R NN N=NN+1\n    <- eq-symmetric N=NN+1 NN+1=N\n    <- succ-implies-gt-zero NN NN+1>0\n    <- gt-respects-eq NN+1>0 NN+1=N eq/ N>0\n    <- gt-implies-ge-succ N>0 N>=1\n    <- times-right-identity _ Q*1=Q\n    <- times-left-preserves-ge* N>=1 Q*N=X Q*1=Q X>=Q\n    <- plus-commutative X+R=M R+X=M\n    <- plus-implies-ge R+X=M M>=X\n    <- ge-transitive M>=X X>=Q M>=Q.\n\n%worlds () (quotient-is-no-greater _ _).\n%total { } (quotient-is-no-greater _ _).\n\n\n\n%%%%% minmax.elf\n%%%%% Minimum and Maximum functor\n%%%%% John Boyland\n\n% Minimum and maximum defined given anti-reflexive gt total order.\n% We assume compare three-way comparison.\n% We assume that ge is defined from gt and eq.\n\n\n\n%%%% Definitions\n\n\nmin : nat -> nat -> nat -> type.\n\n\nmin/= : min X X X.\n\nmin/> : gt X1 X2 -> min X1 X2 X2.\n\nmin/< : gt X2 X1 -> min X1 X2 X1.\n\n\n\nmax : nat -> nat -> nat -> type.\n\n\nmax/= : max X X X.\n\nmax/> : gt X1 X2 -> max X1 X2 X1.\n\nmax/< : gt X2 X1 -> max X1 X2 X2.\n\n\n\n\n%%%% Theorems\n\n\n\n%%% Theorems about min\n\n\n%theorem false-implies-min :\n\tforall* {X1} {X2} {X3}\n\tforall {F:void}\n\texists {M:min X1 X2 X3}\n\ttrue.\n\n%worlds () (false-implies-min _ _).\n%total { } (false-implies-min _ _).\n\n\n%theorem min-respects-eq :\n\tforall* {X1} {X2} {X3}\n\t\t{Y1} {Y2} {Y3}\n\tforall {MX:min X1 X2 X3}\n\t       {E1:eq X1 Y1} {E2:eq X2 Y2} {E3:eq X3 Y3}\n\texists {MY:min Y1 Y2 Y3}\n\ttrue.\n\n- : min-respects-eq M eq/ eq/ eq/ M.\n\n%worlds () (min-respects-eq _ _ _ _ _).\n%total { } (min-respects-eq _ _ _ _ _).\n\n\n%theorem min-total** :\n\tforall* {X1} {X2} {C}\n\tforall {D:compare X1 X2 C}\n\texists {X3} {M:min X1 X2 X3}\n\ttrue.\n\n- : min-total** compare/= _ min/=.\n\n- : min-total** (compare/> X1>X2) _ (min/> X1>X2).\n\n- : min-total** (compare/< X2>X1) _ (min/< X2>X1).\n\n%worlds () (min-total** _ _ _).\n%total { } (min-total** _ _ _).\n\n\n%theorem min-total* :\n\tforall {X1} {X2}\n\texists {X3} {M:min X1 X2 X3}\n\ttrue.\n\n- : min-total* X1 X2 X3 M\n    <- compare-total D\n    <- min-total** D X3 M.\n\n%worlds () (min-total* _ _ _ _).\n%total { } (min-total* _ _ _ _).\n\n\n%abbrev min-total = min-total* _ _ _.\n\n\n%theorem min-deterministic :\n\tforall* {X1} {X2} {X3}\n\t\t{Y1} {Y2} {Y3}\n\tforall {MX:min X1 X2 X3}\n\t       {MY:min Y1 Y2 Y3}\n\t       {E1:eq X1 Y1} {E2:eq X2 Y2}\n\texists {E3:eq X3 Y3}\n\ttrue.\n\n- : min-deterministic (min/=) (min/=) eq/ eq/ eq/.\n\n- : min-deterministic (min/=) (min/> X>X) eq/ eq/ eq/.\n\n- : min-deterministic (min/=) (min/< X>X) eq/ eq/ eq/.\n\n- : min-deterministic (min/> X>X) (min/=) eq/ eq/ eq/.\n\n- : min-deterministic (min/> X>Y) (min/> X>YP) eq/ eq/ eq/.\n\n- : min-deterministic (min/> X>Y) (min/< Y>X) eq/ eq/ E\n    <- gt-anti-symmetric X>Y Y>X F\n    <- false-implies-eq F E.\n\n- : min-deterministic (min/< X>X) (min/=) eq/ eq/ eq/.\n\n- : min-deterministic (min/< X>Y) (min/> Y>X) eq/ eq/ E\n    <- gt-anti-symmetric X>Y Y>X F\n    <- false-implies-eq F E.\n\n- : min-deterministic (min/< X>Y) (min/< X>YP) eq/ eq/ eq/.\n\n%worlds () (min-deterministic _ _ _ _ _).\n%total { } (min-deterministic _ _ _ _ _).\n\n\n%theorem min-commutative :\n\tforall* {X1} {X2} {X3}\n\tforall {M:min X1 X2 X3}\n\texists {Mc:min X2 X1 X3}\n\ttrue.\n\n- : min-commutative min/= min/=.\n\n- : min-commutative (min/> X>Y) (min/< X>Y).\n\n- : min-commutative (min/< X>Y) (min/> X>Y).\n\n%worlds () (min-commutative _ _).\n%total { } (min-commutative _ _).\n\n\n%theorem ge-implies-min :\n\tforall* {X1} {X2}\n\tforall {G:ge X1 X2}\n\texists {M:min X1 X2 X2}\n\ttrue.\n\n- : ge-implies-min (ge/> X1>X2) (min/> X1>X2).\n\n- : ge-implies-min (ge/= eq/) (min/=).\n\n%worlds () (ge-implies-min _ _).\n%total { } (ge-implies-min _ _).\n\n\n%theorem le-implies-min :\n\tforall* {X1} {X2}\n\tforall {G:le X1 X2}\n\texists {M:min X1 X2 X1}\n\ttrue.\n\n- : le-implies-min X2>=X1 M\n    <- ge-implies-min X2>=X1 Mc\n    <- min-commutative Mc M.\n\n%worlds () (le-implies-min _ _).\n%total { } (le-implies-min _ _).\n\n\n%theorem min-implies-ge :\n\tforall* {X1} {X2} {X3}\n\tforall {M:min X1 X2 X3}\n\texists {G1:ge X1 X3} {G2:ge X2 X3}\n\ttrue.\n\n- : min-implies-ge min/= (ge/= eq/) (ge/= eq/).\n\n- : min-implies-ge (min/> X1>X2) (ge/> X1>X2) (ge/= eq/).\n\n- : min-implies-ge (min/< X2>X1) (ge/= eq/) (ge/> X2>X1).\n\n%worlds () (min-implies-ge _ _ _).\n%total { } (min-implies-ge _ _ _).\n\n\n%theorem min-left-preserves-ge* :\n\tforall* {X1} {X2} {X3} {X4} {X5} \n\tforall {G:ge X2 X4}\n\t       {M12:min X1 X2 X3} \n\t       {M14:min X1 X4 X5}\n\texists {G:ge X3 X5}\n\ttrue.\n\n- : min-left-preserves-ge* _ min/= M G\n    <- min-implies-ge M G _.\n\n- : min-left-preserves-ge* X2>=X4 (min/> X1>X2) X1&X4=X5 X2>=X5\n    <- min-implies-ge X1&X4=X5 _ X4>=X5\n    <- ge-transitive X2>=X4 X4>=X5 X2>=X5.\n\n- : min-left-preserves-ge* _ (min/< _) X1&X4=X5 X1>=X5\n    <- min-implies-ge X1&X4=X5 X1>=X5 _.\n\n%worlds () (min-left-preserves-ge* _ _ _ _).\n%total { } (min-left-preserves-ge* _ _ _ _).\n\n\n%theorem min-left-preserves-le* :\n\tforall* {X1} {X2} {X3} {X4} {X5} \n\tforall {G:le X2 X4}\n\t       {M12:min X1 X2 X3} \n\t       {M14:min X1 X4 X5}\n\texists {G:le X3 X5}\n\ttrue.\n\n- : min-left-preserves-le* G1 M12 M14 G2\n    <- min-left-preserves-ge* G1 M14 M12 G2.\n\n%worlds () (min-left-preserves-le* _ _ _ _).\n%total { } (min-left-preserves-le* _ _ _ _).\n\n\n\n%theorem min-left-preserves-ge :\n\tforall* {X1} {X2} {X4}\n      \tforall {G:ge X2 X4}\n\texists {X3} {X5}\n               {O1:min X1 X2 X3} {O2:min X1 X4 X5}\n      \t       {G2:ge X3 X5}\n\ttrue.\n\n- : min-left-preserves-ge X2>=X4 X3 X5 X1&X2=A3 X1&X4=X5 X3>=X5\n    <- min-total X1&X2=A3 \n    <- min-total X1&X4=X5\n    <- min-left-preserves-ge* X2>=X4 X1&X2=A3 X1&X4=X5 X3>=X5.\n\n%worlds () (min-left-preserves-ge X2>=X4  X3 X5 X1&X2=A3 X1&X4=X5 X3>=X5).\n%total {} (min-left-preserves-ge _ _ _ _ _ _).\n\n\n%theorem min-right-preserves-ge* :\n\tforall* {X1} {X2} {X3} {X4} {X5}\n\tforall {G1:ge X1 X2} {O1:min X1 X3 X4} {O2:min X2 X3 X5}\n\texists {G2:ge X4 X5}\n\ttrue.\n\n- : min-right-preserves-ge* X1>=X2 X1&X3=X4 X2&X3=X5 X4>=X5\n    <- min-commutative X1&X3=X4 X3&X1=X4\n    <- min-commutative X2&X3=X5 X3&X2=X5\n    <- min-left-preserves-ge* X1>=X2 X3&X1=X4 X3&X2=X5 X4>=X5.\n\n%worlds () (min-right-preserves-ge* X1>=X2 X1&X3=X4 X2&X3=X5  X4>=X5).\n%total {} (min-right-preserves-ge* _ _ _ _).\n\n\n%theorem min-right-preserves-ge :\n\tforall* {X1} {X2} {X3}\n\tforall {G1:ge X1 X2} \n\texists {X4} {X5} {O1:min X1 X3 X4} {O2:min X2 X3 X5} {G2:ge X4 X5}\n\ttrue.\n\n- : min-right-preserves-ge X1>=X2 X4 X5 X1&X3=X4 X2&X3=X5 X4>=X5\n    <- min-total X1&X3=X4 \n    <- min-total X2&X3=X5\n    <- min-right-preserves-ge* X1>=X2 X1&X3=X4 X2&X3=X5 X4>=X5.\n%worlds () (min-right-preserves-ge X1>=X2  X4 X5 X1&X3=X4 X2&X3=X5 X4>=X5).\n%total {} (min-right-preserves-ge _ _ _ _ _ _).\n\n\n%theorem min-preserves-ge* :\n\tforall* {X1} {X2} {X3} {Y1} {Y2} {Y3}\n\tforall {G1:ge X1 Y1} {G2:ge X2 Y2}\n               {MX:min X1 X2 X3} {MY:min Y1 Y2 Y3}\n        exists {G3:ge X3 Y3}\n\ttrue.\n\n- : min-preserves-ge* X1>=Y1 X2>=Y2 X1&X2=X3 Y1&Y2=Y3 X3>=Y3\n    <- min-total Y1&X2=X\n    <- min-right-preserves-ge* X1>=Y1 X1&X2=X3 Y1&X2=X X3>=X\n    <- min-left-preserves-ge* X2>=Y2 Y1&X2=X Y1&Y2=Y3 X>=Y3\n    <- ge-transitive X3>=X X>=Y3 X3>=Y3.\n\n%worlds () (min-preserves-ge* X1>=Y1 X2>=Y2 X1&X2=X3 Y1&Y2=Y3  X3>=Y3).\n%total {} (min-preserves-ge* _ _ _ _ _).\n\n\n%theorem min-preserves-ge :\n\tforall* {X1} {X2} {Y1} {Y2}\n\tforall {G1:ge X1 Y1} {G2:ge X2 Y2}\n\texists {X3} {Y3} {MX:min X1 X2 X3} {MY:min Y1 Y2 Y3} {G3:ge X3 Y3}\n\ttrue.\n\n- : min-preserves-ge X1>=Y1 X2>=Y2 X3 Y3 X1&X2=X3 Y1&Y2=Y3 X3>=Y3\n    <- min-total X1&X2=X3\n    <- min-total Y1&Y2=Y3\n    <- min-preserves-ge* X1>=Y1 X2>=Y2 X1&X2=X3 Y1&Y2=Y3 X3>=Y3.\n\n%worlds () (min-preserves-ge X1>=Y1 X2>=Y2  X3 Y3 X1&X2=X3 Y1&Y2=Y3 X3>=Y3).\n%total {} (min-preserves-ge _ _ _ _ _ _ _).\n\n\n\n%theorem min-left-preserves-le :\n\tforall* {X1} {X2} {X4}\n      \tforall {G:le X2 X4}\n\texists {X3} {X5}\n               {O1:min X1 X2 X3} {O2:min X1 X4 X5}\n      \t       {G2:le X3 X5}\n\ttrue.\n\n- : min-left-preserves-le X2<=X4 X3 X5 X1&X2=A3 X1&X4=X5 X3<=X5\n    <- min-total X1&X2=A3 \n    <- min-total X1&X4=X5\n    <- min-left-preserves-le* X2<=X4 X1&X2=A3 X1&X4=X5 X3<=X5.\n\n%worlds () (min-left-preserves-le X2<=X4  X3 X5 X1&X2=A3 X1&X4=X5 X3<=X5).\n%total {} (min-left-preserves-le _ _ _ _ _ _).\n\n\n%theorem min-right-preserves-le* :\n\tforall* {X1} {X2} {X3} {X4} {X5}\n\tforall {G1:le X1 X2} {O1:min X1 X3 X4} {O2:min X2 X3 X5}\n\texists {G2:le X4 X5}\n\ttrue.\n\n- : min-right-preserves-le* X1<=X2 X1&X3=X4 X2&X3=X5 X4<=X5\n    <- min-commutative X1&X3=X4 X3&X1=X4\n    <- min-commutative X2&X3=X5 X3&X2=X5\n    <- min-left-preserves-le* X1<=X2 X3&X1=X4 X3&X2=X5 X4<=X5.\n\n%worlds () (min-right-preserves-le* X1<=X2 X1&X3=X4 X2&X3=X5  X4<=X5).\n%total {} (min-right-preserves-le* _ _ _ _).\n\n\n%theorem min-right-preserves-le :\n\tforall* {X1} {X2} {X3}\n\tforall {G1:le X1 X2} \n\texists {X4} {X5} {O1:min X1 X3 X4} {O2:min X2 X3 X5} {G2:le X4 X5}\n\ttrue.\n\n- : min-right-preserves-le X1<=X2 X4 X5 X1&X3=X4 X2&X3=X5 X4<=X5\n    <- min-total X1&X3=X4 \n    <- min-total X2&X3=X5\n    <- min-right-preserves-le* X1<=X2 X1&X3=X4 X2&X3=X5 X4<=X5.\n%worlds () (min-right-preserves-le X1<=X2  X4 X5 X1&X3=X4 X2&X3=X5 X4<=X5).\n%total {} (min-right-preserves-le _ _ _ _ _ _).\n\n\n%theorem min-preserves-le* :\n\tforall* {X1} {X2} {X3} {Y1} {Y2} {Y3}\n\tforall {G1:le X1 Y1} {G2:le X2 Y2}\n               {MX:min X1 X2 X3} {MY:min Y1 Y2 Y3}\n        exists {G3:le X3 Y3}\n\ttrue.\n\n- : min-preserves-le* X1<=Y1 X2<=Y2 X1&X2=X3 Y1&Y2=Y3 X3<=Y3\n    <- min-total Y1&X2=X\n    <- min-right-preserves-le* X1<=Y1 X1&X2=X3 Y1&X2=X X3<=X\n    <- min-left-preserves-le* X2<=Y2 Y1&X2=X Y1&Y2=Y3 X<=Y3\n    <- le-transitive X3<=X X<=Y3 X3<=Y3.\n\n%worlds () (min-preserves-le* X1<=Y1 X2<=Y2 X1&X2=X3 Y1&Y2=Y3  X3<=Y3).\n%total {} (min-preserves-le* _ _ _ _ _).\n\n\n%theorem min-preserves-le :\n\tforall* {X1} {X2} {Y1} {Y2}\n\tforall {G1:le X1 Y1} {G2:le X2 Y2}\n\texists {X3} {Y3} {MX:min X1 X2 X3} {MY:min Y1 Y2 Y3} {G3:le X3 Y3}\n\ttrue.\n\n- : min-preserves-le X1<=Y1 X2<=Y2 X3 Y3 X1&X2=X3 Y1&Y2=Y3 X3<=Y3\n    <- min-total X1&X2=X3\n    <- min-total Y1&Y2=Y3\n    <- min-preserves-le* X1<=Y1 X2<=Y2 X1&X2=X3 Y1&Y2=Y3 X3<=Y3.\n\n%worlds () (min-preserves-le X1<=Y1 X2<=Y2  X3 Y3 X1&X2=X3 Y1&Y2=Y3 X3<=Y3).\n%total {} (min-preserves-le _ _ _ _ _ _ _).\n\n\n%theorem min-is-glb :\n\tforall* {X1} {X2} {X3} {X4}\n\tforall {M:min X1 X2 X3}\n\t       {G1:ge X1 X4}\n\t       {G2:ge X2 X4}\n\texists {G3:ge X3 X4}\n\ttrue.\n\n- : min-is-glb min/= G _ G.\n\n- : min-is-glb (min/> X1>X2) _ G G.\n\n- : min-is-glb (min/< X2>X1) G _ G.\n\n%worlds () (min-is-glb _ _ _ _).\n%total { } (min-is-glb _ _ _ _).\n\n\n%theorem min-associative :\n\tforall* {X1} {X2} {X3} {X4} {X7}\n\tforall {M12:min X1 X2 X3}\n\t       {M34:min X3 X4 X7}\n\texists {X6} {M24:min X2 X4 X6}\n\t       {M16:min X1 X6 X7}\n\ttrue.\n\n- : min-associative min/= min/= _ min/= min/=.\n\n- : min-associative min/= (min/> X3>X4) _ (min/> X3>X4) (min/> X3>X4).\n\n- : min-associative min/= (min/< X4>X3) _ (min/< X4>X3) (min/=).\n\n- : min-associative (min/> X1>X2) min/= _ (min/=) (min/> X1>X2).\n\n- : min-associative (min/> X1>X2) (min/> X2>X4) _ (min/> X2>X4) (min/> X1>X4)\n    <- gt-transitive X1>X2 X2>X4 X1>X4.\n\n- : min-associative (min/> X1>X2) (min/< X4>X2) _ (min/< X4>X2) (min/> X1>X2).\n\n- : min-associative (min/< X2>X1) min/= _ (min/> X2>X1) min/=.\n\n- : min-associative (min/< X2>X1) (min/> X1>X4) _ (min/> X2>X4) (min/> X1>X4)\n    <- gt-transitive X2>X1 X1>X4 X2>X4.\n\n- : min-associative (min/< X2>X1) (min/< X4>X1) _ M24 M16\n    <- min-total M24\n    <- min-is-glb M24 (ge/> X2>X1) (ge/> X4>X1) (X6>=X1: ge X6 X1)\n    <- ge-implies-min X6>=X1 M16c\n    <- min-commutative M16c M16.\n\n%worlds () (min-associative _ _ _ _ _).\n%total { } (min-associative _ _ _ _ _).\n\n\n%theorem min-associative* :\n\tforall* {X1} {X2} {X12} {X3} {X23} {X123}\n        forall {OP12:min X1 X2 X12} {OP12-3:min X12 X3 X123} {OP23:min X2 X3 X23}\n        exists {OP1-23:min X1 X23 X123}\n        true.\n\n- : min-associative* X1&X2=X3 X3&X4=X7 X2&X4=X6 X1&X6=X7\n    <- min-associative X1&X2=X3 X3&X4=X7 Y6 X2&X4=Y6 X1&Y6=X7\n    <- min-deterministic X2&X4=Y6 X2&X4=X6 eq/ eq/ Y6=X6\n    <- min-respects-eq X1&Y6=X7 eq/ Y6=X6 eq/ X1&X6=X7.\n\n%worlds () (min-associative* _ _ _ _).\n%total {} (min-associative* _ _ _ _).\n\n\n%theorem min-associative-converse :\n\tforall* {X1} {X2} {X4} {X6} {X7}\n\tforall {OP24:min X2 X4 X6} {OP16:min X1 X6 X7}\n        exists {X3} {OP12:min X1 X2 X3} {OP34:min X3 X4 X7}\n        true.\n\n- : min-associative-converse X2&X4=X6 X1&X6=X7 _ X1&X2=X3 X3&X4=X7\n    <- min-commutative X2&X4=X6 X4&X2=X6\n    <- min-commutative X1&X6=X7 X6&X1=X7\n    <- min-associative X4&X2=X6 X6&X1=X7 _ X2&X1=X3 X4&X3=X7\n    <- min-commutative X2&X1=X3 X1&X2=X3\n    <- min-commutative X4&X3=X7 X3&X4=X7.\n\n%worlds () (min-associative-converse X2&X4=X6 X1&X6=X7 X3 X1&X2=X3 X3&X4=X7).\n%total {} (min-associative-converse _ _ _ _ _).\n\n\n%theorem min-associative-converse* :\n\tforall* {X1} {X2} {X3} {X4} {X6} {X7}\n\tforall {OP24:min X2 X4 X6} {OP16:min X1 X6 X7} {OP12:min X1 X2 X3} \n\texists {OP34:min X3 X4 X7}\n        true.\n\n- : min-associative-converse* X2&X4=X6 X1&X6=X7 X1&X2=X3 X3&X4=X7\n    <- min-associative-converse X2&X4=X6 X1&X6=X7 X3P X1&X2=X3P X3P&X4=X7\n    <- min-deterministic X1&X2=X3P X1&X2=X3 eq/ eq/ X3P=X3\n    <- min-respects-eq X3P&X4=X7 X3P=X3 eq/ eq/ X3&X4=X7.\n\n%worlds () (min-associative-converse* X2&X4=X6 X1&X6=X7 X1&X2=X3  X3&X4=X7).\n%total {} (min-associative-converse* _ _ _ _).\n\n\n%theorem min-assoc-commutative* :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X7}\n\tforall {OP1:min X1 X2 X3} {OP2:min X3 X4 X7}\n               {OP3:min X1 X4 X5} \n        exists {OP4:min X5 X2 X7}\n\ttrue.\n\n- : min-assoc-commutative* X1&X2=X3 X3&X4=X7 X1&X4=X5 X5&X2=X7\n    <- min-associative X1&X2=X3 X3&X4=X7 X6 X2&X4=X6 X1&X6=X7\n    <- min-commutative X2&X4=X6 X4&X2=X6\n    <- min-associative-converse* X4&X2=X6 X1&X6=X7 X1&X4=X5 X5&X2=X7.\n\n%worlds () (min-assoc-commutative* X1&X2=X3 X3&X4=X7 X1&X4=X5  X5&X2=X7).\n%total {} (min-assoc-commutative* _ _ _ _).\n\n\n%theorem min-assoc-commutative :\n\tforall* {X1} {X2} {X3} {X4} {X7}\n\tforall {OP1:min X1 X2 X3} {OP2:min X3 X4 X7}\n        exists {X5} {OP3:min X1 X4 X5} {OP4:min X5 X2 X7}\n\ttrue.\n\n- : min-assoc-commutative X1&X2=X3 X3&X4=X7 X5 X1&X4=X5 X5&X2=X7\n    <- min-associative X1&X2=X3 X3&X4=X7 X6 X2&X4=X6 X1&X6=X7\n    <- min-commutative X2&X4=X6 X4&X2=X6\n    <- min-associative-converse X4&X2=X6 X1&X6=X7 X5 X1&X4=X5 X5&X2=X7.\n\n%worlds () (min-assoc-commutative X1&X2=X3 X3&X4=X7  X5 X1&X4=X5 X5&X2=X7).\n%total {} (min-assoc-commutative _ _ _ _ _).\n\n\n%theorem min-double-associative* :\n\tforall* {A} {B} {C} {D} {A+B} {C+D} {A+C} {B+D} {X}\n\tforall {AB:min A B A+B} {CD:min C D C+D} {ABCD:min A+B C+D X}\n\t       {AC:min A C A+C} {BD:min B D B+D} \n        exists {ACBD:min A+C B+D X}\n\ttrue.\n\n- : min-double-associative* X1&X2=X3 X4&X8=XC X3&XC=XF X1&X4=X5 X2&X8=XA X5&XA=XF\n    <- min-associative X1&X2=X3 X3&XC=XF XE X2&XC=XE X1&XE=XF\n    <- min-commutative X4&X8=XC X8&X4=XC\n    <- min-associative-converse* X8&X4=XC X2&XC=XE X2&X8=XA XA&X4=XE\n    <- min-commutative XA&X4=XE X4&XA=XE\n    <- min-associative-converse* X4&XA=XE X1&XE=XF X1&X4=X5 X5&XA=XF.\n\n%worlds () (min-double-associative* X1&X2=X3 X4&X8=XC X3&XC=XF X1&X4=X5 X2&X8=XA\n                             X5&XA=XF).\n%total {} (min-double-associative* _ _ _ _ _ _).\n\n\n%theorem min-double-associative :\n\tforall* {A} {B} {C} {D} {A+B} {C+D} {X}\n\tforall {AB:min A B A+B} {CD:min C D C+D} {ABCD:min A+B C+D X}\n\texists {A+C} {B+D} {AC:min A C A+C} {BD:min B D B+D} \n               {ACBD:min A+C B+D X}\n\ttrue.\n\n- : min-double-associative X1&X2=X3 X4&X8=XC X3&XC=XF X5 XA X1&X4=X5 X2&X8=XA X5&XA=XF\n    <- min-associative X1&X2=X3 X3&XC=XF XE X2&XC=XE X1&XE=XF\n    <- min-commutative X4&X8=XC X8&X4=XC\n    <- min-associative-converse X8&X4=XC X2&XC=XE XA X2&X8=XA XA&X4=XE\n    <- min-commutative XA&X4=XE X4&XA=XE\n    <- min-associative-converse X4&XA=XE X1&XE=XF X5 X1&X4=X5 X5&XA=XF.\n\n%worlds () (min-double-associative _ _ _ _ _ _ _ _).\n%total { } (min-double-associative _ _ _ _ _ _ _ _).\n\n\n%%% Theorems about max\n\n\n%theorem false-implies-max :\n\tforall* {X1} {X2} {X3}\n\tforall {F:void}\n\texists {M:max X1 X2 X3}\n\ttrue.\n\n%worlds () (false-implies-max _ _).\n%total { } (false-implies-max _ _).\n\n\n%theorem max-respects-eq :\n\tforall* {X1} {X2} {X3}\n\t\t{Y1} {Y2} {Y3}\n\tforall {MX:max X1 X2 X3}\n\t       {E1:eq X1 Y1} {E2:eq X2 Y2} {E3:eq X3 Y3}\n\texists {MY:max Y1 Y2 Y3}\n\ttrue.\n\n- : max-respects-eq M eq/ eq/ eq/ M.\n\n%worlds () (max-respects-eq _ _ _ _ _).\n%total { } (max-respects-eq _ _ _ _ _).\n\n\n%theorem max-total** :\n\tforall* {X1} {X2} {C}\n\tforall {D:compare X1 X2 C}\n\texists {X3} {M:max X1 X2 X3}\n\ttrue.\n\n- : max-total** compare/= _ max/=.\n\n- : max-total** (compare/> X1>X2) _ (max/> X1>X2).\n\n- : max-total** (compare/< X2>X1) _ (max/< X2>X1).\n\n%worlds () (max-total** _ _ _).\n%total { } (max-total** _ _ _).\n\n\n%theorem max-total* :\n\tforall {X1} {X2}\n\texists {X3} {M:max X1 X2 X3}\n\ttrue.\n\n- : max-total* X1 X2 X3 M\n    <- compare-total D\n    <- max-total** D X3 M.\n\n%worlds () (max-total* _ _ _ _).\n%total { } (max-total* _ _ _ _).\n\n\n%abbrev max-total = max-total* _ _ _.\n\n\n%theorem max-deterministic :\n\tforall* {X1} {X2} {X3}\n\t\t{Y1} {Y2} {Y3}\n\tforall {MX:max X1 X2 X3}\n\t       {MY:max Y1 Y2 Y3}\n\t       {E1:eq X1 Y1} {E2:eq X2 Y2}\n\texists {E3:eq X3 Y3}\n\ttrue.\n\n- : max-deterministic (max/=) (max/=) eq/ eq/ eq/.\n\n- : max-deterministic (max/=) (max/> X>X) eq/ eq/ eq/.\n\n- : max-deterministic (max/=) (max/< X>X) eq/ eq/ eq/.\n\n- : max-deterministic (max/> X>X) (max/=) eq/ eq/ eq/.\n\n- : max-deterministic (max/> X>Y) (max/> X>YP) eq/ eq/ eq/.\n\n- : max-deterministic (max/> X>Y) (max/< Y>X) eq/ eq/ E\n    <- gt-anti-symmetric X>Y Y>X F\n    <- false-implies-eq F E.\n\n- : max-deterministic (max/< X>X) (max/=) eq/ eq/ eq/.\n\n- : max-deterministic (max/< X>Y) (max/> Y>X) eq/ eq/ E\n    <- gt-anti-symmetric X>Y Y>X F\n    <- false-implies-eq F E.\n\n- : max-deterministic (max/< X>Y) (max/< X>YP) eq/ eq/ eq/.\n\n%worlds () (max-deterministic _ _ _ _ _).\n%total { } (max-deterministic _ _ _ _ _).\n\n\n%theorem max-commutative :\n\tforall* {X1} {X2} {X3}\n\tforall {M:max X1 X2 X3}\n\texists {Mc:max X2 X1 X3}\n\ttrue.\n\n- : max-commutative max/= max/=.\n\n- : max-commutative (max/> X>Y) (max/< X>Y).\n\n- : max-commutative (max/< X>Y) (max/> X>Y).\n\n%worlds () (max-commutative _ _).\n%total { } (max-commutative _ _).\n\n\n%theorem ge-implies-max :\n\tforall* {X1} {X2}\n\tforall {G:ge X1 X2}\n\texists {M:max X1 X2 X1}\n\ttrue.\n\n- : ge-implies-max (ge/> X1>X2) (max/> X1>X2).\n\n- : ge-implies-max (ge/= eq/) (max/=).\n\n%worlds () (ge-implies-max _ _).\n%total { } (ge-implies-max _ _).\n\n\n%theorem le-implies-max :\n\tforall* {X1} {X2}\n\tforall {G:le X1 X2}\n\texists {M:max X1 X2 X2}\n\ttrue.\n\n- : le-implies-max X2>=X1 M\n    <- ge-implies-max X2>=X1 Mc\n    <- max-commutative Mc M.\n\n%worlds () (le-implies-max _ _).\n%total { } (le-implies-max _ _).\n\n\n%theorem max-implies-ge :\n\tforall* {X1} {X2} {X3}\n\tforall {M:max X1 X2 X3}\n\texists {G1:ge X3 X1} {G2:ge X3 X2}\n\ttrue.\n\n- : max-implies-ge max/= (ge/= eq/) (ge/= eq/).\n\n- : max-implies-ge (max/> X1>X2) (ge/= eq/) (ge/> X1>X2).\n\n- : max-implies-ge (max/< X2>X1) (ge/> X2>X1) (ge/= eq/).\n\n%worlds () (max-implies-ge _ _ _).\n%total { } (max-implies-ge _ _ _).\n\n\n%theorem max-is-lub :\n\tforall* {X0} {X1} {X2} {X3}\n\tforall {M:max X1 X2 X3}\n\t       {G1:ge X0 X1}\n\t       {G2:ge X0 X2}\n\texists {G3:ge X0 X3}\n\ttrue.\n\n- : max-is-lub max/= G _ G.\n\n- : max-is-lub (max/> X1>X2) G _ G.\n\n- : max-is-lub (max/< X2>X1) _ G G.\n\n%worlds () (max-is-lub _ _ _ _).\n%total { } (max-is-lub _ _ _ _).\n\n\n%theorem max-left-preserves-ge* :\n\tforall* {X1} {X2} {X3} {X4} {X5} \n\tforall {G:ge X2 X4}\n\t       {M12:max X1 X2 X3} \n\t       {M14:max X1 X4 X5}\n\texists {G:ge X3 X5}\n\ttrue.\n\n- : max-left-preserves-ge* X>=X4 max/= X|X4=X5 X>=X5\n    <- ge-reflexive _ X>=X\n    <- max-is-lub X|X4=X5 X>=X X>=X4 X>=X5.\n\n- : max-left-preserves-ge* X2>=X4 (max/> X1>X2) X1|X4=X5 X1>=X5\n    <- ge-transitive (ge/> X1>X2) X2>=X4 X1>=X4\n    <- ge-reflexive _ X1>=X1\n    <- max-is-lub X1|X4=X5 X1>=X1 X1>=X4 X1>=X5.\n\n- : max-left-preserves-ge* X2>=X4 (max/< X2>X1) X1|X4=X5 X2>=X5\n    <- max-is-lub X1|X4=X5 (ge/> X2>X1) X2>=X4 X2>=X5.\n\n%worlds () (max-left-preserves-ge* _ _ _ _).\n%total { } (max-left-preserves-ge* _ _ _ _).\n\n\n%theorem max-left-preserves-le* :\n\tforall* {X1} {X2} {X3} {X4} {X5} \n\tforall {G:le X2 X4}\n\t       {M12:max X1 X2 X3} \n\t       {M14:max X1 X4 X5}\n\texists {G:le X3 X5}\n\ttrue.\n\n- : max-left-preserves-le* G1 M12 M14 G2\n    <- max-left-preserves-ge* G1 M14 M12 G2.\n\n%worlds () (max-left-preserves-le* _ _ _ _).\n%total { } (max-left-preserves-le* _ _ _ _).\n\n\n\n%theorem max-left-preserves-ge :\n\tforall* {X1} {X2} {X4}\n      \tforall {G:ge X2 X4}\n\texists {X3} {X5}\n               {O1:max X1 X2 X3} {O2:max X1 X4 X5}\n      \t       {G2:ge X3 X5}\n\ttrue.\n\n- : max-left-preserves-ge X2>=X4 X3 X5 X1&X2=A3 X1&X4=X5 X3>=X5\n    <- max-total X1&X2=A3 \n    <- max-total X1&X4=X5\n    <- max-left-preserves-ge* X2>=X4 X1&X2=A3 X1&X4=X5 X3>=X5.\n\n%worlds () (max-left-preserves-ge X2>=X4  X3 X5 X1&X2=A3 X1&X4=X5 X3>=X5).\n%total {} (max-left-preserves-ge _ _ _ _ _ _).\n\n\n%theorem max-right-preserves-ge* :\n\tforall* {X1} {X2} {X3} {X4} {X5}\n\tforall {G1:ge X1 X2} {O1:max X1 X3 X4} {O2:max X2 X3 X5}\n\texists {G2:ge X4 X5}\n\ttrue.\n\n- : max-right-preserves-ge* X1>=X2 X1&X3=X4 X2&X3=X5 X4>=X5\n    <- max-commutative X1&X3=X4 X3&X1=X4\n    <- max-commutative X2&X3=X5 X3&X2=X5\n    <- max-left-preserves-ge* X1>=X2 X3&X1=X4 X3&X2=X5 X4>=X5.\n\n%worlds () (max-right-preserves-ge* X1>=X2 X1&X3=X4 X2&X3=X5  X4>=X5).\n%total {} (max-right-preserves-ge* _ _ _ _).\n\n\n%theorem max-right-preserves-ge :\n\tforall* {X1} {X2} {X3}\n\tforall {G1:ge X1 X2} \n\texists {X4} {X5} {O1:max X1 X3 X4} {O2:max X2 X3 X5} {G2:ge X4 X5}\n\ttrue.\n\n- : max-right-preserves-ge X1>=X2 X4 X5 X1&X3=X4 X2&X3=X5 X4>=X5\n    <- max-total X1&X3=X4 \n    <- max-total X2&X3=X5\n    <- max-right-preserves-ge* X1>=X2 X1&X3=X4 X2&X3=X5 X4>=X5.\n%worlds () (max-right-preserves-ge X1>=X2  X4 X5 X1&X3=X4 X2&X3=X5 X4>=X5).\n%total {} (max-right-preserves-ge _ _ _ _ _ _).\n\n\n%theorem max-preserves-ge* :\n\tforall* {X1} {X2} {X3} {Y1} {Y2} {Y3}\n\tforall {G1:ge X1 Y1} {G2:ge X2 Y2}\n               {MX:max X1 X2 X3} {MY:max Y1 Y2 Y3}\n        exists {G3:ge X3 Y3}\n\ttrue.\n\n- : max-preserves-ge* X1>=Y1 X2>=Y2 X1&X2=X3 Y1&Y2=Y3 X3>=Y3\n    <- max-total Y1&X2=X\n    <- max-right-preserves-ge* X1>=Y1 X1&X2=X3 Y1&X2=X X3>=X\n    <- max-left-preserves-ge* X2>=Y2 Y1&X2=X Y1&Y2=Y3 X>=Y3\n    <- ge-transitive X3>=X X>=Y3 X3>=Y3.\n\n%worlds () (max-preserves-ge* X1>=Y1 X2>=Y2 X1&X2=X3 Y1&Y2=Y3  X3>=Y3).\n%total {} (max-preserves-ge* _ _ _ _ _).\n\n\n%theorem max-preserves-ge :\n\tforall* {X1} {X2} {Y1} {Y2}\n\tforall {G1:ge X1 Y1} {G2:ge X2 Y2}\n\texists {X3} {Y3} {MX:max X1 X2 X3} {MY:max Y1 Y2 Y3} {G3:ge X3 Y3}\n\ttrue.\n\n- : max-preserves-ge X1>=Y1 X2>=Y2 X3 Y3 X1&X2=X3 Y1&Y2=Y3 X3>=Y3\n    <- max-total X1&X2=X3\n    <- max-total Y1&Y2=Y3\n    <- max-preserves-ge* X1>=Y1 X2>=Y2 X1&X2=X3 Y1&Y2=Y3 X3>=Y3.\n\n%worlds () (max-preserves-ge X1>=Y1 X2>=Y2  X3 Y3 X1&X2=X3 Y1&Y2=Y3 X3>=Y3).\n%total {} (max-preserves-ge _ _ _ _ _ _ _).\n\n\n\n%theorem max-left-preserves-le :\n\tforall* {X1} {X2} {X4}\n      \tforall {G:le X2 X4}\n\texists {X3} {X5}\n               {O1:max X1 X2 X3} {O2:max X1 X4 X5}\n      \t       {G2:le X3 X5}\n\ttrue.\n\n- : max-left-preserves-le X2<=X4 X3 X5 X1&X2=A3 X1&X4=X5 X3<=X5\n    <- max-total X1&X2=A3 \n    <- max-total X1&X4=X5\n    <- max-left-preserves-le* X2<=X4 X1&X2=A3 X1&X4=X5 X3<=X5.\n\n%worlds () (max-left-preserves-le X2<=X4  X3 X5 X1&X2=A3 X1&X4=X5 X3<=X5).\n%total {} (max-left-preserves-le _ _ _ _ _ _).\n\n\n%theorem max-right-preserves-le* :\n\tforall* {X1} {X2} {X3} {X4} {X5}\n\tforall {G1:le X1 X2} {O1:max X1 X3 X4} {O2:max X2 X3 X5}\n\texists {G2:le X4 X5}\n\ttrue.\n\n- : max-right-preserves-le* X1<=X2 X1&X3=X4 X2&X3=X5 X4<=X5\n    <- max-commutative X1&X3=X4 X3&X1=X4\n    <- max-commutative X2&X3=X5 X3&X2=X5\n    <- max-left-preserves-le* X1<=X2 X3&X1=X4 X3&X2=X5 X4<=X5.\n\n%worlds () (max-right-preserves-le* X1<=X2 X1&X3=X4 X2&X3=X5  X4<=X5).\n%total {} (max-right-preserves-le* _ _ _ _).\n\n\n%theorem max-right-preserves-le :\n\tforall* {X1} {X2} {X3}\n\tforall {G1:le X1 X2} \n\texists {X4} {X5} {O1:max X1 X3 X4} {O2:max X2 X3 X5} {G2:le X4 X5}\n\ttrue.\n\n- : max-right-preserves-le X1<=X2 X4 X5 X1&X3=X4 X2&X3=X5 X4<=X5\n    <- max-total X1&X3=X4 \n    <- max-total X2&X3=X5\n    <- max-right-preserves-le* X1<=X2 X1&X3=X4 X2&X3=X5 X4<=X5.\n%worlds () (max-right-preserves-le X1<=X2  X4 X5 X1&X3=X4 X2&X3=X5 X4<=X5).\n%total {} (max-right-preserves-le _ _ _ _ _ _).\n\n\n%theorem max-preserves-le* :\n\tforall* {X1} {X2} {X3} {Y1} {Y2} {Y3}\n\tforall {G1:le X1 Y1} {G2:le X2 Y2}\n               {MX:max X1 X2 X3} {MY:max Y1 Y2 Y3}\n        exists {G3:le X3 Y3}\n\ttrue.\n\n- : max-preserves-le* X1<=Y1 X2<=Y2 X1&X2=X3 Y1&Y2=Y3 X3<=Y3\n    <- max-total Y1&X2=X\n    <- max-right-preserves-le* X1<=Y1 X1&X2=X3 Y1&X2=X X3<=X\n    <- max-left-preserves-le* X2<=Y2 Y1&X2=X Y1&Y2=Y3 X<=Y3\n    <- le-transitive X3<=X X<=Y3 X3<=Y3.\n\n%worlds () (max-preserves-le* X1<=Y1 X2<=Y2 X1&X2=X3 Y1&Y2=Y3  X3<=Y3).\n%total {} (max-preserves-le* _ _ _ _ _).\n\n\n%theorem max-preserves-le :\n\tforall* {X1} {X2} {Y1} {Y2}\n\tforall {G1:le X1 Y1} {G2:le X2 Y2}\n\texists {X3} {Y3} {MX:max X1 X2 X3} {MY:max Y1 Y2 Y3} {G3:le X3 Y3}\n\ttrue.\n\n- : max-preserves-le X1<=Y1 X2<=Y2 X3 Y3 X1&X2=X3 Y1&Y2=Y3 X3<=Y3\n    <- max-total X1&X2=X3\n    <- max-total Y1&Y2=Y3\n    <- max-preserves-le* X1<=Y1 X2<=Y2 X1&X2=X3 Y1&Y2=Y3 X3<=Y3.\n\n%worlds () (max-preserves-le X1<=Y1 X2<=Y2  X3 Y3 X1&X2=X3 Y1&Y2=Y3 X3<=Y3).\n%total {} (max-preserves-le _ _ _ _ _ _ _).\n\n\n%theorem max-associative :\n\tforall* {X1} {X2} {X3} {X4} {X7}\n\tforall {M12:max X1 X2 X3}\n\t       {M34:max X3 X4 X7}\n\texists {X6} {M24:max X2 X4 X6}\n\t       {M16:max X1 X6 X7}\n\ttrue.\n\n- : max-associative max/= max/= _ max/= max/=.\n\n- : max-associative max/= (max/> X3>X4) _ (max/> X3>X4) max/=.\n\n- : max-associative max/= (max/< X4>X3) _ (max/< X4>X3) (max/< X4>X3).\n\n- : max-associative (max/> X1>X2) max/= _ (max/< X1>X2) max/=.\n\n- : max-associative (max/> X1>X2) (max/> X1>X4) _ M24 M16\n    <- max-total M24\n    <- max-is-lub M24 (ge/> X1>X2) (ge/> X1>X4) X1>=X6\n    <- ge-implies-max X1>=X6 M16.\n\n- : max-associative (max/> X1>X2) (max/< X4>X1) _ (max/< X4>X2) (max/< X4>X1)\n    <- gt-transitive X4>X1 X1>X2 X4>X2.\n\n- : max-associative (max/< X2>X1) max/= _ max/= (max/< X2>X1).\n\n- : max-associative (max/< X2>X1) (max/> X2>X4) _ (max/> X2>X4) (max/< X2>X1).\n\n- : max-associative (max/< X2>X1) (max/< X4>X2) _ (max/< X4>X2) (max/< X4>X1)\n    <- gt-transitive X4>X2 X2>X1 X4>X1.\n\n%worlds () (max-associative _ _ _ _ _).\n%total { } (max-associative _ _ _ _ _).\n\n\n%theorem max-associative* :\n\tforall* {X1} {X2} {X12} {X3} {X23} {X123}\n        forall {OP12:max X1 X2 X12} {OP12-3:max X12 X3 X123} {OP23:max X2 X3 X23}\n        exists {OP1-23:max X1 X23 X123}\n        true.\n\n- : max-associative* X1|X2=X3 X3|X4=X7 X2|X4=X6 X1|X6=X7\n    <- max-associative X1|X2=X3 X3|X4=X7 Y6 X2|X4=Y6 X1|Y6=X7\n    <- max-deterministic X2|X4=Y6 X2|X4=X6 eq/ eq/ Y6=X6\n    <- max-respects-eq X1|Y6=X7 eq/ Y6=X6 eq/ X1|X6=X7.\n\n%worlds () (max-associative* _ _ _ _).\n%total {} (max-associative* _ _ _ _).\n\n\n%theorem max-associative-converse :\n\tforall* {X1} {X2} {X4} {X6} {X7}\n\tforall {OP24:max X2 X4 X6} {OP16:max X1 X6 X7}\n        exists {X3} {OP12:max X1 X2 X3} {OP34:max X3 X4 X7}\n        true.\n\n- : max-associative-converse X2|X4=X6 X1|X6=X7 _ X1|X2=X3 X3|X4=X7\n    <- max-commutative X2|X4=X6 X4|X2=X6\n    <- max-commutative X1|X6=X7 X6|X1=X7\n    <- max-associative X4|X2=X6 X6|X1=X7 _ X2|X1=X3 X4|X3=X7\n    <- max-commutative X2|X1=X3 X1|X2=X3\n    <- max-commutative X4|X3=X7 X3|X4=X7.\n\n%worlds () (max-associative-converse X2|X4=X6 X1|X6=X7 X3 X1|X2=X3 X3|X4=X7).\n%total {} (max-associative-converse _ _ _ _ _).\n\n\n%theorem max-associative-converse* :\n\tforall* {X1} {X2} {X3} {X4} {X6} {X7}\n\tforall {OP24:max X2 X4 X6} {OP16:max X1 X6 X7} {OP12:max X1 X2 X3} \n\texists {OP34:max X3 X4 X7}\n        true.\n\n- : max-associative-converse* X2|X4=X6 X1|X6=X7 X1|X2=X3 X3|X4=X7\n    <- max-associative-converse X2|X4=X6 X1|X6=X7 X3P X1|X2=X3P X3P|X4=X7\n    <- max-deterministic X1|X2=X3P X1|X2=X3 eq/ eq/ X3P=X3\n    <- max-respects-eq X3P|X4=X7 X3P=X3 eq/ eq/ X3|X4=X7.\n\n%worlds () (max-associative-converse* X2|X4=X6 X1|X6=X7 X1|X2=X3  X3|X4=X7).\n%total {} (max-associative-converse* _ _ _ _).\n\n\n%theorem max-assoc-commutative* :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X7}\n\tforall {OP1:max X1 X2 X3} {OP2:max X3 X4 X7}\n               {OP3:max X1 X4 X5} \n        exists {OP4:max X5 X2 X7}\n\ttrue.\n\n- : max-assoc-commutative* X1|X2=X3 X3|X4=X7 X1|X4=X5 X5|X2=X7\n    <- max-associative X1|X2=X3 X3|X4=X7 X6 X2|X4=X6 X1|X6=X7\n    <- max-commutative X2|X4=X6 X4|X2=X6\n    <- max-associative-converse* X4|X2=X6 X1|X6=X7 X1|X4=X5 X5|X2=X7.\n\n%worlds () (max-assoc-commutative* X1|X2=X3 X3|X4=X7 X1|X4=X5  X5|X2=X7).\n%total {} (max-assoc-commutative* _ _ _ _).\n\n\n%theorem max-assoc-commutative :\n\tforall* {X1} {X2} {X3} {X4} {X7}\n\tforall {OP1:max X1 X2 X3} {OP2:max X3 X4 X7}\n        exists {X5} {OP3:max X1 X4 X5} {OP4:max X5 X2 X7}\n\ttrue.\n\n- : max-assoc-commutative X1|X2=X3 X3|X4=X7 X5 X1|X4=X5 X5|X2=X7\n    <- max-associative X1|X2=X3 X3|X4=X7 X6 X2|X4=X6 X1|X6=X7\n    <- max-commutative X2|X4=X6 X4|X2=X6\n    <- max-associative-converse X4|X2=X6 X1|X6=X7 X5 X1|X4=X5 X5|X2=X7.\n\n%worlds () (max-assoc-commutative X1|X2=X3 X3|X4=X7  X5 X1|X4=X5 X5|X2=X7).\n%total {} (max-assoc-commutative _ _ _ _ _).\n\n\n%theorem max-double-associative* :\n\tforall* {A} {B} {C} {D} {A+B} {C+D} {A+C} {B+D} {X}\n\tforall {AB:max A B A+B} {CD:max C D C+D} {ABCD:max A+B C+D X}\n\t       {AC:max A C A+C} {BD:max B D B+D} \n        exists {ACBD:max A+C B+D X}\n\ttrue.\n\n- : max-double-associative* X1|X2=X3 X4|X8=XC X3|XC=XF X1|X4=X5 X2|X8=XA X5|XA=XF\n    <- max-associative X1|X2=X3 X3|XC=XF XE X2|XC=XE X1|XE=XF\n    <- max-commutative X4|X8=XC X8|X4=XC\n    <- max-associative-converse* X8|X4=XC X2|XC=XE X2|X8=XA XA|X4=XE\n    <- max-commutative XA|X4=XE X4|XA=XE\n    <- max-associative-converse* X4|XA=XE X1|XE=XF X1|X4=X5 X5|XA=XF.\n\n%worlds () (max-double-associative* X1|X2=X3 X4|X8=XC X3|XC=XF X1|X4=X5 X2|X8=XA\n                             X5|XA=XF).\n%total {} (max-double-associative* _ _ _ _ _ _).\n\n\n%theorem max-double-associative :\n\tforall* {A} {B} {C} {D} {A+B} {C+D} {X}\n\tforall {AB:max A B A+B} {CD:max C D C+D} {ABCD:max A+B C+D X}\n\texists {A+C} {B+D} {AC:max A C A+C} {BD:max B D B+D} \n               {ACBD:max A+C B+D X}\n\ttrue.\n\n- : max-double-associative X1|X2=X3 X4|X8=XC X3|XC=XF X5 XA X1|X4=X5 X2|X8=XA X5|XA=XF\n    <- max-associative X1|X2=X3 X3|XC=XF XE X2|XC=XE X1|XE=XF\n    <- max-commutative X4|X8=XC X8|X4=XC\n    <- max-associative-converse X8|X4=XC X2|XC=XE XA X2|X8=XA XA|X4=XE\n    <- max-commutative XA|X4=XE X4|XA=XE\n    <- max-associative-converse X4|XA=XE X1|XE=XF X5 X1|X4=X5 X5|XA=XF.\n\n%worlds () (max-double-associative _ _ _ _ _ _ _ _).\n%total { } (max-double-associative _ _ _ _ _ _ _ _).\n\n\n%%% Distributivity theorems\n\n\n%theorem min-right-distributes-over-max :\n\tforall* {X1} {X2} {X3} {X4} {X7}\n        forall {A12:max X1 X2 X3} {M34:min X3 X4 X7}\n        exists {X5} {X6}\n               {M14:min X1 X4 X5} {M24:min X2 X4 X6}\n               {A56:max X5 X6 X7}\n\ttrue.\n\n- : min-right-distributes-over-max max/= M _ _ M M max/=.\n\n- : min-right-distributes-over-max (max/> X1>X2) X1&X4=X7 _ _ \n                                   X1&X4=X7 X2&X4=X6 X7|X6=X7\n    <- min-total X2&X4=X6\n    <- min-right-preserves-ge* (ge/> X1>X2) X1&X4=X7 X2&X4=X6 X7>=X6\n    <- ge-implies-max X7>=X6 X7|X6=X7.\n\n- : min-right-distributes-over-max (max/< X2>X1) X2&X4=X7 _ _\n\t\t\t\t   X1&X4=X5 X2&X4=X7 X5|X7=X7\n    <- min-total X1&X4=X5\n    <- min-right-preserves-ge* (ge/> X2>X1) X2&X4=X7 X1&X4=X5 X7>=X5\n    <- ge-implies-max X7>=X5 X7|X5=X7\n    <- max-commutative X7|X5=X7 X5|X7=X7.\n\n%worlds () (min-right-distributes-over-max _ _ _ _ _ _ _).\n%total { } (min-right-distributes-over-max _ _ _ _ _ _ _).\n\n\n%theorem max-right-distributes-over-min :\n\tforall* {X1} {X2} {X3} {X4} {X7}\n        forall {A12:min X1 X2 X3} {M34:max X3 X4 X7}\n        exists {X5} {X6}\n               {M14:max X1 X4 X5} {M24:max X2 X4 X6}\n               {A56:min X5 X6 X7}\n\ttrue.\n\n- : max-right-distributes-over-min min/= M _ _ M M min/=.\n\n- : max-right-distributes-over-min (min/> X1>X2) X2|X4=X7 _ _\n                                   X1|X4=X5 X2|X4=X7 X5&X7=X7\n    <- max-total X1|X4=X5\n    <- max-right-preserves-ge* (ge/> X1>X2) X1|X4=X5 X2|X4=X7 X5>=X7\n    <- ge-implies-min X5>=X7 X5&X7=X7.\n\n- : max-right-distributes-over-min (min/< X2>X1) X1|X4=X7 _ _\n\t\t\t\t   X1|X4=X7 X2|X4=X6 X7&X6=X7\n    <- max-total X2|X4=X6\n    <- max-right-preserves-ge* (ge/> X2>X1) X2|X4=X6 X1|X4=X7 X6>=X7\n    <- le-implies-min X6>=X7 X7&X6=X7.\n\n%worlds () (max-right-distributes-over-min _ _ _ _ _ _ _).\n%total { } (max-right-distributes-over-min _ _ _ _ _ _ _).\n\n\n\n%theorem min-right-distributes-over-max* :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X6} {X7}\n        forall {A12:max X1 X2 X3} {M34:min X3 X4 X7}\n               {M14:min X1 X4 X5} {M24:min X2 X4 X6}\n        exists {A56:max X5 X6 X7}\n\ttrue.\n\n- : min-right-distributes-over-max* X1|X2=X3 X3&X4=X7 X1&X4=X5 X2&X4=X6 X5|X6=X7\n    <- min-right-distributes-over-max X1|X2=X3 X3&X4=X7 Y5 Y6\n                                      X1&X4=Y5 X2&X4=Y6 Y5|Y6=X7\n    <- min-deterministic X1&X4=Y5 X1&X4=X5 eq/ eq/ Y5=X5\n    <- min-deterministic X2&X4=Y6 X2&X4=X6 eq/ eq/ Y6=X6\n    <- max-respects-eq Y5|Y6=X7 Y5=X5 Y6=X6 eq/ X5|X6=X7.\n\n%worlds () (min-right-distributes-over-max* X1|X2=X3 X3&X4=X7 X1&X4=X5 X2&X4=X6\n                                       X5|X6=X7).\n%total {} (min-right-distributes-over-max* _ _ _ _ _).\n\n\n%theorem min-left-distributes-over-max* :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X6} {X7}\n        forall {A12:max X2 X4 X6} {M34:min X1 X6 X7}\n               {M14:min X1 X2 X3} {M24:min X1 X4 X5}\n        exists {A56:max X3 X5 X7}\n\ttrue.\n\n- : min-left-distributes-over-max* X2|X4=X6 X1&X6=X7 X1&X2=X3 X1&X4=X5 X3|X5=X7\n    <- min-commutative X1&X6=X7 X6&X1=X7\n    <- min-commutative X1&X2=X3 X2&X1=X3\n    <- min-commutative X1&X4=X5 X4&X1=X5\n    <- min-right-distributes-over-max* X2|X4=X6 X6&X1=X7 X2&X1=X3 X4&X1=X5\n                                       X3|X5=X7.\n\n%worlds () (min-left-distributes-over-max* X2|X4=X6 X1&X6=X7 X1&X2=X3 X1&X4=X5\n                                     X3|X5=X7).\n%total {} (min-left-distributes-over-max* _ _ _ _ _).\n\n\n%theorem min-left-distributes-over-max :\n\tforall* {X1} {X2} {X4} {X6} {X7}\n        forall {A12:max X2 X4 X6} {M34:min X1 X6 X7}\n        exists {X3} {X5} {M14:min X1 X2 X3} {M24:min X1 X4 X5}\n               {A56:max X3 X5 X7}\n\ttrue.\n\n- : min-left-distributes-over-max X2|X4=X6 X1&X6=X7 \n                                  X3 X5 X1&X2=X3 X1&X4=X5 X3|X5=X7\n    <- min-total X1&X2=X3\n    <- min-total X1&X4=X5\n    <- min-left-distributes-over-max* X2|X4=X6 X1&X6=X7 X1&X2=X3 X1&X4=X5\n                                      X3|X5=X7.\n\n%worlds () (min-left-distributes-over-max X2|X4=X6 X1&X6=X7 \n                                    X3 X5 X1&X2=X3 X1&X4=X5 X3|X5=X7).\n%total {} (min-left-distributes-over-max _ _ _ _ _ _ _).\n\n\n%theorem min-right-factors-over-max :\n\tforall* {X1} {X2} {X4} {X5} {X6} {X7}\n        forall {M14:min X1 X4 X5} {M24:min X2 X4 X6} {A56:max X5 X6 X7}\n        exists {X3} {A12:max X1 X2 X3} {M34:min X3 X4 X7}\n\ttrue.\n- : min-right-factors-over-max X1&X4=X5 X2&X4=X6 X5|X6=X7 X3 X1|X2=X3 X3&X4=X7\n    <- max-total X1|X2=X3\n    <- min-total X3&X4=Y7\n    <- min-right-distributes-over-max* X1|X2=X3 X3&X4=Y7 X1&X4=X5 X2&X4=X6 \n                                       X5|X6=Y7\n    <- max-deterministic X5|X6=Y7 X5|X6=X7 eq/ eq/ Y7=X7\n    <- min-respects-eq X3&X4=Y7 eq/ eq/ Y7=X7 X3&X4=X7.\n\n%worlds () (min-right-factors-over-max X1&X4=X5 X2&X4=X6 X5|X6=X7\n                                 X3 X1|X2=X3 X3&X4=X7 ).\n%total {} (min-right-factors-over-max _ _ _ _ _ _).\n\n\n%theorem min-right-factors-over-max* :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X6} {X7}\n        forall {M14:min X1 X4 X5} {M24:min X2 X4 X6} {A56:max X5 X6 X7}\n               {A12:max X1 X2 X3} \n        exists {M34:min X3 X4 X7}\n\ttrue.\n\n- : min-right-factors-over-max* X1&X4=X5 X2&X4=X6 X5|X6=X7 X1|X2=X3 X3&X4=X7\n    <- min-total X3&X4=Y7\n    <- min-right-distributes-over-max* X1|X2=X3 X3&X4=Y7 X1&X4=X5 X2&X4=X6 \n                                       X5|X6=Y7\n    <- max-deterministic X5|X6=Y7 X5|X6=X7 eq/ eq/ Y7=X7\n    <- min-respects-eq X3&X4=Y7 eq/ eq/ Y7=X7 X3&X4=X7.\n\n%worlds () (min-right-factors-over-max* X1&X4=X5 X2&X4=X6 X5|X6=X7 X1|X2=X3\n                                  X3&X4=X7 ).\n%total {} (min-right-factors-over-max* _ _ _ _ _).\n\n\n%theorem min-left-factors-over-max :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X7}\n\tforall {M12:min X1 X2 X3} {M14:min X1 X4 X5} {A35:max X3 X5 X7}\n        exists {X6} {A24:max X2 X4 X6} {M16:min X1 X6 X7}\n        true.\n\n- : min-left-factors-over-max X1&X2=X3 X1&X4=X5 X3|X5=X7 X6 X2|X4=X6 X1&X6=X7\n    <- min-commutative X1&X2=X3 X2&X1=X3\n    <- min-commutative X1&X4=X5 X4&X1=X5\n    <- min-right-factors-over-max X2&X1=X3 X4&X1=X5 X3|X5=X7 X6 X2|X4=X6 X6&X1=X7\n    <- min-commutative X6&X1=X7 X1&X6=X7.\n\n%worlds () (min-left-factors-over-max X1&X2=X3 X1&X4=X5 X3|X5=X7\n                                X6 X2|X4=X6 X1&X6=X7).\n%total {} (min-left-factors-over-max _ _ _ _ _ _).\n\n\n%theorem min-left-factors-over-max* :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X6} {X7}\n\tforall {M12:min X1 X2 X3} {M14:min X1 X4 X5} \n               {A35:max X3 X5 X7} {A24:max X2 X4 X6} \n        exists {M16:min X1 X6 X7}\n        true.\n\n- : min-left-factors-over-max* X1&X2=X3 X1&X4=X5 X3|X5=X7 X2|X4=X6 \n                               X1&X6=X7\n    <- min-total X1&X6=Y7\n    <- min-left-distributes-over-max* X2|X4=X6 X1&X6=Y7 X1&X2=X3 X1&X4=X5\n                                      X3|X5=Y7\n    <- max-deterministic X3|X5=Y7 X3|X5=X7 eq/ eq/ Y7=X7\n    <- min-respects-eq X1&X6=Y7 eq/ eq/ Y7=X7 X1&X6=X7.\n\n%worlds () (min-left-factors-over-max* X1&X2=X3 X1&X4=X5 X3|X5=X7 X2|X4=X6 \n                                X1&X6=X7).\n%total {} (min-left-factors-over-max* _ _ _ _ _).\n\n\n\n%theorem max-right-distributes-over-min* :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X6} {X7}\n        forall {A12:min X1 X2 X3} {M34:max X3 X4 X7}\n               {M14:max X1 X4 X5} {M24:max X2 X4 X6}\n        exists {A56:min X5 X6 X7}\n\ttrue.\n\n- : max-right-distributes-over-min* X1&X2=X3 X3|X4=X7 X1|X4=X5 X2|X4=X6 X5&X6=X7\n    <- max-right-distributes-over-min X1&X2=X3 X3|X4=X7 Y5 Y6\n                                      X1|X4=Y5 X2|X4=Y6 Y5&Y6=X7\n    <- max-deterministic X1|X4=Y5 X1|X4=X5 eq/ eq/ Y5=X5\n    <- max-deterministic X2|X4=Y6 X2|X4=X6 eq/ eq/ Y6=X6\n    <- min-respects-eq Y5&Y6=X7 Y5=X5 Y6=X6 eq/ X5&X6=X7.\n\n%worlds () (max-right-distributes-over-min* X1&X2=X3 X3|X4=X7 X1|X4=X5 X2|X4=X6\n                                       X5&X6=X7).\n%total {} (max-right-distributes-over-min* _ _ _ _ _).\n\n\n%theorem max-left-distributes-over-min* :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X6} {X7}\n        forall {A12:min X2 X4 X6} {M34:max X1 X6 X7}\n               {M14:max X1 X2 X3} {M24:max X1 X4 X5}\n        exists {A56:min X3 X5 X7}\n\ttrue.\n\n- : max-left-distributes-over-min* X2&X4=X6 X1|X6=X7 X1|X2=X3 X1|X4=X5 X3&X5=X7\n    <- max-commutative X1|X6=X7 X6|X1=X7\n    <- max-commutative X1|X2=X3 X2|X1=X3\n    <- max-commutative X1|X4=X5 X4|X1=X5\n    <- max-right-distributes-over-min* X2&X4=X6 X6|X1=X7 X2|X1=X3 X4|X1=X5\n                                       X3&X5=X7.\n\n%worlds () (max-left-distributes-over-min* X2&X4=X6 X1|X6=X7 X1|X2=X3 X1|X4=X5\n                                     X3&X5=X7).\n%total {} (max-left-distributes-over-min* _ _ _ _ _).\n\n\n%theorem max-left-distributes-over-min :\n\tforall* {X1} {X2} {X4} {X6} {X7}\n        forall {A12:min X2 X4 X6} {M34:max X1 X6 X7}\n        exists {X3} {X5} {M14:max X1 X2 X3} {M24:max X1 X4 X5}\n               {A56:min X3 X5 X7}\n\ttrue.\n\n- : max-left-distributes-over-min X2&X4=X6 X1|X6=X7 \n                                  X3 X5 X1|X2=X3 X1|X4=X5 X3&X5=X7\n    <- max-total X1|X2=X3\n    <- max-total X1|X4=X5\n    <- max-left-distributes-over-min* X2&X4=X6 X1|X6=X7 X1|X2=X3 X1|X4=X5\n                                      X3&X5=X7.\n\n%worlds () (max-left-distributes-over-min X2&X4=X6 X1|X6=X7 \n                                    X3 X5 X1|X2=X3 X1|X4=X5 X3&X5=X7).\n%total {} (max-left-distributes-over-min _ _ _ _ _ _ _).\n\n\n%theorem max-right-factors-over-min :\n\tforall* {X1} {X2} {X4} {X5} {X6} {X7}\n        forall {M14:max X1 X4 X5} {M24:max X2 X4 X6} {A56:min X5 X6 X7}\n        exists {X3} {A12:min X1 X2 X3} {M34:max X3 X4 X7}\n\ttrue.\n- : max-right-factors-over-min X1|X4=X5 X2|X4=X6 X5&X6=X7 X3 X1&X2=X3 X3|X4=X7\n    <- min-total X1&X2=X3\n    <- max-total X3|X4=Y7\n    <- max-right-distributes-over-min* X1&X2=X3 X3|X4=Y7 X1|X4=X5 X2|X4=X6 \n                                       X5&X6=Y7\n    <- min-deterministic X5&X6=Y7 X5&X6=X7 eq/ eq/ Y7=X7\n    <- max-respects-eq X3|X4=Y7 eq/ eq/ Y7=X7 X3|X4=X7.\n\n%worlds () (max-right-factors-over-min X1|X4=X5 X2|X4=X6 X5&X6=X7\n                                 X3 X1&X2=X3 X3|X4=X7 ).\n%total {} (max-right-factors-over-min _ _ _ _ _ _).\n\n\n%theorem max-right-factors-over-min* :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X6} {X7}\n        forall {M14:max X1 X4 X5} {M24:max X2 X4 X6} {A56:min X5 X6 X7}\n               {A12:min X1 X2 X3} \n        exists {M34:max X3 X4 X7}\n\ttrue.\n\n- : max-right-factors-over-min* X1|X4=X5 X2|X4=X6 X5&X6=X7 X1&X2=X3 X3|X4=X7\n    <- max-total X3|X4=Y7\n    <- max-right-distributes-over-min* X1&X2=X3 X3|X4=Y7 X1|X4=X5 X2|X4=X6 \n                                       X5&X6=Y7\n    <- min-deterministic X5&X6=Y7 X5&X6=X7 eq/ eq/ Y7=X7\n    <- max-respects-eq X3|X4=Y7 eq/ eq/ Y7=X7 X3|X4=X7.\n\n%worlds () (max-right-factors-over-min* X1|X4=X5 X2|X4=X6 X5&X6=X7 X1&X2=X3\n                                  X3|X4=X7 ).\n%total {} (max-right-factors-over-min* _ _ _ _ _).\n\n\n%theorem max-left-factors-over-min :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X7}\n\tforall {M12:max X1 X2 X3} {M14:max X1 X4 X5} {A35:min X3 X5 X7}\n        exists {X6} {A24:min X2 X4 X6} {M16:max X1 X6 X7}\n        true.\n\n- : max-left-factors-over-min X1|X2=X3 X1|X4=X5 X3&X5=X7 X6 X2&X4=X6 X1|X6=X7\n    <- max-commutative X1|X2=X3 X2|X1=X3\n    <- max-commutative X1|X4=X5 X4|X1=X5\n    <- max-right-factors-over-min X2|X1=X3 X4|X1=X5 X3&X5=X7 X6 X2&X4=X6 X6|X1=X7\n    <- max-commutative X6|X1=X7 X1|X6=X7.\n\n%worlds () (max-left-factors-over-min X1|X2=X3 X1|X4=X5 X3&X5=X7\n                                X6 X2&X4=X6 X1|X6=X7).\n%total {} (max-left-factors-over-min _ _ _ _ _ _).\n\n\n%theorem max-left-factors-over-min* :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X6} {X7}\n\tforall {M12:max X1 X2 X3} {M14:max X1 X4 X5} \n               {A35:min X3 X5 X7} {A24:min X2 X4 X6} \n        exists {M16:max X1 X6 X7}\n        true.\n\n- : max-left-factors-over-min* X1|X2=X3 X1|X4=X5 X3&X5=X7 X2&X4=X6 \n                               X1|X6=X7\n    <- max-total X1|X6=Y7\n    <- max-left-distributes-over-min* X2&X4=X6 X1|X6=Y7 X1|X2=X3 X1|X4=X5\n                                      X3&X5=Y7\n    <- min-deterministic X3&X5=Y7 X3&X5=X7 eq/ eq/ Y7=X7\n    <- max-respects-eq X1|X6=Y7 eq/ eq/ Y7=X7 X1|X6=X7.\n\n%worlds () (max-left-factors-over-min* X1|X2=X3 X1|X4=X5 X3&X5=X7 X2&X4=X6 \n                                X1|X6=X7).\n%total {} (max-left-factors-over-min* _ _ _ _ _).\n\n\n%abbrev nat`nat = nat.\n%abbrev nat`z = z.\n%abbrev nat`s = s.\n%abbrev nat`plus = plus.\n%abbrev nat`plus/z = plus/z.\n%abbrev nat`plus/s = plus/s.\n%abbrev nat`times = times.\n%abbrev nat`times/z = times/z.\n%abbrev nat`times/s = times/s.\n%abbrev nat`eq = eq.\n%abbrev nat`eq/ = eq/.\n%abbrev nat`gt = gt.\n%abbrev nat`gt/1 = gt/1.\n%abbrev nat`gt/> = gt/>.\n%abbrev nat`compare = compare.\n%abbrev nat`compare/= = compare/=.\n%abbrev nat`compare/< = compare/<.\n%abbrev nat`compare/> = compare/>.\n%abbrev nat`meta-eq = meta-eq.\n%abbrev nat`false-implies-eq = false-implies-eq.\n%abbrev nat`eq-symmetric = eq-symmetric.\n%abbrev nat`eq-transitive = eq-transitive.\n%abbrev nat`succ-deterministic = succ-deterministic.\n%abbrev nat`succ-cancels = succ-cancels.\n%abbrev nat`eq-contradiction = eq-contradiction.\n%abbrev nat`meta-gt = meta-gt.\n%abbrev nat`false-implies-gt = false-implies-gt.\n%abbrev nat`gt-respects-eq = gt-respects-eq.\n%abbrev nat`succ-implies-gt = succ-implies-gt.\n%abbrev nat`succ-implies-gt-zero = succ-implies-gt-zero.\n%abbrev nat`succ-preserves-gt = succ-preserves-gt.\n%abbrev nat`succ-preserves-gt-converse = succ-preserves-gt-converse.\n%abbrev nat`gt-implies-positive = gt-implies-positive.\n%abbrev nat`gt-anti-reflexive* = gt-anti-reflexive*.\n%abbrev nat`gt-anti-reflexive = gt-anti-reflexive.\n%abbrev nat`gt-transitive = gt-transitive.\n%abbrev nat`gt-anti-symmetric = gt-anti-symmetric.\n%abbrev nat`gt-implies-plus = gt-implies-plus.\n%abbrev nat`gt-contradiction = gt-contradiction.\n%abbrev nat`false-implies-compare = false-implies-compare.\n%abbrev nat`succ-preserves-compare = succ-preserves-compare.\n%abbrev nat`compare-total* = compare-total*.\n%abbrev nat`compare-total = compare-total.\n%abbrev nat`greater-implies-gt = greater-implies-gt.\n%abbrev nat`less-is-reverse-greater = less-is-reverse-greater.\n%abbrev nat`less-implies-lt = less-implies-lt.\n%abbrev nat`equal-implies-eq = equal-implies-eq.\n%abbrev nat`false-implies-plus = false-implies-plus.\n%abbrev nat`plus-respects-eq = plus-respects-eq.\n%abbrev nat`plus-total* = plus-total*.\n%abbrev nat`plus-total = plus-total.\n%abbrev nat`plus-deterministic = plus-deterministic.\n%abbrev nat`plus-left-identity = plus-left-identity.\n%abbrev nat`plus-left-increase = plus-left-increase.\n%abbrev nat`plus-right-identity = plus-right-identity.\n%abbrev nat`plus-right-increase = plus-right-increase.\n%abbrev nat`plus-left-decrease = plus-left-decrease.\n%abbrev nat`plus-right-decrease = plus-right-decrease.\n%abbrev nat`plus-swap-succ = plus-swap-succ.\n%abbrev nat`plus-swap-succ-converse = plus-swap-succ-converse.\n%abbrev nat`plus-left-preserves-positive = plus-left-preserves-positive.\n%abbrev nat`plus-right-preserves-positive = plus-right-preserves-positive.\n%abbrev nat`plus-is-zero-implies-zero = plus-is-zero-implies-zero.\n%abbrev nat`plus-commutative = plus-commutative.\n%abbrev nat`plus-associative = plus-associative.\n%abbrev nat`plus-associative* = plus-associative*.\n%abbrev nat`plus-associative-converse = plus-associative-converse.\n%abbrev nat`plus-associative-converse* = plus-associative-converse*.\n%abbrev nat`plus-assoc-commutative* = plus-assoc-commutative*.\n%abbrev nat`plus-assoc-commutative = plus-assoc-commutative.\n%abbrev nat`plus-double-associative* = plus-double-associative*.\n%abbrev nat`plus-double-associative = plus-double-associative.\n%abbrev nat`plus-left-cancels = plus-left-cancels.\n%abbrev nat`plus-right-cancels* = plus-right-cancels*.\n%abbrev nat`plus-right-cancels = plus-right-cancels.\n%abbrev nat`plus-left-preserves-gt* = plus-left-preserves-gt*.\n%abbrev nat`plus-left-cancels-gt = plus-left-cancels-gt.\n%abbrev nat`plus-left-preserves-gt = plus-left-preserves-gt.\n%abbrev nat`plus-right-preserves-gt* = plus-right-preserves-gt*.\n%abbrev nat`plus-right-preserves-gt = plus-right-preserves-gt.\n%abbrev nat`plus-preserves-gt* = plus-preserves-gt*.\n%abbrev nat`plus-preserves-gt = plus-preserves-gt.\n%abbrev nat`plus-right-cancels-gt = plus-right-cancels-gt.\n%abbrev nat`plus-implies-gt = plus-implies-gt.\n%abbrev nat`plus-gt-contradiction = plus-gt-contradiction.\n%abbrev nat`false-implies-times = false-implies-times.\n%abbrev nat`times-respects-eq = times-respects-eq.\n%abbrev nat`times-total* = times-total*.\n%abbrev nat`times-total = times-total.\n%abbrev nat`times-deterministic = times-deterministic.\n%abbrev nat`times-left-identity = times-left-identity.\n%abbrev nat`times-right-identity = times-right-identity.\n%abbrev nat`times-right-zero = times-right-zero.\n%abbrev nat`times-preserves-positive = times-preserves-positive.\n%abbrev nat`times-preserves-positive* = times-preserves-positive*.\n%abbrev nat`times-positive-implies-positive = times-positive-implies-positive.\n%abbrev nat`times-left-increase = times-left-increase.\n%abbrev nat`times-right-increase = times-right-increase.\n%abbrev nat`times-left-decrease = times-left-decrease.\n%abbrev nat`times-right-decrease = times-right-decrease.\n%abbrev nat`times-commutative = times-commutative.\n%abbrev nat`times-right-distributes-over-plus = times-right-distributes-over-plus.\n%abbrev nat`times-right-distributes-over-plus* = times-right-distributes-over-plus*.\n%abbrev nat`times-left-distributes-over-plus* = times-left-distributes-over-plus*.\n%abbrev nat`times-left-distributes-over-plus = times-left-distributes-over-plus.\n%abbrev nat`times-right-factors-over-plus = times-right-factors-over-plus.\n%abbrev nat`times-right-factors-over-plus* = times-right-factors-over-plus*.\n%abbrev nat`times-left-factors-over-plus = times-left-factors-over-plus.\n%abbrev nat`times-left-factors-over-plus* = times-left-factors-over-plus*.\n%abbrev nat`times-associative = times-associative.\n%abbrev nat`times-associative* = times-associative*.\n%abbrev nat`times-associative-converse = times-associative-converse.\n%abbrev nat`times-associative-converse* = times-associative-converse*.\n%abbrev nat`times-assoc-commutative* = times-assoc-commutative*.\n%abbrev nat`times-assoc-commutative = times-assoc-commutative.\n%abbrev nat`times-double-associative* = times-double-associative*.\n%abbrev nat`times-double-associative = times-double-associative.\n%abbrev nat`times-right-cancels = times-right-cancels.\n%abbrev nat`times-right-cancels* = times-right-cancels*.\n%abbrev nat`times-right-cancels** = times-right-cancels**.\n%abbrev nat`times-left-cancels = times-left-cancels.\n%abbrev nat`times-left-cancels* = times-left-cancels*.\n%abbrev nat`times-left-preserves-gt = times-left-preserves-gt.\n%abbrev nat`times-left-preserves-gt* = times-left-preserves-gt*.\n%abbrev nat`times-right-preserves-gt = times-right-preserves-gt.\n%abbrev nat`times-right-preserves-gt* = times-right-preserves-gt*.\n%abbrev nat`times-preserves-gt = times-preserves-gt.\n%abbrev nat`times-right-cancels-gt = times-right-cancels-gt.\n%abbrev nat`times-left-cancels-gt = times-left-cancels-gt.\n%abbrev nat`minus = minus.\n%abbrev nat`false-implies-minus = false-implies-minus.\n%abbrev nat`minus-respects-eq = minus-respects-eq.\n%abbrev nat`minus-deterministic = minus-deterministic.\n%abbrev nat`plus-associates-with-minus* = plus-associates-with-minus*.\n%abbrev nat`plus-associates-with-minus-converse* = plus-associates-with-minus-converse*.\n%abbrev nat`plus-associates-with-minus-converse = plus-associates-with-minus-converse.\n%abbrev nat`minus-associates-from-plus* = minus-associates-from-plus*.\n%abbrev nat`minus-associates-from-plus-converse* = minus-associates-from-plus-converse*.\n%abbrev nat`minus-associates-to-plus* = minus-associates-to-plus*.\n%abbrev nat`minus-associates-to-plus = minus-associates-to-plus.\n%abbrev nat`minus-associates-to-plus-converse* = minus-associates-to-plus-converse*.\n%abbrev nat`minus-associates-to-plus-converse = minus-associates-to-plus-converse.\n%abbrev nat`minus-is-zero-implies-eq = minus-is-zero-implies-eq.\n%abbrev nat`minus-implies-gt = minus-implies-gt.\n%abbrev nat`minus-left-cancels = minus-left-cancels.\n%abbrev nat`minus-right-cancels = minus-right-cancels.\n%abbrev nat`minus-left-inverts-gt* = minus-left-inverts-gt*.\n%abbrev nat`minus-right-preserves-gt* = minus-right-preserves-gt*.\n%abbrev nat`minus-left-cancels-inverts-gt = minus-left-cancels-inverts-gt.\n%abbrev nat`minus-right-cancels-gt = minus-right-cancels-gt.\n%abbrev nat`times-right-distributes-over-minus = times-right-distributes-over-minus.\n%abbrev nat`times-right-distributes-over-minus* = times-right-distributes-over-minus*.\n%abbrev nat`times-left-distributes-over-minus* = times-left-distributes-over-minus*.\n%abbrev nat`times-left-distributes-over-minus = times-left-distributes-over-minus.\n%abbrev nat`times-right-factors-over-minus* = times-right-factors-over-minus*.\n%abbrev nat`times-left-factors-over-minus* = times-left-factors-over-minus*.\n%abbrev nat`times-right-factors-over-minus = times-right-factors-over-minus.\n%abbrev nat`times-left-factors-over-minus = times-left-factors-over-minus.\n%abbrev nat`ge = ge.\n%abbrev nat`ge/= = ge/=.\n%abbrev nat`ge/> = ge/>.\n%abbrev nat`false-implies-ge = false-implies-ge.\n%abbrev nat`ge-respects-eq = ge-respects-eq.\n%abbrev nat`ge-reflexive = ge-reflexive.\n%abbrev nat`ge-transitive = ge-transitive.\n%abbrev nat`ge-anti-symmetric = ge-anti-symmetric.\n%abbrev nat`ge-transitive-gt = ge-transitive-gt.\n%abbrev nat`gt-transitive-ge = gt-transitive-ge.\n%abbrev nat`meta-ge = meta-ge.\n%abbrev nat`succ-preserves-ge = succ-preserves-ge.\n%abbrev nat`succ-preserves-ge-converse = succ-preserves-ge-converse.\n%abbrev nat`ge-succ-implies-gt = ge-succ-implies-gt.\n%abbrev nat`ge-implies-succ-gt = ge-implies-succ-gt.\n%abbrev nat`succ-gt-implies-ge = succ-gt-implies-ge.\n%abbrev nat`gt-implies-ge-succ = gt-implies-ge-succ.\n%abbrev nat`ge-implies-plus = ge-implies-plus.\n%abbrev nat`plus-implies-ge = plus-implies-ge.\n%abbrev nat`ge-zero-always = ge-zero-always.\n%abbrev nat`nonzero-times-implies-ge = nonzero-times-implies-ge.\n%abbrev nat`times-nonzero-implies-ge = times-nonzero-implies-ge.\n%abbrev nat`non-trivial-times-implies-much-gt* = non-trivial-times-implies-much-gt*.\n%abbrev nat`non-trivial-times-implies-much-gt = non-trivial-times-implies-much-gt.\n%abbrev nat`plus-left-preserves-ge* = plus-left-preserves-ge*.\n%abbrev nat`plus-left-cancels-ge = plus-left-cancels-ge.\n%abbrev nat`plus-left-preserves-ge = plus-left-preserves-ge.\n%abbrev nat`plus-right-preserves-ge* = plus-right-preserves-ge*.\n%abbrev nat`plus-right-preserves-ge = plus-right-preserves-ge.\n%abbrev nat`plus-preserves-ge* = plus-preserves-ge*.\n%abbrev nat`plus-preserves-ge = plus-preserves-ge.\n%abbrev nat`plus-right-cancels-ge = plus-right-cancels-ge.\n%abbrev nat`times-left-preserves-ge* = times-left-preserves-ge*.\n%abbrev nat`times-left-preserves-ge = times-left-preserves-ge.\n%abbrev nat`times-right-preserves-ge* = times-right-preserves-ge*.\n%abbrev nat`times-right-preserves-ge = times-right-preserves-ge.\n%abbrev nat`ne = ne.\n%abbrev nat`ne/< = ne/<.\n%abbrev nat`ne/> = ne/>.\n%abbrev nat`eq? = eq?.\n%abbrev nat`eq?/yes = eq?/yes.\n%abbrev nat`eq?/no = eq?/no.\n%abbrev nat`false-implies-ne = false-implies-ne.\n%abbrev nat`ne-respects-eq = ne-respects-eq.\n%abbrev nat`ne-anti-reflexive = ne-anti-reflexive.\n%abbrev nat`ne-symmetric = ne-symmetric.\n%abbrev nat`eq-ne-implies-false = eq-ne-implies-false.\n%abbrev nat`ge-ne-implies-gt = ge-ne-implies-gt.\n%abbrev nat`eq?-total* = eq?-total*.\n%abbrev nat`eq?-total*/L = eq?-total*/L.\n%abbrev nat`eq?-total = eq?-total.\n%abbrev nat`succ-preserves-ne = succ-preserves-ne.\n%abbrev nat`succ-preserves-ne-converse = succ-preserves-ne-converse.\n%abbrev nat`plus-left-preserves-ne* = plus-left-preserves-ne*.\n%abbrev nat`plus-left-cancels-ne = plus-left-cancels-ne.\n%abbrev nat`plus-left-preserves-ne = plus-left-preserves-ne.\n%abbrev nat`plus-right-preserves-ne* = plus-right-preserves-ne*.\n%abbrev nat`plus-right-preserves-ne = plus-right-preserves-ne.\n%abbrev nat`plus-right-cancels-ne = plus-right-cancels-ne.\n%abbrev nat`lt = lt.\n%abbrev nat`false-implies-lt = false-implies-lt.\n%abbrev nat`lt-respects-eq = lt-respects-eq.\n%abbrev nat`lt-anti-symmetric = lt-anti-symmetric.\n%abbrev nat`lt-transitive = lt-transitive.\n%abbrev nat`lt-anti-reflexive = lt-anti-reflexive.\n%abbrev nat`plus-left-preserves-lt* = plus-left-preserves-lt*.\n%abbrev nat`plus-left-cancels-lt = plus-left-cancels-lt.\n%abbrev nat`plus-left-preserves-lt = plus-left-preserves-lt.\n%abbrev nat`plus-right-preserves-lt* = plus-right-preserves-lt*.\n%abbrev nat`plus-right-preserves-lt = plus-right-preserves-lt.\n%abbrev nat`plus-preserves-lt* = plus-preserves-lt*.\n%abbrev nat`plus-preserves-lt = plus-preserves-lt.\n%abbrev nat`plus-right-cancels-lt = plus-right-cancels-lt.\n%abbrev nat`le = le.\n%abbrev nat`false-implies-le = false-implies-le.\n%abbrev nat`le-respects-eq = le-respects-eq.\n%abbrev nat`le-anti-symmetric = le-anti-symmetric.\n%abbrev nat`le-transitive = le-transitive.\n%abbrev nat`le-reflexive = le-reflexive.\n%abbrev nat`le-transitive-lt = le-transitive-lt.\n%abbrev nat`lt-transitive-le = lt-transitive-le.\n%abbrev nat`plus-left-preserves-le* = plus-left-preserves-le*.\n%abbrev nat`plus-left-cancels-le = plus-left-cancels-le.\n%abbrev nat`plus-left-preserves-le = plus-left-preserves-le.\n%abbrev nat`plus-right-preserves-le* = plus-right-preserves-le*.\n%abbrev nat`plus-right-preserves-le = plus-right-preserves-le.\n%abbrev nat`plus-preserves-le* = plus-preserves-le*.\n%abbrev nat`plus-preserves-le = plus-preserves-le.\n%abbrev nat`plus-right-cancels-le = plus-right-cancels-le.\n%abbrev nat`times-left-preserves-le* = times-left-preserves-le*.\n%abbrev nat`times-left-preserves-le = times-left-preserves-le.\n%abbrev nat`times-right-preserves-le* = times-right-preserves-le*.\n%abbrev nat`times-right-preserves-le = times-right-preserves-le.\n%abbrev nat`times-preserves-le* = times-preserves-le*.\n%abbrev nat`times-preserves-le = times-preserves-le.\n%abbrev nat`minus-left-inverts-ge* = minus-left-inverts-ge*.\n%abbrev nat`minus-right-preserves-ge* = minus-right-preserves-ge*.\n%abbrev nat`minus-left-cancels-inverts-ge = minus-left-cancels-inverts-ge.\n%abbrev nat`minus-right-cancels-ge = minus-right-cancels-ge.\n%abbrev nat`minus-left-preserves-ne* = minus-left-preserves-ne*.\n%abbrev nat`minus-right-preserves-ne* = minus-right-preserves-ne*.\n%abbrev nat`minus-left-cancels-ne = minus-left-cancels-ne.\n%abbrev nat`minus-right-cancels-ne = minus-right-cancels-ne.\n%abbrev nat`minus-left-inverts-lt* = minus-left-inverts-lt*.\n%abbrev nat`minus-right-preserves-lt* = minus-right-preserves-lt*.\n%abbrev nat`minus-left-cancels-inverts-lt = minus-left-cancels-inverts-lt.\n%abbrev nat`minus-right-cancels-lt = minus-right-cancels-lt.\n%abbrev nat`minus-left-inverts-le* = minus-left-inverts-le*.\n%abbrev nat`minus-right-preserves-le* = minus-right-preserves-le*.\n%abbrev nat`minus-left-cancels-inverts-le = minus-left-cancels-inverts-le.\n%abbrev nat`minus-right-cancels-le = minus-right-cancels-le.\n%abbrev nat`divrem = divrem.\n%abbrev nat`divrem/z = divrem/z.\n%abbrev nat`divrem/s = divrem/s.\n%abbrev nat`false-implies-divrem = false-implies-divrem.\n%abbrev nat`divrem-respects-eq = divrem-respects-eq.\n%abbrev nat`divrem-total** = divrem-total**.\n%abbrev nat`divrem-total* = divrem-total*.\n%abbrev nat`divrem-total = divrem-total.\n%abbrev nat`divrem-deterministic = divrem-deterministic.\n%abbrev nat`divrem-implies-positive = divrem-implies-positive.\n%abbrev nat`divrem-implies-gt = divrem-implies-gt.\n%abbrev nat`divrem-contradiction = divrem-contradiction.\n%abbrev nat`divrem-can-be-inverted = divrem-can-be-inverted.\n%abbrev nat`div-can-be-inverted = div-can-be-inverted.\n%abbrev nat`divrem-can-be-constructed = divrem-can-be-constructed.\n%abbrev nat`div-can-be-constructed = div-can-be-constructed.\n%abbrev nat`remainder-implies-gt-quotient = remainder-implies-gt-quotient.\n%abbrev nat`quotient-of-nonzero-is-smaller = quotient-of-nonzero-is-smaller.\n%abbrev nat`quotient-is-no-greater = quotient-is-no-greater.\n%abbrev nat`min = min.\n%abbrev nat`min/= = min/=.\n%abbrev nat`min/> = min/>.\n%abbrev nat`min/< = min/<.\n%abbrev nat`max = max.\n%abbrev nat`max/= = max/=.\n%abbrev nat`max/> = max/>.\n%abbrev nat`max/< = max/<.\n%abbrev nat`false-implies-min = false-implies-min.\n%abbrev nat`min-respects-eq = min-respects-eq.\n%abbrev nat`min-total** = min-total**.\n%abbrev nat`min-total* = min-total*.\n%abbrev nat`min-total = min-total.\n%abbrev nat`min-deterministic = min-deterministic.\n%abbrev nat`min-commutative = min-commutative.\n%abbrev nat`ge-implies-min = ge-implies-min.\n%abbrev nat`le-implies-min = le-implies-min.\n%abbrev nat`min-implies-ge = min-implies-ge.\n%abbrev nat`min-left-preserves-ge* = min-left-preserves-ge*.\n%abbrev nat`min-left-preserves-le* = min-left-preserves-le*.\n%abbrev nat`min-left-preserves-ge = min-left-preserves-ge.\n%abbrev nat`min-right-preserves-ge* = min-right-preserves-ge*.\n%abbrev nat`min-right-preserves-ge = min-right-preserves-ge.\n%abbrev nat`min-preserves-ge* = min-preserves-ge*.\n%abbrev nat`min-preserves-ge = min-preserves-ge.\n%abbrev nat`min-left-preserves-le = min-left-preserves-le.\n%abbrev nat`min-right-preserves-le* = min-right-preserves-le*.\n%abbrev nat`min-right-preserves-le = min-right-preserves-le.\n%abbrev nat`min-preserves-le* = min-preserves-le*.\n%abbrev nat`min-preserves-le = min-preserves-le.\n%abbrev nat`min-is-glb = min-is-glb.\n%abbrev nat`min-associative = min-associative.\n%abbrev nat`min-associative* = min-associative*.\n%abbrev nat`min-associative-converse = min-associative-converse.\n%abbrev nat`min-associative-converse* = min-associative-converse*.\n%abbrev nat`min-assoc-commutative* = min-assoc-commutative*.\n%abbrev nat`min-assoc-commutative = min-assoc-commutative.\n%abbrev nat`min-double-associative* = min-double-associative*.\n%abbrev nat`min-double-associative = min-double-associative.\n%abbrev nat`false-implies-max = false-implies-max.\n%abbrev nat`max-respects-eq = max-respects-eq.\n%abbrev nat`max-total** = max-total**.\n%abbrev nat`max-total* = max-total*.\n%abbrev nat`max-total = max-total.\n%abbrev nat`max-deterministic = max-deterministic.\n%abbrev nat`max-commutative = max-commutative.\n%abbrev nat`ge-implies-max = ge-implies-max.\n%abbrev nat`le-implies-max = le-implies-max.\n%abbrev nat`max-implies-ge = max-implies-ge.\n%abbrev nat`max-is-lub = max-is-lub.\n%abbrev nat`max-left-preserves-ge* = max-left-preserves-ge*.\n%abbrev nat`max-left-preserves-le* = max-left-preserves-le*.\n%abbrev nat`max-left-preserves-ge = max-left-preserves-ge.\n%abbrev nat`max-right-preserves-ge* = max-right-preserves-ge*.\n%abbrev nat`max-right-preserves-ge = max-right-preserves-ge.\n%abbrev nat`max-preserves-ge* = max-preserves-ge*.\n%abbrev nat`max-preserves-ge = max-preserves-ge.\n%abbrev nat`max-left-preserves-le = max-left-preserves-le.\n%abbrev nat`max-right-preserves-le* = max-right-preserves-le*.\n%abbrev nat`max-right-preserves-le = max-right-preserves-le.\n%abbrev nat`max-preserves-le* = max-preserves-le*.\n%abbrev nat`max-preserves-le = max-preserves-le.\n%abbrev nat`max-associative = max-associative.\n%abbrev nat`max-associative* = max-associative*.\n%abbrev nat`max-associative-converse = max-associative-converse.\n%abbrev nat`max-associative-converse* = max-associative-converse*.\n%abbrev nat`max-assoc-commutative* = max-assoc-commutative*.\n%abbrev nat`max-assoc-commutative = max-assoc-commutative.\n%abbrev nat`max-double-associative* = max-double-associative*.\n%abbrev nat`max-double-associative = max-double-associative.\n%abbrev nat`min-right-distributes-over-max = min-right-distributes-over-max.\n%abbrev nat`max-right-distributes-over-min = max-right-distributes-over-min.\n%abbrev nat`min-right-distributes-over-max* = min-right-distributes-over-max*.\n%abbrev nat`min-left-distributes-over-max* = min-left-distributes-over-max*.\n%abbrev nat`min-left-distributes-over-max = min-left-distributes-over-max.\n%abbrev nat`min-right-factors-over-max = min-right-factors-over-max.\n%abbrev nat`min-right-factors-over-max* = min-right-factors-over-max*.\n%abbrev nat`min-left-factors-over-max = min-left-factors-over-max.\n%abbrev nat`min-left-factors-over-max* = min-left-factors-over-max*.\n%abbrev nat`max-right-distributes-over-min* = max-right-distributes-over-min*.\n%abbrev nat`max-left-distributes-over-min* = max-left-distributes-over-min*.\n%abbrev nat`max-left-distributes-over-min = max-left-distributes-over-min.\n%abbrev nat`max-right-factors-over-min = max-right-factors-over-min.\n%abbrev nat`max-right-factors-over-min* = max-right-factors-over-min*.\n%abbrev nat`max-left-factors-over-min = max-left-factors-over-min.\n%abbrev nat`max-left-factors-over-min* = max-left-factors-over-min*.\n\n%%%%% natpair.elf\n%%%%% Pairs of natural numbers\n%%%%% John Boyland\n\n\n% Pairs of natural numbers are mapped one-to-one to the natural numbers.\n% We use the binary merging technique, e.g.:\n%   (x3x2x1x0,y3y2y1y0) <-> x3y3x2y2x1y1x0y0\n\n\n\n%%%% Functor use\n\n\n\n\n%%%%% pair.elf\n%%%%% a pseudo-functor\n%%%%% John Boyland\n\n% We require the following definitions:\n%  nat : equality type.\n%  nat : equality type.\n% The result is an equality type too.\n\n\n\n\n%%%% Definitions\n\n\n\npair : type.\n\npair/ : nat -> nat -> pair.\n\n\neq : pair -> pair -> type.\n\neq/ : eq P P.\n\n\nne : pair -> pair -> type.\n\nne/1 : ne (pair/ X1 Y1) (pair/ X2 Y2)\n    <- nat`ne X1 X2.\n\nne/2 : ne (pair/ X1 Y1) (pair/ X2 Y2)\n    <- nat`ne Y1 Y2.\n\n\neq? : pair -> pair -> bool -> type.\n\neq?/yes : eq? P P true.\n\neq?/no : eq? P1 P2 false\n    <- ne P1 P2.\n\n\n\n%%%% Theorems\n\n\n\n%%% theorems about eq\n\n\n%theorem false-implies-eq :\n\tforall* {X1} {X2}\n\tforall {F:void}\n\texists {E:eq X1 X2}\n\ttrue.\n\n%worlds () (false-implies-eq _ _).\n%total { } (false-implies-eq _ _).\n\n\n%theorem meta-eq :\n\tforall {X1} {X2} {E:eq X1 X2}\n\ttrue.\n\n- : meta-eq _ _ eq/.\n\n%worlds () (meta-eq _ _ _).\n%total { } (meta-eq _ _ _).\n%reduces X = Y (meta-eq X Y _).\n\n\t\n%theorem eq-reflexive : \n\tforall {X} \n\texists {E:eq X X} \n\ttrue.\n\n- : eq-reflexive _ eq/.\n\n%worlds () (eq-reflexive _ _).\n%total { } (eq-reflexive _ _).\n\n\n%theorem eq-symmetric : \n\tforall* {X} {Y}\n\tforall {E:eq X Y}\n\texists {F:eq Y X}\n\ttrue.\n\n- : eq-symmetric (eq/) (eq/).\n\n%worlds () (eq-symmetric _ _).\n%total { } (eq-symmetric _ _).\n\n\n%theorem eq-transitive : \n\tforall* {X} {Y} {Z}\n\tforall {E1:eq X Y} {E2:eq Y Z}\n\texists {F:eq X Z}\n\ttrue.\n\n- : eq-transitive (eq/) (eq/) (eq/).\n\n%worlds () (eq-transitive _ _ _).\n%total { } (eq-transitive _ _ _).\n\n\n%theorem pair-eq-implies-eq :\n\tforall* {D1a} {D1b} {D2a} {D2b}\n        forall {E:eq (pair/ D1a D2a) (pair/ D1b D2b)}\n\texists {E1:nat`eq D1a D1b}\n               {E2:nat`eq D2a D2b}\n\ttrue.\n\n- : pair-eq-implies-eq eq/ nat`eq/ nat`eq/.\n\n%worlds () (pair-eq-implies-eq _ _ _).\n%total { } (pair-eq-implies-eq _ _ _).\n\n\n%theorem pair-preserves-eq :\n\tforall* {D1a} {D1b} {D2a} {D2b}\n\tforall {E1:nat`eq D1a D1b}\n               {E2:nat`eq D2a D2b}\n        exists {E:eq (pair/ D1a D2a) (pair/ D1b D2b)}\n\ttrue.\n\n- : pair-preserves-eq nat`eq/ nat`eq/ eq/.\n\n%worlds () (pair-preserves-eq _ _ _).\n%total { } (pair-preserves-eq _ _ _).\n\n\n%%% theorems about ne\n\n\n%theorem false-implies-ne :\n\tforall* {X1} {X2}\n\tforall {F:void}\n\texists {G:ne X1 X2}\n\ttrue.\n\n%worlds () (false-implies-ne _ _).\n%total { } (false-implies-ne _ _).\n\n\n%theorem ne-respects-eq :\n\tforall* {X1} {X2} {Y1} {Y2}\n\tforall {D1:ne X1 X2} {E1:eq X1 Y1} {E2:eq X2 Y2}\n\texists {D2:ne Y1 Y2}\n\ttrue.\n\n- : ne-respects-eq X1<>X2 eq/ eq/ X1<>X2.\n\n%worlds () (ne-respects-eq _ _ _ _).\n%total { } (ne-respects-eq _ _ _ _).\n\n\n%theorem ne-anti-reflexive :\n\tforall* {P}\n\tforall {R:ne P P}\n\texists {F:void}\n\ttrue.\n\n- : ne-anti-reflexive (ne/1 X<>X) F\n    <- nat`ne-anti-reflexive X<>X F.\n\n- : ne-anti-reflexive (ne/2 Y<>Y) F\n    <- nat`ne-anti-reflexive Y<>Y F.\n\n%worlds () (ne-anti-reflexive _ _).\n%total { } (ne-anti-reflexive _ _).\n\n\n%theorem ne-symmetric :\n\tforall* {P1} {P2}\n\tforall {R1:ne P1 P2}\n\texists {R2:ne P2 P1}\n\ttrue.\n\n- : ne-symmetric (ne/1 X1<>X2) (ne/1 X2<>X1)\n    <- nat`ne-symmetric X1<>X2 X2<>X1.\n\n- : ne-symmetric (ne/2 Y1<>Y2) (ne/2 Y2<>Y1)\n    <- nat`ne-symmetric Y1<>Y2 Y2<>Y1.\n\n\n%worlds () (ne-symmetric _ _).\n%total { } (ne-symmetric _ _).\n\n\n%theorem eq-ne-implies-false :\n\tforall* {P1} {P2}\n\tforall {D1:eq P1 P2} {D2:ne P1 P2}\n\texists {F:void}\n\ttrue.\n\n- : eq-ne-implies-false eq/ X<>X F\n    <- ne-anti-reflexive X<>X F.\n\n%worlds () (eq-ne-implies-false _ _ _).\n%total { } (eq-ne-implies-false _ _ _).\n\n\n\n%%% theorems about eq?\n\n\n%theorem eq?-total* :\n\tforall {P1} {P2}\n\texists {B} {T:eq? P1 P2 B}\n\ttrue.\n\n%theorem eq?-total*/L :\n\tforall* {X1} {Y1} {X2} {Y2} {B1} {B2}\n\tforall {T1:nat`eq? X1 Y1 B1} {T2:nat`eq? X2 Y2 B2}\n\texists {B} {T:eq? (pair/ X1 X2) (pair/ Y1 Y2) B}\n\ttrue.\n\n- : eq?-total*/L (nat`eq?/yes) (nat`eq?/yes) _ (eq?/yes).\n\n- : eq?-total*/L (nat`eq?/no X1<>Y1) _ _ (eq?/no (ne/1 X1<>Y1)).\n\n- : eq?-total*/L _ (nat`eq?/no X2<>Y2) _ (eq?/no (ne/2 X2<>Y2)).\n\n%worlds () (eq?-total*/L _ _ _ _).\n%total { } (eq?-total*/L _ _ _ _).\n\n- : eq?-total* _ _ _ T\n    <- nat`eq?-total E?1\n    <- nat`eq?-total E?2\n    <- eq?-total*/L E?1 E?2 _ T.\n\n%worlds () (eq?-total* _ _ _ _).\n%total { } (eq?-total* _ _ _ _).\n\n\n%abbrev eq?-total = eq?-total* _ _ _.\n\n\n\n\n\n\n%%%% Definitions\n\n\n\n%%% local abbreviations:\n\n %abbrev ssN>N = (gt/> gt/1).\n %abbrev 2>0 : gt (s (s z)) z = ssN>N.\n %abbrev 1*N=N = (times/s times/z plus/z).\n %abbrev 1*2=2 : times (s z) (s (s z)) (s (s z)) = 1*N=N.\n %abbrev 2*2=4 = (times/s 1*N=N (plus/s (plus/s plus/z))).\n %abbrev 2+1=3 : plus (s (s z)) (s z) (s (s (s z))) = (plus/s (plus/s plus/z)).\n\n\n%%% mapping from a pair to a nat\n\n\npair2nat : pair -> nat -> type.\n\n\npair2nat/00 : pair2nat (pair/ z z) z.\n\npair2nat/XX : \n\tplus Z3 Y0 Z ->\n        plus Z2 X2 Z3 ->\n        times X0 (s (s z)) X2 ->\n        times Z1 (s (s (s (s z)))) Z2 ->\n\tpair2nat (pair/ X1 Y1) Z1 ->\n        divrem Y (s (s z)) Y1 Y0 ->\n\tdivrem X (s (s z)) X1 X0 ->\n    pair2nat (pair/ X Y) Z.\n\n\n\n%%% mapping from a nat to pair\n\n\n%abbrev \nnat2pair : nat -> pair -> type = [N] [P] pair2nat P N.\n\n\n\n%%%% Theorems\n\n\n%theorem false-implies-pair2nat :\n\tforall* {P} {N}\n\tforall {F:void}\n\texists {P2N:pair2nat P N}\n\ttrue.\n\n%worlds () (false-implies-pair2nat _ _).\n%total { } (false-implies-pair2nat _ _).\n\n\n%abbrev false-implies-not2pair = false-implies-pair2nat.\n\n\n%theorem pair2nat-respects-eq :\n\tforall* {P1} {N1} {P2} {N2}\n\tforall {D1:pair2nat P1 N1} {EP:eq P1 P2} {EN:nat`eq N1 N2}\n\texists {D2:pair2nat P2 N2}\n\ttrue.\n\n- : pair2nat-respects-eq P2N eq/ nat`eq/ P2N.\n\n%worlds () (pair2nat-respects-eq _ _ _ _).\n%total { } (pair2nat-respects-eq _ _ _ _).\n%reduces D1 = D2 (pair2nat-respects-eq D1 _ _ D2).\n\n%abbrev nat2pair-respects-eq :\n\t  (nat2pair N1 P1) -> (nat`eq N1 N2) -> (eq P1 P2) -> (nat2pair N2 P2)\n        -> type\n\t= [D1] [EN] [EP] [D2] pair2nat-respects-eq D1 EP EN D2.\n\n\n%theorem pair2nat-total** :\n\tforall {X:nat} {Y:nat}\n\texists {Z} {P2N:pair2nat (pair/ X Y) Z}\n\ttrue.\n\n- : pair2nat-total** z z z pair2nat/00.\n\n- : pair2nat-total** (s X-) Y Z \n\t(pair2nat/XX Z3+Y0=Z Z2+X2=Z3 X0*2=X2 Z1*4=Z2 \n                     (P2N:pair2nat (pair/ X1 Y1) Z1) Y/2=Y1,Y0 X/2=X1,X0)\n    <- divrem-total X/2=X1,X0\n    <- divrem-total Y/2=Y1,Y0\n    <- quotient-of-nonzero-is-smaller X/2=X1,X0 nat`eq/ X>X1\n    <- quotient-is-no-greater Y/2=Y1,Y0 Y>=Y1\n    <- meta-gt _ _ X>X1\n    <- meta-ge _ _ Y>=Y1\n    <- pair2nat-total** _ _ _ P2N\n    <- times-total Z1*4=Z2\n    <- times-total X0*2=X2\n    <- plus-total Z2+X2=Z3\n    <- plus-total Z3+Y0=Z.\n\n- : pair2nat-total** X (s Y-) Z \n\t(pair2nat/XX Z3+Y0=Z Z2+X2=Z3 X0*2=X2 Z1*4=Z2 \n                     (P2N:pair2nat (pair/ X1 Y1) Z1) Y/2=Y1,Y0 X/2=X1,X0)\n    <- divrem-total X/2=X1,X0\n    <- divrem-total Y/2=Y1,Y0\n    <- quotient-is-no-greater X/2=X1,X0 X>=X1\n    <- quotient-of-nonzero-is-smaller Y/2=Y1,Y0 nat`eq/ Y>Y1\n    <- meta-ge _ _ X>=X1\n    <- meta-gt _ _ Y>Y1\n    <- pair2nat-total** _ _ _ P2N\n    <- times-total Z1*4=Z2\n    <- times-total X0*2=X2\n    <- plus-total Z2+X2=Z3\n    <- plus-total Z3+Y0=Z.\n\n%worlds () (pair2nat-total** _ _ _ _).\n%total [X Y] (pair2nat-total** X Y _ _).\n\n%theorem pair2nat-total* :\n\tforall {P:pair}\n\texists {N:nat} {P2N:pair2nat P N}\n\ttrue.\n\n- : pair2nat-total* (pair/ X Y) Z P2N\n    <- pair2nat-total** X Y Z P2N.\n\n%worlds () (pair2nat-total* _ _ _).\n%total { } (pair2nat-total* _ _ _).\n\n\n%abbrev pair2nat-total = pair2nat-total* _ _.\n\n\n%theorem nat2pair-total* :\n\tforall {N:nat}\n\texists {P:pair} {N2P:nat2pair N P}\n\ttrue.\n\n- : nat2pair-total* z (pair/ z z) (pair2nat/00).\n\n- : nat2pair-total* (s Z-) (pair/ X Y)\n\t(pair2nat/XX Z3+Y0=Z Z2+X2=Z3 X0*2=X2 Z1*4=Z2 \n                     (P2N:pair2nat (pair/ X1 Y1) Z1) Y/2=Y1,Y0 X/2=X1,X0)\n    <- divrem-total Z/4=Z1,R\n    <- divrem-implies-gt Z/4=Z1,R FOUR>R\n    <- divrem-can-be-inverted Z/4=Z1,R Z2 Z1*4=Z2 Z2+R=Z\n    <- divrem-total R/2=X0,Y0\n    <- divrem-implies-gt R/2=X0,Y0 TWO>Y0\n    <- divrem-can-be-inverted R/2=X0,Y0 X2 X0*2=X2 X2+Y0=R\n    <- plus-associative-converse X2+Y0=R Z2+R=Z Z3 Z2+X2=Z3 Z3+Y0=Z\n    % now we need to get 2>X0\n    <- plus-commutative X2+Y0=R Y0+X2=R\n    <- plus-implies-ge Y0+X2=R R>=X2\n    <- gt-transitive-ge FOUR>R R>=X2 FOUR>X2\n    <- times-right-cancels-gt 2*2=4 X0*2=X2 nat`eq/ FOUR>X2 TWO>X0\n    % now we need to prove Z>Z1 (for termination)\n    <- quotient-of-nonzero-is-smaller Z/4=Z1,R nat`eq/ Z>Z1\n    <- meta-gt _ _ Z>Z1\n    <- nat2pair-total* Z1 (pair/ X1 Y1) P2N\n    <- times-total X1*2=XE\n    <- times-total Y1*2=YE\n    <- plus-total XE+X0=X\n    <- plus-total YE+Y0=Y\n    <- divrem-can-be-constructed X1*2=XE XE+X0=X TWO>X0 X/2=X1,X0\n    <- divrem-can-be-constructed Y1*2=YE YE+Y0=Y TWO>Y0 Y/2=Y1,Y0.\n\n%worlds () (nat2pair-total* _ _ _).\n%total (Z) (nat2pair-total* Z _ _).\n% %reduces X <= N (nat2pair-total* N (pair/ X _) _).\n% %reduces Y <= N (pair2nat-total* N (pair/ _ Y) _).\n\n\n%abbrev nat2pair-total = nat2pair-total* _ _.\n\n\n%theorem pair2nat-deterministic :\n\tforall* {P1} {P2} {N1} {N2}\n\tforall {D1:pair2nat P1 N1} {D2:pair2nat P2 N2}\n\t       {EP:eq P1 P2}\n\texists {EN:nat`eq N1 N2}\n\ttrue.\n\n- : pair2nat-deterministic pair2nat/00 pair2nat/00 eq/ nat`eq/.\n\n% lemma\n%theorem pair2nat-deterministic/00 :\n\tforall* {Z}\n\tforall {P2N:pair2nat (pair/ z z) Z}\n\texists {E:nat`eq Z z}\n\ttrue.\n\n- : pair2nat-deterministic/00 pair2nat/00 nat`eq/.\n\n- : pair2nat-deterministic/00\n\t(pair2nat/XX Z3+Y0=Z Z2+X2=Z3 X0*2=X2 Z1*4=Z2 \n                     (P2N:pair2nat (pair/ X1 Y1) Z1) ZERO/2=Y1,Y0 ZERO/2=X1,X0)\n        Z=0\n    <- divrem-deterministic ZERO/2=X1,X0 (divrem/z 2>0) nat`eq/ nat`eq/\n                            X1=0 X0=0\n    <- divrem-deterministic ZERO/2=Y1,Y0 (divrem/z 2>0) nat`eq/ nat`eq/\n                            Y1=0 Y0=0\n    <- pair-preserves-eq X1=0 Y1=0 X1,Y1=0,0\n    <- pair2nat-respects-eq P2N X1,Y1=0,0 nat`eq/ ZERO,ZERO->Z1\n    <- pair2nat-deterministic/00 ZERO,ZERO->Z1 Z1=0\n    <- times-deterministic Z1*4=Z2 times/z Z1=0 nat`eq/ Z2=0\n    <- times-deterministic X0*2=X2 times/z X0=0 nat`eq/ X2=0\n    <- plus-deterministic Z2+X2=Z3 plus/z Z2=0 X2=0 Z3=0\n    <- plus-deterministic Z3+Y0=Z plus/z Z3=0 Y0=0 Z=0.\n\n%worlds () (pair2nat-deterministic/00 _ _).\n%total (D) (pair2nat-deterministic/00 D _).\n\n- : pair2nat-deterministic pair2nat/00 P2N eq/ ZERO=Z\n    <- pair2nat-deterministic/00 P2N Z=0\n    <- nat`eq-symmetric Z=0 ZERO=Z.\n\n- : pair2nat-deterministic P2N pair2nat/00 eq/ Z=0\n    <- pair2nat-deterministic/00 P2N Z=0.\n\n- : pair2nat-deterministic\n\t(pair2nat/XX Z3+Y0=Z Z2+X2=Z3 X0*2=X2 Z1*4=Z2 \n                     (P2N:pair2nat (pair/ X1 Y1) Z1) Y/2=Y1,Y0 X/2=X1,X0)\n\t(pair2nat/XX Z3'+Y0'=Z' Z2'+X2'=Z3' X0'*2=X2' Z1'*4=Z2' \n                     (P2N':pair2nat (pair/ X1' Y1')Z1') Y/2=Y1',Y0' X/2=X1',X0')\n        eq/ Z=Z'\n    <- divrem-deterministic X/2=X1,X0 X/2=X1',X0' nat`eq/ nat`eq/ X1=X1' X0=X0'\n    <- divrem-deterministic Y/2=Y1,Y0 Y/2=Y1',Y0' nat`eq/ nat`eq/ Y1=Y1' Y0=Y0'\n    <- pair-preserves-eq X1=X1' Y1=Y1' X1,Y1=X1',Y1'\n    <- pair2nat-deterministic P2N P2N' X1,Y1=X1',Y1' Z1=Z1'\n    <- times-deterministic Z1*4=Z2 Z1'*4=Z2' Z1=Z1' nat`eq/ Z2=Z2'\n    <- times-deterministic X0*2=X2 X0'*2=X2' X0=X0' nat`eq/ X2=X2'\n    <- plus-deterministic Z2+X2=Z3 Z2'+X2'=Z3' Z2=Z2' X2=X2' Z3=Z3'\n    <- plus-deterministic Z3+Y0=Z Z3'+Y0'=Z' Z3=Z3' Y0=Y0' Z=Z'.\n\n%worlds () (pair2nat-deterministic _ _ _ _).\n%total (D) (pair2nat-deterministic D _ _ _).\n\n\n%theorem nat2pair-deterministic :\n\tforall* {P1} {P2} {N1} {N2}\n\tforall {D1:nat2pair N1 P1} {D2:nat2pair N2 P2}\t{EN:nat`eq N1 N2}\n\texists {EP:eq P1 P2}\n\ttrue.\n\n% lemma\n%theorem nat2pair-deterministic/0 :\n\tforall* {P}\n\tforall {D:nat2pair z P}\n\texists {EP:eq P (pair/ z z)}\n\ttrue.\n\n- : nat2pair-deterministic/0 pair2nat/00 eq/.\n\n- : nat2pair-deterministic/0 \n\t(pair2nat/XX Z3+Y0=0 Z2+X2=Z3 X0*2=X2 Z1*4=Z2 \n                     (P2N:pair2nat (pair/ X1 Y1) Z1) Y/2=Y1,Y0 X/2=X1,X0)\n\tX,Y=0,0\n    <- plus-is-zero-implies-zero Z3+Y0=0 nat`eq/ Z3=0 Y0=0\n    <- plus-is-zero-implies-zero Z2+X2=Z3 Z3=0 Z2=0 X2=0\n    <- times-right-cancels X0*2=X2 times/z nat`eq/ X2=0 X0=0\n    <- times-right-cancels Z1*4=Z2 times/z nat`eq/ Z2=0 Z1=0\n    <- nat2pair-respects-eq P2N Z1=0 eq/ N2P\n    <- nat2pair-deterministic/0 N2P X1,Y1=0,0\n    <- pair-eq-implies-eq X1,Y1=0,0 X1=0 Y1=0\n    <- divrem-can-be-inverted X/2=X1,X0 XM X1*2=XM XM+X0=X\n    <- divrem-can-be-inverted Y/2=Y1,Y0 YM Y1*2=YM YM+Y0=Y\n    <- times-deterministic X1*2=XM times/z X1=0 nat`eq/ XM=0\n    <- times-deterministic Y1*2=YM times/z Y1=0 nat`eq/ YM=0\n    <- plus-deterministic XM+X0=X plus/z XM=0 X0=0 X=0\n    <- plus-deterministic YM+Y0=Y plus/z YM=0 Y0=0 Y=0\n    <- pair-preserves-eq X=0 Y=0 X,Y=0,0.\n\n%worlds () (nat2pair-deterministic/0 _ _).\n%total (D) (nat2pair-deterministic/0 D _).\n\n- : nat2pair-deterministic N2P N2P' nat`eq/ X,Y=X',Y'\n    <- nat2pair-deterministic/0 N2P X,Y=0,0\n    <- nat2pair-deterministic/0 N2P' X',Y'=0,0\n    <- eq-symmetric X',Y'=0,0 ZERO,ZERO=X',Y'\n    <- eq-transitive X,Y=0,0 ZERO,ZERO=X',Y' X,Y=X',Y'.\n\n- : nat2pair-deterministic\n\t(pair2nat/XX Z3+Y0=Z Z2+X2=Z3 X0*2=X2 Z1*4=Z2 \n                     (P2N:pair2nat (pair/ X1 Y1) Z1) Y/2=Y1,Y0 X/2=X1,X0)\n\t(pair2nat/XX Z3'+Y0'=Z Z2'+X2'=Z3' X0'*2=X2' Z1'*4=Z2' \n                     (P2N':pair2nat (pair/ X1' Y1') Z1') \n                     Y'/2=Y1',Y0' X'/2=X1',X0')\n        nat`eq/ X,Y=X',Y'\n    <- plus-associative Z2+X2=Z3 Z3+Y0=Z R X2+Y0=R Z2+R=Z\n    <- divrem-implies-gt X/2=X1,X0 TWO>X0\n    <- divrem-implies-gt Y/2=Y1,Y0 TWO>Y0\n    <- succ-gt-implies-ge TWO>X0 ONE>=X0\n    <- succ-gt-implies-ge TWO>Y0 ONE>=Y0\n    <- times-right-preserves-ge* ONE>=X0 1*2=2 X0*2=X2 TWO>=X2\n    <- plus-preserves-ge* TWO>=X2 ONE>=Y0 2+1=3 X2+Y0=R THREE>=R\n    <- ge-implies-succ-gt THREE>=R FOUR>R\n    <- divrem-can-be-constructed Z1*4=Z2 Z2+R=Z FOUR>R Z/4=Z1,R\n    <- plus-associative Z2'+X2'=Z3' Z3'+Y0'=Z R' X2'+Y0'=R' Z2'+R'=Z\n    <- divrem-implies-gt X'/2=X1',X0' TWO>X0'\n    <- divrem-implies-gt Y'/2=Y1',Y0' TWO>Y0'\n    <- succ-gt-implies-ge TWO>X0' ONE>=X0'\n    <- succ-gt-implies-ge TWO>Y0' ONE>=Y0'\n    <- times-right-preserves-ge* ONE>=X0' 1*2=2 X0'*2=X2' TWO>=X2'\n    <- plus-preserves-ge* TWO>=X2' ONE>=Y0' 2+1=3 X2'+Y0'=R' THREE>=R'\n    <- ge-implies-succ-gt THREE>=R' FOUR>R'\n    <- divrem-can-be-constructed Z1'*4=Z2' Z2'+R'=Z FOUR>R' Z/4=Z1',R'\n    <- divrem-deterministic Z/4=Z1,R Z/4=Z1',R' nat`eq/ nat`eq/ Z1=Z1' R=R'\n    <- divrem-can-be-constructed X0*2=X2 X2+Y0=R TWO>Y0 R/2=X0,Y0\n    <- divrem-can-be-constructed X0'*2=X2' X2'+Y0'=R' TWO>Y0' R'/2=X0',Y0'\n    <- divrem-deterministic R/2=X0,Y0 R'/2=X0',Y0' R=R' nat`eq/ X0=X0' Y0=Y0'\n    <- nat2pair-deterministic P2N P2N' Z1=Z1' X1,Y1=X1',Y1'\n    <- pair-eq-implies-eq X1,Y1=X1',Y1' X1=X1' Y1=Y1'\n    <- divrem-can-be-inverted X/2=X1,X0 XM X1*2=XM XM+X0=X\n    <- divrem-can-be-inverted Y/2=Y1,Y0 YM Y1*2=YM YM+Y0=Y\n    <- divrem-can-be-inverted X'/2=X1',X0' XM' X1'*2=XM' XM'+X0'=X'\n    <- divrem-can-be-inverted Y'/2=Y1',Y0' YM' Y1'*2=YM' YM'+Y0'=Y'\n    <- times-deterministic X1*2=XM X1'*2=XM' X1=X1' nat`eq/ XM=XM'\n    <- plus-deterministic XM+X0=X XM'+X0'=X' XM=XM' X0=X0' X=X'\n    <- times-deterministic Y1*2=YM Y1'*2=YM' Y1=Y1' nat`eq/ YM=YM'\n    <- plus-deterministic YM+Y0=Y YM'+Y0'=Y' YM=YM' Y0=Y0' Y=Y'\n    <- pair-preserves-eq X=X' Y=Y' X,Y=X',Y'.\n\n%worlds () (nat2pair-deterministic _ _ _ _).\n%total (D) (nat2pair-deterministic D _ _ _).\n\n\n%theorem pair2nat-preserves-ne* :\n\tforall* {P1} {P2} {N1} {N2}\n\tforall {PNE: ne P1 P2} {T1:pair2nat P1 N1} {T2:pair2nat P2 N2}\n\texists {NE: nat`ne N1 N2}\n\ttrue.\n\n%theorem pair2nat-preserves-ne*/L :\n\tforall* {P1} {P2} {N1} {N2} {B}\n\tforall {PNE: ne P1 P2} {T1:pair2nat P1 N1} {T2:pair2nat P2 N2}\n               {NT: nat`eq? N1 N2 B}\n\texists {NE: nat`ne N1 N2}\n\ttrue.\n\n- : pair2nat-preserves-ne* P1<>P2 P1->N1 P2->N2 N1<>N2\n    <- nat`eq?-total EQ?\n    <- pair2nat-preserves-ne*/L P1<>P2 P1->N1 P2->N2 EQ? N1<>N2.\n\n- : pair2nat-preserves-ne*/L _ _ _ (nat`eq?/no N1<>N2) N1<>N2.\n\n- : pair2nat-preserves-ne*/L P1<>P2 P1->N P2->N (nat`eq?/yes) N<>N\n    <- nat2pair-deterministic P1->N P2->N nat`eq/ P1=P2\n    <- eq-ne-implies-false P1=P2 P1<>P2 F\n    <- nat`false-implies-ne F N<>N.\n\n%worlds () (pair2nat-preserves-ne*/L _ _ _ _ _).\n%total { } (pair2nat-preserves-ne*/L _ _ _ _ _).\n\n%worlds () (pair2nat-preserves-ne* _ _ _ _).\n%total { } (pair2nat-preserves-ne* _ _ _ _).\n\n\n%theorem pair2nat-preserves-ne :\n\tforall* {P1} {P2}\n\tforall {PNE: ne P1 P2} \n        exists {N1} {N2} {T1:pair2nat P1 N1} {T2:pair2nat P2 N2}\n\t       {NE: nat`ne N1 N2}\n\ttrue.\n\n- : pair2nat-preserves-ne P1<>P2 N1 N2 T1 T2 N1<>N2\n   <- pair2nat-total T1\n   <- pair2nat-total T2\n   <- pair2nat-preserves-ne* P1<>P2 T1 T2 N1<>N2.\n\n%worlds () (pair2nat-preserves-ne _ _ _ _ _ _).\n%total { } (pair2nat-preserves-ne _ _ _ _ _ _).\n\n\n%theorem nat2pair-preserves-ne* :\n\tforall* {P1} {P2} {N1} {N2}\n\tforall {NE: nat`ne N1 N2} {T1:nat2pair N1 P1} {T2:nat2pair N2 P2}\n\texists {PNE: ne P1 P2}\n\ttrue.\n\n%theorem nat2pair-preserves-ne*/L :\n\tforall* {P1} {P2} {N1} {N2} {B}\n\tforall {NE: nat`ne N1 N2} {T1:nat2pair N1 P1} {T2:nat2pair N2 P2}\n               {PT: eq? P1 P2 B}\n\texists {PNE: ne P1 P2}\n\ttrue.\n\n- : nat2pair-preserves-ne* N1<>N2 N1->P1 N2->P2 P1<>P2\n    <- eq?-total EP?\n    <- nat2pair-preserves-ne*/L N1<>N2 N1->P1 N2->P2 EP? P1<>P2.\n\n- : nat2pair-preserves-ne*/L _ _ _ (eq?/no P1<>P2) P1<>P2.\n\n- : nat2pair-preserves-ne*/L N1<>N2 N1->P N2->P (eq?/yes) P<>P\n    <- pair2nat-deterministic N1->P N2->P eq/ N1=N2\n    <- nat`eq-ne-implies-false N1=N2 N1<>N2 F\n    <- false-implies-ne F P<>P.\n\n%worlds () (nat2pair-preserves-ne*/L _ _ _ _ _).\n%total { } (nat2pair-preserves-ne*/L _ _ _ _ _).\n\n%worlds () (nat2pair-preserves-ne* _ _ _ _).\n%total { } (nat2pair-preserves-ne* _ _ _ _).\n\n\n%theorem nat2pair-preserves-ne :\n\tforall* {N1} {N2}\n\tforall {NNE: nat`ne N1 N2} \n        exists {P1} {P2} {T1:nat2pair N1 P1} {T2:nat2pair N2 P2}\n\t       {PE: ne P1 P2}\n\ttrue.\n\n- : nat2pair-preserves-ne N1<>N2 P1 P2 T1 T2 P1<>P2\n   <- nat2pair-total T1\n   <- nat2pair-total T2\n   <- nat2pair-preserves-ne* N1<>N2 T1 T2 P1<>P2.\n\n%worlds () (nat2pair-preserves-ne _ _ _ _ _ _).\n%total { } (nat2pair-preserves-ne _ _ _ _ _ _).\n\n\n%theorem nonzero-nat2pair-implies-gt-ge :\n\tforall* {N} {X} {Y}\n\tforall {D:nat2pair (s N) (pair/ X Y)}\n\texists {G1: gt (s N) X} {G2: ge (s N) Y}\n\ttrue.\n\n- : nonzero-nat2pair-implies-gt-ge \n     (pair2nat/XX plus/z plus/z times/z times/z _ (divrem/z _) (divrem/z _))\n     N+1>0 (nat`ge/= nat`eq/)\n     <- succ-implies-gt-zero _ N+1>0.\n\n- : nonzero-nat2pair-implies-gt-ge \n     (pair2nat/XX X2+Y=sN plus/z (times/s X-1*2=X2-2 X2-2+2=X2) \n     times/z _ (divrem/z _) (divrem/z TWO>X)) N+1>X N+1>=Y\n    <- plus-implies-ge X2+Y=sN (N+1>=Y:ge (s N) Y)\n    <- succ-gt-implies-ge TWO>X ONE>=X\n    <- ge-succ-implies-gt ONE>=X ONE>X-1\n    <- succ-gt-implies-ge ONE>X-1 ZERO>=X-1\n    <- ge-zero-always _ X-1>=0\n    <- ge-anti-symmetric ZERO>=X-1 X-1>=0 ZERO=X-1\n    <- succ-deterministic ZERO=X-1 ONE=X\n    <- times-deterministic times/z X-1*2=X2-2 ZERO=X-1 nat`eq/ ZERO=X2-2\n    <- plus-deterministic plus/z X2-2+2=X2 ZERO=X2-2 nat`eq/ TWO=X2\n    <- gt-respects-eq (gt/1) TWO=X2 ONE=X X2>X\n    <- plus-commutative X2+Y=sN Y+X2=sN\n    <- plus-implies-ge Y+X2=sN N+1>=X2\n    <- ge-transitive-gt N+1>=X2 X2>X N+1>X.\n\n- : nonzero-nat2pair-implies-gt-ge \n     (pair2nat/XX _ _ _ _ (P2z:pair2nat (pair/ (s _) _) z) _ _) GT GE\n    <- nat2pair-deterministic pair2nat/00 P2z nat`eq/ ZERO,0=sN,_\n    <- pair-eq-implies-eq ZERO,0=sN,_ ZERO=sN _\n    <- nat`eq-contradiction ZERO=sN F\n    <- nat`false-implies-gt F GT\n    <- nat`false-implies-ge F GE.\n\n- : nonzero-nat2pair-implies-gt-ge \n     (pair2nat/XX _ _ _ _ (P2z:pair2nat (pair/ _ (s _)) z) _ _) GT GE\n    <- nat2pair-deterministic pair2nat/00 P2z nat`eq/ ZERO,0=_,sN\n    <- pair-eq-implies-eq ZERO,0=_,sN _ ZERO=sN\n    <- nat`eq-contradiction ZERO=sN F\n    <- nat`false-implies-gt F GT\n    <- nat`false-implies-ge F GE.\n\n- : nonzero-nat2pair-implies-gt-ge \n     (pair2nat/XX Z3+Y0=sN Z2+X2=Z3 X0*2=X2 Z1*4=Z2 Z1->X1,Y1 \n\t          Y/2=Y1,Y0 X/2=X1,X0) N+1>X (ge/> N+1>Y)\n    <- plus-commutative Z3+Y0=sN Y0+Z3=sN\n    <- plus-implies-ge Y0+Z3=sN N+1>=Z3\n    <- plus-commutative Z2+X2=Z3 X2+Z2=Z3\n    <- plus-implies-ge X2+Z2=Z3 Z3>=Z2\n    <- ge-transitive N+1>=Z3 Z3>=Z2 N+1>=Z2\n    <- nonzero-nat2pair-implies-gt-ge Z1->X1,Y1 Z1>X1 Z1>=Y1\n    <- times-associative-converse 2*2=4 Z1*4=Z2 Z2/2 Z1*2=Z2/2 Z2/2*2=Z2\n    <- divrem-can-be-inverted Y/2=Y1,Y0 Y12 Y1*2=Y12 Y12+Y0=Y\n    <- divrem-can-be-inverted X/2=X1,X0 X12 X1*2=X12 X12+X0=X\n    <- times-right-preserves-gt* Z1>X1 Z1*2=Z2/2 X1*2=X12 nat`eq/ Z2/2>X12\n    <- succ-implies-gt-zero _ Z1>0\n    <- gt-implies-ge-succ Z1>0 Z1>=1\n    <- times-right-preserves-ge* Z1>=1 Z1*2=Z2/2 1*2=2 Z2/2>=2\n    <- ge-implies-plus Z2/2>=2 ZZ ZZ+2=Z2/2\n    <- plus-commutative ZZ+2=Z2/2 TWO+ZZ=Z2/2\n    <- plus-deterministic TWO+ZZ=Z2/2 (plus/s (plus/s plus/z)) nat`eq/ nat`eq/\n                          Z2/2=ssZZ\n    <- times-respects-eq Z2/2*2=Z2 Z2/2=ssZZ nat`eq/ nat`eq/ SSZZ*2=Z2\n    <- non-trivial-times-implies-much-gt* SSZZ*2=Z2 Z2>sssZZ\n    <- divrem-implies-gt X/2=X1,X0 TWO>X0\n    <- succ-gt-implies-ge TWO>X0 ONE>=X0\n    <- plus-right-identity _ X12+0=X12 \n    <- plus-right-increase X12+0=X12 X12+1=sX12\n    <- plus-left-preserves-ge* ONE>=X0 X12+1=sX12 X12+X0=X SX12>=X\n    <- gt-implies-ge-succ Z2/2>X12 Z2/2>=sX12\n    <- ge-transitive Z2/2>=sX12 SX12>=X Z2/2>=X\n    <- ge-respects-eq Z2/2>=X Z2/2=ssZZ nat`eq/ SSZZ>=X\n    <- ge-implies-succ-gt SSZZ>=X SSSZZ>X\n    <- gt-transitive Z2>sssZZ SSSZZ>X Z2>X\n    <- ge-transitive-gt N+1>=Z2 Z2>X N+1>X\n    <- times-right-preserves-ge* Z1>=Y1 Z1*2=Z2/2 Y1*2=Y12 Z2/2>=Y12\n    <- ge-respects-eq Z2/2>=Y12 Z2/2=ssZZ nat`eq/ SSZZ>=Y12\n    <- divrem-implies-gt Y/2=Y1,Y0 TWO>Y0\n    <- succ-gt-implies-ge TWO>Y0 ONE>=Y0\n    <- plus-right-identity _ Y12+0=Y12 \n    <- plus-right-increase Y12+0=Y12 Y12+1=sY12\n    <- plus-left-preserves-ge* ONE>=Y0 Y12+1=sY12 Y12+Y0=Y SY12>=Y\n    <- succ-preserves-ge SSZZ>=Y12 SSSZZ>=SY12\n    <- ge-transitive SSSZZ>=SY12 SY12>=Y SSSZZ>=Y\n    <- gt-transitive-ge Z2>sssZZ SSSZZ>=Y Z2>Y\n    <- ge-transitive-gt N+1>=Z2 Z2>Y N+1>Y.\n\n%worlds () (nonzero-nat2pair-implies-gt-ge _ _ _).\n%total (N) (nonzero-nat2pair-implies-gt-ge N _ _).\n\n\n%theorem nat2pair-implies-ge :\n\tforall* {N} {X} {Y}\n\tforall {D:nat2pair N (pair/ X Y)}\n\texists {G1: ge N X} {G2: ge N Y}\n\ttrue.\n\t\n- : nat2pair-implies-ge N2P (ge/> N>X) N>=Y\n    <- nonzero-nat2pair-implies-gt-ge N2P N>X N>=Y.\n\n- : nat2pair-implies-ge Z2P (ge/= ZERO=X) (ge/= ZERO=Y)\n    <- nat2pair-deterministic pair2nat/00 Z2P nat`eq/ ZERO,ZERO=X,Y\n    <- pair-eq-implies-eq ZERO,ZERO=X,Y ZERO=X ZERO=Y.\n\n%worlds () (nat2pair-implies-ge _ _ _).\n%total { } (nat2pair-implies-ge _ _ _).\n\n\n%theorem constrained1-pair2nat-unbounded :\n\tforall {N1} {B}\n\texists {N2} {N} {D:pair2nat (pair/ N1 N2) N} {G:gt N B}\n\ttrue.\n\n- : constrained1-pair2nat-unbounded N1 B (s B) N N1,N2->N N>B\n    <- pair2nat-total N1,N2->N\n    <- nat2pair-implies-ge N1,N2->N N>=N1 N>=N2\n    <- ge-succ-implies-gt N>=N2 N>B.\n\n%worlds () (constrained1-pair2nat-unbounded _ _ _ _ _ _).\n%total { } (constrained1-pair2nat-unbounded _ _ _ _ _ _).\n\n\n%theorem constrained2-pair2nat-unbounded :\n\tforall {N2} {B}\n\texists {N1} {N} {D:pair2nat (pair/ N1 N2) N} {G:gt N B}\n\ttrue.\n\n- : constrained2-pair2nat-unbounded N2 B (s B) N N1,N2->N N>B\n    <- pair2nat-total N1,N2->N\n    <- nat2pair-implies-ge N1,N2->N N>=N1 N>=N2\n    <- ge-succ-implies-gt N>=N1 N>B.\n\n%worlds () (constrained2-pair2nat-unbounded _ _ _ _ _ _).\n%total { } (constrained2-pair2nat-unbounded _ _ _ _ _ _).\n\n\n\n\n%%%% Renamings\n\n\n%abbrev natpair = pair.\n\n\n%abbrev natpair/ = pair/.\n\n\n\n%%%% Exports\n%abbrev natpair`pair = pair.\n%abbrev natpair`pair/ = pair/.\n%abbrev natpair`eq = eq.\n%abbrev natpair`eq/ = eq/.\n%abbrev natpair`ne = ne.\n%abbrev natpair`ne/1 = ne/1.\n%abbrev natpair`ne/2 = ne/2.\n%abbrev natpair`eq? = eq?.\n%abbrev natpair`eq?/yes = eq?/yes.\n%abbrev natpair`eq?/no = eq?/no.\n%abbrev natpair`false-implies-eq = false-implies-eq.\n%abbrev natpair`meta-eq = meta-eq.\n%abbrev natpair`eq-reflexive = eq-reflexive.\n%abbrev natpair`eq-symmetric = eq-symmetric.\n%abbrev natpair`eq-transitive = eq-transitive.\n%abbrev natpair`pair-eq-implies-eq = pair-eq-implies-eq.\n%abbrev natpair`pair-preserves-eq = pair-preserves-eq.\n%abbrev natpair`false-implies-ne = false-implies-ne.\n%abbrev natpair`ne-respects-eq = ne-respects-eq.\n%abbrev natpair`ne-anti-reflexive = ne-anti-reflexive.\n%abbrev natpair`ne-symmetric = ne-symmetric.\n%abbrev natpair`eq-ne-implies-false = eq-ne-implies-false.\n%abbrev natpair`eq?-total* = eq?-total*.\n%abbrev natpair`eq?-total*/L = eq?-total*/L.\n%abbrev natpair`eq?-total = eq?-total.\n%abbrev natpair`pair2nat = pair2nat.\n%abbrev natpair`pair2nat/00 = pair2nat/00.\n%abbrev natpair`pair2nat/XX = pair2nat/XX.\n%abbrev natpair`nat2pair = nat2pair.\n%abbrev natpair`false-implies-pair2nat = false-implies-pair2nat.\n%abbrev natpair`false-implies-not2pair = false-implies-not2pair.\n%abbrev natpair`pair2nat-respects-eq = pair2nat-respects-eq.\n%abbrev natpair`nat2pair-respects-eq = nat2pair-respects-eq.\n%abbrev natpair`pair2nat-total** = pair2nat-total**.\n%abbrev natpair`pair2nat-total* = pair2nat-total*.\n%abbrev natpair`pair2nat-total = pair2nat-total.\n%abbrev natpair`nat2pair-total* = nat2pair-total*.\n%abbrev natpair`nat2pair-total = nat2pair-total.\n%abbrev natpair`pair2nat-deterministic = pair2nat-deterministic.\n%abbrev natpair`pair2nat-deterministic/00 = pair2nat-deterministic/00.\n%abbrev natpair`nat2pair-deterministic = nat2pair-deterministic.\n%abbrev natpair`nat2pair-deterministic/0 = nat2pair-deterministic/0.\n%abbrev natpair`pair2nat-preserves-ne* = pair2nat-preserves-ne*.\n%abbrev natpair`pair2nat-preserves-ne*/L = pair2nat-preserves-ne*/L.\n%abbrev natpair`pair2nat-preserves-ne = pair2nat-preserves-ne.\n%abbrev natpair`nat2pair-preserves-ne* = nat2pair-preserves-ne*.\n%abbrev natpair`nat2pair-preserves-ne*/L = nat2pair-preserves-ne*/L.\n%abbrev natpair`nat2pair-preserves-ne = nat2pair-preserves-ne.\n%abbrev natpair`nonzero-nat2pair-implies-gt-ge = nonzero-nat2pair-implies-gt-ge.\n%abbrev natpair`nat2pair-implies-ge = nat2pair-implies-ge.\n%abbrev natpair`constrained1-pair2nat-unbounded = constrained1-pair2nat-unbounded.\n%abbrev natpair`constrained2-pair2nat-unbounded = constrained2-pair2nat-unbounded.\n%abbrev natpair`natpair = natpair.\n%abbrev natpair`natpair/ = natpair/.\n\n\n\n\n%{ == Definitions == }%\n\n\n\n%{ === The syntax === }%\n\n%{\nThe HOAS defined here is uninteresting.  There isn't even any way to use\nmore than one variable (although the proofs use techniques that can \nhandle any number of variables).\n}%\n\n\nt : type.\n\n\na : t.\n\nb : t -> t.\n\nf : (t -> t) -> t.\n\n%block blocksimple : block {v:t}.\n\n\n\n%{ === Equality === }%\n\n\neq : t -> t -> type.\n\n\neq/ : eq T T.\n\n\n\n%{ === Variable levels === }%\n\n%{\nA variable level is the (nonzero) natural number for a variable.\nThis value is used to determine the mapping for a variable.\n}%\n\n\nvarlevel : t -> nat -> type.\n\n%block blockvar : some {l} block {v} {vl:varlevel v (s l)}.\n\n\n\n%{ === Mapping === }%\n\n%{\nThe bijection from t to nat is called \"tonat\".  In its more general\nform the relation takes a natural number indicating how deep we are\ninside functions.\n}%\n\n\ntonat* : nat -> t -> nat -> type.\n\n%abbrev tonat = tonat* z.\n\n\ntonat/v : \n\tvarlevel V L ->\n\tplus M L N ->\n    tonat* N V M.\n\ntonat/a : tonat* N a N.\n\ntonat/b : \n\ttonat* N T M ->\n\ttimes (s (s z)) M TM ->\n\tplus (s N) TM M' ->\n    tonat* N (b T) M'.\n\ntonat/f :\n\t({v} (varlevel v (s N)) ->\n         tonat* (s N) (F v) M) ->\n\ttimes (s (s z)) M TM ->\n\tplus (s (s N)) TM M' ->\n    tonat* N (f F) M'.\n\n\n\n%{ === Utility lemmas === }%\n\n%{\nThe following theorems prove obvious simple things about the\nbasic relations.  They following the conventions established in\nJohn Boyland's library signatures.\n}%\n\n\n%theorem false-implies-varlevel :\n\tforall*\t{V} {L}\n\tforall\t{F:void}\n\texists\t{VL:varlevel V L}\n\ttrue.\n\n%worlds (blockvar) (false-implies-varlevel _ _).\n%total { } (false-implies-varlevel _ _).\n\n\n%theorem varlevel-respects-eq :\n\tforall* {V} {L1} {L2}\n\tforall\t{VL1:varlevel V L1}\n\t\t{E:nat`eq L1 L2}\n\texists\t{VL2:varlevel V L2}\n\ttrue.\n\n- : varlevel-respects-eq VL nat`eq/ VL.\n\n%worlds (blocksimple | blockvar) (varlevel-respects-eq _ _ _).\n%total { } (varlevel-respects-eq _ _ _).\n\n\n%theorem false-implies-tonat :\n\tforall* {N} {T} {M}\n\tforall\t{F:void}\n\texists\t{TN:tonat* N T M}\n\ttrue.\n\n%worlds (blockvar) (false-implies-tonat _ _).\n%total { } (false-implies-tonat _ _).\n\n\n\n\n%{ == Proof of totality of tonat == }%\n\n%{\nThe difficulty here is that we need to prove that when\nwe get to a variable (and exactly how we tell this\nin Twelf is tricky because variables can't be captured in\ncase analysis), we need to ensure that (1) the variable\nhas a level associated with it and (2) the level is \nin the range 1..N where N is the block nesting we are in.\nBlocks are useful for (1) but not for (2) because there's\nno way to connect the context with the current nesting level.\n\nInstead we use a technique (I learn from Rob Simmons) to handle\none level of variable a time in a separate lemma.  This works since \nfor each particular HOAS function we know that the variable\nis bound legally.\n\nWe package this approach up into an auxiliary relation that incidentally\nmakes it easy to capture variables in case analysis.  This makes\nfor a wordy series of proofs.  Perhaps we can get rid of 'case'\nin general.\n}%\n\n\n\n%{ === Auxiliary definitions === }%\n\n\n%{ ==== raw variables ==== }%\n\n%{\nA variable is raw if we haven't verified that it has a level in range.\nNon variables are not raw.\n}%\n\nisraw : t -> bool -> type.\n\n%abbrev rawvar = [T] israw T true.\n\n\nisraw/a : israw a false.\n\nisraw/b : israw (b _) false.\n\nisraw/f : israw (f _) false.\n\n\n%{ ==== case analysis ==== }%\n\n%{\nWe case analysis terms with two cases for variables.\nThe raw case is used only internally and can be ignored in\n\"clients\" that don't use israw.\n}%\n\ncase : nat -> t -> type.\n\n\ncase/a : case _ a.\n\ncase/b : case N T -> case N (b T).\n\ncase/f : ({v} varlevel v (s N) -> case (s N) (F v)) -> case N (f F).\n\ncase/var : varlevel V L -> nat`ge N L -> case N V.\n\ncase/raw : rawvar V -> case N V.\n\n\n\n%{ === Theorems about auxiliary definitions === }%\n\n%{\nWhat follows first is a theorem that says that in a context where \nall variables are raw, we can campute the rawness of all terms.\nIn a Twelf idiom that will be seen several times in this file\n(and which I learned from Rob Simmons), we have to put the theorem\nfor the the variable case in the same context that defines the variable\nas raw.  (This is rather annoying: Twelf should be smart enough to\nsee that the context that defines the variable has the\nnecessary relation.)  This somewhat contorted idiom falls afoul of\nautofreezing in Twelf 1.5r3.  I consider this a bug in Twelf,\nbut fortunately it can be worked around by defining a fake \ncircular dependency.  (Again, the idea from Rob Simmons.)\nFor some reason, unlike Rob's examples and the later instances in\nthis file, I need to add israw to the fake dependencies as well.\nThe definition \"fake\" is never used again.  It has no \"meaning.\"\n}%\n\n\n%theorem israw-total* :\n\tforall\t{T}\n\texists\t{B} {I:israw T B}\n\ttrue.\n\n%abbrev israw-total = israw-total* _ _.\n\n- : israw-total israw/a.\n\n- : israw-total israw/b.\n\n- : israw-total israw/f.\n\nfake : type.\n- : fake <- {i:israw-total* T B I} israw-total* T' B' I'.\n- : fake <- {i:israw-total* T B I} israw T' B'.\n\n%block blockraw : block {v} {rv:rawvar v} {irt:israw-total rv}.\n\n%worlds (blockraw) (israw-total* _ _ _).\n%total { } (israw-total* _ _ _).\n\n\n%{\nThe following theorem handles one variable converting it from raw to\nhandle a level that is in the required range.  This is an important\ntechnique for handle variables in Twelf: one at a time.\n}%\n\n%theorem var-gets-level :\n\tforall* {N} {T} {L}\n\tforall\t{F: {v} {rv:rawvar v} {i:israw-total rv} case N (T v)}\n\t\t{GE: nat`ge N L}\n\texists  {F': {v} (varlevel v L) -> case N (T v)}\n\ttrue.\n\n- : var-gets-level ([v] [r] [i] (case/raw r)) N>=L\n                   ([v] [vl] (case/var vl N>=L)).\n\n- : var-gets-level ([v] [r] [i] (case/raw R)) _\n                   ([v] [vl] (case/raw R)).\n\n- : var-gets-level ([v] [c] [i] (case/var VL N>=L)) _\n                   ([v] [vl] (case/var VL N>=L)).\n\n- : var-gets-level ([v] [c] [i] case/a) _\n                   ([v] [vl] case/a).\n\n- : var-gets-level ([v] [c] [i] (case/b (C v c i))) N>=L\n                   ([v] [vl] (case/b (C' v vl)))\n    <- var-gets-level ([v] [c] [i] (C v c i)) N>=L ([v][vl] (C' v vl)).\n\n- : var-gets-level ([v] [c] [i] (case/f ([v'][vl'] (C v' vl' v c i)))) N>=L\n                   ([v][vl] (case/f ([v'][vl'] (C' v' vl' v vl))))\n    <- ge-implies-succ-gt N>=L N+1>L\n    <- ({v'} {vl':varlevel v' _} \n\tvar-gets-level ([v] [c] [i] (C v' vl' v c i)) (nat`ge/> N+1>L)\n             ([v][vl](C' v' vl' v vl))).\n\n%worlds (blockvar | blockraw) (var-gets-level _ _ _).\n%total F (var-gets-level F _ _).\n\n\n%{\nWe are now ready to prove that we can always \"case\" a term.\nThis code follows John Boyland's library convention of defining a \n\"-total\" metatheorem as having implicit arguments that are explicit\nin a \"-total*\" version.  In the main lemma, the interesting case\nis when we have a \"f\" term: after ensuring that the subterm can be\nbe tested for rawness, we recurse while the variable is assumed raw.\nOnce this is done, we convert the variable into one with a level\nusing \"var-gets-level\".  Note that the var levels don't go into \nthe context for this theorem.\n}%\n\n%theorem case-total* :\n\tforall\t{T}\n\texists\t{C:case z T}\n\ttrue.\n\n%abbrev case-total = case-total* _.\n\n%theorem case-total/L :\n\tforall* {B}\n\tforall\t{N} {T} {I:israw T B}\n\texists\t{C:case N T}\n\ttrue.\n\n- : case-total/L _ _ _ (case/a).\n\n- : case-total/L _ _ _ (case/b C)\n    <- israw-total I\n    <- case-total/L _ _ I C.\n\n- : case-total/L _ (f ([v] F v)) israw/f (case/f ([v] [vl] (C' v vl)))\n    <- ({v} {r:rawvar v} {i:israw-total r}\n        israw-total (I v r i))\n    <- ({v} {r:rawvar v} {i:israw-total r} \n        case-total/L _ (F v) (I v r i : israw (F v) B) (C v r i))\n    <- var-gets-level C (nat`ge/= nat`eq/) C'.\n\n- : case-total/L _ V R (case/raw R).\n\n%worlds (blockraw) (case-total/L _ _ _ _).\n%total T (case-total/L _ T _ _).\n\n- : case-total* T C\n    <- israw-total I\n    <- case-total/L z T I C.\n\n%worlds () (case-total* _ _).\n%total { } (case-total* _ _).\n\n\n\n%{ === Main theorem === }%\n\n%{\nWe are ready now to prove totality of the relation.\nWe case the term first and then have everything we need\nto push through totality.\n}%\n\n\n%theorem tonat-total* :\n\tforall {T:t}\n\texists {M:nat} {D:tonat T M}\n\ttrue.\n\n%abbrev tonat-total = tonat-total* _ _.\n\n%theorem tonat-total/L :\n\tforall {N:nat} {T:t} {C:case N T}\n\texists {M:nat} {D:tonat* N T M}\n\ttrue.\n\n- : tonat-total/L _ _ (case/var VL GE) _ (tonat/v VL P)\n    <- ge-implies-plus GE _ P.\n\n- : tonat-total/L _ _ (case/a) _ (tonat/a).\n\n- : tonat-total/L _ _ (case/b C) _ (tonat/b TN T P)\n    <- tonat-total/L _ _ C _ TN\n    <- times-total T\n    <- plus-total P.\n\n- : tonat-total/L _ _ (case/f ([v] [vl] (C v vl))) _ \n                      (tonat/f ([v] [vl] (TN v vl)) T P)\n    <- ({v} {vl:varlevel v (s N)} tonat-total/L _ _ (C v vl) _ (TN v vl))\n    <- times-total T\n    <- plus-total P.\n\n%worlds (blockvar) (tonat-total/L _ _ _ _ _).\n%total (C) (tonat-total/L _ _ C _ _).\n\n- : tonat-total TN\n    <- case-total C\n    <- tonat-total/L _ _ C _ TN.\n\n%worlds () (tonat-total* _ _ _).\n%total { } (tonat-total* _ _ _).\n\n\n\n\n%{ == Proof of the determinicity of the mapping == }%\n\n%{\nIn this section, we prove that tonat gives only one value \n(hence it is a function).  This sort of theorem is called\na \"uniqueness\" theorem.  Here the name I use for it comes from \nTwelf's \"%deterministic\" declaration.  (I find the term \"unique\" \nmight refer to the \"one2one\" aspect, proved later.)\n\nThis aspect is much easier to prove that any of the others.\nThat probably reflects the fact that the relation was written \nin a functional style.\n}%\n\n\n\n%{ === Auxiliary theorems === }%\n\n\n%{\nWe prove that variable levels are \"unique\" and that they are never zero.\nThe proofs are trivial: Twelf can accept them from the context alone.\n}%\n\n\n%theorem varlevel-deterministic :\n\tforall* {V} {L1} {L2}\n\tforall\t{VL1:varlevel V L1}\n\t\t{VL2:varlevel V L2}\n\texists\t{E:nat`eq L1 L2}\n\ttrue.\n\n- : varlevel-deterministic _ _ nat`eq/.\n\n%worlds (blockvar) (varlevel-deterministic _ _ _).\n%total { } (varlevel-deterministic _ _ _).\n\n\n%theorem varlevel-contradiction :\n\tforall* {V} {L}\n\tforall\t{VL:varlevel V L}\n\t\t{E:nat`eq L z}\n\texists\t{F:void}\n\ttrue.\n\n%worlds (blockvar) (varlevel-contradiction _ _ _).\n%total { }  (varlevel-contradiction _ _ _).\n\n\n\n%{ === Main Theorem === }%\n\n\n%theorem tonat-deterministic :\n\tforall* {T1} {T2} {N1} {N2}\n\tforall\t{TN1:tonat T1 N1} \n\t\t{TN2:tonat T2 N2}\n\t\t{E: eq T1 T2}\n\texists\t{E: nat`eq N1 N2}\n\ttrue.\n\n%theorem tonat-deterministic/L :\n\tforall* {T} {N} {N1} {N2}\n\tforall\t{TN1:tonat* N T N1} \n\t\t{TN2:tonat* N T N2}\n\texists\t{E: nat`eq N1 N2}\n\ttrue.\n\n- : tonat-deterministic/L (tonat/v VL1 P1) (tonat/v VL2 P2) N1=N2\n    <- varlevel-deterministic VL1 VL2 L1=L2\n    <- plus-right-cancels P1 P2 L1=L2 nat`eq/ N1=N2.\n\n- : tonat-deterministic/L (tonat/a) (tonat/a) nat`eq/.\n\n- : tonat-deterministic/L (tonat/b TN1 T1 P1) (tonat/b TN2 T2 P2) M1'=M2'\n    <- tonat-deterministic/L TN1 TN2 M1=M2\n    <- times-deterministic T1 T2 nat`eq/ M1=M2 TM1=TM2\n    <- plus-deterministic P1 P2 nat`eq/ TM1=TM2 M1'=M2'.\n\n- : tonat-deterministic/L (tonat/f ([v] [vl] (TN1 v vl)) T1 P1)\n                          (tonat/f ([v] [vl] (TN2 v vl)) T2 P2) M1'=M2'\n    <- ({v} {vl:varlevel v (s N)} tonat-deterministic/L (TN1 v vl) (TN2 v vl)\n                                                        M1=M2)\n    <- times-deterministic T1 T2 nat`eq/ M1=M2 TM1=TM2\n    <- plus-deterministic P1 P2 nat`eq/ TM1=TM2 M1'=M2'.\n\n%worlds (blockvar) (tonat-deterministic/L _ _ _).\n%total (T) (tonat-deterministic/L T _ _).\n\n- : tonat-deterministic TN1 TN2 eq/ N1=N2\n    <- tonat-deterministic/L TN1 TN2 N1=N2.\n\n%worlds () (tonat-deterministic _ _ _ _).\n%total { } (tonat-deterministic _ _ _ _).\n\n\n\n%{ ==  Proving that the mapping is onto. == }%\n\n%{\nHere we use the mathematical term \"onto\": a function is \"onto\" if \nits range is equal to its co-domain: that is if every value in the \nco-domain has a value in the domain that maps to it.\n\nThe tricky aspect here is that we need to show that every level that the\nreverse mapping has a variable associated with it.  We do this using a \nhelper relation, as opposed to putting something in the context, since \nas explained earlier, the context is useless to connect variables with \nthe nesting level.\n}%\n\n\n%{ === Auxiliary definitions === }%\n\n\n\n%{\nWe define a relation that builds on the context relation.\nI find this rather interesting because it uses the context relation but\nis not itself in the context.  This is rather rare in my limited \nexperience.\n\nupto N says that we have a variable for all levels 1..N.\n}%\n\n\nupto : nat -> type.\n\n\nupto/z : upto z.\n\nupto/s : upto N -> varlevel V (s N) -> upto (s N).\n\n\n\n%{ === Theorems about auxiliary definitions === }%\n\n\n%{ ==== The obvious lemma that makes use of the main purpose of the relation: ==== }%\n\n%theorem upto-implies-varlevel :\n\tforall* {N} {L}\n\tforall\t{U:upto N}\n\t\t{LT:nat`gt N L}\n\texists\t{V} {VL:varlevel V (s L)}\n\ttrue.\n\n- : upto-implies-varlevel upto/z ZERO>L a VL\n    <- nat`gt-contradiction ZERO>L F\n    <- false-implies-varlevel F VL.\n\n- : upto-implies-varlevel (upto/s _ VL) (gt/1) _ VL.\n\n- : upto-implies-varlevel (upto/s U _) (gt/> G) _ VL\n    <- upto-implies-varlevel U G _ VL.\n\n%worlds (blockvar) (upto-implies-varlevel _ _ _ _).\n%total (U) (upto-implies-varlevel U _ _ _).\n\n\n\n%{ === Main theorem === }%\n\n%{\nWe prove the main result using two lemmas that do the case\nanalysis on the number against the nesting level and the\nparity.  (In general, one would use a divisor counting all\ncases that are recursive.)  The proofs are long but simply\narithmetic manipulation.  Proving termination uses meta-gt\nfor strong induction over the natural numbers.\n}%\n\n\n%theorem tonat-onto* :\n\tforall\t{N:nat}\n\texists\t{T} {TN:tonat T N}\n\ttrue.\n\n%abbrev tonat-onto = tonat-onto* _ _.\n\n%theorem tonat-onto/L1 :\n\tforall* {C}\n\tforall\t{N:nat} \n\t\t{U:upto N}\n\t\t{M:nat}\n\t\t{CMP:nat`compare N M C}\n\texists\t{T} {TN:tonat* N T M}\n\ttrue.\n\n%theorem tonat-onto/L2 :\n\tforall*\t{TM}\n\tforall\t{N:nat}\n\t\t{U:upto N}\n\t\t{M:nat}\n\t\t{P:plus N (s TM) M}\n\t\t{Q} {R} {DR:divrem TM (s (s z)) Q R}\n\texists\t{T} {TN:tonat* N T M}\n\ttrue.\n\n- : tonat-onto/L1 N U M (compare/> N>M) _ (tonat/v VL M+L+1=N)\n    <- nat`gt-implies-plus N>M L L+1+M=N\n    <- plus-commutative L+1+M=N M+L+1=N\n    <- plus-implies-ge M+L+1=N N>=L+1\n    <- ge-succ-implies-gt N>=L+1 N>L\n    <- upto-implies-varlevel U N>L _ VL.\n\n- : tonat-onto/L1 N U _ (compare/=) a tonat/a.\n\n- : tonat-onto/L1 N U M (compare/< M>N) _ TN\n    <- gt-implies-plus M>N TM TM+1+N=M\n    <- plus-commutative TM+1+N=M N+TM+1=M\n    <- divrem-total DR\n    <- tonat-onto/L2 N U M N+TM+1=M _ _ DR _ TN.\n\n- : tonat-onto/L2 _ U M' N+TM+1=M' M z TM/2=M _ (tonat/b TN TWO*M=TM N+1+TM=M')\n    <- div-can-be-inverted TM/2=M M*2=TM\n    <- times-commutative M*2=TM TWO*M=TM\n    <- plus-swap-succ-converse N+TM+1=M' N+1+TM=M'\n    <- plus-implies-gt N+1+TM=M' nat`eq/ M'>TM\n    <- times-nonzero-implies-ge M*2=TM TM>=M\n    <- nat`gt-transitive-ge M'>TM TM>=M M'>M\n    <- meta-gt _ _ M'>M\n    <- compare-total CMP\n    <- tonat-onto/L1 _ U M CMP _ TN.\n\n- : tonat-onto/L2 N U M' (N+TM'+1=M':plus N (s TM') M') M (s z) TM'/2=M,1 \n                  (f ([v] F v))\n                  (tonat/f ([v] [vl] (TN v vl))\n                           TWO*M=TM N+2+TM=M')\n    <- divrem-can-be-inverted TM'/2=M,1 TM M*2=TM TM+ONE=TM'\n    <- times-commutative M*2=TM TWO*M=TM\n    <- plus-commutative (plus/s plus/z) TM+ONE=TM+1\n    <- plus-deterministic TM+ONE=TM' TM+ONE=TM+1 nat`eq/ nat`eq/ TM'=TM+1\n    <- succ-deterministic TM'=TM+1 (TM'+1=TM+2:nat`eq (s TM') (s (s TM)))\n    <- plus-respects-eq N+TM'+1=M' nat`eq/ TM'+1=TM+2 nat`eq/ N+TM+2=M'\n    <- plus-swap-succ-converse N+TM+2=M' N+1+TM+1=M'\n    <- plus-swap-succ-converse N+1+TM+1=M' N+2+TM=M'\n    <- plus-implies-ge N+TM'+1=M' M'>=TM'+1\n    <- ge-succ-implies-gt M'>=TM'+1 M'>TM'\n    <- quotient-of-nonzero-is-smaller TM'/2=M,1 TM'=TM+1 TM'>M\n    <- nat`gt-transitive M'>TM' TM'>M M'>M\n    <- meta-gt _ _ M'>M\n    <- nat`compare-total CMP\n    <- ({v} {vl:varlevel v (s N)} \n        tonat-onto/L1 (s N) (upto/s U vl) M CMP (F v) (TN v vl)).\n\n- : tonat-onto/L2 _ _ _ _ _ (s (s _)) DR a TN\n    <- divrem-implies-gt DR TWO>R+2\n    <- succ-preserves-gt-converse TWO>R+2 ONE>R+1\n    <- succ-preserves-gt-converse ONE>R+1 ZERO>R\n    <- gt-contradiction ZERO>R F\n    <- false-implies-tonat F TN.\n\n%worlds (blockvar) (tonat-onto/L1 _ _ _ _ _ _)\n                   (tonat-onto/L2 _ _ _ _ _ _ _ _ _).\n%total (M1 M2) (tonat-onto/L2 _ _ M2 _ _ _ _ _ _)\n               (tonat-onto/L1 _ _ M1 _ _ _).\n\n\n\n\n%{ == Proof that mapping is \"one to one\" == }%\n\n%{\nThis is the most involved proof.  The sketch is that we first prove\nthat two terms that reduce to the same natural number are \"eql\" in a way \nthat only requires that the variables have the same level, but not that \nthey are the same.  Of course, there is only one variable for each level, \nwhich means that the terms are truly identical.  But this is impossible\nto express in the context.  Instead, we chip away at the variables from\nthe \"outside\", each time reducing the level of the remaining variables.\n}%\n\n\n\n%{ === Auxiliary definitions === }%\n\n\n%{ ==== Equality (permitting variables with the same level). ==== }%\n\neql* : nat -> t -> t -> type.\n\n%abbrev eql = eql* z.\n\n\neql/eq : eq T1 T2 -> eql* N T1 T2.\n\neql/b : eql* N T1 T2 -> eql* N (b T1) (b T2).\n\neql/f1 : ({v:t} (eql* N (F1 v) (F2 v))) -> \n\t eql* N (f F1) (f F2).\n\neql/f2 : ({v:t} {vl:varlevel v (s N)} (eql* (s N) (F1 v) (F2 v))) ->\n\teql* N (f F1) (f F2).\n\neql/v : varlevel V1 L -> varlevel V2 L -> eql* N V1 V2.\n\n\n%{ ==== Measure of eql sizes. ==== }%\n\n%{\nWe use this measure to be able to prove termination.\nWe need eqlsize/v = eqlsize/eq, eqlsize/f1 = eqlsize/f2.\n(Less than is ok in each case but would require that we\nrephrase the lemmas.)\n}%\n\neqlsize : (eql* N T1 T2) -> nat -> type.\n\n\neqlsize/eq : eqlsize (eql/eq _) z.\n\neqlsize/b : eqlsize E N -> eqlsize (eql/b E) (s N).\n\neqlsize/f1 : ({v} eqlsize (E v) N) ->\n\teqlsize (eql/f1 ([v] (E v))) (s N).\n\neqlsize/f2 : ({v} {vl} eqlsize (E v vl) N) ->\n\teqlsize (eql/f2 ([v] [vl] (E v vl))) (s N).\n\neqlsize/v : eqlsize (eql/v _ _) z.\n\n\n%{ ==== Copied definitions ==== }%\n\n%{\nIt turns out that switching variables to an earlier level\nwill cause mixup (because we need to have both the old\nand new levels in the context at the same time) unless\nwe use a different definition.  For that reason, we define\nalternatives for varlevel, eql and eqlsize.\n}%\n\nvarlevel' : t -> nat -> type.\n\n\neql*' : nat -> t -> t -> type.\n\neql'/eq : eq T1 T2 -> eql*' N T1 T2.\n\neql'/b : eql*' N T1 T2 -> eql*' N (b T1) (b T2).\n\neql'/f1 : ({v:t} (eql*' N (F1 v) (F2 v))) -> \n\t eql*' N (f F1) (f F2).\n\neql'/f2 : ({v:t} {vl:varlevel' v (s N)} (eql*' (s N) (F1 v) (F2 v))) ->\n\teql*' N (f F1) (f F2).\n\neql'/v : varlevel' V1 L -> varlevel' V2 L -> eql*' N V1 V2.\n\n\neqlsize' : (eql*' N T1 T2) -> nat -> type.\n\neqlsize'/eq : eqlsize' (eql'/eq _) z.\n\neqlsize'/b : eqlsize' E N -> eqlsize' (eql'/b E) (s N).\n\neqlsize'/f1 : ({v} eqlsize' (E v) N) ->\n\teqlsize' (eql'/f1 ([v] (E v))) (s N).\n\neqlsize'/f2 : ({v} {vl} eqlsize' (E v vl) N) ->\n\teqlsize' (eql'/f2 ([v] [vl] (E v vl))) (s N).\n\neqlsize'/v : eqlsize' (eql'/v _ _) z.\n\n\n\n%{ === Theorems about auxiliary definitions === }%\n\n\n%theorem false-implies-eql :\n\tforall* {T1} {T2} {N}\n\tforall\t{F:void}\n\texists\t{E:eql* N T1 T2}\n\ttrue.\n\n%worlds (blockvar | blocksimple) (false-implies-eql _ _).\n%total { }  (false-implies-eql _ _).\n\n\n%theorem eqlsize-total* :\n\tforall*\t{N} {T1} {T2}\n\tforall  {E:eql* N T1 T2}\n\texists  {S} {ES:eqlsize E S}\n\ttrue.\n\n%abbrev eqlsize-total = eqlsize-total* _ _.\n\n- : eqlsize-total eqlsize/eq.\n\n- : eqlsize-total (eqlsize/b ES)\n    <- eqlsize-total ES.\n\n- : eqlsize-total (eqlsize/f1 ([v] (ES v)))\n    <- ({v} eqlsize-total (ES v)).\n\n- : eqlsize-total (eqlsize/f2 ([v] [vl] (ES v vl)))\n    <- ({v} {vl} eqlsize-total (ES v vl)).\n\n- : eqlsize-total eqlsize/v.\n\n%worlds (blocksimple | blockvar) (eqlsize-total* _ _ _).\n%total (E)  (eqlsize-total* E _ _).\n\n\n%{\nThe following block is used when we remove the outmost variable:\nall other variables are at least level 2.  \"blockvar2\"\nmakes this context explicit.\n}%\n\n%block blockvar2 : some {l} block {v} {vl:varlevel v (s (s l))}.\n\n\n%theorem remove-one-var :\n\tforall* {F1} {F2} {N} {S}\n\tforall {E:{v} {vl:varlevel v (s z)} (eql* (s N) (F1 v) (F2 v))}\n\t       {ES:{v} {vl} eqlsize (E v vl) S}\n\texists {E':{v} (eql* (s N) (F1 v) (F2 v))}\n\t       {ES':{v} eqlsize (E' v) S}\n\ttrue.\n\n- : remove-one-var ([v] [vl] eql/eq eq/) ([v] [vl] eqlsize/eq)\n                   ([v] eql/eq eq/) ([v] eqlsize/eq).\n\n- : remove-one-var ([v] [vl] eql/b (F v vl)) ([v] [vl] eqlsize/b (FS v vl))\n                   ([v] eql/b (F' v)) ([v] eqlsize/b (FS' v))\n    <- remove-one-var F FS F' FS'.\n\n- : remove-one-var ([v] [vl] eql/f1 ([v'] (F v' v vl)))\n\t\t   ([v] [vl] eqlsize/f1 ([v'] (FS v' v vl)))\n                   ([v] eql/f1 ([v'] (F' v' v)))\n                   ([v] eqlsize/f1 ([v'] (FS' v' v)))\n    <- {v'} remove-one-var (F v') (FS v') (F' v') (FS' v').\n\n- : remove-one-var ([v] [vl] eql/f2 ([v'] [vl'] (F v' vl' v vl)))\n\t\t   ([v] [vl] eqlsize/f2 ([v'] [vl'] (FS v' vl' v vl)))\n                   ([v] eql/f2 ([v'] [vl'] (F' v' vl' v)))\n                   ([v] eqlsize/f2 ([v'] [vl'] (FS' v' vl' v)))\n    <- {v'} {vl'} remove-one-var (F v' vl') (FS v' vl') (F' v' vl') (FS' v' vl').\n- : remove-one-var ([v] [vl] eql/v vl vl) ([v] [vl] eqlsize/v)\n                   ([v] eql/eq eq/) ([v] eqlsize/eq).\n\n- : remove-one-var ([v] [vl] eql/v VL1 VL2) ([v] [vl] eqlsize/v)\n                   ([v] eql/v VL1 VL2) ([v] eqlsize/v).\n\n%worlds (blocksimple | blockvar2) (remove-one-var _ _ _ _).\n%total (E) (remove-one-var E _ _ _).\n\n\n%{\nNext follows the tortuous shift down of levels:\nwe shift down and change to use the alternative definitions,\nand then we go to back the normal definitions (with no shift).\nThe context we use will have both the old and new varlevels.\nIt order to shift from one to the other, we need theorems\nthat let us go from one to the other.  Unfortunately, Twelf\nis not smart enough to infer that the context has what the\ntheorem needs, so (as explained above) we need to put the theorem\nin context itself and add fake dependencies.\n\nAdding to the complexity is the fact that we need to track the\nsize of the equality rules for termination proof (later).\n}%\n\n\n%theorem varlevel-shifts-down :\n\tforall* {V} {L}\n\tforall\t{VL:varlevel V (s (s L))}\n\texists\t{VL':varlevel' V (s L)}\n\ttrue.\n\n%block shiftdown : some {l} block {v} {vl:varlevel v (s (s l))} \n                                      {vl':varlevel' v (s l)}\n                                      {vsd:varlevel-shifts-down vl vl'}.\n\nfake : type.\n- : fake <- ({x:varlevel-shifts-down X Y} varlevel-shifts-down X' Y').\n\n%worlds (blocksimple | shiftdown) (varlevel-shifts-down _ _).\n%total { } (varlevel-shifts-down _ _).\n\n\n%theorem shift-varlevel/L1 :\n\tforall* {N} {T1} {T2} {S}\n\tforall\t{E: eql* (s N) T1 T2}\n\t\t{ES:eqlsize E S}\n\texists\t{E': eql*' N T1 T2}\n\t\t{ES':eqlsize' E' S}\n\ttrue.\n\n- : shift-varlevel/L1 (eql/eq eq/) eqlsize/eq (eql'/eq eq/) eqlsize'/eq.\n\n- : shift-varlevel/L1 (eql/b E) (eqlsize/b ES) (eql'/b E') (eqlsize'/b ES')\n    <- shift-varlevel/L1 E ES E' ES'.\n\n- : shift-varlevel/L1 (eql/f1 ([v] (F v))) (eqlsize/f1 FS)\n                      (eql'/f1 ([v] (F' v))) (eqlsize'/f1 FS')\n    <- {v} shift-varlevel/L1 (F v) (FS v) (F' v) (FS' v).\n\n- : shift-varlevel/L1 (eql/f2 ([v] [vl:varlevel v (s (s N))] (F v vl)))\n\t\t      (eqlsize/f2 FS)\n                      (eql'/f2 ([v] [vl:varlevel' v (s N)] (F' v vl)))\n\t\t      (eqlsize'/f2 FS')\n    <- {v} {vl} {vl':varlevel' v (s N)} {vsd:varlevel-shifts-down vl vl'}\n       shift-varlevel/L1 (F v vl) (FS v vl) (F' v vl') (FS' v vl').\n\n- : shift-varlevel/L1 (eql/v VL1 VL2) eqlsize/v (eql'/v VL1' VL2') eqlsize'/v\n    <- varlevel-shifts-down VL1 VL1'\n    <- varlevel-shifts-down VL2 VL2'.\n\n%worlds (blocksimple | shiftdown) (shift-varlevel/L1 _ _ _ _).\n%total (E)  (shift-varlevel/L1 E _ _ _).\n\n\n%theorem varlevel-shifts-back :\n\tforall* {V} {L}\n\tforall\t{VL':varlevel' V (s L)}\n\texists\t{VL:varlevel V (s L)}\n\ttrue.\n\n%block shiftback : some {l} block {v} {vl':varlevel' v (s l)} \n                                      {vl:varlevel v (s l)}\n                                      {vsb:varlevel-shifts-back vl' vl}.\n\nfake : type.\n- : fake <- ({x:varlevel-shifts-back X Y} varlevel-shifts-back X' Y').\n\n%worlds (blocksimple | shiftback) (varlevel-shifts-back _ _).\n%total { } (varlevel-shifts-back _ _).\n\n\n%theorem shift-varlevel/L2 :\n\tforall* {N} {T1} {T2} {S}\n\tforall\t{E': eql*' N T1 T2}\n\t\t{ES': eqlsize' E' S}\n\texists\t{E: eql* N T1 T2}\n\t\t{ES: eqlsize E S}\n\ttrue.\n\n- : shift-varlevel/L2 (eql'/eq eq/) eqlsize'/eq (eql/eq eq/) eqlsize/eq.\n\n- : shift-varlevel/L2 (eql'/b E) (eqlsize'/b ES) (eql/b E') (eqlsize/b ES')\n    <- shift-varlevel/L2 E ES E' ES'.\n\n- : shift-varlevel/L2 (eql'/f1 ([v] (F v))) (eqlsize'/f1 FS)\n                      (eql/f1 ([v] (F' v))) (eqlsize/f1 FS')\n    <- {v} shift-varlevel/L2 (F v) (FS v) (F' v) (FS' v).\n\n- : shift-varlevel/L2 (eql'/f2 ([v] [vl:varlevel' v (s N)] (F v vl)))\n\t\t      (eqlsize'/f2 FS)\n                      (eql/f2 ([v] [vl:varlevel v (s N)] (F' v vl)))\n\t\t      (eqlsize/f2 FS')\n    <- {v} {vl'} {vl} {vsb:varlevel-shifts-back vl' vl}\n       shift-varlevel/L2 (F v vl') (FS v vl') (F' v vl) (FS' v vl).\n\n- : shift-varlevel/L2 (eql'/v VL1 VL2) eqlsize'/v (eql/v VL1' VL2') eqlsize/v\n    <- varlevel-shifts-back VL1 VL1'\n    <- varlevel-shifts-back VL2 VL2'.\n\n%worlds (blocksimple | shiftback) (shift-varlevel/L2 _ _ _ _).\n%total (E)  (shift-varlevel/L2 E _ _ _).\n\n\n%{\nNow we put these two parts in one that hides the alternative definitions.\n}%\n\n%theorem shift-varlevel :\n\tforall* {N} {T1} {T2} {S}\n\tforall\t{E: eql* (s N) T1 T2}\n\t\t{ES:eqlsize E S}\n\texists\t{E': eql* N T1 T2}\n\t\t{ES':eqlsize E' S}\n\ttrue.\n\n- : shift-varlevel E1 ES1 E3 ES3\n    <- shift-varlevel/L1 E1 ES1 E2 ES2\n    <- shift-varlevel/L2 E2 ES2 E3 ES3.\n\n%worlds (blocksimple) (shift-varlevel _ _ _ _).\n%total { } (shift-varlevel _ _ _ _).\n\n\n%{\nThe following two theorems relate structural equality with\nidentity based equality.  One of them is called \"Leibnitz\" equality,\nI have heard, but apparently haven't remembered which one.\n}%\n\n\n%theorem b-preserves-eq :\n\tforall* {T1} {T2}\n\tforall\t{E:eq T1 T2}\n\texists\t{BE:eq (b T1) (b T2)}\n\ttrue.\n\n- : b-preserves-eq eq/ eq/.\n\n%worlds (blocksimple) (b-preserves-eq _ _).\n%total { } (b-preserves-eq _ _).\n\n\n%theorem f-preserves-eq :\n\tforall* {F1} {F2}\n\tforall {E:{v} eq (F1 v) (F2 v)}\n\texists\t{E:eq (f F1) (f F2)}\n\ttrue.\n\n- : f-preserves-eq ([v] eq/) eq/.\n\n%worlds (blocksimple) (f-preserves-eq _ _).\n%total { } (f-preserves-eq _ _).\n\n\n%{\nNext the main lemma that says we can avoid looking at varlevels in checking\nequality.  We remove the outside variable, shift remaining variables,\nand then recurse (hence the need for tracking eqlsize).  Note that we\nnever put var levels in the context.\n}%\n\n%theorem eql-implies-eq :\n\tforall* {T1} {T2}\n\tforall\t{E:eql T1 T2}\n\texists\t{E':eq T1 T2}\n\ttrue.\n\n%theorem eql-implies-eq/L :\n\tforall* {T1} {T2}\n\tforall\t{E:eql T1 T2} \n\t\t{S} {ES:eqlsize E S}\n\texists\t{E':eq T1 T2}\n\ttrue.\n\n- : eql-implies-eq/L (eql/eq E) _ _ E.\n\n- : eql-implies-eq/L (eql/b E1) _ (eqlsize/b ES) E'\n    <- eql-implies-eq/L E1 _ ES E1'\n    <- b-preserves-eq E1' E'.\n\n- : eql-implies-eq/L (eql/f1 ([v] (E1 v))) _ (eqlsize/f1 FS) E'\n    <- ({v} eql-implies-eq/L (E1 v) _ (FS v) (E1' v))\n    <- f-preserves-eq E1' E'.\n\n- : eql-implies-eq/L (eql/f2 ([v] [vl] (F1 v vl))) _ (eqlsize/f2 FS1) E'\n    <- remove-one-var F1 FS1 ([v] (F2 v)) FS2\n    <- ({v} shift-varlevel (F2 v) (FS2 v) (F3 v) (FS3 v))\n    <- ({v} eql-implies-eq/L (F3 v) _ (FS3 v) (F4 v))\n    <- f-preserves-eq F4 E'.\n\n%worlds (blocksimple) (eql-implies-eq/L _ _ _ _).\n%total (S) (eql-implies-eq/L _ S _ _).\n\n- : eql-implies-eq E E'\n    <- eqlsize-total ES\n    <- eql-implies-eq/L E _ ES E'.\n\n%worlds (blocksimple) (eql-implies-eq _ _).\n%total { } (eql-implies-eq _ _).\n\n\n%{ === Main Theorem === }%\n\n%{\nFinally the statement of the main theorem of this section.\nIt is proved by using eql as a between station.  In this case,\nwe do have var levels in the context.  This theorem (or rather \nits main lemma) uses reasoning-from-false extensively because the\ncases cannot be distinguished by Twelf's case analysis.\nIt also uses the \"divrem\" part of the nat signature extensively\nas well as theorems about plus and times.  The proofs of the cases are\nuninteresting arithmetic fiddling.\n}%\n\n\n%theorem tonat-one2one :\n\tforall*\t{T1} {N1} {T2} {N2}\n\tforall\t{TN1:tonat T1 N1}\n\t\t{TN2:tonat T2 N2}\n\t\t{E:nat`eq N1 N2}\n\texists\t{ET:eq T1 T2}\n\ttrue.\n\n%theorem tonat-one2one/L :\n\tforall*\t{N} {T1} {M1} {T2} {M2}\n\tforall\t{TN1:tonat* N T1 M1}\n\t\t{TN2:tonat* N T2 M2}\n\t\t{E:nat`eq M1 M2}\n\texists\t{ET:eql* N T1 T2}\n\ttrue.\n\n- : tonat-one2one/L tonat/a tonat/a _ (eql/eq eq/).\n\n- : tonat-one2one/L tonat/a (tonat/b _ _ N+1+TM=N) nat`eq/ E\n    <- plus-swap-succ N+1+TM=N N+TM+1=N\n    <- plus-commutative N+TM+1=N TM+1+N=N\n    <- plus-implies-gt TM+1+N=N nat`eq/ N>N\n    <- gt-anti-reflexive N>N F\n    <- false-implies-eql F E.\n\n- : tonat-one2one/L (tonat/b _ _ N+1+TM=N) tonat/a nat`eq/ E\n    <- plus-swap-succ N+1+TM=N N+TM+1=N\n    <- plus-commutative N+TM+1=N TM+1+N=N\n    <- plus-implies-gt TM+1+N=N nat`eq/ N>N\n    <- gt-anti-reflexive N>N F\n    <- false-implies-eql F E.\n\n- : tonat-one2one/L tonat/a (tonat/f _ _ N+2+TM=N) nat`eq/ E\n    <- plus-swap-succ N+2+TM=N N+1+TM+1=N\n    <- plus-swap-succ N+1+TM+1=N N+TM+2=N\n    <- plus-commutative N+TM+2=N TM+2+N=N\n    <- plus-implies-gt TM+2+N=N nat`eq/ N>N\n    <- gt-anti-reflexive N>N F\n    <- false-implies-eql F E.\n\n- : tonat-one2one/L (tonat/f _ _ N+2+TM=N) tonat/a nat`eq/ E\n    <- plus-swap-succ N+2+TM=N N+1+TM+1=N\n    <- plus-swap-succ N+1+TM+1=N N+TM+2=N\n    <- plus-commutative N+TM+2=N TM+2+N=N\n    <- plus-implies-gt TM+2+N=N nat`eq/ N>N\n    <- gt-anti-reflexive N>N F\n    <- false-implies-eql F E.\n\n- : tonat-one2one/L tonat/a (tonat/v VL N+L=N) nat`eq/ E\n    <- plus-right-identity N N+0=N\n    <- plus-left-cancels N+L=N N+0=N nat`eq/ nat`eq/ L=0\n    <- varlevel-contradiction VL L=0 F\n    <- false-implies-eql F E.\n\n- : tonat-one2one/L (tonat/v VL N+L=N) tonat/a nat`eq/ E\n    <- plus-right-identity N N+0=N\n    <- plus-left-cancels N+L=N N+0=N nat`eq/ nat`eq/ L=0\n    <- varlevel-contradiction VL L=0 F\n    <- false-implies-eql F E.\n\n- : tonat-one2one/L (tonat/b TN1 TWO*M1=TM1 N+1+TM1=M)\n                    (tonat/b TN2 TWO*M2=TM2 N+1+TM2=M) nat`eq/ (eql/b E)\n    <- plus-left-cancels N+1+TM1=M N+1+TM2=M nat`eq/ nat`eq/ TM1=TM2\n    <- times-left-cancels TWO*M1=TM1 TWO*M2=TM2 nat`eq/ TM1=TM2 M1=M2\n    <- tonat-one2one/L TN1 TN2 M1=M2 E.\n\n- : tonat-one2one/L (tonat/b _ TWO*M1=TM1 N+1+TM1=M) \n                    (tonat/f _ TWO*M2=TM2 N+2+TM2=M)\n                    nat`eq/ E\n    <- plus-swap-succ N+2+TM2=M N+1+TM2+1=M\n    <- plus-left-cancels N+1+TM1=M N+1+TM2+1=M nat`eq/ nat`eq/ TM1=TM2+1\n    <- times-commutative TWO*M1=TM1 M1*2=TM1\n    <- plus-right-identity _ TM1+0=TM1\n    <- divrem-can-be-constructed M1*2=TM1 TM1+0=TM1 (gt/> gt/1) TM1/2=M1,0\n    <- times-commutative TWO*M2=TM2 M2*2=TM2\n    <- nat`eq-symmetric TM1=TM2+1 TM2+1=TM1\n    <- plus-respects-eq (plus/s plus/z) nat`eq/ nat`eq/ TM2+1=TM1 ONE+TM2=TM1\n    <- plus-commutative ONE+TM2=TM1 TM2+ONE=TM1\n    <- divrem-can-be-constructed M2*2=TM2 TM2+ONE=TM1 gt/1 TM1/2=M2,1\n    <- divrem-deterministic TM1/2=M1,0 TM1/2=M2,1 nat`eq/ nat`eq/ _ ZERO=ONE\n    <- nat`eq-contradiction ZERO=ONE F\n    <- false-implies-eql F E.\n\n- : tonat-one2one/L (tonat/f _ TWO*M2=TM2 N+2+TM2=M)\n                    (tonat/b _ TWO*M1=TM1 N+1+TM1=M) nat`eq/ E\n    <- plus-swap-succ N+2+TM2=M N+1+TM2+1=M\n    <- plus-left-cancels N+1+TM1=M N+1+TM2+1=M nat`eq/ nat`eq/ TM1=TM2+1\n    <- times-commutative TWO*M1=TM1 M1*2=TM1\n    <- plus-right-identity _ TM1+0=TM1\n    <- divrem-can-be-constructed M1*2=TM1 TM1+0=TM1 (gt/> gt/1) TM1/2=M1,0\n    <- times-commutative TWO*M2=TM2 M2*2=TM2\n    <- nat`eq-symmetric TM1=TM2+1 TM2+1=TM1\n    <- plus-respects-eq (plus/s plus/z) nat`eq/ nat`eq/ TM2+1=TM1 ONE+TM2=TM1\n    <- plus-commutative ONE+TM2=TM1 TM2+ONE=TM1\n    <- divrem-can-be-constructed M2*2=TM2 TM2+ONE=TM1 gt/1 TM1/2=M2,1\n    <- divrem-deterministic TM1/2=M1,0 TM1/2=M2,1 nat`eq/ nat`eq/ _ ZERO=ONE\n    <- nat`eq-contradiction ZERO=ONE F\n    <- false-implies-eql F E.\n\n- : tonat-one2one/L (tonat/b _ _ N+1+TM=M) (tonat/v _ M+L=N) nat`eq/ E\n    <- plus-swap-succ N+1+TM=M N+TM+1=M\n    <- plus-commutative N+TM+1=M TM+1+N=M\n    <- plus-implies-gt TM+1+N=M nat`eq/ M>N\n    <- plus-commutative M+L=N L+M=N\n    <- plus-implies-ge L+M=N N>=M\n    <- nat`gt-transitive-ge M>N N>=M M>M\n    <- nat`gt-anti-reflexive M>M F\n    <- false-implies-eql F E.\n\n- : tonat-one2one/L (tonat/v _ M+L=N) (tonat/b _ _ N+1+TM=M) nat`eq/ E \n    <- plus-swap-succ N+1+TM=M N+TM+1=M\n    <- plus-commutative N+TM+1=M TM+1+N=M\n    <- plus-implies-gt TM+1+N=M nat`eq/ M>N\n    <- plus-commutative M+L=N L+M=N\n    <- plus-implies-ge L+M=N N>=M\n    <- nat`gt-transitive-ge M>N N>=M M>M\n    <- nat`gt-anti-reflexive M>M F\n    <- false-implies-eql F E.\n\n- : tonat-one2one/L (tonat/f ([v] [vl] (F1 v vl)) TWO*M1=TM1 N+2+TM1=M) \n                    (tonat/f ([v] [vl] (F2 v vl)) TWO*M2=TM2 N+2+TM2=M)\n                    nat`eq/ (eql/f2 FE)\n    <- plus-left-cancels N+2+TM1=M N+2+TM2=M nat`eq/ nat`eq/ TM1=TM2\n    <- times-left-cancels TWO*M1=TM1 TWO*M2=TM2 nat`eq/ TM1=TM2 M1=M2\n    <- ({v} {vl:varlevel v (s N)} \n        tonat-one2one/L (F1 v vl) (F2 v vl) M1=M2 (FE v vl)).\n\n- : tonat-one2one/L (tonat/f _ _ N+2+TM=M) (tonat/v _ M+L=N) nat`eq/ E\n    <- plus-swap-succ N+2+TM=M N+1+TM+1=M\n    <- plus-swap-succ N+1+TM+1=M N+TM+2=M\n    <- plus-commutative N+TM+2=M TM+2+N=M\n    <- plus-implies-gt TM+2+N=M nat`eq/ M>N\n    <- plus-commutative M+L=N L+M=N\n    <- plus-implies-ge L+M=N N>=M\n    <- nat`gt-transitive-ge M>N N>=M M>M\n    <- nat`gt-anti-reflexive M>M F\n    <- false-implies-eql F E.\n\n- : tonat-one2one/L (tonat/v _ M+L=N) (tonat/f _ _ N+2+TM=M) nat`eq/ E \n    <- plus-swap-succ N+2+TM=M N+1+TM+1=M\n    <- plus-swap-succ N+1+TM+1=M N+TM+2=M\n    <- plus-commutative N+TM+2=M TM+2+N=M\n    <- plus-implies-gt TM+2+N=M nat`eq/ M>N\n    <- plus-commutative M+L=N L+M=N\n    <- plus-implies-ge L+M=N N>=M\n    <- nat`gt-transitive-ge M>N N>=M M>M\n    <- nat`gt-anti-reflexive M>M F\n    <- false-implies-eql F E.\n\n- : tonat-one2one/L (tonat/v VL1 M+L1=N) (tonat/v VL2 M+L2=N) nat`eq/ \n\t\t     (eql/v VL1' VL2)\n    <- plus-left-cancels M+L1=N M+L2=N nat`eq/ nat`eq/ L1=L2\n    <- varlevel-respects-eq VL1 L1=L2 VL1'.\n\n%worlds (blockvar) (tonat-one2one/L _ _ _ _).\n%total (T) (tonat-one2one/L T _ _ _).\n\n- : tonat-one2one TN1 TN2 EQ TEQ\n    <- tonat-one2one/L TN1 TN2 EQ EQL\n    <- eql-implies-eq EQL TEQ.\n\n%worlds () (tonat-one2one _ _ _ _).\n%total { } (tonat-one2one _ _ _ _)."
          },
          "sha1": "0dw1061i7cx8chk4mwpo3g4ykds1t9w"
        }
      },
      {
        "title": "Hauptsatz",
        "ns": 0,
        "id": 1787,
        "redirect": {
          "@title": "Admissibility of cut",
          "#text": null
        },
        "revision": {
          "id": 3248,
          "timestamp": "2006-10-30T20:02:25Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "comment": "until we have de.twelf.plparty.org ;)",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 34,
            "#text": "#REDIRECT [[Admissibility of cut]]"
          },
          "sha1": "5kfbkue2jgh2dmpbwo4l9modeajuvw5"
        }
      },
      {
        "title": "Hereditary substitution",
        "ns": 0,
        "id": 1969,
        "revision": {
          "id": 6515,
          "parentid": 4506,
          "timestamp": "2012-02-02T21:36:30Z",
          "contributor": {
            "username": "Rowandavies",
            "id": 892
          },
          "comment": "Fixed minor typo in example: final answer is z not y.",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 1490,
            "#text": "[[LF]] is defined so that only [[canonical form]]s exist.  However, canonical forms are not closed under substitution.  '''Hereditary substitution''' is an algorithm that directly computes the canonical result of an ordinary substiution of one canonical form into another.  This algorithm has been applied in several additional type theories as well.\n\n{{needs|citations of said type theories.}}\n\n== Example ==\n\nSubstitution <math>\\mathsf{}[M'/x]M</math> of one canonical form into another does not necessarily produce a canonical result.  For example:\n\n<math>\\mathsf{}[\\lambda y.y/x](x \\; z)  \\; = \\;(\\lambda y.y) \\; z</math>\n\nEven though both terms are canonical forms, the result is [[beta-equivalence|beta-reducible]].  \n\nHowever, ''hereditary substitution'' directly computes the canonical result of an ordinary substitution.  When ordinary substitution would return a non-canonical form, hereditary substitution continues to reduce by substituting the argument into the body of the function.  In the above example, the hereditary substitution \n\n<math>\\mathsf{}[\\lambda y.y/x](x \\; z)  \\; = \\; [z/y] y \\; = \\; z </math>\n\nWhenever we use the notation <math>\\mathsf{}[M'/x]M</math> for LF, we mean hereditary substitution.\n\n{{needs|an explanation of the hereditary substitution algorithm and its metatheory.}}\n\n== See also ==\n* The tutorial on [[hereditary substitution for the STLC]] formalizes the hereditary substitution algorithm for a simply typed lambda-calculus in Twelf.\n\n{{stub}}"
          },
          "sha1": "dvinvj9cwc25c2dxkltxci0ztsqhp80"
        }
      },
      {
        "title": "Hereditary substitution for the STLC",
        "ns": 0,
        "id": 1910,
        "revision": {
          "id": 6143,
          "parentid": 6129,
          "timestamp": "2010-09-20T15:03:58Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "forwarding pointer",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 35247,
            "#text": "''You may wish to read the tutorial on [[admissibility of cut]] and/or the article on [[verifications and uses]] first.''\n\nIn this tutorial, we recast the proof of cut admissibility as an algorithm for normalizing terms in the simply-typed λ-calculus.  This algorithm is called ''hereditary substitution''; it is used in the definition of LF itself, as well as in many other type theories.  To apply hereditary substitution, it is necessary to:\n# Define a language of [[canonical form]]s.  In programming language terms, canonical forms correspond to terms that are not β-reducible ([[beta-normal]]) and then are η-expanded as much as possible ([[eta-long]]); logically, canonical forms correspond to the cut-free sequent calculus proofs.\n# Define hereditary substitution, which computes the canonical result of substituting one canonical form into another.  In programming language terms, hereditary substitution is part of a normalization algorithm; logically, it is the computational content of the proof of cut admissibility.\n# Define an eta-expansion judgement.  In programming language terms, eta-expansion is part of a normalization algorithm; logically, it is the computational content of the identity theorem (<math>\\Gamma,A \\Rightarrow A</math>).  \n# Define an external language that admits non-canonical forms by elaboration into the canonical forms.  In programming language terms, this elaboration relation corresponds to a normalization algorithm; logically, it is the computational content of the proof of cut elimination.  \n\nIn this article, we formalize hereditary substitution and elaboration in Twelf.  We prove several results:\n# It is decidable whether or not a hereditary substitution exists.  (This property is proved automatically by Twelf.)\n# Under the appropriate typing conditions, hereditary substitutions exist and preserve types.  Moreover, hereditary substitutions compute a unique result.\n# Eta-expansions exist, preserve types, and are unique.\n# All well-typed non-canonical forms elaborate to a canonical form of the same type.\n\nThis example brings together a number of Twelf proof techniques: \n* using [[%reduces]] for termination \n* [[mutual induction]] and [[lexicographic induction]]\n* reasoning with [[equality]] and [[respects lemma]]s\n* proving [[uniqueness lemma]]s\n* [[output factoring]]\n* [[reasoning from false]]\n* [[catch-all case]]s.\nYou may wish to read the individual tutorials on these techniques before reading this example.\n \nThe canonical forms language is described on this page; the external language and elaboration are described on the [[Hereditary substitution for the STLC (part 2)|next page]].  \n\n'''Experience report ([[User:Drl|DRL]]):''' ''This tutorial might seem like it takes a lot of Twelf code.  At the time I wrote this code, I was an experienced Twelf user and familiar with the basic ideas of the canonical forms approach.  However, I hadn't gone through the details of these proofs before (that's why I wrote the code).  That said, it took no more than a work-day to work out and formalize the metatheory the canonical forms approach (everything on this page), and no more than another day to do the elaboration on the next page.''\n\n== Canonical forms language: syntax and judgements ==\n\n=== Syntax ===\n\nWe consider a calculus with function and pair types, as well as a single base type:\n\n<twelf>\ntp : type.\n\nb : tp.\narrow : tp -> tp -> tp.\nprod : tp -> tp -> tp.\n\nrtm : type.\nmtm : type.\n\napp : rtm -> mtm -> rtm.\nc : rtm.\nfst : rtm -> rtm.\nsnd : rtm -> rtm.\n\nasm : rtm -> mtm.\nlam : (rtm -> mtm) -> mtm.\npair : mtm -> mtm -> mtm.\n\n%block rtm_block : block {x : rtm}.\n%worlds (rtm_block) (tp) (rtm) (mtm).\n</twelf>\n\nThe syntax of types is standard.  There are a few subtleties in the syntax of terms:\n* The syntax of terms is stratified into atomic terms <tt>rtm</tt> and canonical terms <tt>mtm</tt> in order to syntactically prevent β-redices.  For example, pairs are canonical but the argument of a projection (<tt>fst</tt> and <tt>snd</tt>) is atomic, so we can never project from a term that is syntactically a pair.  \n* We name the syntactic classes <tt>rtm</tt> and <tt>mtm</tt> after the metavariables <tt>R</tt> and <tt>M</tt> that we will use to refer to them.\n* Because variables are considered to be atomic terms, the body of a <tt>lam</tt> binds a variable of type <tt>rtm</tt>.  This means that the substitution operation that we get \"for free\" from the encoding is only the substitution of an <tt>rtm</tt> for a variable; hereditary substitution defines the substitution of an  <tt>mtm</tt> for a variable.\n* The constant <tt>asm</tt> represents an injection from <tt>rtm</tt> into <tt>mtm</tt>.\n\n=== Typing judgements ===\n\n<twelf>\natom : rtm -> tp -> type.\n%mode atom +X1 -X2.\n\ncanon : mtm -> tp -> type.\n%mode canon +X1 +X2.\n\n% atomic \n\natom_c : atom c b.\n\natom_app : atom (app R1 M2) A\n            <- atom R1 (arrow A2 A)\n            <- canon M2 A2.\n\natom_fst : atom (fst R) A1\n            <- atom R (prod A1 A2).\n\natom_snd : atom (snd R) A2\n            <- atom R (prod A1 A2).\n\n%% canonical \n\ncanon_asm : canon (asm R) b\n             <- atom R b.\n\ncanon_lam : canon (lam M) (arrow A2 A)\n             <- {x : rtm} (atom x A2) ->  canon (M x) A.\n\ncanon_pair : canon (pair M1 M2) (prod A1 A2)\n              <- canon M1 A1\n              <- canon M2 A2.\n\n%block atom_block : some {A:tp}\n                     block {x:rtm} {dx : atom x A}. \n%worlds (atom_block) (atom _ _) (canon _ _).\n%terminates (R M) (atom R _) (canon M _).\n</twelf>\n\nWe define two mutually-recursive judgements, <tt>atom R A</tt> and <tt>canon M A</tt>.  The typing judgements for the two syntactic categories have a bidirectional operational interpretation: an <tt>mtm</tt> is checked against a type, whereas an <tt>rtm</tt> synthesizes a type.  The rules are the standard typing rules for the λ-calculus,  modified to follow the restrictions of the syntax.  Additionally, the rule <tt>canon_asm</tt> applies only at base type, which forces an <tt>mtm</tt> to be η-long.\n\nThese judgements are manifestly terminating, which we verify with the <tt>%terminates</tt>.\n\n=== Hereditary substitution ===\n\nWe define three hereditary substitution judgements:\n* <tt>hsubst_m M0 A0 ([x0] M) M'</tt>: compute the canonical form <tt>M'</tt> of substituting <tt>M0</tt> for <tt>x0</tt> in <tt>M</tt>.  <tt>A0</tt> should be the type of <tt>M0</tt>; it is used to show that hereditary substitution is decidable.  \n* <tt>hsubst_r M0 A0 ([x0] R) R'</tt>: compute the atomic term <tt>R'</tt> resulting from substituting <tt>M0</tt> for <tt>x0</tt> in <tt>R</tt>.  This judgement applies when <tt>x0</tt> is not the head variable of the atomic term <tt>R</tt>.\n* <tt>hsubst_rr M0 A0 ([x0] R) M' A'</tt>: compute a new canonical form term <tt>M'</tt> resulting from substituting <tt>M0</tt> for <tt>x0</tt> in <tt>R</tt>.  This judgement applies when <tt>x0</tt> is the head variable of <tt>R</tt>.\n\nThe head variable of an atomic term <tt>R</tt> is the variable at the root of a series of eliminations.  E.g., the head of <tt>fst (app x c)</tt> is <tt>x</tt>.  When a canonical form is substituted for a head variable, hereditary substitution continues reducing.  E.g., the following judgement is derivable:\n\n<twelf discard=true>\nhsubst_rr \n (lam ([x] (pair c c)))\n (arrow b (prod b b)) \n ([x] fst (app x c))\n c\n b\n</twelf>\n\nIntuitively, we substitute  <tt>(lam ([x] (pair c c)))</tt> to get <tt>fst (app (lam ([x] (pair c c))) c)</tt> and then reduce this to <tt>c</tt>.  \n\n<tt>hsubst_rr</tt> also computes the type of the canonical form it produces, which is needed for the termination metric for hereditary substitution. \n\nHere are the judgements:\n\n<twelf>\nhsubst_m : mtm -> tp -> (rtm -> mtm) -> mtm -> type.\n%mode hsubst_m +X1 +X2 +X3 -X4.\n\nhsubst_r : mtm -> tp -> (rtm -> rtm) -> rtm -> type.\n%mode hsubst_r +X1 +X2 +X3 -X4.\n\nhsubst_rr : mtm -> tp -> (rtm -> rtm) -> mtm -> tp -> type.\n%mode hsubst_rr +X1 +X2 +X3 -X4 -X5.\n\n%% Ms\n\nhsubst_m_r : hsubst_m M0 A0 ([x] asm (R x)) (asm R')\n              <- hsubst_r M0 A0 R R'.\n\nhsubst_m_rr : hsubst_m M0 A0 ([x] asm (R x)) M'\n               <- hsubst_rr M0 A0 R M' _.\n\nhsubst_m_lam : hsubst_m M0 A0 ([x] (lam ([y] M x y))) (lam M')\n                <- ({y:rtm} \n                      hsubst_m M0 A0 ([x] M x y) (M' y)).\n\nhsubst_m_pair : hsubst_m M0 A0 ([x] (pair (M1 x) (M2 x))) (pair M1' M2')\n                 <- hsubst_m M0 A0 M1 M1'\n                 <- hsubst_m M0 A0 M2 M2'.\n\n%% R not head\n\nhsubst_r_closed : hsubst_r M0 A0 ([x] E) E.\n\nhsubst_r_app : hsubst_r M0 A0 ([x] (app (R x) (M x))) (app R' M')\n                <- hsubst_r M0 A0 R R'\n                <- hsubst_m M0 A0 M M'.\n\nhsubst_r_fst : hsubst_r M0 A0 ([x] (fst (R x))) (fst R')\n                <- hsubst_r M0 A0 R R'.\n\nhsubst_r_snd : hsubst_r M0 A0 ([x] (snd (R x))) (snd R')\n                <- hsubst_r M0 A0 R R'.\n\n%% r head\n\nhsubst_rr_var : hsubst_rr M0 A0 ([x] x) M0 A0.\n\nhsubst_rr_app : hsubst_rr M0 A0 ([x] app (R1 x) (M2 x)) M'' A\n                 <- hsubst_rr M0 A0 R1 (lam M') (arrow A2 A)\n                 <- hsubst_m M0 A0 M2 M2'\n                 <- hsubst_m M2' A2 M' M''.\n\nhsubst_rr_fst : hsubst_rr M0 A0 ([x] (fst (R x))) M1' A1'\n                 <- hsubst_rr M0 A0 R (pair M1' M2') (prod A1' A2').\n\nhsubst_rr_snd : hsubst_rr M0 A0 ([x] (snd (R x))) M2' A2'\n                 <- hsubst_rr M0 A0 R (pair M1' M2') (prod A1' A2').\n\n%worlds (rtm_block) (hsubst_m _ _ _ _) (hsubst_r _ _ _ _) (hsubst_rr _ _ _ _ _).\n%reduces A' <= A0 (hsubst_rr _ A0 _ _ A').\n%terminates {(A0 A0' A0'') (M R R')} (hsubst_m _ A0 M _) (hsubst_r _ A0' R _) (hsubst_rr _ A0'' R' _ _).\n</twelf>\n\nThe rule <tt>hsubst_r_closed</tt> is similar to a [[catch-all case]]: rather than putting cases of hereditary substitution into the LF context, we give a single rule that applies whenever the variable is not free in the term we are substituting into.  This covers both the variables <tt>y:rtm</tt> in the context and the constant <tt>c</tt>, as well as any series of applications or projections made up from these terms—so the downside is that we have made hereditary substitution non-deterministic.  However, keeping hereditary substitution out of the context simplifies some proofs below.\n\nOther than that, the judgements <tt>hsubst_m</tt> and <tt>hsubst_r</tt> are defined in the straightforward compositional manner.  The interesting judgement is <tt>hsubst_rr</tt>, which in each case performs some reduction on the output of the recursive call in order to compute a new canonical form.  The most interesting rule is <tt>hsubst_rr_app</tt>, which continues the hereditary substitution into the body of the function.\n\nWhen processing the <tt>%terminates</tt> declaration, Twelf proves that it is decidable whether or not a hereditary substitution exists: the hereditary substitution judgements define a terminating logic program.  The auxiliary <tt>%reduces</tt> proves that the result type of <tt>hsubst_rr</tt> is always a subterm of the type of the term being substituted for. This is true because <tt>hsubst_rr</tt> only applies when the cut variable is the head of a sequence of eliminations, and applying one of these elimination forms always decreases the type of the term.  With this reduces information, we check that the hereditary substitution judgements terminate by mutual lexicographic induction—mutual because we show termination for all three judgements simultaneously, and lexicographic because, in each case, the termination metric is first the type of the substituted term, and then the term being substituted into.  This metric is expressed in Twelf by writing <tt><nowiki>{(A0 A0' A0'') (M R R')}</nowiki></tt>.  The curly-braces mean lexicographic induction; the parentheses mean mutual induction.\n\n=== Expansion ===\n\nExpansion shows that we can turn an atomic term of any type into a canonical term of that type.  It is a total judgement defined by induction on the structure of the type:\n\n<twelf>\nexpand : tp -> rtm -> mtm -> type.\n%mode expand +X1 +X2 -X3.\n\nexpand_b : expand b R (asm R).\n\nexpand_arrow : expand (arrow A2 A) R (lam M)\n                <- ({x : rtm} expand A2 x (M2 x))\n                <- ({x : rtm} expand A (app R (M2 x)) (M x)).\n\nexpand_prod : expand (prod A1 A2) R (pair M1 M2)\n               <- expand A1 (fst R) M1\n               <- expand A2 (snd R) M2.\n\n%worlds (rtm_block) (expand _ _ _).\n%total A (expand A _ _).\n</twelf>\n\nIn the <tt>expand_arrow</tt> case, we first expand a variable at the argument type, and then we expand the application at the result type.\n\n== Canonical forms language: Metatheory ==\n\n=== Hereditary substitution ===\n\n==== Existence of hereditary substitution====\n\nEven though we annotated <tt>hsubst_rr</tt> with a [[%reduces]] above, we will need an [[effectiveness lemma]] version of this [[%reduces]] to use that fact in the proof below.\n\n{{needs|to figure out if there's a way to avoid this}}\n\n<twelf>\nhsubst_rr_size : {A2} {A'} hsubst_rr M2 A2 R M' A'\n                    -> type.\n%mode hsubst_rr_size +X1 +X2 +X3.\n\n- : hsubst_rr_size \n     A2 A2 hsubst_rr_var.\n\n- : hsubst_rr_size\n     A2 A4 (hsubst_rr_app _ _ Drr)\n     <- hsubst_rr_size A2 (arrow A3 A4) Drr.\n\n- : hsubst_rr_size\n     A2 Al (hsubst_rr_fst Drr)\n     <- hsubst_rr_size A2 (prod Al Ar) Drr.\n\n- : hsubst_rr_size\n     A2 Ar (hsubst_rr_snd Drr)\n     <- hsubst_rr_size A2 (prod Al Ar) Drr.\n\n%worlds (rtm_block) (hsubst_rr_size _ _ _).\n%total D (hsubst_rr_size _ _ D).\n%reduces A' <= A2 (hsubst_rr_size A2 A' _).\n</twelf>\nAll the terms are inputs; the only output is the <tt>%reduces</tt>.\n\nThe main theorem proves that under the appropriate typing conditions, hereditary substitutions exist and preserve types.  For atomic terms, this means that one of the two kinds of hereditary substitutions exists.  Thus, we define the following sum type:\n\n<twelf> \nhsubst_r_exists_sum : mtm -> tp -> (rtm -> rtm) -> tp -> type.\nhsubst_r_exists_sum_r : hsubst_r_exists_sum M2 A2 R A\n                         <- hsubst_r M2 A2 R R'\n                         <- atom R' A.\nhsubst_r_exists_sum_rr : hsubst_r_exists_sum M2 A2 R A'\n                          <- hsubst_rr M2 A2 R M' A'\n                          <- canon M' A'.\n</twelf>\n\nBecause we are proving a theorem that concludes a disjunction, it should not be surprising that we need some [[output factoring]] lemmas.  The following lemmas may be proved independently:\n\n<twelf>\nhsubst_m_exists_asm :  hsubst_r_exists_sum M2 A2 R b\n                       -> hsubst_m M2 A2 ([x] (asm (R x))) M'\n                       -> canon M' b\n                       -> type.\n%mode hsubst_m_exists_asm +X1 -X2 -X3.\n\n- : hsubst_m_exists_asm \n     (hsubst_r_exists_sum_r DaR' DsR)\n     (hsubst_m_r DsR)\n     (canon_asm DaR').\n\n- : hsubst_m_exists_asm \n     (hsubst_r_exists_sum_rr DcM' DsR)\n     (hsubst_m_rr DsR)\n     DcM'.\n\n%worlds (atom_block) (hsubst_m_exists_asm _ _ _).\n%total {} (hsubst_m_exists_asm _ _ _).\n\n\nhsubst_r_exists_fst : hsubst_r_exists_sum M2 A2 R (prod Al Ar)\n                       -> hsubst_r_exists_sum M2 A2 ([x] (fst (R x))) Al\n                       -> type.\n%mode hsubst_r_exists_fst +X1 -X2.\n\n- : hsubst_r_exists_fst \n     (hsubst_r_exists_sum_r DaR' DsR)\n     (hsubst_r_exists_sum_r (atom_fst DaR') (hsubst_r_fst DsR)).\n\n- : hsubst_r_exists_fst \n     (hsubst_r_exists_sum_rr (canon_pair _ DcMl') DsR)\n     (hsubst_r_exists_sum_rr DcMl' (hsubst_rr_fst DsR)).\n\n%worlds (atom_block) (hsubst_r_exists_fst _ _).\n%total {} (hsubst_r_exists_fst _ _).\n\n\nhsubst_r_exists_snd : hsubst_r_exists_sum M2 A2 R (prod Al Ar)\n                       -> hsubst_r_exists_sum M2 A2 ([x] (snd (R x))) Ar\n                       -> type.\n%mode hsubst_r_exists_snd +X1 -X2.\n\n- : hsubst_r_exists_snd \n     (hsubst_r_exists_sum_r DaR' DsR)\n     (hsubst_r_exists_sum_r (atom_snd DaR') (hsubst_r_snd DsR)).\n\n- : hsubst_r_exists_snd \n     (hsubst_r_exists_sum_rr (canon_pair DcMr' _) DsR)\n     (hsubst_r_exists_sum_rr DcMr' (hsubst_rr_snd DsR)).\n\n%worlds (atom_block) (hsubst_r_exists_snd _ _).\n%total {} (hsubst_r_exists_snd _ _).\n</twelf>\n\nNext, we prove the overall theorems, as well as a factoring lemma for application.  This last factoring lemma \nmust be in the mutually recursive loop with the main theorems because of the final premise of <tt>hsubst_rr_app</tt>, which continues the hereditary substitution.  \n\n<twelf>\nhsubst_m_exists : {A2}\n                   ({y : rtm} {dy : atom y A2} canon (M y) A)\n                   -> canon M2 A2\n                   -> hsubst_m M2 A2 M M'\n                   -> canon M' A\n                   -> type.\n%mode hsubst_m_exists +X0 +X1 +X2 -X3 -X4.\n\nhsubst_r_exists : {A2}\n                   ({y : rtm} {dx : atom y A2} atom (R y) A)\n                   -> canon M2 A2\n                   -> hsubst_r_exists_sum M2 A2 R A\n                   -> type.\n%mode hsubst_r_exists +X0 +X1 +X2 -X3.\n\nhsubst_m_exists_app : {A2}\n                       %% this next argument is makes the termination argument work\n                       ({y : rtm} {dx : atom y A2} atom (R1 y) (arrow A3 A4)) \n                       -> hsubst_r_exists_sum M2 A2 R1 (arrow A3 A4)\n                       -> hsubst_m M2 A2 M3 M3'\n                       -> canon M3' A3\n                       -> hsubst_r_exists_sum M2 A2 ([x] (app (R1 x) (M3 x))) A4\n                       -> type.\n%mode hsubst_m_exists_app +X-1 +X0 +X1 +X2 +X3 -X4.\n\n%% canonical terms\n\n- : hsubst_m_exists \n     A2\n     ([x] [dx] canon_asm (DaR x dx))\n     DcM2\n     DsR\n     DcM'\n     <- hsubst_r_exists A2 DaR DcM2 Dsum\n     <- hsubst_m_exists_asm Dsum DsR DcM'.\n\n- : hsubst_m_exists \n     A2\n     ([x] [dx] (canon_lam ([y] [dy] DcM x dx y dy)) : canon (lam (M x)) (arrow Af At))\n     (DcM2 : canon M2 A2)\n     (hsubst_m_lam DsM)\n     (canon_lam DcM')\n     <- ({y} \n           {dy : atom y Af}\n           hsubst_m_exists A2 ([x] [dx] (DcM x dx y dy)) DcM2 (DsM y) (DcM' y dy)).\n\n- : hsubst_m_exists\n     A2\n     ([x] [dx] (canon_pair (DcMr x dx) (DcMl x dx)))\n     DcM2\n     (hsubst_m_pair DsMr DsMl)\n     (canon_pair DcMr' DcMl')\n     <- hsubst_m_exists A2 DcMl DcM2 DsMl DcMl'\n     <- hsubst_m_exists A2 DcMr DcM2 DsMr DcMr'.\n\n%% atomic terms\n\n- : hsubst_r_exists \n     A2\n     ([x] [dx] D)\n     _\n     (hsubst_r_exists_sum_r D hsubst_r_closed).\n\n- : hsubst_r_exists\n     A2\n     ([x] [dx] dx)\n     DcM2\n     (hsubst_r_exists_sum_rr DcM2 hsubst_rr_var).\n\n- : hsubst_r_exists\n     A2\n     ([x] [dx] (atom_app (DcM x dx) (DaR x dx)))\n     DcM2\n     DsumApp\n     <- hsubst_m_exists A2 DcM DcM2 DsM' DcM'\n     <- hsubst_r_exists A2 DaR DcM2 DsumR'\n     <- hsubst_m_exists_app A2 DaR DsumR' DsM' DcM' DsumApp.\n\n- : hsubst_r_exists\n     A2\n     ([x] [dx] (atom_fst (DcR x dx)))\n     DcM2\n     DsumFst\n     <- hsubst_r_exists A2 DcR DcM2 DsumR\n     <- hsubst_r_exists_fst DsumR DsumFst.\n\n- : hsubst_r_exists\n     A2\n     ([x] [dx] (atom_snd (DcR x dx)))\n     DcM2\n     DsumSnd\n     <- hsubst_r_exists A2 DcR DcM2 DsumR\n     <- hsubst_r_exists_snd DsumR DsumSnd.\n\n%% app factoring lemma\n\n- : hsubst_m_exists_app \n     A2 \n     _\n     (hsubst_r_exists_sum_r DaR1 DsR1)\n     DsM3\n     DcM3\n     (hsubst_r_exists_sum_r (atom_app DcM3 DaR1) (hsubst_r_app DsM3 DsR1)).\n\n- : hsubst_m_exists_app \n     A2\n     _\n     (hsubst_r_exists_sum_rr (canon_lam DcM4') DsR1)\n     DsM3\n     DcM3\n     (hsubst_r_exists_sum_rr DcM4'' (hsubst_rr_app DsM4' DsM3 DsR1))\n     <- hsubst_rr_size A2 (arrow A3 A4) DsR1\n     <- hsubst_m_exists A3 DcM4' DcM3 DsM4' DcM4''.\n\n%worlds (atom_block) \n(hsubst_m_exists_app _ _ _ _ _ _)\n(hsubst_r_exists _ _ _ _)\n(hsubst_m_exists _ _ _ _ _).\n\n%total {(A2 A2' A2'') (D  D' D'')}\n(hsubst_m_exists A2' D' _ _ _)\n(hsubst_m_exists_app A2'' D'' _ _ _ _)\n(hsubst_r_exists A2 D _ _).\n</twelf>\n\nAs you can see, the proof is a straightforward induction, where in each case we use the appropriate factoring lemma.  In the final case of the application factoring lemma, we use the <tt>hsubst_rr_size</tt> lemma for its \"side effect\" of justifying the recursive call back to <tt>hsubst_m_exists</tt>.  The mutual lexicographic termination metric is the same as before.\n\n==== Uniqueness of hereditary substitution ====\n\nAs usual for a [[uniqueness lemma]], we must begin by defining the appropriate identity types:\n\n<twelf>\nid/mtm : mtm -> mtm -> type.\nid/mtm_refl : id/mtm M M.\n\nid/rtm : rtm -> rtm -> type.\nid/rtm_refl : id/rtm R R.\n\nid/tp : tp -> tp -> type.\nid/tp_refl : id/tp A A.\n</twelf>\n\nWe elide the trivial proofs of the equivalence relation, congruence, inversion, and respects lemmas; see the complete Twelf code at the end for their statements.\n<twelf hidden=\"true\">\nid/rtm_sym : id/rtm R R'\n\t      -> id/rtm R' R\n\t      -> type.\n%mode id/rtm_sym +X1 -X2.\n\n- : id/rtm_sym id/rtm_refl id/rtm_refl.\n\n%worlds (rtm_block) (id/rtm_sym _ _).\n%total {} (id/rtm_sym _ _).\n\nid/tp_arrow_inv : id/tp (arrow A1 A2) (arrow A1' A2')\n\t\t   -> id/tp A1 A1'\n\t\t   -> id/tp A2 A2'\n\t\t   -> type.\n%mode id/tp_arrow_inv +X1 -X2 -X3.\n\n- : id/tp_arrow_inv _ id/tp_refl id/tp_refl.\n\n%worlds (rtm_block) (id/tp_arrow_inv _ _ _).\n%total {} (id/tp_arrow_inv _ _ _).\n\nid/tp_prod_inv : id/tp (prod A1 A2) (prod A1' A2')\n\t\t   -> id/tp A1 A1'\n\t\t   -> id/tp A2 A2'\n\t\t   -> type.\n%mode id/tp_prod_inv +X1 -X2 -X3.\n\n- : id/tp_prod_inv _ id/tp_refl id/tp_refl.\n\n%worlds (rtm_block) (id/tp_prod_inv _ _ _).\n%total {} (id/tp_prod_inv _ _ _).\n\nid/rtm_app_cong : id/rtm R R'\n\t\t   -> id/mtm M M'\n\t\t   -> id/rtm (app R M) (app R' M')\n\t\t   -> type.\n%mode id/rtm_app_cong +X1 +X2 -X3.\n\n- : id/rtm_app_cong _ _ id/rtm_refl.\n\n%worlds (rtm_block) (id/rtm_app_cong _ _ _).\n%total {} (id/rtm_app_cong _ _ _).\n\nid/rtm_fst_cong : id/rtm R R'\n\t\t   -> id/rtm (fst R) (fst R')\n\t\t   -> type.\n%mode id/rtm_fst_cong +X1  -X3.\n\n- : id/rtm_fst_cong _ id/rtm_refl.\n\n%worlds (rtm_block) (id/rtm_fst_cong _ _).\n%total {} (id/rtm_fst_cong _ _).\n\nid/rtm_snd_cong : id/rtm R R'\n\t\t   -> id/rtm (snd R) (snd R')\n\t\t   -> type.\n%mode id/rtm_snd_cong +X1  -X3.\n\n- : id/rtm_snd_cong _ id/rtm_refl.\n\n%worlds (rtm_block) (id/rtm_snd_cong _ _).\n%total {} (id/rtm_snd_cong _ _).\n\nid/mtm_lam_cong :  ({x:rtm} id/mtm (M x) (M' x))\n\t\t   -> id/mtm (lam M) (lam M')\n\t\t   -> type.\n%mode id/mtm_lam_cong +X1 -X3.\n\n- : id/mtm_lam_cong _ id/mtm_refl.\n\n%worlds (rtm_block) (id/mtm_lam_cong _ _).\n%total {} (id/mtm_lam_cong _ _).\n\nid/mtm_lam_inv :  id/mtm (lam M) (lam M')\n\t\t  -> ({x:rtm} id/mtm (M x) (M' x))\n\t\t  -> type.\n%mode id/mtm_lam_inv +X1 -X3.\n\n- : id/mtm_lam_inv _ ([_] id/mtm_refl).\n\n%worlds (rtm_block) (id/mtm_lam_inv _ _).\n%total {} (id/mtm_lam_inv _ _).\n\nid/mtm_pair_cong : id/mtm M1 M1'\n\t\t   -> id/mtm M2 M2'\n\t\t   -> id/mtm (pair M1 M2) (pair M1' M2')\n\t\t   -> type.\n%mode id/mtm_pair_cong +X1 +X2 -X3.\n\n- : id/mtm_pair_cong _ _ id/mtm_refl.\n\n%worlds (rtm_block) (id/mtm_pair_cong _ _ _).\n%total {} (id/mtm_pair_cong _ _ _).\n\nid/mtm_pair_inv : id/mtm (pair M1 M2) (pair M1' M2')\n\t\t   -> id/mtm M1 M1'\n\t\t   -> id/mtm M2 M2'\n\t\t   -> type.\n%mode id/mtm_pair_inv +X1 -X2 -X3.\n\n- : id/mtm_pair_inv _ id/mtm_refl id/mtm_refl.\n\n%worlds (rtm_block) (id/mtm_pair_inv _ _ _).\n%total {} (id/mtm_pair_inv _ _ _).\n\nexpand_respects_id : id/rtm R R'\n\t\t      -> id/mtm M M'\n\t\t      -> expand A R M\n\t\t      -> expand A R' M'\n\t\t      -> type.\n%mode expand_respects_id +X1 +X2 +X3 -X4.\n\n- : expand_respects_id _ _ D D.\n\n%worlds (rtm_block) (expand_respects_id _ _ _ _).\n%total {} (expand_respects_id _ _ _ _).\n%reduces D1 = D2 (expand_respects_id _ _ D2 D1).\n\ncanon_respects_id :  id/mtm M M'\n\t\t     -> id/tp A A'\n\t\t     -> canon M A\n\t\t     -> canon M' A'\n\t\t     -> type.\n%mode canon_respects_id +X1 +X2 +X3 -X4.\n\n- : canon_respects_id _ _ D D.\n\n%worlds (atom_block) (canon_respects_id _ _ _ _).\n%total {} (canon_respects_id _ _ _ _).\n%reduces D1 = D2 (canon_respects_id _ _ D2 D1).\n\nhsubst_m_respects_id : id/mtm M2 M2'\n\t\t\t-> id/tp A2 A2'\n\t\t\t-> ({x} id/mtm (M x) (M' x))\n\t\t\t-> hsubst_m M2 A2 M Ms\n\t\t\t-> hsubst_m M2' A2' M' Ms\n\t\t\t-> type.\n%mode hsubst_m_respects_id +X1 +X2 +X3 +X4 -X5.\n\n- : hsubst_m_respects_id _ _ _ D D.\n\n%worlds (rtm_block) (hsubst_m_respects_id _ _ _ _ _).\n%total {} (hsubst_m_respects_id _ _ _ _ _).\n%reduces D1 = D2 (hsubst_m_respects_id _ _ _ D2 D1).\n\nid/mtm_asm_cong : id/rtm R R'\n\t\t   -> id/mtm (asm R) (asm R')\n\t\t   -> type.\n%mode id/mtm_asm_cong +X1  -X3.\n\n- : id/mtm_asm_cong _ id/mtm_refl.\n\n%worlds (rtm_block) (id/mtm_asm_cong _ _).\n%total {} (id/mtm_asm_cong _ _).\n</twelf>\n\nThe hardest part of proving uniqueness of hereditary substitution is proving that the rules <tt>hsubst_m_r</tt> and <tt>hsubst_m_rr</tt> are mutually exclusive.  We do by using [[reasoning from false|reasoning with contradiction]].  \n\n<twelf>\nfalse : type.\n%freeze false.\n</twelf>\n\nFirst, we prove that <tt>hsubst_rr</tt> is never inhabited when the variable is not free in the term being substituted into:\n<twelf>\nhsubst_rr_closed_contra : hsubst_rr M2 A2 ([_] R) M' A'\n                           -> false\n                           -> type.\n%mode hsubst_rr_closed_contra +X1 -X2.\n\n- : hsubst_rr_closed_contra \n     (hsubst_rr_app _ _ Dr)\n     X\n     <- hsubst_rr_closed_contra Dr X.\n\n- : hsubst_rr_closed_contra \n     (hsubst_rr_fst D)\n     X\n     <- hsubst_rr_closed_contra D X.\n\n- : hsubst_rr_closed_contra \n     (hsubst_rr_snd D)\n     X\n     <- hsubst_rr_closed_contra D X.\n\n%worlds (rtm_block) (hsubst_rr_closed_contra _ _).\n%total D (hsubst_rr_closed_contra D _).\n</twelf>\nThis is an example of deriving a contradiction by induction—the coverage checker rules out all the base cases.\n\nNext, we show that the two atomic term judgements are exclusive.  In the only base case that is not ruled out by coverage checking, we use the previous lemma.  \n<twelf>\n%% contradiction of root and non-root\n\nhsubst_r_rr_contra : hsubst_r M2 A2 R R'\n                      -> hsubst_rr M2 A2 R M' A'\n                      -> false\n                      -> type.\n%mode hsubst_r_rr_contra +X1 +X2 -X3.\n\n- : hsubst_r_rr_contra\n     hsubst_r_closed\n     Drr\n     X\n     <- hsubst_rr_closed_contra Drr X.\n\n- : hsubst_r_rr_contra \n     (hsubst_r_app _ DsrR)\n     (hsubst_rr_app _ _ DsrrR)\n     X\n     <- hsubst_r_rr_contra DsrR DsrrR X.\n\n- : hsubst_r_rr_contra \n     (hsubst_r_fst DsrR)\n     (hsubst_rr_fst DsrrR)\n     X\n     <- hsubst_r_rr_contra DsrR DsrrR X.\n\n- : hsubst_r_rr_contra \n     (hsubst_r_snd DsrR)\n     (hsubst_rr_snd DsrrR)\n     X\n     <- hsubst_r_rr_contra DsrR DsrrR X.\n\n%worlds (rtm_block) (hsubst_r_rr_contra _ _ _). %% bar in extra block for lemma below's future use\n%total (D) (hsubst_r_rr_contra D _ _).\n</twelf>\n\nNext, we write a little lemma showing that <tt>false</tt> implies any identity that we need.\n<twelf>\n%% false implies id\nfalse_implies_id/mtm : {M} {M'}\n                        false \n                        -> id/mtm M M'\n                        -> type.\n%mode false_implies_id/mtm +X1 +X2 +X3 -X4.\n%worlds (rtm_block) (false_implies_id/mtm _ _ _ _). %% bar in extra block for lemma below's future use\n%total {} (false_implies_id/mtm _ _ _ _).\n</twelf>\n\nThe cost of defining hereditary substitution in a non-deterministic manner, which we did to avoid putting cases of hereditary substitution in the context, is that we now need to prove the following lemmas.  These lemmas establish that any way of deriving a hereditary substitution for a closed term produces the same result as <tt>hsubst_r_closed</tt>.  \n<twelf>\nhsubst_r_vacuous_id : hsubst_r M2 A2 ([_] R) R'\n                     -> id/rtm R' R\n                     -> type.\n%mode hsubst_r_vacuous_id +X1 -X2.\n\nhsubst_m_vacuous_id : hsubst_m M2 A2 ([_] M) M'\n                     -> id/mtm M' M\n                     -> type.\n%mode hsubst_m_vacuous_id +X1 -X2.\n\n%% R\n\n- : hsubst_r_vacuous_id hsubst_r_closed id/rtm_refl.\n\n- : hsubst_r_vacuous_id (hsubst_r_app Dm Dr) Did'\n     <- hsubst_r_vacuous_id Dr DidR\n     <- hsubst_m_vacuous_id Dm DidM\n     <- id/rtm_app_cong DidR DidM Did'.\n\n- : hsubst_r_vacuous_id (hsubst_r_fst D) Did'\n     <- hsubst_r_vacuous_id D Did\n     <- id/rtm_fst_cong Did Did'.\n\n- : hsubst_r_vacuous_id (hsubst_r_snd D) Did'\n     <- hsubst_r_vacuous_id D Did\n     <- id/rtm_snd_cong Did Did'.\n\n%% M\n\n- : hsubst_m_vacuous_id\n     (hsubst_m_r Dr)\n     Did'\n     <- hsubst_r_vacuous_id Dr Did\n     <- id/mtm_asm_cong Did Did'.\n\n- : hsubst_m_vacuous_id\n     (hsubst_m_rr D)\n     Did\n     <- hsubst_rr_closed_contra D X\n     <- false_implies_id/mtm _ _ X Did.\n\n- : hsubst_m_vacuous_id\n     (hsubst_m_lam D)\n     Did'\n     <- ({x} \n           hsubst_m_vacuous_id (D x) (Did x))\n     <- id/mtm_lam_cong Did Did'.\n\n- : hsubst_m_vacuous_id\n     (hsubst_m_pair D2 D1)\n     Did'\n     <- hsubst_m_vacuous_id D1 Did1\n     <- hsubst_m_vacuous_id D2 Did2\n     <- id/mtm_pair_cong Did1 Did2 Did'.\n\n%worlds (rtm_block) (hsubst_r_vacuous_id _ _) (hsubst_m_vacuous_id _ _).\n%total (D1 D2) \n(hsubst_r_vacuous_id D1 _)\n(hsubst_m_vacuous_id D2 _).\n</twelf>\n\nNow, we prove the top-level results:\n<twelf>\nhsubst_m_unique : hsubst_m M2 A2 M M'\n                   -> hsubst_m M2 A2 M M''\n                   -> id/mtm M' M''\n                   -> type.\n%mode hsubst_m_unique +X1 +X2 -X3.\n\nhsubst_r_unique : hsubst_r M2 A2 R R'\n                   -> hsubst_r M2 A2 R R''\n                   -> id/rtm R' R''\n                   -> type.\n%mode hsubst_r_unique +X1 +X2 -X3.\n\nhsubst_rr_unique : hsubst_rr M2 A2 R M' A'\n                    -> hsubst_rr M2 A2 R M'' A''\n                    -> id/mtm M' M''\n                    -> id/tp A' A''\n                    -> type.\n%mode hsubst_rr_unique +X1 +X2 -X3 -X4.\n\n%% M\n\n- : hsubst_m_unique\n     (hsubst_m_r Dsr)\n     (hsubst_m_r Dsr')\n     DidAsm\n     <- hsubst_r_unique Dsr Dsr' DidR\n     <- id/mtm_asm_cong DidR DidAsm.\n\n- : hsubst_m_unique\n     (hsubst_m_rr Dsr)\n     (hsubst_m_rr Dsr')\n     Did\n     <- hsubst_rr_unique Dsr Dsr' Did _.\n\n%% contradict mismatch\n- : hsubst_m_unique\n     (hsubst_m_r Dsr)\n     (hsubst_m_rr Dsrr)\n     Did\n     <- hsubst_r_rr_contra Dsr Dsrr X\n     <- false_implies_id/mtm _ _ X Did.\n\n%% contradict mismatch\n- : hsubst_m_unique\n     (hsubst_m_rr Dsrr)\n     (hsubst_m_r Dsr)\n     Did\n     <- hsubst_r_rr_contra Dsr Dsrr X\n     <- false_implies_id/mtm _ _ X Did.\n\n- : hsubst_m_unique\n     (hsubst_m_pair DsRight DsLeft)\n     (hsubst_m_pair DsRight' DsLeft')\n     DidPair\n     <- hsubst_m_unique DsLeft DsLeft' DidLeft\n     <- hsubst_m_unique DsRight DsRight' DidRight\n     <- id/mtm_pair_cong DidLeft DidRight DidPair.\n\n- : hsubst_m_unique\n     (hsubst_m_lam Ds)\n     (hsubst_m_lam Ds')\n     DidLam\n     <- ({y:rtm} hsubst_m_unique (Ds y) (Ds' y) (Did y))\n     <- id/mtm_lam_cong Did DidLam.\n     \n%% R non-root\n\n- : hsubst_r_unique D D id/rtm_refl.\n\n- : hsubst_r_unique \n     (hsubst_r_closed : hsubst_r M2 A2 ([_] R) R)\n     (D : hsubst_r M2 A2 ([_] R) R')\n     Did'\n     <- hsubst_r_vacuous_id D Did\n     <- id/rtm_sym Did Did'.\n\n- : hsubst_r_unique \n     (D : hsubst_r M2 A2 ([_] R) R')\n     (hsubst_r_closed : hsubst_r M2 A2 ([_] R) R)\n     Did\n     <- hsubst_r_vacuous_id D Did.\n\n- : hsubst_r_unique \n     (hsubst_r_app DsM' DsR') \n     (hsubst_r_app DsM'' DsR'')\n     DidApp\n     <- hsubst_r_unique DsR' DsR'' DidR\n     <- hsubst_m_unique DsM' DsM'' DidM\n     <- id/rtm_app_cong DidR DidM DidApp.\n\n- : hsubst_r_unique\n     (hsubst_r_fst DsR')\n     (hsubst_r_fst DsR'')\n     DidFst\n     <- hsubst_r_unique DsR' DsR'' DidR\n     <- id/rtm_fst_cong DidR DidFst.\n- : hsubst_r_unique\n     (hsubst_r_snd DsR')\n     (hsubst_r_snd DsR'')\n     DidSnd\n     <- hsubst_r_unique DsR' DsR'' DidR\n     <- id/rtm_snd_cong DidR DidSnd.\n\n%% R root\n\n- : hsubst_rr_unique \n     hsubst_rr_var\n     hsubst_rr_var\n     id/mtm_refl\n     id/tp_refl.\n\n- : hsubst_rr_unique\n     (hsubst_rr_app DsM4' DsM3 DsR1)\n     (hsubst_rr_app DsM4'-2 DsM3-2 DsR1-2)\n     DidM4''\n     DidA4\n     <- hsubst_rr_unique DsR1 DsR1-2 DidLam DidArrow\n     <- hsubst_m_unique DsM3 DsM3-2 DidM3'\n     <- id/tp_arrow_inv DidArrow DidA3 DidA4\n     <- id/mtm_lam_inv DidLam DidM4'\n     <- hsubst_m_respects_id DidM3' DidA3 DidM4' DsM4' DsM4'-1\n     <- hsubst_m_unique DsM4'-1 DsM4'-2 DidM4''.\n\n- : hsubst_rr_unique \n     (hsubst_rr_fst DsR')\n     (hsubst_rr_fst DsR'')\n     DidMl\n     DidAl\n     <- hsubst_rr_unique DsR' DsR'' DidPair DidProd\n     <- id/tp_prod_inv DidProd DidAl _\n     <- id/mtm_pair_inv DidPair DidMl _.\n\n- : hsubst_rr_unique \n     (hsubst_rr_snd DsR')\n     (hsubst_rr_snd DsR'')\n     DidMr\n     DidAr\n     <- hsubst_rr_unique DsR' DsR'' DidPair DidProd\n     <- id/tp_prod_inv DidProd _ DidAr\n     <- id/mtm_pair_inv DidPair _ DidMr.\n\n%worlds (rtm_block) \n(hsubst_m_unique _ _ _)\n(hsubst_r_unique _ _ _)\n(hsubst_rr_unique _ _ _ _).\n\n%total (D1 D2 D3) \n(hsubst_r_unique D2 _ _)\n(hsubst_rr_unique D3 _ _ _)\n(hsubst_m_unique D1 _ _).\n</twelf>\n\n=== Expansion ===\n\n==== Existence of expansion ====\n\nThis lemma is in part an [[effectiveness lemma]] for expansion, but it also shows that expansion preserves types.  \n\n<twelf>\nexpand_exists : {A}\n                 atom R A\n                 -> expand A R M\n                 -> canon M A\n                 -> type.\n%mode expand_exists +X0 +X1 -X2 -X3.\n\n- : expand_exists \n     b\n     D\n     expand_b\n     (canon_asm D).\n\n- : expand_exists\n     (arrow A2 A)\n     DaR\n     (expand_arrow DeApp DeX)\n     (canon_lam DcApp)\n     <- ({x : rtm}\n           {dx : atom x A2}\n           expand_exists A2 dx (DeX x) (DcM x dx))\n     <- ({x : rtm}\n           {dx : atom x A2}\n           expand_exists A (atom_app (DcM x dx) DaR) (DeApp x) (DcApp x dx)).\n\n- : expand_exists\n     (prod A1 A2)\n     DaR\n     (expand_prod DeS DeF)\n     (canon_pair DcS DcF)\n     <- expand_exists A1 (atom_fst DaR) DeF DcF\n     <- expand_exists A2 (atom_snd DaR) DeS DcS.\n\n%worlds (atom_block) (expand_exists _ _ _ _). \n%total D (expand_exists D _ _ _).\n</twelf>\n\n==== Uniqueness of expansion ====\n\nUniqueness is proved by a straightforward induction using some identity lemmas:\n\n<twelf>\nexpand_unique : expand A R M \n                 -> expand A R M'\n                 -> id/mtm M M'\n                 -> type.\n%mode expand_unique +X1 +X2 -X3.\n\n- : expand_unique\n     expand_b\n     expand_b\n     id/mtm_refl.\n\n- : expand_unique \n     (expand_arrow \n        (DeApp : {x : rtm} expand A (app R (Mx x)) (MApp x))\n        (DeX : {x : rtm} expand A2 x (Mx x)))\n      (expand_arrow \n         (DeApp' : {x : rtm} expand A (app R (Mx' x)) (MApp' x))\n         (DeX' : {x : rtm} expand A2 x (Mx' x)))\n     DidLam\n     <- ({x : rtm}\n           expand_unique (DeX x) (DeX' x) (DidX x))\n     <- ({x : rtm}\n           id/rtm_app_cong (id/rtm_refl : id/rtm R R) (DidX x) (DidApp x))\n     <- ({x : rtm}\n           expand_respects_id (DidApp x) id/mtm_refl (DeApp x) (DeApp-2 x))\n     <- ({x : rtm} \n           expand_unique (DeApp-2 x) (DeApp' x) (DidAppExp x))\n     <- id/mtm_lam_cong DidAppExp DidLam.\n\n- : expand_unique\n     (expand_prod DeS DeF)\n     (expand_prod DeS' DeF')\n     DidPair\n     <- expand_unique DeF DeF' DidF\n     <- expand_unique DeS DeS' DidS\n     <- id/mtm_pair_cong DidF DidS DidPair.\n     \n%worlds (rtm_block) (expand_unique _ _ _).\n%total D (expand_unique _ D _).\n</twelf>\n\n== Elaboration ==\n\nIn [[Hereditary substitution for the STLC (part 2)|part 2]], we discuss elaboration.  \n\nThe complete Twelf code for this tutorial contains the identity lemmas that we elided above.\n\n<twelflink>All Twelf code for this tutorial.</twelflink>\n<twelflink check=\"true\">See Twelf's output.</twelflink>\n\n{{case study}}"
          },
          "sha1": "d2jcpojheari2p4qap6rtlrs3zv5n37"
        }
      },
      {
        "title": "Hereditary substitution for the STLC (part 2)",
        "ns": 0,
        "id": 1911,
        "revision": {
          "id": 4589,
          "parentid": 4247,
          "timestamp": "2007-03-21T13:07:18Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "minor": null,
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 60265,
            "#text": "This is part 2 of the case study [[Hereditary substitution for the STLC]].  \n\n<twelf hidden=\"true\">\ntp : type.\n\nb : tp.\narrow : tp -> tp -> tp.\nprod : tp -> tp -> tp.\n\nrtm : type.\nmtm : type.\n\napp : rtm -> mtm -> rtm.\nc : rtm.\nfst : rtm -> rtm.\nsnd : rtm -> rtm.\n\nasm : rtm -> mtm.\nlam : (rtm -> mtm) -> mtm.\npair : mtm -> mtm -> mtm.\n\n%block rtm_block : block {x : rtm}.\n%worlds (rtm_block) (tp) (rtm) (mtm).\n\natom : rtm -> tp -> type.\n%mode atom +X1 -X2.\n\ncanon : mtm -> tp -> type.\n%mode canon +X1 +X2.\n\n% atomic \n\natom_c : atom c b.\n\natom_app : atom (app R1 M2) A\n            <- atom R1 (arrow A2 A)\n            <- canon M2 A2.\n\natom_fst : atom (fst R) A1\n            <- atom R (prod A1 A2).\n\natom_snd : atom (snd R) A2\n            <- atom R (prod A1 A2).\n\n%% canonical \n\ncanon_asm : canon (asm R) b\n             <- atom R b.\n\ncanon_lam : canon (lam M) (arrow A2 A)\n             <- {x : rtm} (atom x A2) ->  canon (M x) A.\n\ncanon_pair : canon (pair M1 M2) (prod A1 A2)\n              <- canon M1 A1\n              <- canon M2 A2.\n\n%block atom_block : some {A:tp}\n                     block {x:rtm} {dx : atom x A}. \n%worlds (atom_block) (atom _ _) (canon _ _).\n%terminates (R M) (atom R _) (canon M _).\n\nhsubst_m : mtm -> tp -> (rtm -> mtm) -> mtm -> type.\n%mode hsubst_m +X1 +X2 +X3 -X4.\n\nhsubst_r : mtm -> tp -> (rtm -> rtm) -> rtm -> type.\n%mode hsubst_r +X1 +X2 +X3 -X4.\n\nhsubst_rr : mtm -> tp -> (rtm -> rtm) -> mtm -> tp -> type.\n%mode hsubst_rr +X1 +X2 +X3 -X4 -X5.\n\n%% Ms\n\nhsubst_m_r : hsubst_m M0 A0 ([x] asm (R x)) (asm R')\n              <- hsubst_r M0 A0 R R'.\n\nhsubst_m_rr : hsubst_m M0 A0 ([x] asm (R x)) M'\n               <- hsubst_rr M0 A0 R M' _.\n\nhsubst_m_lam : hsubst_m M0 A0 ([x] (lam ([y] M x y))) (lam M')\n                <- ({y:rtm} \n                      hsubst_m M0 A0 ([x] M x y) (M' y)).\n\nhsubst_m_pair : hsubst_m M0 A0 ([x] (pair (M1 x) (M2 x))) (pair M1' M2')\n                 <- hsubst_m M0 A0 M1 M1'\n                 <- hsubst_m M0 A0 M2 M2'.\n\n%% R not head\n\nhsubst_r_closed : hsubst_r M0 A0 ([x] E) E.\n\nhsubst_r_app : hsubst_r M0 A0 ([x] (app (R x) (M x))) (app R' M')\n                <- hsubst_r M0 A0 R R'\n                <- hsubst_m M0 A0 M M'.\n\nhsubst_r_fst : hsubst_r M0 A0 ([x] (fst (R x))) (fst R')\n                <- hsubst_r M0 A0 R R'.\n\nhsubst_r_snd : hsubst_r M0 A0 ([x] (snd (R x))) (snd R')\n                <- hsubst_r M0 A0 R R'.\n\n%% r head\n\nhsubst_rr_var : hsubst_rr M0 A0 ([x] x) M0 A0.\n\nhsubst_rr_app : hsubst_rr M0 A0 ([x] app (R1 x) (M2 x)) M'' A\n                 <- hsubst_rr M0 A0 R1 (lam M') (arrow A2 A)\n                 <- hsubst_m M0 A0 M2 M2'\n                 <- hsubst_m M2' A2 M' M''.\n\nhsubst_rr_fst : hsubst_rr M0 A0 ([x] (fst (R x))) M1' A1'\n                 <- hsubst_rr M0 A0 R (pair M1' M2') (prod A1' A2').\n\nhsubst_rr_snd : hsubst_rr M0 A0 ([x] (snd (R x))) M2' A2'\n                 <- hsubst_rr M0 A0 R (pair M1' M2') (prod A1' A2').\n\n%worlds (rtm_block) (hsubst_m _ _ _ _) (hsubst_r _ _ _ _) (hsubst_rr _ _ _ _ _).\n%reduces A' <= A0 (hsubst_rr _ A0 _ _ A').\n%terminates {(A0 A0' A0'') (M R R')} (hsubst_m _ A0 M _) (hsubst_r _ A0' R _) (hsubst_rr _ A0'' R' _ _).\n\nexpand : tp -> rtm -> mtm -> type.\n%mode expand +X1 +X2 -X3.\n\nexpand_b : expand b R (asm R).\n\nexpand_arrow : expand (arrow A2 A) R (lam M)\n                <- ({x : rtm} expand A2 x (M2 x))\n                <- ({x : rtm} expand A (app R (M2 x)) (M x)).\n\nexpand_prod : expand (prod A1 A2) R (pair M1 M2)\n               <- expand A1 (fst R) M1\n               <- expand A2 (snd R) M2.\n\n%worlds (rtm_block) (expand _ _ _).\n%total A (expand A _ _).\n\nhsubst_rr_size : {A2} {A'} hsubst_rr M2 A2 R M' A'\n                    -> type.\n%mode hsubst_rr_size +X1 +X2 +X3.\n\n- : hsubst_rr_size \n     A2 A2 hsubst_rr_var.\n\n- : hsubst_rr_size\n     A2 A4 (hsubst_rr_app _ _ Drr)\n     <- hsubst_rr_size A2 (arrow A3 A4) Drr.\n\n- : hsubst_rr_size\n     A2 Al (hsubst_rr_fst Drr)\n     <- hsubst_rr_size A2 (prod Al Ar) Drr.\n\n- : hsubst_rr_size\n     A2 Ar (hsubst_rr_snd Drr)\n     <- hsubst_rr_size A2 (prod Al Ar) Drr.\n\n%worlds (rtm_block) (hsubst_rr_size _ _ _).\n%total D (hsubst_rr_size _ _ D).\n%reduces A' <= A2 (hsubst_rr_size A2 A' _).\n \nhsubst_r_exists_sum : mtm -> tp -> (rtm -> rtm) -> tp -> type.\nhsubst_r_exists_sum_r : hsubst_r_exists_sum M2 A2 R A\n                         <- hsubst_r M2 A2 R R'\n                         <- atom R' A.\nhsubst_r_exists_sum_rr : hsubst_r_exists_sum M2 A2 R A'\n                          <- hsubst_rr M2 A2 R M' A'\n                          <- canon M' A'.\n\nhsubst_m_exists_asm :  hsubst_r_exists_sum M2 A2 R b\n                       -> hsubst_m M2 A2 ([x] (asm (R x))) M'\n                       -> canon M' b\n                       -> type.\n%mode hsubst_m_exists_asm +X1 -X2 -X3.\n\n- : hsubst_m_exists_asm \n     (hsubst_r_exists_sum_r DaR' DsR)\n     (hsubst_m_r DsR)\n     (canon_asm DaR').\n\n- : hsubst_m_exists_asm \n     (hsubst_r_exists_sum_rr DcM' DsR)\n     (hsubst_m_rr DsR)\n     DcM'.\n\n%worlds (atom_block) (hsubst_m_exists_asm _ _ _).\n%total {} (hsubst_m_exists_asm _ _ _).\n\n\nhsubst_r_exists_fst : hsubst_r_exists_sum M2 A2 R (prod Al Ar)\n                       -> hsubst_r_exists_sum M2 A2 ([x] (fst (R x))) Al\n                       -> type.\n%mode hsubst_r_exists_fst +X1 -X2.\n\n- : hsubst_r_exists_fst \n     (hsubst_r_exists_sum_r DaR' DsR)\n     (hsubst_r_exists_sum_r (atom_fst DaR') (hsubst_r_fst DsR)).\n\n- : hsubst_r_exists_fst \n     (hsubst_r_exists_sum_rr (canon_pair _ DcMl') DsR)\n     (hsubst_r_exists_sum_rr DcMl' (hsubst_rr_fst DsR)).\n\n%worlds (atom_block) (hsubst_r_exists_fst _ _).\n%total {} (hsubst_r_exists_fst _ _).\n\n\nhsubst_r_exists_snd : hsubst_r_exists_sum M2 A2 R (prod Al Ar)\n                       -> hsubst_r_exists_sum M2 A2 ([x] (snd (R x))) Ar\n                       -> type.\n%mode hsubst_r_exists_snd +X1 -X2.\n\n- : hsubst_r_exists_snd \n     (hsubst_r_exists_sum_r DaR' DsR)\n     (hsubst_r_exists_sum_r (atom_snd DaR') (hsubst_r_snd DsR)).\n\n- : hsubst_r_exists_snd \n     (hsubst_r_exists_sum_rr (canon_pair DcMr' _) DsR)\n     (hsubst_r_exists_sum_rr DcMr' (hsubst_rr_snd DsR)).\n\n%worlds (atom_block) (hsubst_r_exists_snd _ _).\n%total {} (hsubst_r_exists_snd _ _).\n\nhsubst_m_exists : {A2}\n                   ({y : rtm} {dy : atom y A2} canon (M y) A)\n                   -> canon M2 A2\n                   -> hsubst_m M2 A2 M M'\n                   -> canon M' A\n                   -> type.\n%mode hsubst_m_exists +X0 +X1 +X2 -X3 -X4.\n\nhsubst_r_exists : {A2}\n                   ({y : rtm} {dx : atom y A2} atom (R y) A)\n                   -> canon M2 A2\n                   -> hsubst_r_exists_sum M2 A2 R A\n                   -> type.\n%mode hsubst_r_exists +X0 +X1 +X2 -X3.\n\nhsubst_m_exists_app : {A2}\n                       %% this next argument is makes the termination argument work\n                       ({y : rtm} {dx : atom y A2} atom (R1 y) (arrow A3 A4)) \n                       -> hsubst_r_exists_sum M2 A2 R1 (arrow A3 A4)\n                       -> hsubst_m M2 A2 M3 M3'\n                       -> canon M3' A3\n                       -> hsubst_r_exists_sum M2 A2 ([x] (app (R1 x) (M3 x))) A4\n                       -> type.\n%mode hsubst_m_exists_app +X-1 +X0 +X1 +X2 +X3 -X4.\n\n%% canonical terms\n\n- : hsubst_m_exists \n     A2\n     ([x] [dx] canon_asm (DaR x dx))\n     DcM2\n     DsR\n     DcM'\n     <- hsubst_r_exists A2 DaR DcM2 Dsum\n     <- hsubst_m_exists_asm Dsum DsR DcM'.\n\n- : hsubst_m_exists \n     A2\n     ([x] [dx] (canon_lam ([y] [dy] DcM x dx y dy)) : canon (lam (M x)) (arrow Af At))\n     (DcM2 : canon M2 A2)\n     (hsubst_m_lam DsM)\n     (canon_lam DcM')\n     <- ({y} \n           {dy : atom y Af}\n           hsubst_m_exists A2 ([x] [dx] (DcM x dx y dy)) DcM2 (DsM y) (DcM' y dy)).\n\n- : hsubst_m_exists\n     A2\n     ([x] [dx] (canon_pair (DcMr x dx) (DcMl x dx)))\n     DcM2\n     (hsubst_m_pair DsMr DsMl)\n     (canon_pair DcMr' DcMl')\n     <- hsubst_m_exists A2 DcMl DcM2 DsMl DcMl'\n     <- hsubst_m_exists A2 DcMr DcM2 DsMr DcMr'.\n\n%% atomic terms\n\n- : hsubst_r_exists \n     A2\n     ([x] [dx] D)\n     _\n     (hsubst_r_exists_sum_r D hsubst_r_closed).\n\n- : hsubst_r_exists\n     A2\n     ([x] [dx] dx)\n     DcM2\n     (hsubst_r_exists_sum_rr DcM2 hsubst_rr_var).\n\n- : hsubst_r_exists\n     A2\n     ([x] [dx] (atom_app (DcM x dx) (DaR x dx)))\n     DcM2\n     DsumApp\n     <- hsubst_m_exists A2 DcM DcM2 DsM' DcM'\n     <- hsubst_r_exists A2 DaR DcM2 DsumR'\n     <- hsubst_m_exists_app A2 DaR DsumR' DsM' DcM' DsumApp.\n\n- : hsubst_r_exists\n     A2\n     ([x] [dx] (atom_fst (DcR x dx)))\n     DcM2\n     DsumFst\n     <- hsubst_r_exists A2 DcR DcM2 DsumR\n     <- hsubst_r_exists_fst DsumR DsumFst.\n\n- : hsubst_r_exists\n     A2\n     ([x] [dx] (atom_snd (DcR x dx)))\n     DcM2\n     DsumSnd\n     <- hsubst_r_exists A2 DcR DcM2 DsumR\n     <- hsubst_r_exists_snd DsumR DsumSnd.\n\n%% app factoring lemma\n\n- : hsubst_m_exists_app \n     A2 \n     _\n     (hsubst_r_exists_sum_r DaR1 DsR1)\n     DsM3\n     DcM3\n     (hsubst_r_exists_sum_r (atom_app DcM3 DaR1) (hsubst_r_app DsM3 DsR1)).\n\n- : hsubst_m_exists_app \n     A2\n     _\n     (hsubst_r_exists_sum_rr (canon_lam DcM4') DsR1)\n     DsM3\n     DcM3\n     (hsubst_r_exists_sum_rr DcM4'' (hsubst_rr_app DsM4' DsM3 DsR1))\n     <- hsubst_rr_size A2 (arrow A3 A4) DsR1\n     <- hsubst_m_exists A3 DcM4' DcM3 DsM4' DcM4''.\n\n%worlds (atom_block) \n(hsubst_m_exists_app _ _ _ _ _ _)\n(hsubst_r_exists _ _ _ _)\n(hsubst_m_exists _ _ _ _ _).\n\n%total {(A2 A2' A2'') (D  D' D'')}\n(hsubst_m_exists A2' D' _ _ _)\n(hsubst_m_exists_app A2'' D'' _ _ _ _)\n(hsubst_r_exists A2 D _ _).\n\nid/mtm : mtm -> mtm -> type.\nid/mtm_refl : id/mtm M M.\n\nid/rtm : rtm -> rtm -> type.\nid/rtm_refl : id/rtm R R.\n\nid/tp : tp -> tp -> type.\nid/tp_refl : id/tp A A.\n\nid/rtm_sym : id/rtm R R'\n\t      -> id/rtm R' R\n\t      -> type.\n%mode id/rtm_sym +X1 -X2.\n\n- : id/rtm_sym id/rtm_refl id/rtm_refl.\n\n%worlds (rtm_block) (id/rtm_sym _ _).\n%total {} (id/rtm_sym _ _).\n\nid/tp_arrow_inv : id/tp (arrow A1 A2) (arrow A1' A2')\n\t\t   -> id/tp A1 A1'\n\t\t   -> id/tp A2 A2'\n\t\t   -> type.\n%mode id/tp_arrow_inv +X1 -X2 -X3.\n\n- : id/tp_arrow_inv _ id/tp_refl id/tp_refl.\n\n%worlds (rtm_block) (id/tp_arrow_inv _ _ _).\n%total {} (id/tp_arrow_inv _ _ _).\n\nid/tp_prod_inv : id/tp (prod A1 A2) (prod A1' A2')\n\t\t   -> id/tp A1 A1'\n\t\t   -> id/tp A2 A2'\n\t\t   -> type.\n%mode id/tp_prod_inv +X1 -X2 -X3.\n\n- : id/tp_prod_inv _ id/tp_refl id/tp_refl.\n\n%worlds (rtm_block) (id/tp_prod_inv _ _ _).\n%total {} (id/tp_prod_inv _ _ _).\n\nid/rtm_app_cong : id/rtm R R'\n\t\t   -> id/mtm M M'\n\t\t   -> id/rtm (app R M) (app R' M')\n\t\t   -> type.\n%mode id/rtm_app_cong +X1 +X2 -X3.\n\n- : id/rtm_app_cong _ _ id/rtm_refl.\n\n%worlds (rtm_block) (id/rtm_app_cong _ _ _).\n%total {} (id/rtm_app_cong _ _ _).\n\nid/rtm_fst_cong : id/rtm R R'\n\t\t   -> id/rtm (fst R) (fst R')\n\t\t   -> type.\n%mode id/rtm_fst_cong +X1  -X3.\n\n- : id/rtm_fst_cong _ id/rtm_refl.\n\n%worlds (rtm_block) (id/rtm_fst_cong _ _).\n%total {} (id/rtm_fst_cong _ _).\n\nid/rtm_snd_cong : id/rtm R R'\n\t\t   -> id/rtm (snd R) (snd R')\n\t\t   -> type.\n%mode id/rtm_snd_cong +X1  -X3.\n\n- : id/rtm_snd_cong _ id/rtm_refl.\n\n%worlds (rtm_block) (id/rtm_snd_cong _ _).\n%total {} (id/rtm_snd_cong _ _).\n\nid/mtm_lam_cong :  ({x:rtm} id/mtm (M x) (M' x))\n\t\t   -> id/mtm (lam M) (lam M')\n\t\t   -> type.\n%mode id/mtm_lam_cong +X1 -X3.\n\n- : id/mtm_lam_cong _ id/mtm_refl.\n\n%worlds (rtm_block) (id/mtm_lam_cong _ _).\n%total {} (id/mtm_lam_cong _ _).\n\nid/mtm_lam_inv :  id/mtm (lam M) (lam M')\n\t\t  -> ({x:rtm} id/mtm (M x) (M' x))\n\t\t  -> type.\n%mode id/mtm_lam_inv +X1 -X3.\n\n- : id/mtm_lam_inv _ ([_] id/mtm_refl).\n\n%worlds (rtm_block) (id/mtm_lam_inv _ _).\n%total {} (id/mtm_lam_inv _ _).\n\nid/mtm_pair_cong : id/mtm M1 M1'\n\t\t   -> id/mtm M2 M2'\n\t\t   -> id/mtm (pair M1 M2) (pair M1' M2')\n\t\t   -> type.\n%mode id/mtm_pair_cong +X1 +X2 -X3.\n\n- : id/mtm_pair_cong _ _ id/mtm_refl.\n\n%worlds (rtm_block) (id/mtm_pair_cong _ _ _).\n%total {} (id/mtm_pair_cong _ _ _).\n\nid/mtm_pair_inv : id/mtm (pair M1 M2) (pair M1' M2')\n\t\t   -> id/mtm M1 M1'\n\t\t   -> id/mtm M2 M2'\n\t\t   -> type.\n%mode id/mtm_pair_inv +X1 -X2 -X3.\n\n- : id/mtm_pair_inv _ id/mtm_refl id/mtm_refl.\n\n%worlds (rtm_block) (id/mtm_pair_inv _ _ _).\n%total {} (id/mtm_pair_inv _ _ _).\n\nexpand_respects_id : id/rtm R R'\n\t\t      -> id/mtm M M'\n\t\t      -> expand A R M\n\t\t      -> expand A R' M'\n\t\t      -> type.\n%mode expand_respects_id +X1 +X2 +X3 -X4.\n\n- : expand_respects_id _ _ D D.\n\n%worlds (rtm_block) (expand_respects_id _ _ _ _).\n%total {} (expand_respects_id _ _ _ _).\n%reduces D1 = D2 (expand_respects_id _ _ D2 D1).\n\ncanon_respects_id :  id/mtm M M'\n\t\t     -> id/tp A A'\n\t\t     -> canon M A\n\t\t     -> canon M' A'\n\t\t     -> type.\n%mode canon_respects_id +X1 +X2 +X3 -X4.\n\n- : canon_respects_id _ _ D D.\n\n%worlds (atom_block) (canon_respects_id _ _ _ _).\n%total {} (canon_respects_id _ _ _ _).\n%reduces D1 = D2 (canon_respects_id _ _ D2 D1).\n\nhsubst_m_respects_id : id/mtm M2 M2'\n\t\t\t-> id/tp A2 A2'\n\t\t\t-> ({x} id/mtm (M x) (M' x))\n\t\t\t-> hsubst_m M2 A2 M Ms\n\t\t\t-> hsubst_m M2' A2' M' Ms\n\t\t\t-> type.\n%mode hsubst_m_respects_id +X1 +X2 +X3 +X4 -X5.\n\n- : hsubst_m_respects_id _ _ _ D D.\n\n%worlds (rtm_block) (hsubst_m_respects_id _ _ _ _ _).\n%total {} (hsubst_m_respects_id _ _ _ _ _).\n%reduces D1 = D2 (hsubst_m_respects_id _ _ _ D2 D1).\n\nid/mtm_asm_cong : id/rtm R R'\n\t\t   -> id/mtm (asm R) (asm R')\n\t\t   -> type.\n%mode id/mtm_asm_cong +X1  -X3.\n\n- : id/mtm_asm_cong _ id/mtm_refl.\n\n%worlds (rtm_block) (id/mtm_asm_cong _ _).\n%total {} (id/mtm_asm_cong _ _).\n\nfalse : type.\n%freeze false.\n\nhsubst_rr_closed_contra : hsubst_rr M2 A2 ([_] R) M' A'\n                           -> false\n                           -> type.\n%mode hsubst_rr_closed_contra +X1 -X2.\n\n- : hsubst_rr_closed_contra \n     (hsubst_rr_app _ _ Dr)\n     X\n     <- hsubst_rr_closed_contra Dr X.\n\n- : hsubst_rr_closed_contra \n     (hsubst_rr_fst D)\n     X\n     <- hsubst_rr_closed_contra D X.\n\n- : hsubst_rr_closed_contra \n     (hsubst_rr_snd D)\n     X\n     <- hsubst_rr_closed_contra D X.\n\n%worlds (rtm_block) (hsubst_rr_closed_contra _ _).\n%total D (hsubst_rr_closed_contra D _).\n\n%% contradiction of root and non-root\n\nhsubst_r_rr_contra : hsubst_r M2 A2 R R'\n                      -> hsubst_rr M2 A2 R M' A'\n                      -> false\n                      -> type.\n%mode hsubst_r_rr_contra +X1 +X2 -X3.\n\n- : hsubst_r_rr_contra\n     hsubst_r_closed\n     Drr\n     X\n     <- hsubst_rr_closed_contra Drr X.\n\n- : hsubst_r_rr_contra \n     (hsubst_r_app _ DsrR)\n     (hsubst_rr_app _ _ DsrrR)\n     X\n     <- hsubst_r_rr_contra DsrR DsrrR X.\n\n- : hsubst_r_rr_contra \n     (hsubst_r_fst DsrR)\n     (hsubst_rr_fst DsrrR)\n     X\n     <- hsubst_r_rr_contra DsrR DsrrR X.\n\n- : hsubst_r_rr_contra \n     (hsubst_r_snd DsrR)\n     (hsubst_rr_snd DsrrR)\n     X\n     <- hsubst_r_rr_contra DsrR DsrrR X.\n\n%worlds (rtm_block) (hsubst_r_rr_contra _ _ _). %% bar in extra block for lemma below's future use\n%total (D) (hsubst_r_rr_contra D _ _).\n\n%% false implies id\nfalse_implies_id/mtm : {M} {M'}\n                        false \n                        -> id/mtm M M'\n                        -> type.\n%mode false_implies_id/mtm +X1 +X2 +X3 -X4.\n%worlds (rtm_block) (false_implies_id/mtm _ _ _ _). %% bar in extra block for lemma below's future use\n%total {} (false_implies_id/mtm _ _ _ _).\n\nhsubst_r_vacuous_id : hsubst_r M2 A2 ([_] R) R'\n                     -> id/rtm R' R\n                     -> type.\n%mode hsubst_r_vacuous_id +X1 -X2.\n\nhsubst_m_vacuous_id : hsubst_m M2 A2 ([_] M) M'\n                     -> id/mtm M' M\n                     -> type.\n%mode hsubst_m_vacuous_id +X1 -X2.\n\n%% R\n\n- : hsubst_r_vacuous_id hsubst_r_closed id/rtm_refl.\n\n- : hsubst_r_vacuous_id (hsubst_r_app Dm Dr) Did'\n     <- hsubst_r_vacuous_id Dr DidR\n     <- hsubst_m_vacuous_id Dm DidM\n     <- id/rtm_app_cong DidR DidM Did'.\n\n- : hsubst_r_vacuous_id (hsubst_r_fst D) Did'\n     <- hsubst_r_vacuous_id D Did\n     <- id/rtm_fst_cong Did Did'.\n\n- : hsubst_r_vacuous_id (hsubst_r_snd D) Did'\n     <- hsubst_r_vacuous_id D Did\n     <- id/rtm_snd_cong Did Did'.\n\n%% M\n\n- : hsubst_m_vacuous_id\n     (hsubst_m_r Dr)\n     Did'\n     <- hsubst_r_vacuous_id Dr Did\n     <- id/mtm_asm_cong Did Did'.\n\n- : hsubst_m_vacuous_id\n     (hsubst_m_rr D)\n     Did\n     <- hsubst_rr_closed_contra D X\n     <- false_implies_id/mtm _ _ X Did.\n\n- : hsubst_m_vacuous_id\n     (hsubst_m_lam D)\n     Did'\n     <- ({x} \n           hsubst_m_vacuous_id (D x) (Did x))\n     <- id/mtm_lam_cong Did Did'.\n\n- : hsubst_m_vacuous_id\n     (hsubst_m_pair D2 D1)\n     Did'\n     <- hsubst_m_vacuous_id D1 Did1\n     <- hsubst_m_vacuous_id D2 Did2\n     <- id/mtm_pair_cong Did1 Did2 Did'.\n\n%worlds (rtm_block) (hsubst_r_vacuous_id _ _) (hsubst_m_vacuous_id _ _).\n%total (D1 D2) \n(hsubst_r_vacuous_id D1 _)\n(hsubst_m_vacuous_id D2 _).\n\nhsubst_m_unique : hsubst_m M2 A2 M M'\n                   -> hsubst_m M2 A2 M M''\n                   -> id/mtm M' M''\n                   -> type.\n%mode hsubst_m_unique +X1 +X2 -X3.\n\nhsubst_r_unique : hsubst_r M2 A2 R R'\n                   -> hsubst_r M2 A2 R R''\n                   -> id/rtm R' R''\n                   -> type.\n%mode hsubst_r_unique +X1 +X2 -X3.\n\nhsubst_rr_unique : hsubst_rr M2 A2 R M' A'\n                    -> hsubst_rr M2 A2 R M'' A''\n                    -> id/mtm M' M''\n                    -> id/tp A' A''\n                    -> type.\n%mode hsubst_rr_unique +X1 +X2 -X3 -X4.\n\n%% M\n\n- : hsubst_m_unique\n     (hsubst_m_r Dsr)\n     (hsubst_m_r Dsr')\n     DidAsm\n     <- hsubst_r_unique Dsr Dsr' DidR\n     <- id/mtm_asm_cong DidR DidAsm.\n\n- : hsubst_m_unique\n     (hsubst_m_rr Dsr)\n     (hsubst_m_rr Dsr')\n     Did\n     <- hsubst_rr_unique Dsr Dsr' Did _.\n\n%% contradict mismatch\n- : hsubst_m_unique\n     (hsubst_m_r Dsr)\n     (hsubst_m_rr Dsrr)\n     Did\n     <- hsubst_r_rr_contra Dsr Dsrr X\n     <- false_implies_id/mtm _ _ X Did.\n\n%% contradict mismatch\n- : hsubst_m_unique\n     (hsubst_m_rr Dsrr)\n     (hsubst_m_r Dsr)\n     Did\n     <- hsubst_r_rr_contra Dsr Dsrr X\n     <- false_implies_id/mtm _ _ X Did.\n\n- : hsubst_m_unique\n     (hsubst_m_pair DsRight DsLeft)\n     (hsubst_m_pair DsRight' DsLeft')\n     DidPair\n     <- hsubst_m_unique DsLeft DsLeft' DidLeft\n     <- hsubst_m_unique DsRight DsRight' DidRight\n     <- id/mtm_pair_cong DidLeft DidRight DidPair.\n\n- : hsubst_m_unique\n     (hsubst_m_lam Ds)\n     (hsubst_m_lam Ds')\n     DidLam\n     <- ({y:rtm} hsubst_m_unique (Ds y) (Ds' y) (Did y))\n     <- id/mtm_lam_cong Did DidLam.\n     \n%% R non-root\n\n- : hsubst_r_unique D D id/rtm_refl.\n\n- : hsubst_r_unique \n     (hsubst_r_closed : hsubst_r M2 A2 ([_] R) R)\n     (D : hsubst_r M2 A2 ([_] R) R')\n     Did'\n     <- hsubst_r_vacuous_id D Did\n     <- id/rtm_sym Did Did'.\n\n- : hsubst_r_unique \n     (D : hsubst_r M2 A2 ([_] R) R')\n     (hsubst_r_closed : hsubst_r M2 A2 ([_] R) R)\n     Did\n     <- hsubst_r_vacuous_id D Did.\n\n- : hsubst_r_unique \n     (hsubst_r_app DsM' DsR') \n     (hsubst_r_app DsM'' DsR'')\n     DidApp\n     <- hsubst_r_unique DsR' DsR'' DidR\n     <- hsubst_m_unique DsM' DsM'' DidM\n     <- id/rtm_app_cong DidR DidM DidApp.\n\n- : hsubst_r_unique\n     (hsubst_r_fst DsR')\n     (hsubst_r_fst DsR'')\n     DidFst\n     <- hsubst_r_unique DsR' DsR'' DidR\n     <- id/rtm_fst_cong DidR DidFst.\n- : hsubst_r_unique\n     (hsubst_r_snd DsR')\n     (hsubst_r_snd DsR'')\n     DidSnd\n     <- hsubst_r_unique DsR' DsR'' DidR\n     <- id/rtm_snd_cong DidR DidSnd.\n\n%% R root\n\n- : hsubst_rr_unique \n     hsubst_rr_var\n     hsubst_rr_var\n     id/mtm_refl\n     id/tp_refl.\n\n- : hsubst_rr_unique\n     (hsubst_rr_app DsM4' DsM3 DsR1)\n     (hsubst_rr_app DsM4'-2 DsM3-2 DsR1-2)\n     DidM4''\n     DidA4\n     <- hsubst_rr_unique DsR1 DsR1-2 DidLam DidArrow\n     <- hsubst_m_unique DsM3 DsM3-2 DidM3'\n     <- id/tp_arrow_inv DidArrow DidA3 DidA4\n     <- id/mtm_lam_inv DidLam DidM4'\n     <- hsubst_m_respects_id DidM3' DidA3 DidM4' DsM4' DsM4'-1\n     <- hsubst_m_unique DsM4'-1 DsM4'-2 DidM4''.\n\n- : hsubst_rr_unique \n     (hsubst_rr_fst DsR')\n     (hsubst_rr_fst DsR'')\n     DidMl\n     DidAl\n     <- hsubst_rr_unique DsR' DsR'' DidPair DidProd\n     <- id/tp_prod_inv DidProd DidAl _\n     <- id/mtm_pair_inv DidPair DidMl _.\n\n- : hsubst_rr_unique \n     (hsubst_rr_snd DsR')\n     (hsubst_rr_snd DsR'')\n     DidMr\n     DidAr\n     <- hsubst_rr_unique DsR' DsR'' DidPair DidProd\n     <- id/tp_prod_inv DidProd _ DidAr\n     <- id/mtm_pair_inv DidPair _ DidMr.\n\n%worlds (rtm_block) \n(hsubst_m_unique _ _ _)\n(hsubst_r_unique _ _ _)\n(hsubst_rr_unique _ _ _ _).\n\n%total (D1 D2 D3) \n(hsubst_r_unique D2 _ _)\n(hsubst_rr_unique D3 _ _ _)\n(hsubst_m_unique D1 _ _).\n\nexpand_exists : {A}\n                 atom R A\n                 -> expand A R M\n                 -> canon M A\n                 -> type.\n%mode expand_exists +X0 +X1 -X2 -X3.\n\n- : expand_exists \n     b\n     D\n     expand_b\n     (canon_asm D).\n\n- : expand_exists\n     (arrow A2 A)\n     DaR\n     (expand_arrow DeApp DeX)\n     (canon_lam DcApp)\n     <- ({x : rtm}\n           {dx : atom x A2}\n           expand_exists A2 dx (DeX x) (DcM x dx))\n     <- ({x : rtm}\n           {dx : atom x A2}\n           expand_exists A (atom_app (DcM x dx) DaR) (DeApp x) (DcApp x dx)).\n\n- : expand_exists\n     (prod A1 A2)\n     DaR\n     (expand_prod DeS DeF)\n     (canon_pair DcS DcF)\n     <- expand_exists A1 (atom_fst DaR) DeF DcF\n     <- expand_exists A2 (atom_snd DaR) DeS DcS.\n\n%worlds (atom_block) (expand_exists _ _ _ _). \n%total D (expand_exists D _ _ _).\n\nexpand_unique : expand A R M \n                 -> expand A R M'\n                 -> id/mtm M M'\n                 -> type.\n%mode expand_unique +X1 +X2 -X3.\n\n- : expand_unique\n     expand_b\n     expand_b\n     id/mtm_refl.\n\n- : expand_unique \n     (expand_arrow \n        (DeApp : {x : rtm} expand A (app R (Mx x)) (MApp x))\n        (DeX : {x : rtm} expand A2 x (Mx x)))\n      (expand_arrow \n         (DeApp' : {x : rtm} expand A (app R (Mx' x)) (MApp' x))\n         (DeX' : {x : rtm} expand A2 x (Mx' x)))\n     DidLam\n     <- ({x : rtm}\n           expand_unique (DeX x) (DeX' x) (DidX x))\n     <- ({x : rtm}\n           id/rtm_app_cong (id/rtm_refl : id/rtm R R) (DidX x) (DidApp x))\n     <- ({x : rtm}\n           expand_respects_id (DidApp x) id/mtm_refl (DeApp x) (DeApp-2 x))\n     <- ({x : rtm} \n           expand_unique (DeApp-2 x) (DeApp' x) (DidAppExp x))\n     <- id/mtm_lam_cong DidAppExp DidLam.\n\n- : expand_unique\n     (expand_prod DeS DeF)\n     (expand_prod DeS' DeF')\n     DidPair\n     <- expand_unique DeF DeF' DidF\n     <- expand_unique DeS DeS' DidS\n     <- id/mtm_pair_cong DidF DidS DidPair.\n     \n%worlds (rtm_block) (expand_unique _ _ _).\n%total D (expand_unique _ D _).\n\ntp : type.\n\nb : tp.\narrow : tp -> tp -> tp.\nprod : tp -> tp -> tp.\n\nrtm : type.\nmtm : type.\n\napp : rtm -> mtm -> rtm.\nc : rtm.\nfst : rtm -> rtm.\nsnd : rtm -> rtm.\n\nasm : rtm -> mtm.\nlam : (rtm -> mtm) -> mtm.\npair : mtm -> mtm -> mtm.\n\n%block rtm_block : block {x : rtm}.\n%worlds (rtm_block) (tp) (rtm) (mtm).\n\natom : rtm -> tp -> type.\n%mode atom +X1 -X2.\n\ncanon : mtm -> tp -> type.\n%mode canon +X1 +X2.\n\n% atomic \n\natom_c : atom c b.\n\natom_app : atom (app R1 M2) A\n            <- atom R1 (arrow A2 A)\n            <- canon M2 A2.\n\natom_fst : atom (fst R) A1\n            <- atom R (prod A1 A2).\n\natom_snd : atom (snd R) A2\n            <- atom R (prod A1 A2).\n\n%% canonical \n\ncanon_asm : canon (asm R) b\n             <- atom R b.\n\ncanon_lam : canon (lam M) (arrow A2 A)\n             <- {x : rtm} (atom x A2) ->  canon (M x) A.\n\ncanon_pair : canon (pair M1 M2) (prod A1 A2)\n              <- canon M1 A1\n              <- canon M2 A2.\n\n%block atom_block : some {A:tp}\n                     block {x:rtm} {dx : atom x A}. \n%worlds (atom_block) (atom _ _) (canon _ _).\n%terminates (R M) (atom R _) (canon M _).\n\nhsubst_m : mtm -> tp -> (rtm -> mtm) -> mtm -> type.\n%mode hsubst_m +X1 +X2 +X3 -X4.\n\nhsubst_r : mtm -> tp -> (rtm -> rtm) -> rtm -> type.\n%mode hsubst_r +X1 +X2 +X3 -X4.\n\nhsubst_rr : mtm -> tp -> (rtm -> rtm) -> mtm -> tp -> type.\n%mode hsubst_rr +X1 +X2 +X3 -X4 -X5.\n\n%% Ms\n\nhsubst_m_r : hsubst_m M0 A0 ([x] asm (R x)) (asm R')\n              <- hsubst_r M0 A0 R R'.\n\nhsubst_m_rr : hsubst_m M0 A0 ([x] asm (R x)) M'\n               <- hsubst_rr M0 A0 R M' _.\n\nhsubst_m_lam : hsubst_m M0 A0 ([x] (lam ([y] M x y))) (lam M')\n                <- ({y:rtm} \n                      hsubst_m M0 A0 ([x] M x y) (M' y)).\n\nhsubst_m_pair : hsubst_m M0 A0 ([x] (pair (M1 x) (M2 x))) (pair M1' M2')\n                 <- hsubst_m M0 A0 M1 M1'\n                 <- hsubst_m M0 A0 M2 M2'.\n\n%% R not head\n\nhsubst_r_closed : hsubst_r M0 A0 ([x] E) E.\n\nhsubst_r_app : hsubst_r M0 A0 ([x] (app (R x) (M x))) (app R' M')\n                <- hsubst_r M0 A0 R R'\n                <- hsubst_m M0 A0 M M'.\n\nhsubst_r_fst : hsubst_r M0 A0 ([x] (fst (R x))) (fst R')\n                <- hsubst_r M0 A0 R R'.\n\nhsubst_r_snd : hsubst_r M0 A0 ([x] (snd (R x))) (snd R')\n                <- hsubst_r M0 A0 R R'.\n\n%% r head\n\nhsubst_rr_var : hsubst_rr M0 A0 ([x] x) M0 A0.\n\nhsubst_rr_app : hsubst_rr M0 A0 ([x] app (R1 x) (M2 x)) M'' A\n                 <- hsubst_rr M0 A0 R1 (lam M') (arrow A2 A)\n                 <- hsubst_m M0 A0 M2 M2'\n                 <- hsubst_m M2' A2 M' M''.\n\nhsubst_rr_fst : hsubst_rr M0 A0 ([x] (fst (R x))) M1' A1'\n                 <- hsubst_rr M0 A0 R (pair M1' M2') (prod A1' A2').\n\nhsubst_rr_snd : hsubst_rr M0 A0 ([x] (snd (R x))) M2' A2'\n                 <- hsubst_rr M0 A0 R (pair M1' M2') (prod A1' A2').\n\n%worlds (rtm_block) (hsubst_m _ _ _ _) (hsubst_r _ _ _ _) (hsubst_rr _ _ _ _ _).\n%reduces A' <= A0 (hsubst_rr _ A0 _ _ A').\n%terminates {(A0 A0' A0'') (M R R')} (hsubst_m _ A0 M _) (hsubst_r _ A0' R _) (hsubst_rr _ A0'' R' _ _).\n\nexpand : tp -> rtm -> mtm -> type.\n%mode expand +X1 +X2 -X3.\n\nexpand_b : expand b R (asm R).\n\nexpand_arrow : expand (arrow A2 A) R (lam M)\n                <- ({x : rtm} expand A2 x (M2 x))\n                <- ({x : rtm} expand A (app R (M2 x)) (M x)).\n\nexpand_prod : expand (prod A1 A2) R (pair M1 M2)\n               <- expand A1 (fst R) M1\n               <- expand A2 (snd R) M2.\n\n%worlds (rtm_block) (expand _ _ _).\n%total A (expand A _ _).\n\nhsubst_rr_size : {A2} {A'} hsubst_rr M2 A2 R M' A'\n                    -> type.\n%mode hsubst_rr_size +X1 +X2 +X3.\n\n- : hsubst_rr_size \n     A2 A2 hsubst_rr_var.\n\n- : hsubst_rr_size\n     A2 A4 (hsubst_rr_app _ _ Drr)\n     <- hsubst_rr_size A2 (arrow A3 A4) Drr.\n\n- : hsubst_rr_size\n     A2 Al (hsubst_rr_fst Drr)\n     <- hsubst_rr_size A2 (prod Al Ar) Drr.\n\n- : hsubst_rr_size\n     A2 Ar (hsubst_rr_snd Drr)\n     <- hsubst_rr_size A2 (prod Al Ar) Drr.\n\n%worlds (rtm_block) (hsubst_rr_size _ _ _).\n%total D (hsubst_rr_size _ _ D).\n%reduces A' <= A2 (hsubst_rr_size A2 A' _).\n \nhsubst_r_exists_sum : mtm -> tp -> (rtm -> rtm) -> tp -> type.\nhsubst_r_exists_sum_r : hsubst_r_exists_sum M2 A2 R A\n                         <- hsubst_r M2 A2 R R'\n                         <- atom R' A.\nhsubst_r_exists_sum_rr : hsubst_r_exists_sum M2 A2 R A'\n                          <- hsubst_rr M2 A2 R M' A'\n                          <- canon M' A'.\n\nhsubst_m_exists_asm :  hsubst_r_exists_sum M2 A2 R b\n                       -> hsubst_m M2 A2 ([x] (asm (R x))) M'\n                       -> canon M' b\n                       -> type.\n%mode hsubst_m_exists_asm +X1 -X2 -X3.\n\n- : hsubst_m_exists_asm \n     (hsubst_r_exists_sum_r DaR' DsR)\n     (hsubst_m_r DsR)\n     (canon_asm DaR').\n\n- : hsubst_m_exists_asm \n     (hsubst_r_exists_sum_rr DcM' DsR)\n     (hsubst_m_rr DsR)\n     DcM'.\n\n%worlds (atom_block) (hsubst_m_exists_asm _ _ _).\n%total {} (hsubst_m_exists_asm _ _ _).\n\n\nhsubst_r_exists_fst : hsubst_r_exists_sum M2 A2 R (prod Al Ar)\n                       -> hsubst_r_exists_sum M2 A2 ([x] (fst (R x))) Al\n                       -> type.\n%mode hsubst_r_exists_fst +X1 -X2.\n\n- : hsubst_r_exists_fst \n     (hsubst_r_exists_sum_r DaR' DsR)\n     (hsubst_r_exists_sum_r (atom_fst DaR') (hsubst_r_fst DsR)).\n\n- : hsubst_r_exists_fst \n     (hsubst_r_exists_sum_rr (canon_pair _ DcMl') DsR)\n     (hsubst_r_exists_sum_rr DcMl' (hsubst_rr_fst DsR)).\n\n%worlds (atom_block) (hsubst_r_exists_fst _ _).\n%total {} (hsubst_r_exists_fst _ _).\n\n\nhsubst_r_exists_snd : hsubst_r_exists_sum M2 A2 R (prod Al Ar)\n                       -> hsubst_r_exists_sum M2 A2 ([x] (snd (R x))) Ar\n                       -> type.\n%mode hsubst_r_exists_snd +X1 -X2.\n\n- : hsubst_r_exists_snd \n     (hsubst_r_exists_sum_r DaR' DsR)\n     (hsubst_r_exists_sum_r (atom_snd DaR') (hsubst_r_snd DsR)).\n\n- : hsubst_r_exists_snd \n     (hsubst_r_exists_sum_rr (canon_pair DcMr' _) DsR)\n     (hsubst_r_exists_sum_rr DcMr' (hsubst_rr_snd DsR)).\n\n%worlds (atom_block) (hsubst_r_exists_snd _ _).\n%total {} (hsubst_r_exists_snd _ _).\n\nhsubst_m_exists : {A2}\n                   ({y : rtm} {dy : atom y A2} canon (M y) A)\n                   -> canon M2 A2\n                   -> hsubst_m M2 A2 M M'\n                   -> canon M' A\n                   -> type.\n%mode hsubst_m_exists +X0 +X1 +X2 -X3 -X4.\n\nhsubst_r_exists : {A2}\n                   ({y : rtm} {dx : atom y A2} atom (R y) A)\n                   -> canon M2 A2\n                   -> hsubst_r_exists_sum M2 A2 R A\n                   -> type.\n%mode hsubst_r_exists +X0 +X1 +X2 -X3.\n\nhsubst_m_exists_app : {A2}\n                       %% this next argument is makes the termination argument work\n                       ({y : rtm} {dx : atom y A2} atom (R1 y) (arrow A3 A4)) \n                       -> hsubst_r_exists_sum M2 A2 R1 (arrow A3 A4)\n                       -> hsubst_m M2 A2 M3 M3'\n                       -> canon M3' A3\n                       -> hsubst_r_exists_sum M2 A2 ([x] (app (R1 x) (M3 x))) A4\n                       -> type.\n%mode hsubst_m_exists_app +X-1 +X0 +X1 +X2 +X3 -X4.\n\n%% canonical terms\n\n- : hsubst_m_exists \n     A2\n     ([x] [dx] canon_asm (DaR x dx))\n     DcM2\n     DsR\n     DcM'\n     <- hsubst_r_exists A2 DaR DcM2 Dsum\n     <- hsubst_m_exists_asm Dsum DsR DcM'.\n\n- : hsubst_m_exists \n     A2\n     ([x] [dx] (canon_lam ([y] [dy] DcM x dx y dy)) : canon (lam (M x)) (arrow Af At))\n     (DcM2 : canon M2 A2)\n     (hsubst_m_lam DsM)\n     (canon_lam DcM')\n     <- ({y} \n           {dy : atom y Af}\n           hsubst_m_exists A2 ([x] [dx] (DcM x dx y dy)) DcM2 (DsM y) (DcM' y dy)).\n\n- : hsubst_m_exists\n     A2\n     ([x] [dx] (canon_pair (DcMr x dx) (DcMl x dx)))\n     DcM2\n     (hsubst_m_pair DsMr DsMl)\n     (canon_pair DcMr' DcMl')\n     <- hsubst_m_exists A2 DcMl DcM2 DsMl DcMl'\n     <- hsubst_m_exists A2 DcMr DcM2 DsMr DcMr'.\n\n%% atomic terms\n\n- : hsubst_r_exists \n     A2\n     ([x] [dx] D)\n     _\n     (hsubst_r_exists_sum_r D hsubst_r_closed).\n\n- : hsubst_r_exists\n     A2\n     ([x] [dx] dx)\n     DcM2\n     (hsubst_r_exists_sum_rr DcM2 hsubst_rr_var).\n\n- : hsubst_r_exists\n     A2\n     ([x] [dx] (atom_app (DcM x dx) (DaR x dx)))\n     DcM2\n     DsumApp\n     <- hsubst_m_exists A2 DcM DcM2 DsM' DcM'\n     <- hsubst_r_exists A2 DaR DcM2 DsumR'\n     <- hsubst_m_exists_app A2 DaR DsumR' DsM' DcM' DsumApp.\n\n- : hsubst_r_exists\n     A2\n     ([x] [dx] (atom_fst (DcR x dx)))\n     DcM2\n     DsumFst\n     <- hsubst_r_exists A2 DcR DcM2 DsumR\n     <- hsubst_r_exists_fst DsumR DsumFst.\n\n- : hsubst_r_exists\n     A2\n     ([x] [dx] (atom_snd (DcR x dx)))\n     DcM2\n     DsumSnd\n     <- hsubst_r_exists A2 DcR DcM2 DsumR\n     <- hsubst_r_exists_snd DsumR DsumSnd.\n\n%% app factoring lemma\n\n- : hsubst_m_exists_app \n     A2 \n     _\n     (hsubst_r_exists_sum_r DaR1 DsR1)\n     DsM3\n     DcM3\n     (hsubst_r_exists_sum_r (atom_app DcM3 DaR1) (hsubst_r_app DsM3 DsR1)).\n\n- : hsubst_m_exists_app \n     A2\n     _\n     (hsubst_r_exists_sum_rr (canon_lam DcM4') DsR1)\n     DsM3\n     DcM3\n     (hsubst_r_exists_sum_rr DcM4'' (hsubst_rr_app DsM4' DsM3 DsR1))\n     <- hsubst_rr_size A2 (arrow A3 A4) DsR1\n     <- hsubst_m_exists A3 DcM4' DcM3 DsM4' DcM4''.\n\n%worlds (atom_block) \n(hsubst_m_exists_app _ _ _ _ _ _)\n(hsubst_r_exists _ _ _ _)\n(hsubst_m_exists _ _ _ _ _).\n\n%total {(A2 A2' A2'') (D  D' D'')}\n(hsubst_m_exists A2' D' _ _ _)\n(hsubst_m_exists_app A2'' D'' _ _ _ _)\n(hsubst_r_exists A2 D _ _).\n\nid/mtm : mtm -> mtm -> type.\nid/mtm_refl : id/mtm M M.\n\nid/rtm : rtm -> rtm -> type.\nid/rtm_refl : id/rtm R R.\n\nid/tp : tp -> tp -> type.\nid/tp_refl : id/tp A A.\n\nid/rtm_sym : id/rtm R R'\n\t      -> id/rtm R' R\n\t      -> type.\n%mode id/rtm_sym +X1 -X2.\n\n- : id/rtm_sym id/rtm_refl id/rtm_refl.\n\n%worlds (rtm_block) (id/rtm_sym _ _).\n%total {} (id/rtm_sym _ _).\n\nid/tp_arrow_inv : id/tp (arrow A1 A2) (arrow A1' A2')\n\t\t   -> id/tp A1 A1'\n\t\t   -> id/tp A2 A2'\n\t\t   -> type.\n%mode id/tp_arrow_inv +X1 -X2 -X3.\n\n- : id/tp_arrow_inv _ id/tp_refl id/tp_refl.\n\n%worlds (rtm_block) (id/tp_arrow_inv _ _ _).\n%total {} (id/tp_arrow_inv _ _ _).\n\nid/tp_prod_inv : id/tp (prod A1 A2) (prod A1' A2')\n\t\t   -> id/tp A1 A1'\n\t\t   -> id/tp A2 A2'\n\t\t   -> type.\n%mode id/tp_prod_inv +X1 -X2 -X3.\n\n- : id/tp_prod_inv _ id/tp_refl id/tp_refl.\n\n%worlds (rtm_block) (id/tp_prod_inv _ _ _).\n%total {} (id/tp_prod_inv _ _ _).\n\nid/rtm_app_cong : id/rtm R R'\n\t\t   -> id/mtm M M'\n\t\t   -> id/rtm (app R M) (app R' M')\n\t\t   -> type.\n%mode id/rtm_app_cong +X1 +X2 -X3.\n\n- : id/rtm_app_cong _ _ id/rtm_refl.\n\n%worlds (rtm_block) (id/rtm_app_cong _ _ _).\n%total {} (id/rtm_app_cong _ _ _).\n\nid/rtm_fst_cong : id/rtm R R'\n\t\t   -> id/rtm (fst R) (fst R')\n\t\t   -> type.\n%mode id/rtm_fst_cong +X1  -X3.\n\n- : id/rtm_fst_cong _ id/rtm_refl.\n\n%worlds (rtm_block) (id/rtm_fst_cong _ _).\n%total {} (id/rtm_fst_cong _ _).\n\nid/rtm_snd_cong : id/rtm R R'\n\t\t   -> id/rtm (snd R) (snd R')\n\t\t   -> type.\n%mode id/rtm_snd_cong +X1  -X3.\n\n- : id/rtm_snd_cong _ id/rtm_refl.\n\n%worlds (rtm_block) (id/rtm_snd_cong _ _).\n%total {} (id/rtm_snd_cong _ _).\n\nid/mtm_lam_cong :  ({x:rtm} id/mtm (M x) (M' x))\n\t\t   -> id/mtm (lam M) (lam M')\n\t\t   -> type.\n%mode id/mtm_lam_cong +X1 -X3.\n\n- : id/mtm_lam_cong _ id/mtm_refl.\n\n%worlds (rtm_block) (id/mtm_lam_cong _ _).\n%total {} (id/mtm_lam_cong _ _).\n\nid/mtm_lam_inv :  id/mtm (lam M) (lam M')\n\t\t  -> ({x:rtm} id/mtm (M x) (M' x))\n\t\t  -> type.\n%mode id/mtm_lam_inv +X1 -X3.\n\n- : id/mtm_lam_inv _ ([_] id/mtm_refl).\n\n%worlds (rtm_block) (id/mtm_lam_inv _ _).\n%total {} (id/mtm_lam_inv _ _).\n\nid/mtm_pair_cong : id/mtm M1 M1'\n\t\t   -> id/mtm M2 M2'\n\t\t   -> id/mtm (pair M1 M2) (pair M1' M2')\n\t\t   -> type.\n%mode id/mtm_pair_cong +X1 +X2 -X3.\n\n- : id/mtm_pair_cong _ _ id/mtm_refl.\n\n%worlds (rtm_block) (id/mtm_pair_cong _ _ _).\n%total {} (id/mtm_pair_cong _ _ _).\n\nid/mtm_pair_inv : id/mtm (pair M1 M2) (pair M1' M2')\n\t\t   -> id/mtm M1 M1'\n\t\t   -> id/mtm M2 M2'\n\t\t   -> type.\n%mode id/mtm_pair_inv +X1 -X2 -X3.\n\n- : id/mtm_pair_inv _ id/mtm_refl id/mtm_refl.\n\n%worlds (rtm_block) (id/mtm_pair_inv _ _ _).\n%total {} (id/mtm_pair_inv _ _ _).\n\nexpand_respects_id : id/rtm R R'\n\t\t      -> id/mtm M M'\n\t\t      -> expand A R M\n\t\t      -> expand A R' M'\n\t\t      -> type.\n%mode expand_respects_id +X1 +X2 +X3 -X4.\n\n- : expand_respects_id _ _ D D.\n\n%worlds (rtm_block) (expand_respects_id _ _ _ _).\n%total {} (expand_respects_id _ _ _ _).\n%reduces D1 = D2 (expand_respects_id _ _ D2 D1).\n\ncanon_respects_id :  id/mtm M M'\n\t\t     -> id/tp A A'\n\t\t     -> canon M A\n\t\t     -> canon M' A'\n\t\t     -> type.\n%mode canon_respects_id +X1 +X2 +X3 -X4.\n\n- : canon_respects_id _ _ D D.\n\n%worlds (atom_block) (canon_respects_id _ _ _ _).\n%total {} (canon_respects_id _ _ _ _).\n%reduces D1 = D2 (canon_respects_id _ _ D2 D1).\n\nhsubst_m_respects_id : id/mtm M2 M2'\n\t\t\t-> id/tp A2 A2'\n\t\t\t-> ({x} id/mtm (M x) (M' x))\n\t\t\t-> hsubst_m M2 A2 M Ms\n\t\t\t-> hsubst_m M2' A2' M' Ms\n\t\t\t-> type.\n%mode hsubst_m_respects_id +X1 +X2 +X3 +X4 -X5.\n\n- : hsubst_m_respects_id _ _ _ D D.\n\n%worlds (rtm_block) (hsubst_m_respects_id _ _ _ _ _).\n%total {} (hsubst_m_respects_id _ _ _ _ _).\n%reduces D1 = D2 (hsubst_m_respects_id _ _ _ D2 D1).\n\nid/mtm_asm_cong : id/rtm R R'\n\t\t   -> id/mtm (asm R) (asm R')\n\t\t   -> type.\n%mode id/mtm_asm_cong +X1  -X3.\n\n- : id/mtm_asm_cong _ id/mtm_refl.\n\n%worlds (rtm_block) (id/mtm_asm_cong _ _).\n%total {} (id/mtm_asm_cong _ _).\n\nfalse : type.\n%freeze false.\n\nhsubst_rr_closed_contra : hsubst_rr M2 A2 ([_] R) M' A'\n                           -> false\n                           -> type.\n%mode hsubst_rr_closed_contra +X1 -X2.\n\n- : hsubst_rr_closed_contra \n     (hsubst_rr_app _ _ Dr)\n     X\n     <- hsubst_rr_closed_contra Dr X.\n\n- : hsubst_rr_closed_contra \n     (hsubst_rr_fst D)\n     X\n     <- hsubst_rr_closed_contra D X.\n\n- : hsubst_rr_closed_contra \n     (hsubst_rr_snd D)\n     X\n     <- hsubst_rr_closed_contra D X.\n\n%worlds (rtm_block) (hsubst_rr_closed_contra _ _).\n%total D (hsubst_rr_closed_contra D _).\n\n%% contradiction of root and non-root\n\nhsubst_r_rr_contra : hsubst_r M2 A2 R R'\n                      -> hsubst_rr M2 A2 R M' A'\n                      -> false\n                      -> type.\n%mode hsubst_r_rr_contra +X1 +X2 -X3.\n\n- : hsubst_r_rr_contra\n     hsubst_r_closed\n     Drr\n     X\n     <- hsubst_rr_closed_contra Drr X.\n\n- : hsubst_r_rr_contra \n     (hsubst_r_app _ DsrR)\n     (hsubst_rr_app _ _ DsrrR)\n     X\n     <- hsubst_r_rr_contra DsrR DsrrR X.\n\n- : hsubst_r_rr_contra \n     (hsubst_r_fst DsrR)\n     (hsubst_rr_fst DsrrR)\n     X\n     <- hsubst_r_rr_contra DsrR DsrrR X.\n\n- : hsubst_r_rr_contra \n     (hsubst_r_snd DsrR)\n     (hsubst_rr_snd DsrrR)\n     X\n     <- hsubst_r_rr_contra DsrR DsrrR X.\n\n%worlds (rtm_block) (hsubst_r_rr_contra _ _ _). %% bar in extra block for lemma below's future use\n%total (D) (hsubst_r_rr_contra D _ _).\n\n%% false implies id\nfalse_implies_id/mtm : {M} {M'}\n                        false \n                        -> id/mtm M M'\n                        -> type.\n%mode false_implies_id/mtm +X1 +X2 +X3 -X4.\n%worlds (rtm_block) (false_implies_id/mtm _ _ _ _). %% bar in extra block for lemma below's future use\n%total {} (false_implies_id/mtm _ _ _ _).\n\nhsubst_r_vacuous_id : hsubst_r M2 A2 ([_] R) R'\n                     -> id/rtm R' R\n                     -> type.\n%mode hsubst_r_vacuous_id +X1 -X2.\n\nhsubst_m_vacuous_id : hsubst_m M2 A2 ([_] M) M'\n                     -> id/mtm M' M\n                     -> type.\n%mode hsubst_m_vacuous_id +X1 -X2.\n\n%% R\n\n- : hsubst_r_vacuous_id hsubst_r_closed id/rtm_refl.\n\n- : hsubst_r_vacuous_id (hsubst_r_app Dm Dr) Did'\n     <- hsubst_r_vacuous_id Dr DidR\n     <- hsubst_m_vacuous_id Dm DidM\n     <- id/rtm_app_cong DidR DidM Did'.\n\n- : hsubst_r_vacuous_id (hsubst_r_fst D) Did'\n     <- hsubst_r_vacuous_id D Did\n     <- id/rtm_fst_cong Did Did'.\n\n- : hsubst_r_vacuous_id (hsubst_r_snd D) Did'\n     <- hsubst_r_vacuous_id D Did\n     <- id/rtm_snd_cong Did Did'.\n\n%% M\n\n- : hsubst_m_vacuous_id\n     (hsubst_m_r Dr)\n     Did'\n     <- hsubst_r_vacuous_id Dr Did\n     <- id/mtm_asm_cong Did Did'.\n\n- : hsubst_m_vacuous_id\n     (hsubst_m_rr D)\n     Did\n     <- hsubst_rr_closed_contra D X\n     <- false_implies_id/mtm _ _ X Did.\n\n- : hsubst_m_vacuous_id\n     (hsubst_m_lam D)\n     Did'\n     <- ({x} \n           hsubst_m_vacuous_id (D x) (Did x))\n     <- id/mtm_lam_cong Did Did'.\n\n- : hsubst_m_vacuous_id\n     (hsubst_m_pair D2 D1)\n     Did'\n     <- hsubst_m_vacuous_id D1 Did1\n     <- hsubst_m_vacuous_id D2 Did2\n     <- id/mtm_pair_cong Did1 Did2 Did'.\n\n%worlds (rtm_block) (hsubst_r_vacuous_id _ _) (hsubst_m_vacuous_id _ _).\n%total (D1 D2) \n(hsubst_r_vacuous_id D1 _)\n(hsubst_m_vacuous_id D2 _).\n\nhsubst_m_unique : hsubst_m M2 A2 M M'\n                   -> hsubst_m M2 A2 M M''\n                   -> id/mtm M' M''\n                   -> type.\n%mode hsubst_m_unique +X1 +X2 -X3.\n\nhsubst_r_unique : hsubst_r M2 A2 R R'\n                   -> hsubst_r M2 A2 R R''\n                   -> id/rtm R' R''\n                   -> type.\n%mode hsubst_r_unique +X1 +X2 -X3.\n\nhsubst_rr_unique : hsubst_rr M2 A2 R M' A'\n                    -> hsubst_rr M2 A2 R M'' A''\n                    -> id/mtm M' M''\n                    -> id/tp A' A''\n                    -> type.\n%mode hsubst_rr_unique +X1 +X2 -X3 -X4.\n\n%% M\n\n- : hsubst_m_unique\n     (hsubst_m_r Dsr)\n     (hsubst_m_r Dsr')\n     DidAsm\n     <- hsubst_r_unique Dsr Dsr' DidR\n     <- id/mtm_asm_cong DidR DidAsm.\n\n- : hsubst_m_unique\n     (hsubst_m_rr Dsr)\n     (hsubst_m_rr Dsr')\n     Did\n     <- hsubst_rr_unique Dsr Dsr' Did _.\n\n%% contradict mismatch\n- : hsubst_m_unique\n     (hsubst_m_r Dsr)\n     (hsubst_m_rr Dsrr)\n     Did\n     <- hsubst_r_rr_contra Dsr Dsrr X\n     <- false_implies_id/mtm _ _ X Did.\n\n%% contradict mismatch\n- : hsubst_m_unique\n     (hsubst_m_rr Dsrr)\n     (hsubst_m_r Dsr)\n     Did\n     <- hsubst_r_rr_contra Dsr Dsrr X\n     <- false_implies_id/mtm _ _ X Did.\n\n- : hsubst_m_unique\n     (hsubst_m_pair DsRight DsLeft)\n     (hsubst_m_pair DsRight' DsLeft')\n     DidPair\n     <- hsubst_m_unique DsLeft DsLeft' DidLeft\n     <- hsubst_m_unique DsRight DsRight' DidRight\n     <- id/mtm_pair_cong DidLeft DidRight DidPair.\n\n- : hsubst_m_unique\n     (hsubst_m_lam Ds)\n     (hsubst_m_lam Ds')\n     DidLam\n     <- ({y:rtm} hsubst_m_unique (Ds y) (Ds' y) (Did y))\n     <- id/mtm_lam_cong Did DidLam.\n     \n%% R non-root\n\n- : hsubst_r_unique D D id/rtm_refl.\n\n- : hsubst_r_unique \n     (hsubst_r_closed : hsubst_r M2 A2 ([_] R) R)\n     (D : hsubst_r M2 A2 ([_] R) R')\n     Did'\n     <- hsubst_r_vacuous_id D Did\n     <- id/rtm_sym Did Did'.\n\n- : hsubst_r_unique \n     (D : hsubst_r M2 A2 ([_] R) R')\n     (hsubst_r_closed : hsubst_r M2 A2 ([_] R) R)\n     Did\n     <- hsubst_r_vacuous_id D Did.\n\n- : hsubst_r_unique \n     (hsubst_r_app DsM' DsR') \n     (hsubst_r_app DsM'' DsR'')\n     DidApp\n     <- hsubst_r_unique DsR' DsR'' DidR\n     <- hsubst_m_unique DsM' DsM'' DidM\n     <- id/rtm_app_cong DidR DidM DidApp.\n\n- : hsubst_r_unique\n     (hsubst_r_fst DsR')\n     (hsubst_r_fst DsR'')\n     DidFst\n     <- hsubst_r_unique DsR' DsR'' DidR\n     <- id/rtm_fst_cong DidR DidFst.\n- : hsubst_r_unique\n     (hsubst_r_snd DsR')\n     (hsubst_r_snd DsR'')\n     DidSnd\n     <- hsubst_r_unique DsR' DsR'' DidR\n     <- id/rtm_snd_cong DidR DidSnd.\n\n%% R root\n\n- : hsubst_rr_unique \n     hsubst_rr_var\n     hsubst_rr_var\n     id/mtm_refl\n     id/tp_refl.\n\n- : hsubst_rr_unique\n     (hsubst_rr_app DsM4' DsM3 DsR1)\n     (hsubst_rr_app DsM4'-2 DsM3-2 DsR1-2)\n     DidM4''\n     DidA4\n     <- hsubst_rr_unique DsR1 DsR1-2 DidLam DidArrow\n     <- hsubst_m_unique DsM3 DsM3-2 DidM3'\n     <- id/tp_arrow_inv DidArrow DidA3 DidA4\n     <- id/mtm_lam_inv DidLam DidM4'\n     <- hsubst_m_respects_id DidM3' DidA3 DidM4' DsM4' DsM4'-1\n     <- hsubst_m_unique DsM4'-1 DsM4'-2 DidM4''.\n\n- : hsubst_rr_unique \n     (hsubst_rr_fst DsR')\n     (hsubst_rr_fst DsR'')\n     DidMl\n     DidAl\n     <- hsubst_rr_unique DsR' DsR'' DidPair DidProd\n     <- id/tp_prod_inv DidProd DidAl _\n     <- id/mtm_pair_inv DidPair DidMl _.\n\n- : hsubst_rr_unique \n     (hsubst_rr_snd DsR')\n     (hsubst_rr_snd DsR'')\n     DidMr\n     DidAr\n     <- hsubst_rr_unique DsR' DsR'' DidPair DidProd\n     <- id/tp_prod_inv DidProd _ DidAr\n     <- id/mtm_pair_inv DidPair _ DidMr.\n\n%worlds (rtm_block) \n(hsubst_m_unique _ _ _)\n(hsubst_r_unique _ _ _)\n(hsubst_rr_unique _ _ _ _).\n\n%total (D1 D2 D3) \n(hsubst_r_unique D2 _ _)\n(hsubst_rr_unique D3 _ _ _)\n(hsubst_m_unique D1 _ _).\n\nexpand_exists : {A}\n                 atom R A\n                 -> expand A R M\n                 -> canon M A\n                 -> type.\n%mode expand_exists +X0 +X1 -X2 -X3.\n\n- : expand_exists \n     b\n     D\n     expand_b\n     (canon_asm D).\n\n- : expand_exists\n     (arrow A2 A)\n     DaR\n     (expand_arrow DeApp DeX)\n     (canon_lam DcApp)\n     <- ({x : rtm}\n           {dx : atom x A2}\n           expand_exists A2 dx (DeX x) (DcM x dx))\n     <- ({x : rtm}\n           {dx : atom x A2}\n           expand_exists A (atom_app (DcM x dx) DaR) (DeApp x) (DcApp x dx)).\n\n- : expand_exists\n     (prod A1 A2)\n     DaR\n     (expand_prod DeS DeF)\n     (canon_pair DcS DcF)\n     <- expand_exists A1 (atom_fst DaR) DeF DcF\n     <- expand_exists A2 (atom_snd DaR) DeS DcS.\n\n%worlds (atom_block) (expand_exists _ _ _ _). \n%total D (expand_exists D _ _ _).\n\nexpand_unique : expand A R M \n                 -> expand A R M'\n                 -> id/mtm M M'\n                 -> type.\n%mode expand_unique +X1 +X2 -X3.\n\n- : expand_unique\n     expand_b\n     expand_b\n     id/mtm_refl.\n\n- : expand_unique \n     (expand_arrow \n        (DeApp : {x : rtm} expand A (app R (Mx x)) (MApp x))\n        (DeX : {x : rtm} expand A2 x (Mx x)))\n      (expand_arrow \n         (DeApp' : {x : rtm} expand A (app R (Mx' x)) (MApp' x))\n         (DeX' : {x : rtm} expand A2 x (Mx' x)))\n     DidLam\n     <- ({x : rtm}\n           expand_unique (DeX x) (DeX' x) (DidX x))\n     <- ({x : rtm}\n           id/rtm_app_cong (id/rtm_refl : id/rtm R R) (DidX x) (DidApp x))\n     <- ({x : rtm}\n           expand_respects_id (DidApp x) id/mtm_refl (DeApp x) (DeApp-2 x))\n     <- ({x : rtm} \n           expand_unique (DeApp-2 x) (DeApp' x) (DidAppExp x))\n     <- id/mtm_lam_cong DidAppExp DidLam.\n\n- : expand_unique\n     (expand_prod DeS DeF)\n     (expand_prod DeS' DeF')\n     DidPair\n     <- expand_unique DeF DeF' DidF\n     <- expand_unique DeS DeS' DidS\n     <- id/mtm_pair_cong DidF DidS DidPair.\n     \n%worlds (rtm_block) (expand_unique _ _ _).\n%total D (expand_unique _ D _).\n</twelf>\n\n== External language: syntax and judgements ==\n\n=== Syntax ===\n\nThe external language syntax is a copy of the internal language, where we additionally include canonincal terms <tt>M</tt> into atomic terms <tt>R</tt>.  To preserve the modes of the typing judgements, these canonical terms are annotated with the type that they should be checked against.  \n\n<twelf>\nel_rtm : type.\nel_mtm : type.\n\nel_app : el_rtm -> el_mtm -> el_rtm.\nel_c : el_rtm.\nel_fst : el_rtm -> el_rtm.\nel_snd : el_rtm -> el_rtm.\nel_annot : el_mtm -> tp -> el_rtm.\n\nel_asm : el_rtm -> el_mtm.\nel_lam : (el_rtm -> el_mtm) -> el_mtm.\nel_pair : el_mtm -> el_mtm -> el_mtm.\n\n%block el_rtm_block : block {x : el_rtm}.\n</twelf>\n\nModulo the placement of type annotations, this grammar lets you write any term that you can write without the syntactic stratification.  \n\n=== Typing judgements ===\n\nThe typing judgements for the external language extand the judgements for canonical forms with a rule <tt>synth_annot</tt> for synthesizing the type of an annotated term.  Additionally, the rules do not force terms to be η-long.  \n\n<twelf>\nsynth : el_rtm -> tp -> type.\n%mode synth +X1 -X2.\ncheck : el_mtm -> tp -> type.\n%mode check +X1 +X2.\n\n% synthesize\n\nsynth_c : synth el_c b.\n\nsynth_app : synth (el_app R1 M2) A\n             <- synth R1 (arrow A2 A)\n             <- check M2 A2.\n\nsynth_fst : synth (el_fst R) A1\n             <- synth R (prod A1 A2).\n\nsynth_snd : synth (el_snd R) A2\n             <- synth R (prod A1 A2).\n\n%% admit non-canonical forms with an annotation\nsynth_annot : synth (el_annot M A) A\n               <- check M A.\n\n%% check\n\n%% in the EL anything that synths also checks, no matter the type\ncheck_asm : check (el_asm R) A\n             <- synth R A.\n\ncheck_lam : check (el_lam M) (arrow A2 A)\n             <- ({x : el_rtm} (synth x A2) -> check (M x) A).\n\ncheck_pair : check (el_pair M1 M2) (prod A1 A2)\n              <- check M1 A1\n              <- check M2 A2.\n\n%block synth_block : some {A:tp} block {x : el_rtm} {dx : synth x A}.\n%worlds (synth_block) (synth _ _) (check _ _).\n</twelf>\n\nIt is possible to show that any well-typed term in a standard presentation of the λ-calculus can be translated into a term in this syntax that is well-typed by these rules.  However, we have not formulated this step here, choosing instead to take these rules as the definition of the external language.  \n\n=== Elaboration ===\n\nWe now define elaboration.  We define three mutually recursive elaboration judgements, one for checked terms, and two for synthesizing terms.  The two judgements for synthesizing terms differ in whether the elaboration of the synthesizing term is an atomic term or a canonical term.  \n\n<twelf>\nelab_m : el_mtm -> mtm -> tp -> type.\n%mode elab_m +X1 -X2 +X3.\n\nelab_r_to_r : el_rtm -> rtm -> tp -> type.\n%mode elab_r_to_r +X1 -X2 -X3.\n\nelab_r_to_m : el_rtm -> mtm -> tp -> type.\n%mode elab_r_to_m +X1 -X2 -X3.\n\n% M\n\nelab_m_asm_r2r : elab_m (el_asm ER) M A\n                  <- elab_r_to_r ER R A\n                  <- expand A R M.\n\nelab_m_asm_r2m : elab_m (el_asm ER) M A\n                  <- elab_r_to_m ER M A.\n\nelab_m_lam : elab_m (el_lam EM) (lam M) (arrow A2 A)\n              <- ({el_x : el_rtm} {x : rtm} \n                    (elab_r_to_r el_x x A2) \n                    -> elab_m (EM el_x) (M x) A).\n\nelab_m_pair : elab_m (el_pair EM1 EM2) (pair M1 M2) (prod A1 A2)\n               <- elab_m EM1 M1 A1\n               <- elab_m EM2 M2 A2.\n\n% R to R\n\nelab_r_to_r_c : elab_r_to_r el_c c b.\n\nelab_r_to_r_app : elab_r_to_r (el_app ER1 EM2) (app R1 M2) A\n                   <- elab_r_to_r ER1 R1 (arrow A2 A)\n                   <- elab_m EM2 M2 A2.\n\nelab_r_to_r_fst : elab_r_to_r (el_fst ER) (fst R) A1\n                   <- elab_r_to_r ER R (prod A1 A2).\n\nelab_r_to_r_snd : elab_r_to_r (el_snd ER) (snd R) A2\n                   <- elab_r_to_r ER R (prod A1 A2).\n\n% R root\n\nelab_r_to_m_annot : elab_r_to_m (el_annot EM A) M A\n                     <- elab_m EM M A.\n\nelab_r_to_m_app : elab_r_to_m (el_app ER1 EM2) M' A\n                   <- elab_r_to_m ER1 (lam M) (arrow A2 A)\n                   <- elab_m EM2 M2 A2\n                   <- hsubst_m M2 A2 M M'.\n\nelab_r_to_m_fst : elab_r_to_m (el_fst ER) M1 A1\n                   <- elab_r_to_m ER (pair M1 M2) (prod A1 A2).\n\nelab_r_to_m_snd : elab_r_to_m (el_snd ER) M2 A2\n                   <- elab_r_to_m ER (pair M1 M2) (prod A1 A2).\n\n%block elab_block : some {A:tp}\n                     block \n                     {el_x : el_rtm} \n                     {x : rtm} \n                     {dex : elab_r_to_r el_x x A}.\n</twelf>\n\nThe inductive structure of the elaboration judgements is similar to the structure of hereditary substitution.  Elaboration uses hereditary substitution in the key rule <tt>elab_r_to_m_app</tt> to compute the canonical result of a function application.  Elaboration also uses expansion to expand atomic terms into canonical ones.\n\n== External Language: Metatheory  ==\n\n=== Static Correctness of Elaboration ===\n\nFirst, we prove that the elaboration of a well-typed term is well-typed.\n\n<twelf>\nelab_m_reg : elab_m EM M A\n\t      -> check EM A\n\t      -> canon M A\n\t      -> type.\n%mode elab_m_reg +X1 -X2 -X3.\n\nelab_r2r_reg : elab_r_to_r ER R A\n \t\t-> synth ER A\n \t\t-> atom R A\n \t\t-> type.\n%mode elab_r2r_reg +X1 -X2 -X3.\n\nelab_r2m_reg : elab_r_to_m ER M A\n\t\t-> synth ER A\n\t\t-> canon M A\n\t\t-> type.\n%mode elab_r2m_reg +X1 -X2 -X3.\n\n%% M to M\n\n- : elab_m_reg\n     (elab_m_asm_r2r Dex Del)\n     (check_asm DsynER)\n     DcanM\n     <- elab_r2r_reg Del DsynER DaR\n     <- expand_exists _ DaR Dex-2 DcanM-2\n     <- expand_unique Dex-2 Dex Did\n     <- canon_respects_id Did id/tp_refl DcanM-2 DcanM.\n\n- : elab_m_reg\n     (elab_m_asm_r2m Del)\n     (check_asm DsynER)\n     DcanM\n     <- elab_r2m_reg Del DsynER DcanM.\n\n- : elab_m_reg\n     (elab_m_lam Del)\n     (check_lam Dcheck)\n     (canon_lam Dcanon)\n     <- ({el_x : el_rtm} \n\t   {delx : synth el_x A}\n\t   {x : rtm}\n\t   {dx : atom x A}\n\t   {delabx : elab_r_to_r el_x x A}\n\t   {_ : elab_r2r_reg delabx delx dx}\n\t   elab_m_reg (Del el_x x delabx) (Dcheck el_x delx) (Dcanon x dx)).\n\n- : elab_m_reg\n     (elab_m_pair De2 De1)\n     (check_pair Dcheck2 Dcheck1)\n     (canon_pair Dcanon2 Dcanon1)\n     <- elab_m_reg De2 Dcheck2 Dcanon2 \n     <- elab_m_reg De1 Dcheck1 Dcanon1.\n\n%% R to R\n\n- : elab_r2r_reg\n     elab_r_to_r_c \n     synth_c\n     atom_c.\n\n- : elab_r2r_reg\n     (elab_r_to_r_app De2 De1)\n     (synth_app Dcheck2 Dsynth1)\n     (atom_app Dcanon2 Datom1)\n     <- elab_m_reg De2 Dcheck2 Dcanon2 \n     <- elab_r2r_reg De1 Dsynth1 Datom1.\n\n- : elab_r2r_reg\n     (elab_r_to_r_fst De1)\n     (synth_fst Dsynth1)\n     (atom_fst Datom1)\n     <- elab_r2r_reg De1 Dsynth1 Datom1.\n\n- : elab_r2r_reg\n     (elab_r_to_r_snd De1)\n     (synth_snd Dsynth1)\n     (atom_snd Datom1)\n     <- elab_r2r_reg De1 Dsynth1 Datom1.\n\n%% R to M\n\n- : elab_r2m_reg\n     (elab_r_to_m_annot De)\n     (synth_annot DcheckM)\n     DcanonM\n     <- elab_m_reg De DcheckM DcanonM.\n     \n- : elab_r2m_reg\n     (elab_r_to_m_app DsubstM2 DeM2 DeR1)\n     (synth_app DcheckM2 DsynthR1)\n     DcanonM'\n     <- elab_r2m_reg DeR1 DsynthR1 (canon_lam DcanonM)\n     <- elab_m_reg DeM2 DcheckM2 DcanonM2\n     <- hsubst_m_exists _ DcanonM DcanonM2 DsubstM2-2 DcanonM'-2\n     <- hsubst_m_unique DsubstM2-2 DsubstM2 Did\n     <- canon_respects_id Did id/tp_refl DcanonM'-2 DcanonM'.\n\n- : elab_r2m_reg\n     (elab_r_to_m_fst DeR)\n     (synth_fst DsynthR)\n     DcM1\n     <- elab_r2m_reg DeR DsynthR (canon_pair DcM2 DcM1).\n\n- : elab_r2m_reg\n     (elab_r_to_m_snd DeR)\n     (synth_snd DsynthR)\n     DcM2\n     <- elab_r2m_reg DeR DsynthR (canon_pair DcM2 DcM1).\n\n\n%% because world subsumption doesn't do exchange,\n%% you can't get this block to match both\n%% atom_block/synth_block and elab_block.\n%%\n%% this order matches atom_block/synth_block but not elab_block.\n%block elab_reg_block : some {A:tp}\n                         block \n                         {el_x : el_rtm} \n                         {delx : synth el_x A}\n                         {x : rtm}\n                         {dx : atom x A}\n                         {delabx : elab_r_to_r el_x x A}\n                         {_ : elab_r2r_reg delabx delx dx}.\n\n\n%worlds (elab_reg_block) \n(elab_m_reg _ _ _)\n(elab_r2r_reg _ _ _)\n(elab_r2m_reg _ _ _).\n\n%total (D1 D2 D3)\n(elab_m_reg D1 _ _)\n(elab_r2r_reg D2 _ _)\n(elab_r2m_reg D3 _ _).\n</twelf>\n\nThe proof is a straightforward induction, using <tt>hsubst_m_exists</tt> and <tt>expand_exists</tt>.  Because these two lemmas ''output'' a hereditary substitution or expansion, along with the typing derivation for the result of the operation, we use uniqueness here to show well-typedness of the outputs of the hereditary substitution and expansion derivations given by elaboration.  In retrospect, we should have factored this reasoning into separate lemmas that are like <tt>hsubst_m_exists</tt> and <tt>expand_exists</tt> but take the the hereditary substitution or expansion as an input.\n\n=== Existence of elaboration ===\n\nWe require one addtional [[respects lemma]].  \n\n<twelf>\nelab_r2m_respects_id :  id/mtm M M'\n\t\t\t-> id/tp A A'\n\t\t\t-> elab_r_to_m R M A\n\t\t\t-> elab_r_to_m R M' A'\n\t\t\t-> type.\n%mode elab_r2m_respects_id +X1 +X2 +X3 -X4.\n\n- : elab_r2m_respects_id _ _ D D.\n\n%worlds (elab_block | elab_reg_block) (elab_r2m_respects_id _ _ _ _).  %% bar in other block\n%total {} (elab_r2m_respects_id _ _ _ _).\n%reduces D1 = D2 (elab_r2m_respects_id _ _ D2 D1).\n</twelf>\n\nThe worlds of this lemma require a little explanation.  <tt>elab_reg_block</tt> should equal <tt>elab_block</tt> for this type family.  However, [[world subsumption]] does not notice this relationship because doing so would require permutation.  Consequently, we prove the theorem for both blocks directly.\n\nNext, we prove that all well-typed terms elaborate.  Analogously to hereditary substitution, the theorem for synthesizing terms computes a sum of the two ways it could elaborate:\n<twelf>\nelab_r_exists_sum : el_rtm -> tp -> type.\nelab_r_exists_sum_r2r : elab_r_exists_sum ER A\n                         <- elab_r_to_r ER R A.\nelab_r_exists_sum_r2m : elab_r_exists_sum ER A\n                         <- elab_r_to_m ER M A.\n</twelf>\n\nWe begin with some [[output factoring]] and [[canonical forms]] lemmas:\n\n<twelf>\nelab_m_exists_asm : elab_r_exists_sum ER A\n\t\t     -> elab_m (el_asm ER) M' A\n\t\t     -> type.\n%mode elab_m_exists_asm +X1 -X2.\n\n- : elab_m_exists_asm \n     (elab_r_exists_sum_r2m DeR)\n     (elab_m_asm_r2m DeR).\n\n- : elab_m_exists_asm \n     (elab_r_exists_sum_r2r DeR)\n     (elab_m_asm_r2r Dex DeR)\n     <- elab_r2r_reg DeR _ DaR\n     <- expand_exists _ DaR Dex _.\n\n%worlds (elab_reg_block) (elab_m_exists_asm _ _).\n%total {} (elab_m_exists_asm _ _).\n\n\ncanon_prod_is_pair : canon M (prod A1 A2)\n\t\t      -> id/mtm M (pair M1 M2)\n\t\t      -> type.\n%mode canon_prod_is_pair +X1 -X2.\n\n- : canon_prod_is_pair _ id/mtm_refl.\n\n%worlds (elab_reg_block) (canon_prod_is_pair _ _).\n%total {} (canon_prod_is_pair _ _).\n\nelab_r_exists_fst : elab_r_exists_sum R (prod A1 A2)\n\t\t     -> elab_r_exists_sum (el_fst R) A1\n\t\t     -> type.\n%mode elab_r_exists_fst +X1 -X2.\n\n- : elab_r_exists_fst\n     (elab_r_exists_sum_r2r DeR)\n     (elab_r_exists_sum_r2r (elab_r_to_r_fst DeR)).\n\n- : elab_r_exists_fst\n     (elab_r_exists_sum_r2m DeR)\n     (elab_r_exists_sum_r2m (elab_r_to_m_fst DeR-2))\n     <- elab_r2m_reg DeR _ DcM\n     <- canon_prod_is_pair DcM Did\n     <- elab_r2m_respects_id Did id/tp_refl DeR DeR-2.\n     \n%worlds (elab_reg_block) (elab_r_exists_fst _ _).\n%total {} (elab_r_exists_fst _ _).\n\nelab_r_exists_snd : elab_r_exists_sum R (prod A1 A2)\n\t\t     -> elab_r_exists_sum (el_snd R) A2\n\t\t     -> type.\n%mode elab_r_exists_snd +X1 -X2.\n\n- : elab_r_exists_snd\n     (elab_r_exists_sum_r2r DeR)\n     (elab_r_exists_sum_r2r (elab_r_to_r_snd DeR)).\n\n- : elab_r_exists_snd\n     (elab_r_exists_sum_r2m DeR)\n     (elab_r_exists_sum_r2m (elab_r_to_m_snd DeR-2))\n     <- elab_r2m_reg DeR _ DcM\n     <- canon_prod_is_pair DcM Did\n     <- elab_r2m_respects_id Did id/tp_refl DeR DeR-2.\n     \n%worlds (elab_reg_block) (elab_r_exists_snd _ _).\n%total {} (elab_r_exists_snd _ _).\n\n\ncanon_arrow_is_lam : canon M (arrow A2 A)\n\t\t      -> id/mtm M (lam M')\n\t\t      -> type.\n%mode canon_arrow_is_lam +X1 -X2.\n\n- : canon_arrow_is_lam _ id/mtm_refl.\n\n%worlds (elab_reg_block) (canon_arrow_is_lam _ _).\n%total {} (canon_arrow_is_lam _ _).\n\nelab_r_exists_app : elab_r_exists_sum ER1 (arrow A2 A)\n\t\t     -> elab_m EM2 M2 A2\n\t\t     -> elab_r_exists_sum (el_app ER1 EM2) A\n\t\t     -> type.\n%mode elab_r_exists_app +X1 +X2 -X3.\n\n- : elab_r_exists_app\n     (elab_r_exists_sum_r2r DeR1)\n     DeM2\n     (elab_r_exists_sum_r2r (elab_r_to_r_app DeM2 DeR1)).\n\n- : elab_r_exists_app\n     (elab_r_exists_sum_r2m DeR1)\n     DeM2\n     (elab_r_exists_sum_r2m (elab_r_to_m_app Ds DeM2 DeR1-2))\n     <- elab_r2m_reg DeR1 _ DcM1\n     <- elab_m_reg DeM2 _ DcM2\n     <- canon_arrow_is_lam DcM1 Did\n     <- canon_respects_id Did id/tp_refl DcM1 (canon_lam DcBody)\n     <- elab_r2m_respects_id Did id/tp_refl DeR1 DeR1-2\n     <- hsubst_m_exists _ DcBody DcM2 Ds _.\n\n%worlds (elab_reg_block) (elab_r_exists_app _ _ _).\n%total {} (elab_r_exists_app _ _ _).\n</twelf>\n\nFinally, we prove the main results:\n\n<twelf>\nelab_m_exists : check EM A\n\t\t -> elab_m EM M A\n\t\t -> type.\n%mode elab_m_exists +X1 -X2.\n\nelab_r_exists : synth ER A\n \t\t -> elab_r_exists_sum ER A\n \t\t -> type.\n%mode elab_r_exists +X1 -X2.\n\n%% M\n\n- : elab_m_exists\n     (check_asm Dsyn)\n     DeRes\n     <- elab_r_exists Dsyn Dsum\n     <- elab_m_exists_asm Dsum DeRes.\n\n- : elab_m_exists \n     (check_lam DcM)\n     (elab_m_lam DelabM)\n     <- ({el_x : el_rtm} \n\t   {delx : synth el_x A}\n\t   {x : rtm}\n\t   {dx : atom x A}\n\t   {delabx : elab_r_to_r el_x x A}\n\t   {_ : elab_r2r_reg delabx delx dx}\n\t   {_ : elab_r_exists delx (elab_r_exists_sum_r2r delabx)}\n\t   elab_m_exists (DcM el_x delx) (DelabM el_x x delabx)).\n\t\n- : elab_m_exists \n     (check_pair Dc2 Dc1)\n     (elab_m_pair De2 De1)\n     <- elab_m_exists Dc1 De1 \n     <- elab_m_exists Dc2 De2.\n\n%% R \n\n- : elab_r_exists\n     synth_c \n     (elab_r_exists_sum_r2r elab_r_to_r_c).\n\n- : elab_r_exists \n     (synth_app DchM DsynR)\n     DsumApp\n     <- elab_r_exists DsynR DsumR\n     <- elab_m_exists DchM DeM\n     <- elab_r_exists_app DsumR DeM DsumApp.\n\n\n- : elab_r_exists\n     (synth_fst Dsyn)\n     Dsum'\n     <- elab_r_exists Dsyn Dsum\n     <- elab_r_exists_fst Dsum Dsum'.\n\n- : elab_r_exists\n     (synth_snd Dsyn)\n     Dsum'\n     <- elab_r_exists Dsyn Dsum\n     <- elab_r_exists_snd Dsum Dsum'.\n\n- : elab_r_exists\n     (synth_annot DcM)\n     (elab_r_exists_sum_r2m (elab_r_to_m_annot DeM))\n     <- elab_m_exists DcM DeM.\n     \n% maintains all the invariants from elab_reg_block because the above lemmas use call regularity\n%block elab_exists_block : some {A:tp}\n                            block \n                            {el_x : el_rtm} \n                            {delx : synth el_x A}\n                            {x : rtm}\n                            {dx : atom x A}\n                            {delabx : elab_r_to_r el_x x A}\n                            {_ : elab_r2r_reg delabx delx dx}\n                            {_ : elab_r_exists delx (elab_r_exists_sum_r2r delabx)}.\n%worlds (elab_exists_block) \n(elab_m_exists _ _)\n(elab_r_exists _ _).\n\n%total (D1 D2) \n(elab_m_exists D1 _)\n(elab_r_exists D2 _).\n</twelf>\n\n<twelflink>All Twelf code for this tutorial.</twelflink>\n<twelflink check=\"true\">See Twelf's output.</twelflink>\n\n{{case study}}"
          },
          "sha1": "afv6wc67fqrqcziyfv543tzq6f66y6j"
        }
      },
      {
        "title": "Hereditary substitution with a zipper",
        "ns": 0,
        "id": 2225,
        "revision": {
          "id": 6146,
          "timestamp": "2010-09-20T15:59:41Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "well, this didn't work, but hopefully the next thing will.",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 6650,
            "#text": "%{  This article represents a (partially unsuccessful) attempt to remove the \"ugly\" portion from the global soundness proof in the [[verifications and uses]] article.\nThe language of propositions and rules (and, as a result, the argument for global completeness) is unchanged from the [[verifications and uses]], and so we omit\nit here. \n\nThis article is an intermediate point between the [[verifications and uses]] article and the [[verifications and uses with zippers]] article. | hidden = true }%\n\nprop : type.\natom : type.\n%block bl_atom : block {qp : atom}.\n\na : atom -> prop.\n⊃ : prop -> prop -> prop. %infix right 9 ⊃.\n∧ : prop -> prop -> prop. %infix right 8 ∧.\n\nhyp   : prop -> type.\nverif : prop -> type.\nuse   : prop -> type.\n%block bl_hyp : some {A : prop} block {x : hyp A}.\n\nvar : hyp A -> use A.\natm : use (a Q) -> verif (a Q).\n⊃I  : (hyp A -> verif B) -> verif (A ⊃ B).\n⊃E  : use (A ⊃ B) -> verif A -> use B.\n∧I  : verif A -> verif B -> verif (A ∧ B).\n∧E₁ : use (A ∧ B) -> use A.\n∧E₂ : use (A ∧ B) -> use B.\n\n%{ Rather than the (somewhat ugly) process used to find the main variable \nin the [[verifications and uses]] example, in this example we will create\na sort-of zipper data structure that allows us to \"pull out\" the\nhead variable from the inside of a term. }%\n\n%{ == Defining pseudo-zippers == }%\n\n%{ A [[w:zipper|zipper data structure]] is a way of describing paths into\ncomplex structures. A \"real\" zipper over an atomic term has the structure of a \n''spine'' in a [[spine form]] presentation of logic; what we present\nhere isn't \"really\" a spine (or a zipper).  }%\n\nzip : prop -> prop -> type.\nend : zip A A.\n⊃Z  : zip A (B₁ ⊃ B₂) -> verif B₁ -> zip A B₂.\n∧Z₁ : zip A (B₁ ∧ B₂) -> zip A B₁.\n∧Z₂ : zip A (B₁ ∧ B₂) -> zip A B₂.\n\nuse' : prop -> type.\n· : hyp A -> zip A B -> use' B. %infix none 10 ·.\n\n%{ For instance, the <tt>use'</tt>\ncorresponding to <tt>(⊃E (⊃E (⊃E (var x) N<sub>1</sub>) N<sub>2</sub>)\nN<sub>3</sub>)</tt> is \n<tt>x · (⊃Z (⊃Z (⊃Z end N<sub>1</sub>) N<sub>2</sub>) N<sub>3</sub>)</tt> --- \nthe head variable <tt>x</tt> has been brought out to the top of the term, but\nthe subterm <tt>N<sub>1</sub></tt> is still nested more deeply\nthan the subterms <tt>N<sub>2</sub></tt> and\n<tt>N<sub>3</sub></tt>. In a conversion to spine form,\nwe would not only expose the head variable <tt>x</tt> but would make \n<tt>N<sub>1</sub></tt> the \"least deeply nested\" subterm and make\n<tt>N<sub>3</sub></tt> the \"most deeply nested\" subterm. }%\n\n%{ == Zipping and unzipping == }%\n\n%{ We need to both show that we can zip and unzip a <tt>use</tt> into\na <tt>use'</tt>, and vice versa. These two proofs are essentially the\nsame logic program run in opposite directions, but Twelf only allows\nus to assign a single mode to a metatheorem, so rather than just\ncopying and pasted we have \"cleaned up\" both the <tt>unzip</tt>\nand <tt>rezip</tt> functions a bit. }%\n\nunzip : use B -> use' B -> type.\n- : unzip (⊃E R N) (X · ⊃Z Z N) <- unzip R (X · Z).\n- : unzip (∧E₁ R)  (X · ∧Z₁ Z)  <- unzip R (X · Z).\n- : unzip (∧E₂ R)  (X · ∧Z₂ Z)  <- unzip R (X · Z).\n- : unzip (var X)  (X · end).\n\n%mode unzip +R -R'.\n%worlds (bl_atom | bl_hyp) (unzip _ _).\n%total R (unzip R _).\n\nrezip : hyp A -> zip A B -> use B -> type.\n- : rezip X (⊃Z Z N) (⊃E R N) <- rezip X Z R.\n- : rezip X (∧Z₁ Z)  (∧E₁ R)  <- rezip X Z R.\n- : rezip X (∧Z₂ Z)  (∧E₂ R)  <- rezip X Z R.\n- : rezip X end (var X).\n\n%mode rezip +X +Z -R.\n%worlds (bl_atom | bl_hyp) (rezip _ _ _).\n%total Z (rezip _ Z _).\n\n%{ == Global soundness == }%\n\nhsubst_n  : {A}    verif A -> (hyp A -> verif B)    -> verif B -> type.\nhsubst_r  : {A}    verif A -> (hyp A -> use' (a Q)) -> verif (a Q) -> type.\nhsubst_rr : {A}    verif A -> (hyp A -> zip C B)    -> zip C B' -> type.\nhsubst_rn : {A}{B} verif A -> (hyp A -> zip A B)    -> verif B -> type.\n%mode hsubst_n  +A    +M₀ +M -N.\n%mode hsubst_r  +A    +M₀ +R -N.\n%mode hsubst_rr +A    +M₀ +R -R'.\n%mode hsubst_rn +A +B +M₀ +R -N.\n\n- : hsubst_n A M₀ ([x] ⊃I [y] M x y) (⊃I [y] N y)\n     <- {y : hyp B₁} hsubst_n A M₀ ([x] M x y) (N y : verif B₂).\n- : hsubst_n A M₀ ([x] ∧I (M₁ x) (M₂ x)) (∧I N₁ N₂)\n     <- hsubst_n A M₀ ([x] M₁ x) (N₁ : verif B₁)\n     <- hsubst_n A M₀ ([x] M₂ x) (N₂ : verif B₂).\n- : hsubst_n A M₀ ([x] atm (R x)) N\n     <- ({x : hyp A} unzip (R x) (R' x))\n     <- hsubst_r A M₀ ([x] (R' x)) N.\n\n- : hsubst_r A M₀ ([x] x · Z x) N\n     <- hsubst_rn A _ M₀ ([x] Z x) N.\n- : hsubst_r A M₀ ([x] Y · Z x) (atm R)\n     <- hsubst_rr A M₀ ([x] Z x) Z'\n     <- rezip Y Z' R.\n\n- : hsubst_rr A M₀ ([x] ⊃Z (Z x) (M x)) (⊃Z Z' N)\n     <- hsubst_rr A M₀ ([x] Z x) Z' \n     <- hsubst_n A M₀ ([x] M x) N.\n- : hsubst_rr A M₀ ([x] ∧Z₁ (Z x)) (∧Z₁ Z')\n     <- hsubst_rr A M₀ ([x] Z x) Z'.\n- : hsubst_rr A M₀ ([x] ∧Z₂ (Z x)) (∧Z₂ Z')\n     <- hsubst_rr A M₀ ([x] Z x) Z'.\n- : hsubst_rr A M₀ ([x] end) end.\n\n- : hsubst_rn A _ M₀ ([x] ⊃Z (Z x) (M x)) N'\n     <- hsubst_rn A _ M₀ ([x] Z x) ((⊃I [y] N y) : verif (B₁ ⊃ B₂))\n     <- hsubst_n A M₀ ([x] M x) (M' : verif B₁)\n     <- hsubst_n B₁ M' ([y] N y) (N' : verif B₂).\n- : hsubst_rn A _ M₀ ([x] ∧Z₁ (Z x)) N₁\n     <- hsubst_rn A _ M₀ ([x] Z x) (∧I N₁ N₂ : verif (B₁ ∧ B₂)).\n- : hsubst_rn A _ M₀ ([x] ∧Z₂ (Z x)) N₂\n     <- hsubst_rn A _ M₀ ([x] Z x) (∧I N₁ N₂ : verif (B₁ ∧ B₂)).\n- : hsubst_rn A _ M₀ ([x] end) M₀.\n\n%worlds (bl_atom | bl_hyp)\n(hsubst_n _ _ _ _)\n(hsubst_rr _ _ _ _) \n(hsubst_rn _ _ _ _ _)\n(hsubst_r _ _ _ _) .\n\n%reduces B <= A (hsubst_rn A B _ _ _).\n\n%{ == Failure of termination checking == }%\n\n%{ The fact that our representation uses both proofs <tt>use A</tt> and\nproofs <tt>use' A</tt> means that we will run afowl of Twelf's termination\nchecker --- an unzipped term has a different size than the corresponding \nzipped term. We could certainly convince Twelf that zipping and unzipping\npreserved size by using the same tree-like [[structural metric]] used in the\n[[concrete representation]] case study, but that would be notationally\nheavy and unenlightening.\n\nAnother option is to ask Twelf to trust us: }%\n\n%trustme %reduces R' = R (unzip R R').\n%.\n\nHowever, for some reason\n(possibly because the types of the two terms is different) this does not \nwork. and we still get an error message from the final <tt>%total</tt> \ndeclaration.\n\n<twelf check=decl>\n%total {(A B C D) (M R S T)}\n(hsubst_n A _ M _)\n(hsubst_rr C _ S _) \n(hsubst_rn D _ _ T _)\n(hsubst_r B _ R _).\n</twelf>"
          },
          "sha1": "np9dca0siehwz5q52nyuz8w795mmony"
        }
      },
      {
        "title": "Hereditary substitution with zippers",
        "ns": 0,
        "id": 2227,
        "redirect": {
          "@title": "Hereditary substitution with a zipper",
          "#text": null
        },
        "revision": {
          "id": 6149,
          "timestamp": "2010-09-20T17:05:29Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "Redirected page to [[Hereditary substitution with a zipper]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 51,
            "#text": "#REDIRECT [[hereditary substitution with a zipper]]"
          },
          "sha1": "mic9m1b1ifjbczl5td3yo60o9834oip"
        }
      },
      {
        "title": "Heterogeneous lists",
        "ns": 0,
        "id": 1742,
        "redirect": {
          "@title": "Lists",
          "#text": null
        },
        "revision": {
          "id": 2988,
          "timestamp": "2006-10-20T16:34:05Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "[[Heterogeneous lists]] moved to [[Lists]]: Better teminology.",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 19,
            "#text": "#REDIRECT [[Lists]]"
          },
          "sha1": "atg3key2mwxbqml3f5g908f3gp8tadr"
        }
      },
      {
        "title": "Higher-order abstract syntax",
        "ns": 0,
        "id": 1486,
        "revision": {
          "id": 5057,
          "parentid": 5055,
          "timestamp": "2008-02-15T03:06:50Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "minor": null,
          "comment": "Reverted edits by [[Special:Contributions/Popik|Popik]] ([[User_talk:Popik|Talk]]); changed back to last version by [[User:Drl|Drl]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 3795,
            "#text": "'''Higher-order abstract syntax''' is a technique for the representation of [[abstract syntax]] trees for languages with [[bound variable]]s. It is often abbreviated as '''HOAS'''. In the context of mechanizing metatheory, HOAS refers to a specific technique where binding constructs in the [[object language]] are represented by the binding construct of the [[meta-language]]. When the meta language is Twelf, this is the λ construct.\n\nAn abstract syntax tree is ''abstract'' because it is a mathematical object that has certain structure by its very nature. For instance, in first-order abstract syntax (FOAS) trees, as commonly used in compilers, the tree structure implies the subexpression relation, meaning that no parentheses are required to disambiguate programs (as they are in the [[concrete syntax]]). HOAS exposes additional structure: the relationship between variables and their binding sites. In FOAS representations, a variable is typically represented with an identifier and the relation between binding site and use is indicated by the use of the ''same'' identifier. FOAS representations thus need to formalize the rules of identifier lookup, and often need to formalize other conventions of language metatheory, such as [[alpha-equivalence]], [[weakening]], [[exchange]], and type-preserving [[substitution]]. When it can be used, HOAS is powerful because the metalanguage can provide these properties for free, reducing the amount of boilerplate code in an encoding.\n\n== Example ==\nFor example, LF has a λ construct, which has arrow (→) type. A first-order encoding of an object language construct <tt>let</tt> might be (using Twelf syntax):\n<twelf>exp : type.\nvar : type.\nv   : var -> exp.\nlet : exp -> var -> exp -> exp.</twelf>\n\nHere, <tt>exp</tt> is the family of object language expressions. The family <tt>var</tt> is the representation of variables (implemented perhaps as natural numbers, which is not shown); the constant <tt>v</tt> witnesses the fact that variables are expressions. The constant <tt>let</tt> is an expression that takes three arguments: an expression (that is being bound), a variable (that it is bound to) and another expression (that the variable is bound within).\n\nThe natural HOAS representation of the same object language would be:\n<twelf>exp : type.\nlet : exp -> (exp -> exp) -> exp.</twelf>\nIn this representation, object level variables do not appear explicitly. The constant <tt>let</tt> takes an expression (that is being bound) and a meta-level function <tt>exp</tt> → <tt>exp</tt> (the body of the let). This function is the ''higher-order'' part: an expression with a free variable is represented as an expression with ''holes'' that are filled in by the meta-level function when applied. As a concrete example, we would construct the object level expression\n\n let x = 1 + 2\n in x + 3\n\n(assuming the natural constructors for numbers and addition) using the HOAS signature above as\n<twelf>let (plus 1 2) ([y] plus y 3)</twelf>\nwhere <tt>[y] e</tt> is Twelf's syntax for the function ''λy.e''.\n\nBecause this technique reuses the mechanism of the meta-language to encode a concept in the object language, it is generally only applicable when the meta-language and object-language notions of binding coincide. This is often the case, but not always: for instance, it is unlikely that a HOAS encoding of dynamic scope such as in Lisp would be possible in a statically-scoped language like LF.\n\n== See also ==\n* [[Higher-order judgment]]s: a related LF representation technique, in which object-language [[hypothetical judgment]]s are represented using LF binding.\n* [[Equality]]: when an object language is represented using HOAS, equality of LF terms corresponds with [[alpha-equivalence|α-equivalence]] of object language terms."
          },
          "sha1": "e4oqfz843v84v6tn8e6b815caq9yvto"
        }
      },
      {
        "title": "Higher-order judgement",
        "ns": 0,
        "id": 1953,
        "redirect": {
          "@title": "Higher-order judgements",
          "#text": null
        },
        "revision": {
          "id": 4460,
          "timestamp": "2007-03-20T20:47:53Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "Redirecting to [[Higher-order judgements]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 37,
            "#text": "#REDIRECT [[Higher-order judgements]]"
          },
          "sha1": "feuh95itzjnjwzce62j0wo774p1rg4q"
        }
      },
      {
        "title": "Higher-order judgements",
        "ns": 0,
        "id": 1950,
        "revision": {
          "id": 5090,
          "parentid": 5077,
          "timestamp": "2008-03-04T04:42:51Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "comment": "/* See also */",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 5196,
            "#text": "When representing [[judgment]]s in [[LF]], it is often possible to represent [[hypothetical judgment]]s using LF binding.  We call this representation technique'''higher-order judgments'' because judgments are represented using higher-order types in LF.  Higher-order representations are advantageous because hypothetical judgment properties such as [[weakening]], [[exchange]], and [[substitution]] are inherited \"for free\" from the corresponding properties of LF.\n\n== Example ==\n\n=== Hypothetical judgment in standard notation ===\n\nAs an example, we use the typing judgment for the [[simply-typed lambda calculus]].  This calculus has the following syntax:\n\n<math>\\texttt{}\\tau ::= \\texttt{unit} \\,|\\, \\tau_1 \\rightarrow \\tau_2</math>\n\n<math>\\texttt{}e ::= x \\,|\\, \\langle\\rangle \\,|\\, \\lambda x :\\tau . e \\,|\\, e_1 e_2</math>\n\nThe terms are the variable <math>x</math>, the empty pair (which has type <tt>unit</tt>), lambda abstraction (with a type annotation), and application.\n\nThe typing rules for the simply typed lambda calculus use a typing context <math>\\texttt{}\\gamma</math> containing assumptions of the form <math>\\mathsf{}x : \\tau</math>. Such a context is well-formed when all variables in it are distinct.\n\n<math>{ \\; \\over \\gamma, x : \\tau, \\gamma' \\vdash x : \\tau}\\,\\mbox{of-var}</math>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \n<math>{ \\gamma , x : \\tau_2 \\vdash e : \\tau \\over \\gamma \\vdash \\lambda x:\\tau_2.e : (\\tau_2 \\rightarrow \\tau)}\\,\\mbox{of-lam}</math>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \n\n<math>{ \\; \\over \\gamma \\vdash \\langle\\rangle : \\texttt{unit}}\\,\\mbox{of-empty}</math>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \n<math>{ \\gamma \\vdash e_1 : (\\tau_2 \\rightarrow \\tau) \\qquad \\gamma \\vdash e_2 : \\tau_2 \\over \\gamma \\vdash e_1 e_2 : \\tau}\\,\\mbox{of-app}</math>\n\nThis is a ''hypothetical judgement'', which means that the following structural properties are true:\n* Hypothesis: <math>\\gamma,x : \\tau \\vdash x : \\tau</math>.\n* Weakening: if <math>\\gamma \\vdash e : \\tau</math> and <math>\\mathsf{}x</math> is fresh then <math>\\gamma,x:\\tau' \\vdash e : \\tau</math>.\n* Exchange: if <math>\\gamma,x:\\tau_1,y:\\tau_2 \\vdash e : \\tau</math> then <math>\\gamma,y:\\tau_2,x:\\tau_1 \\vdash e : \\tau</math>.\n* Substitution: if <math>\\gamma,x : \\tau' \\vdash e : \\tau</math> and <math>\\gamma \\vdash e' : \\tau'</math> then <math>\\gamma \\vdash \\{e'/x\\}e : \\tau</math>.\n\nHypothesis is derivable by the rule <math>\\mbox{of-var}</math>.  Weakening, exchange, and substitution are admissible.\n\n=== LF representation ===\n\nWe represent the syntax of this calculus with the following LF signature:\n\n<twelf>\ntp : type.\narrow : tp -> tp -> tp.\nunit : tp.\n\ntm : type.\nempty : tm.\napp : tm -> tm -> tm.\nlam : tp -> (tm -> tm) -> tm.\n</twelf>\nTerms are represented using [[higher-order abstract syntax]].\n\nAs an example of higher-order representations of judgments, we use LF binding to represent the object-language typing judgement.  The following LF signature represents the above judgement <math>\\gamma \\vdash e : \\tau</math> with the LF type family <tt>of</tt>.  \n\n<twelf>\nof       : tm -> tp -> type.\nof-empty : of empty unit.\nof-lam   : of (lam T2 ([x] E x)) (arrow T2 T)\n            <- ({x: tm} of x T2 -> of (E x) T).\nof-app   : of (app E1 E2) T\n            <- of E1 (arrow T2 T)\n            <- of E2 T2.\n</twelf>\n\nThe first thing to note is that the type family is indexed by a <tt>tm</tt> and a <tt>tp</tt> but '''not''' a representation of the context <math>\\gamma</math>.  The reason for this is that we identify the object-language context with the LF context.  Specifically, an object-language assumption <math>x:\\tau</math> does two things:\n* It binds the variable <math>\\mathsf{}x</math>.\n* It declares a typing assumption <math>x : \\tau</math>.\n\nThus, an object-language assumption <math>x:\\tau</math> is represented by the following two LF assumptions:\n\n<tt>x : tm,  dx : of x T </tt> (where <tt>T</tt> is the encoding of <math>\\tau</math>).  \n\nThe first LF variable represents an object-language term <tt>x</tt>, as per the encoding of syntax in the previous section.  The second variable represents a derivation that <tt>of x T</tt>.  Consequently, there is no LF constant corresponding to the rule <math>\\mbox{of-var}</math>; uses of this rule are represented by uses of the corresponding LF variable <tt>dx</tt>.\n\nThis representation of hypotheses gives rise to the higher-order premise of the constant <tt>of-lam</tt>, which has type \n\n<tt>{x: tm} of x T2 -> of (E x) T</tt>\n\nAn LF term of this type has the form <tt>([x] [dx: of x T2] M)</tt>, where <tt>M : of (E x) T</tt> ''in an LF context extended with <tt>x : tm,  dx : of x T2</tt>''.  Thus, <tt>M</tt> is the representation of an object-language derivation under the additional assumption <math>\\mathsf{}x:\\tau</math>.\n\nThe constants <tt>of-empty</tt> and <tt>of-app</tt> correspond to the informal inference rules of the same name.\n\n== See also ==\n* the [[introductions to Twelf]] for more discussion of higher-order representations of hypothetical judgments.\n* [[Reformulating languages to use hypothetical judgements]]\n* [[higher-order abstract syntax]]\n\n{{stub}}"
          },
          "sha1": "3ixm5pkqiuo9pnkpkqdo3qroy48fujz"
        }
      },
      {
        "title": "Higher-order judgment",
        "ns": 0,
        "id": 1951,
        "redirect": {
          "@title": "Higher-order judgements",
          "#text": null
        },
        "revision": {
          "id": 4458,
          "timestamp": "2007-03-20T20:47:08Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "Redirecting to [[Higher-order judgements]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 37,
            "#text": "#REDIRECT [[Higher-order judgements]]"
          },
          "sha1": "feuh95itzjnjwzce62j0wo774p1rg4q"
        }
      },
      {
        "title": "Higher-order judgments",
        "ns": 0,
        "id": 1952,
        "redirect": {
          "@title": "Higher-order judgements",
          "#text": null
        },
        "revision": {
          "id": 4459,
          "timestamp": "2007-03-20T20:47:29Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "Redirecting to [[Higher-order judgements]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 37,
            "#text": "#REDIRECT [[Higher-order judgements]]"
          },
          "sha1": "feuh95itzjnjwzce62j0wo774p1rg4q"
        }
      },
      {
        "title": "Holes in metatheorems",
        "ns": 0,
        "id": 2027,
        "redirect": {
          "@title": "Incremental metatheorem development",
          "#text": null
        },
        "revision": {
          "id": 5005,
          "timestamp": "2007-10-24T15:45:00Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "[[Holes in metatheorems]] moved to [[Incremental metatheorem development]]: This page is the second hit for \"metatheorems\" in google; one might get the wrong idea.",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 49,
            "#text": "#REDIRECT [[Incremental metatheorem development]]"
          },
          "sha1": "tdnt4ihs56mk0gihr0lso812zmb2wot"
        }
      },
      {
        "title": "Homogeneous lists",
        "ns": 0,
        "id": 1744,
        "redirect": {
          "@title": "Indexed lists",
          "#text": null
        },
        "revision": {
          "id": 2992,
          "timestamp": "2006-10-20T16:38:31Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "[[Homogeneous lists]] moved to [[Indexed lists]]: Precursor",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 27,
            "#text": "#REDIRECT [[Indexed lists]]"
          },
          "sha1": "b57ln2nvkj4880isefa66idligl6nwg"
        }
      },
      {
        "title": "Hypothetical judgement",
        "ns": 0,
        "id": 1945,
        "redirect": {
          "@title": "Hypothetical judgment",
          "#text": null
        },
        "revision": {
          "id": 4424,
          "timestamp": "2007-03-20T16:08:46Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "comment": "Redirecting to [[Hypothetical judgment]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 35,
            "#text": "#REDIRECT [[hypothetical judgment]]"
          },
          "sha1": "rahl5hovra4ft4zg33xcv5g7o7up7qe"
        }
      },
      {
        "title": "Hypothetical judgment",
        "ns": 0,
        "id": 1925,
        "revision": {
          "id": 4363,
          "parentid": 4358,
          "timestamp": "2007-03-19T23:08:55Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "minor": null,
          "comment": "tweak, Twelf typecheck",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 2746,
            "#text": "A [[judgment]] is a statement derivable in a particular object logic. A '''hypothetical judgment''' is a judgment that makes use of hypothetical assumptions. On paper, we often represent a set of hypothetical assumptions using a context:\n\n<math>{ \\Gamma, A \\mbox{ true} \\vdash B \\mbox{ true} \\over \\Gamma \\vdash A \\Rightarrow B \\mbox{ true} }</math>\n\nWe name the judgment that proves the truth of a proposition <math>\\Gamma \\vdash C \\mbox{ true}</math>, which can be read as \"Under the assumptions <math>\\texttt{}\\Gamma</math>, <math>\\texttt{}A</math> is true.\" The context is the sequence of assumptions <math>\\Gamma = A_1 \\mbox{ true}, \\ldots, A_n \\mbox{ true}</math>. \n\nWith an ordinary hypothetical context, we may freely coalesce repeated assumptions, add extra unused assumptions, and to reorder the assumptions in the context. (Formally, these are the properties of contraction, weakening, and exchange.) \n\nAdditionally, a context in a hypothetical judgment should satisfy the identity and substitution properties. Identity simply means that we should be able to use our hypotheses -- <math>\\Gamma, A \\mbox{ true} \\vdash A \\mbox{ true}</math>. Substitution  means that if we have a proof tree showing <math>\\Gamma, A \\mbox{ true} \\vdash B \\mbox{ true}</math>, and another proof tree <math>\\Gamma \\vdash A \\mbox{ true}</math>, then we should be able to substitute the second tree into the first, replacing hypothesis <math>\\texttt{}A \\mbox{ true}</math> and producing a new tree proving <math>\\Gamma \\vdash B \\mbox{ true}</math>.\n\nThis sample rule is the implication introduction rule, which says that <math>A \\Rightarrow B</math> is true if we can show <math>\\texttt{}B</math> is true under the hypothetical assumption <math>\\texttt{}A \\mbox{ true}</math>. \n\nIn the LF methodology, we represent the hypothetical context of our object language's judgment using the LF context itself. (See [[higher-order judgment]].)\n\nFor example, we can represent the introduction rule as follows:\n\n<twelf>\nprop : type.\n==> : prop -> prop -> prop.  %infix none 10 ==>.\n\ntrue : prop -> type.   \n\nimp/intro : true (A ==> B) <-\n              (true A -> true B).\n</twelf>\n\nHere, we represent the hypothetical assumption that <math>\\texttt{}A \\mbox{ true}</math> using an LF hypothesis of type <tt>A true</tt>. We can see this clearly if we write down the proof term for the proof of the tautology <tt>P ==> P</tt>:\n\n<twelf>\ntaut : true (P ==> P)= imp/intro ([ptrue : true P] ptrue).\n</twelf>\n\nWithin the scope of the function argument to <tt>imp/intro</tt>, we assume that we have a proof of <tt>P true</tt> (which we creatively named <tt>ptrue</tt>). This assumption lets us show that <tt>P true</tt> holds, and that lets us show that <tt>(P ==> P) true</tt>."
          },
          "sha1": "mzppwa0xedfh682ho5xmplqxuvznsve"
        }
      },
      {
        "title": "Identity",
        "ns": 0,
        "id": 1678,
        "redirect": {
          "@title": "Equality",
          "#text": null
        },
        "revision": {
          "id": 2523,
          "timestamp": "2006-10-10T02:54:00Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "this seems appropriate given the current article on equality",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 22,
            "#text": "#REDIRECT [[Equality]]"
          },
          "sha1": "1evo9trxxsh7ggeo11ch1cqy7ro4l3c"
        }
      },
      {
        "title": "Implicit and explicit parameters",
        "ns": 0,
        "id": 1693,
        "revision": {
          "id": 6110,
          "parentid": 6109,
          "timestamp": "2010-09-02T01:29:06Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 2608,
            "#text": "When declaring a type family or constant, the Twelf programmer often needs to use '''universally quantified''' parameters, and has the choice of making the parameter '''implicit''' or '''explicit'''. The article on [[converting between implicit and explicit parameters]] discusses how these two ways of doing things can be derived from each other.\n\nUsing fully '''explicit parameters''' means that all variables are ''bound'' by being placed within curly braces <tt>{}</tt>. The type family or constant generally has more arguments when using this form.\n\nUsing '''implicit parameters''' means that variables are not put within curly braces. Twelf assumes an identifier is meant to be a universally quantified parameter if the identifier starts with an uppercase letter ''and'' if that identifier has not been bound or defined anywhere else. This is essentially an interface aspect allowing for simpler code&mdash;internally, Twelf applies [[type reconstruction]] to identify the type of the universally quantified variables and converts the implicit parameters into explicit parameters. \n\nThe implicit parameters style is more concise and is often cleaner; however, in some cases it is necessary to use explicit parameters (for instance, a <tt>[[%terminates]]</tt> or <tt>[[%total]]</tt> declaration can refer to explicit parameters, not implicit parameters), and it may make stylistic sense in other situations as well.\n\nExamples of the two different styles follow, using the language from the article on [[converting between implicit and explicit parameters]] which is omitted for brevity. The Twelf output is included - note that the Twelf output ''always'' writes out explicit parameters,{{discuss|Always prints out the parameters}} even if the definition is using implicit parameters; therefore the two examples have almost exactly the same output from Twelf.\n\n=== Implicit parameters ===\n\n<twelf hidden=true>\n\nexp : type.\ntyp : type.\nof  : exp -> typ -> type.\n\n0 : exp.\n1 : exp.\nbit : typ.\nvoid : typ.\nof1 : of 1 bit.\nof0 : of 0 bit.\n\n</twelf><twelf discard=true check=decl>\n\ntranslate-i : of M A -> of M' A -> type.\n%mode translate-i +D -D'.\n\n</twelf>\n\n=== Explicit parameters ===\n\nNote that in this example we use slightly bad [[style guide|style]], capitalizing our bound variables <tt>M</tt>, <tt>A</tt>, and <tt>M'</tt>.\n\n<twelf discard=true check=decl>\n\n\ntranslate-e : {M : exp}{A : typ} {M' : exp} of M A -> of M' A -> type.\n%mode translate-e +M +A -M' +D -D'.\n\n</twelf>\n\n== See also ==\n\n* {{proving|title=Full LF}} discusses implicit and explicit parameters in the section \"Twelf conveniences.\""
          },
          "sha1": "n0lrdvo7pokqzac6kccaoqghr10qz9v"
        }
      },
      {
        "title": "Implicit parameter",
        "ns": 0,
        "id": 1690,
        "redirect": {
          "@title": "Implicit and explicit parameters",
          "#text": null
        },
        "revision": {
          "id": 2662,
          "parentid": 2659,
          "timestamp": "2006-10-12T04:32:35Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "Redirecting to [[Implicit and explicit parameters]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 46,
            "#text": "#REDIRECT [[Implicit and explicit parameters]]"
          },
          "sha1": "29fzo91l1eqb19n37srxe3ofqodcffg"
        }
      },
      {
        "title": "Implicit parameters",
        "ns": 0,
        "id": 1922,
        "redirect": {
          "@title": "Implicit and explicit parameters",
          "#text": null
        },
        "revision": {
          "id": 4314,
          "timestamp": "2007-03-19T21:23:41Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "Redirecting to [[Implicit and explicit parameters]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 46,
            "#text": "#REDIRECT [[Implicit and explicit parameters]]"
          },
          "sha1": "29fzo91l1eqb19n37srxe3ofqodcffg"
        }
      },
      {
        "title": "Incremental metatheorem development",
        "ns": 0,
        "id": 1457,
        "revision": {
          "id": 6029,
          "parentid": 5004,
          "timestamp": "2009-11-21T16:23:42Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 3314,
            "#text": "Typically, metatheorems must be verified as total before they can be used to prove other metatheorems. However, one often wishes to develop a proof without first proving some intermediate lemmas. For example, suppose a programmer believes that if metatheorem A is true, he will be able to prove B. However, A may be difficult to prove, and the effort to prove it may be wasted if it does not lead to a proof of B. Instead, the programmer wants to prove B first (assuming A) and then, if successful, proceed to prove A. Therefore, he would like to create a proof of B with a \"hole\" for A, but still be able to check B.\n\nThe newest versions of Twelf provide a direct way to create such holes. Users of earlier versions may take advantage of a curious feature.\n\n== Twelf CVS: %trustme ==\n\nThe <tt>[[%trustme]]</tt> declaration instructs Twelf to run the immediately following declaration but suppress any errors that occur. It is commonly used on <tt>[[%total]]</tt> declarations to introduce lemmas that have not yet been proved, in order to develop a proof without first proving some necessary lemmas. \n\nIf Twelf is in [[unsafe mode]], it will accept <tt>%trustme</tt> before the <tt>%total</tt> directive of a metatheorem with an incomplete proof. Twelf will consider such metatheorems total for the purpose of the totality checks of subsequent metatheorems. The following is an example of <tt>%trustme</tt> in action.\n\n<twelf>nat : type.\n\nnat/z : nat.\nnat/s : nat -> nat.\n\nnat-less : nat -> nat -> type.\n\nnat-less/z : nat-less nat/z (nat/s N).\nnat-less/s : nat-less (nat/s N1) (nat/s N2)\n              <- nat-less N1 N2.\n\nnat-less-immsucc : {N:nat} nat-less N (nat/s N) -> type.\n%mode nat-less-immsucc +D1 -D2.\n\n- : nat-less-immsucc nat/z nat-less/z.\n\n%worlds () (nat-less-immsucc _ _).\n%trustme %total (D1) (nat-less-immsucc D1 _).</twelf>\n\nWhen <tt>%trustme</tt> directives are no longer needed, unsafe mode can be disabled by inputting the following line into the Twelf server.\n\n<code>set unsafe false</code>\n\nAs of 22 September, 2006, <tt>%trustme</tt> is only available in the [[Software#Twelf Subversion|Subversion version of Twelf]].\n\nThe %trustme declaration makes Twelf's deductions unsound, of course, so should only be thought of as a development and debugging tool.\n\n== Twelf 1.5R1 and earlier ==\n\nIn older versions of Twelf, the following technique can be used. In the following code, \"foo\" is obviously not a total relation&mdash;it has no cases at all defined. However, after Twelf tries to check the line <tt>%total I (foo I _).</tt> and fails, it will actually allow <tt>foo</tt> to be used to check <tt>bar</tt>'s totality.\n\n<twelf>thing : type.\n\na : thing. \nb : thing.\n\nfoo : thing -> thing -> type.\n%mode foo +I -O. \n%worlds () (foo _ _). \n%total I (foo I _).  \n\nbar : thing -> thing -> type.\n\n- : bar I O\n      <- foo I O.\n\n%mode bar +I -O. \n%worlds () (bar _ _). \n%total I (bar I _). </twelf>\n\nTo reiterate, in order to use this \"feature\" you get Twelf to reject the <tt>%total</tt> declaration for foo. Then, it will believe that foo is total in checking ''subsequent'' theorems. It won't believe that foo is total if you try to rerun <tt>%total</tt> for foo itself&mdash;if you re-check the <tt>%total</tt>, it reruns the totality check, and finds that foo still isn't total.\n\n{{tutorial}}"
          },
          "sha1": "3sh2sgttlklj264l9q121vqjbrxv9j0"
        }
      },
      {
        "title": "Indexed HOAS nat bijection",
        "ns": 0,
        "id": 2048,
        "revision": {
          "id": 5167,
          "timestamp": "2008-05-20T18:21:34Z",
          "contributor": {
            "username": "Boyland",
            "id": 17
          },
          "comment": "Added new page on indexed HOAS",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 581923,
            "#text": "%{ = Bijection from indexed HOAS to natural numbers = }%\n\n%{\nThis file shows an *indexed* HOAS term type and a mapping from these\nterms to the natural numbers.  It depends on John Boyland's\nlibrary signatures, in particular void, bool, nat, natpair and multiset.\n\nThis file shows some of the extensions needed to handle indexed HOAS \nterms above and beyond those of \"regular\" HOAS terms (which is the topic of\nthe [HOAS_nat_bijection] page).  In the comments here, I emphasize those \ndifferent aspects rather than repeat the same discussion.\n}%\n\n%{| hidden = true }%\n% contents included from ../library/std.elf\n%%%%%% Proposed Twelf Standard Library\n%%%%%% John Boyland\n%%%%%% You may freely use, modify and distribute this file without restrictions.\n\n\n\n\n\n\n%%%% Structure\n\n\n\n%%% The uninhabited type\n\n\nvoid : type.\n\n\n%freeze void.\n\n\n\n\n%%% The uninteresting type\n\n\nunit : type.\n\n\nunit/ : unit.\n\n\n%freeze unit.\n\n\n\n%%% The three-way comparison type\n\n\ncomp : type.\n\n\nless    : comp.\n\ngreater : comp.\n\nequal   : comp.\n\n\n%freeze comp.\n\n%{| hidden = true }%\n% contents included from ../library/bool.elf\n%%%%% bool.elf\n%%%%% Boolean literals\n%%%%% John Boyland\n\n\n%%%% Definitions\n\n\n\nbool : type.\n\n\ntrue : bool.\n\nfalse : bool.\n\n\n%freeze bool.\n\n\n\neq? : bool -> bool -> bool -> type.\n\n%abbrev eq = [B1] [B2] eq? B1 B2 true.\n\n%abbrev ne = [B1] [B2] eq? B1 B2 false.\n\n\neq/ : eq B B.\n\n\nne/TF : ne true false.\n\nne/FT : ne false true.\n\n\n%abbrev eq?/yes = eq/.\n\n%abbrev eq?/no = [NE:ne B1 B2] NE.\n\n\nnot : bool -> bool -> type.\n\nnot/T : not true false.\n\nnot/F : not false true.\n\n\nand : bool -> bool -> bool -> type.\n\n\nand/FX : and false B false.\n\nand/XF : and B false false.\n\nand/TT : and true true true.\n\n\nor : bool -> bool -> bool -> type.\n\nor/TX: or true B true.\n\nor/XT: or B true true.\n\nor/FF: or false false false.\n\n\n\n\n\n%%%% Theorems\n\n\n\n%%% theorems about eq\n\n\n%theorem false-implies-eq :\n\tforall* {X1} {X2}\n\tforall {F:void}\n\texists {E:eq X1 X2}\n\ttrue.\n\n%worlds () (false-implies-eq _ _).\n%total { } (false-implies-eq _ _).\n\n\n%theorem meta-eq :\n\tforall {X1} {X2} {E:eq X1 X2}\n\ttrue.\n\n- : meta-eq _ _ eq/.\n\n%worlds () (meta-eq _ _ _).\n%total { } (meta-eq _ _ _).\n%reduces X = Y (meta-eq X Y _).\n\n\t\n%theorem eq-reflexive : \n\tforall {X} \n\texists {E:eq X X} \n\ttrue.\n\n- : eq-reflexive _ eq/.\n\n%worlds () (eq-reflexive _ _).\n%total { } (eq-reflexive _ _).\n\n\n%theorem eq-symmetric : \n\tforall* {X} {Y}\n\tforall {E:eq X Y}\n\texists {F:eq Y X}\n\ttrue.\n\n- : eq-symmetric (eq/) (eq/).\n\n%worlds () (eq-symmetric _ _).\n%total { } (eq-symmetric _ _).\n\n\n%theorem eq-transitive : \n\tforall* {X} {Y} {Z}\n\tforall {E1:eq X Y} {E2:eq Y Z}\n\texists {F:eq X Z}\n\ttrue.\n\n- : eq-transitive (eq/) (eq/) (eq/).\n\n%worlds () (eq-transitive _ _ _).\n%total { } (eq-transitive _ _ _).\n\n\n\n%%% theorems about ne\n\n\n%theorem false-implies-ne :\n\tforall* {X1} {X2}\n\tforall {F:void}\n\texists {G:ne X1 X2}\n\ttrue.\n\n%worlds () (false-implies-ne _ _).\n%total { } (false-implies-ne _ _).\n\n\n%theorem ne-respects-eq :\n\tforall* {X1} {X2} {Y1} {Y2}\n\tforall {D1:ne X1 X2} {E1:eq X1 Y1} {E2:eq X2 Y2}\n\texists {D2:ne Y1 Y2}\n\ttrue.\n\n- : ne-respects-eq X1<>X2 eq/ eq/ X1<>X2.\n\n%worlds () (ne-respects-eq _ _ _ _).\n%total { } (ne-respects-eq _ _ _ _).\n\n\n%theorem ne-anti-reflexive :\n\tforall* {B}\n\tforall {R:ne B B}\n\texists {F:void}\n\ttrue.\n\n%worlds () (ne-anti-reflexive _ _).\n%total { } (ne-anti-reflexive _ _).\n\n\n%theorem ne-symmetric :\n\tforall* {B1} {B2}\n\tforall {R1:ne B1 B2}\n\texists {R2:ne B2 B1}\n\ttrue.\n\n- : ne-symmetric ne/TF ne/FT.\n\n- : ne-symmetric ne/FT ne/TF.\n\n%worlds () (ne-symmetric _ _).\n%total { } (ne-symmetric _ _).\n\n\n%theorem eq-ne-implies-false :\n\tforall* {B1} {B2}\n\tforall {D1:eq B1 B2} {D2:ne B1 B2}\n\texists {F:void}\n\ttrue.\n\n%worlds () (eq-ne-implies-false _ _ _).\n%total { } (eq-ne-implies-false _ _ _).\n\n\n\n%%% theorems about eq?\n\n\n%theorem eq?-total* :\n\tforall {B1} {B2}\n\texists {B} {EQ?:eq? B1 B2 B}\n\ttrue.\n\n- : eq?-total* true true _ (eq?/yes).\n\n- : eq?-total* false false _ (eq?/yes).\n\t\n- : eq?-total* true false _ (eq?/no ne/TF).\n\n- : eq?-total* false true _ (eq?/no ne/FT).\n\n\n%worlds () (eq?-total* _ _ _ _).\n%total { } (eq?-total* _ _ _ _).\n\n\n%abbrev eq?-total = eq?-total* _ _ _.\n\n\n\n%%% Theorems about not, and, or\n\n\n\n\n%theorem not-total*:\n\tforall {B1}\n\texists {B2} {N:not B1 B2}\n\ttrue.\n\n%abbrev not-total = not-total* _ _.\n\n- : not-total not/T.\n\n- : not-total not/F.\n\n%worlds () (not-total* _ _ _).\n\n\n%theorem and-total* :\n\tforall {B1} {B2} \n\texists {B3} {A:and B1 B2 B3}\n\ttrue.\n\n%abbrev and-total = and-total* _ _ _.\n\n- : and-total and/FX.\n\n- : and-total and/XF.\n\n- : and-total and/TT.\n\n%worlds () (and-total* _ _ _ _).\n%total { } (and-total* _ _ _ _).\n\n\n%theorem or-total* :\n\tforall {B1} {B2} \n\texists {B3} {A:or B1 B2 B3}\n\ttrue.\n\n%abbrev or-total = or-total* _ _ _.\n\n- : or-total or/TX.\n\n- : or-total or/XT.\n\n- : or-total or/FF.\n\n%worlds () (or-total* _ _ _ _).\n%total { } (or-total* _ _ _ _).\n%abbrev bool`bool = bool.\n%abbrev bool`true = true.\n%abbrev bool`false = false.\n%abbrev bool`eq? = eq?.\n%abbrev bool`eq = eq.\n%abbrev bool`ne = ne.\n%abbrev bool`eq/ = eq/.\n%abbrev bool`ne/TF = ne/TF.\n%abbrev bool`ne/FT = ne/FT.\n%abbrev bool`eq?/yes = eq?/yes.\n%abbrev bool`eq?/no = eq?/no.\n%abbrev bool`not = not.\n%abbrev bool`not/T = not/T.\n%abbrev bool`not/F = not/F.\n%abbrev bool`and = and.\n%abbrev bool`and/FX = and/FX.\n%abbrev bool`and/XF = and/XF.\n%abbrev bool`and/TT = and/TT.\n%abbrev bool`or = or.\n%abbrev bool`or/TX = or/TX.\n%abbrev bool`or/XT = or/XT.\n%abbrev bool`or/FF = or/FF.\n%abbrev bool`false-implies-eq = false-implies-eq.\n%abbrev bool`meta-eq = meta-eq.\n%abbrev bool`eq-reflexive = eq-reflexive.\n%abbrev bool`eq-symmetric = eq-symmetric.\n%abbrev bool`eq-transitive = eq-transitive.\n%abbrev bool`false-implies-ne = false-implies-ne.\n%abbrev bool`ne-respects-eq = ne-respects-eq.\n%abbrev bool`ne-anti-reflexive = ne-anti-reflexive.\n%abbrev bool`ne-symmetric = ne-symmetric.\n%abbrev bool`eq-ne-implies-false = eq-ne-implies-false.\n%abbrev bool`eq?-total* = eq?-total*.\n%abbrev bool`eq?-total = eq?-total.\n%abbrev bool`not-total* = not-total*.\n%abbrev bool`not-total = not-total.\n%abbrev bool`and-total* = and-total*.\n%abbrev bool`and-total = and-total.\n%abbrev bool`or-total* = or-total*.\n%abbrev bool`or-total = or-total.\n%{| hidden = true }%\n% contents included from ../library/nat.elf\n%%%%% Natural numbers\n%%%%% John Boyland\n%%%%% Anyone may use, copy or modify this software without restriction\n\n%%%%% This file requires std.elf\n\n\n\n\n\n\n\n\n%%%%% nat-base.elf\n%%%%% Basic definitions, operations and theorems\n%%%%% This file is part of the nat.elf signature\n\n\n%%%% Definitions\n\n\n%%% Natural numbers:\n\n\nnat : type.\t\t\t\t%name nat N.\n\n\nz : nat.\n\ns : nat -> nat.\n\n%freeze nat.\n\n\n%%% Operations on natural numbers\n\n\nplus : nat -> nat -> nat -> type.\n\n\nplus/z : plus z Y Y.\n\nplus/s : plus (s X) Y (s Z)\n    <- plus X Y Z.\n\n\n\ntimes : nat -> nat -> nat -> type.\n\n\ntimes/z : times z X z.\n\ntimes/s : times (s X) Y Z\n    <- plus T Y Z\n    <- times X Y T.\n\n\n\neq : nat -> nat -> type.\n\n\neq/ : eq N N.\n\n\n\ngt : nat -> nat -> type.\n\n\ngt/1 : gt (s M) M.\n\ngt/> : gt (s M) N\n     <- gt M N.\n\n\n\n%%% Using the conditional for natural numbers\n\n\ncompare : nat -> nat -> comp -> type.\n\n\ncompare/= : compare N N equal.\n\ncompare/< : compare M N less <- gt N M.\n\ncompare/> : compare M N greater <- gt M N.\n\n\n\n\n%%%% Theorems\n\n\n\n%%% Theorems about eq\n\n\n%reduces X = Y (eq X Y).\n\n\n%theorem meta-eq : forall {M} {N} {E:eq M N} true.\n\n- : meta-eq N N eq/.\n\n%worlds () (meta-eq _ _ _).\n%total {} (meta-eq _ _ _).\n%reduces X = Y (meta-eq X Y _).\n\n\n%theorem false-implies-eq :\n\tforall* {M} {N}\n\tforall {P:void}\n        exists {Q:eq M N}\n\ttrue.\n\n%worlds () (false-implies-eq _  M=N).\n%total {} (false-implies-eq _ _).\n\n\t\t    \n%theorem eq-symmetric : forall* {M:nat} {N:nat}\n\tforall {E:eq M N}\n\texists {F:eq N M}\n\ttrue.\n\n- : eq-symmetric (eq/) (eq/).\n\n%worlds () (eq-symmetric M>N  N>M).\n%total {} (eq-symmetric _ _).\n\n\n%theorem eq-transitive : \n\tforall* {M:nat} {N:nat} {P:nat}\n\tforall {E1:eq M N} {E2:eq N P}\n\texists {F:eq M P}\n\ttrue.\n\n- : eq-transitive (eq/) (eq/) (eq/).\n\n%worlds () (eq-transitive M>N N>P  M>P).\n%total {} (eq-transitive _ _ _).\n\n\n%theorem succ-deterministic : \n\tforall* {N1:nat} {N2:nat}\n        forall {E:eq N1 N2}\n        exists {F:eq (s N1) (s N2)}\n        true.\n\n- : succ-deterministic eq/ eq/.\n\n%worlds () (succ-deterministic N1=N2  N1+1=N2+1).\n%total {} (succ-deterministic E _).\n\n\n%theorem succ-cancels : \n\tforall*  {N1:nat} {N2:nat}\n        forall {E:eq (s N1) (s N2)}\n        exists {F:eq N1 N2}\n        true.\n\n- : succ-cancels eq/ eq/.\n\n%worlds () (succ-cancels N1+1=N2+1  N1=N2).\n%total {} (succ-cancels E _).\n\n\n%theorem succ-contradiction :\n\tforall* {N}\n\tforall {E:eq N (s N)}\n\texists {F:void}\n\ttrue.\n\n%worlds () (succ-contradiction _ _).\n%total { } (succ-contradiction _ _).\n\n\n%theorem eq-contradiction : \n\tforall* {N}\n        forall {E:eq z (s N)}\n        exists {F:void}\n\ttrue.\n\n%worlds () (eq-contradiction ZERO=N+1  _).\n%total {} (eq-contradiction _ _).\n\n\n\n%%% Theorems about gt\n\n\n%reduces M < N (gt N M).\n\n\n%% If we want to prove the termination of a theorem using gt,\n%% we need the gt relation lifted to the meta level:\n\n%theorem meta-gt : forall {M} {N} {G:gt M N} true.\n\n- : meta-gt (s M) M (gt/1).\n\n- : meta-gt (s M) N (gt/> G)\n    <- meta-gt M N G.\n\n%worlds () (meta-gt _ _ _).\n%total M (meta-gt M _ _).\n%reduces M < N (meta-gt N M _).\n\n\n%theorem false-implies-gt :\n\tforall* {M} {N}\n\tforall {P:void}\n        exists {Q:gt M N}\n\ttrue.\n\n%worlds () (false-implies-gt _  M>N).\n%total {} (false-implies-gt _ _).\n\n\t\t    \n%theorem gt-respects-eq : \n\tforall* {M1:nat} {M2:nat} {N1:nat} {N2:nat}\n        forall {P:gt M1 N1} {E1:eq M1 M2} {E2:eq N1 N2}\n        exists {Q:gt M2 N2}\n\ttrue.\n\n- : gt-respects-eq M1>N1 eq/ eq/ M1>N1.\n\n%worlds () (gt-respects-eq M1>N1 M1=M2 N1=N2  M2>N2).\n%total {} (gt-respects-eq _ _ _ _).\n\n\n%theorem succ-implies-gt  : \n\tforall* {X} {X'}\n\tforall {E:eq X (s X')}\n\texists {G:gt X X'}\n\ttrue.\n\n- : succ-implies-gt eq/ gt/1.\n\n%worlds () (succ-implies-gt X=sX'  X>X').\n%total {} (succ-implies-gt _ _).\n\n\n%theorem succ-implies-gt-zero: \n        forall {M}\n        exists {G:gt (s M) z}\n\ttrue.\n\n- : succ-implies-gt-zero z gt/1.\n\n- : succ-implies-gt-zero (s M) (gt/> SM>0)\n    <- succ-implies-gt-zero M SM>0.\n\n%worlds () (succ-implies-gt-zero M  SM>0).\n%total M (succ-implies-gt-zero M _).\n\n\n%theorem succ-preserves-gt:     \n        forall* {M} {N}\n        forall {G1:gt M N}\n\texists {G2:gt (s M) (s N)}\n\ttrue.\n\n- : succ-preserves-gt gt/1 gt/1.\n\n- : succ-preserves-gt (gt/> M>N) (gt/> SM>SN)\n    <- succ-preserves-gt M>N SM>SN.\n\n%worlds () (succ-preserves-gt M>N  SM>SN).\n%total G1 (succ-preserves-gt G1 _).\n\n\n%theorem succ-preserves-gt-converse:\n        forall* {M} {N}\n\tforall {G1:gt (s M) (s N)}\n        exists {G2:gt M N}\n\ttrue.\n\n- : succ-preserves-gt-converse gt/1 gt/1.\n\n- : succ-preserves-gt-converse (gt/> SM>SN) (gt/> M>N)\n    <- succ-preserves-gt-converse SM>SN M>N.\n\n%worlds () (succ-preserves-gt-converse SM>SN  M>N).\n%total G1 (succ-preserves-gt-converse G1 _).\n\n\n%theorem gt-implies-positive :\n        forall* {M} {N} \n        forall {G:gt M N} \n        exists {M'} {E:eq M (s M')}\n        true.\n\n- : gt-implies-positive gt/1 M eq/.\n\n- : gt-implies-positive (gt/> (G:gt M N)) M eq/.\n\n%worlds () (gt-implies-positive M>N  M' M=sM').\n%total {} (gt-implies-positive _ _ _).\n\n\n%theorem gt-anti-reflexive* :\n        forall {M}\n               {G:gt M M}\n        exists {F:void}\n        true.\n\n- : gt-anti-reflexive* (s M) (G:gt (s M) (s M)) F\n     <- succ-preserves-gt-converse G G'\n     <- gt-anti-reflexive* M G' F.\n\n%worlds () (gt-anti-reflexive* M M>M  _).\n%total M (gt-anti-reflexive* M _ _).\n\n\n%abbrev gt-anti-reflexive = gt-anti-reflexive* _.\n\n\n%theorem gt-transitive : \n\tforall* {M} {N} {P}\n        forall {G1:gt M N} {G2:gt N P}\n        exists {G3:gt M P}\n        true.\n\n- : gt-transitive gt/1 G (gt/> G).\n\n- : gt-transitive (gt/> M>N) N>P (gt/> M>P)\n    <- gt-transitive M>N N>P M>P.\n\n%worlds () (gt-transitive M>N N>P  M>P).\n%total (G1) (gt-transitive G1 _ _).\n\n\n%theorem gt-anti-symmetric :\n        forall* {M} {N}\n\tforall {G1:gt M N} {G2:gt N M}\n        exists {F:void}\n        true.\n\n- : gt-anti-symmetric M>N N>M F\n    <- gt-transitive M>N N>M M>M\n    <- gt-anti-reflexive M>M F.\n\n%worlds () (gt-anti-symmetric M>N N>M  _).\n%total {} (gt-anti-symmetric _ _ _).\n\n\n%theorem gt-implies-plus : \n\tforall* {M} {N}\n        forall {G:gt M N}\n        exists {D} {P:plus (s D) N M}\n        true.\n\n- : gt-implies-plus gt/1 z (plus/s plus/z).\n\n- : gt-implies-plus (gt/> M>N) (s D) (plus/s SD+N=M)\n    <- gt-implies-plus M>N D SD+N=M.\n\n%worlds () (gt-implies-plus M>N  D SD+N=M).\n%total G (gt-implies-plus G _ _).\n\n\n%theorem gt-contradiction :\n    forall* {M}\n    forall {P:gt z M}\n    exists {Q:void}\n    true.\n\n%worlds () (gt-contradiction ZERO>N  _).\n%total {} (gt-contradiction _ _).\n\n\n\n%%% Theorems about compare\n\n\n%theorem false-implies-compare :\n\tforall* {M} {N} {C}\n\tforall {P:void}\n        exists {Q:compare M N C}\n\ttrue.\n\n%worlds () (false-implies-compare _ _).\n%total {} (false-implies-compare _ _).\n\n\n%theorem succ-preserves-compare :\n\tforall* {M} {N} {C}\n\tforall {CMP:compare M N C}\n\texists {CMP':compare (s M) (s N) C}\n\ttrue.\n\n- : succ-preserves-compare compare/= compare/=.\n\n- : succ-preserves-compare (compare/< M>N) (compare/< M+1>N+1)\n    <- succ-preserves-gt M>N M+1>N+1.\n\n- : succ-preserves-compare (compare/> M>N) (compare/> M+1>N+1)\n    <- succ-preserves-gt M>N M+1>N+1.\n\n%worlds () (succ-preserves-compare _ _).\n%total {} (succ-preserves-compare _ _).\n\n\n%theorem compare-total* :\n\tforall {M} {N}\n\texists {CMP} {P:(compare M N CMP)}\n\ttrue.\n\n- : compare-total* z z equal compare/=.\n\n- : compare-total* z (s M) less (compare/< M+1>0)\n    <- succ-implies-gt-zero M M+1>0.\n\n- : compare-total* (s M) z greater (compare/> M+1>0)\n    <- succ-implies-gt-zero M M+1>0.\n\n- : compare-total* (s M) (s N) R M+1-R-N+1\n    <- compare-total* M N R M-R-N\n    <- succ-preserves-compare M-R-N M+1-R-N+1.\n\n%worlds () (compare-total* _ _ _ _).\n%total (M) (compare-total* M _ _ _).\n\n\n%abbrev compare-total = compare-total* _ _ _.\n\n\n%theorem greater-implies-gt : \n\tforall* {M} {N}\n\tforall {C:compare M N greater}\n        exists {G:gt M N}\n\ttrue.\n\n- : greater-implies-gt (compare/> G) G.\n\n%worlds () (greater-implies-gt M>N  M-gt-N).\n%total C (greater-implies-gt C _).\n\n\n%theorem less-is-reverse-greater :\n        forall* {M} {N}\n\tforall {C1:compare M N less}\n\texists {C2:compare N M greater}\n\ttrue.\n\n- : less-is-reverse-greater (compare/< G) (compare/> G).\n\n%worlds () (less-is-reverse-greater M<N  N>M).\n%total C (less-is-reverse-greater C _).\n\n\n%theorem less-implies-lt : \n\tforall* {M} {N}\n\tforall {C:compare M N less}\n\texists {G:gt N M}\n\ttrue.\n\n- : less-implies-lt (compare/< G) G.\n\n%worlds () (less-implies-lt M<N  N-gt-M).\n%total {} (less-implies-lt _ _).\n\n\n%theorem equal-implies-eq : \n\tforall* {M} {N}\n\tforall {C:compare M N equal}\n\texists {E:eq M N}\n\ttrue.\n\n- : equal-implies-eq compare/= eq/.\n\n%worlds () (equal-implies-eq M=N  M-eq-N).\n%total C (equal-implies-eq C _).\n\n\n\n%%% Theorems about plus\n\n\n%theorem false-implies-plus :\n\tforall* {M} {N} {O}\n\tforall {P:void}\n        exists {Q:plus M N O}\n\ttrue.\n\n%worlds () (false-implies-plus _ _).\n%total {} (false-implies-plus _ _).\n\n\t\t    \n%theorem plus-respects-eq : \n\tforall* {M1:nat} {M2:nat} {N1:nat} {N2:nat} {P1:nat} {P2:nat}\n        forall {P:plus M1 N1 P1} \n               {E1:eq M1 M2} {E2:eq N1 N2} {E3:eq P1 P2}\n        exists {Q:plus M2 N2 P2}\n\ttrue.\n\n- : plus-respects-eq M1+N1=P1 eq/ eq/ eq/ M1+N1=P1.\n\n%worlds () (plus-respects-eq M1+N1=P1 M1=M2 N1=N2 P1=P2  M2+N2=P2).\n%total {} (plus-respects-eq _ _ _ _ _).\n\n\n%theorem plus-total*: \n\tforall {N1:nat} {N2:nat}\n        exists {N3:nat} {P:plus N1 N2 N3}\n        true.\n\n- : plus-total* _ _ _ plus/z.\n\n- : plus-total* (s N1') N2 (s N3) (plus/s P)\n    <- plus-total* N1' N2 N3 P.\n\n%worlds () (plus-total* N1 N2  N3 N1+N2=N3).\n%total N1 (plus-total* N1 _ _ _).\n\n\n%abbrev plus-total = plus-total* _ _ _.\n\n\n%theorem plus-deterministic: \n\tforall* {N1:nat} {N1':nat} {N2:nat} {N2':nat} {N3:nat} {N3':nat}\n        forall {P:plus N1 N2 N3} {P':plus N1' N2' N3'}\n\t       {E1:eq N1 N1'} {E2:eq N2 N2'}\n        exists {E3:eq N3 N3'}\n        true.\n\n- : plus-deterministic plus/z plus/z eq/ eq/ eq/.\n\n- : plus-deterministic \n        (plus/s (P:plus N1 N2 N3)) \n        (plus/s (P':plus N1' N2' N3')) \n        E1 E2 (E:eq (s N3) (s N3'))\n     <- succ-cancels E1 E1'\n     <- plus-deterministic P P' E1' E2 E'\n     <- succ-deterministic E' E.\n\n%worlds () (plus-deterministic _ _ _ _ _).\n%total (P) (plus-deterministic P _ _ _ _).\n\n\n%theorem plus-left-identity : \n\tforall {N:nat}\n\texists {P:plus z N N}\n\ttrue.\n\n- : plus-left-identity N plus/z.\n\n%worlds () (plus-left-identity N  Z+N=N).\n%total {} (plus-left-identity _ _).\n\n\n%theorem plus-left-increase :\n\tforall* {M:nat} {N:nat} {O:nat}\n        forall {P:plus M N O}\n\texists {Q:plus (s M) N (s O)}\n\ttrue.\n\n- : plus-left-increase P (plus/s P).\n\n%worlds () (plus-left-increase M+N=O  SM+N=sO).\n%total {} (plus-left-increase _ _).\n\n\n%theorem plus-right-identity : \n\tforall {N:nat}\n\texists {P:plus N z N}\n\ttrue.\n\n- : plus-right-identity z plus/z.\n\n- : plus-right-identity (s N) (plus/s N+0=N)\n    <- plus-right-identity N N+0=N.\n\n%worlds () (plus-right-identity N  N+0=N).\n%total N (plus-right-identity N _).\n\n\n%theorem plus-right-increase : \n\tforall* {M:nat} {N:nat} {O:nat}\n\tforall {P:plus M N O}\n\texists {Q:plus M (s N) (s O)}\n\ttrue.\n\n- : plus-right-increase plus/z plus/z.\n\n- : plus-right-increase (plus/s M+N=O) (plus/s M+sN=sO)\n    <- plus-right-increase M+N=O M+sN=sO.\n\n%worlds () (plus-right-increase M+N=O  M+sN=sO).\n%total P (plus-right-increase P _).\n\n\n%theorem plus-left-decrease:\n\tforall* {M:nat} {N:nat} {O':nat}\n\tforall {P:plus (s M) N O'}\n\texists {O} {E:eq O' (s O)} {Q:plus M N O}\n\ttrue.\n\n- : plus-left-decrease (plus/s M+N=O) O eq/ M+N=O.\n\n%worlds () (plus-left-decrease SM+N=O'  O O'=sO M+N=O).\n%total {} (plus-left-decrease _ _ _ _).\n\n\n%theorem plus-right-decrease:\n\tforall* {M:nat} {N:nat} {O':nat}\n\tforall {P:plus M (s N) O'}\n\texists {O} {E:eq O' (s O)} {Q:plus M N O}\n\ttrue.\n\n- : plus-right-decrease (plus/z) N eq/ (plus/z).\n\n- : {M+sN=O: plus M (s N) O} {sM+N=O:plus (s M) N O} {sM+N=X:plus (s M) N X}\n    plus-right-decrease (plus/s M+sN=O) _ eq/ sM+N=O\n    <- plus-right-decrease M+sN=O O' O=sO' M+N=O'\n    <- plus-total sM+N=X\n    <- plus-deterministic (plus/s M+N=O') sM+N=X eq/ eq/ SO'=X\n    <- eq-transitive O=sO' SO'=X O=X\n    <- eq-symmetric O=X X=O\n    <- plus-respects-eq sM+N=X eq/ eq/ X=O sM+N=O.\n\n%worlds () (plus-right-decrease M+sN=O'  O O'=sO M+N=O).\n%total P (plus-right-decrease P _ _ _).\n\n\n%theorem plus-swap-succ:\n\tforall* {N1} {N2} {N3}\n\tforall {P:plus (s N1) N2 N3}\n\texists {P':plus N1 (s N2) N3}\n\ttrue.\n\n- : plus-swap-succ (plus/s N1+N2=N3-) N1+sN2=N3\n    <- plus-right-increase N1+N2=N3- N1+sN2=N3.\n\n%worlds () (plus-swap-succ SN1+N2=N3  N1+sN2=N3).\n%total {} (plus-swap-succ _ _).\n\n\n%theorem plus-swap-succ-converse:\n\tforall* {N1} {N2} {N3}\n\tforall {P:plus N1 (s N2) N3}\n\texists {P':plus (s N1) N2 N3}\n\ttrue.\n\n- : plus-swap-succ-converse N1+sN2=N3 SN1+N2=N3\n    <- plus-right-decrease N1+sN2=N3 N3- N3=sN3- N1+N2=N3-\n    <- eq-symmetric N3=sN3- SN3-=N3\n    <- plus-respects-eq (plus/s N1+N2=N3-) eq/ eq/ SN3-=N3 SN1+N2=N3.\n\n%worlds () (plus-swap-succ-converse N1+sN2=N3  SN1+N2=N3).\n%total {} (plus-swap-succ-converse _ _).\n\n\n%theorem plus-left-preserves-positive:\n\tforall* {N1} {N2} {N3} {N1-}\n\tforall {P:plus N1 N2 N3} {E:eq N1 (s N1-)}\n        exists {N3-} {E':eq N3 (s N3-)}\n\ttrue.\n\n- : plus-left-preserves-positive (plus/s N1-+N2=N3-) eq/ _ eq/.\n\n%worlds () (plus-left-preserves-positive N1+N2=N3 N1=sN1-  N3- N3=sN3-).\n%total {} (plus-left-preserves-positive _ _ _ _).\n\n\n%theorem plus-right-preserves-positive:\n\tforall* {N1} {N2} {N3} {N2-}\n\tforall {P:plus N1 N2 N3} {E:eq N2 (s N2-)}\n\texists {N3-} {E':eq N3 (s N3-)}\n\ttrue.\n\n- : plus-right-preserves-positive N1+N2=N3 N2=sN2- N3- N3=sN3-\n    <- plus-respects-eq N1+N2=N3 eq/ N2=sN2- eq/ N1+sN2-=N3\n    <- plus-right-decrease N1+sN2-=N3 N3- N3=sN3- _.\n\n%worlds () (plus-right-preserves-positive N1+N2=N3 N2+  N3- N3+).\n%total {} (plus-right-preserves-positive _ _ _ _).\n\n\n%theorem plus-is-zero-implies-zero :\n\tforall* {N1} {N2} {N3}\n\tforall {P:plus N1 N2 N3} {E3:eq N3 z}\n        exists {E1:eq N1 z} {E2:eq N2 z}\n\ttrue.\n\n- : plus-is-zero-implies-zero plus/z eq/ eq/ eq/.\n\n%worlds () (plus-is-zero-implies-zero X+Y=Z Z=0  X=0 Y=0).\n%total {} (plus-is-zero-implies-zero _ _ _ _).\n\n\n%theorem plus-commutative: \n\tforall* {N1} {N2} {N12}\n        forall {P:plus N1 N2 N12}\n\texists {Q:plus N2 N1 N12}\n\ttrue.\n\n- : plus-commutative (plus/z) N2+z=N2\n    <- plus-right-identity N2 N2+z=N2.\n\n- : plus-commutative (plus/s N1+N2=N3) N2+sN1=sN3\n    <- plus-commutative N1+N2=N3 N2+N1=N3\n    <- plus-right-increase N2+N1=N3 N2+sN1=sN3.\n\n%worlds () (plus-commutative N1+N2=N3  N2+N1=N3).\n%total P (plus-commutative P _).\n\n\n%theorem plus-associative :\n\tforall* {X:nat} {Y:nat} {Z:nat} {X':nat} {Z':nat}\n        forall {P1:plus X Y X'} {P2:plus X' Z Z'}\n\texists {Y':nat} {Q1:plus Y Z Y'} {Q2:plus X Y' Z'}\n\ttrue.\n\n- : plus-associative plus/z (P2:plus N2 N3 N23) N23 P2 plus/z.\n\n- : plus-associative (plus/s N1+N2=N12) (plus/s N12+N3=N123) \n                     N23 N2+N3=N23 (plus/s N1+N23=N123)\n    <- plus-associative N1+N2=N12 N12+N3=N123 N23 N2+N3=N23 N1+N23=N123.\n\n%worlds () (plus-associative _ _ _ _ _).\n%total P1 (plus-associative P1 _ _ _ _).\n\n\n%theorem plus-associative* :\n\tforall* {X1} {X2} {X12} {X3} {X23} {X123}\n        forall {OP12:plus X1 X2 X12} {OP12-3:plus X12 X3 X123} {OP23:plus X2 X3 X23}\n        exists {OP1-23:plus X1 X23 X123}\n        true.\n\n- : plus-associative* X1+X2=X3 X3+X4=X7 X2+X4=X6 X1+X6=X7\n    <- plus-associative X1+X2=X3 X3+X4=X7 Y6 X2+X4=Y6 X1+Y6=X7\n    <- plus-deterministic X2+X4=Y6 X2+X4=X6 eq/ eq/ Y6=X6\n    <- plus-respects-eq X1+Y6=X7 eq/ Y6=X6 eq/ X1+X6=X7.\n\n%worlds () (plus-associative* _ _ _ _).\n%total {} (plus-associative* _ _ _ _).\n\n\n%theorem plus-associative-converse :\n\tforall* {X1} {X2} {X4} {X6} {X7}\n\tforall {OP24:plus X2 X4 X6} {OP16:plus X1 X6 X7}\n        exists {X3} {OP12:plus X1 X2 X3} {OP34:plus X3 X4 X7}\n        true.\n\n- : plus-associative-converse X2+X4=X6 X1+X6=X7 _ X1+X2=X3 X3+X4=X7\n    <- plus-commutative X2+X4=X6 X4+X2=X6\n    <- plus-commutative X1+X6=X7 X6+X1=X7\n    <- plus-associative X4+X2=X6 X6+X1=X7 _ X2+X1=X3 X4+X3=X7\n    <- plus-commutative X2+X1=X3 X1+X2=X3\n    <- plus-commutative X4+X3=X7 X3+X4=X7.\n\n%worlds () (plus-associative-converse X2+X4=X6 X1+X6=X7 X3 X1+X2=X3 X3+X4=X7).\n%total {} (plus-associative-converse _ _ _ _ _).\n\n\n%theorem plus-associative-converse* :\n\tforall* {X1} {X2} {X3} {X4} {X6} {X7}\n\tforall {OP24:plus X2 X4 X6} {OP16:plus X1 X6 X7} {OP12:plus X1 X2 X3} \n\texists {OP34:plus X3 X4 X7}\n        true.\n\n- : plus-associative-converse* X2+X4=X6 X1+X6=X7 X1+X2=X3 X3+X4=X7\n    <- plus-associative-converse X2+X4=X6 X1+X6=X7 X3P X1+X2=X3P X3P+X4=X7\n    <- plus-deterministic X1+X2=X3P X1+X2=X3 eq/ eq/ X3P=X3\n    <- plus-respects-eq X3P+X4=X7 X3P=X3 eq/ eq/ X3+X4=X7.\n\n%worlds () (plus-associative-converse* X2+X4=X6 X1+X6=X7 X1+X2=X3  X3+X4=X7).\n%total {} (plus-associative-converse* _ _ _ _).\n\n%% The following two theorems are useful for reordering elements\n%% is a left-associative sequence of operations.\n\n%theorem plus-assoc-commutative* :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X7}\n\tforall {OP1:plus X1 X2 X3} {OP2:plus X3 X4 X7}\n               {OP3:plus X1 X4 X5} \n        exists {OP4:plus X5 X2 X7}\n\ttrue.\n\n- : plus-assoc-commutative* X1+X2=X3 X3+X4=X7 X1+X4=X5 X5+X2=X7\n    <- plus-associative X1+X2=X3 X3+X4=X7 X6 X2+X4=X6 X1+X6=X7\n    <- plus-commutative X2+X4=X6 X4+X2=X6\n    <- plus-associative-converse* X4+X2=X6 X1+X6=X7 X1+X4=X5 X5+X2=X7.\n\n%worlds () (plus-assoc-commutative* X1+X2=X3 X3+X4=X7 X1+X4=X5  X5+X2=X7).\n%total {} (plus-assoc-commutative* _ _ _ _).\n\n\n%theorem plus-assoc-commutative :\n\tforall* {X1} {X2} {X3} {X4} {X7}\n\tforall {OP1:plus X1 X2 X3} {OP2:plus X3 X4 X7}\n        exists {X5} {OP3:plus X1 X4 X5} {OP4:plus X5 X2 X7}\n\ttrue.\n\n- : plus-assoc-commutative X1+X2=X3 X3+X4=X7 X5 X1+X4=X5 X5+X2=X7\n    <- plus-associative X1+X2=X3 X3+X4=X7 X6 X2+X4=X6 X1+X6=X7\n    <- plus-commutative X2+X4=X6 X4+X2=X6\n    <- plus-associative-converse X4+X2=X6 X1+X6=X7 X5 X1+X4=X5 X5+X2=X7.\n\n%worlds () (plus-assoc-commutative X1+X2=X3 X3+X4=X7  X5 X1+X4=X5 X5+X2=X7).\n%total {} (plus-assoc-commutative _ _ _ _ _).\n\n%% The following theorem is a useful shortcut to\n%% re-associate (AB)(CD) to (AC)(BD):\n\n%theorem plus-double-associative* :\n\tforall* {A} {B} {C} {D} {A+B} {C+D} {A+C} {B+D} {X}\n\tforall {AB:plus A B A+B} {CD:plus C D C+D} {ABCD:plus A+B C+D X}\n\t       {AC:plus A C A+C} {BD:plus B D B+D} \n        exists {ACBD:plus A+C B+D X}\n\ttrue.\n\n- : plus-double-associative* X1+X2=X3 X4+X8=XC X3+XC=XF X1+X4=X5 X2+X8=XA X5+XA=XF\n    <- plus-associative X1+X2=X3 X3+XC=XF XE X2+XC=XE X1+XE=XF\n    <- plus-commutative X4+X8=XC X8+X4=XC\n    <- plus-associative-converse* X8+X4=XC X2+XC=XE X2+X8=XA XA+X4=XE\n    <- plus-commutative XA+X4=XE X4+XA=XE\n    <- plus-associative-converse* X4+XA=XE X1+XE=XF X1+X4=X5 X5+XA=XF.\n\n%worlds () (plus-double-associative* X1+X2=X3 X4+X8=XC X3+XC=XF X1+X4=X5 X2+X8=XA\n                             X5+XA=XF).\n%total {} (plus-double-associative* _ _ _ _ _ _).\n\n\n%theorem plus-double-associative :\n\tforall* {A} {B} {C} {D} {A+B} {C+D} {X}\n\tforall {AB:plus A B A+B} {CD:plus C D C+D} {ABCD:plus A+B C+D X}\n\texists {A+C} {B+D} {AC:plus A C A+C} {BD:plus B D B+D} \n               {ACBD:plus A+C B+D X}\n\ttrue.\n\n- : plus-double-associative X1+X2=X3 X4+X8=XC X3+XC=XF X5 XA X1+X4=X5 X2+X8=XA X5+XA=XF\n    <- plus-associative X1+X2=X3 X3+XC=XF XE X2+XC=XE X1+XE=XF\n    <- plus-commutative X4+X8=XC X8+X4=XC\n    <- plus-associative-converse X8+X4=XC X2+XC=XE XA X2+X8=XA XA+X4=XE\n    <- plus-commutative XA+X4=XE X4+XA=XE\n    <- plus-associative-converse X4+XA=XE X1+XE=XF X5 X1+X4=X5 X5+XA=XF.\n\n%worlds () (plus-double-associative _ _ _ _ _ _ _ _).\n%total { } (plus-double-associative _ _ _ _ _ _ _ _).\n\n%theorem plus-left-cancels : \n\tforall* {X1:nat} {X2:nat} {Y:nat} {Z:nat} {S1:nat} {S2:nat}\n        forall {P1:plus X1 Y S1} {P2:plus X2 Z S2} \n               {EX:eq X1 X2} {ES:eq S1 S2}\n\texists {F:eq Y Z}\n        true.\n\n- : plus-left-cancels plus/z plus/z eq/ eq/ eq/.\n\n- : plus-left-cancels (plus/s X+Y1=Z) (plus/s X+Y2=Z) eq/ eq/ Y1=Y2\n    <- plus-left-cancels X+Y1=Z X+Y2=Z eq/ eq/ Y1=Y2.\n\n%worlds () (plus-left-cancels X1+Y1=Z1 X2+Y2=Z2 X1=X2 Z1=Z2  Y1=Y2).\n%total P1 (plus-left-cancels P1 _ _ _ _).\n\n\n%theorem plus-right-cancels* : \n\tforall* {X:nat} {Y:nat} {Z1:nat} {Z2:nat}\n        forall {S1} {S2}\n               {P1:plus X Z1 S1} {P2:plus Y Z2 S2}\n\t       {EZ:eq Z1 Z2} {ES:eq S1 S2}\n\texists {F:eq X Y}\n        true.\n\n- : plus-right-cancels* Z Z X1+0=Z X2+0=Z eq/ eq/ X1=X2\n    <- plus-right-identity X1 X1+0=X1\n    <- plus-deterministic X1+0=X1 X1+0=Z eq/ eq/ X1=Z\n    <- plus-right-identity X2 X2+0=X2\n    <- plus-deterministic X2+0=X2 X2+0=Z eq/ eq/ X2=Z\n    <- eq-symmetric X2=Z Z=X2\n    <- eq-transitive X1=Z Z=X2 X1=X2.\n\n- : {sZ'=Z:eq (s Z') Z} {sZ'=sZ'':eq (s Z') (s Z'')}\n    plus-right-cancels* Z Z X1+sY=Z X2+sY=Z eq/ eq/ X1=X2\n    <- plus-right-decrease X1+sY=Z Z' Z=sZ' X1+Y=Z'\n    <- plus-right-decrease X2+sY=Z Z'' Z=sZ'' X2+Y=Z''\n    <- eq-symmetric Z=sZ' sZ'=Z\n    <- eq-transitive sZ'=Z Z=sZ'' sZ'=sZ''\n    <- succ-cancels sZ'=sZ'' Z'=Z''\n    <- meta-eq Z (s Z') Z=sZ'\n    <- plus-right-cancels* Z' Z'' X1+Y=Z' X2+Y=Z'' eq/ Z'=Z'' X1=X2.\n\n%worlds () (plus-right-cancels* Z1 Z2 X1+Y1=Z1 X2+Y2=Z2 Y1=Y2 Z1=Z2  X1=X2).\n%total Z (plus-right-cancels* Z _ _ _ _ _ _).\n\n\n%abbrev plus-right-cancels = plus-right-cancels* _ _.\n\n\n%theorem plus-left-preserves-gt*:\n        forall* {M} {N1} {N2} {O1} {O2}\n        forall {G1:gt N1 N2} {P1:plus M N1 O1} {P2:plus M N2 O2}\n        exists {G2:gt O1 O2}\n        true.\n\n- : plus-left-preserves-gt* N1>N2 plus/z plus/z N1>N2.\n\n- : plus-left-preserves-gt* N1>N2 (plus/s M+N1=O1) (plus/s M+N2=O2) SO1>SO2\n    <- plus-left-preserves-gt* N1>N2 M+N1=O1 M+N2=O2 O1>O2\n    <- succ-preserves-gt O1>O2 SO1>SO2.\n\n%worlds () (plus-left-preserves-gt* N1>N2 M+N1=O1 M+N2=O2  O1>O2).\n%total P1 (plus-left-preserves-gt* _ P1 _ _).\n\n\n%theorem plus-left-cancels-gt : \n        forall* {X1:nat} {X2:nat} {Y:nat} {Z:nat} {S1:nat} {S2:nat}\n        forall {P1:plus X1 Y S1} {P2:plus X2 Z S2} \n               {EX:eq X1 X2} {G1:gt S1 S2}\n\texists {G2:gt Y Z}\n        true.\n\n- : plus-left-cancels-gt plus/z plus/z eq/ G G.\n\n- : plus-left-cancels-gt (plus/s X+Y1=Z1) (plus/s X+Y2=Z2) eq/ SZ1>SZ2 Y1>Y2\n    <- succ-preserves-gt-converse SZ1>SZ2 Z1>Z2\n    <- plus-left-cancels-gt X+Y1=Z1 X+Y2=Z2 eq/ Z1>Z2 Y1>Y2.\n\n%worlds () (plus-left-cancels-gt X1+Y1=Z1 X2+Y2=Z2 X1=X2 Z1>Z2  Y1>Y2).\n%total P1 (plus-left-cancels-gt P1 _ _ _ _).\n\n\n\n%theorem plus-left-preserves-gt :\n\tforall* {X1} {X2} {X4}\n      \tforall {G:gt X2 X4}\n\texists {X3} {X5}\n               {O1:plus X1 X2 X3} {O2:plus X1 X4 X5}\n      \t       {G2:gt X3 X5}\n\ttrue.\n\n- : plus-left-preserves-gt X2>X4 X3 X5 X1+X2=A3 X1+X4=X5 X3>X5\n    <- plus-total X1+X2=A3 \n    <- plus-total X1+X4=X5\n    <- plus-left-preserves-gt* X2>X4 X1+X2=A3 X1+X4=X5 X3>X5.\n\n%worlds () (plus-left-preserves-gt X2>X4  X3 X5 X1+X2=A3 X1+X4=X5 X3>X5).\n%total {} (plus-left-preserves-gt _ _ _ _ _ _).\n\n\n%theorem plus-right-preserves-gt* :\n\tforall* {X1} {X2} {X3} {X4} {X5}\n\tforall {G1:gt X1 X2} {O1:plus X1 X3 X4} {O2:plus X2 X3 X5}\n\texists {G2:gt X4 X5}\n\ttrue.\n\n- : plus-right-preserves-gt* X1>X2 X1+X3=X4 X2+X3=X5 X4>X5\n    <- plus-commutative X1+X3=X4 X3+X1=X4\n    <- plus-commutative X2+X3=X5 X3+X2=X5\n    <- plus-left-preserves-gt* X1>X2 X3+X1=X4 X3+X2=X5 X4>X5.\n\n%worlds () (plus-right-preserves-gt* X1>X2 X1+X3=X4 X2+X3=X5  X4>X5).\n%total {} (plus-right-preserves-gt* _ _ _ _).\n\n\n%theorem plus-right-preserves-gt :\n\tforall* {X1} {X2} {X3}\n\tforall {G1:gt X1 X2} \n\texists {X4} {X5} {O1:plus X1 X3 X4} {O2:plus X2 X3 X5} {G2:gt X4 X5}\n\ttrue.\n\n- : plus-right-preserves-gt X1>X2 X4 X5 X1+X3=X4 X2+X3=X5 X4>X5\n    <- plus-total X1+X3=X4 \n    <- plus-total X2+X3=X5\n    <- plus-right-preserves-gt* X1>X2 X1+X3=X4 X2+X3=X5 X4>X5.\n%worlds () (plus-right-preserves-gt X1>X2  X4 X5 X1+X3=X4 X2+X3=X5 X4>X5).\n%total {} (plus-right-preserves-gt _ _ _ _ _ _).\n\n\n%theorem plus-preserves-gt* :\n\tforall* {X1} {X2} {X3} {Y1} {Y2} {Y3}\n\tforall {G1:gt X1 Y1} {G2:gt X2 Y2}\n               {MX:plus X1 X2 X3} {MY:plus Y1 Y2 Y3}\n        exists {G3:gt X3 Y3}\n\ttrue.\n\n- : plus-preserves-gt* X1>Y1 X2>Y2 X1+X2=X3 Y1+Y2=Y3 X3>Y3\n    <- plus-total Y1+X2=X\n    <- plus-right-preserves-gt* X1>Y1 X1+X2=X3 Y1+X2=X X3>X\n    <- plus-left-preserves-gt* X2>Y2 Y1+X2=X Y1+Y2=Y3 X>Y3\n    <- gt-transitive X3>X X>Y3 X3>Y3.\n\n%worlds () (plus-preserves-gt* X1>Y1 X2>Y2 X1+X2=X3 Y1+Y2=Y3  X3>Y3).\n%total {} (plus-preserves-gt* _ _ _ _ _).\n\n\n%theorem plus-preserves-gt :\n\tforall* {X1} {X2} {Y1} {Y2}\n\tforall {G1:gt X1 Y1} {G2:gt X2 Y2}\n\texists {X3} {Y3} {MX:plus X1 X2 X3} {MY:plus Y1 Y2 Y3} {G3:gt X3 Y3}\n\ttrue.\n\n- : plus-preserves-gt X1>Y1 X2>Y2 X3 Y3 X1+X2=X3 Y1+Y2=Y3 X3>Y3\n    <- plus-total X1+X2=X3\n    <- plus-total Y1+Y2=Y3\n    <- plus-preserves-gt* X1>Y1 X2>Y2 X1+X2=X3 Y1+Y2=Y3 X3>Y3.\n\n%worlds () (plus-preserves-gt X1>Y1 X2>Y2  X3 Y3 X1+X2=X3 Y1+Y2=Y3 X3>Y3).\n%total {} (plus-preserves-gt _ _ _ _ _ _ _).\n\n\n%theorem plus-right-cancels-gt :\n\tforall* {X1} {X2} {X3} {Y1} {Y2} {Y3}\n\tforall {OP1:plus X1 X2 X3} {OP2:plus Y1 Y2 Y3} {E2:eq X2 Y2} {G3:gt X3 Y3} \n\texists {G1:gt X1 Y1}\n\ttrue.\n\n- : plus-right-cancels-gt X1+X2=X3 Y1+Y2=Y3 X2=Y2 X3>Y3 X1>Y1\n    <- plus-commutative X1+X2=X3 X2+X1=X3\n    <- plus-commutative Y1+Y2=Y3 Y2+Y1=Y3\n    <- plus-left-cancels-gt X2+X1=X3 Y2+Y1=Y3 X2=Y2 X3>Y3 X1>Y1.\n\n%worlds () (plus-right-cancels-gt X1+X2=X3 Y1+Y2=Y3 X2=Y2 X3>Y3  X1>Y1).\n%total {} (plus-right-cancels-gt _ _ _ _ _).\n\n\n%theorem plus-implies-gt:\n        forall* {M} {N} {O} {M'}\n        forall {P:plus M N O} {E:eq M (s M')}\n        exists {G:gt O N}\n        true.\n\n- : plus-implies-gt X+Y=Z eq/ Z>Y\n    <- succ-implies-gt-zero _ X>0\n    <- plus-right-preserves-gt* X>0 X+Y=Z plus/z Z>Y.\n\n%worlds () (plus-implies-gt X+Y=Z X=sX'  Z>Y).\n%total {} (plus-implies-gt _ _ _).\n\n\n%theorem plus-gt-contradiction :\n\tforall* {M} {N} {O}\n\tforall {P:plus M N O} {G:gt M O}\n\texists {F:void}\n\ttrue.\n\n- : plus-gt-contradiction M+0=O M>O F\n    <- plus-right-identity _ M+0=M\n    <- plus-deterministic M+0=O M+0=M eq/ eq/ O=M\n    <- gt-respects-eq M>O eq/ O=M M>M\n    <- gt-anti-reflexive M>M F.\n\n- : plus-gt-contradiction M+N=O M>O F   % N > 0\n    <- plus-commutative M+N=O N+M=O\n    <- plus-implies-gt N+M=O eq/ O>M\n    <- gt-anti-symmetric M>O O>M F.\n\n%worlds () (plus-gt-contradiction M+N=O M>O  _).\n%total {} (plus-gt-contradiction _ _ _).\n\n\n\n%%% Theorems about times\n\n\n%theorem false-implies-times :\n\tforall* {M} {N} {O}\n\tforall {P:void}\n        exists {Q:times M N O}\n\ttrue.\n\n%worlds () (false-implies-times _ _).\n%total {} (false-implies-times _ _).\n\n\t\t    \n%theorem times-respects-eq: \n\tforall* {M1:nat} {M2:nat} {N1:nat} {N2:nat} {P1:nat} {P2:nat}\n        forall {P:times M1 N1 P1} \n               {E1:eq M1 M2} {E2:eq N1 N2} {E3:eq P1 P2}\n        exists {Q:times M2 N2 P2}\n\ttrue.\n\n- : times-respects-eq M1*N1=P1 eq/ eq/ eq/ M1*N1=P1.\n\n%worlds () (times-respects-eq M1*N1=P1 M1=M2 N1=N2 P1=P2  M2*N2=P2).\n%total {} (times-respects-eq _ _ _ _ _).\n\n\n%theorem times-total* : \n\tforall {N1:nat} {N2:nat}\n        exists {N3:nat} {T:times N1 N2 N3}\n\ttrue.\n\n- : times-total* z N2 z times/z.\n\n- : times-total* (s X) Y Z (times/s X*Y=Z' Z'+Y=Z)\n    <- times-total* X Y Z' X*Y=Z'\n    <- plus-total Z'+Y=Z.\n\n%worlds () (times-total* N1 N2  N3 N1*N2=N3).\n%total (N1) (times-total* N1 _ _ _).\n\n\n%abbrev times-total = times-total* _ _ _.\n\n\n%theorem times-deterministic :\n        forall* {N1:nat} {N1':nat} {N2:nat} {N2':nat} {N3:nat} {N3':nat}\n        forall {P:times N1 N2 N3} {P':times N1' N2' N3'}\n               {E1:eq N1 N1'} {E2:eq N2 N2'}\n        exists {E3:eq N3 N3'}\n        true.\n\n- : times-deterministic (times/z) (times/z) eq/ eq/ eq/.\n\n- : times-deterministic (times/s X*Y=Z1 Z1+Y=Z1') \n                        (times/s X*Y=Z2 Z2+Y=Z2') eq/ eq/ Z1'=Z2'\n    <- times-deterministic X*Y=Z1 X*Y=Z2 eq/ eq/ Z1=Z2\n    <- plus-deterministic Z1+Y=Z1' Z2+Y=Z2' Z1=Z2 eq/ Z1'=Z2'.\n\n%worlds () (times-deterministic X1*Y1=Z1 X2*Y2=Z2 X1=X2 Y1=Y2  Z1=Z2).\n%total P (times-deterministic P _ _ _ _).\n\n\n%theorem times-left-identity : \n\tforall {N:nat}\n\texists {T:times (s z) N N}\n\ttrue.\n\n- : times-left-identity N (times/s (times/z) plus/z).\n\n%worlds () (times-left-identity N  ONE*N=N).\n%total {} (times-left-identity _ _).\n\n\n%theorem times-right-identity : \n\tforall {N:nat}\n\texists {T:times N (s z) N}\n\ttrue.\n\n- : times-right-identity z times/z.\n\n- : times-right-identity (s M) (times/s M*1=M M+1=sM)\n    <- times-right-identity M M*1=M\n    <- plus-right-identity M M+0=M\n    <- plus-right-increase M+0=M M+1=sM.\n\n%worlds () (times-right-identity N  N*1=N).\n%total M (times-right-identity M _).\n\n\n%theorem times-right-zero : forall {N:nat}\n        exists {T:times N z z}\n \ttrue.\n\n- : times-right-zero z times/z.\n\n- : times-right-zero (s M) (times/s M*0=0 plus/z)\n  <- times-right-zero M M*0=0.\n\n%worlds () (times-right-zero N  N*0=0).\n%total M (times-right-zero M _).\n\n\n%theorem times-preserves-positive: \n\tforall {M} {N}\n        exists {P} {T:times (s M) (s N) (s P)}\n        true.\n\n-: {T1:times M (s N) O} {P1:plus O (s N) (s P)} {P2:plus O N P}\n       times-preserves-positive M N P (times/s T1 P1)\n    <- times-total T1\n    <- plus-total P2\n    <- plus-right-increase P2 P1.\n\n%worlds () (times-preserves-positive M N  P SM*SN=SP).\n%total {} (times-preserves-positive _ _ _ _).\n\n\n%theorem times-preserves-positive*:\n        forall* {M} {N} {P} {M'} {N'}\n        forall {T:times M N P} {M+:eq M (s M')} {N+:eq N (s N')}\n        exists {P'} {P+:eq P (s P')}\n        true.\n\n- : times-preserves-positive* M*N=P M=sM' N=sN' P' P=sP'\n    <- times-respects-eq M*N=P M=sM' N=sN' eq/ (times/s M'*sN'=O' O'+sN'=P)\n    <- plus-right-decrease O'+sN'=P P' P=sP' _.\n\n%worlds () (times-preserves-positive* M*N=P M=sM' N=sN'  P' P=sP').\n%total {} (times-preserves-positive* _ _ _ _ _).\n\n\n%theorem times-positive-implies-positive :\n\tforall* {M} {N} {P} {P'}\n\tforall {T:times M N P} {P+:eq P (s P')}\n        exists {M'} {M+:eq M (s M')} {N'}  {N+:eq N (s N')}\n\ttrue.\n\n- : times-positive-implies-positive (times/s M'*N=T plus/z) \n                                    eq/ M' eq/ P' eq/.\n\n- : times-positive-implies-positive (times/s M'*N=sT' (plus/s T'+N=P'))\n                                    eq/ M' eq/ N' N=sN'\n    <- times-positive-implies-positive M'*N=sT' eq/ _ _ N' N=sN'.\n\n%worlds () (times-positive-implies-positive M*N=P P=sP'  M' M=sM' N' N=sN').\n%total T (times-positive-implies-positive T _ _ _ _ _).\n\n\n%theorem times-left-increase :\n\tforall* {M} {N} {O} {X}\n\tforall {T:times M N O} {P:plus O N X}\n        exists {U:times (s M) N X}\n\ttrue.\n\n- : times-left-increase T P (times/s T P).\n\n%worlds () (times-left-increase M*N=O O+N=X  SM*N=X).\n%total {} (times-left-increase _ _ _).\n\n\n%theorem times-right-increase : \n\tforall* {M:nat} {N:nat} {O:nat} {X:nat}\n \tforall {T:times M N O} {P:plus M O X}\n\texists {U:times M (s N) X}\n\ttrue.\n\n- : times-right-increase times/z plus/z times/z.\n\n- : {M*N=O:times M N O} {M+O=Z:plus M O Z}\n    times-right-increase (times/s M*N=O O+N=O1) (plus/s M+O1=Y)\n                         (times/s M*sN=Z Z+sN=sY)\n    <- plus-associative-converse O+N=O1 M+O1=Y Z M+O=Z Z+N=Y\n    <- times-right-increase M*N=O M+O=Z M*sN=Z\n    <- plus-right-increase Z+N=Y Z+sN=sY.\n\n%worlds () (times-right-increase M*N=O M+O=X  M*sN=X).\n%total T (times-right-increase T _ _).\n\n\n%theorem times-left-decrease :\n\tforall* {X} {Y} {Z}\n\tforall {T1:times (s X) Y Z}\n\texists {Z1} {T2:times X Y Z1} {P:plus Z1 Y Z}\n        true.\n\n- : times-left-decrease (times/s T P) _ T P.\n\n%worlds () (times-left-decrease SX*Y=Z Z1 X*Y=Z1 Z1+Y=Z).\n%total {} (times-left-decrease _ _ _ _).\n\n\n%theorem times-right-decrease :\n\tforall* {M} {N} {X}\n\tforall {T:times M (s N) X}\n        exists {O} {U:times M N O} {P:plus M O X}\n\ttrue.\n\n- : times-right-decrease times/z z times/z plus/z.\n\n- : times-right-decrease (times/s M*sN=Y Y+sN=X) O (times/s M*N=P P+N=O) SM+O=X\n    <- times-right-decrease M*sN=Y P M*N=P M+P=Y \n    <- plus-total P+N=O\n    <- plus-right-increase P+N=O P+sN=sO\n    <- plus-associative* M+P=Y Y+sN=X P+sN=sO M+sO=X\n    <- plus-swap-succ-converse M+sO=X SM+O=X.\n\n%worlds () (times-right-decrease M*sN=X  O M*N=O M+O=X).\n%total (T) (times-right-decrease T _ _ _).\n\n\n%theorem times-commutative : \n\tforall* {N1} {N2} {N3}\n        forall {T:times N1 N2 N3}\n \texists {U:times N2 N1 N3}\n\ttrue.\n\n- : times-commutative times/z T\n    <- (times-right-zero N2 T).\n\n- : {T1: times N1' N2 N3'} {P2: plus N3' N2 N3}\n               {T1c: times N2 N1' N3'} {P2c: plus N2 N3' N3}\n\t       {Tc: times N2 (s N1') N3}\n       times-commutative (times/s T1 P2) Tc\n    <- plus-commutative P2 P2c\n    <- times-commutative T1 T1c\n    <- times-right-increase T1c P2c Tc.\n\n%worlds () (times-commutative N1*N2=N3  N2*N1=N3).\n%total T (times-commutative T _).\n\n\n%theorem times-right-distributes-over-plus : \n       forall* {N1} {N2} {N3} {N12} {N123}\n       forall {P1:plus N1 N2 N12} {T1:times N12 N3 N123}\n       exists {N13} {N23} {T13:times N1 N3 N13}\n              {T23:times N2 N3 N23} {P123:plus N13 N23 N123}\n       true.\n\n- : times-right-distributes-over-plus plus/z Y*Z=YZ z YZ times/z Y*Z=YZ plus/z.\n\n- : times-right-distributes-over-plus (plus/s X+Y=XY) (times/s XY*Z=XYZ XYZ+Z=SXYZ)\n                                      SXZ YZ (times/s X*Z=XZ XZ+Z=SXZ) Y*Z=YZ\n                                      SXZ+YZ=SXYZ\n    <- times-right-distributes-over-plus X+Y=XY XY*Z=XYZ \n                                         XZ YZ X*Z=XZ Y*Z=YZ XZ+YZ=XYZ\n    <- plus-commutative XZ+YZ=XYZ YZ+XZ=XYZ\n    <- plus-associative YZ+XZ=XYZ XYZ+Z=SXYZ SXZ XZ+Z=SXZ YZ+SXZ=SXYZ\n    <- plus-commutative YZ+SXZ=SXYZ SXZ+YZ=SXYZ.\n\n%worlds () (times-right-distributes-over-plus X+Y=XY XY*Z=XYZ \n\t                                XZ YZ X*Z=XZ Y*Z=YZ XZ+YZ=XYZ).\n%total (P) (times-right-distributes-over-plus P _ _ _ _ _ _).\n\n\n\n%theorem times-right-distributes-over-plus* :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X6} {X7}\n        forall {A12:plus X1 X2 X3} {M34:times X3 X4 X7}\n               {M14:times X1 X4 X5} {M24:times X2 X4 X6}\n        exists {A56:plus X5 X6 X7}\n\ttrue.\n\n- : times-right-distributes-over-plus* X1+X2=X3 X3*X4=X7 X1*X4=X5 X2*X4=X6 X5+X6=X7\n    <- times-right-distributes-over-plus X1+X2=X3 X3*X4=X7 Y5 Y6\n                                      X1*X4=Y5 X2*X4=Y6 Y5+Y6=X7\n    <- times-deterministic X1*X4=Y5 X1*X4=X5 eq/ eq/ Y5=X5\n    <- times-deterministic X2*X4=Y6 X2*X4=X6 eq/ eq/ Y6=X6\n    <- plus-respects-eq Y5+Y6=X7 Y5=X5 Y6=X6 eq/ X5+X6=X7.\n\n%worlds () (times-right-distributes-over-plus* X1+X2=X3 X3*X4=X7 X1*X4=X5 X2*X4=X6\n                                       X5+X6=X7).\n%total {} (times-right-distributes-over-plus* _ _ _ _ _).\n\n\n%theorem times-left-distributes-over-plus* :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X6} {X7}\n        forall {A12:plus X2 X4 X6} {M34:times X1 X6 X7}\n               {M14:times X1 X2 X3} {M24:times X1 X4 X5}\n        exists {A56:plus X3 X5 X7}\n\ttrue.\n\n- : times-left-distributes-over-plus* X2+X4=X6 X1*X6=X7 X1*X2=X3 X1*X4=X5 X3+X5=X7\n    <- times-commutative X1*X6=X7 X6*X1=X7\n    <- times-commutative X1*X2=X3 X2*X1=X3\n    <- times-commutative X1*X4=X5 X4*X1=X5\n    <- times-right-distributes-over-plus* X2+X4=X6 X6*X1=X7 X2*X1=X3 X4*X1=X5\n                                       X3+X5=X7.\n\n%worlds () (times-left-distributes-over-plus* X2+X4=X6 X1*X6=X7 X1*X2=X3 X1*X4=X5\n                                     X3+X5=X7).\n%total {} (times-left-distributes-over-plus* _ _ _ _ _).\n\n\n%theorem times-left-distributes-over-plus :\n\tforall* {X1} {X2} {X4} {X6} {X7}\n        forall {A12:plus X2 X4 X6} {M34:times X1 X6 X7}\n        exists {X3} {X5} {M14:times X1 X2 X3} {M24:times X1 X4 X5}\n               {A56:plus X3 X5 X7}\n\ttrue.\n\n- : times-left-distributes-over-plus X2+X4=X6 X1*X6=X7 \n                                  X3 X5 X1*X2=X3 X1*X4=X5 X3+X5=X7\n    <- times-total X1*X2=X3\n    <- times-total X1*X4=X5\n    <- times-left-distributes-over-plus* X2+X4=X6 X1*X6=X7 X1*X2=X3 X1*X4=X5\n                                      X3+X5=X7.\n\n%worlds () (times-left-distributes-over-plus X2+X4=X6 X1*X6=X7 \n                                    X3 X5 X1*X2=X3 X1*X4=X5 X3+X5=X7).\n%total {} (times-left-distributes-over-plus _ _ _ _ _ _ _).\n\n\n%theorem times-right-factors-over-plus :\n\tforall* {X1} {X2} {X4} {X5} {X6} {X7}\n        forall {M14:times X1 X4 X5} {M24:times X2 X4 X6} {A56:plus X5 X6 X7}\n        exists {X3} {A12:plus X1 X2 X3} {M34:times X3 X4 X7}\n\ttrue.\n- : times-right-factors-over-plus X1*X4=X5 X2*X4=X6 X5+X6=X7 X3 X1+X2=X3 X3*X4=X7\n    <- plus-total X1+X2=X3\n    <- times-total X3*X4=Y7\n    <- times-right-distributes-over-plus* X1+X2=X3 X3*X4=Y7 X1*X4=X5 X2*X4=X6 \n                                       X5+X6=Y7\n    <- plus-deterministic X5+X6=Y7 X5+X6=X7 eq/ eq/ Y7=X7\n    <- times-respects-eq X3*X4=Y7 eq/ eq/ Y7=X7 X3*X4=X7.\n\n%worlds () (times-right-factors-over-plus X1*X4=X5 X2*X4=X6 X5+X6=X7\n                                 X3 X1+X2=X3 X3*X4=X7 ).\n%total {} (times-right-factors-over-plus _ _ _ _ _ _).\n\n\n%theorem times-right-factors-over-plus* :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X6} {X7}\n        forall {M14:times X1 X4 X5} {M24:times X2 X4 X6} {A56:plus X5 X6 X7}\n               {A12:plus X1 X2 X3} \n        exists {M34:times X3 X4 X7}\n\ttrue.\n\n- : times-right-factors-over-plus* X1*X4=X5 X2*X4=X6 X5+X6=X7 X1+X2=X3 X3*X4=X7\n    <- times-total X3*X4=Y7\n    <- times-right-distributes-over-plus* X1+X2=X3 X3*X4=Y7 X1*X4=X5 X2*X4=X6 \n                                       X5+X6=Y7\n    <- plus-deterministic X5+X6=Y7 X5+X6=X7 eq/ eq/ Y7=X7\n    <- times-respects-eq X3*X4=Y7 eq/ eq/ Y7=X7 X3*X4=X7.\n\n%worlds () (times-right-factors-over-plus* X1*X4=X5 X2*X4=X6 X5+X6=X7 X1+X2=X3\n                                  X3*X4=X7 ).\n%total {} (times-right-factors-over-plus* _ _ _ _ _).\n\n\n%theorem times-left-factors-over-plus :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X7}\n\tforall {M12:times X1 X2 X3} {M14:times X1 X4 X5} {A35:plus X3 X5 X7}\n        exists {X6} {A24:plus X2 X4 X6} {M16:times X1 X6 X7}\n        true.\n\n- : times-left-factors-over-plus X1*X2=X3 X1*X4=X5 X3+X5=X7 X6 X2+X4=X6 X1*X6=X7\n    <- times-commutative X1*X2=X3 X2*X1=X3\n    <- times-commutative X1*X4=X5 X4*X1=X5\n    <- times-right-factors-over-plus X2*X1=X3 X4*X1=X5 X3+X5=X7 X6 X2+X4=X6 X6*X1=X7\n    <- times-commutative X6*X1=X7 X1*X6=X7.\n\n%worlds () (times-left-factors-over-plus X1*X2=X3 X1*X4=X5 X3+X5=X7\n                                X6 X2+X4=X6 X1*X6=X7).\n%total {} (times-left-factors-over-plus _ _ _ _ _ _).\n\n\n%theorem times-left-factors-over-plus* :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X6} {X7}\n\tforall {M12:times X1 X2 X3} {M14:times X1 X4 X5} \n               {A35:plus X3 X5 X7} {A24:plus X2 X4 X6} \n        exists {M16:times X1 X6 X7}\n        true.\n\n- : times-left-factors-over-plus* X1*X2=X3 X1*X4=X5 X3+X5=X7 X2+X4=X6 \n                               X1*X6=X7\n    <- times-total X1*X6=Y7\n    <- times-left-distributes-over-plus* X2+X4=X6 X1*X6=Y7 X1*X2=X3 X1*X4=X5\n                                      X3+X5=Y7\n    <- plus-deterministic X3+X5=Y7 X3+X5=X7 eq/ eq/ Y7=X7\n    <- times-respects-eq X1*X6=Y7 eq/ eq/ Y7=X7 X1*X6=X7.\n\n%worlds () (times-left-factors-over-plus* X1*X2=X3 X1*X4=X5 X3+X5=X7 X2+X4=X6 \n                                X1*X6=X7).\n%total {} (times-left-factors-over-plus* _ _ _ _ _).\n\n\n%theorem times-associative: \n\tforall* {N1} {N2} {N3} {N12} {N123}\n \tforall {T1:times N1 N2 N12} {T12:times N12 N3 N123}\n\texists {N23} {T2:times N2 N3 N23} {T123:times N1 N23 N123}\n\ttrue.\n\n- : {T2:times N2 N3 N23}\n      times-associative times/z times/z N23 T2 times/z\n    <- times-total T2.\n-  : {T1:times N1' N2 N1'2} {P2:plus N1'2 N2 N12}\n                 {T3:times N12 N3 N123} {T4:times N2 N3 N23}\n\t\t {T5:times N1' N23 N1'23} {P6:plus N1'23 N23 N123}\n                 {T7:times N1'2 N3 N1'23}\n       times-associative (times/s T1 P2) T3 N23 T4 (times/s T5 P6)\n    <- times-right-distributes-over-plus P2 T3 N1'23 N23 T7 T4 P6\n    <- times-associative T1 T7 N23' T4' T5'\n    <- times-deterministic T4' T4 eq/ eq/ N23'=N23\n    <- times-respects-eq T5' eq/ N23'=N23 eq/ T5.\n\n%worlds () (times-associative _ _ _ _ _).\n%total T1 (times-associative T1 _ _ _ _).\n\n\n%theorem times-associative* :\n\tforall* {X1} {X2} {X12} {X3} {X23} {X123}\n        forall {OP12:times X1 X2 X12} {OP12-3:times X12 X3 X123} {OP23:times X2 X3 X23}\n        exists {OP1-23:times X1 X23 X123}\n        true.\n\n- : times-associative* X1*X2=X3 X3*X4=X7 X2*X4=X6 X1*X6=X7\n    <- times-associative X1*X2=X3 X3*X4=X7 Y6 X2*X4=Y6 X1*Y6=X7\n    <- times-deterministic X2*X4=Y6 X2*X4=X6 eq/ eq/ Y6=X6\n    <- times-respects-eq X1*Y6=X7 eq/ Y6=X6 eq/ X1*X6=X7.\n\n%worlds () (times-associative* _ _ _ _).\n%total {} (times-associative* _ _ _ _).\n\n\n%theorem times-associative-converse :\n\tforall* {X1} {X2} {X4} {X6} {X7}\n\tforall {OP24:times X2 X4 X6} {OP16:times X1 X6 X7}\n        exists {X3} {OP12:times X1 X2 X3} {OP34:times X3 X4 X7}\n        true.\n\n- : times-associative-converse X2*X4=X6 X1*X6=X7 _ X1*X2=X3 X3*X4=X7\n    <- times-commutative X2*X4=X6 X4*X2=X6\n    <- times-commutative X1*X6=X7 X6*X1=X7\n    <- times-associative X4*X2=X6 X6*X1=X7 _ X2*X1=X3 X4*X3=X7\n    <- times-commutative X2*X1=X3 X1*X2=X3\n    <- times-commutative X4*X3=X7 X3*X4=X7.\n\n%worlds () (times-associative-converse X2*X4=X6 X1*X6=X7 X3 X1*X2=X3 X3*X4=X7).\n%total {} (times-associative-converse _ _ _ _ _).\n\n\n%theorem times-associative-converse* :\n\tforall* {X1} {X2} {X3} {X4} {X6} {X7}\n\tforall {OP24:times X2 X4 X6} {OP16:times X1 X6 X7} {OP12:times X1 X2 X3} \n\texists {OP34:times X3 X4 X7}\n        true.\n\n- : times-associative-converse* X2*X4=X6 X1*X6=X7 X1*X2=X3 X3*X4=X7\n    <- times-associative-converse X2*X4=X6 X1*X6=X7 X3P X1*X2=X3P X3P*X4=X7\n    <- times-deterministic X1*X2=X3P X1*X2=X3 eq/ eq/ X3P=X3\n    <- times-respects-eq X3P*X4=X7 X3P=X3 eq/ eq/ X3*X4=X7.\n\n%worlds () (times-associative-converse* X2*X4=X6 X1*X6=X7 X1*X2=X3  X3*X4=X7).\n%total {} (times-associative-converse* _ _ _ _).\n\n\n%theorem times-assoc-commutative* :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X7}\n\tforall {OP1:times X1 X2 X3} {OP2:times X3 X4 X7}\n               {OP3:times X1 X4 X5} \n        exists {OP4:times X5 X2 X7}\n\ttrue.\n\n- : times-assoc-commutative* X1*X2=X3 X3*X4=X7 X1*X4=X5 X5*X2=X7\n    <- times-associative X1*X2=X3 X3*X4=X7 X6 X2*X4=X6 X1*X6=X7\n    <- times-commutative X2*X4=X6 X4*X2=X6\n    <- times-associative-converse* X4*X2=X6 X1*X6=X7 X1*X4=X5 X5*X2=X7.\n\n%worlds () (times-assoc-commutative* X1*X2=X3 X3*X4=X7 X1*X4=X5  X5*X2=X7).\n%total {} (times-assoc-commutative* _ _ _ _).\n\n\n%theorem times-assoc-commutative :\n\tforall* {X1} {X2} {X3} {X4} {X7}\n\tforall {OP1:times X1 X2 X3} {OP2:times X3 X4 X7}\n        exists {X5} {OP3:times X1 X4 X5} {OP4:times X5 X2 X7}\n\ttrue.\n\n- : times-assoc-commutative X1*X2=X3 X3*X4=X7 X5 X1*X4=X5 X5*X2=X7\n    <- times-associative X1*X2=X3 X3*X4=X7 X6 X2*X4=X6 X1*X6=X7\n    <- times-commutative X2*X4=X6 X4*X2=X6\n    <- times-associative-converse X4*X2=X6 X1*X6=X7 X5 X1*X4=X5 X5*X2=X7.\n\n%worlds () (times-assoc-commutative X1*X2=X3 X3*X4=X7  X5 X1*X4=X5 X5*X2=X7).\n%total {} (times-assoc-commutative _ _ _ _ _).\n\n\n%theorem times-double-associative* :\n\tforall* {A} {B} {C} {D} {A+B} {C+D} {A+C} {B+D} {X}\n\tforall {AB:times A B A+B} {CD:times C D C+D} {ABCD:times A+B C+D X}\n\t       {AC:times A C A+C} {BD:times B D B+D} \n        exists {ACBD:times A+C B+D X}\n\ttrue.\n\n- : times-double-associative* X1*X2=X3 X4*X8=XC X3*XC=XF X1*X4=X5 X2*X8=XA X5*XA=XF\n    <- times-associative X1*X2=X3 X3*XC=XF XE X2*XC=XE X1*XE=XF\n    <- times-commutative X4*X8=XC X8*X4=XC\n    <- times-associative-converse* X8*X4=XC X2*XC=XE X2*X8=XA XA*X4=XE\n    <- times-commutative XA*X4=XE X4*XA=XE\n    <- times-associative-converse* X4*XA=XE X1*XE=XF X1*X4=X5 X5*XA=XF.\n\n%worlds () (times-double-associative* X1*X2=X3 X4*X8=XC X3*XC=XF X1*X4=X5 X2*X8=XA\n                             X5*XA=XF).\n%total {} (times-double-associative* _ _ _ _ _ _).\n\n\n%theorem times-double-associative :\n\tforall* {A} {B} {C} {D} {A+B} {C+D} {X}\n\tforall {AB:times A B A+B} {CD:times C D C+D} {ABCD:times A+B C+D X}\n\texists {A+C} {B+D} {AC:times A C A+C} {BD:times B D B+D} \n               {ACBD:times A+C B+D X}\n\ttrue.\n\n- : times-double-associative X1*X2=X3 X4*X8=XC X3*XC=XF X5 XA X1*X4=X5 X2*X8=XA X5*XA=XF\n    <- times-associative X1*X2=X3 X3*XC=XF XE X2*XC=XE X1*XE=XF\n    <- times-commutative X4*X8=XC X8*X4=XC\n    <- times-associative-converse X8*X4=XC X2*XC=XE XA X2*X8=XA XA*X4=XE\n    <- times-commutative XA*X4=XE X4*XA=XE\n    <- times-associative-converse X4*XA=XE X1*XE=XF X5 X1*X4=X5 X5*XA=XF.\n\n%worlds () (times-double-associative _ _ _ _ _ _ _ _).\n%total { } (times-double-associative _ _ _ _ _ _ _ _).\n\n%theorem times-right-cancels: \n       forall* {X1} {Y1} {Z1} {X2} {Y2} {Z2} \n       forall {T1:times X1 (s Y1) Z1} {T2:times X2 (s Y2) Z2} \n              {EY:eq Y1 Y2} {EZ:eq Z1 Z2} \n       exists {EX:eq X1 X2} \n       true.\n\n- : times-right-cancels times/z times/z EY eq/ eq/.\n\n- :              {T1:times X1 (s Y1) Z1'} {P1: plus Z1' (s Y1) Z1}\n                 {T2:times X2 (s Y2) Z2'} {P2: plus Z2' (s Y2) Z2}\n                 {EY: eq Y1 Y2} {EZ: eq Z1 Z2} {EX: eq X1 X2}\n       times-right-cancels (times/s T1 P1) (times/s T2 P2) EY EZ EX'\n    <- succ-deterministic EY EY'\n    <- plus-right-cancels P1 P2 EY' EZ EZ'\n    <- times-right-cancels T1 T2 EY EZ' EX\n    <- succ-deterministic EX EX'.\n\n%worlds () (times-right-cancels X1*sY1=Z1 X2*sY2=Z2 Y1=Y2 Z1=Z2  X1=X2).\n%total T1 (times-right-cancels T1 _ _ _ _).\n\n\n%theorem times-right-cancels*: \n       forall* {X1} {Y} {Y-1} {Z1} {X2} {Z2} \n       forall {T1:times X1 Y Z1} {T2:times X2 Y Z2} \n              {EY:eq Y (s Y-1)} {EZ:eq Z1 Z2} \n       exists {EX:eq X1 X2} \n       true.\n\n- : times-right-cancels* X1*Y=Z1 X2*Y=Z2 Y+ Z1=Z2 X1=X2\n    <- times-respects-eq X1*Y=Z1 eq/ Y+ eq/ X1*Y+=Z1\n    <- times-respects-eq X2*Y=Z2 eq/ Y+ eq/ X2*Y+=Z2\n    <- times-right-cancels X1*Y+=Z1 X2*Y+=Z2 eq/ Z1=Z2 X1=X2.\n\n%worlds () (times-right-cancels* X1*Y=Z1 X2*Y=Z2 Y+ Z1=Z2  X1=X2).\n%total {} (times-right-cancels* _ _ _ _ _).\n\n\n%theorem times-right-cancels**:\n\tforall* {X1} {Y1} {Z} {X2} {Y2} {Z-}\n        forall {T1:times X1 Y1 Z} {T2:times X2 Y2 Z}\n               {EY:eq Y1 Y2} {EZ:eq Z (s Z-)}\n\texists {EX:eq X1 X2}\n\ttrue.\n\n- : times-right-cancels** X1*0=sZ X2*0=sZ eq/ eq/ X1=X2\n    <- times-right-zero _ X1*0=0\n    <- times-deterministic X1*0=0 X1*0=sZ eq/ eq/ ZERO=sZ\n    <- succ-implies-gt ZERO=sZ ZERO>sZ\n    <- gt-contradiction ZERO>sZ F\n    <- false-implies-eq F X1=X2.\n\n- : times-right-cancels** X1*Y1-=sZ X2*Y1-=sZ eq/ eq/ X1=X2\n    <- times-right-cancels X1*Y1-=sZ X2*Y1-=sZ eq/ eq/ X1=X2.\n\n%worlds () (times-right-cancels** X1*Y1=Z X2*Y2=Z Y1=Y2 Z+  X1=X2).\n%total {} (times-right-cancels** _ _ _ _ _).\n\n\n%theorem times-left-cancels : \n        forall* {X1} {Y1} {Z1} {X2} {Y2} {Z2}\n        forall {T1:times (s X1) Y1 Z1} {T2:times (s X2) Y2 Z2} \n               {E1:eq X1 X2} {E2:eq Z1 Z2} \n        exists {F:eq Y1 Y2} \n        true.\n\n- : times-left-cancels SX1*Y1=Z1 SX2*Y2=Z2 X1=X2 Z1=Z2 Y1=Y2\n    <- times-commutative SX1*Y1=Z1 Y1*sX1=Z1\n    <- times-commutative SX2*Y2=Z2 Y2*sX2=Z2\n    <- times-right-cancels Y1*sX1=Z1 Y2*sX2=Z2 X1=X2 Z1=Z2 Y1=Y2.\n\n%worlds () (times-left-cancels SX1*Y1=Z1 SX2*Y2=Z2 X1=X2 Z1=Z2  Y1=Y2).\n%total {} (times-left-cancels _ _ _ _ _).\n\n\n%theorem times-left-cancels* : \n        forall* {X} {Y1} {Z1} {X-} {Y2} {Z2}\n        forall {T1:times X Y1 Z1} {T2:times X Y2 Z2} \n               {E1:eq X (s X-)} {E2:eq Z1 Z2} \n        exists {F:eq Y1 Y2} \n        true.\n\n- : times-left-cancels* X*Y1=Z1 X*Y2=Z2 X+ Z1=Z2 Y1=Y2\n    <- times-commutative X*Y1=Z1 Y1*X=Z1\n    <- times-commutative X*Y2=Z2 Y2*X=Z2\n    <- times-right-cancels* Y1*X=Z1 Y2*X=Z2 X+ Z1=Z2 Y1=Y2.\n\n%worlds () (times-left-cancels* X*Y1=Z1 X*Y2=Z2 X+ Z1=Z2  Y1=Y2).\n%total {} (times-left-cancels* _ _ _ _ _).\n\n\n%theorem times-left-preserves-gt : \n        forall* {M} {N1} {N2} {P1} {P2}\n        forall {GN:gt N1 N2} \n               {T1:times (s M) N1 P1} {T2:times (s M) N2 P2}\n        exists {GP:gt P1 P2}\n        true.\n\n- : times-left-preserves-gt N1>N2 (times/s times/z plus/z)\n                                  (times/s times/z plus/z) N1>N2.\n\n- : times-left-preserves-gt N1>N2 (times/s (T1:times (s M) N1 X1) X1+N1=O1)\n                                  (times/s (T2:times (s M) N2 X2) X2+N2=O2)\n                            O1>O2\n    <- times-left-preserves-gt N1>N2 T1 T2 X1>X2\n    <- plus-preserves-gt* X1>X2 N1>N2 X1+N1=O1 X2+N2=O2 O1>O2.\n\n%worlds () (times-left-preserves-gt N1>N2 SM*N1=P1 SM*N2=P2  P1>P2).\n%total T1 (times-left-preserves-gt _ T1 _ _).\n\n\n%theorem times-left-preserves-gt* :\n        forall* {M} {M-} {N1} {N2} {P1} {P2}\n        forall {GN:gt N1 N2} \n               {T1:times M N1 P1} {T2:times M N2 P2} {M+:eq M (s M-)}\n        exists {GP:gt P1 P2}\n        true.\n\n- : times-left-preserves-gt* N1>N2 M*N1=P1 M*N2=P2 M+ P1>P2\n    <- times-respects-eq M*N1=P1 M+ eq/ eq/ SM-*N1=P1\n    <- times-respects-eq M*N2=P2 M+ eq/ eq/ SM-*N2=P2\n    <- times-left-preserves-gt N1>N2 SM-*N1=P1 SM-*N2=P2 P1>P2.\n\n%worlds () (times-left-preserves-gt* N1>N2 M*N1=P1 M*N2=P2 M+  P1>P2).\n%total {} (times-left-preserves-gt* _ _ _ _ _).\n\n\n%theorem times-right-preserves-gt :\n        forall* {M1} {M2} {N} {P1} {P2}\n        forall {G1:gt M1 M2} {T1:times M1 (s N) P1} {T2:times M2 (s N) P2}\n        exists {G2:gt P1 P2}\n        true.\n\n- : times-right-preserves-gt M1>M2 M1*sN=P1 M2*sN=P2 P1>P2\n    <- times-commutative M1*sN=P1 SN*M1=P1\n    <- times-commutative M2*sN=P2 SN*M2=P2\n    <- times-left-preserves-gt M1>M2 SN*M1=P1 SN*M2=P2 P1>P2.\n\n%worlds () (times-right-preserves-gt M1>M2 M1*sN=P1 M2*sN=P2  P1>P2).\n%total {} (times-right-preserves-gt _ _ _ _).\n\n\n%theorem times-right-preserves-gt* :\n        forall* {M1} {M2} {N} {N-1} {P1} {P2}\n        forall {G1:gt M1 M2} {T1:times M1 N P1} {T2:times M2 N P2}\n               {N+:eq N (s N-1)}\n        exists {G2:gt P1 P2}\n        true.\n\n- : times-right-preserves-gt* M1>M2 M1*N=P1 M2*N=P2 N=sN-1 P1>P2\n    <- times-respects-eq M1*N=P1 eq/ N=sN-1 eq/ M1*N+=P1\n    <- times-respects-eq M2*N=P2 eq/ N=sN-1 eq/ M2*N+=P2\n    <- times-right-preserves-gt M1>M2 M1*N+=P1 M2*N+=P2 P1>P2.\n\n%worlds () (times-right-preserves-gt* M1>M2 M1*N=P1 M2*N=P2 N=sN-1  P1>P2).\n%total {} (times-right-preserves-gt* _ _ _ _ _).\n\n\n%theorem times-preserves-gt : \n        forall* {M1} {N1} {P1} {M2} {N2} {P2} \n        forall {GM:gt M1 M2} {GN:gt N1 N2}\n               {T1:times M1 N1 P1} {T2:times M2 N2 P2}\n        exists {GP:gt P1 P2}\n        true.\n\n- : {0=0': eq z _}\n    times-preserves-gt (M1>M2:gt M1 M2) (N1>0:gt N1 z) (M1*N1=P1:times M1 N1 P1)\n                       M2*0=0' P1>0'\n    <- gt-implies-positive M1>M2 M1' M1=sM1'\n    <- times-respects-eq M1*N1=P1 M1=sM1' eq/ eq/ SM1'*N1=P1\n    <- times-right-zero M2 M2*0=0\n    <- times-deterministic M2*0=0 M2*0=0' eq/ eq/ 0=0'\n    <- times-right-zero (s M1') SM1'*0=0\n    <- times-left-preserves-gt N1>0 SM1'*N1=P1 SM1'*0=0 P1>0\n    <- gt-respects-eq P1>0 eq/ 0=0' P1>0'.\n\n- : times-preserves-gt M1>M2 (N1>sN2':gt N1 (s N2')) M1*N1=P1 M2*sN2'=P2 P1>P2\n    <- gt-implies-positive M1>M2 M1' M1=sM1'\n    <- times-respects-eq M1*N1=P1 M1=sM1' eq/ eq/ SM1'*N1=P1\n    <- times-total (SM1'*sN2'=PX:times (s M1') (s N2') _)\n    <- times-left-preserves-gt N1>sN2' SM1'*N1=P1 SM1'*sN2'=PX P1>PX\n    <- eq-symmetric M1=sM1' SM1'=M1\n    <- times-respects-eq SM1'*sN2'=PX SM1'=M1 eq/ eq/ M1*sN2'=PX\n    <- times-right-preserves-gt M1>M2 M1*sN2'=PX M2*sN2'=P2 PX>P2\n    <- gt-transitive P1>PX PX>P2 P1>P2.\n\n%worlds () (times-preserves-gt M1>M2 N1>N2 M1*N1=P1 M2*N2=P2  P1>P2).\n%total {} (times-preserves-gt _ _ _ _ _).\n\n\n%theorem times-right-cancels-gt : \n        forall* {X1:nat} {X2:nat} {Y1:nat} {Y2:nat} {Z1:nat} {Z2:nat}\n        forall {P1:times X1 Y1 Z1} {P2:times X2 Y2 Z2}\n               {EY:eq Y1 Y2} {G1:gt Z1 Z2}\n\texists {G2:gt X1 X2}\n        true.\n\n- : times-right-cancels-gt (times/s X1*Y=N1 N1+Y=Z1) times/z eq/ Z1>0 SX1>0\n    <- succ-implies-gt-zero _ SX1>0.\n\n- : times-right-cancels-gt (times/s X1*Y=N1 N1+Y=Z1) (times/s X2*Y=N2 N2+Y=Z2)\n                           eq/ Z1>Z2 SX1>SX2\n    <- plus-right-cancels-gt N1+Y=Z1 N2+Y=Z2 eq/ Z1>Z2 N1>N2\n    <- times-right-cancels-gt X1*Y=N1 X2*Y=N2 eq/ N1>N2 X1>X2\n    <- succ-preserves-gt X1>X2 SX1>SX2.\n\n%worlds () (times-right-cancels-gt X1*Y1=Z1 X2*Y2=Z2 Y1=Y2 Z1>Z2  X1>X2).\n%total [P1 P2] (times-right-cancels-gt P1 P2 _ _ _).\n\n\n%theorem times-left-cancels-gt : \n        forall* {X1:nat} {X2:nat} {Y1:nat} {Y2:nat} {Z1:nat} {Z2:nat}\n        forall {P1:times X1 Y1 Z1} {P2:times X2 Y2 Z2} \n               {EX:eq X1 X2} {G1:gt Z1 Z2}\n\texists {G2:gt Y1 Y2}\n        true.\n\n- : times-left-cancels-gt X1*Y1=Z1 X2*Y2=Z2 X1=X2 Z1>Z2 Y1>Y2\n    <- times-commutative X1*Y1=Z1 Y1*X1=Z1\n    <- times-commutative X2*Y2=Z2 Y2*X2=Z2\n    <- times-right-cancels-gt Y1*X1=Z1 Y2*X2=Z2 X1=X2 Z1>Z2 Y1>Y2.\n\n%worlds () (times-left-cancels-gt X1*Y1=Z1 X2*Y2=Z2 X1=X2 Z1>Z2  Y1>Y2).\n%total P1 (times-left-cancels-gt P1 _ _ _ _).\n\n\n\n\n\n%%%%% nat-inv.elf\n%%%%% Minus for natural numbers\n%%%%% This file is part of the nat.elf signature\n\n\n\n\n\n%%%% Definitions\n\n%abbrev minus = [X1] [X2] [X3] plus X3 X2 X1.\n\n\n\n\n%%%% Theorems\n\n\n%%% Theorems about minus\n\n\n%abbrev false-implies-minus = false-implies-plus.\n\n\n%theorem minus-respects-eq :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X6}\n\tforall {D:minus X1 X2 X3} {E1:eq X1 X4} {E2:eq X2 X5} {E3:eq X3 X6}\n        exists {DP:minus X4 X5 X6}\n        true.\n\n- : minus-respects-eq S eq/ eq/ eq/ S.\n\n%worlds () (minus-respects-eq _ _ _ _ _).\n%total {} (minus-respects-eq _ _ _ _ _).\n\n\n%theorem minus-deterministic :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X6}\n\tforall {S:minus X1 X2 X3} {SP:minus X4 X5 X6}\n               {E1:eq X1 X4} {E2:eq X2 X5}\n\texists {E3:eq X3 X6}\n\ttrue.\n\n- : minus-deterministic X3+X2=X1 X6+X5=X4 X1=X4 X2=X5 X3=X6\n    <- plus-right-cancels X3+X2=X1 X6+X5=X4 X2=X5 X1=X4 X3=X6.\n\n%worlds () (minus-deterministic X1-X2=X3 X4-X5=X6 X1=X4 X2=X5 X3=X6).\n%total {} (minus-deterministic _ _ _ _ _).\n\n\n%theorem plus-associates-with-minus* :\n\tforall* {X1} {X2} {X3} {X4} {X6} {X7}\n\tforall {OP1:plus X1 X2 X3} {IOP1:minus X3 X4 X7} {IOP2:minus X2 X4 X6} \n\texists {OP2:plus X1 X6 X7}\n        true.\n\n- : plus-associates-with-minus* X1+X2=X3 X7+X4=X3 X6+X4=X2 X1+X6=X7\n    <- plus-associative-converse X6+X4=X2 X1+X2=X3 X7P X1+X6=X7P X7P+X4=X3\n    <- plus-right-cancels X7P+X4=X3 X7+X4=X3 eq/ eq/ X7P=X7\n    <- plus-respects-eq X1+X6=X7P eq/ eq/ X7P=X7 X1+X6=X7.\n\n%worlds () (plus-associates-with-minus* X1+X2=X3 X3-X4=X7 X2-X4=X6 \n                               X1+X6=X7).\n%total {} (plus-associates-with-minus* _ _ _ _).\n\n\n%theorem plus-associates-with-minus-converse* :\n\tforall* {X1} {X2} {X3} {X4} {X6} {X7}\n        forall {IOP2:minus X2 X4 X6} {OP2:plus X1 X6 X7} {OP1:plus X1 X2 X3} \n\texists {IOP1:minus X3 X4 X7} \n        true.\n\n- : plus-associates-with-minus-converse* X6+X4=X2 X1+X6=X7 X1+X2=X3 X7+X4=X3\n    <- plus-associative-converse* X6+X4=X2 X1+X2=X3 X1+X6=X7 X7+X4=X3.\n\n%worlds () (plus-associates-with-minus-converse* X2-X4=X6 X1+X6=X7 X1+X2=X3 \n                                        X3-X4=X7).\n%total {} (plus-associates-with-minus-converse* _ _ _ _).\n\n\n%theorem plus-associates-with-minus-converse :\n\tforall* {X1} {X2} {X4} {X6} {X7}\n        forall {IOP2:minus X2 X4 X6} {OP2:plus X1 X6 X7} \n        exists {X3} {OP1:plus X1 X2 X3} {IOP1:minus X3 X4 X7} \n        true.\n\n- : plus-associates-with-minus-converse X6+X4=X2 X1+X6=X7 X3 X1+X2=X3 X7+X4=X3\n    <- plus-total X1+X2=X3\n    <- plus-associates-with-minus-converse* X6+X4=X2 X1+X6=X7 X1+X2=X3 X7+X4=X3.\n%worlds () (plus-associates-with-minus-converse X2-X4=X6 X1+X6=X7 \n                                       X3 X1+X2=X3 X3-X4=X7).\n%total {} (plus-associates-with-minus-converse _ _ _ _ _).\n\n\n%theorem minus-associates-from-plus* :\n\tforall* {X1} {X2} {X3} {X4} {X6} {X7}\n\tforall {IOP1:minus X1 X2 X3} {OP1:plus X3 X4 X7} {IOP2:minus X2 X4 X6}\n        exists {IOP3:minus X1 X6 X7}\n        true.\n\n- : minus-associates-from-plus* X3+X2=X1 X3+X4=X7 X6+X4=X2 X7+X6=X1\n    <- plus-commutative X6+X4=X2 X4+X6=X2\n    <- plus-associative-converse* X4+X6=X2 X3+X2=X1 X3+X4=X7 X7+X6=X1.\n\n%worlds () (minus-associates-from-plus* X1-X2=X3 X3+X4=X7 X2-X4=X6  X1-X6=X7).\n%total {} (minus-associates-from-plus* _ _ _ _).\n\n\n%theorem minus-associates-from-plus-converse* :\n\tforall* {X1} {X2} {X3} {X4} {X6} {X7} \n\tforall {IOP2:minus X2 X4 X6} {IOP3:minus X1 X6 X7} {IOP1:minus X1 X2 X3} \n        exists {OP1:plus X3 X4 X7} \n        true.\n\n- : minus-associates-from-plus-converse* X6+X4=X2 X7+X6=X1 X3+X2=X1 X3+X4=X7\n    <- plus-commutative X6+X4=X2 X4+X6=X2\n    <- plus-associative-converse X4+X6=X2 X3+X2=X1 X7P X3+X4=X7P X7P+X6=X1\n    <- plus-right-cancels X7P+X6=X1 X7+X6=X1 eq/ eq/ X7P=X7\n    <- plus-respects-eq X3+X4=X7P eq/ eq/ X7P=X7 X3+X4=X7.\n\n%worlds () (minus-associates-from-plus-converse* X2-X4=X6 X1-X6=X7 X1-X2=X3 \n                                        X3+X4=X7).\n%total {} (minus-associates-from-plus-converse* _ _ _ _).\n\n\n%theorem minus-associates-to-plus* :\n\tforall* {X1} {X2} {X3} {X4} {X6} {X7}\n\tforall {IOP1:minus X1 X2 X3} {IOP2:minus X3 X4 X7} {OP1:plus X2 X4 X6} \n        exists {IOP3:minus X1 X6 X7}\n        true.\n\n- : minus-associates-to-plus* X3+X2=X1 X7+X4=X3 X2+X4=X6 X7+X6=X1\n    <- plus-commutative X2+X4=X6 X4+X2=X6 \n    <- plus-associative* X7+X4=X3 X3+X2=X1 X4+X2=X6 X7+X6=X1.\n\n%worlds () (minus-associates-to-plus* X1-X2=X3 X3-X4=X7 X2+X4=X6  X1-X6=X7).\n%total {} (minus-associates-to-plus* _ _ _ _).\n\n\n%theorem minus-associates-to-plus :\n\tforall* {X1} {X2} {X3} {X4} {X7}\n\tforall {IOP1:minus X1 X2 X3} {IOP2:minus X3 X4 X7}\n        exists {X6} {OP1:plus X2 X4 X6} {IOP3:minus X1 X6 X7}\n        true.\n\n- : minus-associates-to-plus X3+X2=X1 X7+X4=X3 X6 X2+X4=X6 X7+X6=X1\n    <- plus-associative X7+X4=X3 X3+X2=X1 X6 X4+X2=X6 X7+X6=X1\n    <- plus-commutative X4+X2=X6 X2+X4=X6.\n\n%worlds () (minus-associates-to-plus X1-X2=X3 X3-X4=X7 X6 X2+X4=X6 X1-X6=X7).\n%total {} (minus-associates-to-plus _ _ _ _ _).\n\n\n%theorem minus-associates-to-plus-converse* :\n\tforall* {X1} {X2} {X3} {X4} {X6} {X7}\n        forall {OP1:plus X2 X4 X6} {IOP3:minus X1 X6 X7} {IOP1:minus X1 X2 X3}\n\texists {IOP2:minus X3 X4 X7} \n        true.\n\n- : minus-associates-to-plus-converse* X2+X4=X6 X7+X6=X1 X3+X2=X1 X7+X4=X3\n    <- plus-commutative X2+X4=X6 X4+X2=X6\n    <- plus-associative-converse X4+X2=X6 X7+X6=X1 X3P X7+X4=X3P X3P+X2=X1\n    <- plus-right-cancels X3P+X2=X1 X3+X2=X1 eq/ eq/ X3P=X3\n    <- plus-respects-eq X7+X4=X3P eq/ eq/ X3P=X3 X7+X4=X3.\n\n%worlds () (minus-associates-to-plus-converse* X2+X4=X6 X1-X6=X7 X1-X2=X3 \n                                      X3-X4=X7).\n%total {} (minus-associates-to-plus-converse* _ _ _ _).\n\n\n%theorem minus-associates-to-plus-converse :\n\tforall* {X1} {X2} {X4} {X6} {X7}\n        forall {OP1:plus X2 X4 X6} {IOP3:minus X1 X6 X7} \n        exists {X3} {IOP1:minus X1 X2 X3} {IOP2:minus X3 X4 X7} \n        true.\n\n- : minus-associates-to-plus-converse X2+X4=X6 X7+X6=X1 X3 X3+X2=X1 X7+X4=X3\n    <- plus-commutative X2+X4=X6 X4+X2=X6\n    <- plus-associative-converse X4+X2=X6 X7+X6=X1 X3 X7+X4=X3 X3+X2=X1.\n\n%worlds () (minus-associates-to-plus-converse X2+X4=X6 X1-X6=X7 \n                                     X3 X1-X2=X3 X3-X4=X7).\n%total {} (minus-associates-to-plus-converse _ _ _ _ _).\n\n%theorem minus-is-zero-implies-eq :\n\tforall* {N1} {N2} {N3}\n\tforall {P:minus N1 N2 N3} {E3:eq N3 z}\n        exists {E1:eq N1 N2}\n\ttrue.\n\n- : minus-is-zero-implies-eq plus/z eq/ eq/.\n\n%worlds () (minus-is-zero-implies-eq X-Y=Z Z=0  X=Y).\n%total {} (minus-is-zero-implies-eq _ _ _).\n\n\n%abbrev minus-implies-gt = plus-implies-gt.\n\n\n%theorem minus-left-cancels : \n\tforall* {X1} {X2} {X3} {X4} {X5} {X6}\n\tforall {IOP1:minus X1 X2 X3} {IOP2:minus X4 X5 X6}\n               {E1:eq X1 X4} {E3:eq X3 X6}\n\texists {E2:eq X2 X5}\n\ttrue.\n\n- : minus-left-cancels X3+X2=X1 X6+X5=X4 X1=X4 X3=X6 X2=X5\n   <- plus-left-cancels X3+X2=X1 X6+X5=X4 X3=X6 X1=X4 X2=X5.\n\n%worlds () (minus-left-cancels X1-X2=X3 X4-X5=X6 X1=X4 X3=X6 X2=X5).\n%total {} (minus-left-cancels _ _ _ _ _).\n\n\n%theorem minus-right-cancels : \n\tforall* {X1} {X2} {X3} {X4} {X5} {X6}\n\tforall {IOP1:minus X1 X2 X3} {IOP2:minus X4 X5 X6}\n               {E2:eq X2 X5} {E3:eq X3 X6}\n\texists {E1:eq X1 X4}\n\ttrue.\n\n- : minus-right-cancels X3+X2=X1 X6+X5=X4 X2=X5 X3=X6 X1=X4\n    <- plus-deterministic  X3+X2=X1 X6+X5=X4 X3=X6 X2=X5 X1=X4.\n\n%worlds () (minus-right-cancels X1-X2=X3 X4-X5=X6 X2=X5 X3=X6 X1=X4).\n%total {} (minus-right-cancels _ _ _ _ _).\n\n\n\n%theorem minus-left-inverts-gt* :\n\tforall* {X1} {X2} {X3} {X4} {X5}\n        forall {G:gt X2 X4}\n               {IOP1:minus X1 X2 X3} {IOP2:minus X1 X4 X5}\n        exists {GP:gt X5 X3}\n\ttrue.\n\n- : minus-left-inverts-gt* X2>X4 X3+X2=X1 X5+X4=X1 X5>X3\n    <- plus-total X3+X4=X7\n    <- plus-left-preserves-gt* X2>X4 X3+X2=X1 X3+X4=X7 X1>X7\n    <- plus-right-cancels-gt X5+X4=X1 X3+X4=X7 eq/ X1>X7 X5>X3.\n\n%worlds () (minus-left-inverts-gt* X2>X4 X1-X2=X3 X1-X4=X5  X5>X3).\n%total {} (minus-left-inverts-gt* _ _ _ _).\n\n\n%theorem minus-right-preserves-gt* :\n\tforall* {X1} {X2} {X3} {X4} {X5}\n        forall {G:gt X1 X2}\n               {IOP1:minus X1 X3 X4} {IOP2:minus X2 X3 X5}\n        exists {GP:gt X4 X5}\n\ttrue.\n\n- : minus-right-preserves-gt*  X1>X2 X4+X3=X1 X5+X3=X2 X4>X5\n    <- plus-right-cancels-gt X4+X3=X1 X5+X3=X2 eq/ X1>X2 X4>X5.\n\n%worlds () (minus-right-preserves-gt* X1>X2 X1-X3=X4 X2-X3=X5  X4>X5).\n%total {} (minus-right-preserves-gt* _ _ _ _).\n\n\n%theorem minus-left-cancels-inverts-gt :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X6}\n\tforall {IOP1:minus X1 X2 X3} {IOP2:minus X4 X5 X6}\n               {E:eq X1 X4} {G:gt X3 X6}\n        exists {GP:gt X5 X2}\n\ttrue.\n\n- : minus-left-cancels-inverts-gt X3+X2=X1 X6+X5=X4 X1=X4 X3>X6 X5>X2\n    <- plus-total X6+X2=X7\n    <- plus-right-preserves-gt* X3>X6 X3+X2=X1 X6+X2=X7 X1>X7\n    <- eq-symmetric X1=X4 X4=X1\n    <- plus-respects-eq X6+X5=X4 eq/ eq/ X4=X1 X6+X5=X1\n    <- plus-left-cancels-gt X6+X5=X1 X6+X2=X7 eq/ X1>X7 X5>X2.\n\n%worlds () (minus-left-cancels-inverts-gt X1-X2=X3 X4-X5=X6 X1=X4 X3>X6 \n                                   X5>X2).\n%total {} (minus-left-cancels-inverts-gt _ _ _ _ _).\n\n\n%theorem minus-right-cancels-gt :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X6}\n\tforall {IOP1:minus X1 X2 X3} {IOP2:minus X4 X5 X6}\n               {E2:eq X2 X5} {G3:gt X3 X6}\n        exists {G1:gt X1 X4}\n\ttrue.\n\n- : minus-right-cancels-gt X3+X2=X1 X6+X5=X4 X2=X5 X3>X6 X1>X4\n    <- plus-respects-eq X3+X2=X1 eq/ X2=X5 eq/ X3+X5=X1\n    <- plus-right-preserves-gt* X3>X6 X3+X5=X1 X6+X5=X4 X1>X4.\n\n%worlds () (minus-right-cancels-gt X1-X2=X3 X4-X5=X6 X2=X5 X3>X6 \n                            X1>X4).\n%total {} (minus-right-cancels-gt _ _ _ _ _).\n\n\n\n%theorem times-right-distributes-over-minus :\n\tforall* {X1} {X2} {X3} {X4} {X7}\n        forall {S12:minus X1 X2 X3} {M34:times X3 X4 X7}\n        exists {X5} {X6} {M14:times X1 X4 X5} {M24:times X2 X4 X6}\n               {S56:minus X5 X6 X7}\n\ttrue.\n\n- : times-right-distributes-over-minus X3+X2=X1 X3*X4=X7 _ _ X1*X4=X5 X2*X4=X6 \n                                   X7+X6=X5\n    <- times-total X1*X4=X5\n    <- times-right-distributes-over-plus X3+X2=X1 X1*X4=X5 _ _\n                                      X3*X4=Y7 X2*X4=X6 Y7+X6=X5\n    <- times-deterministic X3*X4=Y7 X3*X4=X7 eq/ eq/ Y7=X7\n    <- plus-respects-eq Y7+X6=X5 Y7=X7 eq/ eq/ X7+X6=X5.\n\n%worlds () (times-right-distributes-over-minus X1-X2=X3 X3*X4=X7 \n                                     X5 X6 X1*X4=X5 X2*X4=X6 X5-X6=X7).\n%total {} (times-right-distributes-over-minus _ _ _ _ _ _ _).\n\n\n\n%theorem times-right-distributes-over-minus* :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X6} {X7}\n        forall {A12:minus X1 X2 X3} {M34:times X3 X4 X7}\n               {M14:times X1 X4 X5} {M24:times X2 X4 X6}\n        exists {A56:minus X5 X6 X7}\n\ttrue.\n\n- : times-right-distributes-over-minus* X1-X2=X3 X3*X4=X7 X1*X4=X5 X2*X4=X6 X5-X6=X7\n    <- times-right-distributes-over-minus X1-X2=X3 X3*X4=X7 Y5 Y6\n                                      X1*X4=Y5 X2*X4=Y6 Y5-Y6=X7\n    <- times-deterministic X1*X4=Y5 X1*X4=X5 eq/ eq/ Y5=X5\n    <- times-deterministic X2*X4=Y6 X2*X4=X6 eq/ eq/ Y6=X6\n    <- minus-respects-eq Y5-Y6=X7 Y5=X5 Y6=X6 eq/ X5-X6=X7.\n\n%worlds () (times-right-distributes-over-minus* X1-X2=X3 X3*X4=X7 X1*X4=X5 X2*X4=X6\n                                       X5-X6=X7).\n%total {} (times-right-distributes-over-minus* _ _ _ _ _).\n\n\n%theorem times-left-distributes-over-minus* :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X6} {X7}\n        forall {A12:minus X2 X4 X6} {M34:times X1 X6 X7}\n               {M14:times X1 X2 X3} {M24:times X1 X4 X5}\n        exists {A56:minus X3 X5 X7}\n\ttrue.\n\n- : times-left-distributes-over-minus* X2-X4=X6 X1*X6=X7 X1*X2=X3 X1*X4=X5 X3-X5=X7\n    <- times-commutative X1*X6=X7 X6*X1=X7\n    <- times-commutative X1*X2=X3 X2*X1=X3\n    <- times-commutative X1*X4=X5 X4*X1=X5\n    <- times-right-distributes-over-minus* X2-X4=X6 X6*X1=X7 X2*X1=X3 X4*X1=X5\n                                       X3-X5=X7.\n\n%worlds () (times-left-distributes-over-minus* X2-X4=X6 X1*X6=X7 X1*X2=X3 X1*X4=X5\n                                     X3-X5=X7).\n%total {} (times-left-distributes-over-minus* _ _ _ _ _).\n\n\n%theorem times-left-distributes-over-minus :\n\tforall* {X1} {X2} {X4} {X6} {X7}\n        forall {A12:minus X2 X4 X6} {M34:times X1 X6 X7}\n        exists {X3} {X5} {M14:times X1 X2 X3} {M24:times X1 X4 X5}\n               {A56:minus X3 X5 X7}\n\ttrue.\n\n- : times-left-distributes-over-minus X2-X4=X6 X1*X6=X7 \n                                  X3 X5 X1*X2=X3 X1*X4=X5 X3-X5=X7\n    <- times-total X1*X2=X3\n    <- times-total X1*X4=X5\n    <- times-left-distributes-over-minus* X2-X4=X6 X1*X6=X7 X1*X2=X3 X1*X4=X5\n                                      X3-X5=X7.\n\n%worlds () (times-left-distributes-over-minus X2-X4=X6 X1*X6=X7 \n                                    X3 X5 X1*X2=X3 X1*X4=X5 X3-X5=X7).\n%total {} (times-left-distributes-over-minus _ _ _ _ _ _ _).\n\n\n%theorem times-right-factors-over-minus* :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X6} {X7}\n        forall {M14:times X1 X4 X5} {M24:times X2 X4 X6} {A56:minus X5 X6 X7}\n               {A12:minus X1 X2 X3} \n        exists {M34:times X3 X4 X7}\n\ttrue.\n\n- : times-right-factors-over-minus* X1*X4=X5 X2*X4=X6 X5-X6=X7 X1-X2=X3 X3*X4=X7\n    <- times-total X3*X4=Y7\n    <- times-right-distributes-over-minus* X1-X2=X3 X3*X4=Y7 X1*X4=X5 X2*X4=X6 \n                                       X5-X6=Y7\n    <- minus-deterministic X5-X6=Y7 X5-X6=X7 eq/ eq/ Y7=X7\n    <- times-respects-eq X3*X4=Y7 eq/ eq/ Y7=X7 X3*X4=X7.\n\n%worlds () (times-right-factors-over-minus* X1*X4=X5 X2*X4=X6 X5-X6=X7 X1-X2=X3\n                                  X3*X4=X7 ).\n%total {} (times-right-factors-over-minus* _ _ _ _ _).\n\n\n%theorem times-left-factors-over-minus* :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X6} {X7}\n\tforall {M12:times X1 X2 X3} {M14:times X1 X4 X5} \n               {A35:minus X3 X5 X7} {A24:minus X2 X4 X6} \n        exists {M16:times X1 X6 X7}\n        true.\n\n- : times-left-factors-over-minus* X1*X2=X3 X1*X4=X5 X3-X5=X7 X2-X4=X6 \n                               X1*X6=X7\n    <- times-total X1*X6=Y7\n    <- times-left-distributes-over-minus* X2-X4=X6 X1*X6=Y7 X1*X2=X3 X1*X4=X5\n                                      X3-X5=Y7\n    <- minus-deterministic X3-X5=Y7 X3-X5=X7 eq/ eq/ Y7=X7\n    <- times-respects-eq X1*X6=Y7 eq/ eq/ Y7=X7 X1*X6=X7.\n\n%worlds () (times-left-factors-over-minus* X1*X2=X3 X1*X4=X5 X3-X5=X7 X2-X4=X6 \n                                X1*X6=X7).\n%total {} (times-left-factors-over-minus* _ _ _ _ _).\n\n\n%theorem times-right-factors-over-minus :\n\tforall* {Y} {Z} {XY} {XZ} {YZ} {XYZ} {Z-}\n\tforall {TXY:times XY Z XYZ} {TY:times Y Z YZ}\n               {M:minus XYZ YZ XZ} {EZ:eq Z (s Z-)}\n        exists {X} {M':minus XY Y X} {TX:times X Z XZ}\n        true.\n\n% minus isn't total, so this is harder.\n- : times-right-factors-over-minus XY*Z=YZ Y*Z=YZ plus/z eq/ \n                                   z ZERO+Y=XY times/z\n    <- times-right-cancels* XY*Z=YZ Y*Z=YZ eq/ eq/ XY=Y\n    <- plus-respects-eq plus/z eq/ XY=Y eq/ ZERO+Y=XY.\n\n- : times-right-factors-over-minus XY*Z=XYZ Y*Z=YZ XZ+YZ=XYZ _\n                                   (s X-) X+Y=XY X*Z=XZ\n    %% we assume XZ is of the form (s XZ-)\n    <- plus-implies-gt XZ+YZ=XYZ eq/ XYZ>YZ \n    <- times-right-cancels-gt XY*Z=XYZ Y*Z=YZ eq/ XYZ>YZ XY>Y\n    <- gt-implies-plus XY>Y X- X+Y=XY\n    <- times-right-factors-over-minus* XY*Z=XYZ Y*Z=YZ XZ+YZ=XYZ X+Y=XY X*Z=XZ.\n\n%worlds () (times-right-factors-over-minus XY*Z=XYZ Y*Z=YZ XYZ-YZ=XZ Z+\n                                           X XY-Y=X X*Z=XZ).\n%total {} (times-right-factors-over-minus _ _ _ _ _ _ _).\n\n\n%theorem times-left-factors-over-minus :\n\tforall* {X} {Y} {Z} {XY} {XZ} {XYZ} {X-}\n\tforall {TXY:times X Y XY} {TXZ:times X Z XZ}\n               {M:minus XY XZ XYZ} {EX:eq X (s X-)}\n        exists {YZ} {MYZ:minus Y Z YZ} {TXYZ:times X YZ XYZ}\n        true.\n\n- : times-left-factors-over-minus X*Y=XY X*Z=XZ XY-XZ=XYZ X=sX- YZ Y-Z=YZ X*YZ=XYZ\n    <- times-commutative X*Y=XY Y*X=XY\n    <- times-commutative X*Z=XZ Z*X=XZ\n    <- times-right-factors-over-minus Y*X=XY Z*X=XZ XY-XZ=XYZ X=sX- \n                                      YZ Y-Z=YZ YZ*X=XYZ\n    <- times-commutative YZ*X=XYZ X*YZ=XYZ.\n\n%worlds () (times-left-factors-over-minus X*Y=XY X*Z=XZ XY-XZ=XYZ X=sX-\n                                    YZ Y-Z=YZ X*YZ=XYZ).\n%total {} (times-left-factors-over-minus _ _ _ _ _ _ _).\n\n\n\n\n\n%%%%% nat-comp.elf\n%%%%% Composed relations for natural numbers\n%%%%% This file is part of the nat.elf signature\n\n\n\n\n\n%%%% Definitions\n\n\n\nge : nat -> nat -> type.\n\n\nge/= : ge X Y\n    <- eq X Y.\n\nge/> : ge X Y\n    <- gt X Y.\n\n\n\n\n%%%% Theorems\n\n\n\n%%% Theorems about ge\n\n\n%theorem false-implies-ge :\n\tforall* {X1} {X2}\n\tforall {F:void}\n\texists {G:ge X1 X2}\n\ttrue.\n\n%worlds () (false-implies-ge _ _).\n%total { } (false-implies-ge _ _).\n\n\n%theorem ge-respects-eq :\n\tforall* {X1} {X2} {Y1} {Y2}\n\tforall {D1:ge X1 X2} {E1:eq X1 Y1} {E2:eq X2 Y2}\n\texists {D2:ge Y1 Y2}\n\ttrue.\n\n- : ge-respects-eq X1>=X2 eq/ eq/ X1>=X2.\n\n%worlds () (ge-respects-eq _ _ _ _).\n%total { } (ge-respects-eq _ _ _ _).\n\n%theorem ge-reflexive :\n\tforall {X}\n\texists {G:ge X X}\n\ttrue.\n\n- : ge-reflexive _ (ge/= eq/).\n\n%worlds () (ge-reflexive X  X>=X).\n%total {} (ge-reflexive _ _).\n\n\n%theorem ge-transitive:\n\tforall* {X1} {X2} {X3}\n\tforall {G1:ge X1 X2} {G2:ge X2 X3}\n\texists {G3:ge X1 X3}\n\ttrue.\n\n- : ge-transitive (ge/= eq/) (ge/= eq/) (ge/= eq/).\n\n- : ge-transitive (ge/= eq/) (ge/> X>X3) (ge/> X>X3).\n\n- : ge-transitive (ge/> X1>X) (ge/= eq/) (ge/> X1>X).\n\n- : ge-transitive (ge/> X1>X2) (ge/> X2>X3) (ge/> X1>X3)\n    <- gt-transitive X1>X2 X2>X3 X1>X3.\n\n%worlds () (ge-transitive X1>=X2 X2>=X3  X1>=X3).\n%total {} (ge-transitive _ _ _).\n\n\n%theorem ge-anti-symmetric :\n\tforall* {X1} {X2}\n\tforall {G1:ge X1 X2} {G2:ge X2 X1}\n        exists {E:eq X1 X2}\n\ttrue.\n\n- : ge-anti-symmetric (ge/= eq/) _ eq/.\n\n- : ge-anti-symmetric _ (ge/= eq/) eq/.\n\n- : ge-anti-symmetric (ge/> X1>X2) (ge/> X2>X1) X1=X2\n    <- gt-anti-symmetric X1>X2 X2>X1 F\n    <- false-implies-eq F X1=X2.\n\n%worlds () (ge-anti-symmetric X1>=X2 X2>=X1  X1=X2).\n%total {} (ge-anti-symmetric _ _ _).\n\n\n%theorem ge-transitive-gt:\n\tforall* {X1} {X2} {X3}\n\tforall {G1:ge X1 X2} {G2:gt X2 X3}\n\texists {G3:gt X1 X3}\n\ttrue.\n\n- : ge-transitive-gt (ge/= eq/) X>X3 X>X3.\n\n- : ge-transitive-gt (ge/> X1>X2) X2>X3 X1>X3\n    <- gt-transitive X1>X2 X2>X3 X1>X3.\n\n%worlds () (ge-transitive-gt X1>=X2 X2>X3  X1>X3).\n%total {} (ge-transitive-gt _ _ _).\n\n\n%theorem gt-transitive-ge:\n\tforall* {X1} {X2} {X3}\n\tforall {G1:gt X1 X2} {G2:ge X2 X3}\n\texists {G3:gt X1 X3}\n\ttrue.\n\n- : gt-transitive-ge X1>X2 (ge/= eq/) X1>X2.\n\n- : gt-transitive-ge X1>X2 (ge/> X2>X3) X1>X3\n    <- gt-transitive X1>X2 X2>X3 X1>X3.\n\n%worlds () (gt-transitive-ge X1>X2 X2>=X3  X1>X3).\n%total {} (gt-transitive-ge _ _ _).\n\n%theorem meta-ge :\n\tforall {M} {N} {G:ge M N}\n        true.\n\n- : meta-ge _ _ (ge/= eq/).\n\n- : meta-ge _ _ (ge/> M>N) \n    <- meta-gt _ _ M>N.\n\n%worlds () (meta-ge _ _ _).\n%total { } (meta-ge _ _ _).\n%reduces N <= M (meta-ge M N _).\n\n\n%theorem succ-preserves-ge :\n\tforall* {M} {N}\n\tforall {G:ge M N}\n\texists {G':ge (s M) (s N)}\n\ttrue.\n\n- : succ-preserves-ge (ge/= eq/) (ge/= eq/).\n\n- : succ-preserves-ge (ge/> N>M) (ge/> N+1>M+1)\n    <- succ-preserves-gt N>M N+1>M+1.\n\n%worlds () (succ-preserves-ge M>=N  M+1>=N+1).\n%total {} (succ-preserves-ge _ _).\n\n\n%theorem succ-preserves-ge-converse :\n\tforall* {M} {N}\n\tforall {G':ge (s M) (s N)}\n\texists {G:ge M N}\n\ttrue.\n\n- : succ-preserves-ge-converse (ge/= eq/) (ge/= eq/).\n\n- : succ-preserves-ge-converse (ge/> N+1>M+1) (ge/> N>M)\n    <- succ-preserves-gt-converse N+1>M+1 N>M.\n\n%worlds () (succ-preserves-ge-converse M+1>=N+1  M>=N).\n%total {} (succ-preserves-ge-converse _ _).\n\n\n%theorem ge-succ-implies-gt :\n\tforall* {N1} {N2}\n\tforall {G:ge N1 (s N2)}\n        exists {G':gt N1 N2}\n\ttrue.\n\n- : ge-succ-implies-gt (ge/= eq/) (gt/1).\n\n- : ge-succ-implies-gt (ge/> N1>sN2) N1>N2\n    <- gt-transitive N1>sN2 (gt/1) N1>N2.\n\n%worlds () (ge-succ-implies-gt _ _).\n%total { } (ge-succ-implies-gt _ _).\n\n\n%theorem ge-implies-succ-gt :\n\tforall* {N1} {N2}\n\tforall {G:ge N1 N2}\n\texists {G':gt (s N1) N2}\n\ttrue.\n\n- : ge-implies-succ-gt N1>=N2 N1+1>N2\n    <- succ-preserves-ge N1>=N2 N1+1>=N2+1\n    <- ge-succ-implies-gt N1+1>=N2+1 N1+1>N2.\n\n%worlds () (ge-implies-succ-gt _ _).\n%total { } (ge-implies-succ-gt _ _).\n\n\n%theorem succ-gt-implies-ge :\n\tforall* {N1} {N2}\n\tforall {G:gt (s N1) N2}\n        exists {G':ge N1 N2}\n\ttrue.\n\n- : succ-gt-implies-ge (gt/1) (ge/= eq/).\n\n- : succ-gt-implies-ge (gt/> N1>N2) (ge/> N1>N2).\n\n%worlds () (succ-gt-implies-ge _ _).\n%total { } (succ-gt-implies-ge _ _).\n\n\n%theorem gt-implies-ge-succ :\n\tforall* {N1} {N2}\n        forall {G':gt N1 N2}\n\texists {G:ge N1 (s N2)}\n\ttrue.\n\n- : gt-implies-ge-succ N1>N2 N1>=N2+1\n    <- succ-preserves-gt N1>N2 N1+1>N2+1\n    <- succ-gt-implies-ge N1+1>N2+1 N1>=N2+1.\n\n%worlds () (gt-implies-ge-succ _ _).\n%total { } (gt-implies-ge-succ _ _).\n\n\n%theorem ge-implies-plus:\n\tforall* {N1} {N2}\n\tforall {G:ge N2 N1}\n        exists {N0} {P:plus N0 N1 N2}\n        true.\n\n- : ge-implies-plus (ge/= eq/) z plus/z.\n\n- : ge-implies-plus (ge/> N2>N1) (s N0) P\n    <- gt-implies-plus N2>N1 N0 P.\n\n%worlds () (ge-implies-plus N2>=N1  N0 N0+N1=N2).\n%total { } (ge-implies-plus _ _ _).\n\n\n%theorem plus-implies-ge:\n\tforall* {N0} {N1} {N2}\n\tforall {P:plus N0 N1 N2}\n\texists {G:ge N2 N1}\n\ttrue.\n\n- : plus-implies-ge plus/z (ge/= eq/).\n\n- : plus-implies-ge P (ge/> N2>N1)\n    <- plus-implies-gt P eq/ N2>N1.\n\n%worlds () (plus-implies-ge N0+N1=N2  N2>=N1).\n%total { } (plus-implies-ge _ _).\n\n\n%theorem ge-zero-always :\n\tforall {N}\n\texists {G:ge N z}\n\ttrue.\n\n- : ge-zero-always _ N>=0\n    <- plus-right-identity _ N+0=N\n    <- plus-implies-ge N+0=N N>=0.\n\t\n%worlds () (ge-zero-always _ _).\n%total { } (ge-zero-always _ _).\n\n\n%theorem nonzero-times-implies-ge :\n\tforall* {N0} {N1} {N2}\n\tforall {P:times (s N0) N1 N2}\n\texists {G:ge N2 N1}\n\ttrue.\n\n- : nonzero-times-implies-ge (times/s _ X+N1=N2) N2>=N1\n    <- plus-implies-ge X+N1=N2 N2>=N1.\n\n%worlds () (nonzero-times-implies-ge N0*N1=N2  N2>=N1).\n%total { } (nonzero-times-implies-ge _ _).\n\n\n%theorem times-nonzero-implies-ge :\n\tforall* {N0} {N1} {N2}\n\tforall {P:times N0 (s N1) N2}\n\texists {G:ge N2 N0}\n\ttrue.\n\n- : times-nonzero-implies-ge A*B=C C>=A\n    <- times-commutative A*B=C B*A=C\n    <- nonzero-times-implies-ge B*A=C C>=A.\n\n%worlds () (times-nonzero-implies-ge _ _).\n%total { } (times-nonzero-implies-ge _ _).\n\n\n%theorem non-trivial-times-implies-much-gt* :\n\tforall* {N1} {N2} {N3}\n\tforall {D:times (s (s N1)) (s (s N2)) N3}\n        exists {G:gt N3 (s (s (s N1)))}\n\ttrue.\n\n- : non-trivial-times-implies-much-gt* \n     (times/s (times/s N1*ssN2=P1 P1+ssN2=P2) P2+ssN2=N3) N3>sssN1\n    <- times-nonzero-implies-ge N1*ssN2=P1 P1>=N1\n    <- succ-preserves-ge P1>=N1 SP1>=sN1\n    <- plus-swap-succ-converse P1+ssN2=P2 SP1+sN2=P2\n    <- plus-commutative SP1+sN2=P2 SN2+sP1=P2\n    <- plus-implies-gt SN2+sP1=P2 eq/ P2>sP1\n    <- gt-transitive-ge P2>sP1 SP1>=sN1 P2>sN1\n    <- succ-preserves-gt P2>sN1 SP2>ssN1\n    <- gt-implies-ge-succ SP2>ssN1 SP2>=sssN1\n    <- plus-commutative P2+ssN2=N3 SSN2+P2=N3\n    <- plus-swap-succ SSN2+P2=N3 SN2+sP2=N3\n    <- plus-implies-gt SN2+sP2=N3 eq/ N3>sP2\n    <- gt-transitive-ge N3>sP2 SP2>=sssN1 N3>sssN1.\n\n%worlds () (non-trivial-times-implies-much-gt* _ _).\n%total { } (non-trivial-times-implies-much-gt* _ _).\n\n\n%theorem non-trivial-times-implies-much-gt :\n\tforall* {N1} {N2} {N3}\n\tforall {D:times (s (s N1)) (s (s N2)) N3}\n        exists {G1:gt N3 (s (s (s N1)))} {G2:gt N3 (s (s (s N2)))}\n\ttrue.\n\n- : non-trivial-times-implies-much-gt T G1 G2\n    <- non-trivial-times-implies-much-gt* T G1\n    <- times-commutative T Tc\n    <- non-trivial-times-implies-much-gt* Tc G2.\n\n%worlds () (non-trivial-times-implies-much-gt _ _ _).\n%total { } (non-trivial-times-implies-much-gt _ _ _).\n\n\n\n%theorem plus-left-preserves-ge* :\n\tforall* {X1} {X2} {X3} {X4} {X5}\n        forall {G:ge X2 X4}\n               {OP1:plus X1 X2 X3} {OP2:plus X1 X4 X5}\n        exists {G2:ge X3 X5}\n\ttrue.\n\n- : plus-left-preserves-ge* (ge/= eq/) X1+X2=X3 X1+X2=X5 (ge/= X3=X5)\n    <- plus-deterministic X1+X2=X3 X1+X2=X5 eq/ eq/ X3=X5.\n\n- : plus-left-preserves-ge* (ge/> X2>X4) X1+X2=X3 X1+X4=X5 (ge/> X3>X5)\n    <- plus-left-preserves-gt* X2>X4 X1+X2=X3 X1+X4=X5 X3>X5.\n\n%worlds () (plus-left-preserves-ge* X2>=X4 X1+X2=X3 X1+X4=X5  X3>=X5).\n%total {} (plus-left-preserves-ge* _ _ _ _).\n\n\n%theorem plus-left-cancels-ge :\n\tforall* {X1} {X2} {X3} {Y1} {Y2} {Y3}\n\tforall {OP1:plus X1 X2 X3} {OP2:plus Y1 Y2 Y3} {E1:eq X1 Y1} {G3:ge X3 Y3} \n\texists {G2:ge X2 Y2}\n\ttrue.\n\n- : plus-left-cancels-ge X1+X2=X3 X1+Y2=X3 eq/ (ge/= eq/) (ge/= X2=Y2)\n    <- plus-left-cancels X1+X2=X3 X1+Y2=X3 eq/ eq/ X2=Y2.\n\n- : plus-left-cancels-ge X1+X2=X3 X1+Y2=Y3 eq/ (ge/> X3>Y3) (ge/> X2>Y2)\n    <- plus-left-cancels-gt X1+X2=X3 X1+Y2=Y3 eq/ X3>Y3 X2>Y2.\n\n%worlds () (plus-left-cancels-ge X1+X2=X3 Y1+Y2=Y3 X1=Y1 X3>=Y3  X2>=Y2).\n%total {} (plus-left-cancels-ge _ _ _ _ _).\n\n\n\n%theorem plus-left-preserves-ge :\n\tforall* {X1} {X2} {X4}\n      \tforall {G:ge X2 X4}\n\texists {X3} {X5}\n               {O1:plus X1 X2 X3} {O2:plus X1 X4 X5}\n      \t       {G2:ge X3 X5}\n\ttrue.\n\n- : plus-left-preserves-ge X2>=X4 X3 X5 X1+X2=A3 X1+X4=X5 X3>=X5\n    <- plus-total X1+X2=A3 \n    <- plus-total X1+X4=X5\n    <- plus-left-preserves-ge* X2>=X4 X1+X2=A3 X1+X4=X5 X3>=X5.\n\n%worlds () (plus-left-preserves-ge X2>=X4  X3 X5 X1+X2=A3 X1+X4=X5 X3>=X5).\n%total {} (plus-left-preserves-ge _ _ _ _ _ _).\n\n\n%theorem plus-right-preserves-ge* :\n\tforall* {X1} {X2} {X3} {X4} {X5}\n\tforall {G1:ge X1 X2} {O1:plus X1 X3 X4} {O2:plus X2 X3 X5}\n\texists {G2:ge X4 X5}\n\ttrue.\n\n- : plus-right-preserves-ge* X1>=X2 X1+X3=X4 X2+X3=X5 X4>=X5\n    <- plus-commutative X1+X3=X4 X3+X1=X4\n    <- plus-commutative X2+X3=X5 X3+X2=X5\n    <- plus-left-preserves-ge* X1>=X2 X3+X1=X4 X3+X2=X5 X4>=X5.\n\n%worlds () (plus-right-preserves-ge* X1>=X2 X1+X3=X4 X2+X3=X5  X4>=X5).\n%total {} (plus-right-preserves-ge* _ _ _ _).\n\n\n%theorem plus-right-preserves-ge :\n\tforall* {X1} {X2} {X3}\n\tforall {G1:ge X1 X2} \n\texists {X4} {X5} {O1:plus X1 X3 X4} {O2:plus X2 X3 X5} {G2:ge X4 X5}\n\ttrue.\n\n- : plus-right-preserves-ge X1>=X2 X4 X5 X1+X3=X4 X2+X3=X5 X4>=X5\n    <- plus-total X1+X3=X4 \n    <- plus-total X2+X3=X5\n    <- plus-right-preserves-ge* X1>=X2 X1+X3=X4 X2+X3=X5 X4>=X5.\n%worlds () (plus-right-preserves-ge X1>=X2  X4 X5 X1+X3=X4 X2+X3=X5 X4>=X5).\n%total {} (plus-right-preserves-ge _ _ _ _ _ _).\n\n\n%theorem plus-preserves-ge* :\n\tforall* {X1} {X2} {X3} {Y1} {Y2} {Y3}\n\tforall {G1:ge X1 Y1} {G2:ge X2 Y2}\n               {MX:plus X1 X2 X3} {MY:plus Y1 Y2 Y3}\n        exists {G3:ge X3 Y3}\n\ttrue.\n\n- : plus-preserves-ge* X1>=Y1 X2>=Y2 X1+X2=X3 Y1+Y2=Y3 X3>=Y3\n    <- plus-total Y1+X2=X\n    <- plus-right-preserves-ge* X1>=Y1 X1+X2=X3 Y1+X2=X X3>=X\n    <- plus-left-preserves-ge* X2>=Y2 Y1+X2=X Y1+Y2=Y3 X>=Y3\n    <- ge-transitive X3>=X X>=Y3 X3>=Y3.\n\n%worlds () (plus-preserves-ge* X1>=Y1 X2>=Y2 X1+X2=X3 Y1+Y2=Y3  X3>=Y3).\n%total {} (plus-preserves-ge* _ _ _ _ _).\n\n\n%theorem plus-preserves-ge :\n\tforall* {X1} {X2} {Y1} {Y2}\n\tforall {G1:ge X1 Y1} {G2:ge X2 Y2}\n\texists {X3} {Y3} {MX:plus X1 X2 X3} {MY:plus Y1 Y2 Y3} {G3:ge X3 Y3}\n\ttrue.\n\n- : plus-preserves-ge X1>=Y1 X2>=Y2 X3 Y3 X1+X2=X3 Y1+Y2=Y3 X3>=Y3\n    <- plus-total X1+X2=X3\n    <- plus-total Y1+Y2=Y3\n    <- plus-preserves-ge* X1>=Y1 X2>=Y2 X1+X2=X3 Y1+Y2=Y3 X3>=Y3.\n\n%worlds () (plus-preserves-ge X1>=Y1 X2>=Y2  X3 Y3 X1+X2=X3 Y1+Y2=Y3 X3>=Y3).\n%total {} (plus-preserves-ge _ _ _ _ _ _ _).\n\n\n%theorem plus-right-cancels-ge :\n\tforall* {X1} {X2} {X3} {Y1} {Y2} {Y3}\n\tforall {OP1:plus X1 X2 X3} {OP2:plus Y1 Y2 Y3} {E2:eq X2 Y2} {G3:ge X3 Y3} \n\texists {G1:ge X1 Y1}\n\ttrue.\n\n- : plus-right-cancels-ge X1+X2=X3 Y1+Y2=Y3 X2=Y2 X3>=Y3 X1>=Y1\n    <- plus-commutative X1+X2=X3 X2+X1=X3\n    <- plus-commutative Y1+Y2=Y3 Y2+Y1=Y3\n    <- plus-left-cancels-ge X2+X1=X3 Y2+Y1=Y3 X2=Y2 X3>=Y3 X1>=Y1.\n\n%worlds () (plus-right-cancels-ge X1+X2=X3 Y1+Y2=Y3 X2=Y2 X3>=Y3  X1>=Y1).\n%total {} (plus-right-cancels-ge _ _ _ _ _).\n\n\n% Times preserves ge only because multiplying with zero yields equality.\n%theorem times-left-preserves-ge* :\n\tforall* {X1} {X2} {X3} {X4} {X5}\n        forall {G:ge X2 X4}\n               {OP1:times X1 X2 X3} {OP2:times X1 X4 X5}\n        exists {G2:ge X3 X5}\n\ttrue.\n\n- : times-left-preserves-ge* _ times/z times/z (ge/= eq/).\n\n- : times-left-preserves-ge* (ge/= eq/) X1*X2=X3 X1*X2=X5 (ge/= X3=X5)\n    <- times-deterministic X1*X2=X3 X1*X2=X5 eq/ eq/ X3=X5.\n\n- : times-left-preserves-ge* (ge/> X2>X4) X1*X2=X3 X1*X4=X5 (ge/> X3>X5)\n    <- times-left-preserves-gt X2>X4 X1*X2=X3 X1*X4=X5 X3>X5.\n\n%worlds () (times-left-preserves-ge* X2>=X4 X1*X2=X3 X1*X4=X5  X3>=X5).\n%total {} (times-left-preserves-ge* _ _ _ _).\n\n\n\n%theorem times-left-preserves-ge :\n\tforall* {X1} {X2} {X4}\n      \tforall {G:ge X2 X4}\n\texists {X3} {X5}\n               {O1:times X1 X2 X3} {O2:times X1 X4 X5}\n      \t       {G2:ge X3 X5}\n\ttrue.\n\n- : times-left-preserves-ge X2>=X4 X3 X5 X1*X2=A3 X1*X4=X5 X3>=X5\n    <- times-total X1*X2=A3 \n    <- times-total X1*X4=X5\n    <- times-left-preserves-ge* X2>=X4 X1*X2=A3 X1*X4=X5 X3>=X5.\n\n%worlds () (times-left-preserves-ge X2>=X4  X3 X5 X1*X2=A3 X1*X4=X5 X3>=X5).\n%total {} (times-left-preserves-ge _ _ _ _ _ _).\n\n\n%theorem times-right-preserves-ge* :\n\tforall* {X1} {X2} {X3} {X4} {X5}\n\tforall {G1:ge X1 X2} {O1:times X1 X3 X4} {O2:times X2 X3 X5}\n\texists {G2:ge X4 X5}\n\ttrue.\n\n- : times-right-preserves-ge* X1>=X2 X1*X3=X4 X2*X3=X5 X4>=X5\n    <- times-commutative X1*X3=X4 X3*X1=X4\n    <- times-commutative X2*X3=X5 X3*X2=X5\n    <- times-left-preserves-ge* X1>=X2 X3*X1=X4 X3*X2=X5 X4>=X5.\n\n%worlds () (times-right-preserves-ge* X1>=X2 X1*X3=X4 X2*X3=X5  X4>=X5).\n%total {} (times-right-preserves-ge* _ _ _ _).\n\n\n%theorem times-right-preserves-ge :\n\tforall* {X1} {X2} {X3}\n\tforall {G1:ge X1 X2} \n\texists {X4} {X5} {O1:times X1 X3 X4} {O2:times X2 X3 X5} {G2:ge X4 X5}\n\ttrue.\n\n- : times-right-preserves-ge X1>=X2 X4 X5 X1*X3=X4 X2*X3=X5 X4>=X5\n    <- times-total X1*X3=X4 \n    <- times-total X2*X3=X5\n    <- times-right-preserves-ge* X1>=X2 X1*X3=X4 X2*X3=X5 X4>=X5.\n%worlds () (times-right-preserves-ge X1>=X2  X4 X5 X1*X3=X4 X2*X3=X5 X4>=X5).\n%total {} (times-right-preserves-ge _ _ _ _ _ _).\n\n\n\n\n\n\n%%%% Definitions\n\n\n\nne : nat -> nat -> type.\n\n\nne/< : ne X Y\n    <- gt Y X.\n\nne/> : ne X Y\n    <- gt X Y.\n\n\n\n\neq? : nat -> nat -> bool -> type.\n\n\neq?/yes : eq? X X true.\n\neq?/no : eq? X Y false\n    <- ne X Y.\n\n\n\n\n%%%% Theorems\n\n\n\n%%% Theorems about ne\n\n\n%theorem false-implies-ne :\n\tforall* {X1} {X2}\n\tforall {F:void}\n\texists {G:ne X1 X2}\n\ttrue.\n\n%worlds () (false-implies-ne _ _).\n%total { } (false-implies-ne _ _).\n\n\n%theorem ne-respects-eq :\n\tforall* {X1} {X2} {Y1} {Y2}\n\tforall {D1:ne X1 X2} {E1:eq X1 Y1} {E2:eq X2 Y2}\n\texists {D2:ne Y1 Y2}\n\ttrue.\n\n- : ne-respects-eq X1<>X2 eq/ eq/ X1<>X2.\n\n%worlds () (ne-respects-eq _ _ _ _).\n%total { } (ne-respects-eq _ _ _ _).\n\n%theorem ne-anti-reflexive :\n\tforall* {X}\n\tforall {R:ne X X}\n\texists {F:void}\n\ttrue.\n\n- : ne-anti-reflexive (ne/< X<X) F\n    <- gt-anti-reflexive X<X F.\n\n- : ne-anti-reflexive (ne/> X>X) F\n    <- gt-anti-reflexive X>X F.\n\n%worlds () (ne-anti-reflexive X<>X  _).\n%total {} (ne-anti-reflexive _ _).\n\n\n%theorem ne-symmetric :\n\tforall* {X} {Y}\n\tforall {R1:ne X Y}\n\texists {R2:ne Y X}\n\ttrue.\n\n- : ne-symmetric (ne/< X<Y) (ne/> X<Y).\n\n- : ne-symmetric (ne/> X>Y) (ne/< X>Y).\n\n%worlds () (ne-symmetric X<>Y  Y<>X).\n%total {} (ne-symmetric _ _).\n\n\n%theorem eq-ne-implies-false :\n\tforall* {X} {Y}\n\tforall {D1:eq X Y} {D2:ne X Y}\n\texists {F:void}\n\ttrue.\n\n- : eq-ne-implies-false eq/ X<>X F\n    <- ne-anti-reflexive X<>X F.\n\n%worlds () (eq-ne-implies-false X=Y X<>Y  _).\n%total {} (eq-ne-implies-false _ _ _).\n\n\n%theorem ge-ne-implies-gt :\n\tforall* {X} {Y}\n\tforall {D1:ge X Y} {D2:ne X Y}\n\texists {D3:gt X Y}\n\ttrue.\n\n- : ge-ne-implies-gt (ge/> X>Y) _ X>Y.\n\n- : ge-ne-implies-gt (ge/= eq/) X<>X X>X\n    <- ne-anti-reflexive X<>X F\n    <- false-implies-gt F X>X.\n\n%worlds () (ge-ne-implies-gt X>=Y X<>Y  X>Y).\n%total {} (ge-ne-implies-gt _ _ _).\n\n\n%theorem eq?-total* :\n\tforall {M} {N}\n\texists {B} {T:eq? M N B}\n\ttrue.\n\n%theorem eq?-total*/L :\n\tforall* {M} {N} {C}\n\tforall {CMP:compare M N C}\n\texists {B} {T:eq? M N B}\n\ttrue.\n\n- : eq?-total*/L compare/= true eq?/yes.\n\n- : eq?-total*/L (compare/< X<Y) false (eq?/no (ne/< X<Y)).\n\n- : eq?-total*/L (compare/> X>Y) false (eq?/no (ne/> X>Y)).\n\n%worlds () (eq?-total*/L _ _ _).\n%total { } (eq?-total*/L _ _ _).\n\n- : eq?-total* M N B T\n    <- compare-total CMP\n    <- eq?-total*/L CMP B T.\n\n%worlds () (eq?-total* _ _ _ _).\n%total { } (eq?-total* _ _ _ _).\n\n\n%abbrev eq?-total = eq?-total* _ _ _.\n\n%theorem succ-preserves-ne :\n\tforall* {M} {N}\n\tforall {D:ne M N}\n\texists {D':ne (s M) (s N)}\n\ttrue.\n\n- : succ-preserves-ne (ne/< N>M) (ne/< N+1>M+1)\n    <- succ-preserves-gt N>M N+1>M+1.\n\n- : succ-preserves-ne (ne/> N>M) (ne/> N+1>M+1)\n    <- succ-preserves-gt N>M N+1>M+1.\n\n%worlds () (succ-preserves-ne M<>N  M+1<>N+1).\n%total {} (succ-preserves-ne _ _).\n\n\n%theorem succ-preserves-ne-converse :\n\tforall* {M} {N}\n\tforall {D':ne (s M) (s N)}\n\texists {D:ne M N}\n\ttrue.\n\n- : succ-preserves-ne-converse (ne/< N+1>M+1) (ne/< N>M)\n    <- succ-preserves-gt-converse N+1>M+1 N>M.\n\n- : succ-preserves-ne-converse (ne/> N+1>M+1) (ne/> N>M)\n    <- succ-preserves-gt-converse N+1>M+1 N>M.\n\n%worlds () (succ-preserves-ne-converse M+1<>N+1  M<>N).\n%total {} (succ-preserves-ne-converse _ _).\n\n\n\n%theorem plus-left-preserves-ne* :\n\tforall* {X1} {X2} {X3} {X4} {X5}\n        forall {G:ne X2 X4}\n               {OP1:plus X1 X2 X3} {OP2:plus X1 X4 X5}\n        exists {G2:ne X3 X5}\n\ttrue.\n\n- : plus-left-preserves-ne* (ne/< X4>X2) X1+X2=X3 X1+X4=X5 (ne/< X5>X3)\n    <- plus-left-preserves-gt* X4>X2 X1+X4=X5 X1+X2=X3 X5>X3.\n\n- : plus-left-preserves-ne* (ne/> X2>X4) X1+X2=X3 X1+X4=X5 (ne/> X3>X5)\n    <- plus-left-preserves-gt* X2>X4 X1+X2=X3 X1+X4=X5 X3>X5.\n\n%worlds () (plus-left-preserves-ne* X2<>X4 X1+X2=X3 X1+X4=X5  X3<>X5).\n%total {} (plus-left-preserves-ne* _ _ _ _).\n\n\n%theorem plus-left-cancels-ne :\n\tforall* {X1} {X2} {X3} {Y1} {Y2} {Y3}\n\tforall {OP1:plus X1 X2 X3} {OP2:plus Y1 Y2 Y3} {E1:eq X1 Y1} {G3:ne X3 Y3} \n\texists {G2:ne X2 Y2}\n\ttrue.\n\n- : plus-left-cancels-ne X1+X2=X3 X1+Y2=Y3 eq/ (ne/< Y3>X3) (ne/< Y2>X2)\n    <- plus-left-cancels-gt X1+Y2=Y3 X1+X2=X3 eq/ Y3>X3 Y2>X2.\n\n- : plus-left-cancels-ne X1+X2=X3 X1+Y2=Y3 eq/ (ne/> X3>Y3) (ne/> X2>Y2)\n    <- plus-left-cancels-gt X1+X2=X3 X1+Y2=Y3 eq/ X3>Y3 X2>Y2.\n\n%worlds () (plus-left-cancels-ne X1+X2=X3 Y1+Y2=Y3 X1=Y1 X3<>Y3  X2<>Y2).\n%total {} (plus-left-cancels-ne _ _ _ _ _).\n\n\n\n%theorem plus-left-preserves-ne :\n\tforall* {X1} {X2} {X4}\n      \tforall {G:ne X2 X4}\n\texists {X3} {X5}\n               {O1:plus X1 X2 X3} {O2:plus X1 X4 X5}\n      \t       {G2:ne X3 X5}\n\ttrue.\n\n- : plus-left-preserves-ne X2<>X4 X3 X5 X1+X2=A3 X1+X4=X5 X3<>X5\n    <- plus-total X1+X2=A3 \n    <- plus-total X1+X4=X5\n    <- plus-left-preserves-ne* X2<>X4 X1+X2=A3 X1+X4=X5 X3<>X5.\n\n%worlds () (plus-left-preserves-ne X2<>X4  X3 X5 X1+X2=A3 X1+X4=X5 X3<>X5).\n%total {} (plus-left-preserves-ne _ _ _ _ _ _).\n\n\n%theorem plus-right-preserves-ne* :\n\tforall* {X1} {X2} {X3} {X4} {X5}\n\tforall {G1:ne X1 X2} {O1:plus X1 X3 X4} {O2:plus X2 X3 X5}\n\texists {G2:ne X4 X5}\n\ttrue.\n\n- : plus-right-preserves-ne* X1<>X2 X1+X3=X4 X2+X3=X5 X4<>X5\n    <- plus-commutative X1+X3=X4 X3+X1=X4\n    <- plus-commutative X2+X3=X5 X3+X2=X5\n    <- plus-left-preserves-ne* X1<>X2 X3+X1=X4 X3+X2=X5 X4<>X5.\n\n%worlds () (plus-right-preserves-ne* X1<>X2 X1+X3=X4 X2+X3=X5  X4<>X5).\n%total {} (plus-right-preserves-ne* _ _ _ _).\n\n\n%theorem plus-right-preserves-ne :\n\tforall* {X1} {X2} {X3}\n\tforall {G1:ne X1 X2} \n\texists {X4} {X5} {O1:plus X1 X3 X4} {O2:plus X2 X3 X5} {G2:ne X4 X5}\n\ttrue.\n\n- : plus-right-preserves-ne X1<>X2 X4 X5 X1+X3=X4 X2+X3=X5 X4<>X5\n    <- plus-total X1+X3=X4 \n    <- plus-total X2+X3=X5\n    <- plus-right-preserves-ne* X1<>X2 X1+X3=X4 X2+X3=X5 X4<>X5.\n%worlds () (plus-right-preserves-ne X1<>X2  X4 X5 X1+X3=X4 X2+X3=X5 X4<>X5).\n%total {} (plus-right-preserves-ne _ _ _ _ _ _).\n\n\n%theorem plus-right-cancels-ne :\n\tforall* {X1} {X2} {X3} {Y1} {Y2} {Y3}\n\tforall {OP1:plus X1 X2 X3} {OP2:plus Y1 Y2 Y3} {E2:eq X2 Y2} {G3:ne X3 Y3} \n\texists {G1:ne X1 Y1}\n\ttrue.\n\n- : plus-right-cancels-ne X1+X2=X3 Y1+Y2=Y3 X2=Y2 X3<>Y3 X1<>Y1\n    <- plus-commutative X1+X2=X3 X2+X1=X3\n    <- plus-commutative Y1+Y2=Y3 Y2+Y1=Y3\n    <- plus-left-cancels-ne X2+X1=X3 Y2+Y1=Y3 X2=Y2 X3<>Y3 X1<>Y1.\n\n%worlds () (plus-right-cancels-ne X1+X2=X3 Y1+Y2=Y3 X2=Y2 X3<>Y3  X1<>Y1).\n%total {} (plus-right-cancels-ne _ _ _ _ _).\n\n\n\n\n\n\n\n%%%%% nat-less.elf\n%%%%% Inverse relations for natural numbers\n%%%%% This file is part of the nat.elf signature\n\n\n\n\n\n\n\n\n\n\n\n%%%% Definitions\n\n\n%abbrev lt = [X] [Y] gt Y X.\n\n\n\n\n%%%% Theorems about lt\n\n\n%theorem false-implies-lt :\n\tforall* {X1} {X2}\n\tforall {F:void}\n\texists {G:lt X1 X2}\n\ttrue.\n\n%worlds () (false-implies-lt _ _).\n%total { } (false-implies-lt _ _).\n\n\n%theorem lt-respects-eq :\n\tforall* {X1} {X2} {Y1} {Y2}\n\tforall {D1:lt X1 X2} {E1:eq X1 Y1} {E2:eq X2 Y2}\n\texists {D2:lt Y1 Y2}\n\ttrue.\n\n- : lt-respects-eq X1<X2 eq/ eq/ X1<X2.\n\n%worlds () (lt-respects-eq _ _ _ _).\n%total { } (lt-respects-eq _ _ _ _).\n\n%theorem lt-anti-symmetric :\n\tforall* {X1} {X2}\n\tforall {G1:lt X1 X2} {G2:lt X2 X1}\n\texists {F:void}\n\ttrue.\n\n- : lt-anti-symmetric X2>X1 X1>X2 R\n    <- gt-anti-symmetric X1>X2 X2>X1 R.\n\n%worlds () (lt-anti-symmetric _ _ _).\n%total {} (lt-anti-symmetric _ _ _).\n\n\n%theorem lt-transitive : \n\tforall* {X1} {X2} {X3}\n\tforall {G1:lt X1 X2} {G2:lt X2 X3}\n\texists {G3:lt X1 X3}\n\ttrue.\n\n- : lt-transitive X1<X2 X2<X3 X1<X3\n    <- gt-transitive X2<X3 X1<X2 X1<X3.\n\n%worlds () (lt-transitive X1<X2 X2<X3 X1<X3).\n%total {} (lt-transitive _ _ _).\n\n\n\n\n\n\n\n%abbrev lt-anti-reflexive = gt-anti-reflexive.\n\n%theorem plus-left-preserves-lt* :\n\tforall* {X1} {X2} {X3} {X4} {X5}\n        forall {R1:lt X2 X4}\n               {OP1:plus X1 X2 X3} {OP2:plus X1 X4 X5}\n        exists {R2:lt X3 X5}\n\ttrue.\n\n- : plus-left-preserves-lt* X4>X2 X1+X2=X3 X1+X4=X5 X5>X3\n    <- plus-left-preserves-gt* X4>X2 X1+X4=X5 X1+X2=X3 X5>X3.\n\n%worlds () (plus-left-preserves-lt* X2<X4 X1+X2=X3 X1+X4=X5  X3<X5).\n%total {} (plus-left-preserves-lt* _ _ _ _).\n\n\n%theorem plus-left-cancels-lt :\n\tforall* {X1} {X2} {X3} {Y1} {Y2} {Y3}\n\tforall {OP1:plus X1 X2 X3} {OP2:plus Y1 Y2 Y3} {E1:eq X1 Y1} {R3:lt X3 Y3} \n\texists {R2:lt X2 Y2}\n\ttrue.\n\n- : plus-left-cancels-lt X1+X2=X3 X1+Y2=X3 eq/ Y3>X3 Y2>X2\n    <-  plus-left-cancels-gt X1+Y2=X3 X1+X2=X3 eq/ Y3>X3 Y2>X2.\n\n%worlds () (plus-left-cancels-lt X1+X2=X3 Y1+Y2=Y3 X1=Y1 X3<Y3  X2<Y2).\n%total {} (plus-left-cancels-lt _ _ _ _ _).\n\n\n\n%theorem plus-left-preserves-lt :\n\tforall* {X1} {X2} {X4}\n      \tforall {G:lt X2 X4}\n\texists {X3} {X5}\n               {O1:plus X1 X2 X3} {O2:plus X1 X4 X5}\n      \t       {G2:lt X3 X5}\n\ttrue.\n\n- : plus-left-preserves-lt X2<X4 X3 X5 X1+X2=A3 X1+X4=X5 X3<X5\n    <- plus-total X1+X2=A3 \n    <- plus-total X1+X4=X5\n    <- plus-left-preserves-lt* X2<X4 X1+X2=A3 X1+X4=X5 X3<X5.\n\n%worlds () (plus-left-preserves-lt X2<X4  X3 X5 X1+X2=A3 X1+X4=X5 X3<X5).\n%total {} (plus-left-preserves-lt _ _ _ _ _ _).\n\n\n%theorem plus-right-preserves-lt* :\n\tforall* {X1} {X2} {X3} {X4} {X5}\n\tforall {G1:lt X1 X2} {O1:plus X1 X3 X4} {O2:plus X2 X3 X5}\n\texists {G2:lt X4 X5}\n\ttrue.\n\n- : plus-right-preserves-lt* X1<X2 X1+X3=X4 X2+X3=X5 X4<X5\n    <- plus-commutative X1+X3=X4 X3+X1=X4\n    <- plus-commutative X2+X3=X5 X3+X2=X5\n    <- plus-left-preserves-lt* X1<X2 X3+X1=X4 X3+X2=X5 X4<X5.\n\n%worlds () (plus-right-preserves-lt* X1<X2 X1+X3=X4 X2+X3=X5  X4<X5).\n%total {} (plus-right-preserves-lt* _ _ _ _).\n\n\n%theorem plus-right-preserves-lt :\n\tforall* {X1} {X2} {X3}\n\tforall {G1:lt X1 X2} \n\texists {X4} {X5} {O1:plus X1 X3 X4} {O2:plus X2 X3 X5} {G2:lt X4 X5}\n\ttrue.\n\n- : plus-right-preserves-lt X1<X2 X4 X5 X1+X3=X4 X2+X3=X5 X4<X5\n    <- plus-total X1+X3=X4 \n    <- plus-total X2+X3=X5\n    <- plus-right-preserves-lt* X1<X2 X1+X3=X4 X2+X3=X5 X4<X5.\n%worlds () (plus-right-preserves-lt X1<X2  X4 X5 X1+X3=X4 X2+X3=X5 X4<X5).\n%total {} (plus-right-preserves-lt _ _ _ _ _ _).\n\n\n%theorem plus-preserves-lt* :\n\tforall* {X1} {X2} {X3} {Y1} {Y2} {Y3}\n\tforall {G1:lt X1 Y1} {G2:lt X2 Y2}\n               {MX:plus X1 X2 X3} {MY:plus Y1 Y2 Y3}\n        exists {G3:lt X3 Y3}\n\ttrue.\n\n- : plus-preserves-lt* X1<Y1 X2<Y2 X1+X2=X3 Y1+Y2=Y3 X3<Y3\n    <- plus-total Y1+X2=X\n    <- plus-right-preserves-lt* X1<Y1 X1+X2=X3 Y1+X2=X X3<X\n    <- plus-left-preserves-lt* X2<Y2 Y1+X2=X Y1+Y2=Y3 X<Y3\n    <- lt-transitive X3<X X<Y3 X3<Y3.\n\n%worlds () (plus-preserves-lt* X1<Y1 X2<Y2 X1+X2=X3 Y1+Y2=Y3  X3<Y3).\n%total {} (plus-preserves-lt* _ _ _ _ _).\n\n\n%theorem plus-preserves-lt :\n\tforall* {X1} {X2} {Y1} {Y2}\n\tforall {G1:lt X1 Y1} {G2:lt X2 Y2}\n\texists {X3} {Y3} {MX:plus X1 X2 X3} {MY:plus Y1 Y2 Y3} {G3:lt X3 Y3}\n\ttrue.\n\n- : plus-preserves-lt X1<Y1 X2<Y2 X3 Y3 X1+X2=X3 Y1+Y2=Y3 X3<Y3\n    <- plus-total X1+X2=X3\n    <- plus-total Y1+Y2=Y3\n    <- plus-preserves-lt* X1<Y1 X2<Y2 X1+X2=X3 Y1+Y2=Y3 X3<Y3.\n\n%worlds () (plus-preserves-lt X1<Y1 X2<Y2  X3 Y3 X1+X2=X3 Y1+Y2=Y3 X3<Y3).\n%total {} (plus-preserves-lt _ _ _ _ _ _ _).\n\n\n%theorem plus-right-cancels-lt :\n\tforall* {X1} {X2} {X3} {Y1} {Y2} {Y3}\n\tforall {OP1:plus X1 X2 X3} {OP2:plus Y1 Y2 Y3} {E2:eq X2 Y2} {G3:lt X3 Y3} \n\texists {G1:lt X1 Y1}\n\ttrue.\n\n- : plus-right-cancels-lt X1+X2=X3 Y1+Y2=Y3 X2=Y2 X3<Y3 X1<Y1\n    <- plus-commutative X1+X2=X3 X2+X1=X3\n    <- plus-commutative Y1+Y2=Y3 Y2+Y1=Y3\n    <- plus-left-cancels-lt X2+X1=X3 Y2+Y1=Y3 X2=Y2 X3<Y3 X1<Y1.\n\n%worlds () (plus-right-cancels-lt X1+X2=X3 Y1+Y2=Y3 X2=Y2 X3<Y3  X1<Y1).\n%total {} (plus-right-cancels-lt _ _ _ _ _).\n\n\n\n\n\n\n\n\n\n\n\n\n%%%% Definitions\n\n\n%abbrev le = [X] [Y] ge Y X.\n\n\n\n\n%%%% Theorems about le\n\n\n%theorem false-implies-le :\n\tforall* {X1} {X2}\n\tforall {F:void}\n\texists {G:le X1 X2}\n\ttrue.\n\n%worlds () (false-implies-le _ _).\n%total { } (false-implies-le _ _).\n\n\n%theorem le-respects-eq :\n\tforall* {X1} {X2} {Y1} {Y2}\n\tforall {D1:le X1 X2} {E1:eq X1 Y1} {E2:eq X2 Y2}\n\texists {D2:le Y1 Y2}\n\ttrue.\n\n- : le-respects-eq X1<=X2 eq/ eq/ X1<=X2.\n\n%worlds () (le-respects-eq _ _ _ _).\n%total { } (le-respects-eq _ _ _ _).\n\n%theorem le-anti-symmetric :\n\tforall* {X1} {X2}\n\tforall {G1:le X1 X2} {G2:le X2 X1}\n\texists {E3:eq X1 X2}\n\ttrue.\n\n- : le-anti-symmetric X2>=X1 X1>=X2 R\n    <- ge-anti-symmetric X1>=X2 X2>=X1 R.\n\n%worlds () (le-anti-symmetric _ _ _).\n%total {} (le-anti-symmetric _ _ _).\n\n\n%theorem le-transitive : \n\tforall* {X1} {X2} {X3}\n\tforall {G1:le X1 X2} {G2:le X2 X3}\n\texists {G3:le X1 X3}\n\ttrue.\n\n- : le-transitive X1<=X2 X2<=X3 X1<=X3\n    <- ge-transitive X2<=X3 X1<=X2 X1<=X3.\n\n%worlds () (le-transitive X1<=X2 X2<=X3 X1<=X3).\n%total {} (le-transitive _ _ _).\n\n\n\n\n\n\n\n\n%abbrev le-reflexive = ge-reflexive.\n\n%theorem le-transitive-lt:\n\tforall* {X1} {X2} {X3}\n\tforall {L1:le X1 X2} {L2:lt X2 X3}\n\texists {L3:lt X1 X3}\n\ttrue.\n- : le-transitive-lt X2>=X1 X3>X2 X3>X1\n    <- gt-transitive-ge X3>X2 X2>=X1 X3>X1.\n%worlds () (le-transitive-lt X1<=X2 X2<X3  X1<X3).\n%total {} (le-transitive-lt _ _ _).\n\n%theorem lt-transitive-le:\n\tforall* {X1} {X2} {X3}\n\tforall {L1:lt X1 X2} {L2:le X2 X3}\n\texists {L3:lt X1 X3}\n\ttrue.\n- : lt-transitive-le X2>X1 X3>=X2 X3>X1\n    <- ge-transitive-gt X3>=X2 X2>X1 X3>X1.\n%worlds () (lt-transitive-le X1<X2 X2<=X3  X1<X3).\n%total {} (lt-transitive-le _ _ _).\n\n%theorem plus-left-preserves-le* :\n\tforall* {X1} {X2} {X3} {X4} {X5}\n        forall {R1:le X2 X4}\n               {OP1:plus X1 X2 X3} {OP2:plus X1 X4 X5}\n        exists {R2:le X3 X5}\n\ttrue.\n\n- : plus-left-preserves-le* X4>=X2 X1+X2=X3 X1+X4=X5 X5>=X3\n    <- plus-left-preserves-ge* X4>=X2 X1+X4=X5 X1+X2=X3 X5>=X3.\n\n%worlds () (plus-left-preserves-le* X2<=X4 X1+X2=X3 X1+X4=X5  X3<=X5).\n%total {} (plus-left-preserves-le* _ _ _ _).\n\n\n%theorem plus-left-cancels-le :\n\tforall* {X1} {X2} {X3} {Y1} {Y2} {Y3}\n\tforall {OP1:plus X1 X2 X3} {OP2:plus Y1 Y2 Y3} {E1:eq X1 Y1} {R3:le X3 Y3} \n\texists {R2:le X2 Y2}\n\ttrue.\n\n- : plus-left-cancels-le X1+X2=X3 X1+Y2=X3 eq/ Y3>=X3 Y2>=X2\n    <-  plus-left-cancels-ge X1+Y2=X3 X1+X2=X3 eq/ Y3>=X3 Y2>=X2.\n\n%worlds () (plus-left-cancels-le X1+X2=X3 Y1+Y2=Y3 X1=Y1 X3<=Y3  X2<=Y2).\n%total {} (plus-left-cancels-le _ _ _ _ _).\n\n\n\n%theorem plus-left-preserves-le :\n\tforall* {X1} {X2} {X4}\n      \tforall {G:le X2 X4}\n\texists {X3} {X5}\n               {O1:plus X1 X2 X3} {O2:plus X1 X4 X5}\n      \t       {G2:le X3 X5}\n\ttrue.\n\n- : plus-left-preserves-le X2<=X4 X3 X5 X1+X2=A3 X1+X4=X5 X3<=X5\n    <- plus-total X1+X2=A3 \n    <- plus-total X1+X4=X5\n    <- plus-left-preserves-le* X2<=X4 X1+X2=A3 X1+X4=X5 X3<=X5.\n\n%worlds () (plus-left-preserves-le X2<=X4  X3 X5 X1+X2=A3 X1+X4=X5 X3<=X5).\n%total {} (plus-left-preserves-le _ _ _ _ _ _).\n\n\n%theorem plus-right-preserves-le* :\n\tforall* {X1} {X2} {X3} {X4} {X5}\n\tforall {G1:le X1 X2} {O1:plus X1 X3 X4} {O2:plus X2 X3 X5}\n\texists {G2:le X4 X5}\n\ttrue.\n\n- : plus-right-preserves-le* X1<=X2 X1+X3=X4 X2+X3=X5 X4<=X5\n    <- plus-commutative X1+X3=X4 X3+X1=X4\n    <- plus-commutative X2+X3=X5 X3+X2=X5\n    <- plus-left-preserves-le* X1<=X2 X3+X1=X4 X3+X2=X5 X4<=X5.\n\n%worlds () (plus-right-preserves-le* X1<=X2 X1+X3=X4 X2+X3=X5  X4<=X5).\n%total {} (plus-right-preserves-le* _ _ _ _).\n\n\n%theorem plus-right-preserves-le :\n\tforall* {X1} {X2} {X3}\n\tforall {G1:le X1 X2} \n\texists {X4} {X5} {O1:plus X1 X3 X4} {O2:plus X2 X3 X5} {G2:le X4 X5}\n\ttrue.\n\n- : plus-right-preserves-le X1<=X2 X4 X5 X1+X3=X4 X2+X3=X5 X4<=X5\n    <- plus-total X1+X3=X4 \n    <- plus-total X2+X3=X5\n    <- plus-right-preserves-le* X1<=X2 X1+X3=X4 X2+X3=X5 X4<=X5.\n%worlds () (plus-right-preserves-le X1<=X2  X4 X5 X1+X3=X4 X2+X3=X5 X4<=X5).\n%total {} (plus-right-preserves-le _ _ _ _ _ _).\n\n\n%theorem plus-preserves-le* :\n\tforall* {X1} {X2} {X3} {Y1} {Y2} {Y3}\n\tforall {G1:le X1 Y1} {G2:le X2 Y2}\n               {MX:plus X1 X2 X3} {MY:plus Y1 Y2 Y3}\n        exists {G3:le X3 Y3}\n\ttrue.\n\n- : plus-preserves-le* X1<=Y1 X2<=Y2 X1+X2=X3 Y1+Y2=Y3 X3<=Y3\n    <- plus-total Y1+X2=X\n    <- plus-right-preserves-le* X1<=Y1 X1+X2=X3 Y1+X2=X X3<=X\n    <- plus-left-preserves-le* X2<=Y2 Y1+X2=X Y1+Y2=Y3 X<=Y3\n    <- le-transitive X3<=X X<=Y3 X3<=Y3.\n\n%worlds () (plus-preserves-le* X1<=Y1 X2<=Y2 X1+X2=X3 Y1+Y2=Y3  X3<=Y3).\n%total {} (plus-preserves-le* _ _ _ _ _).\n\n\n%theorem plus-preserves-le :\n\tforall* {X1} {X2} {Y1} {Y2}\n\tforall {G1:le X1 Y1} {G2:le X2 Y2}\n\texists {X3} {Y3} {MX:plus X1 X2 X3} {MY:plus Y1 Y2 Y3} {G3:le X3 Y3}\n\ttrue.\n\n- : plus-preserves-le X1<=Y1 X2<=Y2 X3 Y3 X1+X2=X3 Y1+Y2=Y3 X3<=Y3\n    <- plus-total X1+X2=X3\n    <- plus-total Y1+Y2=Y3\n    <- plus-preserves-le* X1<=Y1 X2<=Y2 X1+X2=X3 Y1+Y2=Y3 X3<=Y3.\n\n%worlds () (plus-preserves-le X1<=Y1 X2<=Y2  X3 Y3 X1+X2=X3 Y1+Y2=Y3 X3<=Y3).\n%total {} (plus-preserves-le _ _ _ _ _ _ _).\n\n\n%theorem plus-right-cancels-le :\n\tforall* {X1} {X2} {X3} {Y1} {Y2} {Y3}\n\tforall {OP1:plus X1 X2 X3} {OP2:plus Y1 Y2 Y3} {E2:eq X2 Y2} {G3:le X3 Y3} \n\texists {G1:le X1 Y1}\n\ttrue.\n\n- : plus-right-cancels-le X1+X2=X3 Y1+Y2=Y3 X2=Y2 X3<=Y3 X1<=Y1\n    <- plus-commutative X1+X2=X3 X2+X1=X3\n    <- plus-commutative Y1+Y2=Y3 Y2+Y1=Y3\n    <- plus-left-cancels-le X2+X1=X3 Y2+Y1=Y3 X2=Y2 X3<=Y3 X1<=Y1.\n\n%worlds () (plus-right-cancels-le X1+X2=X3 Y1+Y2=Y3 X2=Y2 X3<=Y3  X1<=Y1).\n%total {} (plus-right-cancels-le _ _ _ _ _).\n\n\n%theorem times-left-preserves-le* :\n\tforall* {X1} {X2} {X3} {X4} {X5}\n        forall {R1:le X2 X4}\n               {OP1:times X1 X2 X3} {OP2:times X1 X4 X5}\n        exists {R2:le X3 X5}\n\ttrue.\n\n- : times-left-preserves-le* X4>=X2 X1*X2=X3 X1*X4=X5 X5>=X3\n    <- times-left-preserves-ge* X4>=X2 X1*X4=X5 X1*X2=X3 X5>=X3.\n\n%worlds () (times-left-preserves-le* X2<=X4 X1*X2=X3 X1*X4=X5  X3<=X5).\n%total {} (times-left-preserves-le* _ _ _ _).\n\n\n\n%theorem times-left-preserves-le :\n\tforall* {X1} {X2} {X4}\n      \tforall {G:le X2 X4}\n\texists {X3} {X5}\n               {O1:times X1 X2 X3} {O2:times X1 X4 X5}\n      \t       {G2:le X3 X5}\n\ttrue.\n\n- : times-left-preserves-le X2<=X4 X3 X5 X1*X2=A3 X1*X4=X5 X3<=X5\n    <- times-total X1*X2=A3 \n    <- times-total X1*X4=X5\n    <- times-left-preserves-le* X2<=X4 X1*X2=A3 X1*X4=X5 X3<=X5.\n\n%worlds () (times-left-preserves-le X2<=X4  X3 X5 X1*X2=A3 X1*X4=X5 X3<=X5).\n%total {} (times-left-preserves-le _ _ _ _ _ _).\n\n\n%theorem times-right-preserves-le* :\n\tforall* {X1} {X2} {X3} {X4} {X5}\n\tforall {G1:le X1 X2} {O1:times X1 X3 X4} {O2:times X2 X3 X5}\n\texists {G2:le X4 X5}\n\ttrue.\n\n- : times-right-preserves-le* X1<=X2 X1*X3=X4 X2*X3=X5 X4<=X5\n    <- times-commutative X1*X3=X4 X3*X1=X4\n    <- times-commutative X2*X3=X5 X3*X2=X5\n    <- times-left-preserves-le* X1<=X2 X3*X1=X4 X3*X2=X5 X4<=X5.\n\n%worlds () (times-right-preserves-le* X1<=X2 X1*X3=X4 X2*X3=X5  X4<=X5).\n%total {} (times-right-preserves-le* _ _ _ _).\n\n\n%theorem times-right-preserves-le :\n\tforall* {X1} {X2} {X3}\n\tforall {G1:le X1 X2} \n\texists {X4} {X5} {O1:times X1 X3 X4} {O2:times X2 X3 X5} {G2:le X4 X5}\n\ttrue.\n\n- : times-right-preserves-le X1<=X2 X4 X5 X1*X3=X4 X2*X3=X5 X4<=X5\n    <- times-total X1*X3=X4 \n    <- times-total X2*X3=X5\n    <- times-right-preserves-le* X1<=X2 X1*X3=X4 X2*X3=X5 X4<=X5.\n%worlds () (times-right-preserves-le X1<=X2  X4 X5 X1*X3=X4 X2*X3=X5 X4<=X5).\n%total {} (times-right-preserves-le _ _ _ _ _ _).\n\n\n%theorem times-preserves-le* :\n\tforall* {X1} {X2} {X3} {Y1} {Y2} {Y3}\n\tforall {G1:le X1 Y1} {G2:le X2 Y2}\n               {MX:times X1 X2 X3} {MY:times Y1 Y2 Y3}\n        exists {G3:le X3 Y3}\n\ttrue.\n\n- : times-preserves-le* X1<=Y1 X2<=Y2 X1*X2=X3 Y1*Y2=Y3 X3<=Y3\n    <- times-total Y1*X2=X\n    <- times-right-preserves-le* X1<=Y1 X1*X2=X3 Y1*X2=X X3<=X\n    <- times-left-preserves-le* X2<=Y2 Y1*X2=X Y1*Y2=Y3 X<=Y3\n    <- le-transitive X3<=X X<=Y3 X3<=Y3.\n\n%worlds () (times-preserves-le* X1<=Y1 X2<=Y2 X1*X2=X3 Y1*Y2=Y3  X3<=Y3).\n%total {} (times-preserves-le* _ _ _ _ _).\n\n\n%theorem times-preserves-le :\n\tforall* {X1} {X2} {Y1} {Y2}\n\tforall {G1:le X1 Y1} {G2:le X2 Y2}\n\texists {X3} {Y3} {MX:times X1 X2 X3} {MY:times Y1 Y2 Y3} {G3:le X3 Y3}\n\ttrue.\n\n- : times-preserves-le X1<=Y1 X2<=Y2 X3 Y3 X1*X2=X3 Y1*Y2=Y3 X3<=Y3\n    <- times-total X1*X2=X3\n    <- times-total Y1*Y2=Y3\n    <- times-preserves-le* X1<=Y1 X2<=Y2 X1*X2=X3 Y1*Y2=Y3 X3<=Y3.\n\n%worlds () (times-preserves-le X1<=Y1 X2<=Y2  X3 Y3 X1*X2=X3 Y1*Y2=Y3 X3<=Y3).\n%total {} (times-preserves-le _ _ _ _ _ _ _).\n\n\n\n\n\n\n%%%%% nat-inv-comp.elf\n%%%%% Theorems about minus and composed relations\n%%%%% This file is part of the nat.elf signature\n\n\n%%%% Theorems\n\n\n\n%%% Theorems about minus\n\n\n\n%theorem minus-left-inverts-ge* :\n\tforall* {X1} {X2} {X3} {X4} {X5}\n        forall {G:ge X2 X4}\n               {IOP1:minus X1 X2 X3} {IOP2:minus X1 X4 X5}\n        exists {GP:ge X5 X3}\n\ttrue.\n\n- : minus-left-inverts-ge* X2>=X4 X3+X2=X1 X5+X4=X1 X5>=X3\n    <- plus-total X3+X4=X7\n    <- plus-left-preserves-ge* X2>=X4 X3+X2=X1 X3+X4=X7 X1>=X7\n    <- plus-right-cancels-ge X5+X4=X1 X3+X4=X7 eq/ X1>=X7 X5>=X3.\n\n%worlds () (minus-left-inverts-ge* X2>=X4 X1-X2=X3 X1-X4=X5  X5>=X3).\n%total {} (minus-left-inverts-ge* _ _ _ _).\n\n\n%theorem minus-right-preserves-ge* :\n\tforall* {X1} {X2} {X3} {X4} {X5}\n        forall {G:ge X1 X2}\n               {IOP1:minus X1 X3 X4} {IOP2:minus X2 X3 X5}\n        exists {GP:ge X4 X5}\n\ttrue.\n\n- : minus-right-preserves-ge*  X1>=X2 X4+X3=X1 X5+X3=X2 X4>=X5\n    <- plus-right-cancels-ge X4+X3=X1 X5+X3=X2 eq/ X1>=X2 X4>=X5.\n\n%worlds () (minus-right-preserves-ge* X1>=X2 X1-X3=X4 X2-X3=X5  X4>=X5).\n%total {} (minus-right-preserves-ge* _ _ _ _).\n\n\n%theorem minus-left-cancels-inverts-ge :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X6}\n\tforall {IOP1:minus X1 X2 X3} {IOP2:minus X4 X5 X6}\n               {E:eq X1 X4} {G:ge X3 X6}\n        exists {GP:ge X5 X2}\n\ttrue.\n\n- : minus-left-cancels-inverts-ge X3+X2=X1 X6+X5=X4 X1=X4 X3>=X6 X5>=X2\n    <- plus-total X6+X2=X7\n    <- plus-right-preserves-ge* X3>=X6 X3+X2=X1 X6+X2=X7 X1>=X7\n    <- eq-symmetric X1=X4 X4=X1\n    <- plus-respects-eq X6+X5=X4 eq/ eq/ X4=X1 X6+X5=X1\n    <- plus-left-cancels-ge X6+X5=X1 X6+X2=X7 eq/ X1>=X7 X5>=X2.\n\n%worlds () (minus-left-cancels-inverts-ge X1-X2=X3 X4-X5=X6 X1=X4 X3>=X6 \n                                   X5>=X2).\n%total {} (minus-left-cancels-inverts-ge _ _ _ _ _).\n\n\n%theorem minus-right-cancels-ge :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X6}\n\tforall {IOP1:minus X1 X2 X3} {IOP2:minus X4 X5 X6}\n               {E2:eq X2 X5} {G3:ge X3 X6}\n        exists {G1:ge X1 X4}\n\ttrue.\n\n- : minus-right-cancels-ge X3+X2=X1 X6+X5=X4 X2=X5 X3>=X6 X1>=X4\n    <- plus-respects-eq X3+X2=X1 eq/ X2=X5 eq/ X3+X5=X1\n    <- plus-right-preserves-ge* X3>=X6 X3+X5=X1 X6+X5=X4 X1>=X4.\n\n%worlds () (minus-right-cancels-ge X1-X2=X3 X4-X5=X6 X2=X5 X3>=X6 \n                            X1>=X4).\n%total {} (minus-right-cancels-ge _ _ _ _ _).\n\n\n\n%theorem minus-left-preserves-ne* :\n\tforall* {X1} {X2} {X3} {X4} {X5}\n        forall {G:ne X2 X4}\n               {IOP1:minus X1 X2 X3} {IOP2:minus X1 X4 X5}\n        exists {GP:ne X3 X5}\n\ttrue.\n\n- : minus-left-preserves-ne* X2<>X4 X3+X2=X1 X5+X4=X1 X3<>X5\n    <- plus-total X3+X4=X7\n    <- plus-left-preserves-ne* X2<>X4 X3+X2=X1 X3+X4=X7 X1<>X7\n    <- plus-right-cancels-ne X5+X4=X1 X3+X4=X7 eq/ X1<>X7 X5<>X3\n    <- ne-symmetric X5<>X3 X3<>X5.\n\n%worlds () (minus-left-preserves-ne* X2<>X4 X1-X2=X3 X1-X4=X5  X3<>X5).\n%total {} (minus-left-preserves-ne* _ _ _ _).\n\n\n%theorem minus-right-preserves-ne* :\n\tforall* {X1} {X2} {X3} {X4} {X5}\n        forall {G:ne X1 X2}\n               {IOP1:minus X1 X3 X4} {IOP2:minus X2 X3 X5}\n        exists {GP:ne X4 X5}\n\ttrue.\n\n- : minus-right-preserves-ne*  X1<>X2 X4+X3=X1 X5+X3=X2 X4<>X5\n    <- plus-right-cancels-ne X4+X3=X1 X5+X3=X2 eq/ X1<>X2 X4<>X5.\n\n%worlds () (minus-right-preserves-ne* X1<>X2 X1-X3=X4 X2-X3=X5  X4<>X5).\n%total {} (minus-right-preserves-ne* _ _ _ _).\n\n\n%theorem minus-left-cancels-ne :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X6}\n\tforall {IOP1:minus X1 X2 X3} {IOP2:minus X4 X5 X6}\n               {E:eq X1 X4} {G:ne X3 X6}\n        exists {GP:ne X2 X5}\n\ttrue.\n\n- : minus-left-cancels-ne X3+X2=X1 X6+X5=X4 X1=X4 X3<>X6 X2<>X5\n    <- plus-total X6+X2=X7\n    <- plus-right-preserves-ne* X3<>X6 X3+X2=X1 X6+X2=X7 X1<>X7\n    <- eq-symmetric X1=X4 X4=X1\n    <- plus-respects-eq X6+X5=X4 eq/ eq/ X4=X1 X6+X5=X1\n    <- plus-left-cancels-ne X6+X5=X1 X6+X2=X7 eq/ X1<>X7 X5<>X2\n    <- ne-symmetric X5<>X2 X2<>X5.\n\n%worlds () (minus-left-cancels-ne X1-X2=X3 X4-X5=X6 X1=X4 X3<>X6 \n                                   X2<>X5).\n%total {} (minus-left-cancels-ne _ _ _ _ _).\n\n\n%theorem minus-right-cancels-ne :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X6}\n\tforall {IOP1:minus X1 X2 X3} {IOP2:minus X4 X5 X6}\n               {E2:eq X2 X5} {G3:ne X3 X6}\n        exists {G1:ne X1 X4}\n\ttrue.\n\n- : minus-right-cancels-ne X3+X2=X1 X6+X5=X4 X2=X5 X3<>X6 X1<>X4\n    <- plus-respects-eq X3+X2=X1 eq/ X2=X5 eq/ X3+X5=X1\n    <- plus-right-preserves-ne* X3<>X6 X3+X5=X1 X6+X5=X4 X1<>X4.\n\n%worlds () (minus-right-cancels-ne X1-X2=X3 X4-X5=X6 X2=X5 X3<>X6 \n                            X1<>X4).\n%total {} (minus-right-cancels-ne _ _ _ _ _).\n\n\n\n\n\n\n%%%%% nat-inv-less.elf\n%%%%% Theorems about minus and inverted relations\n%%%%% This file is part of the nat.elf signature\n\n\n\n\n%%%% Theorems\n\n\n\n%%% Theorems about minus\n\n\n\n%theorem minus-left-inverts-lt* :\n\tforall* {X1} {X2} {X3} {X4} {X5}\n        forall {G:lt X2 X4}\n               {IOP1:minus X1 X2 X3} {IOP2:minus X1 X4 X5}\n        exists {GP:lt X5 X3}\n\ttrue.\n\n- : minus-left-inverts-lt* X2<X4 X3+X2=X1 X5+X4=X1 X5<X3\n    <- plus-total X3+X4=X7\n    <- plus-left-preserves-lt* X2<X4 X3+X2=X1 X3+X4=X7 X1<X7\n    <- plus-right-cancels-lt X5+X4=X1 X3+X4=X7 eq/ X1<X7 X5<X3.\n\n%worlds () (minus-left-inverts-lt* X2<X4 X1-X2=X3 X1-X4=X5  X5<X3).\n%total {} (minus-left-inverts-lt* _ _ _ _).\n\n\n%theorem minus-right-preserves-lt* :\n\tforall* {X1} {X2} {X3} {X4} {X5}\n        forall {G:lt X1 X2}\n               {IOP1:minus X1 X3 X4} {IOP2:minus X2 X3 X5}\n        exists {GP:lt X4 X5}\n\ttrue.\n\n- : minus-right-preserves-lt*  X1<X2 X4+X3=X1 X5+X3=X2 X4<X5\n    <- plus-right-cancels-lt X4+X3=X1 X5+X3=X2 eq/ X1<X2 X4<X5.\n\n%worlds () (minus-right-preserves-lt* X1<X2 X1-X3=X4 X2-X3=X5  X4<X5).\n%total {} (minus-right-preserves-lt* _ _ _ _).\n\n\n%theorem minus-left-cancels-inverts-lt :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X6}\n\tforall {IOP1:minus X1 X2 X3} {IOP2:minus X4 X5 X6}\n               {E:eq X1 X4} {G:lt X3 X6}\n        exists {GP:lt X5 X2}\n\ttrue.\n\n- : minus-left-cancels-inverts-lt X3+X2=X1 X6+X5=X4 X1=X4 X3<X6 X5<X2\n    <- plus-total X6+X2=X7\n    <- plus-right-preserves-lt* X3<X6 X3+X2=X1 X6+X2=X7 X1<X7\n    <- eq-symmetric X1=X4 X4=X1\n    <- plus-respects-eq X6+X5=X4 eq/ eq/ X4=X1 X6+X5=X1\n    <- plus-left-cancels-lt X6+X5=X1 X6+X2=X7 eq/ X1<X7 X5<X2.\n\n%worlds () (minus-left-cancels-inverts-lt X1-X2=X3 X4-X5=X6 X1=X4 X3<X6 \n                                   X5<X2).\n%total {} (minus-left-cancels-inverts-lt _ _ _ _ _).\n\n\n%theorem minus-right-cancels-lt :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X6}\n\tforall {IOP1:minus X1 X2 X3} {IOP2:minus X4 X5 X6}\n               {E2:eq X2 X5} {G3:lt X3 X6}\n        exists {G1:lt X1 X4}\n\ttrue.\n\n- : minus-right-cancels-lt X3+X2=X1 X6+X5=X4 X2=X5 X3<X6 X1<X4\n    <- plus-respects-eq X3+X2=X1 eq/ X2=X5 eq/ X3+X5=X1\n    <- plus-right-preserves-lt* X3<X6 X3+X5=X1 X6+X5=X4 X1<X4.\n\n%worlds () (minus-right-cancels-lt X1-X2=X3 X4-X5=X6 X2=X5 X3<X6 \n                            X1<X4).\n%total {} (minus-right-cancels-lt _ _ _ _ _).\n\n\n\n%theorem minus-left-inverts-le* :\n\tforall* {X1} {X2} {X3} {X4} {X5}\n        forall {G:le X2 X4}\n               {IOP1:minus X1 X2 X3} {IOP2:minus X1 X4 X5}\n        exists {GP:le X5 X3}\n\ttrue.\n\n- : minus-left-inverts-le* X2<=X4 X3+X2=X1 X5+X4=X1 X5<=X3\n    <- plus-total X3+X4=X7\n    <- plus-left-preserves-le* X2<=X4 X3+X2=X1 X3+X4=X7 X1<=X7\n    <- plus-right-cancels-le X5+X4=X1 X3+X4=X7 eq/ X1<=X7 X5<=X3.\n\n%worlds () (minus-left-inverts-le* X2<=X4 X1-X2=X3 X1-X4=X5  X5<=X3).\n%total {} (minus-left-inverts-le* _ _ _ _).\n\n\n%theorem minus-right-preserves-le* :\n\tforall* {X1} {X2} {X3} {X4} {X5}\n        forall {G:le X1 X2}\n               {IOP1:minus X1 X3 X4} {IOP2:minus X2 X3 X5}\n        exists {GP:le X4 X5}\n\ttrue.\n\n- : minus-right-preserves-le*  X1<=X2 X4+X3=X1 X5+X3=X2 X4<=X5\n    <- plus-right-cancels-le X4+X3=X1 X5+X3=X2 eq/ X1<=X2 X4<=X5.\n\n%worlds () (minus-right-preserves-le* X1<=X2 X1-X3=X4 X2-X3=X5  X4<=X5).\n%total {} (minus-right-preserves-le* _ _ _ _).\n\n\n%theorem minus-left-cancels-inverts-le :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X6}\n\tforall {IOP1:minus X1 X2 X3} {IOP2:minus X4 X5 X6}\n               {E:eq X1 X4} {G:le X3 X6}\n        exists {GP:le X5 X2}\n\ttrue.\n\n- : minus-left-cancels-inverts-le X3+X2=X1 X6+X5=X4 X1=X4 X3<=X6 X5<=X2\n    <- plus-total X6+X2=X7\n    <- plus-right-preserves-le* X3<=X6 X3+X2=X1 X6+X2=X7 X1<=X7\n    <- eq-symmetric X1=X4 X4=X1\n    <- plus-respects-eq X6+X5=X4 eq/ eq/ X4=X1 X6+X5=X1\n    <- plus-left-cancels-le X6+X5=X1 X6+X2=X7 eq/ X1<=X7 X5<=X2.\n\n%worlds () (minus-left-cancels-inverts-le X1-X2=X3 X4-X5=X6 X1=X4 X3<=X6 \n                                   X5<=X2).\n%total {} (minus-left-cancels-inverts-le _ _ _ _ _).\n\n\n%theorem minus-right-cancels-le :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X6}\n\tforall {IOP1:minus X1 X2 X3} {IOP2:minus X4 X5 X6}\n               {E2:eq X2 X5} {G3:le X3 X6}\n        exists {G1:le X1 X4}\n\ttrue.\n\n- : minus-right-cancels-le X3+X2=X1 X6+X5=X4 X2=X5 X3<=X6 X1<=X4\n    <- plus-respects-eq X3+X2=X1 eq/ X2=X5 eq/ X3+X5=X1\n    <- plus-right-preserves-le* X3<=X6 X3+X5=X1 X6+X5=X4 X1<=X4.\n\n%worlds () (minus-right-cancels-le X1-X2=X3 X4-X5=X6 X2=X5 X3<=X6 \n                            X1<=X4).\n%total {} (minus-right-cancels-le _ _ _ _ _).\n\n\n\n\n\n\n%%%%% nat-divrem.elf\n%%%%% Integer quotient/remainder division\n%%%%% This file is part of the nat.elf signature\n\n\n\n%%%% Definitions\n\n\n\n%%% Division with remainder\n\n\ndivrem : nat -> nat -> nat -> nat -> type.\n\n\ndivrem/z : divrem M N z M\n    <- gt N M.\n\ndivrem/s : divrem M (s N-) (s Q) R\n    <- plus D (s N-) M\n    <- divrem D (s N-) Q R.\n\n\n\n\n%%%% Theorems\n\n\n%%% Theorems about divrem\n\n\n%theorem false-implies-divrem :\n\tforall* {M} {N} {Q} {R}\n\tforall {F:void}\n\texists {D:divrem M N Q R}\n\ttrue.\n\n%worlds () (false-implies-divrem _  M/N=Q,R).\n%total {} (false-implies-divrem _ _).\n\n\n%theorem divrem-respects-eq :\n\tforall* {M} {N} {Q} {R} {M'} {N'} {Q'} {R'}\n\tforall {D:divrem M N Q R} \n               {E1:eq M M'} {E2:eq N N'} {E3:eq Q Q'} {E4:eq R R'}\n\texists {D':divrem M' N' Q' R'}\n\ttrue.\n\n- : divrem-respects-eq D eq/ eq/ eq/ eq/ D.\n\n%worlds () (divrem-respects-eq M/N=Q,R M=M' N=N' Q=Q' R=R'  M'/N'=Q',R').\n%total {} (divrem-respects-eq _ _ _ _ _ _).\n\n\n%theorem divrem-total** :\n\tforall {M} {N-1} {C} {CMP:compare M N-1 C}\n\texists {Q} {R} {D:divrem M (s N-1) Q R}\n\ttrue.\n\n- : divrem-total** M N-1 equal CMP z M (divrem/z N>M)\n    <- equal-implies-eq CMP M=N-1\n    <- succ-implies-gt eq/ N>N-1\n    <- eq-symmetric M=N-1 N-1=M\n    <- gt-respects-eq N>N-1 eq/ N-1=M N>M.\n\n- : divrem-total** M N-1 less CMP z M (divrem/z N>M)\n    <- less-implies-lt CMP N-1>M\n    <- succ-implies-gt eq/ N>N-1\n    <- gt-transitive N>N-1 N-1>M N>M.\n\n- : divrem-total** M N-1 greater CMP (s Q) R (divrem/s D/N=Q,R D+N=M)\n    <- greater-implies-gt CMP M>N-1\n    <- gt-implies-plus M>N-1 D SD+N-1=M\n    <- plus-swap-succ SD+N-1=M D+N=M\n    <- plus-commutative D+N=M N+D=M\n    <- plus-implies-gt N+D=M eq/ M>D\n    <- meta-gt M D M>D\n    <- compare-total* D N-1 C' CMP'\n    <- divrem-total** D N-1 C' CMP' Q R D/N=Q,R.\n\n%worlds () (divrem-total** M N-1 C MCN  Q R M/N=Q,R).\n%total (M) (divrem-total** M _ _ _ _ _ _).\n\n\n%theorem divrem-total* :\n\tforall {M} {N-}\n\texists {Q} {R} {D:divrem M (s N-) Q R}\n\ttrue.\n\n- : divrem-total* M N-1 Q R M/N=Q,R\n    <- compare-total* M N-1 C CMP\n    <- divrem-total** M N-1 C CMP Q R M/N=Q,R.\n\n%worlds () (divrem-total* M N-1  Q R M/N=Q,R).\n%total {} (divrem-total* _ _ _ _ _).\n\n\n%abbrev divrem-total = divrem-total* _ _ _ _.\n\n\n%theorem divrem-deterministic :\n\tforall* {M} {N} {Q} {R} {M'} {N'} {Q'} {R'}\n\tforall {D:divrem M N Q R} {D':divrem M' N' Q' R'}\n\t       {E1:eq M M'} {E2:eq N N'}\n\texists {E3:eq Q Q'} {E4:eq R R'}\n\ttrue.\n\n- : divrem-deterministic (divrem/z _) (divrem/z _) eq/ eq/ eq/ eq/.\n\n- : divrem-deterministic (divrem/s D/N=Q,R D+N=M) (divrem/s D'/N=Q',R' D'+N=M)\n                         eq/ eq/ SQ=SQ' R=R'\n    <- plus-right-cancels D+N=M D'+N=M eq/ eq/ D=D'\n    <- divrem-deterministic D/N=Q,R  D'/N=Q',R' D=D' eq/ Q=Q' R=R'\n    <- succ-deterministic Q=Q' SQ=SQ'.\n\n%% contradiction cases:\n\n- : divrem-deterministic (divrem/z N>M) (divrem/s _ D+N=M) eq/ eq/ Q=Q' R=R'\n    <- plus-commutative D+N=M N+D=M\n    <- plus-gt-contradiction N+D=M N>M F\n    <- false-implies-eq F Q=Q'\n    <- false-implies-eq F R=R'.\n\n- : divrem-deterministic (divrem/s _ D+N=M) (divrem/z N>M) eq/ eq/ Q=Q' R=R'\n    <- plus-commutative D+N=M N+D=M\n    <- plus-gt-contradiction N+D=M N>M F\n    <- false-implies-eq F Q=Q'\n    <- false-implies-eq F R=R'.\n\n%worlds () (divrem-deterministic M/N=Q,R M'/N'=Q'/R' M=M' N=N'  Q=Q' R=R').\n%total (D) (divrem-deterministic D _ _ _ _ _).\n\n\n%theorem divrem-implies-positive :\n\tforall* {M} {N} {Q} {R}\n\tforall {D:divrem M N Q R}\n\texists {N-1} {E:eq N (s N-1)}\n\ttrue.\n\n- : divrem-implies-positive (divrem/z N>M) N-1 N=sN-1\n    <- gt-implies-positive N>M N-1 N=sN-1.\n\n- : divrem-implies-positive (divrem/s _ _) _ eq/.\n\n%worlds () (divrem-implies-positive M/N=Q,R  N-1 N=sN-1).\n%total {} (divrem-implies-positive _ _ _).\n\n\n%theorem divrem-implies-gt :\n\tforall* {M} {N} {Q} {R}\n\tforall {D:divrem M N Q R}\n\texists {G:gt N R}\n\ttrue.\n\n- : divrem-implies-gt (divrem/z N>M) N>M.\n\n- : divrem-implies-gt (divrem/s D/N=Q,R _) N>R\n    <- divrem-implies-gt D/N=Q,R N>R.\n\n%worlds () (divrem-implies-gt M/N=Q,R  N>R).\n%total D (divrem-implies-gt D _).\n\n\n%theorem divrem-contradiction :\n\tforall* {M} {N} {Q} {R} {X}\n\tforall\t{D:divrem M N Q R}\n\t\t{P:plus N X R}\n\texists\t{F:void}\n\ttrue.\n\n- : divrem-contradiction D P F\n    <- divrem-implies-gt D N>R\n    <- plus-commutative P Pc\n    <- plus-implies-ge Pc R>=N\n    <- gt-transitive-ge N>R R>=N N>N\n    <- gt-anti-reflexive N>N F.\n\n%worlds () (divrem-contradiction _ _ _).\n%total { } (divrem-contradiction _ _ _).\n   \n\n%theorem divrem-can-be-inverted :\n\tforall* {M} {N} {Q} {R}\n\tforall {D:divrem M N Q R}\n\texists {X} {T:times Q N X} {P:plus X R M}\n\ttrue.\n\n- : divrem-can-be-inverted (divrem/z _) z times/z plus/z.\n\n- : divrem-can-be-inverted (divrem/s D/N=Q,R D+N=M) \n                           X (times/s Q*N=Y Y+N=X) X+R=M\n    <- divrem-can-be-inverted D/N=Q,R Y Q*N=Y Y+R=D\n    <- plus-commutative Y+R=D R+Y=D\n    <- plus-associative R+Y=D D+N=M X Y+N=X R+X=M\n    <- plus-commutative R+X=M X+R=M.\n\n%worlds () (divrem-can-be-inverted M/N=Q,R  X Q*N=X X+R=M).\n%total (D) (divrem-can-be-inverted D _ _ _).\n\n\n%theorem div-can-be-inverted :\n\tforall* {M} {N} {Q}\n\tforall {D:divrem M N Q z}\n\texists {T:times Q N M}\n\ttrue.\n\n- : div-can-be-inverted (divrem/z _) times/z.\n\n- : div-can-be-inverted (divrem/s D/N=Q,z D+N=M) \n                        (times/s Q*N=D D+N=M)\n    <- div-can-be-inverted D/N=Q,z Q*N=D.\n\n%worlds () (div-can-be-inverted _ _).\n%total (D) (div-can-be-inverted D _).\n\n\n%theorem divrem-can-be-constructed :\n\tforall* {M} {N} {Q} {R} {X}\n\tforall {T:times Q N X} {P:plus X R M} {G:gt N R}\n        exists {D:divrem M N Q R}\n\ttrue.\n\n- : divrem-can-be-constructed (times/z) (plus/z) N>R (divrem/z N>R).\n\n- : divrem-can-be-constructed (times/s Q*N=Y Y+N=X) X+R=M N>R\n                              (divrem/s Z/N=Q,R Z+N=M)\n    <- plus-commutative Y+N=X N+Y=X\n    <- plus-associative N+Y=X X+R=M Z Y+R=Z N+Z=M\n    <- plus-commutative N+Z=M Z+N=M\n    <- divrem-can-be-constructed Q*N=Y Y+R=Z N>R Z/N=Q,R.\n\n- : divrem-can-be-constructed _ _ ZERO>R D\n    <- gt-contradiction ZERO>R F\n    <- false-implies-divrem F D.\n\n%worlds () (divrem-can-be-constructed Q*N=X X+R=M N>R  M/N=Q,R).\n%total (T) (divrem-can-be-constructed T _ _ _).\n\n\n%theorem div-can-be-constructed :\n\tforall* {M} {N} {Q}\n\tforall {T:times Q (s N) M}\n        exists {D:divrem M (s N) Q z}\n\ttrue.\n\n- : div-can-be-constructed (times/z) (divrem/z N+1>0)\n    <- succ-implies-gt-zero _ N+1>0.\n\n- : div-can-be-constructed (times/s Q*sN=D D+sN=M)\n                           (divrem/s D/sN=Q,z D+sN=M)\n    <- div-can-be-constructed Q*sN=D D/sN=Q,z.\n\n%worlds () (div-can-be-constructed _ _).\n%total (T) (div-can-be-constructed T _).\n\n\n%theorem remainder-implies-gt-quotient :\n\tforall* {M} {N} {Q} {R}\n\tforall {D:divrem M N Q (s R)}\n\texists {G:gt M Q}\n\ttrue.\n\n- : remainder-implies-gt-quotient (divrem/z _) R+1>0\n    <- succ-implies-gt-zero _ R+1>0.\n\n- : remainder-implies-gt-quotient (divrem/s D/N=Q,sR D+N=M) M>sQ\n    <- remainder-implies-gt-quotient D/N=Q,sR D>Q\n    <- gt-implies-ge-succ D>Q D>=sQ\n    <- plus-commutative D+N=M N+D=M\n    <- plus-implies-gt N+D=M eq/ M>D\n    <- gt-transitive-ge M>D D>=sQ M>sQ.\n\n%worlds () (remainder-implies-gt-quotient _ _).\n%total (D) (remainder-implies-gt-quotient D _).\n\n\n%theorem quotient-of-nonzero-is-smaller :\n\tforall* {M} {N} {Q} {R} {M-}\n\tforall {DR:divrem M (s (s N)) Q R} {EN:eq M (s M-)}\n\texists {G:gt M Q}\n\ttrue.\n\n- : quotient-of-nonzero-is-smaller _ eq/ M>0\n    <- succ-implies-gt-zero _ M>0.\n\n- : quotient-of-nonzero-is-smaller M/N=Q,R eq/ M>Q\n    <- divrem-can-be-inverted M/N=Q,R X Q*N=X X+R=M\n    <- times-right-identity _ Q*1=Q\n    <- succ-implies-gt-zero _ N->0\n    <- succ-preserves-gt N->0 N>1\n    <- times-left-preserves-gt N>1 Q*N=X Q*1=Q X>Q\n    <- plus-commutative X+R=M R+X=M\n    <- plus-implies-ge R+X=M M>=X\n    <- ge-transitive-gt M>=X X>Q M>Q.\n\n%worlds () (quotient-of-nonzero-is-smaller _ _ _).\n%total { } (quotient-of-nonzero-is-smaller _ _ _).\n\n\n%theorem quotient-is-no-greater :\n\tforall* {M} {N} {Q} {R}\n\tforall {DR:divrem M N Q R}\n\texists {ge:ge M Q}\n\ttrue.\n\n- : quotient-is-no-greater M/N=Q,R M>=Q\n    <- divrem-can-be-inverted M/N=Q,R X Q*N=X X+R=M\n    <- divrem-implies-positive M/N=Q,R NN N=NN+1\n    <- eq-symmetric N=NN+1 NN+1=N\n    <- succ-implies-gt-zero NN NN+1>0\n    <- gt-respects-eq NN+1>0 NN+1=N eq/ N>0\n    <- gt-implies-ge-succ N>0 N>=1\n    <- times-right-identity _ Q*1=Q\n    <- times-left-preserves-ge* N>=1 Q*N=X Q*1=Q X>=Q\n    <- plus-commutative X+R=M R+X=M\n    <- plus-implies-ge R+X=M M>=X\n    <- ge-transitive M>=X X>=Q M>=Q.\n\n%worlds () (quotient-is-no-greater _ _).\n%total { } (quotient-is-no-greater _ _).\n\n\n\n%%%%% minmax.elf\n%%%%% Minimum and Maximum functor\n%%%%% John Boyland\n\n\n\n\n\n%%%% Definitions\n\n\nmin : nat -> nat -> nat -> type.\n\n\nmin/= : min X X X.\n\nmin/> : gt X1 X2 -> min X1 X2 X2.\n\nmin/< : gt X2 X1 -> min X1 X2 X1.\n\n\n\nmax : nat -> nat -> nat -> type.\n\n\nmax/= : max X X X.\n\nmax/> : gt X1 X2 -> max X1 X2 X1.\n\nmax/< : gt X2 X1 -> max X1 X2 X2.\n\n\n\n\n%%%% Theorems\n\n\n\n%%% Theorems about min\n\n\n%theorem false-implies-min :\n\tforall* {X1} {X2} {X3}\n\tforall {F:void}\n\texists {M:min X1 X2 X3}\n\ttrue.\n\n%worlds () (false-implies-min _ _).\n%total { } (false-implies-min _ _).\n\n\n%theorem min-respects-eq :\n\tforall* {X1} {X2} {X3}\n\t\t{Y1} {Y2} {Y3}\n\tforall {MX:min X1 X2 X3}\n\t       {E1:eq X1 Y1} {E2:eq X2 Y2} {E3:eq X3 Y3}\n\texists {MY:min Y1 Y2 Y3}\n\ttrue.\n\n- : min-respects-eq M eq/ eq/ eq/ M.\n\n%worlds () (min-respects-eq _ _ _ _ _).\n%total { } (min-respects-eq _ _ _ _ _).\n\n\n%theorem min-total** :\n\tforall* {X1} {X2} {C}\n\tforall {D:compare X1 X2 C}\n\texists {X3} {M:min X1 X2 X3}\n\ttrue.\n\n- : min-total** compare/= _ min/=.\n\n- : min-total** (compare/> X1>X2) _ (min/> X1>X2).\n\n- : min-total** (compare/< X2>X1) _ (min/< X2>X1).\n\n%worlds () (min-total** _ _ _).\n%total { } (min-total** _ _ _).\n\n\n%theorem min-total* :\n\tforall {X1} {X2}\n\texists {X3} {M:min X1 X2 X3}\n\ttrue.\n\n- : min-total* X1 X2 X3 M\n    <- compare-total D\n    <- min-total** D X3 M.\n\n%worlds () (min-total* _ _ _ _).\n%total { } (min-total* _ _ _ _).\n\n\n%abbrev min-total = min-total* _ _ _.\n\n\n%theorem min-deterministic :\n\tforall* {X1} {X2} {X3}\n\t\t{Y1} {Y2} {Y3}\n\tforall {MX:min X1 X2 X3}\n\t       {MY:min Y1 Y2 Y3}\n\t       {E1:eq X1 Y1} {E2:eq X2 Y2}\n\texists {E3:eq X3 Y3}\n\ttrue.\n\n- : min-deterministic (min/=) (min/=) eq/ eq/ eq/.\n\n- : min-deterministic (min/=) (min/> X>X) eq/ eq/ eq/.\n\n- : min-deterministic (min/=) (min/< X>X) eq/ eq/ eq/.\n\n- : min-deterministic (min/> X>X) (min/=) eq/ eq/ eq/.\n\n- : min-deterministic (min/> X>Y) (min/> X>YP) eq/ eq/ eq/.\n\n- : min-deterministic (min/> X>Y) (min/< Y>X) eq/ eq/ E\n    <- gt-anti-symmetric X>Y Y>X F\n    <- false-implies-eq F E.\n\n- : min-deterministic (min/< X>X) (min/=) eq/ eq/ eq/.\n\n- : min-deterministic (min/< X>Y) (min/> Y>X) eq/ eq/ E\n    <- gt-anti-symmetric X>Y Y>X F\n    <- false-implies-eq F E.\n\n- : min-deterministic (min/< X>Y) (min/< X>YP) eq/ eq/ eq/.\n\n%worlds () (min-deterministic _ _ _ _ _).\n%total { } (min-deterministic _ _ _ _ _).\n\n\n%theorem min-commutative :\n\tforall* {X1} {X2} {X3}\n\tforall {M:min X1 X2 X3}\n\texists {Mc:min X2 X1 X3}\n\ttrue.\n\n- : min-commutative min/= min/=.\n\n- : min-commutative (min/> X>Y) (min/< X>Y).\n\n- : min-commutative (min/< X>Y) (min/> X>Y).\n\n%worlds () (min-commutative _ _).\n%total { } (min-commutative _ _).\n\n\n%theorem ge-implies-min :\n\tforall* {X1} {X2}\n\tforall {G:ge X1 X2}\n\texists {M:min X1 X2 X2}\n\ttrue.\n\n- : ge-implies-min (ge/> X1>X2) (min/> X1>X2).\n\n- : ge-implies-min (ge/= eq/) (min/=).\n\n%worlds () (ge-implies-min _ _).\n%total { } (ge-implies-min _ _).\n\n\n%theorem le-implies-min :\n\tforall* {X1} {X2}\n\tforall {G:le X1 X2}\n\texists {M:min X1 X2 X1}\n\ttrue.\n\n- : le-implies-min X2>=X1 M\n    <- ge-implies-min X2>=X1 Mc\n    <- min-commutative Mc M.\n\n%worlds () (le-implies-min _ _).\n%total { } (le-implies-min _ _).\n\n\n%theorem min-implies-ge :\n\tforall* {X1} {X2} {X3}\n\tforall {M:min X1 X2 X3}\n\texists {G1:ge X1 X3} {G2:ge X2 X3}\n\ttrue.\n\n- : min-implies-ge min/= (ge/= eq/) (ge/= eq/).\n\n- : min-implies-ge (min/> X1>X2) (ge/> X1>X2) (ge/= eq/).\n\n- : min-implies-ge (min/< X2>X1) (ge/= eq/) (ge/> X2>X1).\n\n%worlds () (min-implies-ge _ _ _).\n%total { } (min-implies-ge _ _ _).\n\n\n%theorem min-left-preserves-ge* :\n\tforall* {X1} {X2} {X3} {X4} {X5} \n\tforall {G:ge X2 X4}\n\t       {M12:min X1 X2 X3} \n\t       {M14:min X1 X4 X5}\n\texists {G:ge X3 X5}\n\ttrue.\n\n- : min-left-preserves-ge* _ min/= M G\n    <- min-implies-ge M G _.\n\n- : min-left-preserves-ge* X2>=X4 (min/> X1>X2) X1&X4=X5 X2>=X5\n    <- min-implies-ge X1&X4=X5 _ X4>=X5\n    <- ge-transitive X2>=X4 X4>=X5 X2>=X5.\n\n- : min-left-preserves-ge* _ (min/< _) X1&X4=X5 X1>=X5\n    <- min-implies-ge X1&X4=X5 X1>=X5 _.\n\n%worlds () (min-left-preserves-ge* _ _ _ _).\n%total { } (min-left-preserves-ge* _ _ _ _).\n\n\n%theorem min-left-preserves-le* :\n\tforall* {X1} {X2} {X3} {X4} {X5} \n\tforall {G:le X2 X4}\n\t       {M12:min X1 X2 X3} \n\t       {M14:min X1 X4 X5}\n\texists {G:le X3 X5}\n\ttrue.\n\n- : min-left-preserves-le* G1 M12 M14 G2\n    <- min-left-preserves-ge* G1 M14 M12 G2.\n\n%worlds () (min-left-preserves-le* _ _ _ _).\n%total { } (min-left-preserves-le* _ _ _ _).\n\n\n\n%theorem min-left-preserves-ge :\n\tforall* {X1} {X2} {X4}\n      \tforall {G:ge X2 X4}\n\texists {X3} {X5}\n               {O1:min X1 X2 X3} {O2:min X1 X4 X5}\n      \t       {G2:ge X3 X5}\n\ttrue.\n\n- : min-left-preserves-ge X2>=X4 X3 X5 X1&X2=A3 X1&X4=X5 X3>=X5\n    <- min-total X1&X2=A3 \n    <- min-total X1&X4=X5\n    <- min-left-preserves-ge* X2>=X4 X1&X2=A3 X1&X4=X5 X3>=X5.\n\n%worlds () (min-left-preserves-ge X2>=X4  X3 X5 X1&X2=A3 X1&X4=X5 X3>=X5).\n%total {} (min-left-preserves-ge _ _ _ _ _ _).\n\n\n%theorem min-right-preserves-ge* :\n\tforall* {X1} {X2} {X3} {X4} {X5}\n\tforall {G1:ge X1 X2} {O1:min X1 X3 X4} {O2:min X2 X3 X5}\n\texists {G2:ge X4 X5}\n\ttrue.\n\n- : min-right-preserves-ge* X1>=X2 X1&X3=X4 X2&X3=X5 X4>=X5\n    <- min-commutative X1&X3=X4 X3&X1=X4\n    <- min-commutative X2&X3=X5 X3&X2=X5\n    <- min-left-preserves-ge* X1>=X2 X3&X1=X4 X3&X2=X5 X4>=X5.\n\n%worlds () (min-right-preserves-ge* X1>=X2 X1&X3=X4 X2&X3=X5  X4>=X5).\n%total {} (min-right-preserves-ge* _ _ _ _).\n\n\n%theorem min-right-preserves-ge :\n\tforall* {X1} {X2} {X3}\n\tforall {G1:ge X1 X2} \n\texists {X4} {X5} {O1:min X1 X3 X4} {O2:min X2 X3 X5} {G2:ge X4 X5}\n\ttrue.\n\n- : min-right-preserves-ge X1>=X2 X4 X5 X1&X3=X4 X2&X3=X5 X4>=X5\n    <- min-total X1&X3=X4 \n    <- min-total X2&X3=X5\n    <- min-right-preserves-ge* X1>=X2 X1&X3=X4 X2&X3=X5 X4>=X5.\n%worlds () (min-right-preserves-ge X1>=X2  X4 X5 X1&X3=X4 X2&X3=X5 X4>=X5).\n%total {} (min-right-preserves-ge _ _ _ _ _ _).\n\n\n%theorem min-preserves-ge* :\n\tforall* {X1} {X2} {X3} {Y1} {Y2} {Y3}\n\tforall {G1:ge X1 Y1} {G2:ge X2 Y2}\n               {MX:min X1 X2 X3} {MY:min Y1 Y2 Y3}\n        exists {G3:ge X3 Y3}\n\ttrue.\n\n- : min-preserves-ge* X1>=Y1 X2>=Y2 X1&X2=X3 Y1&Y2=Y3 X3>=Y3\n    <- min-total Y1&X2=X\n    <- min-right-preserves-ge* X1>=Y1 X1&X2=X3 Y1&X2=X X3>=X\n    <- min-left-preserves-ge* X2>=Y2 Y1&X2=X Y1&Y2=Y3 X>=Y3\n    <- ge-transitive X3>=X X>=Y3 X3>=Y3.\n\n%worlds () (min-preserves-ge* X1>=Y1 X2>=Y2 X1&X2=X3 Y1&Y2=Y3  X3>=Y3).\n%total {} (min-preserves-ge* _ _ _ _ _).\n\n\n%theorem min-preserves-ge :\n\tforall* {X1} {X2} {Y1} {Y2}\n\tforall {G1:ge X1 Y1} {G2:ge X2 Y2}\n\texists {X3} {Y3} {MX:min X1 X2 X3} {MY:min Y1 Y2 Y3} {G3:ge X3 Y3}\n\ttrue.\n\n- : min-preserves-ge X1>=Y1 X2>=Y2 X3 Y3 X1&X2=X3 Y1&Y2=Y3 X3>=Y3\n    <- min-total X1&X2=X3\n    <- min-total Y1&Y2=Y3\n    <- min-preserves-ge* X1>=Y1 X2>=Y2 X1&X2=X3 Y1&Y2=Y3 X3>=Y3.\n\n%worlds () (min-preserves-ge X1>=Y1 X2>=Y2  X3 Y3 X1&X2=X3 Y1&Y2=Y3 X3>=Y3).\n%total {} (min-preserves-ge _ _ _ _ _ _ _).\n\n\n\n%theorem min-left-preserves-le :\n\tforall* {X1} {X2} {X4}\n      \tforall {G:le X2 X4}\n\texists {X3} {X5}\n               {O1:min X1 X2 X3} {O2:min X1 X4 X5}\n      \t       {G2:le X3 X5}\n\ttrue.\n\n- : min-left-preserves-le X2<=X4 X3 X5 X1&X2=A3 X1&X4=X5 X3<=X5\n    <- min-total X1&X2=A3 \n    <- min-total X1&X4=X5\n    <- min-left-preserves-le* X2<=X4 X1&X2=A3 X1&X4=X5 X3<=X5.\n\n%worlds () (min-left-preserves-le X2<=X4  X3 X5 X1&X2=A3 X1&X4=X5 X3<=X5).\n%total {} (min-left-preserves-le _ _ _ _ _ _).\n\n\n%theorem min-right-preserves-le* :\n\tforall* {X1} {X2} {X3} {X4} {X5}\n\tforall {G1:le X1 X2} {O1:min X1 X3 X4} {O2:min X2 X3 X5}\n\texists {G2:le X4 X5}\n\ttrue.\n\n- : min-right-preserves-le* X1<=X2 X1&X3=X4 X2&X3=X5 X4<=X5\n    <- min-commutative X1&X3=X4 X3&X1=X4\n    <- min-commutative X2&X3=X5 X3&X2=X5\n    <- min-left-preserves-le* X1<=X2 X3&X1=X4 X3&X2=X5 X4<=X5.\n\n%worlds () (min-right-preserves-le* X1<=X2 X1&X3=X4 X2&X3=X5  X4<=X5).\n%total {} (min-right-preserves-le* _ _ _ _).\n\n\n%theorem min-right-preserves-le :\n\tforall* {X1} {X2} {X3}\n\tforall {G1:le X1 X2} \n\texists {X4} {X5} {O1:min X1 X3 X4} {O2:min X2 X3 X5} {G2:le X4 X5}\n\ttrue.\n\n- : min-right-preserves-le X1<=X2 X4 X5 X1&X3=X4 X2&X3=X5 X4<=X5\n    <- min-total X1&X3=X4 \n    <- min-total X2&X3=X5\n    <- min-right-preserves-le* X1<=X2 X1&X3=X4 X2&X3=X5 X4<=X5.\n%worlds () (min-right-preserves-le X1<=X2  X4 X5 X1&X3=X4 X2&X3=X5 X4<=X5).\n%total {} (min-right-preserves-le _ _ _ _ _ _).\n\n\n%theorem min-preserves-le* :\n\tforall* {X1} {X2} {X3} {Y1} {Y2} {Y3}\n\tforall {G1:le X1 Y1} {G2:le X2 Y2}\n               {MX:min X1 X2 X3} {MY:min Y1 Y2 Y3}\n        exists {G3:le X3 Y3}\n\ttrue.\n\n- : min-preserves-le* X1<=Y1 X2<=Y2 X1&X2=X3 Y1&Y2=Y3 X3<=Y3\n    <- min-total Y1&X2=X\n    <- min-right-preserves-le* X1<=Y1 X1&X2=X3 Y1&X2=X X3<=X\n    <- min-left-preserves-le* X2<=Y2 Y1&X2=X Y1&Y2=Y3 X<=Y3\n    <- le-transitive X3<=X X<=Y3 X3<=Y3.\n\n%worlds () (min-preserves-le* X1<=Y1 X2<=Y2 X1&X2=X3 Y1&Y2=Y3  X3<=Y3).\n%total {} (min-preserves-le* _ _ _ _ _).\n\n\n%theorem min-preserves-le :\n\tforall* {X1} {X2} {Y1} {Y2}\n\tforall {G1:le X1 Y1} {G2:le X2 Y2}\n\texists {X3} {Y3} {MX:min X1 X2 X3} {MY:min Y1 Y2 Y3} {G3:le X3 Y3}\n\ttrue.\n\n- : min-preserves-le X1<=Y1 X2<=Y2 X3 Y3 X1&X2=X3 Y1&Y2=Y3 X3<=Y3\n    <- min-total X1&X2=X3\n    <- min-total Y1&Y2=Y3\n    <- min-preserves-le* X1<=Y1 X2<=Y2 X1&X2=X3 Y1&Y2=Y3 X3<=Y3.\n\n%worlds () (min-preserves-le X1<=Y1 X2<=Y2  X3 Y3 X1&X2=X3 Y1&Y2=Y3 X3<=Y3).\n%total {} (min-preserves-le _ _ _ _ _ _ _).\n\n\n%theorem min-is-glb :\n\tforall* {X1} {X2} {X3} {X4}\n\tforall {M:min X1 X2 X3}\n\t       {G1:ge X1 X4}\n\t       {G2:ge X2 X4}\n\texists {G3:ge X3 X4}\n\ttrue.\n\n- : min-is-glb min/= G _ G.\n\n- : min-is-glb (min/> X1>X2) _ G G.\n\n- : min-is-glb (min/< X2>X1) G _ G.\n\n%worlds () (min-is-glb _ _ _ _).\n%total { } (min-is-glb _ _ _ _).\n\n\n%theorem min-associative :\n\tforall* {X1} {X2} {X3} {X4} {X7}\n\tforall {M12:min X1 X2 X3}\n\t       {M34:min X3 X4 X7}\n\texists {X6} {M24:min X2 X4 X6}\n\t       {M16:min X1 X6 X7}\n\ttrue.\n\n- : min-associative min/= min/= _ min/= min/=.\n\n- : min-associative min/= (min/> X3>X4) _ (min/> X3>X4) (min/> X3>X4).\n\n- : min-associative min/= (min/< X4>X3) _ (min/< X4>X3) (min/=).\n\n- : min-associative (min/> X1>X2) min/= _ (min/=) (min/> X1>X2).\n\n- : min-associative (min/> X1>X2) (min/> X2>X4) _ (min/> X2>X4) (min/> X1>X4)\n    <- gt-transitive X1>X2 X2>X4 X1>X4.\n\n- : min-associative (min/> X1>X2) (min/< X4>X2) _ (min/< X4>X2) (min/> X1>X2).\n\n- : min-associative (min/< X2>X1) min/= _ (min/> X2>X1) min/=.\n\n- : min-associative (min/< X2>X1) (min/> X1>X4) _ (min/> X2>X4) (min/> X1>X4)\n    <- gt-transitive X2>X1 X1>X4 X2>X4.\n\n- : min-associative (min/< X2>X1) (min/< X4>X1) _ M24 M16\n    <- min-total M24\n    <- min-is-glb M24 (ge/> X2>X1) (ge/> X4>X1) (X6>=X1: ge X6 X1)\n    <- ge-implies-min X6>=X1 M16c\n    <- min-commutative M16c M16.\n\n%worlds () (min-associative _ _ _ _ _).\n%total { } (min-associative _ _ _ _ _).\n\n\n%theorem min-associative* :\n\tforall* {X1} {X2} {X12} {X3} {X23} {X123}\n        forall {OP12:min X1 X2 X12} {OP12-3:min X12 X3 X123} {OP23:min X2 X3 X23}\n        exists {OP1-23:min X1 X23 X123}\n        true.\n\n- : min-associative* X1&X2=X3 X3&X4=X7 X2&X4=X6 X1&X6=X7\n    <- min-associative X1&X2=X3 X3&X4=X7 Y6 X2&X4=Y6 X1&Y6=X7\n    <- min-deterministic X2&X4=Y6 X2&X4=X6 eq/ eq/ Y6=X6\n    <- min-respects-eq X1&Y6=X7 eq/ Y6=X6 eq/ X1&X6=X7.\n\n%worlds () (min-associative* _ _ _ _).\n%total {} (min-associative* _ _ _ _).\n\n\n%theorem min-associative-converse :\n\tforall* {X1} {X2} {X4} {X6} {X7}\n\tforall {OP24:min X2 X4 X6} {OP16:min X1 X6 X7}\n        exists {X3} {OP12:min X1 X2 X3} {OP34:min X3 X4 X7}\n        true.\n\n- : min-associative-converse X2&X4=X6 X1&X6=X7 _ X1&X2=X3 X3&X4=X7\n    <- min-commutative X2&X4=X6 X4&X2=X6\n    <- min-commutative X1&X6=X7 X6&X1=X7\n    <- min-associative X4&X2=X6 X6&X1=X7 _ X2&X1=X3 X4&X3=X7\n    <- min-commutative X2&X1=X3 X1&X2=X3\n    <- min-commutative X4&X3=X7 X3&X4=X7.\n\n%worlds () (min-associative-converse X2&X4=X6 X1&X6=X7 X3 X1&X2=X3 X3&X4=X7).\n%total {} (min-associative-converse _ _ _ _ _).\n\n\n%theorem min-associative-converse* :\n\tforall* {X1} {X2} {X3} {X4} {X6} {X7}\n\tforall {OP24:min X2 X4 X6} {OP16:min X1 X6 X7} {OP12:min X1 X2 X3} \n\texists {OP34:min X3 X4 X7}\n        true.\n\n- : min-associative-converse* X2&X4=X6 X1&X6=X7 X1&X2=X3 X3&X4=X7\n    <- min-associative-converse X2&X4=X6 X1&X6=X7 X3P X1&X2=X3P X3P&X4=X7\n    <- min-deterministic X1&X2=X3P X1&X2=X3 eq/ eq/ X3P=X3\n    <- min-respects-eq X3P&X4=X7 X3P=X3 eq/ eq/ X3&X4=X7.\n\n%worlds () (min-associative-converse* X2&X4=X6 X1&X6=X7 X1&X2=X3  X3&X4=X7).\n%total {} (min-associative-converse* _ _ _ _).\n\n\n%theorem min-assoc-commutative* :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X7}\n\tforall {OP1:min X1 X2 X3} {OP2:min X3 X4 X7}\n               {OP3:min X1 X4 X5} \n        exists {OP4:min X5 X2 X7}\n\ttrue.\n\n- : min-assoc-commutative* X1&X2=X3 X3&X4=X7 X1&X4=X5 X5&X2=X7\n    <- min-associative X1&X2=X3 X3&X4=X7 X6 X2&X4=X6 X1&X6=X7\n    <- min-commutative X2&X4=X6 X4&X2=X6\n    <- min-associative-converse* X4&X2=X6 X1&X6=X7 X1&X4=X5 X5&X2=X7.\n\n%worlds () (min-assoc-commutative* X1&X2=X3 X3&X4=X7 X1&X4=X5  X5&X2=X7).\n%total {} (min-assoc-commutative* _ _ _ _).\n\n\n%theorem min-assoc-commutative :\n\tforall* {X1} {X2} {X3} {X4} {X7}\n\tforall {OP1:min X1 X2 X3} {OP2:min X3 X4 X7}\n        exists {X5} {OP3:min X1 X4 X5} {OP4:min X5 X2 X7}\n\ttrue.\n\n- : min-assoc-commutative X1&X2=X3 X3&X4=X7 X5 X1&X4=X5 X5&X2=X7\n    <- min-associative X1&X2=X3 X3&X4=X7 X6 X2&X4=X6 X1&X6=X7\n    <- min-commutative X2&X4=X6 X4&X2=X6\n    <- min-associative-converse X4&X2=X6 X1&X6=X7 X5 X1&X4=X5 X5&X2=X7.\n\n%worlds () (min-assoc-commutative X1&X2=X3 X3&X4=X7  X5 X1&X4=X5 X5&X2=X7).\n%total {} (min-assoc-commutative _ _ _ _ _).\n\n\n%theorem min-double-associative* :\n\tforall* {A} {B} {C} {D} {A+B} {C+D} {A+C} {B+D} {X}\n\tforall {AB:min A B A+B} {CD:min C D C+D} {ABCD:min A+B C+D X}\n\t       {AC:min A C A+C} {BD:min B D B+D} \n        exists {ACBD:min A+C B+D X}\n\ttrue.\n\n- : min-double-associative* X1&X2=X3 X4&X8=XC X3&XC=XF X1&X4=X5 X2&X8=XA X5&XA=XF\n    <- min-associative X1&X2=X3 X3&XC=XF XE X2&XC=XE X1&XE=XF\n    <- min-commutative X4&X8=XC X8&X4=XC\n    <- min-associative-converse* X8&X4=XC X2&XC=XE X2&X8=XA XA&X4=XE\n    <- min-commutative XA&X4=XE X4&XA=XE\n    <- min-associative-converse* X4&XA=XE X1&XE=XF X1&X4=X5 X5&XA=XF.\n\n%worlds () (min-double-associative* X1&X2=X3 X4&X8=XC X3&XC=XF X1&X4=X5 X2&X8=XA\n                             X5&XA=XF).\n%total {} (min-double-associative* _ _ _ _ _ _).\n\n\n%theorem min-double-associative :\n\tforall* {A} {B} {C} {D} {A+B} {C+D} {X}\n\tforall {AB:min A B A+B} {CD:min C D C+D} {ABCD:min A+B C+D X}\n\texists {A+C} {B+D} {AC:min A C A+C} {BD:min B D B+D} \n               {ACBD:min A+C B+D X}\n\ttrue.\n\n- : min-double-associative X1&X2=X3 X4&X8=XC X3&XC=XF X5 XA X1&X4=X5 X2&X8=XA X5&XA=XF\n    <- min-associative X1&X2=X3 X3&XC=XF XE X2&XC=XE X1&XE=XF\n    <- min-commutative X4&X8=XC X8&X4=XC\n    <- min-associative-converse X8&X4=XC X2&XC=XE XA X2&X8=XA XA&X4=XE\n    <- min-commutative XA&X4=XE X4&XA=XE\n    <- min-associative-converse X4&XA=XE X1&XE=XF X5 X1&X4=X5 X5&XA=XF.\n\n%worlds () (min-double-associative _ _ _ _ _ _ _ _).\n%total { } (min-double-associative _ _ _ _ _ _ _ _).\n\n\n%%% Theorems about max\n\n\n%theorem false-implies-max :\n\tforall* {X1} {X2} {X3}\n\tforall {F:void}\n\texists {M:max X1 X2 X3}\n\ttrue.\n\n%worlds () (false-implies-max _ _).\n%total { } (false-implies-max _ _).\n\n\n%theorem max-respects-eq :\n\tforall* {X1} {X2} {X3}\n\t\t{Y1} {Y2} {Y3}\n\tforall {MX:max X1 X2 X3}\n\t       {E1:eq X1 Y1} {E2:eq X2 Y2} {E3:eq X3 Y3}\n\texists {MY:max Y1 Y2 Y3}\n\ttrue.\n\n- : max-respects-eq M eq/ eq/ eq/ M.\n\n%worlds () (max-respects-eq _ _ _ _ _).\n%total { } (max-respects-eq _ _ _ _ _).\n\n\n%theorem max-total** :\n\tforall* {X1} {X2} {C}\n\tforall {D:compare X1 X2 C}\n\texists {X3} {M:max X1 X2 X3}\n\ttrue.\n\n- : max-total** compare/= _ max/=.\n\n- : max-total** (compare/> X1>X2) _ (max/> X1>X2).\n\n- : max-total** (compare/< X2>X1) _ (max/< X2>X1).\n\n%worlds () (max-total** _ _ _).\n%total { } (max-total** _ _ _).\n\n\n%theorem max-total* :\n\tforall {X1} {X2}\n\texists {X3} {M:max X1 X2 X3}\n\ttrue.\n\n- : max-total* X1 X2 X3 M\n    <- compare-total D\n    <- max-total** D X3 M.\n\n%worlds () (max-total* _ _ _ _).\n%total { } (max-total* _ _ _ _).\n\n\n%abbrev max-total = max-total* _ _ _.\n\n\n%theorem max-deterministic :\n\tforall* {X1} {X2} {X3}\n\t\t{Y1} {Y2} {Y3}\n\tforall {MX:max X1 X2 X3}\n\t       {MY:max Y1 Y2 Y3}\n\t       {E1:eq X1 Y1} {E2:eq X2 Y2}\n\texists {E3:eq X3 Y3}\n\ttrue.\n\n- : max-deterministic (max/=) (max/=) eq/ eq/ eq/.\n\n- : max-deterministic (max/=) (max/> X>X) eq/ eq/ eq/.\n\n- : max-deterministic (max/=) (max/< X>X) eq/ eq/ eq/.\n\n- : max-deterministic (max/> X>X) (max/=) eq/ eq/ eq/.\n\n- : max-deterministic (max/> X>Y) (max/> X>YP) eq/ eq/ eq/.\n\n- : max-deterministic (max/> X>Y) (max/< Y>X) eq/ eq/ E\n    <- gt-anti-symmetric X>Y Y>X F\n    <- false-implies-eq F E.\n\n- : max-deterministic (max/< X>X) (max/=) eq/ eq/ eq/.\n\n- : max-deterministic (max/< X>Y) (max/> Y>X) eq/ eq/ E\n    <- gt-anti-symmetric X>Y Y>X F\n    <- false-implies-eq F E.\n\n- : max-deterministic (max/< X>Y) (max/< X>YP) eq/ eq/ eq/.\n\n%worlds () (max-deterministic _ _ _ _ _).\n%total { } (max-deterministic _ _ _ _ _).\n\n\n%theorem max-commutative :\n\tforall* {X1} {X2} {X3}\n\tforall {M:max X1 X2 X3}\n\texists {Mc:max X2 X1 X3}\n\ttrue.\n\n- : max-commutative max/= max/=.\n\n- : max-commutative (max/> X>Y) (max/< X>Y).\n\n- : max-commutative (max/< X>Y) (max/> X>Y).\n\n%worlds () (max-commutative _ _).\n%total { } (max-commutative _ _).\n\n\n%theorem ge-implies-max :\n\tforall* {X1} {X2}\n\tforall {G:ge X1 X2}\n\texists {M:max X1 X2 X1}\n\ttrue.\n\n- : ge-implies-max (ge/> X1>X2) (max/> X1>X2).\n\n- : ge-implies-max (ge/= eq/) (max/=).\n\n%worlds () (ge-implies-max _ _).\n%total { } (ge-implies-max _ _).\n\n\n%theorem le-implies-max :\n\tforall* {X1} {X2}\n\tforall {G:le X1 X2}\n\texists {M:max X1 X2 X2}\n\ttrue.\n\n- : le-implies-max X2>=X1 M\n    <- ge-implies-max X2>=X1 Mc\n    <- max-commutative Mc M.\n\n%worlds () (le-implies-max _ _).\n%total { } (le-implies-max _ _).\n\n\n%theorem max-implies-ge :\n\tforall* {X1} {X2} {X3}\n\tforall {M:max X1 X2 X3}\n\texists {G1:ge X3 X1} {G2:ge X3 X2}\n\ttrue.\n\n- : max-implies-ge max/= (ge/= eq/) (ge/= eq/).\n\n- : max-implies-ge (max/> X1>X2) (ge/= eq/) (ge/> X1>X2).\n\n- : max-implies-ge (max/< X2>X1) (ge/> X2>X1) (ge/= eq/).\n\n%worlds () (max-implies-ge _ _ _).\n%total { } (max-implies-ge _ _ _).\n\n\n%theorem max-is-lub :\n\tforall* {X0} {X1} {X2} {X3}\n\tforall {M:max X1 X2 X3}\n\t       {G1:ge X0 X1}\n\t       {G2:ge X0 X2}\n\texists {G3:ge X0 X3}\n\ttrue.\n\n- : max-is-lub max/= G _ G.\n\n- : max-is-lub (max/> X1>X2) G _ G.\n\n- : max-is-lub (max/< X2>X1) _ G G.\n\n%worlds () (max-is-lub _ _ _ _).\n%total { } (max-is-lub _ _ _ _).\n\n\n%theorem max-left-preserves-ge* :\n\tforall* {X1} {X2} {X3} {X4} {X5} \n\tforall {G:ge X2 X4}\n\t       {M12:max X1 X2 X3} \n\t       {M14:max X1 X4 X5}\n\texists {G:ge X3 X5}\n\ttrue.\n\n- : max-left-preserves-ge* X>=X4 max/= X|X4=X5 X>=X5\n    <- ge-reflexive _ X>=X\n    <- max-is-lub X|X4=X5 X>=X X>=X4 X>=X5.\n\n- : max-left-preserves-ge* X2>=X4 (max/> X1>X2) X1|X4=X5 X1>=X5\n    <- ge-transitive (ge/> X1>X2) X2>=X4 X1>=X4\n    <- ge-reflexive _ X1>=X1\n    <- max-is-lub X1|X4=X5 X1>=X1 X1>=X4 X1>=X5.\n\n- : max-left-preserves-ge* X2>=X4 (max/< X2>X1) X1|X4=X5 X2>=X5\n    <- max-is-lub X1|X4=X5 (ge/> X2>X1) X2>=X4 X2>=X5.\n\n%worlds () (max-left-preserves-ge* _ _ _ _).\n%total { } (max-left-preserves-ge* _ _ _ _).\n\n\n%theorem max-left-preserves-le* :\n\tforall* {X1} {X2} {X3} {X4} {X5} \n\tforall {G:le X2 X4}\n\t       {M12:max X1 X2 X3} \n\t       {M14:max X1 X4 X5}\n\texists {G:le X3 X5}\n\ttrue.\n\n- : max-left-preserves-le* G1 M12 M14 G2\n    <- max-left-preserves-ge* G1 M14 M12 G2.\n\n%worlds () (max-left-preserves-le* _ _ _ _).\n%total { } (max-left-preserves-le* _ _ _ _).\n\n\n\n%theorem max-left-preserves-ge :\n\tforall* {X1} {X2} {X4}\n      \tforall {G:ge X2 X4}\n\texists {X3} {X5}\n               {O1:max X1 X2 X3} {O2:max X1 X4 X5}\n      \t       {G2:ge X3 X5}\n\ttrue.\n\n- : max-left-preserves-ge X2>=X4 X3 X5 X1&X2=A3 X1&X4=X5 X3>=X5\n    <- max-total X1&X2=A3 \n    <- max-total X1&X4=X5\n    <- max-left-preserves-ge* X2>=X4 X1&X2=A3 X1&X4=X5 X3>=X5.\n\n%worlds () (max-left-preserves-ge X2>=X4  X3 X5 X1&X2=A3 X1&X4=X5 X3>=X5).\n%total {} (max-left-preserves-ge _ _ _ _ _ _).\n\n\n%theorem max-right-preserves-ge* :\n\tforall* {X1} {X2} {X3} {X4} {X5}\n\tforall {G1:ge X1 X2} {O1:max X1 X3 X4} {O2:max X2 X3 X5}\n\texists {G2:ge X4 X5}\n\ttrue.\n\n- : max-right-preserves-ge* X1>=X2 X1&X3=X4 X2&X3=X5 X4>=X5\n    <- max-commutative X1&X3=X4 X3&X1=X4\n    <- max-commutative X2&X3=X5 X3&X2=X5\n    <- max-left-preserves-ge* X1>=X2 X3&X1=X4 X3&X2=X5 X4>=X5.\n\n%worlds () (max-right-preserves-ge* X1>=X2 X1&X3=X4 X2&X3=X5  X4>=X5).\n%total {} (max-right-preserves-ge* _ _ _ _).\n\n\n%theorem max-right-preserves-ge :\n\tforall* {X1} {X2} {X3}\n\tforall {G1:ge X1 X2} \n\texists {X4} {X5} {O1:max X1 X3 X4} {O2:max X2 X3 X5} {G2:ge X4 X5}\n\ttrue.\n\n- : max-right-preserves-ge X1>=X2 X4 X5 X1&X3=X4 X2&X3=X5 X4>=X5\n    <- max-total X1&X3=X4 \n    <- max-total X2&X3=X5\n    <- max-right-preserves-ge* X1>=X2 X1&X3=X4 X2&X3=X5 X4>=X5.\n%worlds () (max-right-preserves-ge X1>=X2  X4 X5 X1&X3=X4 X2&X3=X5 X4>=X5).\n%total {} (max-right-preserves-ge _ _ _ _ _ _).\n\n\n%theorem max-preserves-ge* :\n\tforall* {X1} {X2} {X3} {Y1} {Y2} {Y3}\n\tforall {G1:ge X1 Y1} {G2:ge X2 Y2}\n               {MX:max X1 X2 X3} {MY:max Y1 Y2 Y3}\n        exists {G3:ge X3 Y3}\n\ttrue.\n\n- : max-preserves-ge* X1>=Y1 X2>=Y2 X1&X2=X3 Y1&Y2=Y3 X3>=Y3\n    <- max-total Y1&X2=X\n    <- max-right-preserves-ge* X1>=Y1 X1&X2=X3 Y1&X2=X X3>=X\n    <- max-left-preserves-ge* X2>=Y2 Y1&X2=X Y1&Y2=Y3 X>=Y3\n    <- ge-transitive X3>=X X>=Y3 X3>=Y3.\n\n%worlds () (max-preserves-ge* X1>=Y1 X2>=Y2 X1&X2=X3 Y1&Y2=Y3  X3>=Y3).\n%total {} (max-preserves-ge* _ _ _ _ _).\n\n\n%theorem max-preserves-ge :\n\tforall* {X1} {X2} {Y1} {Y2}\n\tforall {G1:ge X1 Y1} {G2:ge X2 Y2}\n\texists {X3} {Y3} {MX:max X1 X2 X3} {MY:max Y1 Y2 Y3} {G3:ge X3 Y3}\n\ttrue.\n\n- : max-preserves-ge X1>=Y1 X2>=Y2 X3 Y3 X1&X2=X3 Y1&Y2=Y3 X3>=Y3\n    <- max-total X1&X2=X3\n    <- max-total Y1&Y2=Y3\n    <- max-preserves-ge* X1>=Y1 X2>=Y2 X1&X2=X3 Y1&Y2=Y3 X3>=Y3.\n\n%worlds () (max-preserves-ge X1>=Y1 X2>=Y2  X3 Y3 X1&X2=X3 Y1&Y2=Y3 X3>=Y3).\n%total {} (max-preserves-ge _ _ _ _ _ _ _).\n\n\n\n%theorem max-left-preserves-le :\n\tforall* {X1} {X2} {X4}\n      \tforall {G:le X2 X4}\n\texists {X3} {X5}\n               {O1:max X1 X2 X3} {O2:max X1 X4 X5}\n      \t       {G2:le X3 X5}\n\ttrue.\n\n- : max-left-preserves-le X2<=X4 X3 X5 X1&X2=A3 X1&X4=X5 X3<=X5\n    <- max-total X1&X2=A3 \n    <- max-total X1&X4=X5\n    <- max-left-preserves-le* X2<=X4 X1&X2=A3 X1&X4=X5 X3<=X5.\n\n%worlds () (max-left-preserves-le X2<=X4  X3 X5 X1&X2=A3 X1&X4=X5 X3<=X5).\n%total {} (max-left-preserves-le _ _ _ _ _ _).\n\n\n%theorem max-right-preserves-le* :\n\tforall* {X1} {X2} {X3} {X4} {X5}\n\tforall {G1:le X1 X2} {O1:max X1 X3 X4} {O2:max X2 X3 X5}\n\texists {G2:le X4 X5}\n\ttrue.\n\n- : max-right-preserves-le* X1<=X2 X1&X3=X4 X2&X3=X5 X4<=X5\n    <- max-commutative X1&X3=X4 X3&X1=X4\n    <- max-commutative X2&X3=X5 X3&X2=X5\n    <- max-left-preserves-le* X1<=X2 X3&X1=X4 X3&X2=X5 X4<=X5.\n\n%worlds () (max-right-preserves-le* X1<=X2 X1&X3=X4 X2&X3=X5  X4<=X5).\n%total {} (max-right-preserves-le* _ _ _ _).\n\n\n%theorem max-right-preserves-le :\n\tforall* {X1} {X2} {X3}\n\tforall {G1:le X1 X2} \n\texists {X4} {X5} {O1:max X1 X3 X4} {O2:max X2 X3 X5} {G2:le X4 X5}\n\ttrue.\n\n- : max-right-preserves-le X1<=X2 X4 X5 X1&X3=X4 X2&X3=X5 X4<=X5\n    <- max-total X1&X3=X4 \n    <- max-total X2&X3=X5\n    <- max-right-preserves-le* X1<=X2 X1&X3=X4 X2&X3=X5 X4<=X5.\n%worlds () (max-right-preserves-le X1<=X2  X4 X5 X1&X3=X4 X2&X3=X5 X4<=X5).\n%total {} (max-right-preserves-le _ _ _ _ _ _).\n\n\n%theorem max-preserves-le* :\n\tforall* {X1} {X2} {X3} {Y1} {Y2} {Y3}\n\tforall {G1:le X1 Y1} {G2:le X2 Y2}\n               {MX:max X1 X2 X3} {MY:max Y1 Y2 Y3}\n        exists {G3:le X3 Y3}\n\ttrue.\n\n- : max-preserves-le* X1<=Y1 X2<=Y2 X1&X2=X3 Y1&Y2=Y3 X3<=Y3\n    <- max-total Y1&X2=X\n    <- max-right-preserves-le* X1<=Y1 X1&X2=X3 Y1&X2=X X3<=X\n    <- max-left-preserves-le* X2<=Y2 Y1&X2=X Y1&Y2=Y3 X<=Y3\n    <- le-transitive X3<=X X<=Y3 X3<=Y3.\n\n%worlds () (max-preserves-le* X1<=Y1 X2<=Y2 X1&X2=X3 Y1&Y2=Y3  X3<=Y3).\n%total {} (max-preserves-le* _ _ _ _ _).\n\n\n%theorem max-preserves-le :\n\tforall* {X1} {X2} {Y1} {Y2}\n\tforall {G1:le X1 Y1} {G2:le X2 Y2}\n\texists {X3} {Y3} {MX:max X1 X2 X3} {MY:max Y1 Y2 Y3} {G3:le X3 Y3}\n\ttrue.\n\n- : max-preserves-le X1<=Y1 X2<=Y2 X3 Y3 X1&X2=X3 Y1&Y2=Y3 X3<=Y3\n    <- max-total X1&X2=X3\n    <- max-total Y1&Y2=Y3\n    <- max-preserves-le* X1<=Y1 X2<=Y2 X1&X2=X3 Y1&Y2=Y3 X3<=Y3.\n\n%worlds () (max-preserves-le X1<=Y1 X2<=Y2  X3 Y3 X1&X2=X3 Y1&Y2=Y3 X3<=Y3).\n%total {} (max-preserves-le _ _ _ _ _ _ _).\n\n\n%theorem max-associative :\n\tforall* {X1} {X2} {X3} {X4} {X7}\n\tforall {M12:max X1 X2 X3}\n\t       {M34:max X3 X4 X7}\n\texists {X6} {M24:max X2 X4 X6}\n\t       {M16:max X1 X6 X7}\n\ttrue.\n\n- : max-associative max/= max/= _ max/= max/=.\n\n- : max-associative max/= (max/> X3>X4) _ (max/> X3>X4) max/=.\n\n- : max-associative max/= (max/< X4>X3) _ (max/< X4>X3) (max/< X4>X3).\n\n- : max-associative (max/> X1>X2) max/= _ (max/< X1>X2) max/=.\n\n- : max-associative (max/> X1>X2) (max/> X1>X4) _ M24 M16\n    <- max-total M24\n    <- max-is-lub M24 (ge/> X1>X2) (ge/> X1>X4) X1>=X6\n    <- ge-implies-max X1>=X6 M16.\n\n- : max-associative (max/> X1>X2) (max/< X4>X1) _ (max/< X4>X2) (max/< X4>X1)\n    <- gt-transitive X4>X1 X1>X2 X4>X2.\n\n- : max-associative (max/< X2>X1) max/= _ max/= (max/< X2>X1).\n\n- : max-associative (max/< X2>X1) (max/> X2>X4) _ (max/> X2>X4) (max/< X2>X1).\n\n- : max-associative (max/< X2>X1) (max/< X4>X2) _ (max/< X4>X2) (max/< X4>X1)\n    <- gt-transitive X4>X2 X2>X1 X4>X1.\n\n%worlds () (max-associative _ _ _ _ _).\n%total { } (max-associative _ _ _ _ _).\n\n\n%theorem max-associative* :\n\tforall* {X1} {X2} {X12} {X3} {X23} {X123}\n        forall {OP12:max X1 X2 X12} {OP12-3:max X12 X3 X123} {OP23:max X2 X3 X23}\n        exists {OP1-23:max X1 X23 X123}\n        true.\n\n- : max-associative* X1|X2=X3 X3|X4=X7 X2|X4=X6 X1|X6=X7\n    <- max-associative X1|X2=X3 X3|X4=X7 Y6 X2|X4=Y6 X1|Y6=X7\n    <- max-deterministic X2|X4=Y6 X2|X4=X6 eq/ eq/ Y6=X6\n    <- max-respects-eq X1|Y6=X7 eq/ Y6=X6 eq/ X1|X6=X7.\n\n%worlds () (max-associative* _ _ _ _).\n%total {} (max-associative* _ _ _ _).\n\n\n%theorem max-associative-converse :\n\tforall* {X1} {X2} {X4} {X6} {X7}\n\tforall {OP24:max X2 X4 X6} {OP16:max X1 X6 X7}\n        exists {X3} {OP12:max X1 X2 X3} {OP34:max X3 X4 X7}\n        true.\n\n- : max-associative-converse X2|X4=X6 X1|X6=X7 _ X1|X2=X3 X3|X4=X7\n    <- max-commutative X2|X4=X6 X4|X2=X6\n    <- max-commutative X1|X6=X7 X6|X1=X7\n    <- max-associative X4|X2=X6 X6|X1=X7 _ X2|X1=X3 X4|X3=X7\n    <- max-commutative X2|X1=X3 X1|X2=X3\n    <- max-commutative X4|X3=X7 X3|X4=X7.\n\n%worlds () (max-associative-converse X2|X4=X6 X1|X6=X7 X3 X1|X2=X3 X3|X4=X7).\n%total {} (max-associative-converse _ _ _ _ _).\n\n\n%theorem max-associative-converse* :\n\tforall* {X1} {X2} {X3} {X4} {X6} {X7}\n\tforall {OP24:max X2 X4 X6} {OP16:max X1 X6 X7} {OP12:max X1 X2 X3} \n\texists {OP34:max X3 X4 X7}\n        true.\n\n- : max-associative-converse* X2|X4=X6 X1|X6=X7 X1|X2=X3 X3|X4=X7\n    <- max-associative-converse X2|X4=X6 X1|X6=X7 X3P X1|X2=X3P X3P|X4=X7\n    <- max-deterministic X1|X2=X3P X1|X2=X3 eq/ eq/ X3P=X3\n    <- max-respects-eq X3P|X4=X7 X3P=X3 eq/ eq/ X3|X4=X7.\n\n%worlds () (max-associative-converse* X2|X4=X6 X1|X6=X7 X1|X2=X3  X3|X4=X7).\n%total {} (max-associative-converse* _ _ _ _).\n\n\n%theorem max-assoc-commutative* :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X7}\n\tforall {OP1:max X1 X2 X3} {OP2:max X3 X4 X7}\n               {OP3:max X1 X4 X5} \n        exists {OP4:max X5 X2 X7}\n\ttrue.\n\n- : max-assoc-commutative* X1|X2=X3 X3|X4=X7 X1|X4=X5 X5|X2=X7\n    <- max-associative X1|X2=X3 X3|X4=X7 X6 X2|X4=X6 X1|X6=X7\n    <- max-commutative X2|X4=X6 X4|X2=X6\n    <- max-associative-converse* X4|X2=X6 X1|X6=X7 X1|X4=X5 X5|X2=X7.\n\n%worlds () (max-assoc-commutative* X1|X2=X3 X3|X4=X7 X1|X4=X5  X5|X2=X7).\n%total {} (max-assoc-commutative* _ _ _ _).\n\n\n%theorem max-assoc-commutative :\n\tforall* {X1} {X2} {X3} {X4} {X7}\n\tforall {OP1:max X1 X2 X3} {OP2:max X3 X4 X7}\n        exists {X5} {OP3:max X1 X4 X5} {OP4:max X5 X2 X7}\n\ttrue.\n\n- : max-assoc-commutative X1|X2=X3 X3|X4=X7 X5 X1|X4=X5 X5|X2=X7\n    <- max-associative X1|X2=X3 X3|X4=X7 X6 X2|X4=X6 X1|X6=X7\n    <- max-commutative X2|X4=X6 X4|X2=X6\n    <- max-associative-converse X4|X2=X6 X1|X6=X7 X5 X1|X4=X5 X5|X2=X7.\n\n%worlds () (max-assoc-commutative X1|X2=X3 X3|X4=X7  X5 X1|X4=X5 X5|X2=X7).\n%total {} (max-assoc-commutative _ _ _ _ _).\n\n\n%theorem max-double-associative* :\n\tforall* {A} {B} {C} {D} {A+B} {C+D} {A+C} {B+D} {X}\n\tforall {AB:max A B A+B} {CD:max C D C+D} {ABCD:max A+B C+D X}\n\t       {AC:max A C A+C} {BD:max B D B+D} \n        exists {ACBD:max A+C B+D X}\n\ttrue.\n\n- : max-double-associative* X1|X2=X3 X4|X8=XC X3|XC=XF X1|X4=X5 X2|X8=XA X5|XA=XF\n    <- max-associative X1|X2=X3 X3|XC=XF XE X2|XC=XE X1|XE=XF\n    <- max-commutative X4|X8=XC X8|X4=XC\n    <- max-associative-converse* X8|X4=XC X2|XC=XE X2|X8=XA XA|X4=XE\n    <- max-commutative XA|X4=XE X4|XA=XE\n    <- max-associative-converse* X4|XA=XE X1|XE=XF X1|X4=X5 X5|XA=XF.\n\n%worlds () (max-double-associative* X1|X2=X3 X4|X8=XC X3|XC=XF X1|X4=X5 X2|X8=XA\n                             X5|XA=XF).\n%total {} (max-double-associative* _ _ _ _ _ _).\n\n\n%theorem max-double-associative :\n\tforall* {A} {B} {C} {D} {A+B} {C+D} {X}\n\tforall {AB:max A B A+B} {CD:max C D C+D} {ABCD:max A+B C+D X}\n\texists {A+C} {B+D} {AC:max A C A+C} {BD:max B D B+D} \n               {ACBD:max A+C B+D X}\n\ttrue.\n\n- : max-double-associative X1|X2=X3 X4|X8=XC X3|XC=XF X5 XA X1|X4=X5 X2|X8=XA X5|XA=XF\n    <- max-associative X1|X2=X3 X3|XC=XF XE X2|XC=XE X1|XE=XF\n    <- max-commutative X4|X8=XC X8|X4=XC\n    <- max-associative-converse X8|X4=XC X2|XC=XE XA X2|X8=XA XA|X4=XE\n    <- max-commutative XA|X4=XE X4|XA=XE\n    <- max-associative-converse X4|XA=XE X1|XE=XF X5 X1|X4=X5 X5|XA=XF.\n\n%worlds () (max-double-associative _ _ _ _ _ _ _ _).\n%total { } (max-double-associative _ _ _ _ _ _ _ _).\n\n\n%%% Distributivity theorems\n\n\n%theorem min-right-distributes-over-max :\n\tforall* {X1} {X2} {X3} {X4} {X7}\n        forall {A12:max X1 X2 X3} {M34:min X3 X4 X7}\n        exists {X5} {X6}\n               {M14:min X1 X4 X5} {M24:min X2 X4 X6}\n               {A56:max X5 X6 X7}\n\ttrue.\n\n- : min-right-distributes-over-max max/= M _ _ M M max/=.\n\n- : min-right-distributes-over-max (max/> X1>X2) X1&X4=X7 _ _ \n                                   X1&X4=X7 X2&X4=X6 X7|X6=X7\n    <- min-total X2&X4=X6\n    <- min-right-preserves-ge* (ge/> X1>X2) X1&X4=X7 X2&X4=X6 X7>=X6\n    <- ge-implies-max X7>=X6 X7|X6=X7.\n\n- : min-right-distributes-over-max (max/< X2>X1) X2&X4=X7 _ _\n\t\t\t\t   X1&X4=X5 X2&X4=X7 X5|X7=X7\n    <- min-total X1&X4=X5\n    <- min-right-preserves-ge* (ge/> X2>X1) X2&X4=X7 X1&X4=X5 X7>=X5\n    <- ge-implies-max X7>=X5 X7|X5=X7\n    <- max-commutative X7|X5=X7 X5|X7=X7.\n\n%worlds () (min-right-distributes-over-max _ _ _ _ _ _ _).\n%total { } (min-right-distributes-over-max _ _ _ _ _ _ _).\n\n\n%theorem max-right-distributes-over-min :\n\tforall* {X1} {X2} {X3} {X4} {X7}\n        forall {A12:min X1 X2 X3} {M34:max X3 X4 X7}\n        exists {X5} {X6}\n               {M14:max X1 X4 X5} {M24:max X2 X4 X6}\n               {A56:min X5 X6 X7}\n\ttrue.\n\n- : max-right-distributes-over-min min/= M _ _ M M min/=.\n\n- : max-right-distributes-over-min (min/> X1>X2) X2|X4=X7 _ _\n                                   X1|X4=X5 X2|X4=X7 X5&X7=X7\n    <- max-total X1|X4=X5\n    <- max-right-preserves-ge* (ge/> X1>X2) X1|X4=X5 X2|X4=X7 X5>=X7\n    <- ge-implies-min X5>=X7 X5&X7=X7.\n\n- : max-right-distributes-over-min (min/< X2>X1) X1|X4=X7 _ _\n\t\t\t\t   X1|X4=X7 X2|X4=X6 X7&X6=X7\n    <- max-total X2|X4=X6\n    <- max-right-preserves-ge* (ge/> X2>X1) X2|X4=X6 X1|X4=X7 X6>=X7\n    <- le-implies-min X6>=X7 X7&X6=X7.\n\n%worlds () (max-right-distributes-over-min _ _ _ _ _ _ _).\n%total { } (max-right-distributes-over-min _ _ _ _ _ _ _).\n\n\n\n%theorem min-right-distributes-over-max* :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X6} {X7}\n        forall {A12:max X1 X2 X3} {M34:min X3 X4 X7}\n               {M14:min X1 X4 X5} {M24:min X2 X4 X6}\n        exists {A56:max X5 X6 X7}\n\ttrue.\n\n- : min-right-distributes-over-max* X1|X2=X3 X3&X4=X7 X1&X4=X5 X2&X4=X6 X5|X6=X7\n    <- min-right-distributes-over-max X1|X2=X3 X3&X4=X7 Y5 Y6\n                                      X1&X4=Y5 X2&X4=Y6 Y5|Y6=X7\n    <- min-deterministic X1&X4=Y5 X1&X4=X5 eq/ eq/ Y5=X5\n    <- min-deterministic X2&X4=Y6 X2&X4=X6 eq/ eq/ Y6=X6\n    <- max-respects-eq Y5|Y6=X7 Y5=X5 Y6=X6 eq/ X5|X6=X7.\n\n%worlds () (min-right-distributes-over-max* X1|X2=X3 X3&X4=X7 X1&X4=X5 X2&X4=X6\n                                       X5|X6=X7).\n%total {} (min-right-distributes-over-max* _ _ _ _ _).\n\n\n%theorem min-left-distributes-over-max* :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X6} {X7}\n        forall {A12:max X2 X4 X6} {M34:min X1 X6 X7}\n               {M14:min X1 X2 X3} {M24:min X1 X4 X5}\n        exists {A56:max X3 X5 X7}\n\ttrue.\n\n- : min-left-distributes-over-max* X2|X4=X6 X1&X6=X7 X1&X2=X3 X1&X4=X5 X3|X5=X7\n    <- min-commutative X1&X6=X7 X6&X1=X7\n    <- min-commutative X1&X2=X3 X2&X1=X3\n    <- min-commutative X1&X4=X5 X4&X1=X5\n    <- min-right-distributes-over-max* X2|X4=X6 X6&X1=X7 X2&X1=X3 X4&X1=X5\n                                       X3|X5=X7.\n\n%worlds () (min-left-distributes-over-max* X2|X4=X6 X1&X6=X7 X1&X2=X3 X1&X4=X5\n                                     X3|X5=X7).\n%total {} (min-left-distributes-over-max* _ _ _ _ _).\n\n\n%theorem min-left-distributes-over-max :\n\tforall* {X1} {X2} {X4} {X6} {X7}\n        forall {A12:max X2 X4 X6} {M34:min X1 X6 X7}\n        exists {X3} {X5} {M14:min X1 X2 X3} {M24:min X1 X4 X5}\n               {A56:max X3 X5 X7}\n\ttrue.\n\n- : min-left-distributes-over-max X2|X4=X6 X1&X6=X7 \n                                  X3 X5 X1&X2=X3 X1&X4=X5 X3|X5=X7\n    <- min-total X1&X2=X3\n    <- min-total X1&X4=X5\n    <- min-left-distributes-over-max* X2|X4=X6 X1&X6=X7 X1&X2=X3 X1&X4=X5\n                                      X3|X5=X7.\n\n%worlds () (min-left-distributes-over-max X2|X4=X6 X1&X6=X7 \n                                    X3 X5 X1&X2=X3 X1&X4=X5 X3|X5=X7).\n%total {} (min-left-distributes-over-max _ _ _ _ _ _ _).\n\n\n%theorem min-right-factors-over-max :\n\tforall* {X1} {X2} {X4} {X5} {X6} {X7}\n        forall {M14:min X1 X4 X5} {M24:min X2 X4 X6} {A56:max X5 X6 X7}\n        exists {X3} {A12:max X1 X2 X3} {M34:min X3 X4 X7}\n\ttrue.\n- : min-right-factors-over-max X1&X4=X5 X2&X4=X6 X5|X6=X7 X3 X1|X2=X3 X3&X4=X7\n    <- max-total X1|X2=X3\n    <- min-total X3&X4=Y7\n    <- min-right-distributes-over-max* X1|X2=X3 X3&X4=Y7 X1&X4=X5 X2&X4=X6 \n                                       X5|X6=Y7\n    <- max-deterministic X5|X6=Y7 X5|X6=X7 eq/ eq/ Y7=X7\n    <- min-respects-eq X3&X4=Y7 eq/ eq/ Y7=X7 X3&X4=X7.\n\n%worlds () (min-right-factors-over-max X1&X4=X5 X2&X4=X6 X5|X6=X7\n                                 X3 X1|X2=X3 X3&X4=X7 ).\n%total {} (min-right-factors-over-max _ _ _ _ _ _).\n\n\n%theorem min-right-factors-over-max* :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X6} {X7}\n        forall {M14:min X1 X4 X5} {M24:min X2 X4 X6} {A56:max X5 X6 X7}\n               {A12:max X1 X2 X3} \n        exists {M34:min X3 X4 X7}\n\ttrue.\n\n- : min-right-factors-over-max* X1&X4=X5 X2&X4=X6 X5|X6=X7 X1|X2=X3 X3&X4=X7\n    <- min-total X3&X4=Y7\n    <- min-right-distributes-over-max* X1|X2=X3 X3&X4=Y7 X1&X4=X5 X2&X4=X6 \n                                       X5|X6=Y7\n    <- max-deterministic X5|X6=Y7 X5|X6=X7 eq/ eq/ Y7=X7\n    <- min-respects-eq X3&X4=Y7 eq/ eq/ Y7=X7 X3&X4=X7.\n\n%worlds () (min-right-factors-over-max* X1&X4=X5 X2&X4=X6 X5|X6=X7 X1|X2=X3\n                                  X3&X4=X7 ).\n%total {} (min-right-factors-over-max* _ _ _ _ _).\n\n\n%theorem min-left-factors-over-max :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X7}\n\tforall {M12:min X1 X2 X3} {M14:min X1 X4 X5} {A35:max X3 X5 X7}\n        exists {X6} {A24:max X2 X4 X6} {M16:min X1 X6 X7}\n        true.\n\n- : min-left-factors-over-max X1&X2=X3 X1&X4=X5 X3|X5=X7 X6 X2|X4=X6 X1&X6=X7\n    <- min-commutative X1&X2=X3 X2&X1=X3\n    <- min-commutative X1&X4=X5 X4&X1=X5\n    <- min-right-factors-over-max X2&X1=X3 X4&X1=X5 X3|X5=X7 X6 X2|X4=X6 X6&X1=X7\n    <- min-commutative X6&X1=X7 X1&X6=X7.\n\n%worlds () (min-left-factors-over-max X1&X2=X3 X1&X4=X5 X3|X5=X7\n                                X6 X2|X4=X6 X1&X6=X7).\n%total {} (min-left-factors-over-max _ _ _ _ _ _).\n\n\n%theorem min-left-factors-over-max* :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X6} {X7}\n\tforall {M12:min X1 X2 X3} {M14:min X1 X4 X5} \n               {A35:max X3 X5 X7} {A24:max X2 X4 X6} \n        exists {M16:min X1 X6 X7}\n        true.\n\n- : min-left-factors-over-max* X1&X2=X3 X1&X4=X5 X3|X5=X7 X2|X4=X6 \n                               X1&X6=X7\n    <- min-total X1&X6=Y7\n    <- min-left-distributes-over-max* X2|X4=X6 X1&X6=Y7 X1&X2=X3 X1&X4=X5\n                                      X3|X5=Y7\n    <- max-deterministic X3|X5=Y7 X3|X5=X7 eq/ eq/ Y7=X7\n    <- min-respects-eq X1&X6=Y7 eq/ eq/ Y7=X7 X1&X6=X7.\n\n%worlds () (min-left-factors-over-max* X1&X2=X3 X1&X4=X5 X3|X5=X7 X2|X4=X6 \n                                X1&X6=X7).\n%total {} (min-left-factors-over-max* _ _ _ _ _).\n\n\n\n%theorem max-right-distributes-over-min* :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X6} {X7}\n        forall {A12:min X1 X2 X3} {M34:max X3 X4 X7}\n               {M14:max X1 X4 X5} {M24:max X2 X4 X6}\n        exists {A56:min X5 X6 X7}\n\ttrue.\n\n- : max-right-distributes-over-min* X1&X2=X3 X3|X4=X7 X1|X4=X5 X2|X4=X6 X5&X6=X7\n    <- max-right-distributes-over-min X1&X2=X3 X3|X4=X7 Y5 Y6\n                                      X1|X4=Y5 X2|X4=Y6 Y5&Y6=X7\n    <- max-deterministic X1|X4=Y5 X1|X4=X5 eq/ eq/ Y5=X5\n    <- max-deterministic X2|X4=Y6 X2|X4=X6 eq/ eq/ Y6=X6\n    <- min-respects-eq Y5&Y6=X7 Y5=X5 Y6=X6 eq/ X5&X6=X7.\n\n%worlds () (max-right-distributes-over-min* X1&X2=X3 X3|X4=X7 X1|X4=X5 X2|X4=X6\n                                       X5&X6=X7).\n%total {} (max-right-distributes-over-min* _ _ _ _ _).\n\n\n%theorem max-left-distributes-over-min* :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X6} {X7}\n        forall {A12:min X2 X4 X6} {M34:max X1 X6 X7}\n               {M14:max X1 X2 X3} {M24:max X1 X4 X5}\n        exists {A56:min X3 X5 X7}\n\ttrue.\n\n- : max-left-distributes-over-min* X2&X4=X6 X1|X6=X7 X1|X2=X3 X1|X4=X5 X3&X5=X7\n    <- max-commutative X1|X6=X7 X6|X1=X7\n    <- max-commutative X1|X2=X3 X2|X1=X3\n    <- max-commutative X1|X4=X5 X4|X1=X5\n    <- max-right-distributes-over-min* X2&X4=X6 X6|X1=X7 X2|X1=X3 X4|X1=X5\n                                       X3&X5=X7.\n\n%worlds () (max-left-distributes-over-min* X2&X4=X6 X1|X6=X7 X1|X2=X3 X1|X4=X5\n                                     X3&X5=X7).\n%total {} (max-left-distributes-over-min* _ _ _ _ _).\n\n\n%theorem max-left-distributes-over-min :\n\tforall* {X1} {X2} {X4} {X6} {X7}\n        forall {A12:min X2 X4 X6} {M34:max X1 X6 X7}\n        exists {X3} {X5} {M14:max X1 X2 X3} {M24:max X1 X4 X5}\n               {A56:min X3 X5 X7}\n\ttrue.\n\n- : max-left-distributes-over-min X2&X4=X6 X1|X6=X7 \n                                  X3 X5 X1|X2=X3 X1|X4=X5 X3&X5=X7\n    <- max-total X1|X2=X3\n    <- max-total X1|X4=X5\n    <- max-left-distributes-over-min* X2&X4=X6 X1|X6=X7 X1|X2=X3 X1|X4=X5\n                                      X3&X5=X7.\n\n%worlds () (max-left-distributes-over-min X2&X4=X6 X1|X6=X7 \n                                    X3 X5 X1|X2=X3 X1|X4=X5 X3&X5=X7).\n%total {} (max-left-distributes-over-min _ _ _ _ _ _ _).\n\n\n%theorem max-right-factors-over-min :\n\tforall* {X1} {X2} {X4} {X5} {X6} {X7}\n        forall {M14:max X1 X4 X5} {M24:max X2 X4 X6} {A56:min X5 X6 X7}\n        exists {X3} {A12:min X1 X2 X3} {M34:max X3 X4 X7}\n\ttrue.\n- : max-right-factors-over-min X1|X4=X5 X2|X4=X6 X5&X6=X7 X3 X1&X2=X3 X3|X4=X7\n    <- min-total X1&X2=X3\n    <- max-total X3|X4=Y7\n    <- max-right-distributes-over-min* X1&X2=X3 X3|X4=Y7 X1|X4=X5 X2|X4=X6 \n                                       X5&X6=Y7\n    <- min-deterministic X5&X6=Y7 X5&X6=X7 eq/ eq/ Y7=X7\n    <- max-respects-eq X3|X4=Y7 eq/ eq/ Y7=X7 X3|X4=X7.\n\n%worlds () (max-right-factors-over-min X1|X4=X5 X2|X4=X6 X5&X6=X7\n                                 X3 X1&X2=X3 X3|X4=X7 ).\n%total {} (max-right-factors-over-min _ _ _ _ _ _).\n\n\n%theorem max-right-factors-over-min* :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X6} {X7}\n        forall {M14:max X1 X4 X5} {M24:max X2 X4 X6} {A56:min X5 X6 X7}\n               {A12:min X1 X2 X3} \n        exists {M34:max X3 X4 X7}\n\ttrue.\n\n- : max-right-factors-over-min* X1|X4=X5 X2|X4=X6 X5&X6=X7 X1&X2=X3 X3|X4=X7\n    <- max-total X3|X4=Y7\n    <- max-right-distributes-over-min* X1&X2=X3 X3|X4=Y7 X1|X4=X5 X2|X4=X6 \n                                       X5&X6=Y7\n    <- min-deterministic X5&X6=Y7 X5&X6=X7 eq/ eq/ Y7=X7\n    <- max-respects-eq X3|X4=Y7 eq/ eq/ Y7=X7 X3|X4=X7.\n\n%worlds () (max-right-factors-over-min* X1|X4=X5 X2|X4=X6 X5&X6=X7 X1&X2=X3\n                                  X3|X4=X7 ).\n%total {} (max-right-factors-over-min* _ _ _ _ _).\n\n\n%theorem max-left-factors-over-min :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X7}\n\tforall {M12:max X1 X2 X3} {M14:max X1 X4 X5} {A35:min X3 X5 X7}\n        exists {X6} {A24:min X2 X4 X6} {M16:max X1 X6 X7}\n        true.\n\n- : max-left-factors-over-min X1|X2=X3 X1|X4=X5 X3&X5=X7 X6 X2&X4=X6 X1|X6=X7\n    <- max-commutative X1|X2=X3 X2|X1=X3\n    <- max-commutative X1|X4=X5 X4|X1=X5\n    <- max-right-factors-over-min X2|X1=X3 X4|X1=X5 X3&X5=X7 X6 X2&X4=X6 X6|X1=X7\n    <- max-commutative X6|X1=X7 X1|X6=X7.\n\n%worlds () (max-left-factors-over-min X1|X2=X3 X1|X4=X5 X3&X5=X7\n                                X6 X2&X4=X6 X1|X6=X7).\n%total {} (max-left-factors-over-min _ _ _ _ _ _).\n\n\n%theorem max-left-factors-over-min* :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X6} {X7}\n\tforall {M12:max X1 X2 X3} {M14:max X1 X4 X5} \n               {A35:min X3 X5 X7} {A24:min X2 X4 X6} \n        exists {M16:max X1 X6 X7}\n        true.\n\n- : max-left-factors-over-min* X1|X2=X3 X1|X4=X5 X3&X5=X7 X2&X4=X6 \n                               X1|X6=X7\n    <- max-total X1|X6=Y7\n    <- max-left-distributes-over-min* X2&X4=X6 X1|X6=Y7 X1|X2=X3 X1|X4=X5\n                                      X3&X5=Y7\n    <- min-deterministic X3&X5=Y7 X3&X5=X7 eq/ eq/ Y7=X7\n    <- max-respects-eq X1|X6=Y7 eq/ eq/ Y7=X7 X1|X6=X7.\n\n%worlds () (max-left-factors-over-min* X1|X2=X3 X1|X4=X5 X3&X5=X7 X2&X4=X6 \n                                X1|X6=X7).\n%total {} (max-left-factors-over-min* _ _ _ _ _).\n\n\n%theorem succ-preserves-min :\n\tforall* {N1} {N2} {N3}\n\tforall\t{M: min N1 N2 N3}\n\texists\t{MS: min (s N1) (s N2) (s N3)}\n\ttrue.\n\n- : succ-preserves-min min/= min/=.\n\n- : succ-preserves-min (min/< N2>N1) (min/< N2+1>N1+1)\n    <- succ-preserves-gt N2>N1 N2+1>N1+1.\n\n- : succ-preserves-min (min/> N1>N2) (min/> N1+1>N2+1)\n    <- succ-preserves-gt N1>N2 N1+1>N2+1.\n\n%worlds () (succ-preserves-min _ _).\n%total { } (succ-preserves-min _ _).\n\n\n%theorem succ-preserves-min-converse :\n\tforall* {N1} {N2} {N3}\n\tforall\t{MS: min (s N1) (s N2) (s N3)}\n\texists\t{M: min N1 N2 N3}\n\ttrue.\n\n- : succ-preserves-min-converse min/= min/=.\n\n- : succ-preserves-min-converse (min/< N2+1>N1+1) (min/< N2>N1)\n    <- succ-preserves-gt-converse N2+1>N1+1 N2>N1.\n\n- : succ-preserves-min-converse (min/> N1+1>N2+1) (min/> N1>N2)\n    <- succ-preserves-gt-converse N1+1>N2+1 N1>N2.\n\n%worlds () (succ-preserves-min-converse _ _).\n%total { } (succ-preserves-min-converse _ _).\n\n\n%theorem succ-preserves-max :\n\tforall* {N1} {N2} {N3}\n\tforall\t{M: max N1 N2 N3}\n\texists\t{MS: max (s N1) (s N2) (s N3)}\n\ttrue.\n\n- : succ-preserves-max max/= max/=.\n\n- : succ-preserves-max (max/< N2>N1) (max/< N2+1>N1+1)\n    <- succ-preserves-gt N2>N1 N2+1>N1+1.\n\n- : succ-preserves-max (max/> N1>N2) (max/> N1+1>N2+1)\n    <- succ-preserves-gt N1>N2 N1+1>N2+1.\n\n%worlds () (succ-preserves-max _ _).\n%total { } (succ-preserves-max _ _).\n\n\n%theorem succ-preserves-max-converse :\n\tforall* {N1} {N2} {N3}\n\tforall\t{MS: max (s N1) (s N2) (s N3)}\n\texists\t{M: max N1 N2 N3}\n\ttrue.\n\n- : succ-preserves-max-converse max/= max/=.\n\n- : succ-preserves-max-converse (max/< N2+1>N1+1) (max/< N2>N1)\n    <- succ-preserves-gt-converse N2+1>N1+1 N2>N1.\n\n- : succ-preserves-max-converse (max/> N1+1>N2+1) (max/> N1>N2)\n    <- succ-preserves-gt-converse N1+1>N2+1 N1>N2.\n\n%worlds () (succ-preserves-max-converse _ _).\n%total { } (succ-preserves-max-converse _ _).\n\n%abbrev nat`nat = nat.\n%abbrev nat`z = z.\n%abbrev nat`s = s.\n%abbrev nat`plus = plus.\n%abbrev nat`plus/z = plus/z.\n%abbrev nat`plus/s = plus/s.\n%abbrev nat`times = times.\n%abbrev nat`times/z = times/z.\n%abbrev nat`times/s = times/s.\n%abbrev nat`eq = eq.\n%abbrev nat`eq/ = eq/.\n%abbrev nat`gt = gt.\n%abbrev nat`gt/1 = gt/1.\n%abbrev nat`gt/> = gt/>.\n%abbrev nat`compare = compare.\n%abbrev nat`compare/= = compare/=.\n%abbrev nat`compare/< = compare/<.\n%abbrev nat`compare/> = compare/>.\n%abbrev nat`meta-eq = meta-eq.\n%abbrev nat`false-implies-eq = false-implies-eq.\n%abbrev nat`eq-symmetric = eq-symmetric.\n%abbrev nat`eq-transitive = eq-transitive.\n%abbrev nat`succ-deterministic = succ-deterministic.\n%abbrev nat`succ-cancels = succ-cancels.\n%abbrev nat`succ-contradiction = succ-contradiction.\n%abbrev nat`eq-contradiction = eq-contradiction.\n%abbrev nat`meta-gt = meta-gt.\n%abbrev nat`false-implies-gt = false-implies-gt.\n%abbrev nat`gt-respects-eq = gt-respects-eq.\n%abbrev nat`succ-implies-gt = succ-implies-gt.\n%abbrev nat`succ-implies-gt-zero = succ-implies-gt-zero.\n%abbrev nat`succ-preserves-gt = succ-preserves-gt.\n%abbrev nat`succ-preserves-gt-converse = succ-preserves-gt-converse.\n%abbrev nat`gt-implies-positive = gt-implies-positive.\n%abbrev nat`gt-anti-reflexive* = gt-anti-reflexive*.\n%abbrev nat`gt-anti-reflexive = gt-anti-reflexive.\n%abbrev nat`gt-transitive = gt-transitive.\n%abbrev nat`gt-anti-symmetric = gt-anti-symmetric.\n%abbrev nat`gt-implies-plus = gt-implies-plus.\n%abbrev nat`gt-contradiction = gt-contradiction.\n%abbrev nat`false-implies-compare = false-implies-compare.\n%abbrev nat`succ-preserves-compare = succ-preserves-compare.\n%abbrev nat`compare-total* = compare-total*.\n%abbrev nat`compare-total = compare-total.\n%abbrev nat`greater-implies-gt = greater-implies-gt.\n%abbrev nat`less-is-reverse-greater = less-is-reverse-greater.\n%abbrev nat`less-implies-lt = less-implies-lt.\n%abbrev nat`equal-implies-eq = equal-implies-eq.\n%abbrev nat`false-implies-plus = false-implies-plus.\n%abbrev nat`plus-respects-eq = plus-respects-eq.\n%abbrev nat`plus-total* = plus-total*.\n%abbrev nat`plus-total = plus-total.\n%abbrev nat`plus-deterministic = plus-deterministic.\n%abbrev nat`plus-left-identity = plus-left-identity.\n%abbrev nat`plus-left-increase = plus-left-increase.\n%abbrev nat`plus-right-identity = plus-right-identity.\n%abbrev nat`plus-right-increase = plus-right-increase.\n%abbrev nat`plus-left-decrease = plus-left-decrease.\n%abbrev nat`plus-right-decrease = plus-right-decrease.\n%abbrev nat`plus-swap-succ = plus-swap-succ.\n%abbrev nat`plus-swap-succ-converse = plus-swap-succ-converse.\n%abbrev nat`plus-left-preserves-positive = plus-left-preserves-positive.\n%abbrev nat`plus-right-preserves-positive = plus-right-preserves-positive.\n%abbrev nat`plus-is-zero-implies-zero = plus-is-zero-implies-zero.\n%abbrev nat`plus-commutative = plus-commutative.\n%abbrev nat`plus-associative = plus-associative.\n%abbrev nat`plus-associative* = plus-associative*.\n%abbrev nat`plus-associative-converse = plus-associative-converse.\n%abbrev nat`plus-associative-converse* = plus-associative-converse*.\n%abbrev nat`plus-assoc-commutative* = plus-assoc-commutative*.\n%abbrev nat`plus-assoc-commutative = plus-assoc-commutative.\n%abbrev nat`plus-double-associative* = plus-double-associative*.\n%abbrev nat`plus-double-associative = plus-double-associative.\n%abbrev nat`plus-left-cancels = plus-left-cancels.\n%abbrev nat`plus-right-cancels* = plus-right-cancels*.\n%abbrev nat`plus-right-cancels = plus-right-cancels.\n%abbrev nat`plus-left-preserves-gt* = plus-left-preserves-gt*.\n%abbrev nat`plus-left-cancels-gt = plus-left-cancels-gt.\n%abbrev nat`plus-left-preserves-gt = plus-left-preserves-gt.\n%abbrev nat`plus-right-preserves-gt* = plus-right-preserves-gt*.\n%abbrev nat`plus-right-preserves-gt = plus-right-preserves-gt.\n%abbrev nat`plus-preserves-gt* = plus-preserves-gt*.\n%abbrev nat`plus-preserves-gt = plus-preserves-gt.\n%abbrev nat`plus-right-cancels-gt = plus-right-cancels-gt.\n%abbrev nat`plus-implies-gt = plus-implies-gt.\n%abbrev nat`plus-gt-contradiction = plus-gt-contradiction.\n%abbrev nat`false-implies-times = false-implies-times.\n%abbrev nat`times-respects-eq = times-respects-eq.\n%abbrev nat`times-total* = times-total*.\n%abbrev nat`times-total = times-total.\n%abbrev nat`times-deterministic = times-deterministic.\n%abbrev nat`times-left-identity = times-left-identity.\n%abbrev nat`times-right-identity = times-right-identity.\n%abbrev nat`times-right-zero = times-right-zero.\n%abbrev nat`times-preserves-positive = times-preserves-positive.\n%abbrev nat`times-preserves-positive* = times-preserves-positive*.\n%abbrev nat`times-positive-implies-positive = times-positive-implies-positive.\n%abbrev nat`times-left-increase = times-left-increase.\n%abbrev nat`times-right-increase = times-right-increase.\n%abbrev nat`times-left-decrease = times-left-decrease.\n%abbrev nat`times-right-decrease = times-right-decrease.\n%abbrev nat`times-commutative = times-commutative.\n%abbrev nat`times-right-distributes-over-plus = times-right-distributes-over-plus.\n%abbrev nat`times-right-distributes-over-plus* = times-right-distributes-over-plus*.\n%abbrev nat`times-left-distributes-over-plus* = times-left-distributes-over-plus*.\n%abbrev nat`times-left-distributes-over-plus = times-left-distributes-over-plus.\n%abbrev nat`times-right-factors-over-plus = times-right-factors-over-plus.\n%abbrev nat`times-right-factors-over-plus* = times-right-factors-over-plus*.\n%abbrev nat`times-left-factors-over-plus = times-left-factors-over-plus.\n%abbrev nat`times-left-factors-over-plus* = times-left-factors-over-plus*.\n%abbrev nat`times-associative = times-associative.\n%abbrev nat`times-associative* = times-associative*.\n%abbrev nat`times-associative-converse = times-associative-converse.\n%abbrev nat`times-associative-converse* = times-associative-converse*.\n%abbrev nat`times-assoc-commutative* = times-assoc-commutative*.\n%abbrev nat`times-assoc-commutative = times-assoc-commutative.\n%abbrev nat`times-double-associative* = times-double-associative*.\n%abbrev nat`times-double-associative = times-double-associative.\n%abbrev nat`times-right-cancels = times-right-cancels.\n%abbrev nat`times-right-cancels* = times-right-cancels*.\n%abbrev nat`times-right-cancels** = times-right-cancels**.\n%abbrev nat`times-left-cancels = times-left-cancels.\n%abbrev nat`times-left-cancels* = times-left-cancels*.\n%abbrev nat`times-left-preserves-gt = times-left-preserves-gt.\n%abbrev nat`times-left-preserves-gt* = times-left-preserves-gt*.\n%abbrev nat`times-right-preserves-gt = times-right-preserves-gt.\n%abbrev nat`times-right-preserves-gt* = times-right-preserves-gt*.\n%abbrev nat`times-preserves-gt = times-preserves-gt.\n%abbrev nat`times-right-cancels-gt = times-right-cancels-gt.\n%abbrev nat`times-left-cancels-gt = times-left-cancels-gt.\n%abbrev nat`minus = minus.\n%abbrev nat`false-implies-minus = false-implies-minus.\n%abbrev nat`minus-respects-eq = minus-respects-eq.\n%abbrev nat`minus-deterministic = minus-deterministic.\n%abbrev nat`plus-associates-with-minus* = plus-associates-with-minus*.\n%abbrev nat`plus-associates-with-minus-converse* = plus-associates-with-minus-converse*.\n%abbrev nat`plus-associates-with-minus-converse = plus-associates-with-minus-converse.\n%abbrev nat`minus-associates-from-plus* = minus-associates-from-plus*.\n%abbrev nat`minus-associates-from-plus-converse* = minus-associates-from-plus-converse*.\n%abbrev nat`minus-associates-to-plus* = minus-associates-to-plus*.\n%abbrev nat`minus-associates-to-plus = minus-associates-to-plus.\n%abbrev nat`minus-associates-to-plus-converse* = minus-associates-to-plus-converse*.\n%abbrev nat`minus-associates-to-plus-converse = minus-associates-to-plus-converse.\n%abbrev nat`minus-is-zero-implies-eq = minus-is-zero-implies-eq.\n%abbrev nat`minus-implies-gt = minus-implies-gt.\n%abbrev nat`minus-left-cancels = minus-left-cancels.\n%abbrev nat`minus-right-cancels = minus-right-cancels.\n%abbrev nat`minus-left-inverts-gt* = minus-left-inverts-gt*.\n%abbrev nat`minus-right-preserves-gt* = minus-right-preserves-gt*.\n%abbrev nat`minus-left-cancels-inverts-gt = minus-left-cancels-inverts-gt.\n%abbrev nat`minus-right-cancels-gt = minus-right-cancels-gt.\n%abbrev nat`times-right-distributes-over-minus = times-right-distributes-over-minus.\n%abbrev nat`times-right-distributes-over-minus* = times-right-distributes-over-minus*.\n%abbrev nat`times-left-distributes-over-minus* = times-left-distributes-over-minus*.\n%abbrev nat`times-left-distributes-over-minus = times-left-distributes-over-minus.\n%abbrev nat`times-right-factors-over-minus* = times-right-factors-over-minus*.\n%abbrev nat`times-left-factors-over-minus* = times-left-factors-over-minus*.\n%abbrev nat`times-right-factors-over-minus = times-right-factors-over-minus.\n%abbrev nat`times-left-factors-over-minus = times-left-factors-over-minus.\n%abbrev nat`ge = ge.\n%abbrev nat`ge/= = ge/=.\n%abbrev nat`ge/> = ge/>.\n%abbrev nat`false-implies-ge = false-implies-ge.\n%abbrev nat`ge-respects-eq = ge-respects-eq.\n%abbrev nat`ge-reflexive = ge-reflexive.\n%abbrev nat`ge-transitive = ge-transitive.\n%abbrev nat`ge-anti-symmetric = ge-anti-symmetric.\n%abbrev nat`ge-transitive-gt = ge-transitive-gt.\n%abbrev nat`gt-transitive-ge = gt-transitive-ge.\n%abbrev nat`meta-ge = meta-ge.\n%abbrev nat`succ-preserves-ge = succ-preserves-ge.\n%abbrev nat`succ-preserves-ge-converse = succ-preserves-ge-converse.\n%abbrev nat`ge-succ-implies-gt = ge-succ-implies-gt.\n%abbrev nat`ge-implies-succ-gt = ge-implies-succ-gt.\n%abbrev nat`succ-gt-implies-ge = succ-gt-implies-ge.\n%abbrev nat`gt-implies-ge-succ = gt-implies-ge-succ.\n%abbrev nat`ge-implies-plus = ge-implies-plus.\n%abbrev nat`plus-implies-ge = plus-implies-ge.\n%abbrev nat`ge-zero-always = ge-zero-always.\n%abbrev nat`nonzero-times-implies-ge = nonzero-times-implies-ge.\n%abbrev nat`times-nonzero-implies-ge = times-nonzero-implies-ge.\n%abbrev nat`non-trivial-times-implies-much-gt* = non-trivial-times-implies-much-gt*.\n%abbrev nat`non-trivial-times-implies-much-gt = non-trivial-times-implies-much-gt.\n%abbrev nat`plus-left-preserves-ge* = plus-left-preserves-ge*.\n%abbrev nat`plus-left-cancels-ge = plus-left-cancels-ge.\n%abbrev nat`plus-left-preserves-ge = plus-left-preserves-ge.\n%abbrev nat`plus-right-preserves-ge* = plus-right-preserves-ge*.\n%abbrev nat`plus-right-preserves-ge = plus-right-preserves-ge.\n%abbrev nat`plus-preserves-ge* = plus-preserves-ge*.\n%abbrev nat`plus-preserves-ge = plus-preserves-ge.\n%abbrev nat`plus-right-cancels-ge = plus-right-cancels-ge.\n%abbrev nat`times-left-preserves-ge* = times-left-preserves-ge*.\n%abbrev nat`times-left-preserves-ge = times-left-preserves-ge.\n%abbrev nat`times-right-preserves-ge* = times-right-preserves-ge*.\n%abbrev nat`times-right-preserves-ge = times-right-preserves-ge.\n%abbrev nat`ne = ne.\n%abbrev nat`ne/< = ne/<.\n%abbrev nat`ne/> = ne/>.\n%abbrev nat`eq? = eq?.\n%abbrev nat`eq?/yes = eq?/yes.\n%abbrev nat`eq?/no = eq?/no.\n%abbrev nat`false-implies-ne = false-implies-ne.\n%abbrev nat`ne-respects-eq = ne-respects-eq.\n%abbrev nat`ne-anti-reflexive = ne-anti-reflexive.\n%abbrev nat`ne-symmetric = ne-symmetric.\n%abbrev nat`eq-ne-implies-false = eq-ne-implies-false.\n%abbrev nat`ge-ne-implies-gt = ge-ne-implies-gt.\n%abbrev nat`eq?-total* = eq?-total*.\n%abbrev nat`eq?-total*/L = eq?-total*/L.\n%abbrev nat`eq?-total = eq?-total.\n%abbrev nat`succ-preserves-ne = succ-preserves-ne.\n%abbrev nat`succ-preserves-ne-converse = succ-preserves-ne-converse.\n%abbrev nat`plus-left-preserves-ne* = plus-left-preserves-ne*.\n%abbrev nat`plus-left-cancels-ne = plus-left-cancels-ne.\n%abbrev nat`plus-left-preserves-ne = plus-left-preserves-ne.\n%abbrev nat`plus-right-preserves-ne* = plus-right-preserves-ne*.\n%abbrev nat`plus-right-preserves-ne = plus-right-preserves-ne.\n%abbrev nat`plus-right-cancels-ne = plus-right-cancels-ne.\n%abbrev nat`lt = lt.\n%abbrev nat`false-implies-lt = false-implies-lt.\n%abbrev nat`lt-respects-eq = lt-respects-eq.\n%abbrev nat`lt-anti-symmetric = lt-anti-symmetric.\n%abbrev nat`lt-transitive = lt-transitive.\n%abbrev nat`lt-anti-reflexive = lt-anti-reflexive.\n%abbrev nat`plus-left-preserves-lt* = plus-left-preserves-lt*.\n%abbrev nat`plus-left-cancels-lt = plus-left-cancels-lt.\n%abbrev nat`plus-left-preserves-lt = plus-left-preserves-lt.\n%abbrev nat`plus-right-preserves-lt* = plus-right-preserves-lt*.\n%abbrev nat`plus-right-preserves-lt = plus-right-preserves-lt.\n%abbrev nat`plus-preserves-lt* = plus-preserves-lt*.\n%abbrev nat`plus-preserves-lt = plus-preserves-lt.\n%abbrev nat`plus-right-cancels-lt = plus-right-cancels-lt.\n%abbrev nat`le = le.\n%abbrev nat`false-implies-le = false-implies-le.\n%abbrev nat`le-respects-eq = le-respects-eq.\n%abbrev nat`le-anti-symmetric = le-anti-symmetric.\n%abbrev nat`le-transitive = le-transitive.\n%abbrev nat`le-reflexive = le-reflexive.\n%abbrev nat`le-transitive-lt = le-transitive-lt.\n%abbrev nat`lt-transitive-le = lt-transitive-le.\n%abbrev nat`plus-left-preserves-le* = plus-left-preserves-le*.\n%abbrev nat`plus-left-cancels-le = plus-left-cancels-le.\n%abbrev nat`plus-left-preserves-le = plus-left-preserves-le.\n%abbrev nat`plus-right-preserves-le* = plus-right-preserves-le*.\n%abbrev nat`plus-right-preserves-le = plus-right-preserves-le.\n%abbrev nat`plus-preserves-le* = plus-preserves-le*.\n%abbrev nat`plus-preserves-le = plus-preserves-le.\n%abbrev nat`plus-right-cancels-le = plus-right-cancels-le.\n%abbrev nat`times-left-preserves-le* = times-left-preserves-le*.\n%abbrev nat`times-left-preserves-le = times-left-preserves-le.\n%abbrev nat`times-right-preserves-le* = times-right-preserves-le*.\n%abbrev nat`times-right-preserves-le = times-right-preserves-le.\n%abbrev nat`times-preserves-le* = times-preserves-le*.\n%abbrev nat`times-preserves-le = times-preserves-le.\n%abbrev nat`minus-left-inverts-ge* = minus-left-inverts-ge*.\n%abbrev nat`minus-right-preserves-ge* = minus-right-preserves-ge*.\n%abbrev nat`minus-left-cancels-inverts-ge = minus-left-cancels-inverts-ge.\n%abbrev nat`minus-right-cancels-ge = minus-right-cancels-ge.\n%abbrev nat`minus-left-preserves-ne* = minus-left-preserves-ne*.\n%abbrev nat`minus-right-preserves-ne* = minus-right-preserves-ne*.\n%abbrev nat`minus-left-cancels-ne = minus-left-cancels-ne.\n%abbrev nat`minus-right-cancels-ne = minus-right-cancels-ne.\n%abbrev nat`minus-left-inverts-lt* = minus-left-inverts-lt*.\n%abbrev nat`minus-right-preserves-lt* = minus-right-preserves-lt*.\n%abbrev nat`minus-left-cancels-inverts-lt = minus-left-cancels-inverts-lt.\n%abbrev nat`minus-right-cancels-lt = minus-right-cancels-lt.\n%abbrev nat`minus-left-inverts-le* = minus-left-inverts-le*.\n%abbrev nat`minus-right-preserves-le* = minus-right-preserves-le*.\n%abbrev nat`minus-left-cancels-inverts-le = minus-left-cancels-inverts-le.\n%abbrev nat`minus-right-cancels-le = minus-right-cancels-le.\n%abbrev nat`divrem = divrem.\n%abbrev nat`divrem/z = divrem/z.\n%abbrev nat`divrem/s = divrem/s.\n%abbrev nat`false-implies-divrem = false-implies-divrem.\n%abbrev nat`divrem-respects-eq = divrem-respects-eq.\n%abbrev nat`divrem-total** = divrem-total**.\n%abbrev nat`divrem-total* = divrem-total*.\n%abbrev nat`divrem-total = divrem-total.\n%abbrev nat`divrem-deterministic = divrem-deterministic.\n%abbrev nat`divrem-implies-positive = divrem-implies-positive.\n%abbrev nat`divrem-implies-gt = divrem-implies-gt.\n%abbrev nat`divrem-contradiction = divrem-contradiction.\n%abbrev nat`divrem-can-be-inverted = divrem-can-be-inverted.\n%abbrev nat`div-can-be-inverted = div-can-be-inverted.\n%abbrev nat`divrem-can-be-constructed = divrem-can-be-constructed.\n%abbrev nat`div-can-be-constructed = div-can-be-constructed.\n%abbrev nat`remainder-implies-gt-quotient = remainder-implies-gt-quotient.\n%abbrev nat`quotient-of-nonzero-is-smaller = quotient-of-nonzero-is-smaller.\n%abbrev nat`quotient-is-no-greater = quotient-is-no-greater.\n%abbrev nat`min = min.\n%abbrev nat`min/= = min/=.\n%abbrev nat`min/> = min/>.\n%abbrev nat`min/< = min/<.\n%abbrev nat`max = max.\n%abbrev nat`max/= = max/=.\n%abbrev nat`max/> = max/>.\n%abbrev nat`max/< = max/<.\n%abbrev nat`false-implies-min = false-implies-min.\n%abbrev nat`min-respects-eq = min-respects-eq.\n%abbrev nat`min-total** = min-total**.\n%abbrev nat`min-total* = min-total*.\n%abbrev nat`min-total = min-total.\n%abbrev nat`min-deterministic = min-deterministic.\n%abbrev nat`min-commutative = min-commutative.\n%abbrev nat`ge-implies-min = ge-implies-min.\n%abbrev nat`le-implies-min = le-implies-min.\n%abbrev nat`min-implies-ge = min-implies-ge.\n%abbrev nat`min-left-preserves-ge* = min-left-preserves-ge*.\n%abbrev nat`min-left-preserves-le* = min-left-preserves-le*.\n%abbrev nat`min-left-preserves-ge = min-left-preserves-ge.\n%abbrev nat`min-right-preserves-ge* = min-right-preserves-ge*.\n%abbrev nat`min-right-preserves-ge = min-right-preserves-ge.\n%abbrev nat`min-preserves-ge* = min-preserves-ge*.\n%abbrev nat`min-preserves-ge = min-preserves-ge.\n%abbrev nat`min-left-preserves-le = min-left-preserves-le.\n%abbrev nat`min-right-preserves-le* = min-right-preserves-le*.\n%abbrev nat`min-right-preserves-le = min-right-preserves-le.\n%abbrev nat`min-preserves-le* = min-preserves-le*.\n%abbrev nat`min-preserves-le = min-preserves-le.\n%abbrev nat`min-is-glb = min-is-glb.\n%abbrev nat`min-associative = min-associative.\n%abbrev nat`min-associative* = min-associative*.\n%abbrev nat`min-associative-converse = min-associative-converse.\n%abbrev nat`min-associative-converse* = min-associative-converse*.\n%abbrev nat`min-assoc-commutative* = min-assoc-commutative*.\n%abbrev nat`min-assoc-commutative = min-assoc-commutative.\n%abbrev nat`min-double-associative* = min-double-associative*.\n%abbrev nat`min-double-associative = min-double-associative.\n%abbrev nat`false-implies-max = false-implies-max.\n%abbrev nat`max-respects-eq = max-respects-eq.\n%abbrev nat`max-total** = max-total**.\n%abbrev nat`max-total* = max-total*.\n%abbrev nat`max-total = max-total.\n%abbrev nat`max-deterministic = max-deterministic.\n%abbrev nat`max-commutative = max-commutative.\n%abbrev nat`ge-implies-max = ge-implies-max.\n%abbrev nat`le-implies-max = le-implies-max.\n%abbrev nat`max-implies-ge = max-implies-ge.\n%abbrev nat`max-is-lub = max-is-lub.\n%abbrev nat`max-left-preserves-ge* = max-left-preserves-ge*.\n%abbrev nat`max-left-preserves-le* = max-left-preserves-le*.\n%abbrev nat`max-left-preserves-ge = max-left-preserves-ge.\n%abbrev nat`max-right-preserves-ge* = max-right-preserves-ge*.\n%abbrev nat`max-right-preserves-ge = max-right-preserves-ge.\n%abbrev nat`max-preserves-ge* = max-preserves-ge*.\n%abbrev nat`max-preserves-ge = max-preserves-ge.\n%abbrev nat`max-left-preserves-le = max-left-preserves-le.\n%abbrev nat`max-right-preserves-le* = max-right-preserves-le*.\n%abbrev nat`max-right-preserves-le = max-right-preserves-le.\n%abbrev nat`max-preserves-le* = max-preserves-le*.\n%abbrev nat`max-preserves-le = max-preserves-le.\n%abbrev nat`max-associative = max-associative.\n%abbrev nat`max-associative* = max-associative*.\n%abbrev nat`max-associative-converse = max-associative-converse.\n%abbrev nat`max-associative-converse* = max-associative-converse*.\n%abbrev nat`max-assoc-commutative* = max-assoc-commutative*.\n%abbrev nat`max-assoc-commutative = max-assoc-commutative.\n%abbrev nat`max-double-associative* = max-double-associative*.\n%abbrev nat`max-double-associative = max-double-associative.\n%abbrev nat`min-right-distributes-over-max = min-right-distributes-over-max.\n%abbrev nat`max-right-distributes-over-min = max-right-distributes-over-min.\n%abbrev nat`min-right-distributes-over-max* = min-right-distributes-over-max*.\n%abbrev nat`min-left-distributes-over-max* = min-left-distributes-over-max*.\n%abbrev nat`min-left-distributes-over-max = min-left-distributes-over-max.\n%abbrev nat`min-right-factors-over-max = min-right-factors-over-max.\n%abbrev nat`min-right-factors-over-max* = min-right-factors-over-max*.\n%abbrev nat`min-left-factors-over-max = min-left-factors-over-max.\n%abbrev nat`min-left-factors-over-max* = min-left-factors-over-max*.\n%abbrev nat`max-right-distributes-over-min* = max-right-distributes-over-min*.\n%abbrev nat`max-left-distributes-over-min* = max-left-distributes-over-min*.\n%abbrev nat`max-left-distributes-over-min = max-left-distributes-over-min.\n%abbrev nat`max-right-factors-over-min = max-right-factors-over-min.\n%abbrev nat`max-right-factors-over-min* = max-right-factors-over-min*.\n%abbrev nat`max-left-factors-over-min = max-left-factors-over-min.\n%abbrev nat`max-left-factors-over-min* = max-left-factors-over-min*.\n%abbrev nat`succ-preserves-min = succ-preserves-min.\n%abbrev nat`succ-preserves-min-converse = succ-preserves-min-converse.\n%abbrev nat`succ-preserves-max = succ-preserves-max.\n%abbrev nat`succ-preserves-max-converse = succ-preserves-max-converse.\n%{| hidden = true }%\n% contents included from ../library/natpair.elf\n%%%%% natpair.elf\n%%%%% Pairs of natural numbers\n%%%%% John Boyland\n\n\n\n\n\n\n%%%% Functor use\n\n\n\n\n%%%%% pair.elf\n%%%%% a pseudo-functor\n%%%%% John Boyland\n\n\n\n\n\n\n%%%% Definitions\n\n\n\npair : type.\n\npair/ : nat -> nat -> pair.\n\n\neq : pair -> pair -> type.\n\neq/ : eq P P.\n\n\nne : pair -> pair -> type.\n\nne/1 : ne (pair/ X1 Y1) (pair/ X2 Y2)\n    <- nat`ne X1 X2.\n\nne/2 : ne (pair/ X1 Y1) (pair/ X2 Y2)\n    <- nat`ne Y1 Y2.\n\n\neq? : pair -> pair -> bool -> type.\n\neq?/yes : eq? P P true.\n\neq?/no : eq? P1 P2 false\n    <- ne P1 P2.\n\n\n\n%%%% Theorems\n\n\n\n%%% theorems about eq\n\n\n%theorem false-implies-eq :\n\tforall* {X1} {X2}\n\tforall {F:void}\n\texists {E:eq X1 X2}\n\ttrue.\n\n%worlds () (false-implies-eq _ _).\n%total { } (false-implies-eq _ _).\n\n\n%theorem meta-eq :\n\tforall {X1} {X2} {E:eq X1 X2}\n\ttrue.\n\n- : meta-eq _ _ eq/.\n\n%worlds () (meta-eq _ _ _).\n%total { } (meta-eq _ _ _).\n%reduces X = Y (meta-eq X Y _).\n\n\t\n%theorem eq-reflexive : \n\tforall {X} \n\texists {E:eq X X} \n\ttrue.\n\n- : eq-reflexive _ eq/.\n\n%worlds () (eq-reflexive _ _).\n%total { } (eq-reflexive _ _).\n\n\n%theorem eq-symmetric : \n\tforall* {X} {Y}\n\tforall {E:eq X Y}\n\texists {F:eq Y X}\n\ttrue.\n\n- : eq-symmetric (eq/) (eq/).\n\n%worlds () (eq-symmetric _ _).\n%total { } (eq-symmetric _ _).\n\n\n%theorem eq-transitive : \n\tforall* {X} {Y} {Z}\n\tforall {E1:eq X Y} {E2:eq Y Z}\n\texists {F:eq X Z}\n\ttrue.\n\n- : eq-transitive (eq/) (eq/) (eq/).\n\n%worlds () (eq-transitive _ _ _).\n%total { } (eq-transitive _ _ _).\n\n\n%theorem pair-eq-implies-eq :\n\tforall* {D1a} {D1b} {D2a} {D2b}\n        forall {E:eq (pair/ D1a D2a) (pair/ D1b D2b)}\n\texists {E1:nat`eq D1a D1b}\n               {E2:nat`eq D2a D2b}\n\ttrue.\n\n- : pair-eq-implies-eq eq/ nat`eq/ nat`eq/.\n\n%worlds () (pair-eq-implies-eq _ _ _).\n%total { } (pair-eq-implies-eq _ _ _).\n\n\n%theorem pair-preserves-eq :\n\tforall* {D1a} {D1b} {D2a} {D2b}\n\tforall {E1:nat`eq D1a D1b}\n               {E2:nat`eq D2a D2b}\n        exists {E:eq (pair/ D1a D2a) (pair/ D1b D2b)}\n\ttrue.\n\n- : pair-preserves-eq nat`eq/ nat`eq/ eq/.\n\n%worlds () (pair-preserves-eq _ _ _).\n%total { } (pair-preserves-eq _ _ _).\n\n\n%%% theorems about ne\n\n\n%theorem false-implies-ne :\n\tforall* {X1} {X2}\n\tforall {F:void}\n\texists {G:ne X1 X2}\n\ttrue.\n\n%worlds () (false-implies-ne _ _).\n%total { } (false-implies-ne _ _).\n\n\n%theorem ne-respects-eq :\n\tforall* {X1} {X2} {Y1} {Y2}\n\tforall {D1:ne X1 X2} {E1:eq X1 Y1} {E2:eq X2 Y2}\n\texists {D2:ne Y1 Y2}\n\ttrue.\n\n- : ne-respects-eq X1<>X2 eq/ eq/ X1<>X2.\n\n%worlds () (ne-respects-eq _ _ _ _).\n%total { } (ne-respects-eq _ _ _ _).\n\n\n%theorem ne-anti-reflexive :\n\tforall* {P}\n\tforall {R:ne P P}\n\texists {F:void}\n\ttrue.\n\n- : ne-anti-reflexive (ne/1 X<>X) F\n    <- nat`ne-anti-reflexive X<>X F.\n\n- : ne-anti-reflexive (ne/2 Y<>Y) F\n    <- nat`ne-anti-reflexive Y<>Y F.\n\n%worlds () (ne-anti-reflexive _ _).\n%total { } (ne-anti-reflexive _ _).\n\n\n%theorem ne-symmetric :\n\tforall* {P1} {P2}\n\tforall {R1:ne P1 P2}\n\texists {R2:ne P2 P1}\n\ttrue.\n\n- : ne-symmetric (ne/1 X1<>X2) (ne/1 X2<>X1)\n    <- nat`ne-symmetric X1<>X2 X2<>X1.\n\n- : ne-symmetric (ne/2 Y1<>Y2) (ne/2 Y2<>Y1)\n    <- nat`ne-symmetric Y1<>Y2 Y2<>Y1.\n\n\n%worlds () (ne-symmetric _ _).\n%total { } (ne-symmetric _ _).\n\n\n%theorem eq-ne-implies-false :\n\tforall* {P1} {P2}\n\tforall {D1:eq P1 P2} {D2:ne P1 P2}\n\texists {F:void}\n\ttrue.\n\n- : eq-ne-implies-false eq/ X<>X F\n    <- ne-anti-reflexive X<>X F.\n\n%worlds () (eq-ne-implies-false _ _ _).\n%total { } (eq-ne-implies-false _ _ _).\n\n\n\n%%% theorems about eq?\n\n\n%theorem eq?-total* :\n\tforall {P1} {P2}\n\texists {B} {T:eq? P1 P2 B}\n\ttrue.\n\n%theorem eq?-total*/L :\n\tforall* {X1} {Y1} {X2} {Y2} {B1} {B2}\n\tforall {T1:nat`eq? X1 Y1 B1} {T2:nat`eq? X2 Y2 B2}\n\texists {B} {T:eq? (pair/ X1 X2) (pair/ Y1 Y2) B}\n\ttrue.\n\n- : eq?-total*/L (nat`eq?/yes) (nat`eq?/yes) _ (eq?/yes).\n\n- : eq?-total*/L (nat`eq?/no X1<>Y1) _ _ (eq?/no (ne/1 X1<>Y1)).\n\n- : eq?-total*/L _ (nat`eq?/no X2<>Y2) _ (eq?/no (ne/2 X2<>Y2)).\n\n%worlds () (eq?-total*/L _ _ _ _).\n%total { } (eq?-total*/L _ _ _ _).\n\n- : eq?-total* _ _ _ T\n    <- nat`eq?-total E?1\n    <- nat`eq?-total E?2\n    <- eq?-total*/L E?1 E?2 _ T.\n\n%worlds () (eq?-total* _ _ _ _).\n%total { } (eq?-total* _ _ _ _).\n\n\n%abbrev eq?-total = eq?-total* _ _ _.\n\n\n\n\n\n\n%%%% Definitions\n\n\n\n%%% local abbreviations:\n\n %abbrev ssN>N = (gt/> gt/1).\n %abbrev 2>0 : gt (s (s z)) z = ssN>N.\n %abbrev 1*N=N = (times/s times/z plus/z).\n %abbrev 1*2=2 : times (s z) (s (s z)) (s (s z)) = 1*N=N.\n %abbrev 2*2=4 = (times/s 1*N=N (plus/s (plus/s plus/z))).\n %abbrev 2+1=3 : plus (s (s z)) (s z) (s (s (s z))) = (plus/s (plus/s plus/z)).\n\n\n%%% mapping from a pair to a nat\n\n\npair2nat : pair -> nat -> type.\n\n\npair2nat/00 : pair2nat (pair/ z z) z.\n\npair2nat/XX : \n\tplus Z3 Y0 Z ->\n        plus Z2 X2 Z3 ->\n        times X0 (s (s z)) X2 ->\n        times Z1 (s (s (s (s z)))) Z2 ->\n\tpair2nat (pair/ X1 Y1) Z1 ->\n        divrem Y (s (s z)) Y1 Y0 ->\n\tdivrem X (s (s z)) X1 X0 ->\n    pair2nat (pair/ X Y) Z.\n\n\n\n%%% mapping from a nat to pair\n\n\n%abbrev \nnat2pair : nat -> pair -> type = [N] [P] pair2nat P N.\n\n\n\n%%%% Theorems\n\n\n%theorem false-implies-pair2nat :\n\tforall* {P} {N}\n\tforall {F:void}\n\texists {P2N:pair2nat P N}\n\ttrue.\n\n%worlds () (false-implies-pair2nat _ _).\n%total { } (false-implies-pair2nat _ _).\n\n\n%abbrev false-implies-not2pair = false-implies-pair2nat.\n\n\n%theorem pair2nat-respects-eq :\n\tforall* {P1} {N1} {P2} {N2}\n\tforall {D1:pair2nat P1 N1} {EP:eq P1 P2} {EN:nat`eq N1 N2}\n\texists {D2:pair2nat P2 N2}\n\ttrue.\n\n- : pair2nat-respects-eq P2N eq/ nat`eq/ P2N.\n\n%worlds () (pair2nat-respects-eq _ _ _ _).\n%total { } (pair2nat-respects-eq _ _ _ _).\n%reduces D1 = D2 (pair2nat-respects-eq D1 _ _ D2).\n\n%abbrev nat2pair-respects-eq :\n\t  (nat2pair N1 P1) -> (nat`eq N1 N2) -> (eq P1 P2) -> (nat2pair N2 P2)\n        -> type\n\t= [D1] [EN] [EP] [D2] pair2nat-respects-eq D1 EP EN D2.\n\n\n%theorem pair2nat-total** :\n\tforall {X:nat} {Y:nat}\n\texists {Z} {P2N:pair2nat (pair/ X Y) Z}\n\ttrue.\n\n- : pair2nat-total** z z z pair2nat/00.\n\n- : pair2nat-total** (s X-) Y Z \n\t(pair2nat/XX Z3+Y0=Z Z2+X2=Z3 X0*2=X2 Z1*4=Z2 \n                     (P2N:pair2nat (pair/ X1 Y1) Z1) Y/2=Y1,Y0 X/2=X1,X0)\n    <- divrem-total X/2=X1,X0\n    <- divrem-total Y/2=Y1,Y0\n    <- quotient-of-nonzero-is-smaller X/2=X1,X0 nat`eq/ X>X1\n    <- quotient-is-no-greater Y/2=Y1,Y0 Y>=Y1\n    <- meta-gt _ _ X>X1\n    <- meta-ge _ _ Y>=Y1\n    <- pair2nat-total** _ _ _ P2N\n    <- times-total Z1*4=Z2\n    <- times-total X0*2=X2\n    <- plus-total Z2+X2=Z3\n    <- plus-total Z3+Y0=Z.\n\n- : pair2nat-total** X (s Y-) Z \n\t(pair2nat/XX Z3+Y0=Z Z2+X2=Z3 X0*2=X2 Z1*4=Z2 \n                     (P2N:pair2nat (pair/ X1 Y1) Z1) Y/2=Y1,Y0 X/2=X1,X0)\n    <- divrem-total X/2=X1,X0\n    <- divrem-total Y/2=Y1,Y0\n    <- quotient-is-no-greater X/2=X1,X0 X>=X1\n    <- quotient-of-nonzero-is-smaller Y/2=Y1,Y0 nat`eq/ Y>Y1\n    <- meta-ge _ _ X>=X1\n    <- meta-gt _ _ Y>Y1\n    <- pair2nat-total** _ _ _ P2N\n    <- times-total Z1*4=Z2\n    <- times-total X0*2=X2\n    <- plus-total Z2+X2=Z3\n    <- plus-total Z3+Y0=Z.\n\n%worlds () (pair2nat-total** _ _ _ _).\n%total [X Y] (pair2nat-total** X Y _ _).\n\n%theorem pair2nat-total* :\n\tforall {P:pair}\n\texists {N:nat} {P2N:pair2nat P N}\n\ttrue.\n\n- : pair2nat-total* (pair/ X Y) Z P2N\n    <- pair2nat-total** X Y Z P2N.\n\n%worlds () (pair2nat-total* _ _ _).\n%total { } (pair2nat-total* _ _ _).\n\n\n%abbrev pair2nat-total = pair2nat-total* _ _.\n\n\n%theorem nat2pair-total* :\n\tforall {N:nat}\n\texists {P:pair} {N2P:nat2pair N P}\n\ttrue.\n\n- : nat2pair-total* z (pair/ z z) (pair2nat/00).\n\n- : nat2pair-total* (s Z-) (pair/ X Y)\n\t(pair2nat/XX Z3+Y0=Z Z2+X2=Z3 X0*2=X2 Z1*4=Z2 \n                     (P2N:pair2nat (pair/ X1 Y1) Z1) Y/2=Y1,Y0 X/2=X1,X0)\n    <- divrem-total Z/4=Z1,R\n    <- divrem-implies-gt Z/4=Z1,R FOUR>R\n    <- divrem-can-be-inverted Z/4=Z1,R Z2 Z1*4=Z2 Z2+R=Z\n    <- divrem-total R/2=X0,Y0\n    <- divrem-implies-gt R/2=X0,Y0 TWO>Y0\n    <- divrem-can-be-inverted R/2=X0,Y0 X2 X0*2=X2 X2+Y0=R\n    <- plus-associative-converse X2+Y0=R Z2+R=Z Z3 Z2+X2=Z3 Z3+Y0=Z\n    % now we need to get 2>X0\n    <- plus-commutative X2+Y0=R Y0+X2=R\n    <- plus-implies-ge Y0+X2=R R>=X2\n    <- gt-transitive-ge FOUR>R R>=X2 FOUR>X2\n    <- times-right-cancels-gt 2*2=4 X0*2=X2 nat`eq/ FOUR>X2 TWO>X0\n    % now we need to prove Z>Z1 (for termination)\n    <- quotient-of-nonzero-is-smaller Z/4=Z1,R nat`eq/ Z>Z1\n    <- meta-gt _ _ Z>Z1\n    <- nat2pair-total* Z1 (pair/ X1 Y1) P2N\n    <- times-total X1*2=XE\n    <- times-total Y1*2=YE\n    <- plus-total XE+X0=X\n    <- plus-total YE+Y0=Y\n    <- divrem-can-be-constructed X1*2=XE XE+X0=X TWO>X0 X/2=X1,X0\n    <- divrem-can-be-constructed Y1*2=YE YE+Y0=Y TWO>Y0 Y/2=Y1,Y0.\n\n%worlds () (nat2pair-total* _ _ _).\n%total (Z) (nat2pair-total* Z _ _).\n% %reduces X <= N (nat2pair-total* N (pair/ X _) _).\n% %reduces Y <= N (pair2nat-total* N (pair/ _ Y) _).\n\n\n%abbrev nat2pair-total = nat2pair-total* _ _.\n\n\n%theorem pair2nat-deterministic :\n\tforall* {P1} {P2} {N1} {N2}\n\tforall {D1:pair2nat P1 N1} {D2:pair2nat P2 N2}\n\t       {EP:eq P1 P2}\n\texists {EN:nat`eq N1 N2}\n\ttrue.\n\n- : pair2nat-deterministic pair2nat/00 pair2nat/00 eq/ nat`eq/.\n\n% lemma\n%theorem pair2nat-deterministic/00 :\n\tforall* {Z}\n\tforall {P2N:pair2nat (pair/ z z) Z}\n\texists {E:nat`eq Z z}\n\ttrue.\n\n- : pair2nat-deterministic/00 pair2nat/00 nat`eq/.\n\n- : pair2nat-deterministic/00\n\t(pair2nat/XX Z3+Y0=Z Z2+X2=Z3 X0*2=X2 Z1*4=Z2 \n                     (P2N:pair2nat (pair/ X1 Y1) Z1) ZERO/2=Y1,Y0 ZERO/2=X1,X0)\n        Z=0\n    <- divrem-deterministic ZERO/2=X1,X0 (divrem/z 2>0) nat`eq/ nat`eq/\n                            X1=0 X0=0\n    <- divrem-deterministic ZERO/2=Y1,Y0 (divrem/z 2>0) nat`eq/ nat`eq/\n                            Y1=0 Y0=0\n    <- pair-preserves-eq X1=0 Y1=0 X1,Y1=0,0\n    <- pair2nat-respects-eq P2N X1,Y1=0,0 nat`eq/ ZERO,ZERO->Z1\n    <- pair2nat-deterministic/00 ZERO,ZERO->Z1 Z1=0\n    <- times-deterministic Z1*4=Z2 times/z Z1=0 nat`eq/ Z2=0\n    <- times-deterministic X0*2=X2 times/z X0=0 nat`eq/ X2=0\n    <- plus-deterministic Z2+X2=Z3 plus/z Z2=0 X2=0 Z3=0\n    <- plus-deterministic Z3+Y0=Z plus/z Z3=0 Y0=0 Z=0.\n\n%worlds () (pair2nat-deterministic/00 _ _).\n%total (D) (pair2nat-deterministic/00 D _).\n\n- : pair2nat-deterministic pair2nat/00 P2N eq/ ZERO=Z\n    <- pair2nat-deterministic/00 P2N Z=0\n    <- nat`eq-symmetric Z=0 ZERO=Z.\n\n- : pair2nat-deterministic P2N pair2nat/00 eq/ Z=0\n    <- pair2nat-deterministic/00 P2N Z=0.\n\n- : pair2nat-deterministic\n\t(pair2nat/XX Z3+Y0=Z Z2+X2=Z3 X0*2=X2 Z1*4=Z2 \n                     (P2N:pair2nat (pair/ X1 Y1) Z1) Y/2=Y1,Y0 X/2=X1,X0)\n\t(pair2nat/XX Z3'+Y0'=Z' Z2'+X2'=Z3' X0'*2=X2' Z1'*4=Z2' \n                     (P2N':pair2nat (pair/ X1' Y1')Z1') Y/2=Y1',Y0' X/2=X1',X0')\n        eq/ Z=Z'\n    <- divrem-deterministic X/2=X1,X0 X/2=X1',X0' nat`eq/ nat`eq/ X1=X1' X0=X0'\n    <- divrem-deterministic Y/2=Y1,Y0 Y/2=Y1',Y0' nat`eq/ nat`eq/ Y1=Y1' Y0=Y0'\n    <- pair-preserves-eq X1=X1' Y1=Y1' X1,Y1=X1',Y1'\n    <- pair2nat-deterministic P2N P2N' X1,Y1=X1',Y1' Z1=Z1'\n    <- times-deterministic Z1*4=Z2 Z1'*4=Z2' Z1=Z1' nat`eq/ Z2=Z2'\n    <- times-deterministic X0*2=X2 X0'*2=X2' X0=X0' nat`eq/ X2=X2'\n    <- plus-deterministic Z2+X2=Z3 Z2'+X2'=Z3' Z2=Z2' X2=X2' Z3=Z3'\n    <- plus-deterministic Z3+Y0=Z Z3'+Y0'=Z' Z3=Z3' Y0=Y0' Z=Z'.\n\n%worlds () (pair2nat-deterministic _ _ _ _).\n%total (D) (pair2nat-deterministic D _ _ _).\n\n\n%theorem nat2pair-deterministic :\n\tforall* {P1} {P2} {N1} {N2}\n\tforall {D1:nat2pair N1 P1} {D2:nat2pair N2 P2}\t{EN:nat`eq N1 N2}\n\texists {EP:eq P1 P2}\n\ttrue.\n\n% lemma\n%theorem nat2pair-deterministic/0 :\n\tforall* {P}\n\tforall {D:nat2pair z P}\n\texists {EP:eq P (pair/ z z)}\n\ttrue.\n\n- : nat2pair-deterministic/0 pair2nat/00 eq/.\n\n- : nat2pair-deterministic/0 \n\t(pair2nat/XX Z3+Y0=0 Z2+X2=Z3 X0*2=X2 Z1*4=Z2 \n                     (P2N:pair2nat (pair/ X1 Y1) Z1) Y/2=Y1,Y0 X/2=X1,X0)\n\tX,Y=0,0\n    <- plus-is-zero-implies-zero Z3+Y0=0 nat`eq/ Z3=0 Y0=0\n    <- plus-is-zero-implies-zero Z2+X2=Z3 Z3=0 Z2=0 X2=0\n    <- times-right-cancels X0*2=X2 times/z nat`eq/ X2=0 X0=0\n    <- times-right-cancels Z1*4=Z2 times/z nat`eq/ Z2=0 Z1=0\n    <- nat2pair-respects-eq P2N Z1=0 eq/ N2P\n    <- nat2pair-deterministic/0 N2P X1,Y1=0,0\n    <- pair-eq-implies-eq X1,Y1=0,0 X1=0 Y1=0\n    <- divrem-can-be-inverted X/2=X1,X0 XM X1*2=XM XM+X0=X\n    <- divrem-can-be-inverted Y/2=Y1,Y0 YM Y1*2=YM YM+Y0=Y\n    <- times-deterministic X1*2=XM times/z X1=0 nat`eq/ XM=0\n    <- times-deterministic Y1*2=YM times/z Y1=0 nat`eq/ YM=0\n    <- plus-deterministic XM+X0=X plus/z XM=0 X0=0 X=0\n    <- plus-deterministic YM+Y0=Y plus/z YM=0 Y0=0 Y=0\n    <- pair-preserves-eq X=0 Y=0 X,Y=0,0.\n\n%worlds () (nat2pair-deterministic/0 _ _).\n%total (D) (nat2pair-deterministic/0 D _).\n\n- : nat2pair-deterministic N2P N2P' nat`eq/ X,Y=X',Y'\n    <- nat2pair-deterministic/0 N2P X,Y=0,0\n    <- nat2pair-deterministic/0 N2P' X',Y'=0,0\n    <- eq-symmetric X',Y'=0,0 ZERO,ZERO=X',Y'\n    <- eq-transitive X,Y=0,0 ZERO,ZERO=X',Y' X,Y=X',Y'.\n\n- : nat2pair-deterministic\n\t(pair2nat/XX Z3+Y0=Z Z2+X2=Z3 X0*2=X2 Z1*4=Z2 \n                     (P2N:pair2nat (pair/ X1 Y1) Z1) Y/2=Y1,Y0 X/2=X1,X0)\n\t(pair2nat/XX Z3'+Y0'=Z Z2'+X2'=Z3' X0'*2=X2' Z1'*4=Z2' \n                     (P2N':pair2nat (pair/ X1' Y1') Z1') \n                     Y'/2=Y1',Y0' X'/2=X1',X0')\n        nat`eq/ X,Y=X',Y'\n    <- plus-associative Z2+X2=Z3 Z3+Y0=Z R X2+Y0=R Z2+R=Z\n    <- divrem-implies-gt X/2=X1,X0 TWO>X0\n    <- divrem-implies-gt Y/2=Y1,Y0 TWO>Y0\n    <- succ-gt-implies-ge TWO>X0 ONE>=X0\n    <- succ-gt-implies-ge TWO>Y0 ONE>=Y0\n    <- times-right-preserves-ge* ONE>=X0 1*2=2 X0*2=X2 TWO>=X2\n    <- plus-preserves-ge* TWO>=X2 ONE>=Y0 2+1=3 X2+Y0=R THREE>=R\n    <- ge-implies-succ-gt THREE>=R FOUR>R\n    <- divrem-can-be-constructed Z1*4=Z2 Z2+R=Z FOUR>R Z/4=Z1,R\n    <- plus-associative Z2'+X2'=Z3' Z3'+Y0'=Z R' X2'+Y0'=R' Z2'+R'=Z\n    <- divrem-implies-gt X'/2=X1',X0' TWO>X0'\n    <- divrem-implies-gt Y'/2=Y1',Y0' TWO>Y0'\n    <- succ-gt-implies-ge TWO>X0' ONE>=X0'\n    <- succ-gt-implies-ge TWO>Y0' ONE>=Y0'\n    <- times-right-preserves-ge* ONE>=X0' 1*2=2 X0'*2=X2' TWO>=X2'\n    <- plus-preserves-ge* TWO>=X2' ONE>=Y0' 2+1=3 X2'+Y0'=R' THREE>=R'\n    <- ge-implies-succ-gt THREE>=R' FOUR>R'\n    <- divrem-can-be-constructed Z1'*4=Z2' Z2'+R'=Z FOUR>R' Z/4=Z1',R'\n    <- divrem-deterministic Z/4=Z1,R Z/4=Z1',R' nat`eq/ nat`eq/ Z1=Z1' R=R'\n    <- divrem-can-be-constructed X0*2=X2 X2+Y0=R TWO>Y0 R/2=X0,Y0\n    <- divrem-can-be-constructed X0'*2=X2' X2'+Y0'=R' TWO>Y0' R'/2=X0',Y0'\n    <- divrem-deterministic R/2=X0,Y0 R'/2=X0',Y0' R=R' nat`eq/ X0=X0' Y0=Y0'\n    <- nat2pair-deterministic P2N P2N' Z1=Z1' X1,Y1=X1',Y1'\n    <- pair-eq-implies-eq X1,Y1=X1',Y1' X1=X1' Y1=Y1'\n    <- divrem-can-be-inverted X/2=X1,X0 XM X1*2=XM XM+X0=X\n    <- divrem-can-be-inverted Y/2=Y1,Y0 YM Y1*2=YM YM+Y0=Y\n    <- divrem-can-be-inverted X'/2=X1',X0' XM' X1'*2=XM' XM'+X0'=X'\n    <- divrem-can-be-inverted Y'/2=Y1',Y0' YM' Y1'*2=YM' YM'+Y0'=Y'\n    <- times-deterministic X1*2=XM X1'*2=XM' X1=X1' nat`eq/ XM=XM'\n    <- plus-deterministic XM+X0=X XM'+X0'=X' XM=XM' X0=X0' X=X'\n    <- times-deterministic Y1*2=YM Y1'*2=YM' Y1=Y1' nat`eq/ YM=YM'\n    <- plus-deterministic YM+Y0=Y YM'+Y0'=Y' YM=YM' Y0=Y0' Y=Y'\n    <- pair-preserves-eq X=X' Y=Y' X,Y=X',Y'.\n\n%worlds () (nat2pair-deterministic _ _ _ _).\n%total (D) (nat2pair-deterministic D _ _ _).\n\n\n%theorem pair2nat-preserves-ne* :\n\tforall* {P1} {P2} {N1} {N2}\n\tforall {PNE: ne P1 P2} {T1:pair2nat P1 N1} {T2:pair2nat P2 N2}\n\texists {NE: nat`ne N1 N2}\n\ttrue.\n\n%theorem pair2nat-preserves-ne*/L :\n\tforall* {P1} {P2} {N1} {N2} {B}\n\tforall {PNE: ne P1 P2} {T1:pair2nat P1 N1} {T2:pair2nat P2 N2}\n               {NT: nat`eq? N1 N2 B}\n\texists {NE: nat`ne N1 N2}\n\ttrue.\n\n- : pair2nat-preserves-ne* P1<>P2 P1->N1 P2->N2 N1<>N2\n    <- nat`eq?-total EQ?\n    <- pair2nat-preserves-ne*/L P1<>P2 P1->N1 P2->N2 EQ? N1<>N2.\n\n- : pair2nat-preserves-ne*/L _ _ _ (nat`eq?/no N1<>N2) N1<>N2.\n\n- : pair2nat-preserves-ne*/L P1<>P2 P1->N P2->N (nat`eq?/yes) N<>N\n    <- nat2pair-deterministic P1->N P2->N nat`eq/ P1=P2\n    <- eq-ne-implies-false P1=P2 P1<>P2 F\n    <- nat`false-implies-ne F N<>N.\n\n%worlds () (pair2nat-preserves-ne*/L _ _ _ _ _).\n%total { } (pair2nat-preserves-ne*/L _ _ _ _ _).\n\n%worlds () (pair2nat-preserves-ne* _ _ _ _).\n%total { } (pair2nat-preserves-ne* _ _ _ _).\n\n\n%theorem pair2nat-preserves-ne :\n\tforall* {P1} {P2}\n\tforall {PNE: ne P1 P2} \n        exists {N1} {N2} {T1:pair2nat P1 N1} {T2:pair2nat P2 N2}\n\t       {NE: nat`ne N1 N2}\n\ttrue.\n\n- : pair2nat-preserves-ne P1<>P2 N1 N2 T1 T2 N1<>N2\n   <- pair2nat-total T1\n   <- pair2nat-total T2\n   <- pair2nat-preserves-ne* P1<>P2 T1 T2 N1<>N2.\n\n%worlds () (pair2nat-preserves-ne _ _ _ _ _ _).\n%total { } (pair2nat-preserves-ne _ _ _ _ _ _).\n\n\n%theorem nat2pair-preserves-ne* :\n\tforall* {P1} {P2} {N1} {N2}\n\tforall {NE: nat`ne N1 N2} {T1:nat2pair N1 P1} {T2:nat2pair N2 P2}\n\texists {PNE: ne P1 P2}\n\ttrue.\n\n%theorem nat2pair-preserves-ne*/L :\n\tforall* {P1} {P2} {N1} {N2} {B}\n\tforall {NE: nat`ne N1 N2} {T1:nat2pair N1 P1} {T2:nat2pair N2 P2}\n               {PT: eq? P1 P2 B}\n\texists {PNE: ne P1 P2}\n\ttrue.\n\n- : nat2pair-preserves-ne* N1<>N2 N1->P1 N2->P2 P1<>P2\n    <- eq?-total EP?\n    <- nat2pair-preserves-ne*/L N1<>N2 N1->P1 N2->P2 EP? P1<>P2.\n\n- : nat2pair-preserves-ne*/L _ _ _ (eq?/no P1<>P2) P1<>P2.\n\n- : nat2pair-preserves-ne*/L N1<>N2 N1->P N2->P (eq?/yes) P<>P\n    <- pair2nat-deterministic N1->P N2->P eq/ N1=N2\n    <- nat`eq-ne-implies-false N1=N2 N1<>N2 F\n    <- false-implies-ne F P<>P.\n\n%worlds () (nat2pair-preserves-ne*/L _ _ _ _ _).\n%total { } (nat2pair-preserves-ne*/L _ _ _ _ _).\n\n%worlds () (nat2pair-preserves-ne* _ _ _ _).\n%total { } (nat2pair-preserves-ne* _ _ _ _).\n\n\n%theorem nat2pair-preserves-ne :\n\tforall* {N1} {N2}\n\tforall {NNE: nat`ne N1 N2} \n        exists {P1} {P2} {T1:nat2pair N1 P1} {T2:nat2pair N2 P2}\n\t       {PE: ne P1 P2}\n\ttrue.\n\n- : nat2pair-preserves-ne N1<>N2 P1 P2 T1 T2 P1<>P2\n   <- nat2pair-total T1\n   <- nat2pair-total T2\n   <- nat2pair-preserves-ne* N1<>N2 T1 T2 P1<>P2.\n\n%worlds () (nat2pair-preserves-ne _ _ _ _ _ _).\n%total { } (nat2pair-preserves-ne _ _ _ _ _ _).\n\n\n%theorem nonzero-nat2pair-implies-gt-ge :\n\tforall* {N} {X} {Y}\n\tforall {D:nat2pair (s N) (pair/ X Y)}\n\texists {G1: gt (s N) X} {G2: ge (s N) Y}\n\ttrue.\n\n- : nonzero-nat2pair-implies-gt-ge \n     (pair2nat/XX plus/z plus/z times/z times/z _ (divrem/z _) (divrem/z _))\n     N+1>0 (nat`ge/= nat`eq/)\n     <- succ-implies-gt-zero _ N+1>0.\n\n- : nonzero-nat2pair-implies-gt-ge \n     (pair2nat/XX X2+Y=sN plus/z (times/s X-1*2=X2-2 X2-2+2=X2) \n     times/z _ (divrem/z _) (divrem/z TWO>X)) N+1>X N+1>=Y\n    <- plus-implies-ge X2+Y=sN (N+1>=Y:ge (s N) Y)\n    <- succ-gt-implies-ge TWO>X ONE>=X\n    <- ge-succ-implies-gt ONE>=X ONE>X-1\n    <- succ-gt-implies-ge ONE>X-1 ZERO>=X-1\n    <- ge-zero-always _ X-1>=0\n    <- ge-anti-symmetric ZERO>=X-1 X-1>=0 ZERO=X-1\n    <- succ-deterministic ZERO=X-1 ONE=X\n    <- times-deterministic times/z X-1*2=X2-2 ZERO=X-1 nat`eq/ ZERO=X2-2\n    <- plus-deterministic plus/z X2-2+2=X2 ZERO=X2-2 nat`eq/ TWO=X2\n    <- gt-respects-eq (gt/1) TWO=X2 ONE=X X2>X\n    <- plus-commutative X2+Y=sN Y+X2=sN\n    <- plus-implies-ge Y+X2=sN N+1>=X2\n    <- ge-transitive-gt N+1>=X2 X2>X N+1>X.\n\n- : nonzero-nat2pair-implies-gt-ge \n     (pair2nat/XX _ _ _ _ (P2z:pair2nat (pair/ (s _) _) z) _ _) GT GE\n    <- nat2pair-deterministic pair2nat/00 P2z nat`eq/ ZERO,0=sN,_\n    <- pair-eq-implies-eq ZERO,0=sN,_ ZERO=sN _\n    <- nat`eq-contradiction ZERO=sN F\n    <- nat`false-implies-gt F GT\n    <- nat`false-implies-ge F GE.\n\n- : nonzero-nat2pair-implies-gt-ge \n     (pair2nat/XX _ _ _ _ (P2z:pair2nat (pair/ _ (s _)) z) _ _) GT GE\n    <- nat2pair-deterministic pair2nat/00 P2z nat`eq/ ZERO,0=_,sN\n    <- pair-eq-implies-eq ZERO,0=_,sN _ ZERO=sN\n    <- nat`eq-contradiction ZERO=sN F\n    <- nat`false-implies-gt F GT\n    <- nat`false-implies-ge F GE.\n\n- : nonzero-nat2pair-implies-gt-ge \n     (pair2nat/XX Z3+Y0=sN Z2+X2=Z3 X0*2=X2 Z1*4=Z2 Z1->X1,Y1 \n\t          Y/2=Y1,Y0 X/2=X1,X0) N+1>X (ge/> N+1>Y)\n    <- plus-commutative Z3+Y0=sN Y0+Z3=sN\n    <- plus-implies-ge Y0+Z3=sN N+1>=Z3\n    <- plus-commutative Z2+X2=Z3 X2+Z2=Z3\n    <- plus-implies-ge X2+Z2=Z3 Z3>=Z2\n    <- ge-transitive N+1>=Z3 Z3>=Z2 N+1>=Z2\n    <- nonzero-nat2pair-implies-gt-ge Z1->X1,Y1 Z1>X1 Z1>=Y1\n    <- times-associative-converse 2*2=4 Z1*4=Z2 Z2/2 Z1*2=Z2/2 Z2/2*2=Z2\n    <- divrem-can-be-inverted Y/2=Y1,Y0 Y12 Y1*2=Y12 Y12+Y0=Y\n    <- divrem-can-be-inverted X/2=X1,X0 X12 X1*2=X12 X12+X0=X\n    <- times-right-preserves-gt* Z1>X1 Z1*2=Z2/2 X1*2=X12 nat`eq/ Z2/2>X12\n    <- succ-implies-gt-zero _ Z1>0\n    <- gt-implies-ge-succ Z1>0 Z1>=1\n    <- times-right-preserves-ge* Z1>=1 Z1*2=Z2/2 1*2=2 Z2/2>=2\n    <- ge-implies-plus Z2/2>=2 ZZ ZZ+2=Z2/2\n    <- plus-commutative ZZ+2=Z2/2 TWO+ZZ=Z2/2\n    <- plus-deterministic TWO+ZZ=Z2/2 (plus/s (plus/s plus/z)) nat`eq/ nat`eq/\n                          Z2/2=ssZZ\n    <- times-respects-eq Z2/2*2=Z2 Z2/2=ssZZ nat`eq/ nat`eq/ SSZZ*2=Z2\n    <- non-trivial-times-implies-much-gt* SSZZ*2=Z2 Z2>sssZZ\n    <- divrem-implies-gt X/2=X1,X0 TWO>X0\n    <- succ-gt-implies-ge TWO>X0 ONE>=X0\n    <- plus-right-identity _ X12+0=X12 \n    <- plus-right-increase X12+0=X12 X12+1=sX12\n    <- plus-left-preserves-ge* ONE>=X0 X12+1=sX12 X12+X0=X SX12>=X\n    <- gt-implies-ge-succ Z2/2>X12 Z2/2>=sX12\n    <- ge-transitive Z2/2>=sX12 SX12>=X Z2/2>=X\n    <- ge-respects-eq Z2/2>=X Z2/2=ssZZ nat`eq/ SSZZ>=X\n    <- ge-implies-succ-gt SSZZ>=X SSSZZ>X\n    <- gt-transitive Z2>sssZZ SSSZZ>X Z2>X\n    <- ge-transitive-gt N+1>=Z2 Z2>X N+1>X\n    <- times-right-preserves-ge* Z1>=Y1 Z1*2=Z2/2 Y1*2=Y12 Z2/2>=Y12\n    <- ge-respects-eq Z2/2>=Y12 Z2/2=ssZZ nat`eq/ SSZZ>=Y12\n    <- divrem-implies-gt Y/2=Y1,Y0 TWO>Y0\n    <- succ-gt-implies-ge TWO>Y0 ONE>=Y0\n    <- plus-right-identity _ Y12+0=Y12 \n    <- plus-right-increase Y12+0=Y12 Y12+1=sY12\n    <- plus-left-preserves-ge* ONE>=Y0 Y12+1=sY12 Y12+Y0=Y SY12>=Y\n    <- succ-preserves-ge SSZZ>=Y12 SSSZZ>=SY12\n    <- ge-transitive SSSZZ>=SY12 SY12>=Y SSSZZ>=Y\n    <- gt-transitive-ge Z2>sssZZ SSSZZ>=Y Z2>Y\n    <- ge-transitive-gt N+1>=Z2 Z2>Y N+1>Y.\n\n%worlds () (nonzero-nat2pair-implies-gt-ge _ _ _).\n%total (N) (nonzero-nat2pair-implies-gt-ge N _ _).\n\n\n%theorem nat2pair-implies-ge :\n\tforall* {N} {X} {Y}\n\tforall {D:nat2pair N (pair/ X Y)}\n\texists {G1: ge N X} {G2: ge N Y}\n\ttrue.\n\t\n- : nat2pair-implies-ge N2P (ge/> N>X) N>=Y\n    <- nonzero-nat2pair-implies-gt-ge N2P N>X N>=Y.\n\n- : nat2pair-implies-ge Z2P (ge/= ZERO=X) (ge/= ZERO=Y)\n    <- nat2pair-deterministic pair2nat/00 Z2P nat`eq/ ZERO,ZERO=X,Y\n    <- pair-eq-implies-eq ZERO,ZERO=X,Y ZERO=X ZERO=Y.\n\n%worlds () (nat2pair-implies-ge _ _ _).\n%total { } (nat2pair-implies-ge _ _ _).\n\n\n%theorem constrained1-pair2nat-unbounded :\n\tforall {N1} {B}\n\texists {N2} {N} {D:pair2nat (pair/ N1 N2) N} {G:gt N B}\n\ttrue.\n\n- : constrained1-pair2nat-unbounded N1 B (s B) N N1,N2->N N>B\n    <- pair2nat-total N1,N2->N\n    <- nat2pair-implies-ge N1,N2->N N>=N1 N>=N2\n    <- ge-succ-implies-gt N>=N2 N>B.\n\n%worlds () (constrained1-pair2nat-unbounded _ _ _ _ _ _).\n%total { } (constrained1-pair2nat-unbounded _ _ _ _ _ _).\n\n\n%theorem constrained2-pair2nat-unbounded :\n\tforall {N2} {B}\n\texists {N1} {N} {D:pair2nat (pair/ N1 N2) N} {G:gt N B}\n\ttrue.\n\n- : constrained2-pair2nat-unbounded N2 B (s B) N N1,N2->N N>B\n    <- pair2nat-total N1,N2->N\n    <- nat2pair-implies-ge N1,N2->N N>=N1 N>=N2\n    <- ge-succ-implies-gt N>=N1 N>B.\n\n%worlds () (constrained2-pair2nat-unbounded _ _ _ _ _ _).\n%total { } (constrained2-pair2nat-unbounded _ _ _ _ _ _).\n\n\n\n\n%%%% Renamings\n\n\n%abbrev natpair = pair.\n\n\n%abbrev natpair/ = pair/.\n\n\n\n%%%% Exports\n%abbrev natpair`pair = pair.\n%abbrev natpair`pair/ = pair/.\n%abbrev natpair`eq = eq.\n%abbrev natpair`eq/ = eq/.\n%abbrev natpair`ne = ne.\n%abbrev natpair`ne/1 = ne/1.\n%abbrev natpair`ne/2 = ne/2.\n%abbrev natpair`eq? = eq?.\n%abbrev natpair`eq?/yes = eq?/yes.\n%abbrev natpair`eq?/no = eq?/no.\n%abbrev natpair`false-implies-eq = false-implies-eq.\n%abbrev natpair`meta-eq = meta-eq.\n%abbrev natpair`eq-reflexive = eq-reflexive.\n%abbrev natpair`eq-symmetric = eq-symmetric.\n%abbrev natpair`eq-transitive = eq-transitive.\n%abbrev natpair`pair-eq-implies-eq = pair-eq-implies-eq.\n%abbrev natpair`pair-preserves-eq = pair-preserves-eq.\n%abbrev natpair`false-implies-ne = false-implies-ne.\n%abbrev natpair`ne-respects-eq = ne-respects-eq.\n%abbrev natpair`ne-anti-reflexive = ne-anti-reflexive.\n%abbrev natpair`ne-symmetric = ne-symmetric.\n%abbrev natpair`eq-ne-implies-false = eq-ne-implies-false.\n%abbrev natpair`eq?-total* = eq?-total*.\n%abbrev natpair`eq?-total*/L = eq?-total*/L.\n%abbrev natpair`eq?-total = eq?-total.\n%abbrev natpair`pair2nat = pair2nat.\n%abbrev natpair`pair2nat/00 = pair2nat/00.\n%abbrev natpair`pair2nat/XX = pair2nat/XX.\n%abbrev natpair`nat2pair = nat2pair.\n%abbrev natpair`false-implies-pair2nat = false-implies-pair2nat.\n%abbrev natpair`false-implies-not2pair = false-implies-not2pair.\n%abbrev natpair`pair2nat-respects-eq = pair2nat-respects-eq.\n%abbrev natpair`nat2pair-respects-eq = nat2pair-respects-eq.\n%abbrev natpair`pair2nat-total** = pair2nat-total**.\n%abbrev natpair`pair2nat-total* = pair2nat-total*.\n%abbrev natpair`pair2nat-total = pair2nat-total.\n%abbrev natpair`nat2pair-total* = nat2pair-total*.\n%abbrev natpair`nat2pair-total = nat2pair-total.\n%abbrev natpair`pair2nat-deterministic = pair2nat-deterministic.\n%abbrev natpair`pair2nat-deterministic/00 = pair2nat-deterministic/00.\n%abbrev natpair`nat2pair-deterministic = nat2pair-deterministic.\n%abbrev natpair`nat2pair-deterministic/0 = nat2pair-deterministic/0.\n%abbrev natpair`pair2nat-preserves-ne* = pair2nat-preserves-ne*.\n%abbrev natpair`pair2nat-preserves-ne*/L = pair2nat-preserves-ne*/L.\n%abbrev natpair`pair2nat-preserves-ne = pair2nat-preserves-ne.\n%abbrev natpair`nat2pair-preserves-ne* = nat2pair-preserves-ne*.\n%abbrev natpair`nat2pair-preserves-ne*/L = nat2pair-preserves-ne*/L.\n%abbrev natpair`nat2pair-preserves-ne = nat2pair-preserves-ne.\n%abbrev natpair`nonzero-nat2pair-implies-gt-ge = nonzero-nat2pair-implies-gt-ge.\n%abbrev natpair`nat2pair-implies-ge = nat2pair-implies-ge.\n%abbrev natpair`constrained1-pair2nat-unbounded = constrained1-pair2nat-unbounded.\n%abbrev natpair`constrained2-pair2nat-unbounded = constrained2-pair2nat-unbounded.\n%abbrev natpair`natpair = natpair.\n%abbrev natpair`natpair/ = natpair/.\n%{| hidden = true }%\n% contents included from ../library/multiset.elf\n%%%%%% Multisets of natural numbers\n%%%%%% John Boyland\n%%%%%% You may freely use, modify and distribute this file without restrictions.\n\n%%%%% This file requires the \"nat.elf\" signature\n\n\n\n\n\n\n\n%%%%% multiset-help.elf\n%%%%% Theorems needed to help 'multiset' use 'map.'\n%%%%% This file is part of the multiset.elf signature\n\n\n\n%%%% Renamings\n\n\n\n\n\n %abbrev nat`leq = nat`le.\n %abbrev nat`false-implies-leq = nat`false-implies-le.\n %abbrev nat`leq-reflexive = nat`le-reflexive.\n %abbrev nat`leq-transitive = nat`le-transitive.\n %abbrev nat`leq-anti-symmetric = nat`le-anti-symmetric.\n %abbrev nat`union = nat`max.\n %abbrev nat`false-implies-union = nat`false-implies-max.\n %abbrev nat`union-deterministic = nat`max-deterministic.\n %abbrev nat`union-total* = nat`max-total*.\n %abbrev nat`union-commutative = nat`max-commutative.\n %abbrev nat`union-associative = nat`max-associative.\n %abbrev nat`union-associative* = nat`max-associative*.\n %abbrev nat`union-left-preserves-leq* = nat`max-left-preserves-le*.\n %abbrev nat`union-preserves-leq = nat`max-preserves-le.\n %abbrev nat`union-implies-leq* = [G] [L] nat`max-implies-ge G L IG.\n %abbrev nat`union-implies-leq = nat`max-implies-ge.\n %abbrev nat`union-is-lub = nat`max-is-lub.\n\n %abbrev nat`intersection = nat`min.\n %abbrev nat`false-implies-intersection = nat`false-implies-min.\n %abbrev nat`intersection-deterministic = nat`min-deterministic.\n %abbrev nat`intersection-total* = nat`min-total*.\n %abbrev nat`intersection-commutative = nat`min-commutative.\n %abbrev nat`intersection-associative = nat`min-associative.\n %abbrev nat`intersection-associative* = nat`min-associative*.\n %abbrev nat`intersection-implies-leq* = [M] [L] nat`min-implies-ge M L IG.\n %abbrev nat`intersection-left-preserves-leq* = nat`min-left-preserves-le*.\n\n %abbrev nat`intersection-is-glb = nat`min-is-glb.\n %abbrev nat`intersection-right-distributes-over-union = \n         nat`min-right-distributes-over-max.\n %abbrev nat`union-right-distributes-over-intersection = \n         nat`max-right-distributes-over-min.\n\n\n%%%% Functor Use\n\n\n\n%%%% Definitions of Maps\n\nmap : type.\n\n\nmap/0 : map.\n\nmap/+ : nat -> nat -> map -> map.\n\n\n\n%%%% Relations on maps\n\n\n\neq : map -> map -> type.\n\n\neq/ : eq M M.\n\n\n\nne : map -> map -> type.\n\n\nne/L : ne map/0 (map/+ _ _ _).\n\nne/R : ne (map/+ _ _ _) map/0.\n\nne/N : nat`ne N1 N2 -> ne (map/+ N1 _ _) (map/+ N2 _ _).\n\nne/D : nat`ne D1 D2 -> ne (map/+ _ D1 _) (map/+ _ D2 _).\n\nne/+ : ne M1 M2 -> ne (map/+ _ _ M1) (map/+ _ _ M2).\n\n\n\neq? : map -> map -> bool -> type.\n\n\neq?/yes : eq? X X true.\n\neq?/no : eq? X Y false\n    <- ne X Y.\n\n\n\nlookup : map -> nat -> nat -> type.\n\n\nlookup/= : lookup (map/+ N1 D _) N2 D\n    <- nat`eq N1 N2.\n\nlookup/> : lookup (map/+ N1 _ F) N2 D\n    <- plus (s N0) N1 N2\n    <- lookup F N0 D.\n\n\nnot-member : map -> nat -> type.\n\n\nnot-member/0 : not-member map/0 M.\n\nnot-member/< : not-member (map/+ N _ F) M\n    <- gt N M.\n\nnot-member/> : not-member (map/+ N _ F) M\n    <- plus (s M1) N M\n    <- not-member F M1.\n\n\n\nmember? : map -> nat -> bool -> type.\n\n\nmember?/in : member? M N true\n    <- lookup M N _.\n\nmember?/out : member? M N false\n    <- not-member M N.\n\n\n\ndisjoint : map -> map -> type.\n\n\ndisjoint/L : disjoint map/0 M.\n\ndisjoint/R : disjoint M map/0.\n\ndisjoint/< : disjoint (map/+ N1 D1 M1) (map/+ N2 D2 M2)\n    <- nat`plus (s N0) N1 N2\n    <- disjoint M1 (map/+ N0 D2 M2).\n\ndisjoint/> : disjoint (map/+ N1 D1 M1) (map/+ N2 D2 M2)\n    <- nat`plus (s N3) N2 N1\n    <- disjoint (map/+ N3 D1 M1) M2.\n\n\n\ndisjoint? : map -> map -> bool -> type.\n\n\ndisjoint?/yes : disjoint M1 M2 -> disjoint? M1 M2 true.\n\ndisjoint?/no :\n\tlookup M1 N D1 ->\n\tlookup M2 N D2 ->\n    disjoint? M1 M2 false.\n\n\n\nsize : map -> nat -> type.\n\n\nsize/0 : size map/0 z.\n\nsize/+ : size (map/+ _ _ M) (s N)\n    <- size M N.\n\n\n\n%% useful for proving termination on map operations:\n\nbound : map -> nat -> type.\n\n\nbound/0 : bound map/0 z.\n\nbound/+ : bound (map/+ N1 D M) N3\n    <- bound M N2\n    <- plus (s N1) N2 N3.\n\n\n\nshift : nat -> map -> map -> type.\n\n\nshift/0 : shift _ map/0 map/0.\n\nshift/+ : shift N1 (map/+ N2 D M) (map/+ N3 D M)\n    <- plus (s N1) N2 N3.\n\n\n\nupdate : map -> nat -> nat -> map -> type.\n\n\nupdate/0 : update map/0 N D (map/+ N D map/0).\n\nupdate/= : update (map/+ N1 _ F) N2 D (map/+ N2 D F)\n    <- nat`eq N1 N2.\n\nupdate/< : update (map/+ N1 D1 F) N2 D2 (map/+ N2 D2 (map/+ N3 D1 F))\n    <- plus (s N3) N2 N1.\n\nupdate/> : update (map/+ N1 D1 F1) N2 D2 (map/+ N1 D1 F2)\n    <- plus (s N0) N1 N2\n    <- update F1 N0 D2 F2.\n\n\n\n\n%%%% Theorems\n\n\n\n%%% Theorems about eq\n\n\n%theorem meta-eq :\n\tforall {M} {N} {E:eq M N}\n\ttrue.\n- : meta-eq M M eq/.\n%worlds () (meta-eq _ _ _).\n%total {} (meta-eq _ _ _).\n%reduces M = N (meta-eq M N _).\n\n%theorem false-implies-eq : \n\tforall* {M} {M'} forall {F:void} exists {E:eq M M'} true.\n%worlds () (false-implies-eq _  M=M').\n%total {} (false-implies-eq _ _).\n\n%theorem eq-reflexive : forall {M} exists {E:eq M M} true.\n- : eq-reflexive _ eq/.\n%worlds () (eq-reflexive M  M=M).\n%total {} (eq-reflexive _ _).\n\n%theorem eq-symmetric :\n\tforall* {M} {M'}\n\tforall {E1:eq M M'}\n\texists {E2:eq M' M}\n\ttrue.\n- : eq-symmetric eq/ eq/.\n%worlds () (eq-symmetric M=M'  M'=M).\n%total {} (eq-symmetric _ _).\n\n%theorem eq-transitive:\n\tforall* {M1} {M2} {M3}\n\tforall {E12:eq M1 M2} {E23:eq M2 M3}\n\texists {E13:eq M1 M3}\n\ttrue.\n- : eq-transitive eq/ eq/ eq/.\n%worlds () (eq-transitive M1=M2 M2=M3  M1=M3).\n%total {} (eq-transitive _ _ _).\n\n\n%theorem map/+-preserves-eq :\n\tforall* {N} {NP} {D} {DP} {F} {FP}\n\tforall {EN:nat`eq N NP} {ED:nat`eq D DP} {EF:eq F FP}\n\texists {E:eq (map/+ N D F) (map/+ NP DP FP)}\n\ttrue.\n- : map/+-preserves-eq nat`eq/ nat`eq/ eq/ eq/.\n%worlds () (map/+-preserves-eq N=N' D=D' F=F'  NDF=N'D'F').\n%total {} (map/+-preserves-eq _ _ _ _).\n\n\n%theorem map/+-preserves-eq-converse :\n\tforall* {N} {NP} {D} {DP} {F} {FP}\n\tforall {E:eq (map/+ N D F) (map/+ NP DP FP)}\n\texists {EN:nat`eq N NP} {ED:nat`eq D DP} {EF:eq F FP}\n\ttrue.\n\n- : map/+-preserves-eq-converse eq/ nat`eq/ nat`eq/ eq/.\n\n%worlds () (map/+-preserves-eq-converse _ _ _ _).\n%total {} (map/+-preserves-eq-converse _ _ _ _).\n\n\n%theorem eq-no-occur :\n\tforall*  {M} {N} {D}\n\tforall {E:eq M (map/+ N D M)}\n\texists {F:void}\n\ttrue.\n\n%worlds () (eq-no-occur _ _).\n%total {} (eq-no-occur _ _).\n\n\n%theorem eq-contradiction :\n\tforall* {N} {D} {M}\n\tforall {E:eq map/0 (map/+ N D M)}\n\texists {F:void}\n\ttrue.\n\n%worlds () (eq-contradiction _ _).\n%total {} (eq-contradiction _ _).\n\n\n\n%%% Theorems about ne\n\n\n%theorem false-implies-ne :\n\tforall* {M1} {M2}\n\tforall {F:void}\n\texists {N:ne M1 M2}\n\ttrue.\n\n%worlds () (false-implies-ne _ _).\n%total { } (false-implies-ne _ _).\n\n\n%theorem ne-respects-eq :\n\tforall* {M11} {M12} {M21} {M22}\n\tforall {N1:ne M11 M12} {E1:eq M11 M21} {E2:eq M12 M22}\n\texists {N2:ne M21 M22}\n\ttrue.\n\n- : ne-respects-eq N eq/ eq/ N.\n\n%worlds () (ne-respects-eq _ _ _ _).\n%total { } (ne-respects-eq _ _ _ _).\n\n\n%theorem ne-anti-reflexive :\n\tforall* {M}\n\tforall {N:ne M M}\n\texists {F:void}\n\ttrue.\n\n- : ne-anti-reflexive (ne/N N) F\n    <- nat`ne-anti-reflexive N F.\n\n- : ne-anti-reflexive (ne/D N) F\n    <- nat`ne-anti-reflexive N F.\n\n- : ne-anti-reflexive (ne/+ N) F\n    <- ne-anti-reflexive N F.\n\n%worlds () (ne-anti-reflexive _ _).\n%total (N) (ne-anti-reflexive N _).\n\n\n%theorem ne-symmetric :\n\tforall* {M1} {M2}\n\tforall {N1:ne M1 M2}\n\texists {N2:ne M2 M1}\n\ttrue.\n\n- : ne-symmetric ne/L ne/R.\n\n- : ne-symmetric ne/R ne/L.\n\n- : ne-symmetric (ne/N N1) (ne/N N2)\n    <- nat`ne-symmetric N1 N2.\n\n- : ne-symmetric (ne/D N1) (ne/D N2)\n    <- nat`ne-symmetric N1 N2.\n\n- : ne-symmetric (ne/+ N1) (ne/+ N2)\n    <- ne-symmetric N1 N2.\n\n%worlds () (ne-symmetric _ _).\n%total (N) (ne-symmetric N _).\n\n\n%theorem eq-ne-implies-false :\n        forall* {X} {Y}\n        forall {D1:eq X Y} {D2:ne X Y}\n        exists {F:void}\n        true.\n\n- : eq-ne-implies-false eq/ X<>X F\n    <- ne-anti-reflexive X<>X F.\n\n%worlds () (eq-ne-implies-false _ _ _).\n%total { } (eq-ne-implies-false _ _ _).\n\n\n%theorem eq?-total* :\n        forall {M} {N}\n        exists {B} {T:eq? M N B}\n        true.\n\n%abbrev eq?-total = eq?-total* _ _ _.\n\n%theorem eq?-total/+ :\n\tforall* {N1} {D1} {N2} {D2} {M2} {EN} {ED} {EM}\n\tforall {M1} \n\t       {EN?:nat`eq? N1 N2 EN}\n\t       {ED?:nat`eq? D1 D2 ED}\n\t       {EM?:eq? M1 M2 EM}\n\texists {B}\n\t       {E?:eq? (map/+ N1 D1 M1) (map/+ N2 D2 M2) B}\n\ttrue.\n\n- : eq?-total eq?/yes.\n\n- : eq?-total (eq?/no ne/L).\n\n- : eq?-total (eq?/no ne/R).\n\n- : eq?-total E?\n    <- nat`eq?-total EN?\n    <- nat`eq?-total ED?\n    <- eq?-total EM?\n    <- eq?-total/+ _ EN? ED? EM? _ E?.\n\n- : eq?-total/+ _ (nat`eq?/yes) (nat`eq?/yes) (eq?/yes) _ eq?/yes.\n\n- : eq?-total/+ _ (nat`eq?/no N) _ _ _ (eq?/no (ne/N N)).\n\n- : eq?-total/+ _ _ (nat`eq?/no N) _ _ (eq?/no (ne/D N)).\n\n- : eq?-total/+ _ _ _ (eq?/no N) _ (eq?/no (ne/+ N)).\n\n%worlds ()   (eq?-total* _ _ _ _) (eq?-total/+ _ _ _ _ _ _).\n%total (M W) (eq?-total* M _ _ _) (eq?-total/+ W _ _ _ _ _).\n\n\n\n%%% Theorems about lookup\n\n\n%theorem false-implies-lookup : \n\tforall* {M} {N} {D}\n\tforall {F:void}\n\texists {L:lookup M N D}\n\ttrue.\n\n%worlds () (false-implies-lookup _  F^N=D).\n%total {} (false-implies-lookup _ _).\n\n%theorem lookup-respects-eq :\n\tforall* {M} {N} {D} {MP} {NP} {DP}\n\tforall {L:lookup M N D} {EM:eq M MP} {EN:nat`eq N NP} {ED:nat`eq D DP}\n\texists {LP:lookup MP NP DP}\n\ttrue.\n\n- : lookup-respects-eq L eq/ nat`eq/ nat`eq/ L.\n\n%worlds () (lookup-respects-eq M^N=D M=M' N=N' D=D'  M'^N'=D').\n%total {} (lookup-respects-eq _ _ _ _ _).\n\n%theorem lookup-deterministic :\n\tforall* {M} {N} {D} {MP} {NP} {DP}\n\tforall {L:lookup M N D} {LP:lookup MP NP DP}\n               {EM:eq M MP} {EN:nat`eq N NP}\n\texists {ED:nat`eq D DP}\n\ttrue.\n\n- : lookup-deterministic (lookup/= nat`eq/) (lookup/= nat`eq/) eq/ nat`eq/ nat`eq/.\n\n- : lookup-deterministic (lookup/> F^N0=D   N0+1+N1=N2) \n                         (lookup/> F^N0'=D' N0'+1+N1=N2) eq/ nat`eq/ D=D'\n    <- plus-right-cancels N0+1+N1=N2 N0'+1+N1=N2 nat`eq/ nat`eq/ N0+1=N0'+1\n    <- succ-cancels N0+1=N0'+1 N0=N0'\n    <- lookup-deterministic F^N0=D F^N0'=D' eq/ N0=N0' D=D'.\n\n%% contradiction cases\n- : lookup-deterministic (lookup/= nat`eq/) (lookup/> _ N0+1+N=N) \n                         eq/ nat`eq/ D=D'\n    <- plus-implies-gt N0+1+N=N nat`eq/ N>N\n    <- gt-anti-reflexive N>N FALSE\n    <- nat`false-implies-eq FALSE D=D'.\n\n- : lookup-deterministic (lookup/> _ N0+1+N=N) (lookup/= nat`eq/)\n                         eq/ nat`eq/ D=D'\n    <- plus-implies-gt N0+1+N=N nat`eq/ N>N\n    <- gt-anti-reflexive N>N FALSE\n    <- nat`false-implies-eq FALSE D=D'.\n\n%worlds () (lookup-deterministic M^N=D M'^N'=D' M=M' N=N'  D=D').\n%total (L) (lookup-deterministic L _ _ _ _).\n\n\n%% lookup is NOT total\n\n\n%theorem lookup-contradiction :\n\tforall* {N} {D}\n\tforall {L:lookup map/0 N D}\n\texists {F:void}\n\ttrue.\n\n%worlds () (lookup-contradiction _ _).\n%total { } (lookup-contradiction _ _).\n\n\n%theorem lookup-one-choice :\n\tforall* {N1} {D1} {N2} {D2}\n\tforall  {L:lookup (map/+ N1 D1 map/0) N2 D2}\n\texists  {NE:nat`eq N1 N2} {DE:nat`eq D1 D2}\n\ttrue.\n\n- : lookup-one-choice (lookup/= nat`eq/) nat`eq/ nat`eq/.\n\n%worlds () (lookup-one-choice _ _ _).\n%total { } (lookup-one-choice _ _ _).\n\n\n%theorem lookup-ne-implies-ne :\n\tforall* {M1} {N1} {D1} {M2} {N2} {D2}\n\tforall {L1:lookup M1 N1 D1}\n\t       {L2:lookup M2 N2 D2}\n\t       {EN:nat`eq N1 N2}\n\t       {ND:nat`ne D1 D2}\n\texists {NM:ne M1 M2}\n\ttrue.\n\n%theorem lookup-ne-implies-ne/L :\n\tforall* {M1} {N1} {D1} {M2} {N2} {D2} {B}\n\tforall {L1:lookup M1 N1 D1}\n\t       {L2:lookup M2 N2 D2}\n\t       {EN:nat`eq N1 N2}\n\t       {ND:nat`ne D1 D2}\n\t       {EM?:eq? M1 M2 B}\n\texists {NM:ne M1 M2}\n\ttrue.\n\n- : lookup-ne-implies-ne L1 L2 EN ND NM\n    <- eq?-total EM?\n    <- lookup-ne-implies-ne/L L1 L2 EN ND EM? NM.\n\n- : lookup-ne-implies-ne/L L1 L2 _ _ (eq?/no NM) NM.\n\n- : lookup-ne-implies-ne/L L1 L2 nat`eq/ D1<>D2 eq?/yes NM\n    <- lookup-deterministic L1 L2 eq/ nat`eq/ D1=D2\n    <- nat`eq-ne-implies-false D1=D2 D1<>D2 F\n    <- false-implies-ne F NM.\n\n%worlds () (lookup-ne-implies-ne/L _ _ _ _ _ _).\n%total { } (lookup-ne-implies-ne/L _ _ _ _ _ _).\n\n%worlds () (lookup-ne-implies-ne _ _ _ _ _).\n%total { } (lookup-ne-implies-ne _ _ _ _ _).\n\n\n\n%%% Theorems about not-member\n\n\n%theorem false-implies-not-member : \n\tforall* {M} {N} forall {F:void} exists {D:not-member M N} true.\n\n%worlds () (false-implies-not-member _  N-not-in-member-M).\n%total {} (false-implies-not-member _ _).\n\n\n%theorem not-member-respects-eq :\n\tforall* {M} {N} {MP} {NP}\n\tforall {D:not-member M N} {EM:eq M MP} {EN:nat`eq N NP}\n\texists {DP:not-member MP NP}\n\ttrue.\n\n- : not-member-respects-eq D eq/ nat`eq/ D.\n\n%worlds () (not-member-respects-eq _ _ _ _).\n%total {} (not-member-respects-eq _ _ _ _).\n\n\n%% not-member is NOT deterministic\n\n%theorem not-member-total* :\n\tforall {M}\n\texists {N} {F:not-member M N}\n\ttrue.\n\n- : not-member-total* map/0 z not-member/0.\n\n- : not-member-total* (map/+ N1 _ M) N3 (not-member/> F N+1+N1=N3)\n    <- not-member-total* M N F\n    <- plus-total* (s N) N1 N3 N+1+N1=N3.\n\n%worlds () (not-member-total* M  N N-not-in-member-of-M).\n%total (M) (not-member-total* M _ _).\n\n%abbrev not-member-total = not-member-total* _ _.\n\n\n%theorem not-member-lookup-not-equal :\n\tforall* {M} {N1} {N2} {D2}\n\tforall {F:not-member M N1} {L:lookup M N2 D2}\n\texists {NE:nat`ne N1 N2}\n\ttrue.\n\n- : not-member-lookup-not-equal (not-member/< N2>N1) (lookup/= nat`eq/) (nat`ne/< N2>N1).\n\n- : not-member-lookup-not-equal (not-member/< N1>N3) (lookup/> _ N0+1+N1=N2) \n                           (nat`ne/< N2>N3)\n    <- plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1\n    <- gt-transitive N2>N1 N1>N3 N2>N3.\n\n- : not-member-lookup-not-equal (not-member/> _ X+1+N2=N1) (lookup/= nat`eq/) (nat`ne/> N1>N2)\n    <- plus-implies-gt X+1+N2=N1 nat`eq/ N1>N2.\n\n- : not-member-lookup-not-equal (not-member/> F N4+1+N1=N3) (lookup/> L N0+1+N1=N2)\n                           N3<>N2\n    <- not-member-lookup-not-equal F L N4<>N0\n    <- succ-preserves-ne N4<>N0 N4+1<>N0+1\n    <- plus-right-preserves-ne* N4+1<>N0+1 N4+1+N1=N3 N0+1+N1=N2 N3<>N2.\n\n%worlds () (not-member-lookup-not-equal N1-not-in-member-of-M M^N2=D  N1<>N2).\n%total (F) (not-member-lookup-not-equal F _ _).\n\n\n%theorem not-member-contradiction :\n\tforall* {M} {N} {D}\n\tforall {F:not-member (map/+ N D M) N}\n        exists {V:void}\n\ttrue.\n\n- : not-member-contradiction (not-member/< N>N) V\n    <- nat`gt-anti-reflexive N>N V.\n\n- : not-member-contradiction (not-member/> _ N0+1+N=N) V\n    <- nat`plus-implies-gt N0+1+N=N nat`eq/ N>N\n    <- nat`gt-anti-reflexive N>N V.\n\n%worlds () (not-member-contradiction _ _).\n%total {} (not-member-contradiction _ _).\n\n\n%theorem ne-implies-unit-map-not-member :\n\tforall* {N1} {D} {N2}\n\tforall {NE:nat`ne N1 N2}\n\texists {F:not-member (map/+ N1 D map/0) N2}\n\ttrue.\n\n- : ne-implies-unit-map-not-member \n     (nat`ne/< N1<N2) (not-member/> not-member/0 N0+1+N1=N2)\n    <- nat`gt-implies-plus N1<N2 N0 N0+1+N1=N2.\n\n- : ne-implies-unit-map-not-member\n     (nat`ne/> N1>N2) (not-member/< N1>N2).\n\n%worlds () (ne-implies-unit-map-not-member _ _).\n%total { } (ne-implies-unit-map-not-member _ _).\n\n\n%theorem plus-right-preserves-not-member* :\n\tforall* {M} {N1} {D} {N2} {N} {N3} {N4}\n        forall {F:not-member (map/+ N1 D M) N2}\n               {P1:plus N1 N N3} {P2:plus N2 N N4}\n        exists {FP:not-member (map/+ N3 D M) N4}\n\ttrue.\n\n- : plus-right-preserves-not-member* (not-member/< N2>N1) N1+N=N3 N2+N=N4 (not-member/< N4>N3)\n    <- nat`plus-right-preserves-gt* N2>N1 N1+N=N3 N2+N=N4 N4>N3.\n\n- : plus-right-preserves-not-member* (not-member/> F10 N0+1+N1=N2) N1+N=N3 N2+N=N4\n                                (not-member/> F10 N0+1+N3=N4)\n    <- nat`plus-associative* N0+1+N1=N2 N2+N=N4 N1+N=N3 N0+1+N3=N4.\n\n%worlds () (plus-right-preserves-not-member* _ _ _ _).\n%total {} (plus-right-preserves-not-member* _ _ _ _).\n\n\n%theorem not-member-lookup-implies-ne :\n\tforall* {M1} {N1} {M2} {N2} {D2}\n\tforall {L1:not-member M1 N1}\n\t       {L2:lookup M2 N2 D2}\n\t       {EN:nat`eq N1 N2}\n\texists {NM:ne M1 M2}\n\ttrue.\n\n%theorem not-member-lookup-implies-ne/L :\n\tforall* {M1} {N1} {M2} {N2} {D2} {B}\n\tforall {L1:not-member M1 N1}\n\t       {L2:lookup M2 N2 D2}\n\t       {EN:nat`eq N1 N2}\n\t       {EM?:eq? M1 M2 B}\n\texists {NM:ne M1 M2}\n\ttrue.\n\n- : not-member-lookup-implies-ne F1 L2 EN NM\n    <- eq?-total EM?\n    <- not-member-lookup-implies-ne/L F1 L2 EN EM? NM.\n\n- : not-member-lookup-implies-ne/L _ _ _ (eq?/no NM) NM.\n\n- : not-member-lookup-implies-ne/L F1 L2 nat`eq/ eq?/yes NM\n    <- not-member-lookup-not-equal F1 L2 N<>N\n    <- nat`ne-anti-reflexive N<>N F\n    <- false-implies-ne F NM.\n\n%worlds () (not-member-lookup-implies-ne/L _ _ _ _ _).\n%total { } (not-member-lookup-implies-ne/L _ _ _ _ _).\n\n%worlds () (not-member-lookup-implies-ne _ _ _ _).\n%total { } (not-member-lookup-implies-ne _ _ _ _).\n\n\n\n%%% Theorems about map/member\n\n\n%theorem false-implies-member? :\n\tforall* {M} {N} {D}\n\tforall {F:void}\n\texists {MD:member? M N D}\n\ttrue.\n\n%worlds () (false-implies-member? _ _).\n%total {} (false-implies-member? _ _).\n\n\n%theorem member?-respects-eq :\n\tforall* {M1} {N1} {B1} {M2} {N2} {B2}\n\tforall  {MD1:member? M1 N1 B1}\n\t\t{EM:eq M1 M2}\n\t\t{EN:nat`eq N1 N2}\n\t\t{BE:bool`eq B1 B2}\n\texists  {MD2:member? M2 N2 B2}\n\ttrue.\n\n- : member?-respects-eq MD eq/ nat`eq/ bool`eq/ MD.\n\n%worlds () (member?-respects-eq _ _ _ _ _).\n%total { } (member?-respects-eq _ _ _ _ _).\n\n\n%theorem member?-deterministic :\n\tforall* {M1} {N1} {B1} {M2} {N2} {B2}\n\tforall  {MD1:member? M1 N1 B1}\n\t\t{MD2:member? M2 N2 B2}\n\t\t{EM:eq M1 M2}\n\t\t{EN:nat`eq N1 N2}\n\texists\t{BE:bool`eq B1 B2}\n\ttrue.\n\n- : member?-deterministic _ _ _ _ bool`eq/.\n\n- : member?-deterministic (member?/in L) (member?/out F) eq/ nat`eq/ BE\n    <- not-member-lookup-not-equal F L NE\n    <- nat`ne-anti-reflexive NE V\n    <- bool`false-implies-eq V BE.\n\n- : member?-deterministic (member?/out F) (member?/in L) eq/ nat`eq/ BE\n    <- not-member-lookup-not-equal F L NE\n    <- nat`ne-anti-reflexive NE V\n    <- bool`false-implies-eq V BE.\n\n%worlds () (member?-deterministic _ _ _ _ _).\n%total { } (member?-deterministic _ _ _ _ _).\n\n\n%theorem member?-total* :\n\tforall {M} {N}\n\texists {B} {MD:member? M N B}\n\ttrue.\n\n%% we need a lemma\n%theorem member?-map/+-total :\n\tforall {N1} {D1} {M1} {N2} {C} {CMP:nat`compare N1 N2 C}\n\texists {B} {MD:member? (map/+ N1 D1 M1) N2 B}\n\ttrue.\n\n%% and this lemma needs a lemma\n%theorem member?-map/+-complete :\n\tforall {N1} {D1} {M1} {N2} {N0} {P:plus (s N0) N1 N2}\n               {B} {MD1:member? M1 N0 B}\n\texists {MD:member? (map/+ N1 D1 M1) N2 B}\n\ttrue.\n\n- : member?-total* map/0 N false (member?/out not-member/0).\n\n- : member?-total* (map/+ N1 D1 M1) N2 B MD\n    <- nat`compare-total* N1 N2 C CMP\n    <- member?-map/+-total N1 D1 M1 N2 C CMP B MD.\n\n- : member?-map/+-total N1 D1 M1 N2 equal CMP true \n                           (member?/in (lookup/= N1=N2))\n    <- equal-implies-eq CMP N1=N2.\n\n- : member?-map/+-total N1 D1 M1 N2 greater CMP false \n                           (member?/out (not-member/< N1>N2))\n    <- greater-implies-gt CMP N1>N2.\n\n- : member?-map/+-total N1 D1 M1 N2 less CMP B MD\n    <- less-implies-lt CMP N2>N1\n    <- gt-implies-plus N2>N1 N0 N0+1+N1=N2\n    <- member?-total* M1 N0 B MD1\n    <- member?-map/+-complete N1 D1 M1 N2 N0 N0+1+N1=N2 B MD1 MD.\n\n- : member?-map/+-complete N1 D1 M1 N2 N0 N0+1+N1=N2 true (member?/in L1)\n                              (member?/in (lookup/> L1 N0+1+N1=N2)).\n\n- : member?-map/+-complete N1 D1 M1 N2 N0 N0+1+N1=N2 false (member?/out F1)\n                              (member?/out (not-member/> F1 N0+1+N1=N2)).\n\n%worlds () (member?-map/+-complete _ _ _ _ _ _ _ _ _).\n%total {} (member?-map/+-complete _ _ _ _ _ _ _ _ _).\n\n%worlds () (member?-total* _ _ _ _)\n           (member?-map/+-total _ _ _ _ _ _ _ _).\n%total (M M1) (member?-total* M _ _ _) \n              (member?-map/+-total _ _ M1 _ _ _ _ _).\n\n%abbrev member?-total = member?-total* _ _ _.\n\n\n%theorem in-implies-lookup :\n\tforall* {M} {N}\n\tforall {MD:member? M N true}\n\texists {D} {L:lookup M N D}\n\ttrue.\n\n- : in-implies-lookup (member?/in L) _ L.\n\n%worlds () (in-implies-lookup _ _ _).\n%total {} (in-implies-lookup _ _ _).\n\n\n%theorem out-implies-not-member :\n\tforall* {M} {N}\n\tforall {MD:member? M N false}\n\texists {F:not-member M N}\n\ttrue.\n\n- : out-implies-not-member (member?/out F) F.\n\n%worlds () (out-implies-not-member _ _).\n%total {} (out-implies-not-member _ _).\n\n\n\n%%% Theorems about disjoint\n\n\n%theorem false-implies-disjoint :\n\tforall* {M1} {M2}\n\tforall {F:void}\n\texists {D:disjoint M1 M2}\n\ttrue.\n\n%worlds () (false-implies-disjoint _ _).\n%total { } (false-implies-disjoint _ _).\n\n\n%theorem disjoint-respects-eq :\n\tforall* {M1} {M2} {M1P} {M2P}\n\tforall {A:disjoint M1 M2} {E1:eq M1 M1P} {E2:eq M2 M2P} \n\texists {AP:disjoint M1P M2P}\n\ttrue.\n\n- : disjoint-respects-eq A eq/ eq/ A.\n\n%worlds () (disjoint-respects-eq _ _ _ _).\n%total {} (disjoint-respects-eq _ _ _ _).\n%reduces A = AP (disjoint-respects-eq A _ _ AP).\n\n\n%theorem disjoint/=-contradiction :\n\tforall* {N1} {D1} {M1} {N2} {D2} {M2}\n\tforall {A:disjoint (map/+ N1 D1 M1) (map/+ N2 D2 M2)}\n\t       {G:nat`eq N1 N2}\n\texists {F:void}\n\ttrue.\n\n- : disjoint/=-contradiction (disjoint/< _ N0+1+N=N) nat`eq/ F\n    <- nat`plus-implies-gt N0+1+N=N nat`eq/ N>N\n    <- nat`gt-anti-reflexive N>N F.\n\n- : disjoint/=-contradiction (disjoint/> _ N3+1+N=N) nat`eq/ F\n    <- nat`plus-implies-gt N3+1+N=N nat`eq/ N>N\n    <- nat`gt-anti-reflexive N>N F.\n\n%worlds () (disjoint/=-contradiction _ _ _).\n%total { } (disjoint/=-contradiction _ _ _).\n\n\n%theorem disjoint/<-inversion :\n\tforall* {N1} {D1} {M1} {N2} {D2} {M2} {N0}\n\tforall {A:disjoint (map/+ N1 D1 M1) (map/+ N2 D2 M2)}\n               {P:plus (s N0) N1 N2} \t       \n\texists {AP:disjoint M1 (map/+ N0 D2 M2)}\n\ttrue.\n\n- : disjoint/<-inversion (disjoint/< A P) P' A'\n    <- nat`plus-right-cancels P P' nat`eq/ nat`eq/ N0+1=N0'+1\n    <- succ-cancels N0+1=N0'+1 N0=N0P\n    <- map/+-preserves-eq N0=N0P nat`eq/ eq/ M022=M022'\n    <- disjoint-respects-eq A eq/ M022=M022' A'.\n\n- : disjoint/<-inversion (disjoint/> A' N3+1+N2=N1) N0+1+N1=N2 A\n    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2\n    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1\n    <- nat`gt-anti-symmetric N1>N2 N2>N1 F\n    <- false-implies-eq F M311=M1\n    <- false-implies-eq F M2=M022\n    <- disjoint-respects-eq A' M311=M1 M2=M022 A.\n\n%worlds () (disjoint/<-inversion _ _ _).\n%total {}  (disjoint/<-inversion _ _ _).\n%reduces AP < A (disjoint/<-inversion A _ AP).\n\n\n%theorem disjoint/>-inversion :\n\tforall* {N1} {D1} {M1} {N2} {D2} {M2} {N3}\n\tforall {A:disjoint (map/+ N1 D1 M1) (map/+ N2 D2 M2)}\n\t       {P:plus (s N3) N2 N1}\n\texists {AP:disjoint (map/+ N3 D1 M1) M2}\n\ttrue.\n\n- : disjoint/>-inversion (disjoint/> A P) P' A'\n    <- nat`plus-right-cancels P P' nat`eq/ nat`eq/ N3+1=N3'+1\n    <- succ-cancels N3+1=N3'+1 N3=N3P\n    <- map/+-preserves-eq N3=N3P nat`eq/ eq/ M311=M311'\n    <- disjoint-respects-eq A M311=M311' eq/ A'.\n\n- : disjoint/>-inversion (disjoint/< A' N0+1+N1=N2) N3+1+N2=N1 A\n    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2\n    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1\n    <- nat`gt-anti-symmetric N1>N2 N2>N1 F\n    <- false-implies-eq F M1=M311\n    <- false-implies-eq F M022=M2\n    <- disjoint-respects-eq A' M1=M311 M022=M2 A.\n\n%worlds () (disjoint/>-inversion _ _ _).\n%total { } (disjoint/>-inversion _ _ _).\n%reduces AP < A (disjoint/>-inversion A _ AP).\n\n\n%theorem disjoint-anti-reflexive :\n\tforall* {M}\n\tforall {D:disjoint M M}\n\texists {E:eq map/0 M}\n\ttrue.\n\n- : disjoint-anti-reflexive disjoint/L eq/.\n\n- : disjoint-anti-reflexive disjoint/R eq/.\n\n- : disjoint-anti-reflexive (A:disjoint (map/+ N D M) (map/+ N D M)) E\n    <- disjoint/=-contradiction A nat`eq/ F\n    <- false-implies-eq F E.\n\n%worlds () (disjoint-anti-reflexive _ _).\n%total { } (disjoint-anti-reflexive _ _).\n\n\n%theorem disjoint-symmetric :\n\tforall* {M1} {M2}\n\tforall {D:disjoint M1 M2} \n\texists {D:disjoint M2 M1}\n\ttrue.\n\n- : disjoint-symmetric disjoint/L disjoint/R.\n\n- : disjoint-symmetric disjoint/R disjoint/L.\n\n- : disjoint-symmetric (disjoint/< D P) (disjoint/> D' P)\n    <- disjoint-symmetric D D'.\n\n- : disjoint-symmetric (disjoint/> D P) (disjoint/< D' P)\n    <- disjoint-symmetric D D'.\n\n%worlds () (disjoint-symmetric _ _).\n%total (D) (disjoint-symmetric D _).\n\n\n%theorem disjoint-lookup-contradiction :\n\tforall* {M1} {M2} {N} {D1} {D2}\n\tforall {A:disjoint M1 M2}\n               {L1:lookup M1 N D1} {L2:lookup M2 N D2}\n\texists {F:void}\n\ttrue.\n\n- : disjoint-lookup-contradiction disjoint/L L _ F\n    <- lookup-contradiction L F.\n\n- : disjoint-lookup-contradiction disjoint/R _ L F\n    <- lookup-contradiction L F.\n\n- : disjoint-lookup-contradiction (disjoint/< _ N0+1+N=N)\n                                  (lookup/= nat`eq/) (lookup/= nat`eq/) F\n    <- plus-implies-gt N0+1+N=N nat`eq/ N>N\n    <- gt-anti-reflexive N>N F.\n\n- : disjoint-lookup-contradiction (disjoint/< _ N0+1+N1=N2)\n                                  (lookup/= nat`eq/) \n                                  (lookup/> _ N3+1+N2=N1) F\n    <- plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1\n    <- plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2\n    <- gt-anti-symmetric N2>N1 N1>N2 F.\n    \n- : disjoint-lookup-contradiction (disjoint/< D N0+1+N1=N2)\n                                  (lookup/> L1P N0P+1+N1=N2)\n                                  (lookup/= nat`eq/) F\n    <- plus-right-cancels N0P+1+N1=N2 N0+1+N1=N2 nat`eq/ nat`eq/ N0P+1=N0+1\n    <- succ-cancels N0P+1=N0+1 N0P=N0\n    <- lookup-respects-eq L1P eq/ N0P=N0 nat`eq/ L1\n    <- disjoint-lookup-contradiction D L1 (lookup/= nat`eq/) F.\n\n- : disjoint-lookup-contradiction (disjoint/< D N0+1+N1=N2)\n                                  (lookup/> L1 N1P+1+N1=N) \n                                  (lookup/> L2 N2P+1+N2=N) F\n    <- plus-swap-succ N0+1+N1=N2 N0+N1+1=N2\n    <- plus-associative-converse N0+N1+1=N2 N2P+1+N2=N NX\n                                 N2P+1+N0=NX NX+N1+1=N\n    <- plus-swap-succ N1P+1+N1=N N1P+N1+1=N\n    <- plus-right-cancels NX+N1+1=N N1P+N1+1=N nat`eq/ nat`eq/ NX=N1P\n    <- plus-respects-eq N2P+1+N0=NX nat`eq/ nat`eq/ NX=N1P N2P+1+N0=N1P\n    <- disjoint-lookup-contradiction D L1 (lookup/> L2 N2P+1+N0=N1P) F.\n\n- : disjoint-lookup-contradiction (disjoint/> _ N3+1+N=N)\n                                  (lookup/= nat`eq/) (lookup/= nat`eq/) F\n    <- plus-implies-gt N3+1+N=N nat`eq/ N>N\n    <- gt-anti-reflexive N>N F.\n\n- : disjoint-lookup-contradiction (disjoint/> _ N3+1+N2=N1)\n                                  (lookup/> _ N3+1+N1=N2)\n                                  (lookup/= nat`eq/) F\n    <- plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2\n    <- plus-implies-gt N3+1+N1=N2 nat`eq/ N2>N1\n    <- gt-anti-symmetric N1>N2 N2>N1 F.\n    \n- : disjoint-lookup-contradiction (disjoint/> D N3+1+N2=N1)\n                                  (lookup/= nat`eq/)\n                                  (lookup/> L2P N3P+1+N2=N1) F\n    <- plus-right-cancels N3P+1+N2=N1 N3+1+N2=N1 nat`eq/ nat`eq/ N3P+1=N3+1\n    <- succ-cancels N3P+1=N3+1 N3P=N3\n    <- lookup-respects-eq L2P eq/ N3P=N3 nat`eq/ L2\n    <- disjoint-lookup-contradiction D (lookup/= nat`eq/) L2 F.\n\n- : disjoint-lookup-contradiction (disjoint/> D N3+1+N2=N1)\n                                  (lookup/> L1 N1P+1+N1=N)\n                                  (lookup/> L2 N2P+1+N2=N) F \n    <- plus-swap-succ N3+1+N2=N1 N3+N2+1=N1\n    <- plus-associative-converse N3+N2+1=N1 N1P+1+N1=N NX\n                                 N1P+1+N3=NX NX+N2+1=N\n    <- plus-swap-succ N2P+1+N2=N N2P+N2+1=N\n    <- plus-right-cancels NX+N2+1=N N2P+N2+1=N nat`eq/ nat`eq/ NX=N2P\n    <- plus-respects-eq N1P+1+N3=NX nat`eq/ nat`eq/ NX=N2P N1P+1+N3=N2P\n    <- disjoint-lookup-contradiction D (lookup/> L1 N1P+1+N3=N2P) L2 F.\n\n%worlds () (disjoint-lookup-contradiction _ _ _ _).\n%total (D) (disjoint-lookup-contradiction D _ _ _).\n\n\n%theorem shift-left-preserves-disjoint :\n\tforall* {N} {D} {M1} {M2} {SM1}\n\tforall {A:disjoint M1 M2} {S1:shift N M1 SM1}\n        exists {SA:disjoint SM1 (map/+ N D M2)}\n        true.\n\n- : shift-left-preserves-disjoint _ shift/0 disjoint/L.\n\n- : shift-left-preserves-disjoint M111*M2 (shift/+ N+1+N1=N1P)\n                              (disjoint/> M111*M2 N1+1+N=N1P)\n    <- plus-swap-succ N+1+N1=N1P N+N1+1=N1P\n    <- plus-commutative N+N1+1=N1P N1+1+N=N1P.\n\n%worlds () (shift-left-preserves-disjoint _ _ _).\n%total { } (shift-left-preserves-disjoint _ _ _).\n\n\n%theorem shift-left-preserves-disjoint-converse :\n\tforall* {N} {D} {M1} {M2} {SM1}\n\tforall {SA:disjoint SM1 (map/+ N D M2)} {S1:shift N M1 SM1}\n        exists {A:disjoint M1 M2}\n\ttrue.\n\n- : shift-left-preserves-disjoint-converse _ shift/0 disjoint/L.\n\n- : shift-left-preserves-disjoint-converse M111*M222 (shift/+ N2+1+N3=N1)\n                                           M311*M2\n    <- plus-swap-succ N2+1+N3=N1 N2+N3+1=N1\n    <- plus-commutative N2+N3+1=N1 N3+1+N2=N1\n    <- disjoint/>-inversion M111*M222 N3+1+N2=N1 M311*M2.\n\n%worlds () (shift-left-preserves-disjoint-converse _ _ _).\n%total { } (shift-left-preserves-disjoint-converse _ _ _).\n\n\n%theorem shift-right-preserves-disjoint :\n\tforall* {N} {D} {M1} {M2} {SM2}\n\tforall {A:disjoint M1 M2} {S2:shift N M2 SM2}\n        exists {SA:disjoint (map/+ N D M1) SM2}\n\ttrue.\n\n- : shift-right-preserves-disjoint _ shift/0 disjoint/R.\n\n- : shift-right-preserves-disjoint M1*M222 (shift/+ N+1+N2=N2P)\n                               (disjoint/< M1*M222 N2+1+N=N2P)\n    <- plus-swap-succ N+1+N2=N2P N+N2+1=N2P\n    <- plus-commutative N+N2+1=N2P N2+1+N=N2P.\n\n%worlds () (shift-right-preserves-disjoint _ _ _).\n%total { } (shift-right-preserves-disjoint _ _ _).\n\n\n%theorem shift-right-preserves-disjoint-converse :\n\tforall* {N} {D} {M1} {M2} {SM2}\n\tforall {SA:disjoint (map/+ N D M1) SM2} {S2:shift N M2 SM2}\n        exists {A:disjoint M1 M2}\n\ttrue.\n\n- : shift-right-preserves-disjoint-converse _ shift/0 disjoint/R.\n\n- : shift-right-preserves-disjoint-converse M111*M322 (shift/+ N1+1+N2=N3)\n                                            M1*M222\n    <- plus-swap-succ N1+1+N2=N3 N1+N2+1=N3\n    <- plus-commutative N1+N2+1=N3 N2+1+N1=N3\n    <- disjoint/<-inversion M111*M322 N2+1+N1=N3 M1*M222.\n\n%worlds () (shift-right-preserves-disjoint-converse _ _ _).\n%total { } (shift-right-preserves-disjoint-converse _ _ _).\n\n\n%theorem shift-preserves-disjoint :\n\tforall* {N} {M1} {M2} {SM1} {SM2}\n\tforall {A:disjoint M1 M2} \n               {S1:shift N M1 SM1} {S2:shift N M2 SM2}\n\texists {SA:disjoint SM1 SM2}\n\ttrue.\n\n- : shift-preserves-disjoint _ shift/0 _ disjoint/L.\n\n- : shift-preserves-disjoint _ _ shift/0 disjoint/R.\n\n- : shift-preserves-disjoint (disjoint/< M1*M022 N0+1+N1=N2)\n                             (shift/+ N+1+N1=N4) (shift/+ N+1+N2=N5)\n                             (disjoint/< M1*M022 N0+1+N4=N5)\n    <- plus-swap-succ N+1+N1=N4 N+N1+1=N4\n    <- plus-commutative N+N1+1=N4 N1+1+N=N4\n    <- plus-commutative N0+1+N1=N2 N1+N0+1=N2\n    <- plus-associative-converse* N1+N0+1=N2 N+1+N2=N5 N+1+N1=N4 N4+N0+1=N5\n    <- plus-commutative N4+N0+1=N5 N0+1+N4=N5.\n\n- : shift-preserves-disjoint (disjoint/> M311*M2 N3+1+N2=N1)\n                             (shift/+ N+1+N1=N4) (shift/+ N+1+N2=N5)\n                             (disjoint/> M311*M2 N3+1+N5=N4)\n    <- plus-swap-succ N+1+N2=N5 N+N2+1=N5\n    <- plus-commutative N+N2+1=N5 N2+1+N=N5\n    <- plus-commutative N3+1+N2=N1 N2+N3+1=N1\n    <- plus-associative-converse* N2+N3+1=N1 N+1+N1=N4 N+1+N2=N5 N5+N3+1=N4\n    <- plus-commutative N5+N3+1=N4 N3+1+N5=N4.\n\n%worlds () (shift-preserves-disjoint _ _ _ _).\n%total { } (shift-preserves-disjoint _ _ _ _).\n\n\n%theorem shift-preserves-disjoint-converse :\n\tforall* {N} {M1} {M2} {SM1} {SM2}\n\tforall {SA:disjoint SM1 SM2}\n               {S1:shift N M1 SM1} {S2:shift N M2 SM2} \n\texists {A:disjoint M1 M2}\n\ttrue.\n\n- : shift-preserves-disjoint-converse _ shift/0 _ disjoint/L.\n\n- : shift-preserves-disjoint-converse _ _ shift/0 disjoint/R.\n\n- : shift-preserves-disjoint-converse (disjoint/< M1*M055 N0+1+N4=N5)\n                                      (shift/+ N+1+N1=N4) (shift/+ N+1+N2=N5)\n\t\t\t\t      (disjoint/< M1*M055 N0+1+N1=N2)\n    <- plus-commutative N+1+N1=N4 N1+N+1=N4\n    <- plus-swap-succ-converse N1+N+1=N4 N1+1+N=N4\n    <- plus-associative-converse N1+N+1=N4 N0+1+N4=N5 N2P N0+1+N1=N2P N2P+N+1=N5\n    <- plus-commutative N+1+N2=N5 N2+N+1=N5\n    <- plus-right-cancels N2P+N+1=N5 N2+N+1=N5 nat`eq/ nat`eq/ N2P=N2\n    <- plus-respects-eq N0+1+N1=N2P nat`eq/ nat`eq/ N2P=N2 N0+1+N1=N2.\n                                  \n- : shift-preserves-disjoint-converse (disjoint/> M611*M2 N6+1+N5=N4)\n                                      (shift/+ N+1+N1=N4) (shift/+ N+1+N2=N5)\n                                      (disjoint/> M611*M2 N6+1+N2=N1)\n    <- plus-commutative N+1+N2=N5 N2+N+1=N5\n    <- plus-swap-succ-converse N2+N+1=N5 N2+1+N=N5\n    <- plus-associative-converse N2+N+1=N5 N6+1+N5=N4 N1P N6+1+N2=N1P N1P+N+1=N4\n    <- plus-commutative N+1+N1=N4 N1+N+1=N4\n    <- plus-right-cancels N1P+N+1=N4 N1+N+1=N4 nat`eq/ nat`eq/ N1P=N1\n    <- plus-respects-eq N6+1+N2=N1P nat`eq/ nat`eq/ N1P=N1 N6+1+N2=N1.\n\n%worlds () (shift-preserves-disjoint-converse _ _ _ _).\n%total { } (shift-preserves-disjoint-converse _ _ _ _).\n\n\n%theorem ne-implies-disjoint :\n\tforall* {N1} {D1} {N2} {D2}\n\tforall\t{NE:nat`ne N1 N2}\n\texists\t{D:disjoint (map/+ N1 D1 map/0) (map/+ N2 D2 map/0)}\n\ttrue.\n\n- : ne-implies-disjoint (nat`ne/< N1<N2) \n\t(disjoint/< disjoint/L N0+1+N1=N2)\n    <- gt-implies-plus N1<N2 _ N0+1+N1=N2.\n\n- : ne-implies-disjoint (nat`ne/> N1>N2) \n\t(disjoint/> disjoint/R N3+1+N2=N1)\n    <- gt-implies-plus N1>N2 _ N3+1+N2=N1.\n\n%worlds () (ne-implies-disjoint _ _).\n%total { } (ne-implies-disjoint _ _).\n\n\n\n%%% Theorems about size\n\n\n%theorem false-implies-size :\n\tforall* {M} {N}\n\tforall {F:void}\n\texists {SZ:size M N}\n\ttrue.\n\n%worlds () (false-implies-size _ _).\n%total { } (false-implies-size _ _).\n\n\n%theorem size-total* :\n\tforall {M} \n\texists {N} {MX:size M N}\n\ttrue.\n\n- : size-total* map/0 _ size/0.\n\n- : size-total* _ _ (size/+ SZ)\n    <- size-total* _ _ SZ.\n\n%worlds () (size-total* _ _ _).\n%total (M) (size-total* M _ _).\n\n\n%abbrev size-total = size-total* _ _.\n\n\n%theorem size-deterministic :\n\tforall* {M1} {M2} {N1} {N2}\n\tforall {SZ1:size M1 N1} {SZ2:size M2 N2} {EM:eq M1 M2}\n        exists {EN:nat`eq N1 N2}\n\ttrue.\n\n- : size-deterministic size/0 size/0 eq/ nat`eq/.\n\n- : size-deterministic (size/+ N1=|M1|) (size/+ N2=|M2|) eq/ N1+1=N2+1\n    <- size-deterministic N1=|M1| N2=|M2| eq/ N1=N2\n    <- succ-deterministic N1=N2 N1+1=N2+1.\n\n%worlds () (size-deterministic _ _ _ _).\n%total (S) (size-deterministic S _ _ _).\n\n\n\n%%% Theorems about bound\n\n%theorem false-implies-bound :\n\tforall* {M} {N}\n\tforall {F:void}\n\texists {MX:bound M N}\n\ttrue.\n\n%worlds () (false-implies-bound _ _).\n%total { } (false-implies-bound _ _).\n\n\n%theorem bound-total* :\n\tforall {M} \n\texists {N} {MX:bound M N}\n\ttrue.\n\n- : bound-total* map/0 _ bound/0.\n\n- : bound-total* _ _ (bound/+ P MX)\n    <- bound-total* _ _ MX\n    <- plus-total P.\n\n%worlds () (bound-total* _ _ _).\n%total (M) (bound-total* M _ _).\n\n\n%abbrev bound-total = bound-total* _ _.\n\n\n%theorem ge-bound-implies-not-member :\n\tforall* {M} {X} {N}\n\tforall {B:bound M X} {G:nat`ge N X}\n\texists {F:not-member M N}\n\ttrue.\n\n- : ge-bound-implies-not-member bound/0 _ not-member/0.\n\n- : ge-bound-implies-not-member (bound/+ M1+1+X1=X B) N>=X (not-member/> F1 N1+1+M1=N)\n    <- nat`ge-implies-plus N>=X Y1 Y1+X=N\n    <- nat`plus-commutative M1+1+X1=X X1+M1+1=X\n    <- nat`plus-associative-converse X1+M1+1=X Y1+X=N N1 Y1+X1=N1 N1+M1+1=N\n    <- plus-swap-succ-converse N1+M1+1=N N1+1+M1=N\n    <- plus-implies-ge Y1+X1=N1 N1>=X1\n    <- ge-bound-implies-not-member B N1>=X1 F1.\n\n%worlds () (ge-bound-implies-not-member _ _ _).\n%total (B) (ge-bound-implies-not-member B _ _).\n\n\n\n%%% Theorems about shift\n\n%theorem false-implies-shift :\n\tforall* {M} {N} {M'}\n\tforall {F:void}\n\texists {S:shift N M M'}\n\ttrue.\n%worlds () (false-implies-shift _ _).\n%total { } (false-implies-shift _ _).\n\n\n%theorem shift-respects-eq :\n\tforall* {N} {M1} {M2} {N'} {M1'} {M2'}\n\tforall {S:shift N M1 M2} \n               {EN:nat`eq N N'} {E1:eq M1 M1'} {E2:eq M2 M2'}\n        exists {S':shift N' M1' M2'}\n\ttrue.\n\n- : shift-respects-eq S nat`eq/ eq/ eq/ S.\n\n%worlds () (shift-respects-eq _ _ _ _ _).\n%total { } (shift-respects-eq _ _ _ _ _).\n\n\n%theorem shift-total* :\n\tforall {N} {M1}\n\texists {M2} {S:shift N M1 M2}\n\ttrue.\n\n- : shift-total* N map/0 map/0 shift/0.\n\n- : shift-total* N1 (map/+ N2 D M) (map/+ N3 D M) (shift/+ N1+1+N2=N3)\n    <- plus-total N1+1+N2=N3.\n\n%worlds () (shift-total* _ _ _ _).\n%total { } (shift-total* _ _ _ _).\n\n%abbrev shift-total = shift-total* _ _ _.\n\n\n%theorem shift-deterministic :\n\tforall* {N} {M1} {M2} {N'} {M1'} {M2'}\n\tforall {S:shift N M1 M2} {S':shift N' M1' M2'}\n\t       {EN:nat`eq N N'} {EM1:eq M1 M1'}\n\texists {EM2:eq M2 M2'}\n\ttrue.\n\n- : shift-deterministic shift/0 shift/0 nat`eq/ eq/ eq/.\n\n- : shift-deterministic (shift/+ N1+1+N2=N3) (shift/+ N1+1+N2=N3') nat`eq/ eq/ E\n    <- plus-deterministic N1+1+N2=N3 N1+1+N2=N3' nat`eq/ nat`eq/ N3=N3P\n    <- map/+-preserves-eq N3=N3P nat`eq/ eq/ E.\n\n%worlds () (shift-deterministic _ _ _ _ _).\n%total { } (shift-deterministic _ _ _ _ _).\n\n\n%theorem shifts-add :\n\tforall* {N1} {N2} {N3} {M0} {M1} {M3}\n\tforall {S1:shift N1 M0 M1} {S2:shift N2 M1 M3} {P:plus (s N1) N2 N3}\n        exists {S3:shift N3 M0 M3}\n\ttrue.\n\n- : shifts-add shift/0 shift/0 _ shift/0.\n\n- : shifts-add (shift/+ N1+1+N4=N5) (shift/+ N2+1+N5=N7) N1+1+N2=N3\n               (shift/+ N3+1+N4=N7)          \n    <- plus-total N3+1+N4=N7'\n    <- plus-swap-succ N3+1+N4=N7' N3+N4+1=N7'\n    <- plus-swap-succ N1+1+N2=N3 N1+N2+1=N3\n    <- plus-swap-succ N1+1+N4=N5 N1+N4+1=N5\n    <- plus-commutative N1+N2+1=N3 N2+1+N1=N3\n    <- plus-associative* N2+1+N1=N3 N3+N4+1=N7' N1+N4+1=N5 N2+1+N5=N7'\n    <- plus-deterministic N2+1+N5=N7' N2+1+N5=N7 nat`eq/ nat`eq/ N7'=N7\n    <- plus-respects-eq N3+1+N4=N7' nat`eq/ nat`eq/ N7'=N7 N3+1+N4=N7.\n\n%worlds () (shifts-add _ _ _ _).\n%total { } (shifts-add _ _ _ _).\n\n\n%theorem shifts-add-converse :\n\tforall* {N1} {N2} {N3} {M0} {M3}\n\tforall {S3:shift N3 M0 M3} {P:plus (s N1) N2 N3}\n\texists {M1} {S1:shift N1 M0 M1} {S2:shift N2 M1 M3}\n        true.\n\n- : shifts-add-converse S3 P M1 S1 S2\n    <- shift-total S1\n    <- shift-total S2'\n    <- shifts-add S1 S2' P S3'\n    <- shift-deterministic S3' S3 nat`eq/ eq/ M3'=M3\n    <- shift-respects-eq S2' nat`eq/ eq/ M3'=M3 S2.\n\n%worlds () (shifts-add-converse _ _ _ _ _).\n%total { } (shifts-add-converse _ _ _ _ _).\n\n\n%theorem shift-preserves-not-member-converse* :\n        forall* {M1} {N1} {N2} {M2} {N0}\n\tforall {L2:not-member M2 N2} {S:shift N0 M1 M2}\n               {P:plus (s N0) N1 N2} \n        exists {L1:not-member M1 N1}\n\ttrue.\n\n- : shift-preserves-not-member-converse* not-member/0 shift/0 _ not-member/0.\n\n- : shift-preserves-not-member-converse* \n\t(not-member/< N1>N) (shift/+ S+1+N2=N1) S+1+N'=N\n\t(not-member/< N2>N')\n    <- plus-left-cancels-gt S+1+N2=N1 S+1+N'=N nat`eq/ N1>N N2>N'.\n\n- : shift-preserves-not-member-converse* \n\t(not-member/> F NX+1+N2=N) (shift/+ S+1+N1=N2) S+1+N'=N\n        (not-member/> F NX+1+N1=N')\n    <- plus-commutative S+1+N1=N2 N1+S+1=N2\n    <- plus-associative-converse N1+S+1=N2 NX+1+N2=N N'' NX+1+N1=N'' N''+S+1=N\n    <- plus-commutative N''+S+1=N S+1+N''=N\n    <- plus-left-cancels S+1+N''=N S+1+N'=N nat`eq/ nat`eq/ N''=N'\n    <- plus-respects-eq NX+1+N1=N'' nat`eq/ nat`eq/ N''=N' NX+1+N1=N'.\n\n%worlds () (shift-preserves-not-member-converse* _ _ _ _).\n%total { } (shift-preserves-not-member-converse* _ _ _ _).\n\n\n%theorem shift-preserves-lookup :\n        forall* {M1} {N1} {D} {N0} {M2}\n\tforall {L1:lookup M1 N1 D} {S:shift N0 M1 M2}\n        exists {N2} {P:plus (s N0) N1 N2} {L2:lookup M2 N2 D}\n\ttrue.\n\n- : shift-preserves-lookup (lookup/= nat`eq/) (shift/+ N0+1+N1=N2) _\n                           N0+1+N1=N2 (lookup/= nat`eq/).\n\n- : shift-preserves-lookup (lookup/> L N3+1+N1=N4) (shift/+ N0+1+N1=N2) _\n                           N0+1+N4=N5 (lookup/> L N3+1+N2=N5)\n    <- plus-total N0+1+N4=N5\n    <- plus-commutative N3+1+N1=N4 N1+N3+1=N4\n    <- plus-associative-converse* N1+N3+1=N4 N0+1+N4=N5 N0+1+N1=N2 N2+N3+1=N5\n    <- plus-commutative N2+N3+1=N5 N3+1+N2=N5.\n\n%worlds () (shift-preserves-lookup _ _ _ _ _).\n%total { } (shift-preserves-lookup _ _ _ _ _).\n\n\n%theorem shift-preserves-lookup* :\n        forall* {M1} {N1} {D} {N0} {M2} {N2}\n\tforall {L1:lookup M1 N1 D} {S:shift N0 M1 M2}\n               {P:plus (s N0) N1 N2} \n        exists {L2:lookup M2 N2 D}\n\ttrue.\n\n- : shift-preserves-lookup* L1 S P L2\n    <- shift-preserves-lookup L1 S _ P' L2'\n    <- plus-deterministic P' P nat`eq/ nat`eq/ N2'=N2\n    <- lookup-respects-eq L2' eq/ N2'=N2 nat`eq/ L2.\n\n%worlds () (shift-preserves-lookup* _ _ _ _).\n%total { } (shift-preserves-lookup* _ _ _ _).\n\n\n%theorem shift-preserves-lookup-converse :\n        forall* {M1} {N0} {D} {N2} {M2}\n\tforall {L2:lookup M2 N2 D} {S:shift N0 M1 M2}\n        exists {N1} {P:plus (s N0) N1 N2} {L1:lookup M1 N1 D}\n\ttrue.\n\n- : shift-preserves-lookup-converse (lookup/= nat`eq/) (shift/+ N0+1+N1=N2) _\n                                    N0+1+N1=N2 (lookup/= nat`eq/).\n\n- : shift-preserves-lookup-converse (lookup/> L N3+1+N2=N5) (shift/+ N0+1+N1=N2)\n                                    _ N0+1+N4=N5 (lookup/> L N3+1+N1=N4)\n    <- plus-commutative N0+1+N1=N2 N1+N0+1=N2\n    <- plus-associative-converse N1+N0+1=N2 N3+1+N2=N5 N4 N3+1+N1=N4 N4+N0+1=N5\n    <- plus-commutative N4+N0+1=N5 N0+1+N4=N5.\n\n%worlds () (shift-preserves-lookup-converse _ _ _ _ _).\n%total { } (shift-preserves-lookup-converse _ _ _ _ _).\n\n\n%theorem shift-preserves-lookup-converse* :\n        forall* {M1} {N1} {D} {N2} {M2} {N0}\n\tforall {L2:lookup M2 N2 D} {S:shift N0 M1 M2}\n               {P:plus (s N0) N1 N2} \n        exists {L1:lookup M1 N1 D}\n\ttrue.\n\n- : shift-preserves-lookup-converse* L2 S P L1\n    <- shift-preserves-lookup-converse L2 S _ P' L1'\n    <- plus-left-cancels P' P nat`eq/ nat`eq/ N1'=N1\n    <- lookup-respects-eq L1' eq/ N1'=N1 nat`eq/ L1.\n\n%worlds () (shift-preserves-lookup-converse* _ _ _ _).\n%total { } (shift-preserves-lookup-converse* _ _ _ _).\n\n\n%theorem shift-preserves-size :\n\tforall* {M} {N1} {N2} {S2M}\n\tforall {SZ:size M N1} {SH:shift N2 M S2M}\n\texists {SHSZ:size S2M N1}\n\ttrue.\n\n- : shift-preserves-size size/0 shift/0 size/0.\n\n- : shift-preserves-size (size/+ SZ) (shift/+ _) (size/+ SZ).\n\n%worlds () (shift-preserves-size _ _ _).\n%total { } (shift-preserves-size _ _ _).\n\n\n\n%%% Theorems about disjoint?\n\n\n%theorem disjoint?-total* :\n\tforall {M1} {M2}\n\texists {B} {D:disjoint? M1 M2 B}\n\ttrue.\n\n- : disjoint?-total* _ _ _ (disjoint?/yes disjoint/L).\n\n- : disjoint?-total* _ _ _ (disjoint?/yes disjoint/R).\n\n%theorem disjoint?-total*/+ :\n\tforall* {N1} {D1} {M1} {N2} {D2} {M2} {C}\n\tforall {S1} {S2} {SZ1:size M1 S1} {SZ2:size M2 S2} {CMP:nat`compare N1 N2 C}\n\texists {B} {D:disjoint? (map/+ N1 D1 M1) (map/+ N2 D2 M2) B}\n\ttrue.\n\n%theorem disjoint?-total*/< :\n\tforall* {N1} {D1} {M1} {N2} {D2} {M2} {N0} {B1}\n\tforall {P:plus (s N0) N1 N2}\n               {D?1:disjoint? M1 (map/+ N0 D2 M2) B1}\n\texists {B} {D:disjoint? (map/+ N1 D1 M1) (map/+ N2 D2 M2) B}\n\ttrue.\n\n%theorem disjoint?-total*/> :\n\tforall* {N1} {D1} {M1} {N2} {D2} {M2} {N3} {B1}\n\tforall {P:plus (s N3) N2 N1}\n               {D?1:disjoint? (map/+ N3 D1 M1) M2 B1}\n\texists {B} {D:disjoint? (map/+ N1 D1 M1) (map/+ N2 D2 M2) B}\n\ttrue.\n\n- : disjoint?-total* _ _ _ D?\n    <- size-total SZ1\n    <- size-total SZ2\n    <- nat`compare-total CMP\n    <- disjoint?-total*/+ _ _ SZ1 SZ2 CMP _ D?.\n\n- : disjoint?-total*/+ _ _ _ _ (nat`compare/=) _ \n                       (disjoint?/no (lookup/= nat`eq/) (lookup/= nat`eq/)).\n\n- : disjoint?-total*/+ _ _ _ _ (nat`compare/< N2>N1) _ D?\n    <- gt-implies-plus N2>N1 _ N0+1+N1=N2\n    <- disjoint?-total*/< N0+1+N1=N2 (disjoint?/yes disjoint/L) _ D?.\n\n- : disjoint?-total*/+ _ _ (size/+ SZ1) SZ2 (nat`compare/< N2>N1) _ D?\n    <- gt-implies-plus N2>N1 _ N0+1+N1=N2\n    <- nat`compare-total CMP\n    <- disjoint?-total*/+ _ _ SZ1 SZ2 CMP _ D?1\n    <- disjoint?-total*/< N0+1+N1=N2 D?1 _ D?.\n\n- : disjoint?-total*/< N0+1+N1=N2 (disjoint?/yes M1*M022) _\n                       (disjoint?/yes (disjoint/< M1*M022 N0+1+N1=N2)).\n\n- : disjoint?-total*/< N0+1+N1=N2 (disjoint?/no M1^N3=D1 M022^N3=D2) _\n                       (disjoint?/no (lookup/> M1^N3=D1 N3+1+N1=N4) M222^N4=D2)\n    <- plus-total N3+1+N1=N4\n    <- plus-swap-succ N3+1+N1=N4 N3+N1+1=N4\n    <- plus-commutative N3+N1+1=N4 N1+1+N3=N4\n    <- plus-swap-succ N0+1+N1=N2 N0+N1+1=N2\n    <- plus-commutative N0+N1+1=N2 N1+1+N0=N2\n    <- shift-preserves-lookup* M022^N3=D2 (shift/+ N1+1+N0=N2) N1+1+N3=N4\n                               M222^N4=D2.\n\n%worlds () (disjoint?-total*/< _ _ _ _).\n%total { } (disjoint?-total*/< _ _ _ _).\n\n- : disjoint?-total*/+ _ _ _ _ (nat`compare/> N1>N2) _ D?\n    <- gt-implies-plus N1>N2 _ N3+1+N2=N1\n    <- disjoint?-total*/> N3+1+N2=N1 (disjoint?/yes disjoint/R) _ D?.\n\n- : disjoint?-total*/+ _ _ SZ1 (size/+ SZ2) (nat`compare/> N1>N2) _ D?\n    <- gt-implies-plus N1>N2 _ N3+1+N2=N1\n    <- nat`compare-total CMP\n    <- disjoint?-total*/+ _ _ SZ1 SZ2 CMP _ D?1\n    <- disjoint?-total*/> N3+1+N2=N1 D?1 _ D?.\n\n- : disjoint?-total*/> P (disjoint?/yes D) _ (disjoint?/yes (disjoint/> D P)).\n\n- : disjoint?-total*/> N3+1+N2=N1 (disjoint?/no M311^N4=D1 M2^N4=D2) _\n                       (disjoint?/no M111^N5=D1 (lookup/> M2^N4=D2 N4+1+N2=N5))\n    <- plus-total N4+1+N2=N5\n    <- plus-swap-succ N4+1+N2=N5 N4+N2+1=N5\n    <- plus-commutative N4+N2+1=N5 N2+1+N4=N5\n    <- plus-swap-succ N3+1+N2=N1 N3+N2+1=N1\n    <- plus-commutative N3+N2+1=N1 N2+1+N3=N1\n    <- shift-preserves-lookup* M311^N4=D1 (shift/+ N2+1+N3=N1) N2+1+N4=N5\n                               M111^N5=D1.\n\n%worlds () (disjoint?-total*/> _ _ _ _).\n%total { } (disjoint?-total*/> _ _ _ _).\n\n%worlds () (disjoint?-total*/+ _ _ _ _ _ _ _).\n%total [S1 S2] (disjoint?-total*/+ S1 S2 _ _ _ _ _).\n\n%worlds () (disjoint?-total* _ _ _ _).\n%total { } (disjoint?-total* _ _ _ _).\n\n%abbrev disjoint?-total = disjoint?-total* _ _ _.\n\n\n\n%%% Theorems about update\n\n%theorem false-implies-update :\n\tforall* {M} {N} {D} {M'} \n\tforall {F:void} \n\texists {U:update M N D M'} \n\ttrue.\n%worlds () (false-implies-update _  M^N=D->M').\n%total {} (false-implies-update _ _).\n\n%theorem update-respects-eq :\n\tforall* {M1} {N} {D} {M2} {M1P} {NP} {DP} {M2P}\n\tforall {U:update M1 N D M2} {EM1:eq M1 M1P} \n               {EN:nat`eq N NP} {ED:nat`eq D DP} {EM2:eq M2 M2P}\n\texists {UP:update M1P NP DP M2P} \n\ttrue.\n- : update-respects-eq U eq/ nat`eq/ nat`eq/ eq/ U.\n%worlds () (update-respects-eq M1^N=D->M2 M1=M1' N=N' D=D' M2=M2' \n                         M1'^N'=D'->M2').\n%total {} (update-respects-eq _ _ _ _ _ _).\n%reduces U = U' (update-respects-eq U _ _ _ _ U').\n\n\n\n%%% technical lemmas to help prove reduction arguments\n\n\nupdate-eq : {M1} {N1} {D1} {M1'} {M2} {N2} {D2} {M2'}\n            update M1 N1 D1 M1' -> update M2 N2 D2 M2' -> type.\nupdate-eq/ : update-eq M1 N1 D1 M1' M1 N1 D1 M1' U U.\n\n\n%theorem false-implies-update-eq :\n\tforall* {M1} {N1} {D1} {M1'} {M2} {N2} {D2} {M2'} {U} {U'}\n        forall {F:void}\n\texists {UE:update-eq M1 N1 D1 M1'  M2 N2 D2 M2' U U'}\n        true.\n\n%worlds () (false-implies-update-eq _ _).\n%total { } (false-implies-update-eq _ _).\n\n\n%theorem meta-update-eq :\n\tforall* {M1} {N1} {D1} {M1'} {M2} {N2} {D2} {M2'}\n\tforall {U} {U'} {UE:update-eq M1 N1 D1 M1'  M2 N2 D2 M2' U U'}\n        true.\n\n- : meta-update-eq U U (update-eq/).\n\n%worlds () (meta-update-eq _ _ _).\n%total { } (meta-update-eq _ _ _).\n%reduces U = U' (meta-update-eq U U' _).\n\n\n\n%%% inversion lemmas\n\n%theorem update/=-inversion :\n\tforall* {N1} {D1} {M1} {N2} {D2} {M2}\n\tforall {U:update (map/+ N1 D1 M1) N2 D2 M2} {E:nat`eq N1 N2}\n        exists {EM:eq (map/+ N2 D2 M1) M2}\n\ttrue.\n\n- : update/=-inversion (update/= nat`eq/) nat`eq/ eq/.\n\n- : update/=-inversion (update/< N3+1+N=N) nat`eq/ E\n    <- nat`plus-implies-gt N3+1+N=N nat`eq/ N>N\n    <- nat`gt-anti-reflexive N>N F\n    <- false-implies-eq F E.\n\n- : update/=-inversion (update/> U1022 N3+1+N=N) nat`eq/ E\n    <- nat`plus-implies-gt N3+1+N=N nat`eq/ N>N\n    <- nat`gt-anti-reflexive N>N F\n    <- false-implies-eq F E.\n\n%worlds () (update/=-inversion _ _ _).\n%total { } (update/=-inversion _ _ _).\n\n\n%theorem update/<-inversion:\n\tforall* {N1} {D1} {M1} {N2} {D2} {M2} {N3}\n\tforall {U:update (map/+ N1 D1 M1) N2 D2 M2} {P:plus (s N3) N2 N1}\n\texists {E:eq (map/+ N2 D2 (map/+ N3 D1 M1)) M2}\n\ttrue.\n\n- : update/<-inversion (update/= nat`eq/) N3+1+N=N E\n    <- nat`plus-implies-gt N3+1+N=N nat`eq/ N>N\n    <- nat`gt-anti-reflexive N>N F\n    <- false-implies-eq F E.\n\n- : update/<-inversion (update/< N3+1+N2=N1) N3P+1+N2=N1 E\n    <- nat`plus-right-cancels N3P+1+N2=N1 N3+1+N2=N1 nat`eq/ nat`eq/ N3P+1=N3+1\n    <- nat`succ-cancels N3P+1=N3+1 N3P=N3\n    <- map/+-preserves-eq N3P=N3 nat`eq/ eq/ M311P=M311\n    <- map/+-preserves-eq nat`eq/ nat`eq/ M311P=M311 E.\n\n- : update/<-inversion (update/> _ N0+1+N1=N2) N3+1+N2=N1 E\n    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2\n    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1\n    <- nat`gt-anti-symmetric N1>N2 N2>N1 F\n    <- false-implies-eq F E.\n\n%worlds () (update/<-inversion _ _ _).\n%total { } (update/<-inversion _ _ _).\n\n\n%theorem update/>-inversion :\n\tforall* {N1} {D1} {M1} {N2} {D2} {M} {N0}\n\tforall {U:update (map/+ N1 D1 M1) N2 D2 M} {P:plus (s N0) N1 N2}\n\texists {M2} {UP:update M1 N0 D2 M2} {E:eq (map/+ N1 D1 M2) M}\n\ttrue.\n\n% a little more complex than might be expected\n% because we want to prove reduction\n- : update/>-inversion (update/= nat`eq/: update (map/+ N D1 M1) N D2 \n                                                 (map/+ N D2 M1))\n                       N0+1+N=N M1 U' E\n    <- plus-implies-gt N0+1+N=N nat`eq/ N>N\n    <- gt-anti-reflexive N>N F\n    <- false-implies-eq F E\n    <- false-implies-update F U'\n    <- false-implies-update-eq F\n       (UE:update-eq (map/+ N D1 M1) N D2 (map/+ N D2 M1)\n                     (map/+ N D1 M1) N D2 (map/+ N D1 M1) _ _)\n    <- meta-update-eq (update/= nat`eq/) (update/> U' N0+1+N=N) UE.\n\n- : update/>-inversion (update/< N3+1+N2=N1: update (map/+ N1 D1 M1) _ _ _) \n                       N0+1+N1=N2 M1 U' E\n    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2\n    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1\n    <- nat`gt-anti-symmetric N1>N2 N2>N1 F\n    <- false-implies-update F U'\n    <- false-implies-eq F E\n    <- false-implies-update-eq F\n       (UE:update-eq (map/+ N1 D1 M1) N2 D2 (map/+ N2 D2 (map/+ N3 D1 M1))\n                     (map/+ N1 D1 M1) N2 D2 (map/+ N1 D1 M1) _ _)\n    <- meta-update-eq (update/< N3+1+N2=N1) (update/> U' N0+1+N1=N2) UE.\n\n- : update/>-inversion (update/> U N0+1+N1=N2) N0P+1+N1=N2 _ UP eq/ \n    <- nat`plus-right-cancels N0+1+N1=N2 N0P+1+N1=N2 nat`eq/ nat`eq/ N0+1=N0P+1\n    <- nat`succ-cancels N0+1=N0P+1 N0=N0P\n    <- update-respects-eq U eq/ N0=N0P nat`eq/ eq/ UP.\n\n%worlds () (update/>-inversion _ _ _ _ _).\n%total { } (update/>-inversion _ _ _ _ _).\n%reduces U' < U (update/>-inversion U _ _ U' _).\n\n\n%theorem update-deterministic :\n\tforall* {M1} {N1} {D1} {M1'} {M2} {N2} {D2} {M2'}\n\tforall {U1:update M1 N1 D1 M1'} {U2:update M2 N2 D2 M2'}\n\t       {EM:eq M1 M2} {EN:nat`eq N1 N2} {ED:nat`eq D1 D2}\n\texists {EM':eq M1' M2'}\n\ttrue.\n\n- : update-deterministic update/0 update/0 eq/ nat`eq/ nat`eq/ eq/.\n\n- : update-deterministic (update/= nat`eq/) (update/= nat`eq/) eq/ nat`eq/ nat`eq/ eq/.\n\n- : update-deterministic (update/< N3+1+N2=N1) (update/< N3'+1+N2=N1)\n                         eq/ nat`eq/ nat`eq/ M1'=M2'\n    <- plus-right-cancels N3+1+N2=N1 N3'+1+N2=N1 nat`eq/ nat`eq/ SN3=SN3'\n    <- succ-cancels SN3=SN3' N3E\n    <- map/+-preserves-eq N3E nat`eq/ eq/ MM1=MM2\n    <- map/+-preserves-eq nat`eq/ nat`eq/ MM1=MM2 M1'=M2'.\n\n- : update-deterministic (update/> F1^N0=D2->F2 N0+1+N1=N2)\n                         (update/> F1^N0'=D2->F2' N0'+1+N1=N2)\n                         eq/ nat`eq/ nat`eq/ M1'=M2'\n    <- plus-right-cancels N0+1+N1=N2 N0'+1+N1=N2 nat`eq/ nat`eq/ N0+1=N0'+1\n    <- succ-cancels N0+1=N0'+1 N0=N0'\n    <- update-deterministic F1^N0=D2->F2 F1^N0'=D2->F2' eq/ N0=N0' \n                            nat`eq/ F2=F2'\n    <- map/+-preserves-eq nat`eq/ nat`eq/ F2=F2' M1'=M2'.\n\n%% contradiction cases:\n- : update-deterministic (update/= nat`eq/) (update/< N3+1+N=N) eq/ nat`eq/ nat`eq/ E\n    <- plus-implies-gt N3+1+N=N nat`eq/ N>N\n    <- gt-anti-reflexive N>N F\n    <- false-implies-eq F E.\n\n- : update-deterministic (update/= nat`eq/) (update/> _ N0+1+N=N) eq/ nat`eq/ nat`eq/ E\n    <- plus-implies-gt N0+1+N=N nat`eq/ N>N\n    <- gt-anti-reflexive N>N F\n    <- false-implies-eq F E.\n\n- : update-deterministic (update/< N3+1+N=N) (update/= nat`eq/) eq/ nat`eq/ nat`eq/ E\n    <- plus-implies-gt N3+1+N=N nat`eq/ N>N\n    <- gt-anti-reflexive N>N F\n    <- false-implies-eq F E.\n\n- : update-deterministic (update/< N3+1+N2=N1) (update/> _ N0+1+N1=N2)\n                         eq/ nat`eq/ nat`eq/ E\n    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2\n    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1\n    <- nat`gt-anti-symmetric N1>N2 N2>N1 F\n    <- false-implies-eq F E.\n\n- : update-deterministic (update/> _ N0+1+N=N) (update/= nat`eq/) eq/ nat`eq/ nat`eq/ E\n    <- plus-implies-gt N0+1+N=N nat`eq/ N>N\n    <- gt-anti-reflexive N>N F\n    <- false-implies-eq F E.\n\n- : update-deterministic (update/> _ N0+1+N1=N2) (update/< N3+1+N2=N1)\n                         eq/ nat`eq/ nat`eq/ E\n    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2\n    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1\n    <- nat`gt-anti-symmetric N1>N2 N2>N1 F\n    <- false-implies-eq F E.\n\n%worlds () (update-deterministic M1^N1=D1->M1' M2^N2=D2->M2' M1=M2 N1=N2 D1=D2\n                           M1'=M2').\n%total (U) (update-deterministic U _ _ _ _ _).\n\n%theorem update-total* :\n\tforall {M} {N} {D}\n\texists {M'} {U:update M N D M'}\n\ttrue.\n\n%% we need a mutually recursive lemma\n%theorem update-map/+-total :\n\tforall {N1} {D1} {M1} {N2} {D2} {C} {CMP:nat`compare N1 N2 C}\n\texists {M2} {U:update (map/+ N1 D1 M1) N2 D2 M2}\n\ttrue.\n\n- : update-total* map/0 N D (map/+ N D map/0) update/0.\n\n- : update-total* (map/+ N1 D1 M1) N2 D2 M2 U\n    <- nat`compare-total* N1 N2 C CMP\n    <- update-map/+-total N1 D1 M1 N2 D2 C CMP M2 U.\n\n- : update-map/+-total N1 D1 M1 N2 D2 equal CMP (map/+ N2 D2 M1) (update/= N1=N2)\n    <- equal-implies-eq CMP N1=N2.\n\n- : update-map/+-total N1 D1 M1 N2 D2 less CMP (map/+ N1 D1 M1')\n                       (update/> U1 N0+1+N1=N2)\n    <- less-implies-lt CMP N2>N1\n    <- gt-implies-plus N2>N1 N0 N0+1+N1=N2\n    <- update-total* M1 N0 D2 M1' U1.\n\n- : update-map/+-total N1 D1 M1 N2 D2 greater CMP (map/+ N2 D2 (map/+ N3 D1 M1))\n                       (update/< N3+1+N2=N1)\n    <- greater-implies-gt CMP N1>N2\n    <- gt-implies-plus N1>N2 N3 N3+1+N2=N1.\n\n%worlds () (update-total* M N D  M' M^N=D->M')\n           (update-map/+-total _ _ _ _ _ _ _ _ _).\n%total (M1 M2) (update-total* M1 _ _ _ _) (update-map/+-total _ _ M2 _ _ _ _ _ _).\n\n%abbrev update-total = update-total* _ _ _ _.\n\n\n%theorem lookup-implies-update :\n        forall* {F} {N} {D}\n        forall {L:lookup F N D}\n        exists {U:update F N D F} \n        true.\n        \n- : lookup-implies-update (lookup/= nat`eq/) (update/= nat`eq/).\n\n- : lookup-implies-update (lookup/> L P) (update/> U P)\n    <- lookup-implies-update L U.\n\n%worlds () (lookup-implies-update _ _).\n%total (L) (lookup-implies-update L _).\n\n\n%theorem update-implies-lookup :\n\tforall* {F} {N} {D} {F'}\n\tforall {U:update F N D F'} \n\texists {L:lookup F' N D}\n\ttrue.\n\n- : update-implies-lookup update/0 (lookup/= nat`eq/).\n\n- : update-implies-lookup (update/= nat`eq/) (lookup/= nat`eq/).\n\n- : update-implies-lookup (update/< _) (lookup/= nat`eq/).\n\n- : update-implies-lookup (update/> F^N0=D2->F' N0+1+N1=N2)\n                          (lookup/> F'^N0=D2    N0+1+N1=N2)\n    <- update-implies-lookup F^N0=D2->F' F'^N0=D2.\n\n%worlds () (update-implies-lookup F^N=D->F'  F'^N=D).\n%total (U) (update-implies-lookup U _).\n\n\n%theorem update-preserves-lookup :\n\tforall* {F} {N1} {D1} {F'} {N2} {D2}\n\tforall {L:lookup F N2 D2} {U:update F N1 D1 F'} {X:nat`ne N2 N1}\n        exists {L':lookup F' N2 D2}\n\ttrue.\n\n%% update/0 is impossible\n\n- : update-preserves-lookup (lookup/= nat`eq/) (update/= nat`eq/) N<>N L'\n    <- nat`ne-anti-reflexive N<>N FALSE\n    <- false-implies-lookup FALSE L'.\n\n- : update-preserves-lookup (lookup/> L1 P1) (update/= nat`eq/) _ (lookup/> L1 P1).\n\n- : update-preserves-lookup (lookup/= nat`eq/) (update/< N3+1+N2=N1) _ \n                            (lookup/> (lookup/= nat`eq/) N3+1+N2=N1).\n\n- : update-preserves-lookup (lookup/> L N0+1+N1=N2') (update/< N3+1+N2=N1) _\n\t\t\t    (lookup/> (lookup/> L N0+1+N3=N4)\n\t\t\t              N4+1+N2=N2')\n    <- plus-left-decrease N3+1+N2=N1 N1-1 N1=N1-1+1 N3+N2=N1-1\n    <- plus-right-increase N3+N2=N1-1 N3+N2+1=N1-1+1\n    <- nat`eq-symmetric N1=N1-1+1 N1-1+1=N1\n    <- plus-respects-eq N3+N2+1=N1-1+1 nat`eq/ nat`eq/ N1-1+1=N1 N3+N2+1=N1\n    <- plus-associative-converse N3+N2+1=N1 N0+1+N1=N2' N4 N0+1+N3=N4\n                                N4+N2+1=N2'\n    <- plus-swap-succ-converse N4+N2+1=N2' N4+1+N2=N2'.\n\n- : update-preserves-lookup (lookup/= nat`eq/) (update/> _ _) _ (lookup/= nat`eq/).\n\n- : update-preserves-lookup (lookup/> L N0+1+N1=N2) \n                            ((update/> U N0'+1+N1=N2') \n                             : update (map/+ N1 D1 M1) N2' D' \n                                      (map/+ N1 D1 M1'))\n                            N2<>N2' \n                            ((lookup/> L' N0+1+N1=N2) \n                             : lookup (map/+ N1 D1 M1') N2 D)\n    <- plus-right-cancels-ne N0+1+N1=N2 N0'+1+N1=N2' nat`eq/ N2<>N2' N0+1<>N0'+1\n    <- succ-preserves-ne-converse N0+1<>N0'+1 N0<>N0'\n    <- update-preserves-lookup L U N0<>N0' L'.\n\n%worlds () (update-preserves-lookup F^N2=D2 F^N1=D1->F' N1<>N2 F'^N2=D2).\n%total (L) (update-preserves-lookup L _ _ _).\n\n\n%theorem update-preserves-lookup-converse :\n\tforall* {F1} {N1} {D1} {F2} {N2} {D2}\n\tforall {L2:lookup F2 N2 D2} {U:update F1 N1 D1 F2} {X:nat`ne N2 N1}\n        exists {L1:lookup F1 N2 D2}\n\ttrue.\n\n- : update-preserves-lookup-converse (lookup/= nat`eq/) update/0 N<>N L1\n    <- nat`ne-anti-reflexive N<>N F\n    <- false-implies-lookup F L1.\n\n- : update-preserves-lookup-converse (lookup/= nat`eq/) (update/= nat`eq/) N<>N\n                                     L1\n    <- nat`ne-anti-reflexive N<>N F\n    <- false-implies-lookup F L1.\n\n- : update-preserves-lookup-converse (lookup/= nat`eq/) (update/< N3+1+N2=N1)\n                                     N<>N L1\n    <- nat`ne-anti-reflexive N<>N F\n    <- false-implies-lookup F L1.\n\n- : update-preserves-lookup-converse (lookup/= nat`eq/) (update/> _ _) _\n                                     (lookup/= nat`eq/).\n\n- : update-preserves-lookup-converse (lookup/> L1 P) (update/= nat`eq/) _\n                                     (lookup/> L1 P).\n\n- : update-preserves-lookup-converse (lookup/> (lookup/= nat`eq/) N3+1+N2=N4)\n                                     (update/< N3+1+N2=N1) _\n                                     (lookup/= N1=N4)\n    <- plus-deterministic N3+1+N2=N1 N3+1+N2=N4 nat`eq/ nat`eq/ N1=N4.\n\n- : update-preserves-lookup-converse (lookup/> (lookup/> L1 N6+1+N3=N5) \n                                               N5+1+N2=N4)\n                                     (update/< N3+1+N2=N1) _\n                                     (lookup/> L1 N6+1+N1=N4)\n    <- plus-swap-succ N3+1+N2=N1 N3+N2+1=N1\n    <- plus-swap-succ N5+1+N2=N4 N5+N2+1=N4\n    <- plus-associative* N6+1+N3=N5 N5+N2+1=N4 N3+N2+1=N1 N6+1+N1=N4.\n\n- : update-preserves-lookup-converse (lookup/> L2 N5+1+N1=N4)\n                                     (update/> U1 N0+1+N1=N2) N4<>N2\n                                     (lookup/> L1 N5+1+N1=N4)\n    <- plus-right-cancels-ne N5+1+N1=N4 N0+1+N1=N2 nat`eq/ N4<>N2 N5+1<>N0+1\n    <- succ-preserves-ne-converse N5+1<>N0+1 N5<>N0\n    <- update-preserves-lookup-converse L2 U1 N5<>N0 L1.\n\n%worlds () (update-preserves-lookup-converse _ _ _ _).\n%total (L) (update-preserves-lookup-converse L _ _ _).\n\n\n%theorem update-preserves-not-member :\n\tforall* {M1} {N1} {N2} {D} {M2}\n\tforall {F1:not-member M1 N1} {U:update M1 N2 D M2} {N:nat`ne N1 N2}\n\texists {F2:not-member M2 N1}\n\ttrue.\n\n- : update-preserves-not-member not-member/0 update/0 (nat`ne/< N>M) (not-member/< N>M).\n\n- : update-preserves-not-member not-member/0 update/0 (nat`ne/> M>N) \n                           (not-member/> not-member/0 M1+1+N=M)\n    <- gt-implies-plus M>N M1 M1+1+N=M.\n\n- : update-preserves-not-member (not-member/< N>M) (update/= nat`eq/) _ (not-member/< N>M).\n\n- : update-preserves-not-member (not-member/< N1>M) (update/< N3+1+N2=N1) (nat`ne/< N2>M)\n                           (not-member/< N2>M).\n\n- : update-preserves-not-member (not-member/< N1>M) (update/< N3+1+N2=N1) (nat`ne/> M>N2)\n                           (not-member/> (not-member/< N3>M1) M1+1+N2=M)\n    <- gt-implies-plus M>N2 M1 M1+1+N2=M\n    <- plus-swap-succ N3+1+N2=N1 N3+N2+1=N1\n    <- plus-swap-succ M1+1+N2=M  M1+N2+1=M\n    <- plus-right-cancels-gt N3+N2+1=N1 M1+N2+1=M nat`eq/ N1>M N3>M1.\n\n- : update-preserves-not-member (not-member/< N1>M) (update/> _ _) _ (not-member/< N1>M).\n\n- : update-preserves-not-member (not-member/> F P) (update/= nat`eq/) _ (not-member/> F P).\n\n- : update-preserves-not-member (not-member/> F M1+1+N1=M) (update/< N3+1+N2=N1) _\n                           (not-member/> (not-member/> F M1+1+N3=MM) MM+1+N2=M)\n    <- plus-swap-succ N3+1+N2=N1 N3+N2+1=N1\n    <- plus-associative-converse N3+N2+1=N1 M1+1+N1=M MM M1+1+N3=MM\n                                 MM+N2+1=M\n    <- plus-swap-succ-converse MM+N2+1=M MM+1+N2=M.\n\n- : update-preserves-not-member (not-member/> F M1+1+N1=M) (update/> U N0+1+N1=N2) M<>N2\n                           (not-member/> F' M1+1+N1=M)\n    <- plus-right-cancels-ne M1+1+N1=M N0+1+N1=N2 nat`eq/ M<>N2 M1+1<>N0+1\n    <- succ-preserves-ne-converse M1+1<>N0+1 M1<>N0\n    <- update-preserves-not-member F U M1<>N0 F'.\n\n%worlds () (update-preserves-not-member N1-not-member-M1 M1^N2=D->M2 N1<>N2 N1-not-member-M2).\n%total (F) (update-preserves-not-member F _ _ _).\n\n\n%theorem update-preserves-not-member-converse :\n\tforall* {M1} {N1} {N2} {D} {M2}\n\tforall {F1:not-member M2 N1} {U:update M1 N2 D M2}\n\texists {F2:not-member M1 N1}\n\ttrue.\n\n%theorem update-preserves-not-member-converse-helper :\n\tforall* {M1} {N1} {N2} {D} {M2} {B} {B2}\n\tforall {F1:not-member M2 N1} {U:update M1 N2 D M2}\n               {D:member? M1 N1 B} {E:nat`eq? N1 N2 B2}\n\texists {F2:not-member M1 N1}\n\ttrue.\n\n- : update-preserves-not-member-converse-helper _ _ (member?/out F) _ F.\n\n- : update-preserves-not-member-converse-helper F2 U (member?/in L1) (nat`eq?/no N) F1\n    <- update-preserves-lookup L1 U N L2\n    <- not-member-lookup-not-equal F2 L2 N<>N\n    <- nat`ne-anti-reflexive N<>N F\n    <- false-implies-not-member F F1.\n\n- : update-preserves-not-member-converse-helper F2 U _ nat`eq?/yes F1\n    <- update-implies-lookup U L2\n    <- not-member-lookup-not-equal F2 L2 N<>N\n    <- nat`ne-anti-reflexive N<>N F\n    <- false-implies-not-member F F1.\n\n%worlds () (update-preserves-not-member-converse-helper _ _ _ _ _).\n%total { } (update-preserves-not-member-converse-helper _ _ _ _ _).\n\n- : update-preserves-not-member-converse F2 U F1\n    <- member?-total D\n    <- nat`eq?-total E\n    <- update-preserves-not-member-converse-helper F2 U D E F1.\n\n%worlds () (update-preserves-not-member-converse _ _ _).\n%total { } (update-preserves-not-member-converse _ _ _).\n\n\n%theorem update-is-cause-of-change :\n\tforall* {M1} {N1} {N2} {M2} {D1} {D2}\n\tforall {F:not-member M1 N1}\n\t       {U:update M1 N2 D2 M2}\n\t       {L:lookup M2 N1 D1}\n\texists {EN:nat`eq N1 N2} {ED:nat`eq D1 D2}\n\ttrue.\n\n%theorem update-is-cause-of-change/L :\n\tforall* {M1} {N1} {N2} {M2} {D1} {D2} {B}\n\tforall {F:not-member M1 N1}\n\t       {U:update M1 N2 D2 M2}\n\t       {L:lookup M2 N1 D1}\n\t       {E:nat`eq? N1 N2 B}\n\texists {EN:nat`eq N1 N2} {ED:nat`eq D1 D2}\n\ttrue.\n\n- : update-is-cause-of-change F U L EN ED\n     <- nat`eq?-total E?\n     <- update-is-cause-of-change/L F U L E? EN ED.\n\n- : update-is-cause-of-change/L F U L (nat`eq?/yes) nat`eq/ ED\n    <- update-implies-lookup U L'\n    <- lookup-deterministic L L' eq/ nat`eq/ ED.\n\n- : update-is-cause-of-change/L F U L (nat`eq?/no N1<>N2) EN ED\n    <- update-preserves-not-member F U N1<>N2 F'\n    <- not-member-lookup-not-equal F' L N1<>N1\n    <- nat`ne-anti-reflexive N1<>N1 V\n    <- nat`false-implies-eq V EN\n    <- nat`false-implies-eq V ED.\n    \n%worlds () (update-is-cause-of-change/L _ _ _ _ _ _).\n%total { } (update-is-cause-of-change/L _ _ _ _ _ _).\n\n%worlds () (update-is-cause-of-change _ _ _ _ _).\n%total { } (update-is-cause-of-change _ _ _ _ _).\n\n\n%theorem update-preserves-membership :\n\tforall* {M1} {N1} {B} {N2} {D} {M2}\n\tforall {MD1:member? M1 N1 B} {U:update M1 N2 D M2} {N:nat`ne N1 N2}\n\texists {MD2:member? M2 N1 B}\n\ttrue.\n\n- : update-preserves-membership (member?/in L) U NE (member?/in L')\n    <- update-preserves-lookup L U NE L'.\n\n- : update-preserves-membership (member?/out F) U NE (member?/out F')\n    <- update-preserves-not-member F U NE F'.\n\n%worlds () (update-preserves-membership _ _ _ _).\n%total {} (update-preserves-membership _ _ _ _).\n\n\n%theorem update-preserves-membership-converse :\n\tforall* {M1} {N1} {B} {N2} {D} {M2}\n\tforall {MD2:member? M2 N1 B} {U:update M1 N2 D M2} {N:nat`ne N1 N2}\n\texists {MD1:member? M1 N1 B}\n\ttrue.\n\n- : update-preserves-membership-converse (member?/in L2) U NE (member?/in L1)\n    <- update-preserves-lookup-converse L2 U NE L1.\n\n- : update-preserves-membership-converse (member?/out F2) U NE (member?/out F1)\n    <- update-preserves-not-member-converse F2 U F1.\n\n%worlds () (update-preserves-membership-converse _ _ _ _).\n%total { } (update-preserves-membership-converse _ _ _ _).\n\n\n%theorem lookup-update-preserves-membership :\n\tforall* {M1} {N1} {B} {N2} {D1} {D2} {M2}\n\tforall {MD1:member? M1 N1 B} {L:lookup M1 N2 D1} {U:update M1 N2 D2 M2}\n\texists {MD2:member? M2 N1 B}\n\ttrue.\n\n%theorem lookup-update-preserves-membership/L :\n\tforall* {M1} {N1} {B} {N2} {D1} {D2} {M2} {B2}\n\tforall {MD1:member? M1 N1 B} {L:lookup M1 N2 D1} {U:update M1 N2 D2 M2}\n\t       {EQ?:nat`eq? N1 N2 B2}\n\texists {MD2:member? M2 N1 B}\n\ttrue.\n\n- : lookup-update-preserves-membership/L MD1 _ Ux1 (nat`eq?/no N1<>N2) MD2 \n    <- update-preserves-membership MD1 Ux1 N1<>N2 MD2.\n\n- : lookup-update-preserves-membership/L\n\t(member?/in _) _ U (nat`eq?/yes) (member?/in L2)\n    <- update-implies-lookup U L2.\n\n- : lookup-update-preserves-membership/L\n\t(member?/out F1) L1 _ nat`eq?/yes (member?/out F2)\n    <- not-member-lookup-not-equal F1 L1 NE\n    <- nat`ne-anti-reflexive NE F\n    <- false-implies-not-member F F2.\n\n%worlds () (lookup-update-preserves-membership/L _ _ _ _ _).\n%total { } (lookup-update-preserves-membership/L _ _ _ _ _).\n\n- : lookup-update-preserves-membership MD1 L1 U MD2\n    <- nat`eq?-total EQ?\n    <- lookup-update-preserves-membership/L MD1 L1 U EQ? MD2.\n\n%worlds () (lookup-update-preserves-membership _ _ _ _).\n%total { } (lookup-update-preserves-membership _ _ _ _).\n\n\n%theorem lookup-update-preserves-membership-converse :\n\tforall* {M1} {N1} {B} {N2} {D1} {D2} {M2}\n\tforall {MD1:member? M2 N1 B} {L:lookup M1 N2 D1} {U:update M1 N2 D2 M2}\n\texists {MD2:member? M1 N1 B}\n\ttrue.\n\n- : lookup-update-preserves-membership-converse MD2 ML MU MD1\n    <- member?-total MD1'\n    <- lookup-update-preserves-membership MD1' ML MU MD2'\n    <- member?-deterministic MD2' MD2 eq/ nat`eq/ B'=B\n    <- member?-respects-eq MD1' eq/ nat`eq/ B'=B MD1.\n\n%worlds () (lookup-update-preserves-membership-converse _ _ _ _).\n%total { } (lookup-update-preserves-membership-converse _ _ _ _).\n\n\n%theorem update-preserves-in-member :\n\tforall* {M1} {N1} {N2} {D} {M2}\n\tforall {MD1:member? M1 N1 true} {U:update M1 N2 D M2}\n\texists {MD2:member? M2 N1 true}\n\ttrue.\n\n%theorem update-preserves-in-member/L :\n\tforall* {M1} {N1} {N2} {D} {M2} {B}\n\tforall {MD1:member? M1 N1 true} {U:update M1 N2 D M2}\n\t       {E: nat`eq? N1 N2 B}\n\texists {MD2:member? M2 N1 true}\n\ttrue.\n\n- : update-preserves-in-member/L\n\t(member?/in ML1) U (nat`eq?/no N1<>N2) (member?/in ML2)\n    <- update-preserves-lookup ML1 U N1<>N2 ML2.\n\n- : update-preserves-in-member/L _ U (nat`eq?/yes) (member?/in ML)\n    <- update-implies-lookup U ML.\n\n%worlds () (update-preserves-in-member/L _ _ _ _).\n%total { } (update-preserves-in-member/L _ _ _ _).\n\n- : update-preserves-in-member MD1 U MD2\n    <- nat`eq?-total E\n    <- update-preserves-in-member/L MD1 U E MD2.\n\n%worlds () (update-preserves-in-member _ _ _).\n%total { } (update-preserves-in-member _ _ _).\n\n\n%theorem shift-preserves-update :\n\tforall* {M1} {N1} {D} {M1'} {N0} {M2}\n\tforall {U1:update M1 N1 D M1'}\n               {S:shift N0 M1 M2}\n        exists {N2} {M2'} \n               {P:plus (s N0) N1 N2}\n               {SS:shift N0 M1' M2'}\n               {U2:update M2 N2 D M2'}\n\ttrue.\n\n- : shift-preserves-update update/0 shift/0 _ _ P (shift/+ P) update/0\n    <- plus-total P.\n\n- : shift-preserves-update (update/= nat`eq/) (shift/+ P) _ _ P (shift/+ P)\n                           (update/= nat`eq/).\n\n- : shift-preserves-update (update/< N4+1+N1=N3) (shift/+ N0+1+N3=N5) _ _\n                           N0+1+N1=N2 (shift/+ N0+1+N1=N2) \n                           (update/< N4+1+N2=N5)\n    <- plus-commutative N4+1+N1=N3 N1+N4+1=N3\n    <- plus-associative-converse N1+N4+1=N3 N0+1+N3=N5 _ N0+1+N1=N2 N2+N4+1=N5\n    <- plus-commutative N2+N4+1=N5 N4+1+N2=N5.\n\n- : shift-preserves-update (update/> U N4+1+N3=N1) (shift/+ N0+1+N3=N5) _ _\n                           N0+1+N1=N2 (shift/+ N0+1+N3=N5)\n                           (update/> U N4+1+N5=N2)\n   <- plus-total N0+1+N1=N2\n   <- plus-commutative N4+1+N3=N1 N3+N4+1=N1\n   <- plus-associative-converse* N3+N4+1=N1 N0+1+N1=N2 N0+1+N3=N5 N5+N4+1=N2\n   <- plus-commutative N5+N4+1=N2 N4+1+N5=N2.\n\n%worlds () (shift-preserves-update _ _ _ _ _ _ _).\n%total { } (shift-preserves-update _ _ _ _ _ _ _).\n\n\n%theorem shift-preserves-update* :\n\tforall* {M1} {N1} {D} {M1'} {N0} {M2} {N2} {M2'}\n\tforall {U1:update M1 N1 D M1'}\n               {S:shift N0 M1 M2}\n               {P:plus (s N0) N1 N2}\n               {SS:shift N0 M1' M2'}\n        exists {U2:update M2 N2 D M2'}\n\ttrue.\n\n- : shift-preserves-update* U1 S P SS U2\n    <- shift-preserves-update U1 S _ _ P' SS' U2'\n    <- plus-deterministic P' P nat`eq/ nat`eq/ N2'=N2\n    <- shift-deterministic SS' SS nat`eq/ eq/ M2'=M2\n    <- update-respects-eq U2' eq/ N2'=N2 nat`eq/ M2'=M2 U2.\n\n%worlds () (shift-preserves-update* _ _ _ _ _).\n%total { } (shift-preserves-update* _ _ _ _ _).\n\n\n%theorem shift-preserves-update-converse :\n\tforall* {M1} {N1} {D} {N0} {M2} {N2} {M2'}\n        forall {U2:update M2 N2 D M2'}\n               {S:shift N0 M1 M2}\n               {P:plus (s N0) N1 N2}\n        exists {M1'} {SS:shift N0 M1' M2'}\n\t       {U1:update M1 N1 D M1'}\n\ttrue.\n\n- : shift-preserves-update-converse U2 S P _ SS U1\n    <- update-total U1\n    <- shift-preserves-update U1 S _ _ P' SS' U2'\n    <- plus-deterministic P' P nat`eq/ nat`eq/ N2'=N2\n    <- update-deterministic U2' U2 eq/ N2'=N2 nat`eq/ M2'=M2\n    <- shift-respects-eq SS' nat`eq/ eq/ M2'=M2 SS.\n\n%worlds () (shift-preserves-update-converse _ _ _ _ _ _).\n%total { } (shift-preserves-update-converse _ _ _ _ _ _).\n\n\n%theorem update-overwrites :\n\tforall* {M1} {N1} {D1} {M2} {N2} {D2} {M3}\n\tforall {U1:update M1 N1 D1 M2} {U2:update M2 N2 D2 M3}\n\t       {E:nat`eq N1 N2}\n\texists {U12:update M1 N1 D2 M3}\n\ttrue.\n\n- : update-overwrites (update/0) (update/= nat`eq/) nat`eq/ (update/0).\n\n- : update-overwrites (update/= nat`eq/) (update/= nat`eq/) nat`eq/ (update/= nat`eq/).\n\n- : update-overwrites (update/< P) (update/= nat`eq/) nat`eq/ (update/< P).\n\n- : update-overwrites (update/> U1 P) (update/> U2 P') nat`eq/ (update/> U3 P)\n    <- plus-right-cancels P P' nat`eq/ nat`eq/ N0+1=N0'+1\n    <- succ-cancels N0+1=N0'+1 N0=N0'\n    <- update-overwrites U1 U2 N0=N0' U3.\n\n%% contradiction cases\n- : update-overwrites (update/0) (update/< N3+1+N=N) nat`eq/ U\n    <- plus-implies-gt N3+1+N=N nat`eq/ N>N\n    <- gt-anti-reflexive N>N F\n    <- false-implies-update F U.\n\n- : update-overwrites (update/0) (update/> _ N0+1+N=N) nat`eq/ U\n    <- plus-implies-gt N0+1+N=N nat`eq/ N>N\n    <- gt-anti-reflexive N>N F\n    <- false-implies-update F U.\n\n- : update-overwrites (update/= nat`eq/) (update/< N3+1+N=N) nat`eq/ U\n    <- plus-implies-gt N3+1+N=N nat`eq/ N>N\n    <- gt-anti-reflexive N>N F\n    <- false-implies-update F U.\n\n- : update-overwrites (update/= nat`eq/) (update/> _ N0+1+N=N) nat`eq/ U\n    <- plus-implies-gt N0+1+N=N nat`eq/ N>N\n    <- gt-anti-reflexive N>N F\n    <- false-implies-update F U.\n\n- : update-overwrites (update/< _) (update/< N3+1+N=N) nat`eq/ U\n    <- plus-implies-gt N3+1+N=N nat`eq/ N>N\n    <- gt-anti-reflexive N>N F\n    <- false-implies-update F U.\n\n- : update-overwrites (update/< _) (update/> _ N0+1+N=N) nat`eq/ U\n    <- plus-implies-gt N0+1+N=N nat`eq/ N>N\n    <- gt-anti-reflexive N>N F\n    <- false-implies-update F U.\n\n- : update-overwrites (update/> _ N0+1+N=N) (update/= nat`eq/) nat`eq/ U\n    <- plus-implies-gt N0+1+N=N nat`eq/ N>N\n    <- gt-anti-reflexive N>N F\n    <- false-implies-update F U.\n\n- : update-overwrites (update/> _ N0+1+N1=N2) (update/< N3+1+N2=N1) nat`eq/ U\n    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2\n    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1\n    <- nat`gt-anti-symmetric N1>N2 N2>N1 F\n    <- false-implies-update F U.\n\n%worlds () (update-overwrites M1^N1=D1->M2 M2^N2=D2->M3 N1=N2 \n                        M1^N1=D2->M3).\n%total (U) (update-overwrites U _ _ _).\n\n\n%theorem update-overwrites-converse :\n\tforall* {M1} {N1} {D1} {M2} {D2} {M3}\n\tforall {U12:update M1 N1 D1 M3} {U1:update M1 N1 D2 M2}\n\texists {U2:update M2 N1 D1 M3}\n\ttrue.\n\n- : update-overwrites-converse U12 U1 U2\n    <- update-total U2P \n    <- update-overwrites U1 U2P nat`eq/ U12P\n    <- update-deterministic U12P U12 eq/ nat`eq/ nat`eq/ M2P=M2\n    <- update-respects-eq U2P eq/ nat`eq/ nat`eq/ M2P=M2 U2.\n\n%worlds () (update-overwrites-converse _ _ _).\n%total { } (update-overwrites-converse _ _ _).\n\n\n%theorem update-may-have-no-effect :\n\tforall* {M1} {N} {D} {M2}\n\tforall {L:lookup M1 N D} {U:update M1 N D M2}\n\texists {E:eq M1 M2}\n\ttrue.\n\n- : update-may-have-no-effect (lookup/= nat`eq/) U E\n    <- update/=-inversion U nat`eq/ E.\n\n- : update-may-have-no-effect (lookup/> L1 N0+1+N1=N2) U E\n    <- update/>-inversion U N0+1+N1=N2 _ U1 M112=M2\n    <- update-may-have-no-effect L1 U1 M1=M2\n    <- map/+-preserves-eq nat`eq/ nat`eq/ M1=M2 M111=M112\n    <- eq-transitive M111=M112 M112=M2 E.\n\n%worlds () (update-may-have-no-effect _ _ _).\n%total (L) (update-may-have-no-effect L _ _).\n\n\n%theorem update-idempotent :\n\tforall* {M1} {N1} {D1} {M2} {N2} {D2} {M3}\n\tforall {U1:update M1 N1 D1 M2} {U2:update M2 N2 D2 M3}\n\t       {EN:nat`eq N1 N2} {ED:nat`eq D1 D2}\n\texists {EM:eq M2 M3}\n\ttrue.\n\n- : update-idempotent U1 U2 nat`eq/ nat`eq/ M2=M3\n    <- update-overwrites U1 U2 nat`eq/ M1^N=D->M3\n    <- update-deterministic U1 M1^N=D->M3 eq/ nat`eq/ nat`eq/ M2=M3.\n\n%worlds () (update-idempotent M1^N1=D1->M2 M2^N2=D2->M3 N1=N2 D1=D2\n                        M2=M3).\n%total {} (update-idempotent _ _ _ _ _).\n\n\n%theorem update-commutes :\n\tforall* {M} {N1} {D1} {M1} {N2} {D2} {M12}\n\tforall {U1:update M N1 D1 M1} {U12:update M1 N2 D2 M12}\n               {NE:nat`ne N1 N2}\n        exists {M2} {U2:update M N2 D2 M2} {U21:update M2 N1 D1 M12}\n\ttrue.\n\n- : update-commutes update/0 (update/= nat`eq/) N<>N map/0 U2 U21\n    <- nat`ne-anti-reflexive N<>N F\n    <- false-implies-update F U2\n    <- false-implies-update F U21.\n\n- : update-commutes update/0 (update/< N'+1+N2=N1) _ _ update/0\n                    (update/> update/0 N'+1+N2=N1).\n\n- : update-commutes update/0 (update/> update/0 N'+1+N1=N2) _ _ update/0\n                    (update/< N'+1+N1=N2).\n\n- : update-commutes (update/= nat`eq/) (update/= nat`eq/) N<>N map/0 U2 U21\n    <- nat`ne-anti-reflexive N<>N F\n    <- false-implies-update F U2\n    <- false-implies-update F U21.\n\n- : update-commutes (update/= nat`eq/) (update/< N'+1+N2=N1) _ _ \n                    (update/< N'+1+N2=N1) (update/> (update/= nat`eq/) N'+1+N2=N1).\n\n- : update-commutes (update/= nat`eq/) (update/> U N'+1+N1=N2) _ _ \n                    (update/> U N'+1+N1=N2) (update/= nat`eq/).\n\n- : update-commutes (update/< _) (update/= nat`eq/) N<>N map/0 U2 U21\n    <- nat`ne-anti-reflexive N<>N F\n    <- false-implies-update F U2\n    <- false-implies-update F U21.\n\n- : update-commutes (update/< N1'+1+N1=N) (update/< N2'+1+N2=N1) _ _ \n                    (update/< N2''+1+N2=N) \n                    (update/> (update/< N1'+1+N2'=N2'') N2'+1+N2=N1)\n    <- plus-swap-succ N2'+1+N2=N1 N2'+N2+1=N1\n    <- plus-associative-converse N2'+N2+1=N1 N1'+1+N1=N \n                                 N2'' N1'+1+N2'=N2'' N2''+N2+1=N\n    <- plus-swap-succ-converse N2''+N2+1=N N2''+1+N2=N.\n\n- : update-commutes ((update/< N11+1+N1=N):update (map/+ N D M) _ _ _)\n                  (update/> (update/= nat`eq/) N11+1+N1=N2) _\n                    (map/+ N2 D2 M)\n                    (update/= N=N2)\n                    ((update/< N11+1+N1=N2):update _ N1 D1 _)\n    <- plus-deterministic N11+1+N1=N N11+1+N1=N2 nat`eq/ nat`eq/ N=N2.\n\n- : update-commutes (update/< N11+1+N1=N) \n                    (update/> (update/< N2''+1+N2'=N11) N2'+1+N1=N2) _ _\n                    (update/< N2''+1+N2=N) (update/< N2'+1+N1=N2)\n    <- plus-swap-succ N11+1+N1=N N11+N1+1=N\n    <- plus-swap-succ N2'+1+N1=N2 N2'+N1+1=N2\n    <- plus-associative* N2''+1+N2'=N11 N11+N1+1=N N2'+N1+1=N2\n                         N2''+1+N2=N.\n\n- : update-commutes (update/< N11+1+N1=N) \n                    (update/> (update/> U N2''+1+N11=N2') N2'+1+N1=N2) _ _\n                    (update/> U N2''+1+N=N2) (update/< N11+1+N1=N)\n    <- plus-swap-succ N11+1+N1=N N11+N1+1=N\n    <- plus-swap-succ N2'+1+N1=N2 N2'+N1+1=N2\n    <- plus-associative* N2''+1+N11=N2' N2'+N1+1=N2 N11+N1+1=N N2''+1+N=N2.\n\n- : update-commutes (update/> U N11+1+N=N1) (update/= nat`eq/) _ _\n                    (update/= nat`eq/) (update/> U N11+1+N=N1).\n\n- : update-commutes (update/> U N11+1+N=N1) (update/< N2'+1+N2=N) _ _\n                    (update/< N2'+1+N2=N)\n\t\t    (update/> (update/> U N11+1+N2'=N11') N11'+1+N2=N1)\n    <- plus-swap-succ N2'+1+N2=N N2'+N2+1=N\n    <- plus-associative-converse N2'+N2+1=N N11+1+N=N1 \n                                 N11' N11+1+N2'=N11' N11'+N2+1=N1\n    <- plus-swap-succ-converse N11'+N2+1=N1 N11'+1+N2=N1.\n\n- : update-commutes (update/> U1 N11+1+N=N1) (update/> U12 N2'+1+N=N2) N1<>N2\n                    (map/+ N D M2) \n     \t\t    (update/> U2 N2'+1+N=N2) (update/> U21 N11+1+N=N1)\n    <- plus-right-cancels-ne N11+1+N=N1 N2'+1+N=N2 nat`eq/ N1<>N2 N11+1<>N2'+1\n    <- succ-preserves-ne-converse N11+1<>N2'+1 N11<>N2'\n    <- update-commutes U1 U12 N11<>N2' M2 U2 U21.\n\n%worlds () (update-commutes M^N1=D1->M1 M1^D2=N2->M12 N1<>N2\n                      M2 M^N2=D2->M2 M2^N1=D1->M12).\n%total (U1) (update-commutes U1 _ _ _ _ _).\n\n\n%theorem update-commutes* :\n\tforall* {M} {N1} {D1} {M1} {N2} {D2} {M12} {M2}\n\tforall {U1:update M N1 D1 M1} {U12:update M1 N2 D2 M12}\n               {NE:nat`ne N1 N2} {U2:update M N2 D2 M2} \n        exists {U21:update M2 N1 D1 M12}\n\ttrue.\n\n- : update-commutes* M^N1=D1->M1 M1^D2=N2->M12 N1<>N2 M^N2=D2->M2 M2^N1=D1->M12\n    <- update-commutes M^N1=D1->M1 M1^D2=N2->M12 N1<>N2 \n                       M2' M^N2=D2->M2' M2'^N1=D1->M12\n    <- update-deterministic M^N2=D2->M2' M^N2=D2->M2 eq/ nat`eq/ \n                            nat`eq/ M2'=M2\n    <- update-respects-eq M2'^N1=D1->M12 M2'=M2 nat`eq/ \n                            nat`eq/ eq/ M2^N1=D1->M12.\n\n%worlds () (update-commutes* M^N1=D1->M1 M1^D2=N2->M12 N1<>N2 M^N2=D2->M2\n                       M2^N1=D1->M12).\n%total {} (update-commutes* _ _ _ _ _). \n\n\n%% The following theorem is needed if you want to iteratively\n%% do something with a set.  It says that you can take out an element \n%% and (using the update-preserves-X-converse theorems) get a smaller set\n%% that differs only for this element:\n\n%theorem can-remove :\n        forall* {M} {S} {N} {D}\n\tforall {SZ:size M S} {L:lookup M N D}\n\texists {M-} {S-} {SZ-:size M- S-} {E:nat`eq (s S-) S}\n               {U:update M- N D M} {F:not-member M- N}\n\ttrue.\n\n- : can-remove (size/+ _) (lookup/= _) _ _ size/0 nat`eq/ update/0 not-member/0.\n\n- : can-remove (size/+ (size/+ SZ)) (lookup/= nat`eq/) _ _ (size/+ SZ) nat`eq/\n               (update/< N3+1+N2=N1) (not-member/< N1>N2)\n    <- plus-total N3+1+N2=N1\n    <- plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2.\n\n- : can-remove (size/+ SZ) (lookup/> LK N0+1+N1=N2) _ _\n               (size/+ SZ2) E\n               (update/> U2 N0+1+N1=N2) (not-member/> F2 N0+1+N1=N2)\n    <- can-remove SZ LK M- S- SZ2 E2 U2 F2\n    <- succ-deterministic E2 E.\n\n%worlds () (can-remove _ _ _ _ _ _ _ _).\n%total (L) (can-remove _ L _ _ _ _ _ _).\n\n\n\n\n\n%%%% Map comparison\n\n\n\n%%% Definition of leq\n\n\nleq : map -> map -> type.\n\n\nleq/0 : leq map/0 M.\n\nleq/= : leq (map/+ N1 D1 M1) (map/+ N2 D2 M2)\n    <- nat`eq N1 N2\n    <- nat`leq D1 D2\n    <- leq M1 M2.\n\nleq/> : leq (map/+ N1 D1 M1) (map/+ N2 D2 M2)\n    <- nat`plus (s N3) N2 N1\n    <- leq (map/+ N3 D1 M1) M2.\n\n\n\n\n%%% Theorems about leq\n\n\n%theorem false-implies-leq :\n\tforall* {M1} {M2}\n\tforall {F:void}\n\texists {L:leq M1 M2}\n\ttrue.\n\n%worlds () (false-implies-leq _ _).\n%total {} (false-implies-leq _ _).\n\n\n%theorem leq-respects-eq :\n\tforall* {M1} {M2} {M1'} {M2'}\n\tforall {L:leq M1 M2} {E1:eq M1 M1'} {E2:eq M2 M2'}\n\texists {LP:leq M1' M2'}\n\ttrue.\n\n- : leq-respects-eq L eq/ eq/ L.\n\n%worlds () (leq-respects-eq _ _ _ _).\n%total {} (leq-respects-eq _ _ _ _).\n%reduces L1 = L2 (leq-respects-eq L1 _ _ L2).\n\n\n%theorem leq/0-inversion :\n\tforall* {M1} {M2}\n\tforall {L:leq M1 M2} {E2:eq M2 map/0}\n\texists {E1:eq M1 map/0}\n\ttrue.\n\n- : leq/0-inversion leq/0 eq/ eq/.\n\n%worlds () (leq/0-inversion _ _ _).\n%total { } (leq/0-inversion _ _ _).\n\n\n%theorem leq/=-inversion :\n\tforall* {N1} {D1} {M1} {N2} {D2} {M2}\n\tforall {L:leq (map/+ N1 D1 M1) (map/+ N2 D2 M2)} {EN:nat`eq N1 N2}\n\texists {ED:nat`leq D1 D2} {EM:leq M1 M2}\n\ttrue.\n\n- : leq/=-inversion (leq/= M1<=M2 D1<=D2 nat`eq/) nat`eq/ D1<=D2 M1<=M2.\n\n- : leq/=-inversion (leq/> M311<=M2 N3+1+N=N) nat`eq/ ED M1<=M2\n    <- plus-implies-gt N3+1+N=N nat`eq/ N>N\n    <- gt-anti-reflexive N>N F\n    <- nat`false-implies-leq F ED\n    <- false-implies-eq F M311=M1\n    <- leq-respects-eq M311<=M2 M311=M1 eq/ M1<=M2.\n\n%worlds () (leq/=-inversion _ _ _ _).\n%total { } (leq/=-inversion _ _ _ _).\n%reduces L1 < L (leq/=-inversion L _ _ L1).\n\n\n%theorem leq/>-inversion :\n\tforall* {N1} {D1} {M1} {N2} {D2} {M2} {N3}\n\tforall {L:leq (map/+ N1 D1 M1) (map/+ N2 D2 M2)} \n               {P:plus (s N3) N2 N1}\n\texists {EM:leq (map/+ N3 D1 M1) M2}\n\ttrue.\n\n- : leq/>-inversion (leq/= M1<=M2 D1<=D2 nat`eq/) N3+1+N=N M311<=M2\n    <- plus-implies-gt N3+1+N=N nat`eq/ N>N\n    <- gt-anti-reflexive N>N F\n    <- false-implies-eq F M1=M311\n    <- leq-respects-eq M1<=M2 M1=M311 eq/ M311<=M2.\n\n- : leq/>-inversion (leq/> M311'<=M2 N3P+1+N2=N1) N3+1+N2=N1 M311<=M2\n    <- plus-right-cancels N3P+1+N2=N1 N3+1+N2=N1 nat`eq/ nat`eq/ N3P+1=N3+1\n    <- succ-cancels N3P+1=N3+1 N3P=N3\n    <- map/+-preserves-eq N3P=N3 nat`eq/ eq/ M311'=M311\n    <- leq-respects-eq M311'<=M2 M311'=M311 eq/ M311<=M2.\n\n%worlds () (leq/>-inversion _ _ _).\n%total { } (leq/>-inversion _ _ _).\n%reduces LP < L (leq/>-inversion L _ LP).\n\n\n%theorem leq-contradiction :\n\tforall* {N1} {D1} {M1} {N2} {D2} {M2} {N0}\n\tforall {L:leq (map/+ N1 D1 M1) (map/+ N2 D2 M2)} \n               {P:plus (s N0) N1 N2}\n\texists {F:void}\n\ttrue.\n\n- : leq-contradiction (leq/= _ _ nat`eq/) N0+1+N=N F\n    <- plus-implies-gt N0+1+N=N nat`eq/ N>N\n    <- gt-anti-reflexive N>N F.\n\n- : leq-contradiction (leq/> _ N3+1+N2=N1) N0+1+N1=N2 F\n    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2\n    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1\n    <- nat`gt-anti-symmetric N1>N2 N2>N1 F.\n\n%worlds () (leq-contradiction _ _ _).\n%total { } (leq-contradiction _ _ _).\n\n\n%theorem leq-reflexive :\n\tforall {M}\n\texists {L:leq M M}\n\ttrue.\n\n- : leq-reflexive map/0 leq/0.\n\n- : leq-reflexive (map/+ N D M) (leq/= M<=M D<=D nat`eq/)\n    <- nat`leq-reflexive D D<=D\n    <- leq-reflexive M M<=M.\n\n%worlds () (leq-reflexive _ _).\n%total (M) (leq-reflexive M _).\n\n\n%theorem leq-anti-symmetric :\n\tforall* {M1} {M2}\n\tforall {L1: leq M1 M2} {L2:leq M2 M1}\n\texists {E: eq M1 M2}\n\ttrue.\n\n- : leq-anti-symmetric leq/0 leq/0 eq/.\n\n- : leq-anti-symmetric (leq/= M1<=M2 D1<=D2 nat`eq/) \n                       (leq/= M2<=M1 D2<=D1 nat`eq/) E\n    <- nat`leq-anti-symmetric D1<=D2 D2<=D1 D1=D2\n    <- leq-anti-symmetric M1<=M2 M2<=M1 M1=M2\n    <- map/+-preserves-eq nat`eq/ D1=D2 M1=M2 E.\n\n- : leq-anti-symmetric (leq/= _ _ nat`eq/) (leq/> _ N3+1+N=N) E\n    <- nat`plus-implies-gt N3+1+N=N nat`eq/ N>N\n    <- nat`gt-anti-reflexive N>N F\n    <- false-implies-eq F E.\n\n- : leq-anti-symmetric (leq/> _ N3+1+N=N) (leq/= _ _ nat`eq/) E\n    <- nat`plus-implies-gt N3+1+N=N nat`eq/ N>N\n    <- nat`gt-anti-reflexive N>N F\n    <- false-implies-eq F E.\n\n- : leq-anti-symmetric (leq/> _ N3+1+N2=N1) (leq/> _ N0+1+N1=N2) E\n    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2\n    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1\n    <- nat`gt-anti-symmetric N1>N2 N2>N1 F\n    <- false-implies-eq F E.\n\n%worlds () (leq-anti-symmetric _ _ _).\n%total (L) (leq-anti-symmetric L _ _).\n\n\n%theorem leq-transitive :\n\tforall* {M1} {M2} {M3}\n\tforall {L1:leq M1 M2} {L2:leq M2 M3}\n\texists {L3:leq M1 M3}\n\ttrue.\n\n- : leq-transitive leq/0 _ leq/0.\n\n- : leq-transitive (leq/= M1<=M2 D1<=D2 nat`eq/) (leq/= M2<=M3 D2<=D3 nat`eq/)\n                   (leq/= M1<=M3 D1<=D3 nat`eq/)\n    <- nat`leq-transitive D1<=D2 D2<=D3 D1<=D3\n    <- leq-transitive M1<=M2 M2<=M3 M1<=M3.\n\n- : leq-transitive (leq/= M1<=M2 D1<=D2 nat`eq/) (leq/> M522<=M3 N5+1+N3=N2)\n                   (leq/> M511<=M3 N5+1+N3=N2)\n    <- leq-transitive (leq/= M1<=M2 D1<=D2 nat`eq/) M522<=M3 M511<=M3.\n\n- : leq-transitive (leq/> M011<=M2 N0+1+N=N1) (leq/= M2<=M3 D2<=D3 nat`eq/)\n                   (leq/> M011<=M3 N0+1+N=N1)\n    <- leq-transitive M011<=M2 M2<=M3 M011<=M3.\n\n- : leq-transitive (leq/> M011<=M2 N0+1+N2=N1) (leq/> M522<=M3 N5+1+N3=N2)\n                   (leq/> M411<=M3 N4+1+N3=N1)\n    <- nat`plus-swap-succ N5+1+N3=N2 N5+N3+1=N2 \n    <- nat`plus-associative-converse N5+N3+1=N2 N0+1+N2=N1 N4 N0+1+N5=N4\n                                     N4+N3+1=N1\n    <- nat`plus-swap-succ-converse N4+N3+1=N1 N4+1+N3=N1\n    <- leq-transitive (leq/> M011<=M2 N0+1+N5=N4) M522<=M3 M411<=M3.\n\n%worlds () (leq-transitive _ _ _).\n%total (L) (leq-transitive _ L _).\n\n\n%theorem map/+-preserves-leq :\n\tforall* {N1} {N2} {D1} {D2} {M1} {M2}\n\tforall {E:nat`eq N1 N2} {LD:nat`leq D1 D2} {LM:leq M1 M2}\n        exists {L:leq (map/+ N1 D1 M1) (map/+ N2 D2 M2)}\n\ttrue.\n\n- : map/+-preserves-leq N1=N2 D1<=D2 M1<=M2 (leq/= M1<=M2 D1<=D2 N1=N2).\n\n%worlds () (map/+-preserves-leq _ _ _ _).\n%total { } (map/+-preserves-leq _ _ _ _).\n\n\n%theorem lookup-respects-leq :\n\tforall* {M} {N} {D} {MP}\n\tforall {L:lookup M N D} {ME:leq M MP}\n        exists {DP} {L:lookup MP N DP} {DE:nat`leq D DP}\n\ttrue.\n\n- : lookup-respects-leq (lookup/= nat`eq/) (leq/= _ D1<=D2 nat`eq/) \n                         _ (lookup/= nat`eq/) D1<=D2.\n\n- : lookup-respects-leq (lookup/= nat`eq/) (leq/> M311<=M2 N3+1+N2=N1)\n                         D2 (lookup/> L13 N3+1+N2=N1) D1<=D2\n    <- lookup-respects-leq (lookup/= nat`eq/) M311<=M2 D2 L13 D1<=D2.\n\n- : lookup-respects-leq (lookup/> L13 N3+1+N2=N1) (leq/= M1<=M2 _ nat`eq/)\n                        D2 (lookup/> L13' N3+1+N2=N1) D1<=D2\n    <- lookup-respects-leq L13 M1<=M2 D2 L13' D1<=D2.\n\n- : lookup-respects-leq (lookup/> L10 N0+1+N1=N) (leq/> M311<=M2 N3+1+N2=N1)\n                        D2 (lookup/> L14' N4+1+N2=N) D1<=D2\n    <- nat`plus-swap-succ N3+1+N2=N1 N3+N2+1=N1\n    <- nat`plus-associative-converse N3+N2+1=N1 N0+1+N1=N \n                                     N4 N0+1+N3=N4 N4+N2+1=N\n    <- nat`plus-swap-succ-converse N4+N2+1=N N4+1+N2=N\n    <- lookup-respects-leq (lookup/> L10 N0+1+N3=N4) M311<=M2 D2 L14' D1<=D2.\n\n%worlds () (lookup-respects-leq _ _ _ _ _).\n%total (L) (lookup-respects-leq _ L _ _ _).\n\n\n%theorem not-member-respects-geq :\n\tforall* {M} {MP} {N}\n\tforall {FP:not-member MP N} {L:leq M MP}\n\texists {F:not-member M N}\n\ttrue.\n\n- : not-member-respects-geq F leq/0 not-member/0.\n\n- : not-member-respects-geq (not-member/< R) (leq/= _ _ nat`eq/) (not-member/< R).\n\n- : not-member-respects-geq (not-member/< N2>N) (leq/> _ N3+1+N2=N1) (not-member/< N1>N)\n    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2\n    <- gt-transitive N1>N2 N2>N N1>N.\n\n- : not-member-respects-geq (not-member/> F20 N0+1+N2=N) (leq/= M1<=M2 _ nat`eq/)\n                       (not-member/> F10 N0+1+N2=N) \n    <- not-member-respects-geq F20 M1<=M2 F10.\n\n- : {F3110:not-member (map/+ N3 D1 M1) N0}\n    {N0+1+N2=N:plus (s N0) N2 N}\n    {N3+1+N2=N1:plus (s N3) N2 N1}\n    not-member-respects-geq \n       (not-member/> F20 N0+1+N2=N: not-member (map/+ N2 D2 M2) N) \n       (leq/> M311<=M2 N3+1+N2=N1) F'\n    <- not-member-respects-geq F20 M311<=M2 F3110\n    <- nat`plus-swap-succ N0+1+N2=N N0+N2+1=N\n    <- nat`plus-swap-succ N3+1+N2=N1 N3+N2+1=N1\n    <- plus-right-preserves-not-member* F3110 N3+N2+1=N1 N0+N2+1=N F'.\n\n%worlds () (not-member-respects-geq _ _ _).\n%total (F) (not-member-respects-geq F _ _).\n\n\n%theorem leq-implies-size-le:\n\tforall* {M1} {M2} {N1} {N2}\n\tforall {L:leq M1 M2} {SZ1:size M1 N1} {SZ2:size M2 N2}\n\texists {G:ge N2 N1}\n\ttrue.\n\n- : leq-implies-size-le leq/0 size/0 N2=|M2| N2>=0\n    <- plus-commutative (plus/z:plus z N2 N2) N2+0=N2    \n    <- plus-implies-ge N2+0=N2 N2>=0.\n\n- : leq-implies-size-le (leq/= M1<=M2 _ _) (size/+ N1=|M1|) (size/+ N2=|M2|)\n                        N2+1>=N1+1\n    <- leq-implies-size-le M1<=M2 N1=|M1| N2=|M2| N2>=N1\n    <- succ-preserves-ge N2>=N1 N2+1>=N1+1.\n\n- : leq-implies-size-le (leq/> M311<=M2 _) (size/+ N1=|M1|) (size/+ N2=|M2|)\n                        (ge/> N2+1>N1+1)\n    <- leq-implies-size-le M311<=M2 (size/+ N1=|M1|) N2=|M2| N2>=N1+1\n    <- succ-implies-gt nat`eq/ N2+1>N2\n    <- gt-transitive-ge N2+1>N2 N2>=N1+1 N2+1>N1+1.\n\n%worlds () (leq-implies-size-le _ _ _ _).\n%total (L) (leq-implies-size-le L _ _ _).\n\n\n%theorem leq-implies-bound-le:\n\tforall* {M1} {M2} {N1} {N2}\n\tforall {L:leq M1 M2} {BD1:bound M1 N1} {BD2:bound M2 N2}\n\texists {G:ge N2 N1}\n\ttrue.\n\n- : leq-implies-bound-le leq/0 bound/0 _ N2>=0\n    <- plus-commutative plus/z N2+0=N2    \n    <- plus-implies-ge N2+0=N2 N2>=0.\n\n- : leq-implies-bound-le (leq/= M1<=M2 _ nat`eq/) \n                         (bound/+ N+1+N1=N3 DM1<N1) \n                         (bound/+ N+1+N2=N4 DM2<N2)\n                         N4>=N3\n    <- leq-implies-bound-le M1<=M2 DM1<N1 DM2<N2 N2>=N1\n    <- plus-left-preserves-ge* N2>=N1 N+1+N2=N4 N+1+N1=N3 N4>=N3.\n\n- : leq-implies-bound-le (leq/> M311<=M2 N3+1+N2=N1) \n                         (bound/+ N1+1+N10=N11 DM1<N10) \n                         (bound/+ N2+1+N20=N22 DM2<N20)\n                         N22>=N11\n    <- plus-total N3+1+N10=N13\n    <- leq-implies-bound-le M311<=M2 (bound/+ N3+1+N10=N13 DM1<N10) DM2<N20\n                            N20>=N13 \n    <- plus-swap-succ N1+1+N10=N11 N1+N10+1=N11\n    <- plus-swap-succ N3+1+N2=N1 N3+N2+1=N1\n    <- plus-commutative N3+N2+1=N1 N2+1+N3=N1\n    <- plus-swap-succ N3+1+N10=N13 N3+N10+1=N13\n    <- plus-associative* N2+1+N3=N1 N1+N10+1=N11 N3+N10+1=N13 N2+1+N13=N11\n    <- plus-left-preserves-ge* N20>=N13 N2+1+N20=N22 N2+1+N13=N11 N22>=N11.\n\n%worlds () (leq-implies-bound-le _ _ _ _).\n%total (L) (leq-implies-bound-le L _ _ _).\n\n\n%theorem shift-left-preserves-leq*:\n\tforall* {M1} {M2} {N} {SM1} {D}\n\tforall {L:leq M1 M2}\n\t       {S1:shift N M1 SM1}\n\texists {SL:leq SM1 (map/+ N D M2)}\n\ttrue.\n\n- : shift-left-preserves-leq* _ shift/0 leq/0.\n\n- : shift-left-preserves-leq* M111<=M2 (shift/+ N+1+N1=N1') \n                              (leq/> M111<=M2 N1+1+N=N1')\n    <- plus-swap-succ N+1+N1=N1' N+N1+1=N1'\n    <- plus-commutative N+N1+1=N1' N1+1+N=N1'.\n\n%worlds () (shift-left-preserves-leq* _ _ _).\n%total { } (shift-left-preserves-leq* _ _ _).\n\n%theorem shift-preserves-leq*:\n\tforall* {M1} {M2} {N} {SM1} {SM2} \n\tforall {L:leq M1 M2}\n               {S1:shift N M1 SM1}\n\t       {S1:shift N M2 SM2}\n\texists {SL:leq SM1 SM2}\n\ttrue.\n\n- : shift-preserves-leq* _ shift/0 _ leq/0.\n\n- : shift-preserves-leq* (leq/= M1<=M2 D1<=D2 nat`eq/)\n                         (shift/+ N+1+N1=N1') \n                         (shift/+ N+1+N1=N2')\n                         (leq/= M1<=M2 D1<=D2 N1'=N2')\n    <- plus-deterministic N+1+N1=N1' N+1+N1=N2' nat`eq/ nat`eq/ N1'=N2'.\n\n- : shift-preserves-leq* (leq/> M311<=M2 N3+1+N2=N1)\n                         (shift/+ N+1+N1=N1') \n                         (shift/+ N+1+N2=N2')\n                         (leq/> M311<=M2 N3+1+N2'=N1')\n    <- plus-commutative N3+1+N2=N1 N2+N3+1=N1\n    <- plus-associative-converse* N2+N3+1=N1 N+1+N1=N1' N+1+N2=N2' N2'+N3+1=N1'\n    <- plus-commutative N2'+N3+1=N1' N3+1+N2'=N1'.\n\n%worlds () (shift-preserves-leq* _ _ _ _).\n%total { } (shift-preserves-leq* _ _ _ _).\n\n\n%theorem update-left-preserves-leq*:\n\tforall* {M1} {M2} {N} {D} {M1'} {M2'}\n\tforall {L:leq M1 M2} \n               {U1:update M1 N D M1'}\n\t       {U2:update M2 N D M2'}\n\texists {LP:leq M1' M2'}\n\ttrue.\n\n- : update-left-preserves-leq* leq/0 update/0 update/0 (leq/= leq/0 D<=D nat`eq/)\n    <- nat`leq-reflexive _ D<=D.\n\n- : update-left-preserves-leq* leq/0 update/0 (update/= nat`eq/) \n                          (leq/= leq/0 D<=D nat`eq/)\n    <- nat`leq-reflexive _ D<=D.\n\n- : update-left-preserves-leq* leq/0 update/0 (update/< _)\n                          (leq/= leq/0 D<=D nat`eq/)\n    <- nat`leq-reflexive _ D<=D.\n\n- : update-left-preserves-leq* leq/0 update/0 (update/> U2505 N5+1+N2=N)\n                          (leq/> M500<=M5 N5+1+N2=N)\n    <- update-left-preserves-leq* leq/0 update/0 U2505 M500<=M5.\n\n- : update-left-preserves-leq* (leq/= M1<=M2 D1<=D2 nat`eq/)\n                          (update/= nat`eq/) \n                          (U2:update (map/+ N D2 M2) N D M)\n                          M001<=M\n    <- update/=-inversion U2 nat`eq/ M002=M\n    <- nat`leq-reflexive _ D<=D\n    <- leq-respects-eq (leq/= M1<=M2 D<=D nat`eq/) eq/ M002=M M001<=M.\n\n- : update-left-preserves-leq* (leq/= M1<=M2 D1<=D2 nat`eq/)\n                          (update/< N3+1+N=N1)\n                          (U2:update (map/+ N1 D2 M2) N D M)\n                          M00M311<=M\n    <- update/<-inversion U2 N3+1+N=N1 M00M322=M\n    <- nat`leq-reflexive _ D<=D\n    <- leq-respects-eq (leq/= (leq/= M1<=M2 D1<=D2 nat`eq/) D<=D nat`eq/) eq/ \n                       M00M322=M M00M311<=M.\n\n- : update-left-preserves-leq* (leq/= M1<=M2 D1<=D2 nat`eq/)\n                          (update/> U1303 N3+1+N1=N)\n                          (U2:update (map/+ N1 D2 M2) N D M)\n                          M113<=M\n    <- update/>-inversion U2 N3+1+N1=N M4 U2304 M124=M\n    <- update-left-preserves-leq* M1<=M2 U1303 U2304 M3<=M4\n    <- leq-respects-eq (leq/= M3<=M4 D1<=D2 nat`eq/) eq/ M124=M M113<=M.\n\n- : update-left-preserves-leq* (leq/> M311<=M2 N3+1+N2=N1)\n                          (update/= nat`eq/)\n\t\t\t  (U2:update (map/+ N2 D2 M2) N1 D M)\n                          M101<=M\n    <- update/>-inversion U2 N3+1+N2=N1 M4 U2304 M224=M\n    <- update-left-preserves-leq* M311<=M2 (update/= nat`eq/) U2304 M301<=M4\n    <- leq-respects-eq (leq/> M301<=M4 N3+1+N2=N1) eq/ M224=M M101<=M.\n\n - : update-left-preserves-leq* (leq/> M311<=M2 N3+1+N=N1)\n                           (update/< N4+1+N=N1)   \n                           (update/= nat`eq/) %% hence N=N2\n                           (leq/= M411<=M2 D<=D nat`eq/)\n     <- nat`plus-right-cancels N3+1+N=N1 N4+1+N=N1 nat`eq/ nat`eq/ N3+1=N4+1\n     <- nat`succ-cancels N3+1=N4+1 N3=N4\n     <- map/+-preserves-eq N3=N4 nat`eq/ eq/ M311=M411\n     <- leq-respects-eq M311<=M2 M311=M411 eq/ M411<=M2\n     <- nat`leq-reflexive _ D<=D.\n\n - : update-left-preserves-leq* (leq/> M311<=M2 N3+1+N2=N1)\n                           (update/< N4+1+N=N1)\n                           (update/< N5+1+N=N2)\n                           (leq/= (leq/> M311<=M2 N3+1+N5=N4) D<=D nat`eq/)\n     <- nat`plus-swap-succ N5+1+N=N2 N5+N+1=N2\n     <- nat`plus-associative-converse N5+N+1=N2 N3+1+N2=N1 \n                                      N4' N3+1+N5=N4' N4'+N+1=N1\n     <- nat`plus-swap-succ N4+1+N=N1 N4+N+1=N1\n     <- nat`plus-right-cancels N4'+N+1=N1 N4+N+1=N1 nat`eq/ nat`eq/ N4'=N4\n     <- nat`plus-respects-eq N3+1+N5=N4' nat`eq/ nat`eq/ N4'=N4 N3+1+N5=N4\n     <- nat`leq-reflexive _ D<=D.\n\n - : update-left-preserves-leq* (leq/> M311<=M2 N3+1+N2=N1)\n                           (update/< N4+1+N=N1)   \n                           (update/> U2505 N5+1+N2=N)\n                           (leq/> M50M411<=M5 N5+1+N2=N)\n     <- nat`plus-swap-succ N5+1+N2=N N5+N2+1=N\n     <- nat`plus-associative-converse N5+N2+1=N N4+1+N=N1\n                                      N3P N4+1+N5=N3P N3P+N2+1=N1\n     <- nat`plus-swap-succ N3+1+N2=N1 N3+N2+1=N1\n     <- nat`plus-right-cancels N3P+N2+1=N1 N3+N2+1=N1 nat`eq/ nat`eq/ N3P=N3\n     <- nat`plus-respects-eq N4+1+N5=N3P nat`eq/ nat`eq/ N3P=N3 N4+1+N5=N3\n     <- update-left-preserves-leq* M311<=M2 (update/< N4+1+N5=N3) U2505 \n                              M50M411<=M5.\n\n- : update-left-preserves-leq* (leq/> M311<=M2 N3+1+N2=N1)\n                          (update/> U1404 N4+1+N1=N)\n                          (U2:update (map/+ N2 D2 M2) N D M)\n                          M114<=M\n    <- nat`plus-swap-succ N3+1+N2=N1 N3+N2+1=N1\n    <- nat`plus-associative-converse N3+N2+1=N1 N4+1+N1=N \n                                     N5 N4+1+N3=N5 N5+N2+1=N\n    <- nat`plus-swap-succ-converse N5+N2+1=N N5+1+N2=N\n    <- update/>-inversion U2 N5+1+N2=N M5 U2505 M225=M\n    <- update-left-preserves-leq* M311<=M2 (update/> U1404 N4+1+N3=N5) U2505\n                             M314<=M5\n    <- leq-respects-eq (leq/> M314<=M5 N3+1+N2=N1) eq/ M225=M M114<=M.\n\n%worlds () (update-left-preserves-leq* _ _ _ _).\n%total (U) (update-left-preserves-leq* _ _ U _).\n\n\n%theorem update-right-preserves-leq*:\n\tforall* {M} {N} {D1} {D2} {M1'} {M2'}\n\tforall {L:nat`leq D1 D2} \n               {U1:update M N D1 M1'}\n\t       {U2:update M N D2 M2'}\n\texists {LP:leq M1' M2'}\n\ttrue.\n\n- : update-right-preserves-leq* D1<=D2 update/0 update/0 \n                                (leq/= leq/0 D1<=D2 nat`eq/).\n\n- : update-right-preserves-leq* D1<=D2 (update/= nat`eq/) U2 L\n    <- update/=-inversion U2 nat`eq/ M221=M2'\n    <- leq-reflexive _ M1<=M1\n    <- leq-respects-eq (leq/= M1<=M1 D1<=D2 nat`eq/) eq/ M221=M2' L.\n\n- : update-right-preserves-leq* D1<=D2 (update/< P) U2 L\n    <- update/<-inversion U2 P M22311=M2'\n    <- leq-reflexive _ M311<=M311\n    <- leq-respects-eq (leq/= M311<=M311 D1<=D2 nat`eq/) eq/ M22311=M2' L.\n\n- : update-right-preserves-leq* D1<=D2 (update/> U1 P) U22 L\n    <- update/>-inversion U22 P M2' U2 M112=M\n    <- update-right-preserves-leq* D1<=D2 U1 U2 M1'<=M2'\n    <- nat`leq-reflexive _ D<=D\n    <- leq-respects-eq (leq/= M1'<=M2' D<=D nat`eq/) eq/ M112=M L.\n\n%worlds () (update-right-preserves-leq* _ _ _ _).\n%total (U) (update-right-preserves-leq* _ U _ _).\n\n\n%theorem update-preserves-leq* :\n\tforall* {M1} {M2} {N} {D1} {D2} {M1'} {M2'}\n\tforall {L:leq M1 M2} {L:nat`leq D1 D2} \n               {U1:update M1 N D1 M1'}\n\t       {U2:update M2 N D2 M2'}\n\texists {LP:leq M1' M2'}\n\ttrue.\n\n- : update-preserves-leq* M1<=M2 D1<=D2 M1^N=D1->M1' M2^N=D2->M2' M1'<=M2'\n    <- update-total M2^N=D1->MM\n    <- update-left-preserves-leq* M1<=M2 M1^N=D1->M1' M2^N=D1->MM M1'<=MM\n    <- update-right-preserves-leq* D1<=D2 M2^N=D1->MM M2^N=D2->M2' MM<=M2'\n    <- leq-transitive M1'<=MM MM<=M2' M1'<=M2'.\n\n%worlds () (update-preserves-leq* _ _ _ _ _).\n%total { } (update-preserves-leq* _ _ _ _ _).\n\n\n%theorem not-member-update-implies-leq :\n\tforall* {M1} {N} {D} {M2}\n\tforall {F:not-member M1 N} {U:update M1 N D M2}\n\texists {L:leq M1 M2}\n\ttrue.\n\n- : not-member-update-implies-leq not-member/0 U leq/0.\n\n- : not-member-update-implies-leq (not-member/< N2<N1) U L\n    <- gt-implies-plus N2<N1 _ N3+1+N2=N1\n    <- update/<-inversion U N3+1+N2=N1 M22311=M2\n    <- leq-reflexive _ M311<=M311\n    <- leq-respects-eq (leq/> M311<=M311 N3+1+N2=N1) eq/ M22311=M2 L.\n\n- : not-member-update-implies-leq (not-member/> F1 N0+1+N1=N2) U L\n    <- update/>-inversion U N0+1+N1=N2 _ U1 M112=M\n    <- not-member-update-implies-leq F1 U1 L1\n    <- nat`leq-reflexive _ DL\n    <- leq-respects-eq (leq/= L1 DL nat`eq/) eq/ M112=M L.\n\n%worlds () (not-member-update-implies-leq _ _ _).\n%total (F) (not-member-update-implies-leq F _ _).\n\n\n%theorem lookup-update-preserves-leq :\n\tforall* {M1} {N} {D1} {D2} {M2}\n\tforall {L:lookup M1 N D1} {U:update M1 N D2 M2}\n               {L:nat`leq D1 D2}\n\texists {L:leq M1 M2}\n\ttrue.\n\n- : lookup-update-preserves-leq (lookup/= nat`eq/) U D1<=D2 L\n    <- update/=-inversion U nat`eq/ M221=M2\n    <- leq-reflexive _ M1<=M1\n    <- leq-respects-eq (leq/= M1<=M1 D1<=D2 nat`eq/) eq/ M221=M2 L.\n\n- : lookup-update-preserves-leq (lookup/> L1 N0+1+N1=N2) U D1<=D2 L\n    <- update/>-inversion U N0+1+N1=N2 M2 U1 M112=M\n    <- lookup-update-preserves-leq L1 U1 D1<=D2 L1'\n    <- nat`leq-reflexive _ D1<=D1\n    <- leq-respects-eq (leq/= L1' D1<=D1 nat`eq/) eq/ M112=M L.\n\n%worlds () (lookup-update-preserves-leq _ _ _ _).\n%total (L) (lookup-update-preserves-leq L _ _ _).\n\n\n\n\n%%%% Map addition\n\n\n\n%%% Definition of union\n\n\nunion : map -> map -> map -> type.\n\n\nunion/L : union map/0 M M.\n\nunion/R : union M map/0 M.\n\nunion/= : union (map/+ N1 D1 M1) (map/+ N2 D2 M2) (map/+ N1 D3 M3)\n    <- nat`eq N1 N2\n    <- nat`union D1 D2 D3\n    <- union M1 M2 M3.\n\nunion/< : union (map/+ N1 D1 M1) (map/+ N2 D2 M2) (map/+ N1 D1 M3)\n    <- nat`plus (s N0) N1 N2\n    <- union M1 (map/+ N0 D2 M2) M3.\n\nunion/> : union (map/+ N1 D1 M1) (map/+ N2 D2 M2) (map/+ N2 D2 M3)\n    <- nat`plus (s N3) N2 N1\n    <- union (map/+ N3 D1 M1) M2 M3.\n\n\n\n%%% Theorems about union\n\n\n%theorem false-implies-union :\n\tforall* {M1} {M2} {M3}\n\tforall {F:void}\n\texists {D:union M1 M2 M3}\n\ttrue.\n\n%worlds () (false-implies-union _ _).\n%total {} (false-implies-union _ _).\n\n\n%theorem union-respects-eq :\n\tforall* {M1} {M2} {M3} {M1P} {M2P} {M3P}\n\tforall {A:union M1 M2 M3} {E1:eq M1 M1P} {E2:eq M2 M2P} {E3:eq M3 M3P}\n\texists {AP:union M1P M2P M3P}\n\ttrue.\n\n- : union-respects-eq A eq/ eq/ eq/ A.\n\n%worlds () (union-respects-eq _ _ _ _ _).\n%total {} (union-respects-eq _ _ _ _ _).\n%reduces A = AP (union-respects-eq A _ _ _ AP).\n\n\n%% Inversion lemmas for union\n\n\n%theorem union/=-inversion :\n\tforall* {N1} {D1} {M1} {N2} {D2} {M2} {M} \n\tforall {A:union (map/+ N1 D1 M1) (map/+ N2 D2 M2) M}\n\t       {G:nat`eq N1 N2}\n\texists {D3} {M3} \n\t       {D:nat`union D1 D2 D3}\n               {AP:union M1 M2 M3}\n               {E:eq M (map/+ N1 D3 M3)}\n\ttrue.\n\n- : union/=-inversion (union/= MM DD nat`eq/) _ _ _ DD MM eq/.\n\n- : union/=-inversion (union/< (JP:union _ (map/+ N0 D2 M2) M3) N0+1+N=N) nat`eq/ \n                     D2 M3 DJ MJ ME\n    <- plus-implies-gt N0+1+N=N nat`eq/ N>N\n    <- gt-anti-reflexive N>N F\n    <- nat`false-implies-union F DJ\n    <- false-implies-eq F (M022=M2:eq (map/+ N0 D2 M2) M2)\n    <- union-respects-eq JP eq/ M022=M2 eq/ MJ\n    <- false-implies-eq F ME.\n\n- : union/=-inversion (union/> (JP:union (map/+ _ D1 M1) M2 M3) N3+1+N=N) nat`eq/\n                     D1 M3 DJ MJ ME\n    <- nat`plus-implies-gt N3+1+N=N nat`eq/ N>N\n    <- nat`gt-anti-reflexive N>N F\n    <- nat`false-implies-union F DJ\n    <- false-implies-eq F (M311=M1:eq (map/+ N3 D1 M1) M1)\n    <- union-respects-eq JP M311=M1 eq/ eq/ MJ\n    <- false-implies-eq F ME.\n\n%worlds () (union/=-inversion _ _ _ _ _ _ _).\n%total {} (union/=-inversion _ _ _ _ _ _ _).\n%reduces JP < J (union/=-inversion J _ _ _ _ JP _).\n\n\n%theorem union/<-inversion :\n\tforall* {N1} {D1} {M1} {N2} {D2} {M2} {M} {N0}\n\tforall {A:union (map/+ N1 D1 M1) (map/+ N2 D2 M2) M}\n               {P:plus (s N0) N1 N2} \t       \n\texists {M3} \n               {AP:union M1 (map/+ N0 D2 M2) M3}\n               {E:eq M (map/+ N1 D1 M3)}\n\ttrue.\n\n- : union/<-inversion (union/< J P) P' _ J' eq/\n    <- nat`plus-right-cancels P P' nat`eq/ nat`eq/ N0+1=N0'+1\n    <- succ-cancels N0+1=N0'+1 N0=N0P\n    <- map/+-preserves-eq N0=N0P nat`eq/ eq/ M022=M022'\n    <- union-respects-eq J eq/ M022=M022' eq/ J'.\n\n- : union/<-inversion (union/= J' _ nat`eq/) N0+1+N=N M3 J E\n    <- plus-implies-gt N0+1+N=N nat`eq/ N>N\n    <- gt-anti-reflexive N>N F\n    <- false-implies-eq F M2=M022\n    <- union-respects-eq J' eq/ M2=M022 eq/ J\n    <- false-implies-eq F E.\n\n- : union/<-inversion (union/> J' N3+1+N2=N1) N0+1+N1=N2 M3 J E\n    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2\n    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1\n    <- nat`gt-anti-symmetric N1>N2 N2>N1 F\n    <- false-implies-eq F M311=M1\n    <- false-implies-eq F M2=M022\n    <- union-respects-eq J' M311=M1 M2=M022 eq/ J\n    <- false-implies-eq F E.\n\n%worlds () (union/<-inversion _ _ _ _ _).\n%total {}  (union/<-inversion _ _ _ _ _).\n%reduces JP < J (union/<-inversion J _ _ JP _).\n\n\n%theorem union/>-inversion :\n\tforall* {N1} {D1} {M1} {N2} {D2} {M2} {N3} {M} \n\tforall {A:union (map/+ N1 D1 M1) (map/+ N2 D2 M2) M}\n\t       {P:plus (s N3) N2 N1}\n\texists {M3} \n               {AP:union (map/+ N3 D1 M1) M2 M3}\n               {E:eq M (map/+ N2 D2 M3)}\n\ttrue.\n\n- : union/>-inversion (union/> J P) P' _ J' eq/\n    <- nat`plus-right-cancels P P' nat`eq/ nat`eq/ N3+1=N3'+1\n    <- succ-cancels N3+1=N3'+1 N3=N3P\n    <- map/+-preserves-eq N3=N3P nat`eq/ eq/ M311=M311'\n    <- union-respects-eq J M311=M311' eq/ eq/ J'.\n\n- : union/>-inversion (union/= J' _ nat`eq/) N3+1+N=N M3 J E\n    <- nat`plus-implies-gt N3+1+N=N nat`eq/ N>N\n    <- gt-anti-reflexive N>N F\n    <- false-implies-eq F M1=M311\n    <- union-respects-eq J' M1=M311 eq/ eq/ J\n    <- false-implies-eq F E.\n\n- : union/>-inversion (union/< J' N0+1+N1=N2) N3+1+N2=N1 M3 J E\n    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2\n    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1\n    <- nat`gt-anti-symmetric N1>N2 N2>N1 F\n    <- false-implies-eq F M1=M311\n    <- false-implies-eq F M022=M2\n    <- union-respects-eq J' M1=M311 M022=M2 eq/ J\n    <- false-implies-eq F E.\n\n%worlds () (union/>-inversion _ _ _ _ _).\n%total {} (union/>-inversion _ _ _ _ _).\n%reduces JP < J (union/>-inversion J _ _ JP _).\n\n\n%theorem union-deterministic :\n\tforall* {M1} {M2} {M3} {M1P} {M2P} {M3P}\n\tforall {A:union M1 M2 M3} {AP:union M1P M2P M3P}\n               {E1:eq M1 M1P} {E2:eq M2 M2P}\n\texists {E3:eq M3 M3P}\n\ttrue.\n\n- : union-deterministic union/L union/L eq/ eq/ eq/.\n\n- : union-deterministic union/L union/R eq/ eq/ eq/.\n\n- : union-deterministic union/R union/L eq/ eq/ eq/.\n\n- : union-deterministic union/R union/R eq/ eq/ eq/.\n\n- : union-deterministic (union/= M1+M2=M3 D1+D2=D3 nat`eq/)\n                      (union/= M1+M2=M3' D1+D2=D3P nat`eq/) \n\t\t      eq/ eq/ M=M'\n    <- nat`union-deterministic D1+D2=D3 D1+D2=D3P nat`eq/ nat`eq/ D3=D3'\n    <- union-deterministic M1+M2=M3 M1+M2=M3' eq/ eq/ M3=M3'\n    <- map/+-preserves-eq nat`eq/ D3=D3' M3=M3' M=M'.\n\n- : union-deterministic (union/< M1+MT=M3 N0+1+N1=N2)\n                      (union/< M1+MT'=M3' N0'+1+N1=N2)\n\t\t      eq/ eq/ M=M'\n    <- plus-right-cancels N0+1+N1=N2 N0'+1+N1=N2 nat`eq/ nat`eq/ N0+1=N0'+1\n    <- succ-cancels N0+1=N0'+1 N0=N0P\n    <- map/+-preserves-eq N0=N0P nat`eq/ eq/ MT=MT'\n    <- union-deterministic M1+MT=M3 M1+MT'=M3' eq/ MT=MT' M3=M3'\n    <- map/+-preserves-eq nat`eq/ nat`eq/ M3=M3' M=M'.\n\n- : union-deterministic (union/> MT+M2=M3 N3+1+N2=N1)\n                      (union/> MT'+M2=M3' N3'+1+N2=N1) eq/ eq/ E\n    <- plus-right-cancels N3+1+N2=N1 N3'+1+N2=N1 nat`eq/ nat`eq/ N3+1=N3'+1\n    <- succ-cancels N3+1=N3'+1 N3=N3P\n    <- map/+-preserves-eq N3=N3P nat`eq/ eq/ MT=MT'\n    <- union-deterministic MT+M2=M3 MT'+M2=M3' MT=MT' eq/ M3=M3'\n    <- map/+-preserves-eq nat`eq/ nat`eq/ M3=M3' E.\n\n%% contradiction cases:\n\n- : union-deterministic (union/= _ _ nat`eq/) (union/< _ N'+1+N=N) eq/ eq/ E\n    <- plus-implies-gt N'+1+N=N nat`eq/ N>N\n    <- gt-anti-reflexive N>N F\n    <- false-implies-eq F E.\n\n- : union-deterministic (union/= _ _ nat`eq/) (union/> _ N'+1+N=N) eq/ eq/ E\n    <- plus-implies-gt N'+1+N=N nat`eq/ N>N\n    <- gt-anti-reflexive N>N F\n    <- false-implies-eq F E.\n\n- : union-deterministic (union/< _ NP+1+N=N) (union/= _ _ nat`eq/) eq/ eq/ E\n    <- plus-implies-gt NP+1+N=N nat`eq/ N>N\n    <- gt-anti-reflexive N>N F\n    <- false-implies-eq F E.\n\n- : union-deterministic (union/< _ N0+1+N1=N2) (union/> _ N3+1+N2=N1) eq/ eq/ E\n    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2\n    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1\n    <- nat`gt-anti-symmetric N1>N2 N2>N1 F\n    <- false-implies-eq F E.\n\n- : union-deterministic (union/> _ NP+1+N=N) (union/= _ _ nat`eq/) eq/ eq/ E\n    <- plus-implies-gt NP+1+N=N nat`eq/ N>N\n    <- gt-anti-reflexive N>N F\n    <- false-implies-eq F E.\n\n- : union-deterministic (union/> _ N3+1+N2=N1) (union/< _ N0+1+N1=N2) eq/ eq/ E\n    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2\n    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1\n    <- nat`gt-anti-symmetric N1>N2 N2>N1 F\n    <- false-implies-eq F E.\n\n%worlds () (union-deterministic _ _ _ _ _).\n%total (A) (union-deterministic A _ _ _ _).\n\n\n\n\n%theorem union-total* :\n\tforall {M1} {M2}\n\texists {M3} {A:union M1 M2 M3}\n\ttrue.\n\n%% we need some lemmas\n%% We need them to ensure termination because\n%% union substitutes new maps on recursive calls which\n%% makes it hard to prove the arguments get smaller.\n\n%theorem union-map/+-M-total* :\n\tforall {N1} {D1} {M1} {M2}\n        exists {M3} {A:union (map/+ N1 D1 M1) M2 M3}\n\ttrue.\n\n%theorem union-M-map/+-total* :\n\tforall {M1} {N2} {D2} {M2}\n        exists {M3} {A:union M1 (map/+ N2 D2 M2) M3}\n\ttrue.\n\n%theorem union-map/+-map/+-total* :\n\tforall {N1} {D1} {M1} {N2} {D2} {M2} {C} {CMP:nat`compare N1 N2 C}\n        exists {M3} \n               {A:union (map/+ N1 D1 M1) (map/+ N2 D2 M2) M3}\n\ttrue.\n\n- : union-total* map/0 M M union/L.\n\n- : union-total* M map/0 M union/R.\n\n- : union-total* (map/+ N1 D1 M1) (map/+ N2 D2 M2) M3 A\n    <- nat`compare-total* N1 N2 C CMP\n    <- union-map/+-map/+-total* N1 D1 M1 N2 D2 M2 C CMP M3 A.               \n\n- : union-map/+-map/+-total* N1 D1 M1 N2 D2 M2 equal CMP (map/+ N1 D3 M3)\n                           (union/= M1+M2=M3 D1+D2=D3 N1=N2)\n    <- equal-implies-eq CMP N1=N2\n    <- nat`union-total* D1 D2 D3 D1+D2=D3\n    <- union-total* M1 M2 M3 M1+M2=M3.\n\n- : union-map/+-map/+-total* N1 D1 M1 N2 D2 M2 less CMP (map/+ N1 D1 M3)\n                           (union/< M1+T=M3 N0+1+N1=N2)\n    <- less-implies-lt CMP N2>N1\n    <- gt-implies-plus N2>N1 _ N0+1+N1=N2\n    <- union-M-map/+-total* M1 N0 D2 M2 M3 M1+T=M3.\n\n- : union-map/+-map/+-total* N1 D1 M1 N2 D2 M2 greater CMP (map/+ N2 D2 M3)\n                           (union/> T+M2=M3 N3+1+N2=N1)\n    <- greater-implies-gt CMP N1>N2\n    <- gt-implies-plus N1>N2 _ N3+1+N2=N1\n    <- union-map/+-M-total* N3 D1 M1 M2 M3 T+M2=M3.\n\n- : union-M-map/+-total* map/0 N2 D2 M2 (map/+ N2 D2 M2) union/L.\n\n- : union-M-map/+-total* (map/+ N1 D1 M1) N2 D2 M2 M3 A\n    <- nat`compare-total* N1 N2 C CMP\n    <- union-map/+-map/+-total* N1 D1 M1 N2 D2 M2 C CMP M3 A.\n\n- : union-map/+-M-total* N1 D1 M1 map/0 (map/+ N1 D1 M1) union/R.\n\n- : union-map/+-M-total* N1 D1 M1 (map/+ N2 D2 M2) M3 A\n    <- nat`compare-total* N1 N2 C CMP\n    <- union-map/+-map/+-total* N1 D1 M1 N2 D2 M2 C CMP M3 A.\n\n%worlds () (union-total* _ _ _ _)\n           (union-M-map/+-total* _ _ _ _ _ _)\n           (union-map/+-M-total* _ _ _ _ _ _)\n           (union-map/+-map/+-total* _ _ _ _ _ _ _ _ _ _).\n\n%total [ (M1a M1b M1c M1d) (M2a M2b M2c M2d) ]\n        (union-total* M1d M2d _ _)\n        (union-M-map/+-total* M1c _ _ M2c _ _)\n        (union-map/+-M-total* _ _ M1b M2b _ _)\n\t(union-map/+-map/+-total* _ _ M1a _ _ M2a _ _ _ _).\n               \n%abbrev union-total = union-total* _ _ _.\n\n\n%theorem disjoint-union-total :\n\tforall* {M1} {M2} \n\tforall {D:disjoint M1 M2}\n\texists {M3} {A:union M1 M2 M3}\n\ttrue.\n\n- : disjoint-union-total disjoint/L _ union/L. \n\n- : disjoint-union-total disjoint/R _ union/R.\n\n- : disjoint-union-total (disjoint/< D P) _ (union/< J P)\n    <- disjoint-union-total D _ J.\n\n- : disjoint-union-total (disjoint/> D P) _ (union/> J P)\n    <- disjoint-union-total D _ J.\n\n%worlds () (disjoint-union-total _ _ _).\n%total (D) (disjoint-union-total D _ _).\n\n\n%theorem union-empty-implies-empty :\n\tforall* {M1} {M2}\n\tforall {A:union M1 M2 map/0}\n\texists {E1:eq M1 map/0} {E2:eq M2 map/0}\n\ttrue.\n\n- : union-empty-implies-empty union/L eq/ eq/.\n\n- : union-empty-implies-empty union/R eq/ eq/.\n\n%worlds () (union-empty-implies-empty _ _ _).\n%total { } (union-empty-implies-empty _ _ _).\n\n\n%theorem union-preserves-disjoint* :\n\tforall* {M1} {M2} {M3} {M4}\n\tforall {D1:disjoint M1 M4} {D2:disjoint M2 M4}\n\t       {A:union M1 M2 M3}\n\texists {D3:disjoint M3 M4}\n\ttrue.\n\n% a lemma that counts the size of maps to help prove termination\n%theorem union-preserves-disjoint*/L :\n\tforall* {M1} {M2} {M3} {M4}\n\tforall {S1} {S2} {SZ1:size M1 S1} {SZ2:size M2 S2}\n               {D1:disjoint M1 M4} {D2:disjoint M2 M4}\n\t       {A:union M1 M2 M3}\n\texists {D3:disjoint M3 M4}\n\ttrue.\n\n- : union-preserves-disjoint* D1 D2 J D3\n    <- size-total SZ1\n    <- size-total SZ2\n    <- union-preserves-disjoint*/L _ _ SZ1 SZ2 D1 D2 J D3.\n\n- : union-preserves-disjoint*/L _ _ _ _ disjoint/R _ _ disjoint/R.\n\n- : union-preserves-disjoint*/L _ _ _ _ _ disjoint/R _ disjoint/R.\n\n- : union-preserves-disjoint*/L _ _ _ _ _ D union/L D.\n\n- : union-preserves-disjoint*/L _ _ _ _ D _ union/R D.\n\n- : union-preserves-disjoint*/L (s S1) (s S2) (size/+ SZ1) (size/+ SZ2)\n                               (disjoint/< D1 N5+1+N1=N4) D2X \n                               (union/= J _ nat`eq/)\n                               (disjoint/< D3 N5+1+N1=N4)\n    <- disjoint/<-inversion D2X N5+1+N1=N4 D2\n    <- union-preserves-disjoint*/L S1 S2 SZ1 SZ2 D1 D2 J D3.\n\n- : union-preserves-disjoint*/L (s S1) (s S2) (size/+ SZ1) (size/+ SZ2)\n                               (disjoint/< D1 N5+1+N1=N4) D2X\n                               (union/> J N3+1+N2=N1)\n                               (disjoint/< D3 N6+1+N2=N4)\n    <- plus-swap-succ N3+1+N2=N1 N3+N2+1=N1\n    <- plus-associative-converse N3+N2+1=N1 N5+1+N1=N4 N6 N5+1+N3=N6 N6+N2+1=N4\n    <- plus-swap-succ-converse N6+N2+1=N4 N6+1+N2=N4\n    <- disjoint/<-inversion D2X N6+1+N2=N4 D2\n    <- plus-swap-succ N5+1+N3=N6 N5+N3+1=N6\n    <- plus-commutative N5+N3+1=N6 N3+1+N5=N6\n    <- shift-right-preserves-disjoint D1 (shift/+ N3+1+N5=N6) D1<<N3\n    <- union-preserves-disjoint*/L (s S1) S2 (size/+ SZ1) SZ2 D1<<N3 D2 J D3.\n\n- : union-preserves-disjoint*/L (s S1) (s S2) (size/+ SZ1) (size/+ SZ2)\n                               (disjoint/> D1 N5+1+N4=N1) D2X \n                               (union/= J DJ nat`eq/)\n                               (disjoint/> D3 N5+1+N4=N1)\n    <- disjoint/>-inversion D2X N5+1+N4=N1 D2\n    <- union-preserves-disjoint*/L _ _ (size/+ SZ1) (size/+ SZ2) \n                                  D1 D2 (union/= J DJ nat`eq/) D3.\n\n- : union-preserves-disjoint*/L (s S1) (s S2) (size/+ SZ1) (size/+ SZ2)\n                               (disjoint/> D1 N5+1+N4=N1) D2X\n                               (union/< J N0+1+N1=N2)\n                               (disjoint/> D3 N5+1+N4=N1)\n    <- plus-swap-succ N5+1+N4=N1 N5+N4+1=N1\n    <- plus-associative-converse N5+N4+1=N1 N0+1+N1=N2 N6 N0+1+N5=N6 N6+N4+1=N2\n    <- plus-swap-succ-converse N6+N4+1=N2 N6+1+N4=N2\n    <- disjoint/>-inversion D2X N6+1+N4=N2 D2\n    <- union-preserves-disjoint*/L _ _ (size/+ SZ1) (size/+ SZ2) \n                                  D1 D2 (union/< J N0+1+N5=N6) D3.\n\n- : union-preserves-disjoint*/L (s S1) (s S2) (size/+ SZ1) (size/+ SZ2)\n                               D1X (disjoint/< D2 N6+1+N2=N4) \n                               (union/< J N0+1+N1=N2)\n                               (disjoint/< D3 N5+1+N1=N4)\n    <- plus-swap-succ N0+1+N1=N2 N0+N1+1=N2\n    <- plus-associative-converse N0+N1+1=N2 N6+1+N2=N4 N5 N6+1+N0=N5 N5+N1+1=N4\n    <- plus-swap-succ-converse N5+N1+1=N4 N5+1+N1=N4\n    <- disjoint/<-inversion D1X N5+1+N1=N4 D1\n    <- plus-swap-succ N6+1+N0=N5 N6+N0+1=N5\n    <- plus-commutative N6+N0+1=N5 N0+1+N6=N5\n    <- shift-right-preserves-disjoint D2 (shift/+ N0+1+N6=N5) D2<<N0\n    <- union-preserves-disjoint*/L S1 (s S2) SZ1 (size/+ SZ2) D1 D2<<N0 J D3.\n\n- : union-preserves-disjoint*/L (s S1) (s S2) (size/+ SZ1) (size/+ SZ2)\n                               D1X (disjoint/> D2 N6+1+N4=N2)\n                               (union/> J N3+1+N2=N1)\n                               (disjoint/> D3 N6+1+N4=N2)\n    <- plus-swap-succ N6+1+N4=N2 N6+N4+1=N2\n    <- plus-associative-converse N6+N4+1=N2 N3+1+N2=N1 N5 N3+1+N6=N5 N5+N4+1=N1\n    <- plus-swap-succ-converse N5+N4+1=N1 N5+1+N4=N1\n    <- disjoint/>-inversion D1X N5+1+N4=N1 D1\n    <- union-preserves-disjoint*/L _ _ (size/+ SZ1) (size/+ SZ2) \n                                  D1 D2 (union/> J N3+1+N6=N5) D3.\n\n- : union-preserves-disjoint*/L (s S1) (s S2) (size/+ SZ1) (size/+ SZ2)\n                               (disjoint/< D1 N5+1+N1=N4)\n                               (disjoint/> D2 N6+1+N4=N2) JX D3X\n    <- plus-swap-succ N5+1+N1=N4 N5+N1+1=N4\n    <- plus-associative-converse N5+N1+1=N4 N6+1+N4=N2 N0 N6+1+N5=N0 N0+N1+1=N2\n    <- plus-swap-succ-converse N0+N1+1=N2 N0+1+N1=N2\n    <- union/<-inversion JX N0+1+N1=N2 _ J M=M113\n    <- eq-symmetric M=M113 M113=M\n    <- union-preserves-disjoint*/L S1 (s S2) SZ1 (size/+ SZ2)\n                                  D1 (disjoint/> D2 N6+1+N5=N0) J D3\n    <- disjoint-respects-eq (disjoint/< D3 N5+1+N1=N4) M113=M eq/ D3X.\n\n- : union-preserves-disjoint*/L (s S1) (s S2) (size/+ SZ1) (size/+ SZ2)\n                               (disjoint/> D1 N5+1+N4=N1)\n                               (disjoint/< D2 N6+1+N2=N4) JX D3X\n    <- plus-swap-succ N6+1+N2=N4 N6+N2+1=N4\n    <- plus-associative-converse N6+N2+1=N4 N5+1+N4=N1 N3 N5+1+N6=N3 N3+N2+1=N1\n    <- plus-swap-succ-converse N3+N2+1=N1 N3+1+N2=N1\n    <- union/>-inversion JX N3+1+N2=N1 _ J M=M223\n    <- eq-symmetric M=M223 M223=M\n    <- union-preserves-disjoint*/L _ _ (size/+ SZ1) SZ2\n                                  (disjoint/> D1 N5+1+N6=N3) D2 J D3\n    <- disjoint-respects-eq (disjoint/< D3 N6+1+N2=N4) M223=M eq/ D3X.\n\n%worlds () (union-preserves-disjoint*/L _ _ _ _ _ _ _ _).\n%total {S1 S2 D1} (union-preserves-disjoint*/L S1 S2 _ _ D1 _ _ _).\n\n%worlds () (union-preserves-disjoint* _ _ _ _).\n%total { } (union-preserves-disjoint* _ _ _ _).\n\n\n%theorem shift-left-preserves-union :\n\tforall* {N} {D} {M1} {M2} {M3} {SM1}\n\tforall {A:union M1 M2 M3} {S1:shift N M1 SM1}\n        exists {SA:union SM1 (map/+ N D M2) (map/+ N D M3)}\n        true.\n\n- : shift-left-preserves-union union/L shift/0 union/L.\n\n- : shift-left-preserves-union union/R shift/0 union/L.\n\n- : shift-left-preserves-union M111+M2=M3 (shift/+ N+1+N1=N1')\n                              (union/> M111+M2=M3 N1+1+N=N1')\n    <- plus-swap-succ N+1+N1=N1' N+N1+1=N1'\n    <- plus-commutative N+N1+1=N1' N1+1+N=N1'.\n\n%worlds () (shift-left-preserves-union _ _ _).\n%total { } (shift-left-preserves-union _ _ _).\n\n\n%theorem shift-left-preserves-union-converse :\n\tforall* {N} {D} {M1} {M2} {SM1} {SM3}\n\tforall {SA:union SM1 (map/+ N D M2) SM3} {S1:shift N M1 SM1}\n        exists {M3} {A:union M1 M2 M3} {E:eq (map/+ N D M3) SM3}\n\ttrue.\n\n- : shift-left-preserves-union-converse union/L shift/0 _ union/L eq/.\n\n- : shift-left-preserves-union-converse M111+M222=SM3 (shift/+ N2+1+N3=N1) M3\n                                       M311+M2=M3 M223=SM3\n    <- plus-swap-succ N2+1+N3=N1 N2+N3+1=N1\n    <- plus-commutative N2+N3+1=N1 N3+1+N2=N1\n    <- union/>-inversion M111+M222=SM3 N3+1+N2=N1 M3 M311+M2=M3 SM3=M223\n    <- eq-symmetric SM3=M223 M223=SM3.\n\n%worlds () (shift-left-preserves-union-converse _ _ _ _ _).\n%total { } (shift-left-preserves-union-converse _ _ _ _ _).\n\n\n%theorem shift-right-preserves-union :\n\tforall* {N} {D} {M1} {M2} {M3} {SM2}\n\tforall {A:union M1 M2 M3} {S2:shift N M2 SM2}\n        exists {SA:union (map/+ N D M1) SM2 (map/+ N D M3)}\n\ttrue.\n\n- : shift-right-preserves-union union/L shift/0 union/R.\n\n- : shift-right-preserves-union union/R shift/0 union/R.\n\n- : shift-right-preserves-union M1+M222=M3 (shift/+ N+1+N2=N2') \n                               (union/< M1+M222=M3 N2+1+N=N2')\n    <- plus-swap-succ N+1+N2=N2' N+N2+1=N2'\n    <- plus-commutative N+N2+1=N2' N2+1+N=N2'.\n\n%worlds () (shift-right-preserves-union _ _ _).\n%total { } (shift-right-preserves-union _ _ _).\n\n\n%theorem shift-right-preserves-union-converse :\n\tforall* {N} {D} {M1} {M2} {SM2} {SM3}\n\tforall {SA:union (map/+ N D M1) SM2 SM3} {S2:shift N M2 SM2}\n        exists {M3} {A:union M1 M2 M3} {E:eq (map/+ N D M3) SM3}\n\ttrue.\n\n- : shift-right-preserves-union-converse union/R shift/0 _ union/R eq/.\n\n- : shift-right-preserves-union-converse M111+M322=SM3 (shift/+ N1+1+N2=N3)\n                                        M3 M1+M222=M3 M133=SM3\n    <- plus-swap-succ N1+1+N2=N3 N1+N2+1=N3\n    <- plus-commutative N1+N2+1=N3 N2+1+N1=N3\n    <- union/<-inversion M111+M322=SM3 N2+1+N1=N3 M3 M1+M222=M3 SM3=M133\n    <- eq-symmetric SM3=M133 M133=SM3.\n\n%worlds () (shift-right-preserves-union-converse _ _ _ _ _).\n%total { } (shift-right-preserves-union-converse _ _ _ _ _).\n\n\n%theorem shift-preserves-union :\n\tforall* {N} {M1} {M2} {M3} {SM1} {SM2} {SM3}\n\tforall {A:union M1 M2 M3} \n               {S1:shift N M1 SM1} {S2:shift N M2 SM2} {S3:shift N M3 SM3}\n\texists {SA:union SM1 SM2 SM3}\n\ttrue.\n\n- : shift-preserves-union union/L shift/0 M2<<N=SM2 M2<<N=SM3 Z+SM2=SM3\n    <- shift-deterministic M2<<N=SM2 M2<<N=SM3 nat`eq/ eq/ SM2=SM3\n    <- union-respects-eq union/L eq/ eq/ SM2=SM3 Z+SM2=SM3.\n\n- : shift-preserves-union union/R M1<<N=SM1 shift/0 M1<<N=SM3 SM1+0=SM3\n    <- shift-deterministic M1<<N=SM1 M1<<N=SM3 nat`eq/ eq/ SM1=SM3\n    <- union-respects-eq union/R eq/ eq/ SM1=SM3 SM1+0=SM3.\n\n- : shift-preserves-union (union/= M1+M2=M3 D1+D2=D3 nat`eq/) \n                         (shift/+ N+1+N1=N4) (shift/+ N+1+N1=N5) \n                         (shift/+ N+1+N1=N6)\n                         M411+M522=M633\n    <- plus-deterministic N+1+N1=N4 N+1+N1=N5 nat`eq/ nat`eq/ N4=N5\n    <- plus-deterministic N+1+N1=N4 N+1+N1=N6 nat`eq/ nat`eq/ N4=N6\n    <- map/+-preserves-eq N4=N6 nat`eq/ eq/ M433=M633\n    <- union-respects-eq (union/= M1+M2=M3 D1+D2=D3 N4=N5) eq/ eq/ M433=M633\n                        M411+M522=M633.\n\n- : shift-preserves-union (union/< M1+M022=M3 N0+1+N1=N2)\n                         (shift/+ N+1+N1=N4) (shift/+ N+1+N2=N5) \n                         (shift/+ N+1+N1=N6) M411+M522=M613\n    <- plus-deterministic N+1+N1=N4 N+1+N1=N6 nat`eq/ nat`eq/ N4=N6\n    <- plus-swap-succ N+1+N1=N4 N+N1+1=N4\n    <- plus-commutative N+N1+1=N4 N1+1+N=N4\n    <- plus-commutative N0+1+N1=N2 N1+N0+1=N2\n    <- plus-associative-converse* N1+N0+1=N2 N+1+N2=N5 N+1+N1=N4 N4+N0+1=N5\n    <- plus-commutative N4+N0+1=N5 N0+1+N4=N5\n    <- map/+-preserves-eq N4=N6 nat`eq/ eq/ M433=M613\n    <- union-respects-eq (union/< M1+M022=M3 N0+1+N4=N5) eq/ eq/ M433=M613\n                        M411+M522=M613.\n\n- : shift-preserves-union (union/> M311+M2=M3 N3+1+N2=N1)\n                         (shift/+ N+1+N1=N4) (shift/+ N+1+N2=N5) \n                         (shift/+ N+1+N2=N6) M411+M522=M623\n    <- plus-deterministic N+1+N2=N5 N+1+N2=N6 nat`eq/ nat`eq/ N5=N6\n    <- plus-swap-succ N+1+N2=N5 N+N2+1=N5\n    <- plus-commutative N+N2+1=N5 N2+1+N=N5\n    <- plus-commutative N3+1+N2=N1 N2+N3+1=N1\n    <- plus-associative-converse* N2+N3+1=N1 N+1+N1=N4 N+1+N2=N5 N5+N3+1=N4\n    <- plus-commutative N5+N3+1=N4 N3+1+N5=N4\n    <- map/+-preserves-eq N5=N6 nat`eq/ eq/ M523=M623\n    <- union-respects-eq (union/> M311+M2=M3 N3+1+N5=N4) eq/ eq/ M523=M623\n                        M411+M522=M623.\n\n%worlds () (shift-preserves-union _ _ _ _ _).\n%total { } (shift-preserves-union _ _ _ _ _).\n\n\n%theorem shift-preserves-union-converse :\n\tforall* {N} {M1} {M2} {SM1} {SM2} {SM3}\n\tforall {SA:union SM1 SM2 SM3}\n               {S1:shift N M1 SM1} {S2:shift N M2 SM2} \n\texists {M3} {A:union M1 M2 M3} {S3:shift N M3 SM3}\n\ttrue.\n\n- : shift-preserves-union-converse union/L shift/0 M2<<N=SM2 _ union/L M2<<N=SM2.\n\n- : shift-preserves-union-converse union/R M1<<N=SM1 shift/0 _ union/R M1<<N=SM1.\n\n- : shift-preserves-union-converse (union/= M1+M2=M3 D1+D2=D3 nat`eq/) \n                                  (shift/+ N+1+N1=N4) (shift/+ N+1+N1'=N4)\n                                  (map/+ N1 D3 M3) M111+M122'=M133\n                                  (shift/+ N+1+N1=N4)\n    <- plus-left-cancels N+1+N1=N4 N+1+N1'=N4 nat`eq/ nat`eq/ N1=N1P\n    <- map/+-preserves-eq N1=N1P nat`eq/ eq/ M122=M122'\n    <- union-respects-eq (union/= M1+M2=M3 D1+D2=D3 nat`eq/) eq/ M122=M122' eq/\n                        M111+M122'=M133.\n\n- : shift-preserves-union-converse (union/< M1+M055=M3 N0+1+N4=N5)\n                                  (shift/+ N+1+N1=N4) (shift/+ N+1+N2=N5) _\n\t\t\t\t  (union/< M1+M055=M3 N0+1+N1=N2)\n\t\t\t\t  (shift/+ N+1+N1=N4)\n    <- plus-commutative N+1+N1=N4 N1+N+1=N4\n    <- plus-swap-succ-converse N1+N+1=N4 N1+1+N=N4\n    <- plus-associative-converse N1+N+1=N4 N0+1+N4=N5 N2' N0+1+N1=N2' N2'+N+1=N5\n    <- plus-commutative N+1+N2=N5 N2+N+1=N5\n    <- plus-right-cancels N2'+N+1=N5 N2+N+1=N5 nat`eq/ nat`eq/ N2'=N2\n    <- plus-respects-eq N0+1+N1=N2' nat`eq/ nat`eq/ N2'=N2 N0+1+N1=N2.\n                                  \n- : shift-preserves-union-converse (union/> M611+M2=M3 N6+1+N5=N4)\n                                  (shift/+ N+1+N1=N4) (shift/+ N+1+N2=N5) _\n                                  (union/> M611+M2=M3 N6+1+N2=N1)\n                                  (shift/+ N+1+N2=N5)\n    <- plus-commutative N+1+N2=N5 N2+N+1=N5\n    <- plus-swap-succ-converse N2+N+1=N5 N2+1+N=N5\n    <- plus-associative-converse N2+N+1=N5 N6+1+N5=N4 N1' N6+1+N2=N1' N1'+N+1=N4\n    <- plus-commutative N+1+N1=N4 N1+N+1=N4\n    <- plus-right-cancels N1'+N+1=N4 N1+N+1=N4 nat`eq/ nat`eq/ N1'=N1\n    <- plus-respects-eq N6+1+N2=N1' nat`eq/ nat`eq/ N1'=N1 N6+1+N2=N1.\n\n%worlds () (shift-preserves-union-converse _ _ _ _ _ _).\n%total { } (shift-preserves-union-converse _ _ _ _ _ _).\n\n\n\n%theorem union-commutative :\n\tforall* {M1} {M2} {M3}\n\tforall {A:union M1 M2 M3}\n\texists {AP:union M2 M1 M3}\n\ttrue.\n\n- : union-commutative union/L union/R.\n\n- : union-commutative union/R union/L.\n\n- : union-commutative (union/= M1+M2=M3 D1+D2=D3 nat`eq/) \n                     (union/= M2+M1=M3 D2+D1=D3 nat`eq/)\n    <- nat`union-commutative D1+D2=D3 D2+D1=D3\n    <- union-commutative M1+M2=M3 M2+M1=M3.\n\n- : union-commutative (union/< M1+MT=M3 N0+1+N1=N2) (union/> MT+M1=M3 N0+1+N1=N2)\n    <- union-commutative M1+MT=M3 MT+M1=M3.\n\n- : union-commutative (union/> MT+M2=M3 N3+1+N2=N1) (union/< M2+MT=M3 N3+1+N2=N1)\n    <- union-commutative MT+M2=M3 M2+MT=M3.\n\n%worlds () (union-commutative _ _).\n%total (A) (union-commutative A _).\n\n\n\n\n%theorem union-associative :\n\tforall* {M1} {M2} {M3} {M4} {M7}\n\tforall {A12:union M1 M2 M3} {A34:union M3 M4 M7}\n\texists {M6} {A24:union M2 M4 M6} {A16:union M1 M6 M7}\n\ttrue.\n\n%% a lemma\n\n%theorem union-associative-union/<-union/< :\n\tforall* {N1} {D1} {M1} {N2} {D2} {M2} {N0} {N5} {N4} {D4} {M4} {M6} {M7}\n\tforall {PLUS012:nat`plus (s N0) N1 N2}\n               {PLUS514:nat`plus (s N5) N1 N4}\n               {JOIN246:union (map/+ N0 D2 M2) (map/+ N5 D4 M4) M6}\n               {JOIN167:union M1 M6 M7}\n        exists {M} {JOIN24: union (map/+ N2 D2 M2) (map/+ N4 D4 M4) M}\n               {JOIN:union (map/+ N1 D1 M1) M (map/+ N1 D1 M7)}\n        true.\n               \n- : union-associative union/L A _ A union/L.\n\n- : union-associative A union/R _ union/R A.\n\n- : union-associative union/R A _ union/L A.\n\n- : union-associative (union/= M1+M2=M3 D1+D2=D3 nat`eq/)\n                    (union/= M3+M4=M7 D3+D4=D7 nat`eq/) (map/+ _ D6 M6)\n                    (union/= M2+M4=M6 D2+D4=D6 nat`eq/)\n\t\t    (union/= M1+M6=M7 D1+D6=D7 nat`eq/)\n    <- nat`union-associative D1+D2=D3 D3+D4=D7 D6 D2+D4=D6 D1+D6=D7\n    <- union-associative M1+M2=M3 M3+M4=M7 M6 M2+M4=M6 M1+M6=M7.\n\n- : union-associative (union/= M1+M2=M3 D1+D2=D3 nat`eq/)\n                    (union/< M3+M044=M7 N0+1+N3=N4) (map/+ _ _ M6) \n                    (union/< M2+M044=M6 N0+1+N3=N4) \n                    (union/= M1+M6=M7 D1+D2=D3 nat`eq/)\n    <- union-associative M1+M2=M3 M3+M044=M7 M6 M2+M044=M6 M1+M6=M7.\n\n- : union-associative (union/= M1+M2=M3 D1+D2=D3 nat`eq/)\n\t            (union/> M533+M4=M7 N5+1+N4=N3) (map/+ _ _ M6)\n                    (union/> M522+M4=M6 N5+1+N4=N3)\n                    (union/> M511+M6=M7 N5+1+N4=N3)\n    <- union-associative (union/= M1+M2=M3 D1+D2=D3 nat`eq/) M533+M4=M7\n                       M6 M522+M4=M6 M511+M6=M7.\n\n- : union-associative (union/< M1+M022=M3 N0+1+N1=N2)\n                     (union/= M3+M4=M7 D1+D4=D7 nat`eq/) (map/+ _ _ M6)\n                     (union/> M022+M3=M6 N0+1+N1=N2)\n                     (union/= M1+M6=M7 D1+D4=D7 nat`eq/)\n    <- union-associative M1+M022=M3 M3+M4=M7 M6 M022+M3=M6 M1+M6=M7.\n\n%% the hardest of all 11 cases!\n\n- : {M111+M=M117: union (map/+ N1 D1 M1) M (map/+ N1 D1 M7)}\n    {M3+M544=M7: union M3 (map/+ N5 D4 M4) M7}\n    {M1+M022=M3: union M1 (map/+ N0 D2 M2) M3}\n    {M1+M6=M7: union M1 M6 M7}\n    union-associative (union/< M1+M022=M3 N0+1+N1=N2)\n       \t\t     (union/< M3+M544=M7 N5+1+N1=N4) \n\t\t     M M222+M444=M M111+M=M117\n    <- union-associative M1+M022=M3 M3+M544=M7 M6 M022+M544=M6 M1+M6=M7\n    <- union-associative-union/<-union/< \n       \t\tN0+1+N1=N2 N5+1+N1=N4 M022+M544=M6 M1+M6=M7 \n       \t\tM M222+M444=M M111+M=M117.\n\n- : union-associative-union/<-union/< N+1+N1=N2 N+1+N1=N4\n                                   (union/= M2+M4=M6 D2+D4=D6 nat`eq/) \n                                   M1+M066=M7 (map/+ N2 D6 M6)\n                                   (union/= M2+M4=M6 D2+D4=D6 N2=N4)\n                                   (union/< M1+M066=M7 N+1+N1=N2)\n    <- nat`plus-deterministic N+1+N1=N2 N+1+N1=N4 nat`eq/ nat`eq/ N2=N4.\n\n- : union-associative-union/<-union/< N0+1+N1=N2 N5+1+N1=N4\n                                   (union/< M2+M744=M6 N7+1+N0=N5)\n                                   M1+M026=M7 (map/+ N2 D2 M6)\n     \t\t\t\t   (union/< M2+M744=M6 N7+1+N2=N4)\n                                   (union/< M1+M026=M7 N0+1+N1=N2)\n    <- nat`plus-swap-succ N5+1+N1=N4 N5+N1+1=N4\n    <- nat`plus-swap-succ N0+1+N1=N2 N0+N1+1=N2\n    <- nat`plus-associative* N7+1+N0=N5 N5+N1+1=N4 N0+N1+1=N2 N7+1+N2=N4.\n\n- : union-associative-union/<-union/< N0+1+N1=N2 N5+1+N1=N4\n                                   (union/> M722+M4=M6 N7+1+N5=N0)\n                                   M1+M546=M7 (map/+ N4 D4 M6)\n                                   (union/> M722+M4=M6 N7+1+N4=N2)\n                                   (union/< M1+M546=M7 N5+1+N1=N4)\n    <- nat`plus-swap-succ N0+1+N1=N2 N0+N1+1=N2\n    <- nat`plus-swap-succ N5+1+N1=N4 N5+N1+1=N4\n    <- nat`plus-associative* N7+1+N5=N0 N0+N1+1=N2 N5+N1+1=N4 N7+1+N4=N2.\n\n%% and now we return to the main theorem\n\n- : union-associative (union/< M1+M022=M3 N0+1+N1=N2)\n\t\t    (union/> M513+M4=M7 N5+1+N3=N1) (map/+ _ _ M6)\n                    (union/> M622+M4=M6 N6+1+N3=N2)\n                    (union/> M511+M6=M7 N5+1+N3=N1)\n    <- nat`plus-swap-succ N5+1+N3=N1 N5+N3+1=N1\n    <- nat`plus-associative-converse N5+N3+1=N1 N0+1+N1=N2 N6\n                                     N0+1+N5=N6 N6+N3+1=N2\n    <- nat`plus-swap-succ-converse N6+N3+1=N2 N6+1+N3=N2\n    <- union-associative (union/< M1+M022=M3 N0+1+N5=N6) M513+M4=M7 \n                       M6 M622+M4=M6 M511+M6=M7.\n\n- : union-associative (union/> M311+M2=M3 N3+1+N2=N1)\n                    (union/= M3+M4=M7 D2+D4=D7 nat`eq/) (map/+ _ _ M6)\n                    (union/= M2+M4=M6 D2+D4=D7 nat`eq/)\n                    (union/> M311+M6=M7 N3+1+N2=N1)\n    <- union-associative M311+M2=M3 M3+M4=M7 M6 M2+M4=M6 M311+M6=M7.\n\n- : union-associative (union/> M311+M2=M3 N3+1+N2=N1)\n                    (union/< M3+M044=M7 N0+1+N2=N4) (map/+ _ _ M6)\n                    (union/< M2+M044=M6 N0+1+N2=N4)\n                    (union/> M311+M6=M7 N3+1+N2=N1)\n    <- union-associative M311+M2=M3 M3+M044=M7 M6 M2+M044=M6 M311+M6=M7.\n\n- : union-associative (union/> M311+M2=M3 N3+1+N2=N1)\n                    (union/> M523+M4=M7 N5+1+N4=N2) (map/+ _ _ M6)\n\t\t    (union/> M522+M4=M6 N5+1+N4=N2)\n                    (union/> M711+M6=M7 N7+1+N4=N1)\n    <- nat`plus-swap-succ N5+1+N4=N2 N5+N4+1=N2\n    <- nat`plus-associative-converse N5+N4+1=N2 N3+1+N2=N1 \n                                     N7 N3+1+N5=N7 N7+N4+1=N1\n    <- nat`plus-swap-succ-converse N7+N4+1=N1 N7+1+N4=N1\n    <- union-associative (union/> M311+M2=M3 N3+1+N5=N7) M523+M4=M7\n                       M6 M522+M4=M6 M711+M6=M7.\n\n%worlds () (union-associative-union/<-union/< _ _ _ _ _ _ _).\n%total {} (union-associative-union/<-union/< _ _ _ _ _ _ _).\n\n%worlds () (union-associative _ _ _ _ _).\n%total (J) (union-associative _ J _ _ _).\n\n\n%theorem union-associative* :\n\tforall* {X1} {X2} {X12} {X3} {X23} {X123}\n        forall {OP12:union X1 X2 X12} {OP12-3:union X12 X3 X123} {OP23:union X2 X3 X23}\n        exists {OP1-23:union X1 X23 X123}\n        true.\n\n- : union-associative* X1+X2=X3 X3+X4=X7 X2+X4=X6 X1+X6=X7\n    <- union-associative X1+X2=X3 X3+X4=X7 Y6 X2+X4=Y6 X1+Y6=X7\n    <- union-deterministic X2+X4=Y6 X2+X4=X6 eq/ eq/ Y6=X6\n    <- union-respects-eq X1+Y6=X7 eq/ Y6=X6 eq/ X1+X6=X7.\n\n%worlds () (union-associative* _ _ _ _).\n%total {} (union-associative* _ _ _ _).\n\n\n%theorem union-associative-converse :\n\tforall* {X1} {X2} {X4} {X6} {X7}\n\tforall {OP24:union X2 X4 X6} {OP16:union X1 X6 X7}\n        exists {X3} {OP12:union X1 X2 X3} {OP34:union X3 X4 X7}\n        true.\n\n- : union-associative-converse X2+X4=X6 X1+X6=X7 _ X1+X2=X3 X3+X4=X7\n    <- union-commutative X2+X4=X6 X4+X2=X6\n    <- union-commutative X1+X6=X7 X6+X1=X7\n    <- union-associative X4+X2=X6 X6+X1=X7 _ X2+X1=X3 X4+X3=X7\n    <- union-commutative X2+X1=X3 X1+X2=X3\n    <- union-commutative X4+X3=X7 X3+X4=X7.\n\n%worlds () (union-associative-converse X2+X4=X6 X1+X6=X7 X3 X1+X2=X3 X3+X4=X7).\n%total {} (union-associative-converse _ _ _ _ _).\n\n\n%theorem union-associative-converse* :\n\tforall* {X1} {X2} {X3} {X4} {X6} {X7}\n\tforall {OP24:union X2 X4 X6} {OP16:union X1 X6 X7} {OP12:union X1 X2 X3} \n\texists {OP34:union X3 X4 X7}\n        true.\n\n- : union-associative-converse* X2+X4=X6 X1+X6=X7 X1+X2=X3 X3+X4=X7\n    <- union-associative-converse X2+X4=X6 X1+X6=X7 X3P X1+X2=X3P X3P+X4=X7\n    <- union-deterministic X1+X2=X3P X1+X2=X3 eq/ eq/ X3P=X3\n    <- union-respects-eq X3P+X4=X7 X3P=X3 eq/ eq/ X3+X4=X7.\n\n%worlds () (union-associative-converse* X2+X4=X6 X1+X6=X7 X1+X2=X3  X3+X4=X7).\n%total {} (union-associative-converse* _ _ _ _).\n\n%% The following two theorems are useful for reordering elements\n%% is a left-associative sequence of operations.\n\n%theorem union-assoc-commutative* :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X7}\n\tforall {OP1:union X1 X2 X3} {OP2:union X3 X4 X7}\n               {OP3:union X1 X4 X5} \n        exists {OP4:union X5 X2 X7}\n\ttrue.\n\n- : union-assoc-commutative* X1+X2=X3 X3+X4=X7 X1+X4=X5 X5+X2=X7\n    <- union-associative X1+X2=X3 X3+X4=X7 X6 X2+X4=X6 X1+X6=X7\n    <- union-commutative X2+X4=X6 X4+X2=X6\n    <- union-associative-converse* X4+X2=X6 X1+X6=X7 X1+X4=X5 X5+X2=X7.\n\n%worlds () (union-assoc-commutative* X1+X2=X3 X3+X4=X7 X1+X4=X5  X5+X2=X7).\n%total {} (union-assoc-commutative* _ _ _ _).\n\n\n%theorem union-assoc-commutative :\n\tforall* {X1} {X2} {X3} {X4} {X7}\n\tforall {OP1:union X1 X2 X3} {OP2:union X3 X4 X7}\n        exists {X5} {OP3:union X1 X4 X5} {OP4:union X5 X2 X7}\n\ttrue.\n\n- : union-assoc-commutative X1+X2=X3 X3+X4=X7 X5 X1+X4=X5 X5+X2=X7\n    <- union-associative X1+X2=X3 X3+X4=X7 X6 X2+X4=X6 X1+X6=X7\n    <- union-commutative X2+X4=X6 X4+X2=X6\n    <- union-associative-converse X4+X2=X6 X1+X6=X7 X5 X1+X4=X5 X5+X2=X7.\n\n%worlds () (union-assoc-commutative X1+X2=X3 X3+X4=X7  X5 X1+X4=X5 X5+X2=X7).\n%total {} (union-assoc-commutative _ _ _ _ _).\n\n%% The following theorem is a useful shortcut to\n%% re-associate (AB)(CD) to (AC)(BD):\n\n%theorem union-double-associative* :\n\tforall* {A} {B} {C} {D} {A+B} {C+D} {A+C} {B+D} {X}\n\tforall {AB:union A B A+B} {CD:union C D C+D} {ABCD:union A+B C+D X}\n\t       {AC:union A C A+C} {BD:union B D B+D} \n        exists {ACBD:union A+C B+D X}\n\ttrue.\n\n- : union-double-associative* X1+X2=X3 X4+X8=XC X3+XC=XF X1+X4=X5 X2+X8=XA X5+XA=XF\n    <- union-associative X1+X2=X3 X3+XC=XF XE X2+XC=XE X1+XE=XF\n    <- union-commutative X4+X8=XC X8+X4=XC\n    <- union-associative-converse* X8+X4=XC X2+XC=XE X2+X8=XA XA+X4=XE\n    <- union-commutative XA+X4=XE X4+XA=XE\n    <- union-associative-converse* X4+XA=XE X1+XE=XF X1+X4=X5 X5+XA=XF.\n\n%worlds () (union-double-associative* X1+X2=X3 X4+X8=XC X3+XC=XF X1+X4=X5 X2+X8=XA\n                             X5+XA=XF).\n%total {} (union-double-associative* _ _ _ _ _ _).\n\n\n%theorem union-double-associative :\n\tforall* {A} {B} {C} {D} {A+B} {C+D} {X}\n\tforall {AB:union A B A+B} {CD:union C D C+D} {ABCD:union A+B C+D X}\n\texists {A+C} {B+D} {AC:union A C A+C} {BD:union B D B+D} \n               {ACBD:union A+C B+D X}\n\ttrue.\n\n- : union-double-associative X1+X2=X3 X4+X8=XC X3+XC=XF X5 XA X1+X4=X5 X2+X8=XA X5+XA=XF\n    <- union-associative X1+X2=X3 X3+XC=XF XE X2+XC=XE X1+XE=XF\n    <- union-commutative X4+X8=XC X8+X4=XC\n    <- union-associative-converse X8+X4=XC X2+XC=XE XA X2+X8=XA XA+X4=XE\n    <- union-commutative XA+X4=XE X4+XA=XE\n    <- union-associative-converse X4+XA=XE X1+XE=XF X5 X1+X4=X5 X5+XA=XF.\n\n%worlds () (union-double-associative _ _ _ _ _ _ _ _).\n%total { } (union-double-associative _ _ _ _ _ _ _ _).\n\n%theorem lookup-implies-union :\n\tforall* {M} {N} {D}\n\tforall {L:lookup M N D}\n\texists {M-} {F:not-member M- N}\n\t       {A:union (map/+ N D map/0) M- M}\n\ttrue.\n\n- : lookup-implies-union (lookup/= nat`eq/) _\n                        (not-member/0) (union/R).\n\n- : lookup-implies-union (lookup/= nat`eq/) _\n                        (not-member/< N2>N1) \n                        (union/< union/L N0+1+N1=N2)\n    <- nat`plus-total N0+1+N1=N2\n    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1.\n\n- : lookup-implies-union (lookup/> L N0+1+N1=N2) _\n                        (not-member/> F N0+1+N1=N2)\n\t\t\t(union/> A N0+1+N1=N2)\n    <- lookup-implies-union  L _ F A.\n\n%worlds () (lookup-implies-union _ _ _ _).\n%total (L) (lookup-implies-union L _ _ _).\n\n\n%theorem union-joins-lookup :\n\tforall* {M1} {M2} {M3} {N} {D1} {D2}\n\tforall {L1:lookup M1 N D1} {L2:lookup M2 N D2}\n               {A:union M1 M2 M3}\n\texists {D3} {J:nat`union D1 D2 D3} {L3:lookup M3 N D3}\n\ttrue.\n\n- : union-joins-lookup (lookup/= nat`eq/) (lookup/= nat`eq/) A\n                           _ AD L3\n    <- union/=-inversion A nat`eq/ _ _ AD _ M=M133\n    <- eq-symmetric M=M133 M133=M\n    <- lookup-respects-eq (lookup/= nat`eq/) M133=M nat`eq/ nat`eq/ L3.\n\n- : union-joins-lookup (lookup/> L1 N0+1+N1=N2)\n                           (lookup/= nat`eq/) A _ AD L3P\n    <- union/<-inversion A N0+1+N1=N2 M3 M1+M022=M3 M=M113\n    <- union-joins-lookup L1 (lookup/= nat`eq/) M1+M022=M3 _ AD L3\n    <- eq-symmetric M=M113 M113=M\n    <- lookup-respects-eq (lookup/> L3 N0+1+N1=N2) M113=M  nat`eq/ nat`eq/ L3P.\n\n- : union-joins-lookup (lookup/= nat`eq/) \n                           (lookup/> L2 N3+1+N2=N1) A _ AD L3P\n    <- union/>-inversion A N3+1+N2=N1 M3 M311+M2=M3 M=M223\n    <- union-joins-lookup (lookup/= nat`eq/) L2 M311+M2=M3 _ AD L3\n    <- eq-symmetric M=M223 M223=M\n    <- lookup-respects-eq (lookup/> L3 N3+1+N2=N1) M223=M  nat`eq/ nat`eq/ L3P.\n\n- : union-joins-lookup (lookup/> L1P N4+1+N1=N)\n                           (lookup/> L2 N5+1+N2=N)\n                           (union/= M1+M2=M3 _ nat`eq/) _ AD\n                           (lookup/> L N5+1+N2=N)\n    <- plus-right-cancels N4+1+N1=N N5+1+N2=N nat`eq/ nat`eq/ N4+1=N5+1\n    <- succ-cancels N4+1=N5+1 N4=N5\n    <- lookup-respects-eq L1P eq/ N4=N5 nat`eq/ L1\n    <- union-joins-lookup L1 L2 M1+M2=M3 _ AD L.\n\n- : union-joins-lookup (lookup/> L1 N4+1+N1=N)\n                           (lookup/> L2 N5+1+N2=N)\n                           (union/< M1+M022=M3 N0+1+N1=N2) _ AD\n\t\t\t   (lookup/> L3 N4+1+N1=N)\n    <- plus-swap-succ N0+1+N1=N2 N0+N1+1=N2\n    <- plus-associative-converse N0+N1+1=N2 N5+1+N2=N N6 N5+1+N0=N6 N6+N1+1=N\n    <- plus-swap-succ N4+1+N1=N N4+N1+1=N\n    <- plus-right-cancels N6+N1+1=N N4+N1+1=N nat`eq/ nat`eq/ N6=N4\n    <- plus-respects-eq N5+1+N0=N6 nat`eq/ nat`eq/ N6=N4 N5+1+N0=N4\n    <- union-joins-lookup \n       L1 (lookup/> L2 N5+1+N0=N4) M1+M022=M3 _ AD L3.\n\n- : union-joins-lookup (lookup/> L1 N4+1+N1=N)\n                           (lookup/> L2 N5+1+N2=N)\n                           (union/> M311+M2=M3 N3+1+N2=N1) _ AD\n                           (lookup/> L3 N5+1+N2=N)\n    <- plus-swap-succ N3+1+N2=N1 N3+N2+1=N1\n    <- plus-associative-converse N3+N2+1=N1 N4+1+N1=N N6 N4+1+N3=N6 N6+N2+1=N\n    <- plus-swap-succ N5+1+N2=N N5+N2+1=N\n    <- plus-right-cancels N6+N2+1=N N5+N2+1=N nat`eq/ nat`eq/ N6=N5\n    <- plus-respects-eq N4+1+N3=N6 nat`eq/ nat`eq/ N6=N5 N4+1+N3=N5\n    <- union-joins-lookup\n       (lookup/> L1 N4+1+N3=N5) L2 M311+M2=M3 _ AD L3.\n\n%worlds () (union-joins-lookup _ _ _ _ _ _).\n%total (A) (union-joins-lookup _ _ A _ _ _).\n\n\n%theorem union-preserves-not-member* :\n\tforall* {M1} {M2} {M3} {N}\n\tforall {F1:not-member M1 N} {F2:not-member M2 N}\n               {A:union M1 M2 M3}\n\texists {F3:not-member M3 N}\n\ttrue.\n\t\n- : union-preserves-not-member* _ F union/L F.\n\n- : union-preserves-not-member* F _ union/R F.\n\n- : union-preserves-not-member* (not-member/< N<N1) (not-member/< _) (union/= _ _ _) \n                          (not-member/< N<N1).\n\n- : union-preserves-not-member* (not-member/< N<N1) (not-member/< _) (union/< _ _) \n                          (not-member/< N<N1).\n\n- : union-preserves-not-member* (not-member/< _) (not-member/< N<N2) (union/> _ _) \n                          (not-member/< N<N2).\n\n- : union-preserves-not-member* (not-member/< N<N1) (not-member/> F2 N4+1+N2=N) AX F3X\n    <- gt-implies-plus N<N1 N0 N0+1+N=N1\n    <- plus-swap-succ N4+1+N2=N N4+N2+1=N\n    <- plus-associative-converse N4+N2+1=N N0+1+N=N1 N3 N0+1+N4=N3 N3+N2+1=N1\n    <- plus-swap-succ-converse N3+N2+1=N1 N3+1+N2=N1\n    <- union/>-inversion AX N3+1+N2=N1 M3 A M=M223\n    <- plus-implies-gt N0+1+N4=N3 nat`eq/ N4<N3\n    <- union-preserves-not-member* (not-member/< N4<N3) F2 A F3\n    <- eq-symmetric M=M223 M223=M\n    <- not-member-respects-eq (not-member/> F3 N4+1+N2=N) M223=M nat`eq/ F3X.\n\n- : union-preserves-not-member* (not-member/> F1 N3+1+N1=N) (not-member/< N<N2) AX F3X\n    <- gt-implies-plus N<N2 N4 N4+1+N=N2\n    <- plus-swap-succ N3+1+N1=N N2+N1+1=N\n    <- plus-associative-converse N2+N1+1=N N4+1+N=N2 N0 N4+1+N2=N0 N0+N1+1=N2\n    <- plus-swap-succ-converse N0+N1+1=N2 N0+1+N1=N2\n    <- union/<-inversion AX N0+1+N1=N2 M3 A M=M113\n    <- plus-implies-gt N4+1+N2=N0 nat`eq/ N2<N0\n    <- union-preserves-not-member* F1 (not-member/< N2<N0) A F3\n    <- eq-symmetric M=M113 M113=M\n    <- not-member-respects-eq (not-member/> F3 N3+1+N1=N) M113=M nat`eq/ F3X.\n\n- : union-preserves-not-member* (not-member/> F1 N3+1+N1=N) (not-member/> F2P N4+1+N2=N) \n                          (union/= A _ N1=N2) (not-member/> F3 N3+1+N1=N)\n    <- plus-right-cancels N3+1+N1=N N4+1+N2=N N1=N2 nat`eq/ N3+1=N4+1\n    <- succ-cancels N3+1=N4+1 N3=N4\n    <- nat`eq-symmetric N3=N4 N4=N3\n    <- not-member-respects-eq F2P eq/ N4=N3 F2\n    <- union-preserves-not-member* F1 F2 A F3.\n\n- : union-preserves-not-member* (not-member/> F1 N3+1+N1=N) (not-member/> F2 N4+1+N2=N) \n                          (union/< A N0+1+N1=N2) (not-member/> F3 N3+1+N1=N)\n    <- plus-swap-succ N0+1+N1=N2 N0+N1+1=N2\n    <- plus-associative-converse N0+N1+1=N2 N4+1+N2=N N6 N4+1+N0=N6 N6+N1+1=N\n    <- plus-swap-succ N3+1+N1=N N3+N1+1=N\n    <- plus-right-cancels N6+N1+1=N N3+N1+1=N nat`eq/ nat`eq/ N6=N3\n    <- plus-respects-eq N4+1+N0=N6 nat`eq/ nat`eq/ N6=N3 N4+1+N0=N3\n    <- union-preserves-not-member* F1 (not-member/> F2 N4+1+N0=N3) A F3.\n\n- : union-preserves-not-member* (not-member/> F1 N3+1+N1=N) (not-member/> F2 N4+1+N2=N) \n                          (union/> A N0+1+N2=N1) (not-member/> F3 N4+1+N2=N)\n    <- plus-swap-succ N0+1+N2=N1 N0+N2+1=N1\n    <- plus-associative-converse N0+N2+1=N1 N3+1+N1=N N6 N3+1+N0=N6 N6+N2+1=N\n    <- plus-swap-succ N4+1+N2=N N4+N2+1=N\n    <- plus-right-cancels N6+N2+1=N N4+N2+1=N nat`eq/ nat`eq/ N6=N4\n    <- plus-respects-eq N3+1+N0=N6 nat`eq/ nat`eq/ N6=N4 N3+1+N0=N4\n    <- union-preserves-not-member* (not-member/> F1 N3+1+N0=N4) F2 A F3.\n\n%worlds () (union-preserves-not-member* _ _ _ _).\n%total (A) (union-preserves-not-member* _ _ A _).\n\n\n%theorem not-member-union-left-preserves-lookup* :\n\tforall* {M1} {M2} {M3} {N} {D}\n\tforall {F1:not-member M1 N} {L2:lookup M2 N D} \n               {A:union M1 M2 M3}\n\texists {L3:lookup M3 N D}\n\ttrue.\n\n- : not-member-union-left-preserves-lookup* _ L union/L L.\n\n- : not-member-union-left-preserves-lookup* (not-member/< N2<N1) (lookup/= nat`eq/) AX L3X\n    <- gt-implies-plus N2<N1 N3 N3+1+N2=N1\n    <- union/>-inversion AX N3+1+N2=N1 M3 A M=M223\n    <- eq-symmetric M=M223 M223=M\n    <- lookup-respects-eq (lookup/= nat`eq/) M223=M nat`eq/ nat`eq/ L3X.\n\n- : not-member-union-left-preserves-lookup* (not-member/< N<N1) (lookup/> L2 N4+1+N2=N)\n                                      AX L3X\n    <- gt-implies-plus N<N1 N0 N0+1+N=N1\n    <- plus-swap-succ N4+1+N2=N N4+N2+1=N\n    <- plus-associative-converse N4+N2+1=N N0+1+N=N1 N3 N0+1+N4=N3 N3+N2+1=N1\n    <- plus-swap-succ-converse N3+N2+1=N1 N3+1+N2=N1\n    <- union/>-inversion AX N3+1+N2=N1 M3 A M=M223\n    <- eq-symmetric M=M223 M223=M\n    <- plus-implies-gt N0+1+N4=N3 nat`eq/ N3>N4\n    <- not-member-union-left-preserves-lookup* (not-member/< N3>N4) L2 A L3\n    <- lookup-respects-eq (lookup/> L3 N4+1+N2=N) M223=M nat`eq/ nat`eq/ L3X.\n \n- : not-member-union-left-preserves-lookup* (not-member/> F1 N0+1+N1=N2) \n                                      (lookup/= nat`eq/) AX L3X\n    <- union/<-inversion AX N0+1+N1=N2 M3 A M=M113\n    <- eq-symmetric M=M113 M113=M\n    <- not-member-union-left-preserves-lookup* F1 (lookup/= nat`eq/) A L3\n    <- lookup-respects-eq (lookup/> L3 N0+1+N1=N2) M113=M nat`eq/ nat`eq/ L3X.\n\n- : not-member-union-left-preserves-lookup* (not-member/> F1P N4+1+N1=N)\n                                      (lookup/> L2 N5+1+N1=N)\n                                      (union/= A _ nat`eq/) \n                                      (lookup/> L3 N5+1+N1=N)\n    <- plus-right-cancels N4+1+N1=N N5+1+N1=N nat`eq/ nat`eq/ N4+1=N5+1\n    <- succ-cancels N4+1=N5+1 N4=N5\n    <- not-member-respects-eq F1P eq/ N4=N5 F1\n    <- not-member-union-left-preserves-lookup* F1 L2 A L3.\n\n- : not-member-union-left-preserves-lookup* (not-member/> F1 N4+1+N1=N)\n                                      (lookup/> L2 N5+1+N2=N)\n                                      (union/< A N0+1+N1=N2)\n                                      (lookup/> L3 N4+1+N1=N)\n    <- plus-swap-succ N0+1+N1=N2 N0+N1+1=N2\n    <- plus-associative-converse N0+N1+1=N2 N5+1+N2=N N3 N5+1+N0=N3 N3+N1+1=N\n    <- plus-swap-succ N4+1+N1=N N4+N1+1=N\n    <- plus-right-cancels N3+N1+1=N N4+N1+1=N nat`eq/ nat`eq/ N3=N4\n    <- plus-respects-eq N5+1+N0=N3 nat`eq/ nat`eq/ N3=N4 N5+1+N0=N4\n    <- not-member-union-left-preserves-lookup* F1 (lookup/> L2 N5+1+N0=N4) A L3.\n\n- : not-member-union-left-preserves-lookup* (not-member/> F1 N4+1+N1=N)\n                                      (lookup/> L2 N5+1+N2=N)\n                                      (union/> A N3+1+N2=N1)\n                                      (lookup/> L3 N5+1+N2=N)\n    <- plus-swap-succ N3+1+N2=N1 N3+N2+1=N1\n    <- plus-associative-converse N3+N2+1=N1 N4+1+N1=N N6 N4+1+N3=N6 N6+N2+1=N\n    <- plus-swap-succ N5+1+N2=N N5+N2+1=N\n    <- plus-right-cancels N6+N2+1=N N5+N2+1=N nat`eq/ nat`eq/ N6=N5\n    <- plus-respects-eq N4+1+N3=N6 nat`eq/ nat`eq/ N6=N5 N4+1+N3=N5\n    <- not-member-union-left-preserves-lookup* (not-member/> F1 N4+1+N3=N5) L2 A L3.\n\n%worlds () (not-member-union-left-preserves-lookup* _ _ _ _).\n%total (A) (not-member-union-left-preserves-lookup* _ _ A _).\n\n\n%theorem not-member-union-left-preserves-lookup-converse :\n\tforall* {M1} {M2} {M3} {N} {D}\n\tforall {F1:not-member M1 N} {L3:lookup M3 N D} \n               {A:union M1 M2 M3}\n\texists {L2:lookup M2 N D}\n\ttrue.\n\n%theorem not-member-union-left-preserves-lookup-converse/L :\n\tforall* {M1} {M2} {M3} {N} {D} {B}\n\tforall {F1:not-member M1 N} {L3:lookup M3 N D} \n               {A:union M1 M2 M3}\n               {D?:member? M2 N B}\n\texists {L2:lookup M2 N D}\n\ttrue.\n\n- : not-member-union-left-preserves-lookup-converse F1 L3 A L2\n    <- member?-total D?\n    <- not-member-union-left-preserves-lookup-converse/L F1 L3 A D? L2.\n\n- : not-member-union-left-preserves-lookup-converse/L \n     F1 L3 A (member?/in L2') L2\n    <- not-member-union-left-preserves-lookup* F1 L2' A L3'\n    <- lookup-deterministic L3' L3 eq/ nat`eq/ D'=D\n    <- lookup-respects-eq L2' eq/ nat`eq/ D'=D L2.\n\n- : not-member-union-left-preserves-lookup-converse/L\n     F1 L3 A (member?/out F2) L2\n    <- union-preserves-not-member* F1 F2 A F3\n    <- not-member-lookup-not-equal F3 L3 N<>N\n    <- nat`ne-anti-reflexive N<>N F\n    <- false-implies-lookup F L2.\n\n%worlds () (not-member-union-left-preserves-lookup-converse/L _ _ _ _ _).\n%total { } (not-member-union-left-preserves-lookup-converse/L _ _ _ _ _).\n\n%worlds () (not-member-union-left-preserves-lookup-converse _ _ _ _).\n%total { } (not-member-union-left-preserves-lookup-converse _ _ _ _).\n\n\n%theorem union-left-affects-lookup :\n\tforall* {M1} {N} {D2} {M2} {M3}\n\tforall {L:lookup M2 N D2}\n\t       {A:union M1 M2 M3}\n\texists {D3}\n               {N:lookup M3 N D3}\n\ttrue.\n\n%theorem union-left-affects-lookup/L :\n\tforall* {M1} {N} {D2} {M2} {M3} {B}\n\tforall {L:lookup M2 N D2}\n\t       {A:union M1 M2 M3}\n\t       {D:member? M1 N B}\n\texists {D3}\n               {N:lookup M3 N D3}\n\ttrue.\n\n- : union-left-affects-lookup/L L2 A (member?/in L1) _ L3\n    <- union-joins-lookup L1 L2 A _ _ L3.\n\n- : union-left-affects-lookup/L L2 A (member?/out F1) _ L3\n    <- not-member-union-left-preserves-lookup* F1 L2 A L3.\n\n%worlds () (union-left-affects-lookup/L _ _ _ _ _).\n%total { } (union-left-affects-lookup/L _ _ _ _ _).\n\n- : union-left-affects-lookup L2 A _ L3\n    <- member?-total D\n    <- union-left-affects-lookup/L L2 A D _ L3.\n\n%worlds () (union-left-affects-lookup _ _ _ _).\n%total { } (union-left-affects-lookup _ _ _ _).\n\n\n%theorem not-member-union-right-preserves-lookup* :\n\tforall* {M1} {M2} {M3} {N} {D}\n\tforall {L1:lookup M1 N D} {F2:not-member M2 N}\n               {A:union M1 M2 M3}\n\texists {L3:lookup M3 N D}\n\ttrue.\n\n- : not-member-union-right-preserves-lookup* L1 F2 A L3\n    <- union-commutative A Ac\n    <- not-member-union-left-preserves-lookup* F2 L1 Ac L3.\n\n%worlds () (not-member-union-right-preserves-lookup* _ _ _ _).\n%total { } (not-member-union-right-preserves-lookup* _ _ _ _).\n\n\n%theorem not-member-union-right-preserves-lookup-converse :\n\tforall* {M1} {M2} {M3} {N} {D}\n\tforall {L3:lookup M3 N D} {F2:not-member M2 N}\n               {A:union M1 M2 M3}\n\texists {L1:lookup M1 N D}\n\ttrue.\n\n%theorem not-member-union-right-preserves-lookup-converse/L :\n\tforall* {M1} {M2} {M3} {N} {D} {B}\n\tforall {L3:lookup M3 N D} {F2:not-member M2 N}\n               {A:union M1 M2 M3}\n\t       {D?:member? M1 N B}\n\texists {L1:lookup M1 N D}\n\ttrue.\n\n- : not-member-union-right-preserves-lookup-converse L3 F2 A L1\n    <- member?-total D?\n    <- not-member-union-right-preserves-lookup-converse/L L3 F2 A D? L1.\n\n- : not-member-union-right-preserves-lookup-converse/L \n     L3 F2 A (member?/in L1') L1\n    <- not-member-union-right-preserves-lookup* L1' F2 A L3'\n    <- lookup-deterministic L3' L3 eq/ nat`eq/ D'=D\n    <- lookup-respects-eq L1' eq/ nat`eq/ D'=D L1.\n\n- : not-member-union-right-preserves-lookup-converse/L\n     L3 F2 A (member?/out F1) L1\n    <- union-preserves-not-member* F1 F2 A F3\n    <- not-member-lookup-not-equal F3 L3 N<>N\n    <- nat`ne-anti-reflexive N<>N F\n    <- false-implies-lookup F L1.\n\n%worlds () (not-member-union-right-preserves-lookup-converse/L _ _ _ _ _).\n%total { } (not-member-union-right-preserves-lookup-converse/L _ _ _ _ _).\n\n%worlds () (not-member-union-right-preserves-lookup-converse _ _ _ _).\n%total { } (not-member-union-right-preserves-lookup-converse _ _ _ _).\n\n\n%theorem union-right-affects-lookup :\n\tforall* {M1} {N} {D1} {M2} {M3}\n\tforall {L:lookup M1 N D1}\n\t       {A:union M1 M2 M3}\n\texists {D3}\n               {N:lookup M3 N D3}\n\ttrue.\n\n%theorem union-right-affects-lookup/L :\n\tforall* {M1} {N} {D1} {M2} {M3} {B}\n\tforall {L:lookup M1 N D1}\n\t       {A:union M1 M2 M3}\n\t       {D:member? M2 N B}\n\texists {D3}\n               {N:lookup M3 N D3}\n\ttrue.\n\n- : union-right-affects-lookup/L L1 A (member?/in L2) _ L3\n    <- union-joins-lookup L1 L2 A _ _ L3.\n\n- : union-right-affects-lookup/L L1 A (member?/out F2) _ L3\n    <- not-member-union-right-preserves-lookup* L1 F2 A L3.\n\n%worlds () (union-right-affects-lookup/L _ _ _ _ _).\n%total { } (union-right-affects-lookup/L _ _ _ _ _).\n\n- : union-right-affects-lookup L1 A _ L3\n    <- member?-total D\n    <- union-right-affects-lookup/L L1 A D _ L3.\n\n%worlds () (union-right-affects-lookup _ _ _ _).\n%total { } (union-right-affects-lookup _ _ _ _).\n\n\n%theorem union-preserves-not-member-converse* :\n\tforall* {M1} {M2} {M3} {N}\n\tforall {F3:not-member M3 N}\n               {A:union M1 M2 M3}\n\texists {F1:not-member M1 N} {F2:not-member M2 N}\n\ttrue.\n\n%theorem union-preserves-not-member-converse/L :\n\tforall* {M1} {M2} {M3} {N} {B1} {B2}\n\tforall {F3:not-member M3 N}\n               {A:union M1 M2 M3}\n               {D1:member? M1 N B1}\n               {D2:member? M2 N B2}\n\texists {F1:not-member M1 N} {F2:not-member M2 N}\n\ttrue.\n\n- : union-preserves-not-member-converse* F3 A F1 F2\n    <- member?-total D1\n    <- member?-total D2\n    <- union-preserves-not-member-converse/L F3 A D1 D2 F1 F2.\n\n- : union-preserves-not-member-converse/L _ _\n     (member?/out F1) (member?/out F2) F1 F2.\n\n- : union-preserves-not-member-converse/L F3 A\n     (member?/out F1) (member?/in L2) F1 F2\n    <- not-member-union-left-preserves-lookup* F1 L2 A L3\n    <- not-member-lookup-not-equal F3 L3 N<>N\n    <- nat`ne-anti-reflexive N<>N F\n    <- false-implies-not-member F F2.\n\n- : union-preserves-not-member-converse/L F3 A\n     (member?/in L1) (member?/out F2) F1 F2\n    <- not-member-union-right-preserves-lookup* L1 F2 A L3\n    <- not-member-lookup-not-equal F3 L3 N<>N\n    <- nat`ne-anti-reflexive N<>N F\n    <- false-implies-not-member F F1.\n\n- : union-preserves-not-member-converse/L F3 A\n     (member?/in L1) (member?/in L2) F1 F2\n    <- union-joins-lookup L1 L2 A _ _ L3\n    <- not-member-lookup-not-equal F3 L3 N<>N\n    <- nat`ne-anti-reflexive N<>N F\n    <- false-implies-not-member F F1\n    <- false-implies-not-member F F2.\n\n%worlds () (union-preserves-not-member-converse/L _ _ _ _ _ _).\n%total { } (union-preserves-not-member-converse/L _ _ _ _ _ _).\n\n%worlds () (union-preserves-not-member-converse* _ _ _ _).\n%total { } (union-preserves-not-member-converse* _ _ _ _).\n\n\n%theorem disjoint-union-left-preserves-lookup* :\n\tforall* {M1} {M2} {M3} {N} {D}\n\tforall {L2:lookup M2 N D}\n               {X:disjoint M1 M2}\n               {A:union M1 M2 M3}\n\texists {L3:lookup M3 N D}\n\ttrue.\n\n%theorem disjoint-union-left-preserves-lookup*/L :\n\tforall* {M1} {M2} {M3} {N} {D} {B}\n\tforall {L2:lookup M2 N D}\n               {X:disjoint M1 M2}\n               {A:union M1 M2 M3}\n               {D?:member? M1 N B}\n\texists {L3:lookup M3 N D}\n\ttrue.\n\n- : disjoint-union-left-preserves-lookup* L2 X A L3\n    <- member?-total D?\n    <- disjoint-union-left-preserves-lookup*/L L2 X A D? L3.\n\n- : disjoint-union-left-preserves-lookup*/L L2 X A (member?/in L1) L3\n    <- disjoint-lookup-contradiction X L1 L2 F\n    <- false-implies-lookup F L3.\n\n- : disjoint-union-left-preserves-lookup*/L L2 X A (member?/out F1) L3\n    <- not-member-union-left-preserves-lookup* F1 L2 A L3.\n\n%worlds () (disjoint-union-left-preserves-lookup*/L _ _ _ _ _).\n%total { } (disjoint-union-left-preserves-lookup*/L _ _ _ _ _).\n\n%worlds () (disjoint-union-left-preserves-lookup* _ _ _ _).\n%total { } (disjoint-union-left-preserves-lookup* _ _ _ _).\n\n\n%theorem disjoint-union-right-preserves-lookup* :\n\tforall* {M1} {M2} {M3} {N} {D}\n\tforall {L1:lookup M1 N D}\n               {X:disjoint M1 M2}\n               {A:union M1 M2 M3}\n\texists {L3:lookup M3 N D}\n\ttrue.\n\n%theorem disjoint-union-right-preserves-lookup*/L :\n\tforall* {M1} {M2} {M3} {N} {D} {B}\n\tforall {L1:lookup M1 N D}\n               {X:disjoint M1 M2}\n               {A:union M1 M2 M3}\n               {D?:member? M2 N B}\n\texists {L3:lookup M3 N D}\n\ttrue.\n\n- : disjoint-union-right-preserves-lookup* L1 X A L3\n    <- member?-total D?\n    <- disjoint-union-right-preserves-lookup*/L L1 X A D? L3.\n\n- : disjoint-union-right-preserves-lookup*/L L1 X A (member?/in L2) L3\n    <- disjoint-lookup-contradiction X L1 L2 F\n    <- false-implies-lookup F L3.\n\n- : disjoint-union-right-preserves-lookup*/L L1 X A (member?/out F2) L3\n    <- not-member-union-right-preserves-lookup* L1 F2 A L3.\n\n%worlds () (disjoint-union-right-preserves-lookup*/L _ _ _ _ _).\n%total { } (disjoint-union-right-preserves-lookup*/L _ _ _ _ _).\n\n%worlds () (disjoint-union-right-preserves-lookup* _ _ _ _).\n%total { } (disjoint-union-right-preserves-lookup* _ _ _ _).\n\n\n\n%theorem union-implies-leq* :\n\tforall* {M1} {M2} {M3}\n\tforall {J:union M1 M2 M3}\n        exists {L:leq M1 M3}\n\ttrue.\n\n- : union-implies-leq* union/L leq/0.\n\n- : union-implies-leq* union/R M2=M2\n    <- leq-reflexive _ M2=M2.\n\n- : union-implies-leq* (union/= M1+M2=M3 D1+D2=D3 nat`eq/) \n                      (leq/= M1<=M3 D1<=D3 nat`eq/)\n    <- nat`union-implies-leq* D1+D2=D3 D1<=D3\n    <- union-implies-leq* M1+M2=M3 M1<=M3.\n\n- : union-implies-leq* (union/< M1+_=M3 _) (leq/= M1<=M3 D1<=D1 nat`eq/)\n    <- nat`leq-reflexive _ D1<=D1\n    <- union-implies-leq* M1+_=M3 M1<=M3.\t\n\n- : union-implies-leq* (union/> M311+M2=M3 P) (leq/> M311<=M3 P)\n    <- union-implies-leq* M311+M2=M3 M311<=M3.\n\n%worlds () (union-implies-leq* _ _).\n%total (J) (union-implies-leq* J _).\n\n\n%theorem union-implies-leq :\n\tforall* {M1} {M2} {M3}\n\tforall {A:union M1 M2 M3}\n        exists {L1:leq M1 M3} {L2:leq M2 M3}\n\ttrue.\n\n- : union-implies-leq M1*M2=M3 M1<=M3 M2<=M3\n    <- union-implies-leq* M1*M2=M3 M1<=M3\n    <- union-commutative M1*M2=M3 M2*M1=M3\n    <- union-implies-leq* M2*M1=M3 M2<=M3.\n\n%worlds () (union-implies-leq _ _ _).\n%total { } (union-implies-leq _ _ _).\n\n\n%theorem union-is-lub :\n\tforall* {M1} {M2} {M3} {M4}\n\tforall {J:union M1 M2 M3}\n\t       {L1:leq M1 M4} {L2:leq M2 M4}\n\texists {L3:leq M3 M4}\n\ttrue.\n\n- : union-is-lub union/L _ L L.\n\n- : union-is-lub union/R L _ L.\n\n- : union-is-lub (union/= M1+M2=M3 D1+D2=D3 nat`eq/)\n                (leq/= M1<=M4 D1<=D4 nat`eq/)\n                (leq/= M2<=M4 D2<=D4 nat`eq/)\n                (leq/= M3<=M4 D3<=D4 nat`eq/)\n    <- nat`union-is-lub D1+D2=D3 D1<=D4 D2<=D4 D3<=D4\n    <- union-is-lub M1+M2=M3 M1<=M4 M2<=M4 M3<=M4.\n\n- : union-is-lub (union/= _ _ nat`eq/) (leq/= _ _ nat`eq/) (leq/> _ N3+1+N=N) L\n    <- nat`plus-implies-gt N3+1+N=N nat`eq/ N>N\n    <- gt-anti-reflexive N>N F\n    <- false-implies-leq F L.\n\n- : union-is-lub (union/= _ _ nat`eq/) (leq/> _ N3+1+N=N) (leq/= _ _ nat`eq/) L\n    <- nat`plus-implies-gt N3+1+N=N nat`eq/ N>N\n    <- gt-anti-reflexive N>N F\n    <- false-implies-leq F L.\n\n- : union-is-lub (union/= M1+M2=M3 D1+D2=D3 nat`eq/)\n                (leq/> M511<=M4 N5+1+N4=N)\n                (leq/> M622<=M4 N6+1+N4=N)\n                (leq/> M633<=M4 N6+1+N4=N)\n    <- nat`plus-right-cancels N5+1+N4=N N6+1+N4=N nat`eq/ nat`eq/ N5+1=N6+1\n    <- nat`succ-cancels N5+1=N6+1 N5=N6\n    <- map/+-preserves-eq N5=N6 nat`eq/ eq/ M511=M611\n    <- leq-respects-eq M511<=M4 M511=M611 eq/ M611<=M4\n    <- union-is-lub (union/= M1+M2=M3 D1+D2=D3 nat`eq/) \n                   M611<=M4 M622<=M4 M633<=M4.\n\n- : union-is-lub (union/< _ N0+1+N=N) (leq/= _ _ nat`eq/) (leq/= _ _ nat`eq/) L\n    <- nat`plus-implies-gt N0+1+N=N nat`eq/ N>N\n    <- gt-anti-reflexive N>N F\n    <- false-implies-leq F L.\n\n- : union-is-lub (union/< M1+M022=M3 N0+1+N1=N2)\n                (leq/= M1<=M4 D1<=D4 nat`eq/)\n                (leq/> M622<=M4 N6+1+N1=N2)\n                (leq/= M3<=M4 D1<=D4 nat`eq/)\n    <- nat`plus-right-cancels N6+1+N1=N2 N0+1+N1=N2 nat`eq/ nat`eq/ N6+1=N0+1\n    <- succ-cancels N6+1=N0+1 N6=N0\n    <- map/+-preserves-eq N6=N0 nat`eq/ eq/ M622=M022\n    <- leq-respects-eq M622<=M4 M622=M022 eq/ M022<=M4\n    <- union-is-lub M1+M022=M3 M1<=M4 M022<=M4 M3<=M4.\n\n- : union-is-lub (union/< _ N0+1+N1=N2) (leq/> _ N3+1+N2=N1) (leq/= _ _ nat`eq/) L\n    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2\n    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1\n    <- nat`gt-anti-symmetric N1>N2 N2>N1 F\n    <- false-implies-leq F L.\n\n- : union-is-lub (union/< M1+M022=M3 N0+1+N1=N2)\n                (leq/> M511<=M4 N5+1+N4=N1)\n                (leq/> M622<=M4 N6+1+N4=N2)\n                (leq/> M513<=M4 N5+1+N4=N1)\n    <- nat`plus-swap-succ N5+1+N4=N1 N5+N4+1=N1\n    <- nat`plus-associative-converse N5+N4+1=N1 N0+1+N1=N2 \n                                     N6' N0+1+N5=N6' N6'+N4+1=N2\n    <- nat`plus-swap-succ-converse N6'+N4+1=N2 N6'+1+N4=N2\n    <- nat`plus-right-cancels N6'+1+N4=N2 N6+1+N4=N2 nat`eq/ nat`eq/ N6'+1=N6+1\n    <- nat`succ-cancels N6'+1=N6+1 N6'=N6\n    <- nat`plus-respects-eq N0+1+N5=N6' nat`eq/ nat`eq/ N6'=N6 N0+1+N5=N6\n    <- union-is-lub (union/< M1+M022=M3 N0+1+N5=N6) M511<=M4 M622<=M4 M513<=M4.\n\n- : union-is-lub (union/> _ N3+1+N=N) (leq/= _ _ nat`eq/) (leq/= _ _ nat`eq/) L\n    <- nat`plus-implies-gt N3+1+N=N nat`eq/ N>N\n    <- gt-anti-reflexive N>N F\n    <- false-implies-leq F L.\n\n- : union-is-lub (union/> _ N3+1+N2=N1) (leq/= _ _ nat`eq/) (leq/> _ N0+1+N1=N2) L\n    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2\n    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1\n    <- nat`gt-anti-symmetric N1>N2 N2>N1 F\n    <- false-implies-leq F L.\n\n- : union-is-lub (union/> M311+M2=M3 N3+1+N2=N1)\n                (leq/> M511<=M4 N5+1+N2=N1)\n                (leq/= M2<=M4 D2<=D4 nat`eq/)\n                (leq/= M3<=M4 D2<=D4 nat`eq/)\n    <- nat`plus-right-cancels N3+1+N2=N1 N5+1+N2=N1 nat`eq/ nat`eq/ N3+1=N5+1\n    <- nat`succ-cancels N3+1=N5+1 N3=N5\n    <- map/+-preserves-eq N3=N5 nat`eq/ eq/ M311=M511\n    <- union-respects-eq M311+M2=M3 M311=M511 eq/ eq/ M511+M2=M3\n    <- union-is-lub M511+M2=M3 M511<=M4 M2<=M4 M3<=M4.\n\n- : union-is-lub (union/> M311+M2=M3 N3+1+N2=N1)\n                (leq/> M511<=M4 N5+1+N4=N1)\n                (leq/> M622<=M4 N6+1+N4=N2)\n                (leq/> M623<=M4 N6+1+N4=N2)\n    <- nat`plus-swap-succ N6+1+N4=N2 N6+N4+1=N2\n    <- nat`plus-associative-converse N6+N4+1=N2 N3+1+N2=N1 \n                                     N5' N3+1+N6=N5' N5'+N4+1=N1\n    <- nat`plus-swap-succ N5+1+N4=N1 N5+N4+1=N1\n    <- nat`plus-right-cancels N5'+N4+1=N1 N5+N4+1=N1 nat`eq/ nat`eq/ N5'=N5\n    <- nat`plus-respects-eq N3+1+N6=N5' nat`eq/ nat`eq/ N5'=N5 N3+1+N6=N5\n    <- union-is-lub (union/> M311+M2=M3 N3+1+N6=N5) M511<=M4 M622<=M4 M623<=M4.\n\n%worlds () (union-is-lub _ _ _ _).\n%total (L) (union-is-lub _ L _ _).\n\n\n%theorem union-idempotent :\n\tforall* {S}\n\texists {J:union S S S}\n\ttrue.\n\n- : union-idempotent S+S=S\n    <- union-total S+S=S'\n    <- union-implies-leq* S+S=S' S<=S'\n    <- leq-reflexive _ S<=S\n    <- union-is-lub S+S=S' S<=S S<=S S'<=S\n    <- leq-anti-symmetric S'<=S S<=S' S'=S\n    <- union-respects-eq S+S=S' eq/ eq/ S'=S S+S=S.\n\n%worlds () (union-idempotent _).\n%total { } (union-idempotent _).\n\n\n%theorem leq-implies-union :\n\tforall* {M1} {M2}\n\tforall {L:leq M1 M2}\n\texists {J:union M1 M2 M2}\n\ttrue.\n\n- : leq-implies-union M1<=M2 M1+M2=M2\n    <- union-total M1+M2=M3\n    <- leq-reflexive _ M2<=M2\n    <- union-is-lub M1+M2=M3 M1<=M2 M2<=M2 M3<=M2\n    <- union-implies-leq M1+M2=M3 _ M2<=M3\n    <- leq-anti-symmetric M3<=M2 M2<=M3 M3=M2\n    <- union-respects-eq M1+M2=M3 eq/ eq/ M3=M2 M1+M2=M2.\n\n%worlds () (leq-implies-union _ _).\n%total { } (leq-implies-union _ _).\n\n\n%theorem disjoint-leq-implies-union-leq* :\n\tforall* {C1} {C2} {C} {C3}\n\tforall\t{D:disjoint C1 C2}\n\t\t{L1:leq C1 C}\n\t\t{L2:leq C2 C}\n\t\t{J:union C1 C2 C3}\n\texists\t{L3:leq C3 C}\n\ttrue.\n\n- : disjoint-leq-implies-union-leq* disjoint/L _ C2<=C Z+C2=C3 C3<=C\n    <- union-deterministic union/L Z+C2=C3 eq/ eq/ C2=C3\n    <- leq-respects-eq C2<=C C2=C3 eq/ C3<=C.\n\n- : disjoint-leq-implies-union-leq* disjoint/R C1<=C _ C1+0=C3 C3<=C\n    <- union-deterministic union/R C1+0=C3 eq/ eq/ C1=C3\n    <- leq-respects-eq C1<=C C1=C3 eq/ C3<=C.\n\n- : disjoint-leq-implies-union-leq* \n\t(disjoint/< C1^C022 P) \n\t(leq/= C1<=C4 D1<=D4 nat`eq/) \n\tC222<=C444 C111+C222=C333 C333<=C444\n    <- union/<-inversion C111+C222=C333 P _ C1+C022=C5 C333=C115\n    <- leq/>-inversion C222<=C444 P C022<=C4\n    <- disjoint-leq-implies-union-leq* \n\tC1^C022 C1<=C4 C022<=C4 C1+C022=C5 C5<=C4\n    <- eq-symmetric C333=C115 C115=C333\n    <- leq-respects-eq \n\t(leq/= C5<=C4 D1<=D4 nat`eq/) C115=C333 eq/ C333<=C444.\n\n- : disjoint-leq-implies-union-leq* (disjoint/< C1^C022 N0+1+N1=N2) (leq/> C611<=C4 N6+1+N4=N1) C222<=C444 C111+C222=C333 C333<=C444\n    <- union/<-inversion C111+C222=C333 N0+1+N1=N2 _ C1+C022=C5 C333=C115\n    <- plus-swap-succ N6+1+N4=N1 N6+N4+1=N1\n    <- plus-associative-converse \n\tN6+N4+1=N1 N0+1+N1=N2 N7 N0+1+N6=N7 N7+N4+1=N2\n    <- plus-swap-succ-converse N7+N4+1=N2 N7+1+N4=N2\n    <- leq/>-inversion C222<=C444 N7+1+N4=N2 C722<=C4\n    <- disjoint-leq-implies-union-leq* \n\t(disjoint/< C1^C022 N0+1+N6=N7) \n\tC611<=C4 C722<=C4 \n\t(union/< C1+C022=C5 N0+1+N6=N7) C615<=C4\n    <- eq-symmetric C333=C115 C115=C333\n    <- leq-respects-eq \n\t(leq/> C615<=C4 N6+1+N4=N1) C115=C333 eq/ C333<=C444.\n\n- : disjoint-leq-implies-union-leq* \n\t(disjoint/> C011^C2 P) \n\tC111<=C444 (leq/= C2<=C4 D2<=D4 nat`eq/) \n\tC111+C222=C333 C333<=C444\n    <- union/>-inversion C111+C222=C333 P _ C011+C2=C5 C333=C225\n    <- leq/>-inversion C111<=C444 P C011<=C4\n    <- disjoint-leq-implies-union-leq* \n\tC011^C2 C011<=C4 C2<=C4 C011+C2=C5 C5<=C4\n    <- eq-symmetric C333=C225 C225=C333\n    <- leq-respects-eq \n\t(leq/= C5<=C4 D2<=D4 nat`eq/) C225=C333 eq/ C333<=C444.\n\n- : disjoint-leq-implies-union-leq* \n\t(disjoint/> C011^C2 N0+1+N2=N1) \n\tC111<=C444 (leq/> C622<=C4 N6+1+N4=N2)\n\tC111+C222=C333 C333<=C444\n    <- union/>-inversion C111+C222=C333 N0+1+N2=N1 _ C011+C2=C5 C333=C225\n    <- plus-swap-succ N6+1+N4=N2 N6+N4+1=N2\n    <- plus-associative-converse \n\tN6+N4+1=N2 N0+1+N2=N1 N7 N0+1+N6=N7 N7+N4+1=N1\n    <- plus-swap-succ-converse N7+N4+1=N1 N7+1+N4=N1\n    <- leq/>-inversion C111<=C444 N7+1+N4=N1 C711<=C4\n    <- disjoint-leq-implies-union-leq* \n\t(disjoint/> C011^C2 N0+1+N6=N7) \n\tC711<=C4 C622<=C4 \n\t(union/> C011+C2=C5 N0+1+N6=N7) C625<=C4\n    <- eq-symmetric C333=C225 C225=C333\n    <- leq-respects-eq \n\t(leq/> C625<=C4 N6+1+N4=N2) C225=C333 eq/ C333<=C444.\n\n%worlds () (disjoint-leq-implies-union-leq* _ _ _ _ _).\n%total (L) (disjoint-leq-implies-union-leq* _ L _ _ _).\n\n\n%theorem union-left-preserves-leq* :\n\tforall* {M1} {M2} {M3} {M4} {M5}\n\tforall {L1:leq M2 M4}\n               {J:union M1 M2 M3} {JP:union M1 M4 M5}\n\texists {L3:leq M3 M5}\n\ttrue.\n\n- : union-left-preserves-leq* L union/L union/L L.\n\n- : union-left-preserves-leq* _ union/L union/R leq/0.\n\n- : union-left-preserves-leq* leq/0 union/R M1+M4=M5 M1<=M5\n    <- union-implies-leq* M1+M4=M5 M1<=M5.\n\n- : union-left-preserves-leq* (leq/= M2<=M4 D2<=D4 nat`eq/)\n                             (union/= M1+M2=M3 D1+D2=D3 nat`eq/)\n                             M111+M144=M M133<=M\n    <- union/=-inversion M111+M144=M nat`eq/ D5 M5 D1+D4=D5 M1+M4=M5 M=M155\n    <- eq-symmetric M=M155 M155=M\n    <- meta-eq (map/+ N1 D5 M5) M M155=M\n    <- nat`union-left-preserves-leq* D2<=D4 D1+D2=D3 D1+D4=D5 D3<=D5\n    <- union-left-preserves-leq* M2<=M4 M1+M2=M3 M1+M4=M5 M3<=M5\n    <- leq-respects-eq (leq/= M3<=M5 D3<=D5 nat`eq/) eq/ M155=M M133<=M.\n\n- : {M1+M044=M5:union M1 (map/+ N0 D4 M4) M5}\n    {M115=M: eq (map/+ N1 D1 M5) M}\n    union-left-preserves-leq* (leq/= M2<=M4 D2<=D4 nat`eq/)\n                             (union/< M1+M022=M3 N0+1+N1=N2)\n                             M111+M244=M M113<=M\n    <- union/<-inversion M111+M244=M N0+1+N1=N2 M5 M1+M044=M5 M=M115\n    <- eq-symmetric M=M115 M115=M\n    <- meta-eq (map/+ N1 D1 M5) M M115=M\n    <- union-left-preserves-leq* (leq/= M2<=M4 D2<=D4 nat`eq/) \n                                M1+M022=M3 M1+M044=M5 M3<=M5\n    <- nat`leq-reflexive _ D1<=D1\n    <- leq-respects-eq (leq/= M3<=M5 D1<=D1 nat`eq/) eq/ M115=M M113<=M.\n\n- : union-left-preserves-leq* (leq/= M2<=M4 D2<=D4 nat`eq/)\n                             (union/> M311+M2=M3 N3+1+N2=N1)\n                             M111+M244=M M223<=M\n    <- union/>-inversion M111+M244=M N3+1+N2=N1 M5 M311+M4=M5 M=M245\n    <- eq-symmetric M=M245 M245=M\n    <- meta-eq (map/+ N2 D4 M5) M M245=M\n    <- union-left-preserves-leq* M2<=M4 M311+M2=M3 M311+M4=M5 M3<=M5\n    <- leq-respects-eq (leq/= M3<=M5 D2<=D4 nat`eq/) eq/ M245=M M223<=M.\n\n- : union-left-preserves-leq* (leq/> M622<=M4 N6+1+N4=N2)\n                             (union/= M1+M2=M3 D1+D2=D3 nat`eq/)   % N1=N2\n                             M211+M444=M M233<=M\n    <- union/>-inversion M211+M444=M N6+1+N4=N2 M5 M611+M4=M5 M=M445\n    <- eq-symmetric M=M445 M445=M\n    <- meta-eq (map/+ N4 D4 M5) M M445=M\n    <- union-left-preserves-leq* M622<=M4 (union/= M1+M2=M3 D1+D2=D3 nat`eq/)\n                                M611+M4=M5 M633<=M5\n    <- leq-respects-eq (leq/> M633<=M5 N6+1+N4=N2) eq/ M445=M M233<=M.\n\n- : union-left-preserves-leq* (leq/> M622<=M4 N6+1+N4=N2)\n                             (union/< M1+M022=M3 N0+1+N4=N2)\n                             (union/= M1+M4=M5 D1+D4=D5 nat`eq/)\n                             (leq/= M3<=M5 D1<=D5 nat`eq/)\n    <- nat`plus-right-cancels N6+1+N4=N2 N0+1+N4=N2 nat`eq/ nat`eq/ N6+1=N0+1\n    <- nat`succ-cancels N6+1=N0+1 N6=N0\n    <- map/+-preserves-eq N6=N0 nat`eq/ eq/ M622=M022\n    <- leq-respects-eq M622<=M4 M622=M022 eq/ M022<=M4\n    <- union-left-preserves-leq* M022<=M4 M1+M022=M3 M1+M4=M5 M3<=M5\n    <- nat`union-implies-leq* D1+D4=D5 D1<=D5.\n\n- : union-left-preserves-leq* (leq/> M622<=M4 N6+1+N4=N2)\n                             (union/< M1+M022=M3 N0+1+N1=N2)\n                             (union/< M1+M544=M5 N5+1+N1=N4)\n                             (leq/= M3<=M5 D1<=D1 nat`eq/)\n    <- nat`plus-swap-succ N5+1+N1=N4 N5+N1+1=N4\n    <- nat`plus-associative-converse N5+N1+1=N4 N6+1+N4=N2 \n                                     N0' N6+1+N5=N0' N0'+N1+1=N2\n    <- nat`plus-swap-succ N0+1+N1=N2 N0+N1+1=N2\n    <- nat`plus-right-cancels N0'+N1+1=N2 N0+N1+1=N2 nat`eq/ nat`eq/ N0'=N0\n    <- nat`plus-respects-eq N6+1+N5=N0' nat`eq/ nat`eq/ N0'=N0 N6+1+N5=N0\n    <- union-left-preserves-leq* (leq/> M622<=M4 N6+1+N5=N0) \n                                M1+M022=M3 M1+M544=M5 M3<=M5\n    <- nat`leq-reflexive _ D1<=D1.\n       \n\n% for some reason, twelf needs a lot of help inferring types here:\n- : union-left-preserves-leq* ((leq/> M622<=M4 N6+1+N4=N2):leq (map/+ N2 D2 M2) (map/+ N4 D4 M4))\n                             (union/< M1+M022=M3 N0+1+N1=N2)\n                             (union/> M511+M4=M5 N5+1+N4=N1)\n                             (leq/> M513<=M5 N5+1+N4=N1)\n    <- nat`plus-swap-succ N5+1+N4=N1 N5+N4+1=N1\n    <- nat`plus-associative-converse N5+N4+1=N1 N0+1+N1=N2 \n                                     N6' N0+1+N5=N6' N6'+N4+1=N2\n    <- nat`plus-swap-succ N6+1+N4=N2 N6+N4+1=N2\n    <- nat`plus-right-cancels N6'+N4+1=N2 N6+N4+1=N2 nat`eq/ nat`eq/ N6'=N6\n    <- nat`plus-respects-eq N0+1+N5=N6' nat`eq/ nat`eq/ N6'=N6 N0+1+N5=N6\n    <- union-left-preserves-leq* M622<=M4 \n       ((union/< M1+M022=M3 N0+1+N5=N6):union (map/+ N5 D1 M1) (map/+ N6 D2 M2)\n                                            (map/+ N5 D1 M3))\n                                M511+M4=M5 M513<=M5.\n\n- : union-left-preserves-leq* (leq/> M622<=M4 N6+1+N4=N2)\n                             (union/> M311+M2=M3 N3+1+N2=N1) \n                             M111+M444=M M223<=M\n    <- nat`plus-swap-succ N6+1+N4=N2 N6+N4+1=N2\n    <- nat`plus-associative-converse N6+N4+1=N2 N3+1+N2=N1 \n                                     N5 N3+1+N6=N5 N5+N4+1=N1\n    <- nat`plus-swap-succ-converse N5+N4+1=N1 N5+1+N4=N1 \n    <- union/>-inversion M111+M444=M N5+1+N4=N1 M5 M511+M4=M5 M=M445\n    <- eq-symmetric M=M445 M445=M\n    <- meta-eq _ _ M445=M\n    <- union-left-preserves-leq* M622<=M4 (union/> M311+M2=M3 N3+1+N6=N5)\n                                M511+M4=M5 M623<=M5\n    <- leq-respects-eq (leq/> M623<=M5 N6+1+N4=N2) eq/ M445=M M223<=M.\n  \n%worlds () (union-left-preserves-leq* _ _ _ _).\n%total (J) (union-left-preserves-leq* _ _ J _).\n\n\n\n%theorem union-right-preserves-leq* :\n\tforall* {X1} {X2} {X3} {X4} {X5}\n\tforall {G1:leq X1 X2} {O1:union X1 X3 X4} {O2:union X2 X3 X5}\n\texists {G2:leq X4 X5}\n\ttrue.\n\n- : union-right-preserves-leq* X1<=X2 X1+X3=X4 X2+X3=X5 X4<=X5\n    <- union-commutative X1+X3=X4 X3+X1=X4\n    <- union-commutative X2+X3=X5 X3+X2=X5\n    <- union-left-preserves-leq* X1<=X2 X3+X1=X4 X3+X2=X5 X4<=X5.\n\n%worlds () (union-right-preserves-leq* X1<=X2 X1+X3=X4 X2+X3=X5  X4<=X5).\n%total {} (union-right-preserves-leq* _ _ _ _).\n\n\n%%%% Map ``multiplication''\n\n\n\n%%% Definition of intersection\n\n\nintersection : map -> map -> map -> type.\n\n\nintersection/L : intersection map/0 M map/0.\n\nintersection/R : intersection M map/0 map/0.\n\nintersection/= : intersection (map/+ N1 D1 M1) (map/+ N2 D2 M2) (map/+ N1 D3 M3)\n    <- nat`eq N1 N2\n    <- nat`intersection D1 D2 D3\n    <- intersection M1 M2 M3.\n\nintersection/< : intersection (map/+ N1 D1 M1) (map/+ N2 D2 M2) S1M3\n    <- nat`plus (s N0) N1 N2\n    <- intersection M1 (map/+ N0 D2 M2) M3\n    <- shift N1 M3 S1M3.\n\nintersection/> : intersection (map/+ N1 D1 M1) (map/+ N2 D2 M2) S2M3\n    <- nat`plus (s N3) N2 N1\n    <- intersection (map/+ N3 D1 M1) M2 M3\n    <- shift N2 M3 S2M3.\n\n\n\n%%% Theorems about intersection\n\n\n%theorem false-implies-intersection :\n\tforall* {M1} {M2} {M3}\n\tforall {F:void}\n\texists {D:intersection M1 M2 M3}\n\ttrue.\n\n%worlds () (false-implies-intersection _ _).\n%total {} (false-implies-intersection _ _).\n\n\n%theorem intersection-respects-eq :\n\tforall* {M1} {M2} {M3} {M1P} {M2P} {M3P}\n\tforall {A:intersection M1 M2 M3} {E1:eq M1 M1P} {E2:eq M2 M2P} {E3:eq M3 M3P}\n\texists {AP:intersection M1P M2P M3P}\n\ttrue.\n\n- : intersection-respects-eq A eq/ eq/ eq/ A.\n\n%worlds () (intersection-respects-eq _ _ _ _ _).\n%total {} (intersection-respects-eq _ _ _ _ _).\n%reduces A = AP (intersection-respects-eq A _ _ _ AP).\n\n\n%% Inversion lemmas for intersection\n\n\n%theorem intersection/L-inversion :\n\tforall* {M1} {M2} {M3}\n\tforall {A:intersection M1 M2 M3} {E1:eq map/0 M1}\n        exists {E3:eq map/0 M3}\n\ttrue.\n\n- : intersection/L-inversion intersection/L eq/ eq/.\n\n- : intersection/L-inversion intersection/R eq/ eq/.\n\n%worlds () (intersection/L-inversion _ _ _).\n%total { } (intersection/L-inversion _ _ _).\n\n\n%theorem intersection/R-inversion :\n\tforall* {M1} {M2} {M3}\n\tforall {A:intersection M1 M2 M3} {E1:eq map/0 M2}\n        exists {E3:eq map/0 M3}\n\ttrue.\n\n- : intersection/R-inversion intersection/L eq/ eq/.\n\n- : intersection/R-inversion intersection/R eq/ eq/.\n\n%worlds () (intersection/R-inversion _ _ _).\n%total { } (intersection/R-inversion _ _ _).\n\n\n%theorem intersection/=-inversion :\n\tforall* {N1} {D1} {M1} {N2} {D2} {M2} {M} \n\tforall {A:intersection (map/+ N1 D1 M1) (map/+ N2 D2 M2) M}\n\t       {G:nat`eq N1 N2}\n\texists {D3} {M3} \n\t       {D:nat`intersection D1 D2 D3}\n               {AP:intersection M1 M2 M3}\n               {E:eq (map/+ N1 D3 M3) M}\n\ttrue.\n\n- : intersection/=-inversion (intersection/= MM DD nat`eq/) _ _ _ DD MM eq/.\n\n- : intersection/=-inversion (intersection/< S A' N0+1+N=N) nat`eq/ \n                     D2 M3 DA MA ME\n    <- nat`plus-implies-gt N0+1+N=N nat`eq/ N>N\n    <- nat`gt-anti-reflexive N>N F\n    <- nat`false-implies-intersection F DA\n    <- false-implies-eq F (M022=M2:eq (map/+ N0 D2 M2) M2)\n    <- intersection-respects-eq A' eq/ M022=M2 eq/ MA\n    <- false-implies-eq F ME.\n\n- : intersection/=-inversion (intersection/> S (AP:intersection (map/+ _ D1 M1) M2 _) N3+1+N=N) nat`eq/\n                     D1 M3 DA MA ME\n    <- nat`plus-implies-gt N3+1+N=N nat`eq/ N>N\n    <- nat`gt-anti-reflexive N>N F\n    <- nat`false-implies-intersection F DA\n    <- false-implies-eq F (M311=M1:eq (map/+ N3 D1 M1) M1)\n    <- intersection-respects-eq AP M311=M1 eq/ eq/ MA\n    <- false-implies-eq F ME.\n\n%worlds () (intersection/=-inversion _ _ _ _ _ _ _).\n%total {} (intersection/=-inversion _ _ _ _ _ _ _).\n%reduces AP < A (intersection/=-inversion A _ _ _ _ AP _).\n\n\n%theorem intersection/<-inversion :\n\tforall* {N1} {D1} {M1} {N2} {D2} {M2} {S1M3} {N0}\n\tforall {A:intersection (map/+ N1 D1 M1) (map/+ N2 D2 M2) S1M3}\n               {P:plus (s N0) N1 N2} \t       \n\texists {M3} {AP:intersection M1 (map/+ N0 D2 M2) M3}\n               {S:shift N1 M3 S1M3}\n\ttrue.\n\n- : intersection/<-inversion (intersection/< S A P) P' _ A' S\n    <- nat`plus-right-cancels P P' nat`eq/ nat`eq/ N0+1=N0'+1\n    <- succ-cancels N0+1=N0'+1 N0=N0P\n    <- map/+-preserves-eq N0=N0P nat`eq/ eq/ M022=M022'\n    <- intersection-respects-eq A eq/ M022=M022' eq/ A'.\n\n- : intersection/<-inversion (intersection/= A' _ nat`eq/) N0+1+N=N map/0 A S\n    <- nat`plus-implies-gt N0+1+N=N nat`eq/ N>N\n    <- gt-anti-reflexive N>N F\n    <- false-implies-eq F M2=M022\n    <- false-implies-eq F M3=M333\n    <- intersection-respects-eq A' eq/ M2=M022 M3=M333 A\n    <- false-implies-shift F S.\n\n- : intersection/<-inversion (intersection/> S A' N3+1+N2=N1) N0+1+N1=N2 _ A S'\n    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2\n    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1\n    <- nat`gt-anti-symmetric N1>N2 N2>N1 F\n    <- false-implies-eq F M311=M1\n    <- false-implies-eq F M2=M022\n    <- intersection-respects-eq A' M311=M1 M2=M022 eq/ A\n    <- false-implies-shift F S'.\n\n%worlds () (intersection/<-inversion _ _ _ _ _).\n%total {}  (intersection/<-inversion _ _ _ _ _).\n%reduces AP < A (intersection/<-inversion A _ _ AP _).\n\n\n%theorem intersection/>-inversion :\n\tforall* {N1} {D1} {M1} {N2} {D2} {M2} {N3} {S2M3} \n\tforall {A:intersection (map/+ N1 D1 M1) (map/+ N2 D2 M2) S2M3}\n\t       {P:plus (s N3) N2 N1}\n\texists {M3} {AP:intersection (map/+ N3 D1 M1) M2 M3}\n               {S:shift N2 M3 S2M3}\n\ttrue.\n\n- : intersection/>-inversion (intersection/> S A P) P' _ A' S\n    <- nat`plus-right-cancels P P' nat`eq/ nat`eq/ N3+1=N3'+1\n    <- succ-cancels N3+1=N3'+1 N3=N3P\n    <- map/+-preserves-eq N3=N3P nat`eq/ eq/ M311=M311'\n    <- intersection-respects-eq A M311=M311' eq/ eq/ A'.\n\n- : intersection/>-inversion (intersection/= A' _ nat`eq/) N3+1+N=N map/0 A S\n    <- nat`plus-implies-gt N3+1+N=N nat`eq/ N>N\n    <- gt-anti-reflexive N>N F\n    <- false-implies-eq F M1=M311\n    <- false-implies-eq F M3=M333\n    <- intersection-respects-eq A' M1=M311 eq/ M3=M333 A\n    <- false-implies-shift F S.\n\n- : intersection/>-inversion (intersection/< S A' N0+1+N1=N2) N3+1+N2=N1 _ A S'\n    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2\n    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1\n    <- nat`gt-anti-symmetric N1>N2 N2>N1 F\n    <- false-implies-eq F M1=M311\n    <- false-implies-eq F M022=M2\n    <- intersection-respects-eq A' M1=M311 M022=M2 eq/ A\n    <- false-implies-shift F S'.\n\n%worlds () (intersection/>-inversion _ _ _ _ _).\n%total { } (intersection/>-inversion _ _ _ _ _).\n%reduces AP < A (intersection/>-inversion A _ _ AP _).\n\n\n%theorem intersection-implies-ge :\n\tforall* {N1} {D1} {M1} {N2} {D2} {M2} {N3} {D3} {M3}\n\tforall {A:intersection (map/+ N1 D1 M1) (map/+ N2 D2 M2) (map/+ N3 D3 M3)}\n\texists {G1:ge N3 N1} {G2:ge N3 N2}\n\ttrue.\n\n- : intersection-implies-ge (intersection/= _ _ nat`eq/) (ge/= nat`eq/) (ge/= nat`eq/).\n\n- : intersection-implies-ge (intersection/< (shift/+ N1+1+N3=N4) M1*M022=M333 N0+1+N1=N2)\n                    (ge/> N4>N1) N4>=N2\n    <- plus-swap-succ N1+1+N3=N4 N1+N3+1=N4\n    <- plus-commutative N1+N3+1=N4 N3+1+N1=N4\n    <- plus-implies-gt N3+1+N1=N4 nat`eq/ N4>N1\n    <- intersection-implies-ge M1*M022=M333 _ N3>=N0\n    <- succ-preserves-ge N3>=N0 N3+1>=N0+1\n    <- plus-right-preserves-ge* N3+1>=N0+1 N3+1+N1=N4 N0+1+N1=N2 N4>=N2.\n\n- : intersection-implies-ge (intersection/> (shift/+ N2+1+N3=N5) M011*M2=M333 N0+1+N2=N1)\n                    N5>=N1 (ge/> N5>N2)\n    <- plus-swap-succ N2+1+N3=N5 N2+N3+1=N5\n    <- plus-commutative N2+N3+1=N5 N3+1+N2=N5\n    <- plus-implies-gt N3+1+N2=N5 nat`eq/ N5>N2\n    <- intersection-implies-ge M011*M2=M333 N3>=N0 _\n    <- succ-preserves-ge N3>=N0 N3+1>=N0+1\n    <- plus-right-preserves-ge* N3+1>=N0+1 N3+1+N2=N5 N0+1+N2=N1 N5>=N1.\n\n%worlds () (intersection-implies-ge _ _ _).\n%total (A) (intersection-implies-ge A _ _).\n\n\n%theorem intersection-deterministic :\n\tforall* {M1} {M2} {M3} {M1P} {M2P} {M3P}\n\tforall {A:intersection M1 M2 M3} {AP:intersection M1P M2P M3P}\n               {E1:eq M1 M1P} {E2:eq M2 M2P}\n\texists {E3:eq M3 M3P}\n\ttrue.\n\n- : intersection-deterministic intersection/L intersection/L eq/ eq/ eq/.\n\n- : intersection-deterministic intersection/L intersection/R eq/ eq/ eq/.\n\n- : intersection-deterministic intersection/R intersection/L eq/ eq/ eq/.\n\n- : intersection-deterministic intersection/R intersection/R eq/ eq/ eq/.\n\n- : intersection-deterministic (intersection/= M1*M2=M3 D1*D2=D3 nat`eq/) \n                       (AP:intersection _ _ M') eq/ eq/ M133=M'\n    <- intersection/=-inversion AP nat`eq/ D3' M3' D1*D2=D3P M1*M2=M3' M133'=M'\n    <- nat`intersection-deterministic D1*D2=D3 D1*D2=D3P nat`eq/ nat`eq/ D3=D3'\n    <- intersection-deterministic M1*M2=M3 M1*M2=M3' eq/ eq/ M3=M3'\n    <- map/+-preserves-eq nat`eq/ D3=D3' M3=M3' M133=M133'\n    <- eq-transitive M133=M133' M133'=M' M133=M'.\n\n- : intersection-deterministic (intersection/< M3<<N1=M M1*M022=M3 N0+1+N1=N2)\n                       (AP:intersection _ _ M') eq/ eq/ M=M'\n    <- intersection/<-inversion AP N0+1+N1=N2 M3' M1*M022=M3' M3'<<N1=M'\n    <- intersection-deterministic M1*M022=M3 M1*M022=M3' eq/ eq/ M3=M3'\n    <- shift-deterministic M3<<N1=M M3'<<N1=M' nat`eq/ M3=M3' M=M'.\n\n- : intersection-deterministic (intersection/> M3<<N2=M M311*M2=M3 N3+1+N2=N1) A' eq/ eq/ M=M'\n    <- intersection/>-inversion A' N3+1+N2=N1 M3' M311*M2=M3' M3'<<N2=M'\n    <- intersection-deterministic M311*M2=M3 M311*M2=M3' eq/ eq/ M3=M3'\n    <- shift-deterministic M3<<N2=M M3'<<N2=M' nat`eq/ M3=M3' M=M'.\n\n%worlds () (intersection-deterministic _ _ _ _ _).\n%total (A) (intersection-deterministic A _ _ _ _).\n\n\n%theorem intersection-total* :\n\tforall {M1} {M2}\n\texists {M3} {A:intersection M1 M2 M3}\n\ttrue.\n\n%% we need some lemmas\n%% We need them to ensure termination because\n%% intersection substitutes new maps on recursive calls which\n%% makes it hard to prove the arguments get smaller.\n\n%theorem intersection-map/+-M-total* :\n\tforall {N1} {D1} {M1} {M2}\n        exists {M3} {A:intersection (map/+ N1 D1 M1) M2 M3}\n\ttrue.\n\n%theorem intersection-M-map/+-total* :\n\tforall {M1} {N2} {D2} {M2}\n        exists {M3} {A:intersection M1 (map/+ N2 D2 M2) M3}\n\ttrue.\n\n%theorem intersection-map/+-map/+-total* :\n\tforall {N1} {D1} {M1} {N2} {D2} {M2} {C} {CMP:nat`compare N1 N2 C}\n        exists {M3} \n               {A:intersection (map/+ N1 D1 M1) (map/+ N2 D2 M2) M3}\n\ttrue.\n\n- : intersection-total* map/0 M map/0 intersection/L.\n\n- : intersection-total* M map/0 map/0 intersection/R.\n\n- : intersection-total* (map/+ N1 D1 M1) (map/+ N2 D2 M2) M3 A\n    <- nat`compare-total* N1 N2 C CMP\n    <- intersection-map/+-map/+-total* N1 D1 M1 N2 D2 M2 C CMP M3 A.               \n\n- : intersection-map/+-map/+-total* N1 D1 M1 N2 D2 M2 equal CMP (map/+ N1 D3 M3)\n                           (intersection/= M1*M2=M3 D1*D2=D3 N1=N2)\n    <- equal-implies-eq CMP N1=N2\n    <- nat`intersection-total* D1 D2 D3 D1*D2=D3\n    <- intersection-total* M1 M2 M3 M1*M2=M3.\n\n- : intersection-map/+-map/+-total* N1 D1 M1 N2 D2 M2 less CMP S1M3\n                           (intersection/< M3<<N1=S1M3 M1*M022=M3 N0+1+N1=N2)\n    <- less-implies-lt CMP N2>N1\n    <- gt-implies-plus N2>N1 _ N0+1+N1=N2\n    <- intersection-M-map/+-total* M1 N0 D2 M2 M3 M1*M022=M3\n    <- shift-total* N1 M3 S1M3 M3<<N1=S1M3.\n\n- : intersection-map/+-map/+-total* N1 D1 M1 N2 D2 M2 greater CMP S2M3\n                           (intersection/> M3<<N2=S2M3 M311*M2=M3 N3+1+N2=N1)\n    <- greater-implies-gt CMP N1>N2\n    <- gt-implies-plus N1>N2 _ N3+1+N2=N1\n    <- intersection-map/+-M-total* N3 D1 M1 M2 M3 M311*M2=M3\n    <- shift-total* N2 M3 S2M3 M3<<N2=S2M3.\n\n- : intersection-M-map/+-total* map/0 N2 D2 M2 map/0 intersection/L.\n\n- : intersection-M-map/+-total* (map/+ N1 D1 M1) N2 D2 M2 M3 A\n    <- nat`compare-total* N1 N2 C CMP\n    <- intersection-map/+-map/+-total* N1 D1 M1 N2 D2 M2 C CMP M3 A.\n\n- : intersection-map/+-M-total* N1 D1 M1 map/0 map/0 intersection/R.\n\n- : intersection-map/+-M-total* N1 D1 M1 (map/+ N2 D2 M2) M3 A\n    <- nat`compare-total* N1 N2 C CMP\n    <- intersection-map/+-map/+-total* N1 D1 M1 N2 D2 M2 C CMP M3 A.\n\n%worlds () (intersection-total* _ _ _ _)\n           (intersection-M-map/+-total* _ _ _ _ _ _)\n           (intersection-map/+-M-total* _ _ _ _ _ _)\n           (intersection-map/+-map/+-total* _ _ _ _ _ _ _ _ _ _).\n\n%total [ (M1a M1b M1c M1d) (M2a M2b M2c M2d) ]\n        (intersection-total* M1d M2d _ _)\n        (intersection-M-map/+-total* M1c _ _ M2c _ _)\n        (intersection-map/+-M-total* _ _ M1b M2b _ _)\n\t(intersection-map/+-map/+-total* _ _ M1a _ _ M2a _ _ _ _).\n               \n%abbrev intersection-total = intersection-total* _ _ _.\n\n\n\n%theorem intersection-commutative :\n\tforall* {M1} {M2} {M3}\n\tforall {A:intersection M1 M2 M3}\n\texists {AP:intersection M2 M1 M3}\n\ttrue.\n\n- : intersection-commutative intersection/L intersection/R.\n\n- : intersection-commutative intersection/R intersection/L.\n\n- : intersection-commutative (intersection/= M1*M2=M3 D1*D2=D3 nat`eq/) \n                     (intersection/= M2*M1=M3 D2*D1=D3 nat`eq/)\n    <- nat`intersection-commutative D1*D2=D3 D2*D1=D3\n    <- intersection-commutative M1*M2=M3 M2*M1=M3.\n\n- : intersection-commutative (intersection/< M3<<N1=S1M3 M1*M022=M3 N0+1+N1=N2) \n                     (intersection/> M3<<N1=S1M3 M022*M1=M3 N0+1+N1=N2)\n    <- intersection-commutative M1*M022=M3 M022*M1=M3.\n\n- : intersection-commutative (intersection/> M3<<N2=S2M3 M311*M2=M3 N3+1+N2=N1) \n                     (intersection/< M3<<N2=S2M3 M2*M311=M3 N3+1+N2=N1)\n    <- intersection-commutative M311*M2=M3 M2*M311=M3.\n\n%worlds () (intersection-commutative _ _).\n%total (A) (intersection-commutative A _).\n\n\n%theorem shift-left-preserves-intersection :\n\tforall* {N} {D} {M1} {M2} {M3} {SM1} {SM3}\n\tforall {A:intersection M1 M2 M3} {S1:shift N M1 SM1} {S3:shift N M3 SM3}\n        exists {SA:intersection SM1 (map/+ N D M2) SM3}\n        true.\n\n- : shift-left-preserves-intersection Z*M2=M3 shift/0 M3<<N=SM3 Z*M222=SM3\n    <- intersection/L-inversion Z*M2=M3 eq/ Z=M3\n    <- shift-deterministic shift/0 M3<<N=SM3 nat`eq/ Z=M3 Z=SM3\n    <- intersection-respects-eq intersection/L eq/ eq/ Z=SM3 Z*M222=SM3.\n\n- : shift-left-preserves-intersection M111*M2=M3 (shift/+ N+1+N1=N1') M3<<N=SM3\n                              (intersection/> M3<<N=SM3 M111*M2=M3 N1+1+N=N1')\n    <- plus-swap-succ N+1+N1=N1' N+N1+1=N1'\n    <- plus-commutative N+N1+1=N1' N1+1+N=N1'.\n\n%worlds () (shift-left-preserves-intersection _ _ _ _).\n%total { } (shift-left-preserves-intersection _ _ _ _).\n\n\n%theorem shift-left-preserves-intersection-converse :\n\tforall* {N} {D} {M1} {M2} {SM1} {SM3}\n\tforall {SA:intersection SM1 (map/+ N D M2) SM3} {S1:shift N M1 SM1}\n        exists {M3} {A:intersection M1 M2 M3} {S3:shift N M3 SM3}\n\ttrue.\n\n- : shift-left-preserves-intersection-converse Z*M222=SM3 shift/0 map/0 intersection/L Z<<N=SM3\n    <- intersection/L-inversion Z*M222=SM3 eq/ Z=SM3\n    <- shift-respects-eq shift/0 nat`eq/ eq/ Z=SM3 Z<<N=SM3.\n\n- : shift-left-preserves-intersection-converse M111*M222=SM3 (shift/+ N2+1+N3=N1) M3\n                                       M311*M2=M3 M3<<N2=SM3\n    <- plus-swap-succ N2+1+N3=N1 N2+N3+1=N1\n    <- plus-commutative N2+N3+1=N1 N3+1+N2=N1\n    <- intersection/>-inversion M111*M222=SM3 N3+1+N2=N1 M3 M311*M2=M3 M3<<N2=SM3.\n\n%worlds () (shift-left-preserves-intersection-converse _ _ _ _ _).\n%total { } (shift-left-preserves-intersection-converse _ _ _ _ _).\n\n\n%theorem shift-right-preserves-intersection :\n\tforall* {N} {D} {M1} {M2} {M3} {SM2} {SM3}\n\tforall {A:intersection M1 M2 M3} {S2:shift N M2 SM2} {S3:shift N M3 SM3}\n        exists {SA:intersection (map/+ N D M1) SM2 SM3}\n\ttrue.\n\n- : shift-right-preserves-intersection M1*0=M3 shift/0 M3<<N=SM3 M111*0=SM3\n    <- intersection/R-inversion M1*0=M3 eq/ Z=M3\n    <- shift-deterministic shift/0 M3<<N=SM3 nat`eq/ Z=M3 Z=SM3\n    <- intersection-respects-eq intersection/R eq/ eq/ Z=SM3 M111*0=SM3.\n\n- : shift-right-preserves-intersection M1*M222=M3 (shift/+ N+1+N2=N2') M3<<N=SM3\n                               (intersection/< M3<<N=SM3 M1*M222=M3 N2+1+N=N2')\n    <- plus-swap-succ N+1+N2=N2' N+N2+1=N2'\n    <- plus-commutative N+N2+1=N2' N2+1+N=N2'.\n\n%worlds () (shift-right-preserves-intersection _ _ _ _).\n%total { } (shift-right-preserves-intersection _ _ _ _).\n\n\n%theorem shift-right-preserves-intersection-converse :\n\tforall* {N} {D} {M1} {M2} {SM2} {SM3}\n\tforall {SA:intersection (map/+ N D M1) SM2 SM3} {S2:shift N M2 SM2}\n        exists {M3} {A:intersection M1 M2 M3} {S3:shift N M3 SM3}\n\ttrue.\n\n- : shift-right-preserves-intersection-converse M*0=SM3 shift/0 map/0 intersection/R Z<<N=SM3\n    <- intersection/R-inversion M*0=SM3 eq/ Z=SM3\n    <- shift-respects-eq shift/0 nat`eq/ eq/ Z=SM3 Z<<N=SM3.\n\n- : shift-right-preserves-intersection-converse M111*M322=SM3 (shift/+ N1+1+N2=N3)\n                                        M3 M1*M222=M3 M3<<N1=SM3\n    <- plus-swap-succ N1+1+N2=N3 N1+N2+1=N3\n    <- plus-commutative N1+N2+1=N3 N2+1+N1=N3\n    <- intersection/<-inversion M111*M322=SM3 N2+1+N1=N3 M3 M1*M222=M3 M3<<N1=SM3.\n\n%worlds () (shift-right-preserves-intersection-converse _ _ _ _ _).\n%total { } (shift-right-preserves-intersection-converse _ _ _ _ _).\n\n\n%theorem shift-preserves-intersection :\n\tforall* {N} {M1} {M2} {M3} {SM1} {SM2} {SM3}\n\tforall {A:intersection M1 M2 M3} \n               {S1:shift N M1 SM1} {S2:shift N M2 SM2} {S3:shift N M3 SM3}\n\texists {SA:intersection SM1 SM2 SM3}\n\ttrue.\n\n- : shift-preserves-intersection Z*M2=M3 shift/0 _ M3<<N=SM3 Z*SM2=SM3\n    <- intersection/L-inversion Z*M2=M3 eq/ Z=M3\n    <- shift-deterministic shift/0 M3<<N=SM3 nat`eq/ Z=M3 Z=SM3\n    <- intersection-respects-eq intersection/L eq/ eq/ Z=SM3 Z*SM2=SM3.\n\n- : shift-preserves-intersection M1*0=M3 _ shift/0 M3<<N=SM3 SM1*0=SM3\n    <- intersection/R-inversion M1*0=M3 eq/ Z=M3\n    <- shift-deterministic shift/0 M3<<N=SM3 nat`eq/ Z=M3 Z=SM3\n    <- intersection-respects-eq intersection/R eq/ eq/ Z=SM3 SM1*0=SM3.\n\n- : shift-preserves-intersection (intersection/= M1*M2=M3 D1*D2=D3 nat`eq/) \n                         (shift/+ N+1+N1=N4) (shift/+ N+1+N1=N5) \n                         (shift/+ N+1+N1=N6)\n                         M411*M522=M633\n    <- plus-deterministic N+1+N1=N4 N+1+N1=N5 nat`eq/ nat`eq/ N4=N5\n    <- plus-deterministic N+1+N1=N4 N+1+N1=N6 nat`eq/ nat`eq/ N4=N6\n    <- map/+-preserves-eq N4=N6 nat`eq/ eq/ M433=M633\n    <- intersection-respects-eq (intersection/= M1*M2=M3 D1*D2=D3 N4=N5) eq/ eq/ M433=M633\n                        M411*M522=M633.\n\n- : shift-preserves-intersection (intersection/< M3<<N1=S1M3 M1*M022=M3 N0+1+N1=N2)\n                         (shift/+ N+1+N1=N4) (shift/+ N+1+N2=N5) S1M3<<N=SS1M3\n                         (intersection/< M3<<N4=SS1M3 M1*M022=M3 N0+1+N4=N5)\n    <- plus-swap-succ N+1+N1=N4 N+N1+1=N4\n    <- plus-commutative N+N1+1=N4 N1+1+N=N4\n    <- shifts-add M3<<N1=S1M3 S1M3<<N=SS1M3 N1+1+N=N4 M3<<N4=SS1M3\n    <- plus-commutative N0+1+N1=N2 N1+N0+1=N2\n    <- plus-associative-converse* N1+N0+1=N2 N+1+N2=N5 N+1+N1=N4 N4+N0+1=N5\n    <- plus-commutative N4+N0+1=N5 N0+1+N4=N5.\n\n- : shift-preserves-intersection (intersection/> M3<<N2=S2M3 M311*M2=M3 N3+1+N2=N1)\n                         (shift/+ N+1+N1=N4) (shift/+ N+1+N2=N5) S2M3<<N=SS2M3\n                         (intersection/> M3<<N5=SS2M3 M311*M2=M3 N3+1+N5=N4)\n    <- plus-swap-succ N+1+N2=N5 N+N2+1=N5\n    <- plus-commutative N+N2+1=N5 N2+1+N=N5\n    <- shifts-add M3<<N2=S2M3 S2M3<<N=SS2M3 N2+1+N=N5 M3<<N5=SS2M3\n    <- plus-commutative N3+1+N2=N1 N2+N3+1=N1\n    <- plus-associative-converse* N2+N3+1=N1 N+1+N1=N4 N+1+N2=N5 N5+N3+1=N4\n    <- plus-commutative N5+N3+1=N4 N3+1+N5=N4.\n\n%worlds () (shift-preserves-intersection _ _ _ _ _).\n%total { } (shift-preserves-intersection _ _ _ _ _).\n\n\n%theorem shift-preserves-intersection-converse :\n\tforall* {N} {M1} {M2} {SM1} {SM2} {SM3}\n\tforall {SA:intersection SM1 SM2 SM3}\n               {S1:shift N M1 SM1} {S2:shift N M2 SM2} \n\texists {M3} {A:intersection M1 M2 M3} {S3:shift N M3 SM3}\n\ttrue.\n\n- : shift-preserves-intersection-converse Z*SM2=SM3 shift/0 _ map/0 intersection/L Z<<N=SM3\n    <- intersection/L-inversion Z*SM2=SM3 eq/ Z=SM3\n    <- shift-respects-eq shift/0 nat`eq/ eq/ Z=SM3 Z<<N=SM3.\n\n- : shift-preserves-intersection-converse SM1*0=SM3 _ shift/0 map/0 intersection/R Z<<N=SM3\n    <- intersection/R-inversion SM1*0=SM3 eq/ Z=SM3\n    <- shift-respects-eq shift/0 nat`eq/ eq/ Z=SM3 Z<<N=SM3.\n\n- : shift-preserves-intersection-converse (intersection/= M1*M2=M3 D1*D2=D3 nat`eq/) \n                                  (shift/+ N+1+N1=N4) (shift/+ N+1+N1'=N4)\n                                  (map/+ N1 D3 M3) M111*M122'=M133\n                                  (shift/+ N+1+N1=N4)\n    <- plus-left-cancels N+1+N1=N4 N+1+N1'=N4 nat`eq/ nat`eq/ N1=N1P\n    <- map/+-preserves-eq N1=N1P nat`eq/ eq/ M122=M122'\n    <- intersection-respects-eq (intersection/= M1*M2=M3 D1*D2=D3 nat`eq/) eq/ M122=M122' eq/\n                        M111*M122'=M133.\n\n- : shift-preserves-intersection-converse (intersection/< M3<<N4=S4M3 M1*M055=M3 N0+1+N4=N5)\n                                  (shift/+ N+1+N1=N4) (shift/+ N+1+N2=N5) S1M3\n\t\t\t\t  (intersection/< M3<<N1=S1M3 M1*M055=M3 N0+1+N1=N2)\n\t\t\t\t  S1M3<<N=S4M3\n    <- plus-commutative N+1+N1=N4 N1+N+1=N4\n    <- plus-swap-succ-converse N1+N+1=N4 N1+1+N=N4\n    <- shifts-add-converse M3<<N4=S4M3 N1+1+N=N4 S1M3 M3<<N1=S1M3 S1M3<<N=S4M3\n    <- plus-associative-converse N1+N+1=N4 N0+1+N4=N5 N2' N0+1+N1=N2' N2'+N+1=N5\n    <- plus-commutative N+1+N2=N5 N2+N+1=N5\n    <- plus-right-cancels N2'+N+1=N5 N2+N+1=N5 nat`eq/ nat`eq/ N2'=N2\n    <- plus-respects-eq N0+1+N1=N2' nat`eq/ nat`eq/ N2'=N2 N0+1+N1=N2.\n                                  \n- : shift-preserves-intersection-converse (intersection/> M3<<N5=S5M3 M611*M2=M3 N6+1+N5=N4)\n                                  (shift/+ N+1+N1=N4) (shift/+ N+1+N2=N5) S2M3\n                                  (intersection/> M3<<N2=S2M3 M611*M2=M3 N6+1+N2=N1)\n                                  S2M3<<N=S5M3\n    <- plus-commutative N+1+N2=N5 N2+N+1=N5\n    <- plus-swap-succ-converse N2+N+1=N5 N2+1+N=N5\n    <- shifts-add-converse M3<<N5=S5M3 N2+1+N=N5 S2M3 M3<<N2=S2M3 S2M3<<N=S5M3\n    <- plus-associative-converse N2+N+1=N5 N6+1+N5=N4 N1' N6+1+N2=N1' N1'+N+1=N4\n    <- plus-commutative N+1+N1=N4 N1+N+1=N4\n    <- plus-right-cancels N1'+N+1=N4 N1+N+1=N4 nat`eq/ nat`eq/ N1'=N1\n    <- plus-respects-eq N6+1+N2=N1' nat`eq/ nat`eq/ N1'=N1 N6+1+N2=N1.\n\n%worlds () (shift-preserves-intersection-converse _ _ _ _ _ _).\n%total { } (shift-preserves-intersection-converse _ _ _ _ _ _).\n\n\n%% We prove associativity by induction over the bound of\n%% the first map.  Hence we need to pass the \"BOUND\" to the theorem\n%% (both the actual bound and the fact that it is the bound).\n%% Later we define a traditional associativity theorem using this one.\n\n%theorem intersection-associativeM :\n\tforall* {M1} {M2} {M3} {M4} {M6} {M7}\n\tforall {B} {BD:bound M1 B}\n               {A12:intersection M1 M2 M3} {A34:intersection M3 M4 M7}\n\t       {A24:intersection M2 M4 M6} \n        exists {A16:intersection M1 M6 M7}\n\ttrue.\n\n%theorem intersection-associativeM* :\n        forall* {N1} {D1} {M1} {N2} {D2} {M2} {N4} {D4} {M4} {M3} {M6} {M7}\n                {C12} {C24} {C14}\n\tforall {B} {BD:bound (map/+ N1 D1 M1) B}\n               {CMP12:nat`compare N1 N2 C12} {CMP24:nat`compare N2 N4 C24}\n               {CMP14:nat`compare N1 N4 C14}\n               {A12:intersection (map/+ N1 D1 M1) (map/+ N2 D2 M2) M3} \n               {A34:intersection M3 (map/+ N4 D4 M4) M7} \n               {A24:intersection (map/+ N2 D2 M2) (map/+ N4 D4 M4) M6} \n        exists {A16:intersection (map/+ N1 D1 M1) M6 M7}\n        true.\n\n%% handle all the cases where M1, M2 or M4 is map/0\n\n- : intersection-associativeM _ _ intersection/L Z*M3=M7 _ Z*M6=M7\n    <- intersection/L-inversion Z*M3=M7 eq/ Z=M7\n    <- intersection-respects-eq intersection/L eq/ eq/ Z=M7 Z*M6=M7.\n\n- : intersection-associativeM _ _ intersection/R Z*M3=M7 _ M1*0=M7\n    <- intersection/L-inversion Z*M3=M7 eq/ Z=M7\n    <- intersection-respects-eq intersection/R eq/ eq/ Z=M7 M1*0=M7.\n\n- : intersection-associativeM _ _ _ _ (_:intersection _ _ map/0) intersection/R.\n\n%% now defer the remaining cases to the lemma.\n\n- : intersection-associativeM B BD A12 A34 A24 A16\n    <- nat`compare-total CMP12\n    <- nat`compare-total CMP24\n    <- nat`compare-total CMP14\n    <- intersection-associativeM* B BD CMP12 CMP24 CMP14 A12 A34 A24 A16.\n \n- : intersection-associativeM* B (bound/+ N1+1+B1=B BD1) \n                       (nat`compare/=) (nat`compare/=) _\n                       A12 A34 A24 A16\n    <- intersection/=-inversion A12 nat`eq/ D3 M3 D1*D2=D3 M1*M2=M3 M133=M12\n    <- eq-symmetric M133=M12 M12=M133\n    <- intersection-respects-eq A34 M12=M133 eq/ eq/ A34'\n    <- intersection/=-inversion A34' nat`eq/ D7 M7 D3*D4=D7 M3*M4=M7 M177=M34\n    <- intersection/=-inversion A24 nat`eq/ D6 M6 D2*D4=D6 M2*M4=M6 M166=M24\n    <- nat`intersection-associative* D1*D2=D3 D3*D4=D7 D2*D4=D6 D1*D6=D7\n    <- plus-implies-gt N1+1+B1=B nat`eq/ B>B1\n    <- meta-gt _ _ B>B1\n    <- intersection-associativeM _ BD1 M1*M2=M3 M3*M4=M7 M2*M4=M6 M1*M6=M7\n    <- intersection-respects-eq (intersection/= M1*M6=M7 D1*D6=D7 nat`eq/) \n                        eq/ M166=M24 M177=M34 A16.\n\n- : intersection-associativeM* B (bound/+ N1+1+B1=B BD1) \n                       (nat`compare/=) (nat`compare/< N4>N1) _\n                       A12 A34 A24 A16\n    <- intersection/=-inversion A12 nat`eq/ D3 M3 D1*D2=D3 M1*M2=M3 M133=M12\n    <- eq-symmetric M133=M12 M12=M133\n    <- intersection-respects-eq A34 M12=M133 eq/ eq/ A34'\n    <- gt-implies-plus N4>N1 N5 N5+1+N1=N4 \n    <- intersection/<-inversion A34' N5+1+N1=N4 M7 M3*M544=M7 M7<<N3=M34\n    <- intersection/<-inversion A24  N5+1+N1=N4 M6 M2*M544=M6 M6<<N3=M24\n    <- plus-implies-gt N1+1+B1=B nat`eq/ B>B1\n    <- meta-gt _ _ B>B1\n    <- intersection-associativeM _ BD1 M1*M2=M3 M3*M544=M7 M2*M544=M6 M1*M6=M7\n    <- shift-right-preserves-intersection M1*M6=M7 M6<<N3=M24 M7<<N3=M34 A16.\n\n- : intersection-associativeM* B (bound/+ N1+1+B1=B BD1)\n                       (nat`compare/=) (nat`compare/> N1>N4) _\n                       A12 A34 A24 A16\n    <- intersection/=-inversion A12 nat`eq/ D3 M3 D1*D2=D3 M1*M2=M3 M133=M12\n    <- eq-symmetric M133=M12 M12=M133\n    <- intersection-respects-eq A34 M12=M133 eq/ eq/ A34'\n    <- gt-implies-plus N1>N4 N6 N6+1+N4=N1     %% NB N2 eq N1\n    <- intersection/>-inversion A34' N6+1+N4=N1 M7 M633*M4=M7 M7<<N4=M34\n    <- intersection/>-inversion A24  N6+1+N4=N1 M6 M622*M4=M6 M6<<N4=M24\n    <- plus-swap-succ N6+1+N4=N1 N6+N4+1=N1\n    <- plus-commutative N6+N4+1=N1 N4+1+N6=N1\n    <- plus-implies-gt N4+1+N6=N1 nat`eq/ N1>N6\n    <- succ-preserves-gt N1>N6 N1+1>N6+1\n    <- plus-total N6+1+B1=B6\n    <- plus-right-preserves-gt* N1+1>N6+1  N1+1+B1=B N6+1+B1=B6 B>B6\n    <- meta-gt _ _ B>B6\n    <- intersection-associativeM _ (bound/+ N6+1+B1=B6 BD1)\n                         (intersection/= M1*M2=M3 D1*D2=D3 nat`eq/)\n                         M633*M4=M7 M622*M4=M6 M611*M6=M7\n    <- shift-preserves-intersection M611*M6=M7 \n                            (shift/+ N4+1+N6=N1) M6<<N4=M24 M7<<N4=M34 A16.\n\n- : intersection-associativeM* B (bound/+ N1+1+B1=B BD1)\n                       (nat`compare/< N2>N1) (nat`compare/=) _\n                       A12 A34 A24 A16\n    <- gt-implies-plus N2>N1 N0 N0+1+N1=N2\n    <- intersection/<-inversion A12 N0+1+N1=N2 M3 M1*M022=M3 M3<<N1=M12\n    <- intersection/=-inversion A24 nat`eq/ D6 M6 D2*D4=D6 M2*M4=M6 M266=M24\n    <- plus-swap-succ N0+1+N1=N2 N0+N1+1=N2\n    <- plus-commutative N0+N1+1=N2 N1+1+N0=N2\n    <- shift-preserves-intersection-converse A34 M3<<N1=M12 (shift/+ N1+1+N0=N2)\n                                     M7 M3*M044=M7 M7<<N1=M34\n    <- plus-implies-gt N1+1+B1=B nat`eq/ B>B1\n    <- meta-gt _ _ B>B1\n    <- intersection-associativeM _ BD1 M1*M022=M3 M3*M044=M7 \n                         (intersection/= M2*M4=M6 D2*D4=D6 nat`eq/) \n                         M1*M066=M7\n    <- shift-right-preserves-intersection M1*M066=M7 (shift/+ N1+1+N0=N2) M7<<N1=M34\n                                  M111*M266=M34\n    <- intersection-respects-eq M111*M266=M34 eq/ M266=M24 eq/ A16.\n\n- : intersection-associativeM* B (bound/+ N1+1+B1=B BD1)\n                       (nat`compare/> N1>N2) (nat`compare/=) _\n                       A12 A34 A24 A16\n    <- gt-implies-plus N1>N2 N3 N3+1+N2=N1\n    <- intersection/>-inversion A12 N3+1+N2=N1 M3 M311*M2=M3 M3<<N2=M12\n    <- intersection/=-inversion A24 nat`eq/ D6 M6 D2*D4=D6 M2*M4=M6 M266=M24\n    <- shift-left-preserves-intersection-converse A34 M3<<N2=M12 M7 M3*M4=M7 M7<<N2=M34\n    <- plus-swap-succ N3+1+N2=N1 N3+N2+1=N1\n    <- plus-commutative N3+N2+1=N1 N2+1+N3=N1\n    <- plus-implies-gt N2+1+N3=N1 nat`eq/ N1>N3\n    <- succ-preserves-gt N1>N3 N1+1>N3+1\n    <- plus-total N3+1+B1=B3\n    <- plus-right-preserves-gt* N1+1>N3+1  N1+1+B1=B N3+1+B1=B3 B>B3\n    <- meta-gt _ _ B>B3\n    <- intersection-associativeM _ (bound/+ N3+1+B1=B3 BD1) \n                         M311*M2=M3 M3*M4=M7 M2*M4=M6 M311*M6=M7\n    <- intersection-respects-eq (intersection/> M7<<N2=M34 M311*M6=M7 N3+1+N2=N1) \n                        eq/ M266=M24 eq/ A16.\n\n- : intersection-associativeM* B (bound/+ N1+1+B1=B BD1)\n                       (nat`compare/< N2>N1) _ (nat`compare/=)\n                       A12 A34 A24 A16\n    <- gt-implies-plus N2>N1 N0 N0+1+N1=N2\n    <- intersection/<-inversion A12 N0+1+N1=N2 M3 M1*M022=M3 M3<<N1=M12\n    <- shift-left-preserves-intersection-converse A34 M3<<N1=M12 M7 M3*M4=M7 M7<<N1=M34\n    <- intersection/>-inversion A24 N0+1+N1=N2 M6 M022*M4=M6 M6<<N1=M24\n    <- plus-implies-gt N1+1+B1=B nat`eq/ B>B1\n    <- meta-gt _ _ B>B1\n    <- intersection-associativeM _ BD1 M1*M022=M3 M3*M4=M7 M022*M4=M6 M1*M6=M7\n    <- shift-right-preserves-intersection M1*M6=M7 M6<<N1=M24 M7<<N1=M34 A16.\n\n- : intersection-associativeM* B (bound/+ N1+1+B1=B BD1)\n                       (nat`compare/> N1>N2) _ (nat`compare/=)\n                       A12 A34 A24 A16\n    <- gt-implies-plus N1>N2 N3 N3+1+N2=N1\n    <- plus-swap-succ N3+1+N2=N1 N3+N2+1=N1\n    <- plus-commutative N3+N2+1=N1 N2+1+N3=N1\n    <- intersection/>-inversion A12 N3+1+N2=N1 M3 M311*M2=M3 M3<<N2=M12\n    <- shift-preserves-intersection-converse A34 M3<<N2=M12 (shift/+ N2+1+N3=N1) \n                                     M7 M3*M344=M7 M7<<N2=M34\n    <- intersection/<-inversion A24 N3+1+N2=N1 M6 M2*M344=M6 M6<<N2=M24\n    <- plus-implies-gt N2+1+N3=N1 nat`eq/ N1>N3\n    <- succ-preserves-gt N1>N3 N1+1>N3+1\n    <- plus-total N3+1+B1=B3\n    <- plus-right-preserves-gt* N1+1>N3+1  N1+1+B1=B N3+1+B1=B3 B>B3\n    <- meta-gt _ _ B>B3\n    <- intersection-associativeM _ (bound/+ N3+1+B1=B3 BD1)\n                         M311*M2=M3 M3*M344=M7 M2*M344=M6 M311*M6=M7\n    <- shift-preserves-intersection M311*M6=M7 (shift/+ N2+1+N3=N1) M6<<N2=M24 \n                            M7<<N2=M34 A16.\n\n- : intersection-associativeM* B (bound/+ N1+1+B1=B BD1)\n                       (nat`compare/< N2>N1) (nat`compare/< N4>N2) _\n                       A12 A34 A24 A16\n    <- gt-implies-plus N2>N1 N0 N0+1+N1=N2\n    <- intersection/<-inversion A12 N0+1+N1=N2 M3 M1*M022=M3 M3<<N1=M12\n    <- gt-implies-plus N4>N2 N6 N6+1+N2=N4\n    <- intersection/<-inversion A24 N6+1+N2=N4 M6 M2*M644=M6 M6<<N2=M24\n    <- plus-swap-succ N0+1+N1=N2 N0+N1+1=N2\n    <- plus-associative-converse N0+N1+1=N2 N6+1+N2=N4 \n                                 N7 N6+1+N0=N7 N7+N1+1=N4\n    <- plus-commutative N7+N1+1=N4 N1+1+N7=N4\n    <- plus-swap-succ-converse N7+N1+1=N4 N7+1+N1=N4\n    <- shift-preserves-intersection-converse A34 M3<<N1=M12 (shift/+ N1+1+N7=N4)\n                                     M7 M3*M744=M7 M7<<N1=M34\n    <- shifts-add-converse M6<<N2=M24 N0+1+N1=N2 S0M6 M6<<N0=S0M6 S0M6<<N1=M24\n    <- plus-implies-gt N1+1+B1=B nat`eq/ B>B1\n    <- meta-gt _ _ B>B1\n    <- intersection-associativeM _ BD1 M1*M022=M3 M3*M744=M7 \n                         (intersection/< M6<<N0=S0M6 M2*M644=M6 N6+1+N0=N7)\n                         M1*S0M6=M7\n    <- shift-right-preserves-intersection M1*S0M6=M7 S0M6<<N1=M24 M7<<N1=M34 A16.\n                         \n\n- : intersection-associativeM* B (bound/+ N1+1+B1=B BD1)\n                       (nat`compare/> N1>N2) (nat`compare/> N2>N4) _\n                       A12 A34 A24 A16\n    <- gt-implies-plus N1>N2 N3 N3+1+N2=N1\n    <- intersection/>-inversion A12 N3+1+N2=N1 M3 M311*M2=M3 M3<<N2=M12\n    <- gt-implies-plus N2>N4 N6 N6+1+N4=N2\n    <- intersection/>-inversion A24 N6+1+N4=N2 M6 M622*M4=M6 M6<<N4=M24\n    <- shifts-add-converse M3<<N2=M12 N6+1+N4=N2 S6M3 M3<<N6=S6M3 S6M3<<N4=M12\n    <- shift-left-preserves-intersection-converse A34 S6M3<<N4=M12 \n                                          M7 S6M3*M4=M7 M7<<N4=M34\n    <- plus-swap-succ N6+1+N4=N2 N6+N4+1=N2\n    <- plus-associative-converse N6+N4+1=N2 N3+1+N2=N1 N9 N3+1+N6=N9 N9+N4+1=N1\n    <- plus-swap-succ N3+1+N6=N9 N3+N6+1=N9\n    <- plus-commutative N3+N6+1=N9 N6+1+N3=N9\n    <- shift-left-preserves-intersection M311*M2=M3 (shift/+ N6+1+N3=N9) M3<<N6=S6M3\n                                 M911*M622=S6M3\n    <- plus-commutative N9+N4+1=N1 N4+1+N9=N1\n    <- plus-implies-gt N4+1+N9=N1 nat`eq/ N1>N9\n    <- succ-preserves-gt N1>N9 N1+1>N9+1\n    <- plus-total N9+1+B1=B9\n    <- plus-right-preserves-gt* N1+1>N9+1  N1+1+B1=B N9+1+B1=B9 B>B9\n    <- meta-gt _ _ B>B9\n    <- intersection-associativeM _ (bound/+ N9+1+B1=B9 BD1)\n                         M911*M622=S6M3 S6M3*M4=M7 M622*M4=M6 M911*M6=M7\n    <- shift-preserves-intersection M911*M6=M7 (shift/+ N4+1+N9=N1) \n                            M6<<N4=M24 M7<<N4=M34 A16.\n\n- : intersection-associativeM* B (bound/+ N1+1+B1=B BD1)\n                       _ (nat`compare/> N2>N4) (nat`compare/< N4>N1)\n                       A12 A34 A24 A16\n    <- gt-implies-plus N2>N4 N6 N6+1+N4=N2\n    <- gt-implies-plus N4>N1 N5 N5+1+N1=N4\n    <- plus-swap-succ N5+1+N1=N4 N5+N1+1=N4\n    <- plus-associative-converse N5+N1+1=N4 N6+1+N4=N2 N0 N6+1+N5=N0 N0+N1+1=N2\n    <- plus-swap-succ-converse N0+N1+1=N2 N0+1+N1=N2\n    <- intersection/<-inversion A12 N0+1+N1=N2 M3 M1*M022=M3 M3<<N1=M12\n    <- intersection/>-inversion A24 N6+1+N4=N2 M6 M622*M4=M6 M6<<N4=M24\n    <- plus-commutative N5+N1+1=N4 N1+1+N5=N4\n    <- shift-preserves-intersection-converse A34 M3<<N1=M12 (shift/+ N1+1+N5=N4)\n                                     M7 M3*M544=M7 M7<<N1=M34\n    <- shifts-add-converse M6<<N4=M24 N5+1+N1=N4 S5M6 M6<<N5=S5M6 S5M6<<N1=M24\n    <- plus-swap-succ N6+1+N5=N0 N6+N5+1=N0\n    <- plus-commutative N6+N5+1=N0 N5+1+N6=N0\n    <- shift-left-preserves-intersection M622*M4=M6 (shift/+ N5+1+N6=N0) M6<<N5=S5M6\n                                 M022*M544=S5M6\n    <- plus-implies-gt N1+1+B1=B nat`eq/ B>B1\n    <- meta-gt _ _ B>B1\n    <- intersection-associativeM _ BD1 M1*M022=M3 M3*M544=M7 M022*M544=S5M6 M1*S5M6=M7\n    <- shift-right-preserves-intersection M1*S5M6=M7 S5M6<<N1=M24 M7<<N1=M34 A16.\n\n- : intersection-associativeM* B (bound/+ N1+1+B1=B BD1)\n                       _ (nat`compare/< N4>N2) (nat`compare/> N1>N4)\n                       A12 A34 A24 A16\n    <- gt-implies-plus N4>N2 N6 N6+1+N2=N4\n    <- gt-implies-plus N1>N4 N5 N5+1+N4=N1\n    <- plus-swap-succ N6+1+N2=N4 N6+N2+1=N4\n    <- plus-associative-converse N6+N2+1=N4 N5+1+N4=N1 N3 N5+1+N6=N3 N3+N2+1=N1\n    <- plus-swap-succ-converse N3+N2+1=N1 N3+1+N2=N1\n    <- intersection/>-inversion A12 N3+1+N2=N1 M3 M311*M2=M3 M3<<N2=M12\n    <- intersection/<-inversion A24 N6+1+N2=N4 M6 M2*M644=M6 M6<<N2=M24\n    <- plus-commutative N6+N2+1=N4 N2+1+N6=N4\n    <- shift-preserves-intersection-converse A34 M3<<N2=M12 (shift/+ N2+1+N6=N4)\n                                     M7 M3*M644=M7 M7<<N2=M34\n    <- plus-commutative N3+N2+1=N1 N2+1+N3=N1\n    <- plus-implies-gt N2+1+N3=N1 nat`eq/ N1>N3\n    <- succ-preserves-gt N1>N3 N1+1>N3+1\n    <- plus-total N3+1+B1=B3\n    <- plus-right-preserves-gt* N1+1>N3+1  N1+1+B1=B N3+1+B1=B3 B>B3\n    <- meta-gt _ _ B>B3\n    <- intersection-associativeM _ (bound/+ N3+1+B1=B3 BD1)\n                         M311*M2=M3 M3*M644=M7 M2*M644=M6 M311*M6=M7\n    <- shift-preserves-intersection M311*M6=M7 (shift/+ N2+1+N3=N1) M6<<N2=M24 \n                            M7<<N2=M34 A16.\n\n- : intersection-associativeM* B (bound/+ N1+1+B1=B BD1)\n                       (nat`compare/> N1>N2) _ (nat`compare/< N4>N1)\n                       A12 A34 A24 A16\n    <- gt-implies-plus N1>N2 N3 N3+1+N2=N1\n    <- gt-implies-plus N4>N1 N5 N5+1+N1=N4\n    <- plus-swap-succ N3+1+N2=N1 N3+N2+1=N1\n    <- plus-associative-converse N3+N2+1=N1 N5+1+N1=N4 N6 N5+1+N3=N6 N6+N2+1=N4\n    <- plus-swap-succ-converse N6+N2+1=N4 N6+1+N2=N4\n    <- intersection/>-inversion A12 N3+1+N2=N1 M3 M311*M2=M3 M3<<N2=M12\n    <- intersection/<-inversion A24 N6+1+N2=N4 M6 M2*M644=M6 M6<<N2=M24\n    <- plus-commutative N6+N2+1=N4 N2+1+N6=N4\n    <- shift-preserves-intersection-converse A34 M3<<N2=M12 (shift/+ N2+1+N6=N4)\n                                     M7 M3*M644=M7 M7<<N2=M34\n    <- plus-commutative N3+N2+1=N1 N2+1+N3=N1\n    <- plus-implies-gt N2+1+N3=N1 nat`eq/ N1>N3\n    <- succ-preserves-gt N1>N3 N1+1>N3+1\n    <- plus-total N3+1+B1=B3\n    <- plus-right-preserves-gt* N1+1>N3+1  N1+1+B1=B N3+1+B1=B3 B>B3\n    <- meta-gt _ _ B>B3\n    <- intersection-associativeM _ (bound/+ N3+1+B1=B3 BD1)\n                         M311*M2=M3 M3*M644=M7 M2*M644=M6 M311*M6=M7\n    <- shift-preserves-intersection M311*M6=M7 (shift/+ N2+1+N3=N1) M6<<N2=M24 \n                            M7<<N2=M34 A16.\n\n- : intersection-associativeM* B (bound/+ N1+1+B1=B BD1)\n                       (nat`compare/< N2>N1) _ (nat`compare/> N1>N4)\n                       A12 A34 A24 A16\n    <- gt-implies-plus N2>N1 N0 N0+1+N1=N2\n    <- gt-implies-plus N1>N4 N5 N5+1+N4=N1\n    <- plus-swap-succ N5+1+N4=N1 N5+N4+1=N1\n    <- plus-associative-converse N5+N4+1=N1 N0+1+N1=N2 N6 N0+1+N5=N6 N6+N4+1=N2\n    <- plus-swap-succ-converse N6+N4+1=N2 N6+1+N4=N2\n    <- intersection/<-inversion A12 N0+1+N1=N2 M3 M1*M022=M3 M3<<N1=M12\n    <- intersection/>-inversion A24 N6+1+N4=N2 M6 M622*M4=M6 M6<<N4=M24\n    <- shifts-add-converse M3<<N1=M12 N5+1+N4=N1 S5M3 M3<<N5=S5M3 S5M3<<N4=M12\n    <- shift-left-preserves-intersection-converse A34 S5M3<<N4=M12\n                                          M7 S5M3*M4=M7 M7<<N4=M34\n    <- plus-swap-succ N0+1+N5=N6 N0+N5+1=N6\n    <- plus-commutative N0+N5+1=N6 N5+1+N0=N6\n    <- shift-right-preserves-intersection M1*M022=M3 (shift/+ N5+1+N0=N6) M3<<N5=S5M3\n                                  M511*M622=S5M3\n    <- plus-commutative N5+N4+1=N1 N4+1+N5=N1\n    <- plus-implies-gt N4+1+N5=N1 nat`eq/ N1>N5\n    <- succ-preserves-gt N1>N5 N1+1>N5+1\n    <- plus-total N5+1+B1=B5\n    <- plus-right-preserves-gt* N1+1>N5+1  N1+1+B1=B N5+1+B1=B5 B>B5\n    <- meta-gt _ _ B>B5\n    <- intersection-associativeM _ (bound/+ N5+1+B1=B5 BD1)\n                         M511*M622=S5M3 S5M3*M4=M7 M622*M4=M6 M511*M6=M7\n    <- shift-preserves-intersection M511*M6=M7 (shift/+ N4+1+N5=N1) \n                            M6<<N4=M24 M7<<N4=M34 A16.\n\n%worlds () (intersection-associativeM _ _ _ _ _ _) \n           (intersection-associativeM* _ _ _ _ _ _ _ _ _).\n\n%total (S SP) (intersection-associativeM* SP _ _ _ _ _ _ _ _)\n              (intersection-associativeM S _ _ _ _ _) .\n\n\n%theorem intersection-associative :\n\tforall* {M1} {M2} {M3} {M4} {M7}\n\tforall {A12:intersection M1 M2 M3} {A34:intersection M3 M4 M7}\n        exists {M6} {A24:intersection M2 M4 M6} \n               {A16:intersection M1 M6 M7}\n\ttrue.\n\n- : intersection-associative A12 A34 _ A24 A16\n    <- bound-total BD\n    <- intersection-total A24\n    <- intersection-associativeM _ BD A12 A34 A24 A16.\n\n%worlds () (intersection-associative _ _ _ _ _).\n%total { } (intersection-associative _ _ _ _ _).\n\n\n\n%theorem intersection-associative* :\n\tforall* {X1} {X2} {X12} {X3} {X23} {X123}\n        forall {OP12:intersection X1 X2 X12} {OP12-3:intersection X12 X3 X123} {OP23:intersection X2 X3 X23}\n        exists {OP1-23:intersection X1 X23 X123}\n        true.\n\n- : intersection-associative* X1*X2=X3 X3*X4=X7 X2*X4=X6 X1*X6=X7\n    <- intersection-associative X1*X2=X3 X3*X4=X7 Y6 X2*X4=Y6 X1*Y6=X7\n    <- intersection-deterministic X2*X4=Y6 X2*X4=X6 eq/ eq/ Y6=X6\n    <- intersection-respects-eq X1*Y6=X7 eq/ Y6=X6 eq/ X1*X6=X7.\n\n%worlds () (intersection-associative* _ _ _ _).\n%total {} (intersection-associative* _ _ _ _).\n\n\n%theorem intersection-associative-converse :\n\tforall* {X1} {X2} {X4} {X6} {X7}\n\tforall {OP24:intersection X2 X4 X6} {OP16:intersection X1 X6 X7}\n        exists {X3} {OP12:intersection X1 X2 X3} {OP34:intersection X3 X4 X7}\n        true.\n\n- : intersection-associative-converse X2*X4=X6 X1*X6=X7 _ X1*X2=X3 X3*X4=X7\n    <- intersection-commutative X2*X4=X6 X4*X2=X6\n    <- intersection-commutative X1*X6=X7 X6*X1=X7\n    <- intersection-associative X4*X2=X6 X6*X1=X7 _ X2*X1=X3 X4*X3=X7\n    <- intersection-commutative X2*X1=X3 X1*X2=X3\n    <- intersection-commutative X4*X3=X7 X3*X4=X7.\n\n%worlds () (intersection-associative-converse X2*X4=X6 X1*X6=X7 X3 X1*X2=X3 X3*X4=X7).\n%total {} (intersection-associative-converse _ _ _ _ _).\n\n\n%theorem intersection-associative-converse* :\n\tforall* {X1} {X2} {X3} {X4} {X6} {X7}\n\tforall {OP24:intersection X2 X4 X6} {OP16:intersection X1 X6 X7} {OP12:intersection X1 X2 X3} \n\texists {OP34:intersection X3 X4 X7}\n        true.\n\n- : intersection-associative-converse* X2*X4=X6 X1*X6=X7 X1*X2=X3 X3*X4=X7\n    <- intersection-associative-converse X2*X4=X6 X1*X6=X7 X3P X1*X2=X3P X3P*X4=X7\n    <- intersection-deterministic X1*X2=X3P X1*X2=X3 eq/ eq/ X3P=X3\n    <- intersection-respects-eq X3P*X4=X7 X3P=X3 eq/ eq/ X3*X4=X7.\n\n%worlds () (intersection-associative-converse* X2*X4=X6 X1*X6=X7 X1*X2=X3  X3*X4=X7).\n%total {} (intersection-associative-converse* _ _ _ _).\n\n\n%theorem intersection-assoc-commutative* :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X7}\n\tforall {OP1:intersection X1 X2 X3} {OP2:intersection X3 X4 X7}\n               {OP3:intersection X1 X4 X5} \n        exists {OP4:intersection X5 X2 X7}\n\ttrue.\n\n- : intersection-assoc-commutative* X1*X2=X3 X3*X4=X7 X1*X4=X5 X5*X2=X7\n    <- intersection-associative X1*X2=X3 X3*X4=X7 X6 X2*X4=X6 X1*X6=X7\n    <- intersection-commutative X2*X4=X6 X4*X2=X6\n    <- intersection-associative-converse* X4*X2=X6 X1*X6=X7 X1*X4=X5 X5*X2=X7.\n\n%worlds () (intersection-assoc-commutative* X1*X2=X3 X3*X4=X7 X1*X4=X5  X5*X2=X7).\n%total {} (intersection-assoc-commutative* _ _ _ _).\n\n\n%theorem intersection-assoc-commutative :\n\tforall* {X1} {X2} {X3} {X4} {X7}\n\tforall {OP1:intersection X1 X2 X3} {OP2:intersection X3 X4 X7}\n        exists {X5} {OP3:intersection X1 X4 X5} {OP4:intersection X5 X2 X7}\n\ttrue.\n\n- : intersection-assoc-commutative X1*X2=X3 X3*X4=X7 X5 X1*X4=X5 X5*X2=X7\n    <- intersection-associative X1*X2=X3 X3*X4=X7 X6 X2*X4=X6 X1*X6=X7\n    <- intersection-commutative X2*X4=X6 X4*X2=X6\n    <- intersection-associative-converse X4*X2=X6 X1*X6=X7 X5 X1*X4=X5 X5*X2=X7.\n\n%worlds () (intersection-assoc-commutative X1*X2=X3 X3*X4=X7  X5 X1*X4=X5 X5*X2=X7).\n%total {} (intersection-assoc-commutative _ _ _ _ _).\n\n\n%theorem intersection-double-associative* :\n\tforall* {A} {B} {C} {D} {A+B} {C+D} {A+C} {B+D} {X}\n\tforall {AB:intersection A B A+B} {CD:intersection C D C+D} {ABCD:intersection A+B C+D X}\n\t       {AC:intersection A C A+C} {BD:intersection B D B+D} \n        exists {ACBD:intersection A+C B+D X}\n\ttrue.\n\n- : intersection-double-associative* X1*X2=X3 X4*X8=XC X3*XC=XF X1*X4=X5 X2*X8=XA X5*XA=XF\n    <- intersection-associative X1*X2=X3 X3*XC=XF XE X2*XC=XE X1*XE=XF\n    <- intersection-commutative X4*X8=XC X8*X4=XC\n    <- intersection-associative-converse* X8*X4=XC X2*XC=XE X2*X8=XA XA*X4=XE\n    <- intersection-commutative XA*X4=XE X4*XA=XE\n    <- intersection-associative-converse* X4*XA=XE X1*XE=XF X1*X4=X5 X5*XA=XF.\n\n%worlds () (intersection-double-associative* X1*X2=X3 X4*X8=XC X3*XC=XF X1*X4=X5 X2*X8=XA\n                             X5*XA=XF).\n%total {} (intersection-double-associative* _ _ _ _ _ _).\n\n\n%theorem intersection-double-associative :\n\tforall* {A} {B} {C} {D} {A+B} {C+D} {X}\n\tforall {AB:intersection A B A+B} {CD:intersection C D C+D} {ABCD:intersection A+B C+D X}\n\texists {A+C} {B+D} {AC:intersection A C A+C} {BD:intersection B D B+D} \n               {ACBD:intersection A+C B+D X}\n\ttrue.\n\n- : intersection-double-associative X1*X2=X3 X4*X8=XC X3*XC=XF X5 XA X1*X4=X5 X2*X8=XA X5*XA=XF\n    <- intersection-associative X1*X2=X3 X3*XC=XF XE X2*XC=XE X1*XE=XF\n    <- intersection-commutative X4*X8=XC X8*X4=XC\n    <- intersection-associative-converse X8*X4=XC X2*XC=XE XA X2*X8=XA XA*X4=XE\n    <- intersection-commutative XA*X4=XE X4*XA=XE\n    <- intersection-associative-converse X4*XA=XE X1*XE=XF X5 X1*X4=X5 X5*XA=XF.\n\n%worlds () (intersection-double-associative _ _ _ _ _ _ _ _).\n%total { } (intersection-double-associative _ _ _ _ _ _ _ _).\n\n\n%theorem intersection-implies-leq* :\n\tforall* {M1} {M2} {M3}\n\tforall {A:intersection M1 M2 M3}\n        exists {L:leq M3 M1}\n\ttrue.\n\n- : intersection-implies-leq* intersection/L leq/0.\n\n- : intersection-implies-leq* intersection/R leq/0.\n\n- : intersection-implies-leq* (intersection/= M1*M2=M3 D1*D2=D3 nat`eq/) \n                      (leq/= M3<=M1 D3<=D1 nat`eq/)\n    <- nat`intersection-implies-leq* D1*D2=D3 D3<=D1\n    <- intersection-implies-leq* M1*M2=M3 M3<=M1.\n\n- : intersection-implies-leq* (intersection/< M3<<N1=S1M3 M1*M022=M3 N0+1+N1+N2) \n                      S1M3<=M111\n    <- intersection-implies-leq* M1*M022=M3 M3<=M1\n    <- shift-left-preserves-leq* M3<=M1 M3<<N1=S1M3 S1M3<=M111.\n\n- : intersection-implies-leq* (intersection/> M3<<N2=S2M3 M311*M2=M3 N3+1+N2=N1) \n                      S2M3<=M111\n    <- intersection-implies-leq* M311*M2=M3 M3<=M311\n    <- plus-swap-succ N3+1+N2=N1 N3+N2+1=N1\n    <- plus-commutative N3+N2+1=N1 N2+1+N3=N1\n    <- shift-preserves-leq* M3<=M311 M3<<N2=S2M3 (shift/+ N2+1+N3=N1) \n                            S2M3<=M111.\n\n%worlds () (intersection-implies-leq* _ _).\n%total (A) (intersection-implies-leq* A _).\n\n\n%theorem intersection-implies-leq :\n\tforall* {M1} {M2} {M3}\n\tforall {A:intersection M1 M2 M3}\n        exists {L1:leq M3 M1} {L2:leq M3 M2}\n\ttrue.\n\n- : intersection-implies-leq M1*M2=M3 M3<=M1 M3<=M2\n    <- intersection-implies-leq* M1*M2=M3 M3<=M1\n    <- intersection-commutative M1*M2=M3 M2*M1=M3\n    <- intersection-implies-leq* M2*M1=M3 M3<=M2.\n\n%worlds () (intersection-implies-leq _ _ _).\n%total { } (intersection-implies-leq _ _ _).\n\n\n%theorem intersection-is-glb :\n\tforall* {M0} {M1} {M2} {M3}\n\tforall {A:intersection M1 M2 M3}\n\t       {L1:leq M0 M1} {L2:leq M0 M2}\n\texists {L3:leq M0 M3}\n\ttrue.\n\n- : intersection-is-glb _ leq/0 _ leq/0.\n\n- : intersection-is-glb _ _ leq/0 leq/0.\n\n- : intersection-is-glb (intersection/= M1*M2=M3 D1*D2=D3 nat`eq/)\n                (leq/= M0<=M1 D0<=D1 nat`eq/) L2\n                (leq/= M0<=M3 D0<=D3 nat`eq/)\n    <- leq/=-inversion L2 nat`eq/ D0<=D2 M0<=M2\n    <- nat`intersection-is-glb D1*D2=D3 D0<=D1 D0<=D2 D0<=D3\n    <- intersection-is-glb M1*M2=M3 M0<=M1 M0<=M2 M0<=M3.\n\n- : intersection-is-glb (intersection/= M1*M2=M3 D1*D2=D3 nat`eq/)\n                (leq/> M400<=M1 N4+1+N1=N0) L2\n                (leq/> M400<=M3 N4+1+N1=N0)\n    <- leq/>-inversion L2 N4+1+N1=N0 M400<=M2\n    <- intersection-is-glb M1*M2=M3 M400<=M1 M400<=M2 M400<=M3.\n\n- : intersection-is-glb (intersection/< M3<<N1=S1M3 M1*M022=M3 N0+1+N1=N2)\n                (leq/= M0<=M1 D0<=D1 nat`eq/) L2 L3\n    <- leq-contradiction L2 N0+1+N1=N2 F\n    <- false-implies-leq F L3.\n\n- : intersection-is-glb (intersection/< M3<<N1=S1M3 M1*M322=M3 N3+1+N1=N2)\n                (leq/> M500<=M1 N5+1+N1=N2) (leq/= M0<=M2 D0<=D2 nat`eq/)\n                M200<=S1M3\n    <- plus-right-cancels N5+1+N1=N2 N3+1+N1=N2 nat`eq/ nat`eq/ N5+1=N3+1\n    <- succ-cancels N5+1=N3+1 N5=N3\n    <- map/+-preserves-eq N5=N3 nat`eq/ eq/ M500=M300\n    <- leq-respects-eq M500<=M1 M500=M300 eq/ M300<=M1\n    <- intersection-is-glb M1*M322=M3 M300<=M1 (leq/= M0<=M2 D0<=D2 nat`eq/) M300<=M3\n    <- plus-swap-succ N3+1+N1=N2 N3+N1+1=N2\n    <- plus-commutative N3+N1+1=N2 N1+1+N3=N2\n    <- shift-preserves-leq* M300<=M3 (shift/+ N1+1+N3=N2) M3<<N1=S1M3 M200<=S1M3.\n\n- : intersection-is-glb (intersection/< M3<<N1=S1M3 M1*M322=M3 N3+1+N1=N2)\n                (leq/> M500<=M1 N5+1+N1=N0) (leq/> M600<=M2 N6+1+N2=N0)\n                M000<=S1M3\n    <- plus-swap-succ N3+1+N1=N2 N3+N1+1=N2\n    <- plus-associative-converse N3+N1+1=N2 N6+1+N2=N0 \n                                 N5' N6+1+N3=N5' N5'+N1+1=N0\n    <- plus-swap-succ N5+1+N1=N0 N5+N1+1=N0\n    <- plus-right-cancels N5'+N1+1=N0 N5+N1+1=N0 nat`eq/ nat`eq/ N5'=N5\n    <- plus-respects-eq N6+1+N3=N5' nat`eq/ nat`eq/ N5'=N5 N6+1+N3=N5\n    <- plus-swap-succ N6+1+N3=N5 N6+N3+1=N5\n    <- plus-commutative N6+N3+1=N5 N3+1+N6=N5\n    <- shift-left-preserves-leq* M600<=M2 (shift/+ N3+1+N6=N5) M500<=M322\n    <- intersection-is-glb M1*M322=M3 M500<=M1 M500<=M322 M500<=M3\n    <- plus-commutative N5+N1+1=N0 N1+1+N5=N0\n    <- shift-preserves-leq* M500<=M3 (shift/+ N1+1+N5=N0) M3<<N1=S1M3 M000<=S1M3.\n\n- : intersection-is-glb (intersection/> M3<<N2=S2M3 M311*M2=M3 N3+1+N2=N1)\n                (leq/= M0<=M1 D0<=D1 nat`eq/) L2\n                M100<=S2M3\n    <- leq/>-inversion L2 N3+1+N2=N1 M300<=M2\n    <- intersection-is-glb M311*M2=M3 (leq/= M0<=M1 D0<=D1 nat`eq/) M300<=M2 M300<=M3\n    <- plus-swap-succ N3+1+N2=N1 N3+N2+1=N1\n    <- plus-commutative N3+N2+1=N1 N2+1+N3=N1\n    <- shift-preserves-leq* M300<=M3 (shift/+ N2+1+N3=N1) M3<<N2=S2M3 M100<=S2M3.\n\n- : intersection-is-glb (intersection/> M3<<N2=S2M3 M311*M2=M3 N3+1+N2=N1)\n                (leq/> M500<=M1 N5+1+N1=N0) L2\n                M000<=S2M3\n    <- plus-swap-succ N3+1+N2=N1 N3+N2+1=N1\n    <- plus-associative-converse N3+N2+1=N1 N5+1+N1=N0 \n                                 N6 N5+1+N3=N6 N6+N2+1=N0\n    <- plus-swap-succ-converse N6+N2+1=N0 N6+1+N2=N0\n    <- leq/>-inversion L2 N6+1+N2=N0 M600<=M2\n    <- plus-swap-succ N5+1+N3=N6 N5+N3+1=N6\n    <- plus-commutative N5+N3+1=N6 N3+1+N5=N6\n    <- shift-left-preserves-leq* M500<=M1 (shift/+ N3+1+N5=N6) M600<=M311\n    <- intersection-is-glb M311*M2=M3 M600<=M311 M600<=M2 M600<=M3\n    <- plus-commutative N6+N2+1=N0 N2+1+N6=N0\n    <- shift-preserves-leq* M600<=M3 (shift/+ N2+1+N6=N0) M3<<N2=S2M3 M000<=S2M3.\n\n%worlds () (intersection-is-glb _ _ _ _).\n%total (A) (intersection-is-glb A _ _ _).\n\n\n%theorem intersection-idempotent :\n\tforall* {S}\n\texists {A:intersection S S S}\n\ttrue.\n\n- : intersection-idempotent S*S=S\n    <- intersection-total S*S=S'\n    <- intersection-implies-leq* S*S=S' S'<=S\n    <- leq-reflexive _ S<=S\n    <- intersection-is-glb S*S=S' S<=S S<=S S<=S'\n    <- leq-anti-symmetric S'<=S S<=S' S'=S\n    <- intersection-respects-eq S*S=S' eq/ eq/ S'=S S*S=S.\n\n%worlds () (intersection-idempotent _).\n%total { } (intersection-idempotent _).\n\n\n%theorem leq-implies-intersection :\n\tforall* {M1} {M2}\n\tforall {L:leq M1 M2}\n\texists {J:intersection M1 M2 M1}\n\ttrue.\n\n- : leq-implies-intersection M1<=M2 M1*M2=M1\n    <- intersection-total M1*M2=M3\n    <- leq-reflexive _ M1<=M1\n    <- intersection-is-glb M1*M2=M3 M1<=M1 M1<=M2 M1<=M3\n    <- intersection-implies-leq* M1*M2=M3 M3<=M1\n    <- leq-anti-symmetric M3<=M1 M1<=M3 M3=M1\n    <- intersection-respects-eq M1*M2=M3 eq/ eq/ M3=M1 M1*M2=M1.\n\n%worlds () (leq-implies-intersection _ _).\n%total { } (leq-implies-intersection _ _).\n\n\n%theorem intersection-left-preserves-leq* :\n\tforall* {M1} {M2} {M3} {M4} {M5}\n\tforall {L1:leq M2 M4}\n               {A:intersection M1 M2 M3} {AP:intersection M1 M4 M5}\n\texists {L3:leq M3 M5}\n\ttrue.\n\n- : intersection-left-preserves-leq* _ intersection/L _ leq/0.\n\n- : intersection-left-preserves-leq* _ intersection/R _ leq/0.\n\n- : intersection-left-preserves-leq* (leq/= M2<=M4 D2<=D4 nat`eq/)\n                             (intersection/= M1*M2=M3 D1*D2=D3 nat`eq/)\n                             M111*M144=M M133<=M\n    <- intersection/=-inversion M111*M144=M nat`eq/ D5 M5 D1*D4=D5 M1*M4=M5 M155=M\n    <- meta-eq (map/+ N1 D5 M5) M M155=M\n    <- nat`intersection-left-preserves-leq* D2<=D4 D1*D2=D3 D1*D4=D5 D3<=D5\n    <- intersection-left-preserves-leq* M2<=M4 M1*M2=M3 M1*M4=M5 M3<=M5\n    <- leq-respects-eq (leq/= M3<=M5 D3<=D5 nat`eq/) eq/ M155=M M133<=M.\n\n- : intersection-left-preserves-leq* (leq/= M2<=M4 D2<=D4 nat`eq/)\n                             (intersection/< M3<<N1=S1M3 M1*M022=M3 N0+1+N1=N2)\n                             M111*M244=M S1M3<=M\n    <- intersection/<-inversion M111*M244=M N0+1+N1=N2 M5 M1*M044=M5 M5<<N1=M\n    <- intersection-left-preserves-leq* (leq/= M2<=M4 D2<=D4 nat`eq/) \n                                M1*M022=M3 M1*M044=M5 M3<=M5\n    <- shift-preserves-leq* M3<=M5 M3<<N1=S1M3 M5<<N1=M S1M3<=M.\n\n- : intersection-left-preserves-leq* (leq/= M2<=M4 D2<=D4 nat`eq/)\n                             (intersection/> M3<<N2=S2M3 M311*M2=M3 N3+1+N2=N1)\n                             M111*M244=M S2M3<=M\n    <- intersection/>-inversion M111*M244=M N3+1+N2=N1 M5 M311*M4=M5 M5<<N2=M\n    <- intersection-left-preserves-leq* M2<=M4 M311*M2=M3 M311*M4=M5 M3<=M5\n    <- shift-preserves-leq* M3<=M5 M3<<N2=S2M3 M5<<N2=M S2M3<=M.\n\n- : intersection-left-preserves-leq* (leq/> M622<=M4 N6+1+N4=N2)\n                             (intersection/= M1*M2=M3 D1*D2=D3 nat`eq/)   % N1=N2\n                             M211*M444=M M233<=M\n    <- intersection/>-inversion M211*M444=M N6+1+N4=N2 M5 M611*M4=M5 M5<<N4=M\n    <- intersection-left-preserves-leq* M622<=M4 (intersection/= M1*M2=M3 D1*D2=D3 nat`eq/)\n                                M611*M4=M5 M633<=M5\n    <- plus-swap-succ N6+1+N4=N2 N6+N4+1=N2\n    <- plus-commutative N6+N4+1=N2 N4+1+N6=N2\n    <- shift-preserves-leq* M633<=M5 (shift/+ N4+1+N6=N2) M5<<N4=M M233<=M.\n\n- : intersection-left-preserves-leq* (leq/> M622<=M4 N6+1+N4=N2)\n                             (intersection/> M3<<N2=S2M3 M311*M2=M3 N3+1+N2=N1) \n                             M111*M444=M S2M3<=M\n    <- nat`plus-swap-succ N6+1+N4=N2 N6+N4+1=N2\n    <- nat`plus-associative-converse N6+N4+1=N2 N3+1+N2=N1 \n                                     N5 N3+1+N6=N5 N5+N4+1=N1\n    <- nat`plus-swap-succ-converse N5+N4+1=N1 N5+1+N4=N1 \n    <- intersection/>-inversion M111*M444=M N5+1+N4=N1 M5 M511*M4=M5 M5<<N4=M\n    <- shift-total M3<<N6=S6M3\n    <- intersection-left-preserves-leq* M622<=M4 \n                                (intersection/> M3<<N6=S6M3 M311*M2=M3 N3+1+N6=N5)\n                                M511*M4=M5 S6M3<=M5\n    <- shift-total S6M3<<N4=M?\n    <- shifts-add M3<<N6=S6M3 S6M3<<N4=M? N6+1+N4=N2 M3<<N2=M?\n    <- shift-deterministic M3<<N2=M? M3<<N2=S2M3 nat`eq/ eq/ M?=S2M3\n    <- shift-respects-eq S6M3<<N4=M? nat`eq/ eq/ M?=S2M3 S6M3<<N4=S2M3\n    <- shift-preserves-leq* S6M3<=M5 S6M3<<N4=S2M3 M5<<N4=M S2M3<=M.\n\n- : intersection-left-preserves-leq* (leq/> M622<=M4 N6+1+N4=N2) \n                             A1 (intersection/= M1*M4=M5 D1*D4=D5 nat`eq/)\n                             S1M3<=M455\n    <- intersection/<-inversion A1 N6+1+N4=N2 M3 M1*M622=M3 M3<<N4=S1M3\n    <- intersection-left-preserves-leq* M622<=M4 M1*M622=M3 M1*M4=M5 M3<=M5\n    <- shift-left-preserves-leq* M3<=M5 M3<<N4=S1M3 S1M3<=M455.\n\n- : intersection-left-preserves-leq* (leq/> M622<=M4 N6+1+N4=N2)\n                             A1 (intersection/< M5<<N1=S1M5 M1*M544=M5 N5+1+N1=N4)\n                             M<=S1M5\n    <- plus-swap-succ N5+1+N1=N4 N5+N1+1=N4\n    <- plus-associative-converse N5+N1+1=N4 N6+1+N4=N2 \n                                 N0 N6+1+N5=N0 N0+N1+1=N2\n    <- plus-swap-succ-converse N0+N1+1=N2 N0+1+N1=N2\n    <- intersection/<-inversion A1 N0+1+N1=N2 M3 M1*M022=M3 M3<<N1=M\n    <- plus-swap-succ N6+1+N5=N0 N6+N5+1=N0\n    <- plus-commutative N6+N5+1=N0 N5+1+N6=N0\n    <- shift-left-preserves-leq* M622<=M4 (shift/+ N5+1+N6=N0) M022<=M544\n    <- intersection-left-preserves-leq* M022<=M544 M1*M022=M3 M1*M544=M5 M3<=M5\n    <- shift-preserves-leq* M3<=M5 M3<<N1=M M5<<N1=S1M5 M<=S1M5.\n\n- : intersection-left-preserves-leq* L\n                             (intersection/< M3<<N1=S1M3 M1*M022=M3 N0+1+N1=N2)\n                             (intersection/> M5<<N4=S4M5 M511*M4=M5 N5+1+N4=N1)\n                             S1M3<<S4M5\n    <- nat`plus-swap-succ N5+1+N4=N1 N5+N4+1=N1\n    <- nat`plus-associative-converse N5+N4+1=N1 N0+1+N1=N2 \n                                     N6 N0+1+N5=N6 N6+N4+1=N2\n    <- nat`plus-swap-succ-converse N6+N4+1=N2 N6+1+N4=N2\n    <- leq/>-inversion L N6+1+N4=N2 M622<=M4\n    <- plus-swap-succ N0+1+N5=N6 N0+N5+1=N6\n    <- plus-commutative N0+N5+1=N6 N5+1+N0=N6\n    <- shift-total M3<<N5=S5M3\n    <- shift-right-preserves-intersection M1*M022=M3 (shift/+ N5+1+N0=N6) M3<<N5=S5M3\n                                  M511*M622=S5M3\n    <- intersection-left-preserves-leq* M622<=M4 M511*M622=S5M3 M511*M4=M5 S5M3<=M5\n    <- shift-total S5M3<<N4=S4S5M3\n    <- shifts-add M3<<N5=S5M3 S5M3<<N4=S4S5M3 N5+1+N4=N1 M3<<N1=S4S5M3\n    <- shift-deterministic M3<<N1=S4S5M3 M3<<N1=S1M3 nat`eq/ eq/ S4S5M3=S1M3\n    <- shift-respects-eq S5M3<<N4=S4S5M3 nat`eq/ eq/ S4S5M3=S1M3 S5M3<<N4=S1M3\n    <- shift-preserves-leq* S5M3<=M5 S5M3<<N4=S1M3 M5<<N4=S4M5 S1M3<<S4M5.\n\n%worlds () (intersection-left-preserves-leq* _ _ _ _).\n%total (A) (intersection-left-preserves-leq* _ _ A _).\n\n\n\n%theorem intersection-right-preserves-leq* :\n\tforall* {X1} {X2} {X3} {X4} {X5}\n\tforall {G1:leq X1 X2} {O1:intersection X1 X3 X4} {O2:intersection X2 X3 X5}\n\texists {G2:leq X4 X5}\n\ttrue.\n\n- : intersection-right-preserves-leq* X1<=X2 X1*X3=X4 X2*X3=X5 X4<=X5\n    <- intersection-commutative X1*X3=X4 X3*X1=X4\n    <- intersection-commutative X2*X3=X5 X3*X2=X5\n    <- intersection-left-preserves-leq* X1<=X2 X3*X1=X4 X3*X2=X5 X4<=X5.\n\n%worlds () (intersection-right-preserves-leq* X1<=X2 X1*X3=X4 X2*X3=X5  X4<=X5).\n%total {} (intersection-right-preserves-leq* _ _ _ _).\n\n\n\n%theorem intersection-right-distributes-over-union :\n\tforall* {M1} {M2} {M3} {M4} {M7}\n        forall {J12:union M1 M2 M3} {A34:intersection M3 M4 M7}\n        exists {M5} {M6} {A14:intersection M1 M4 M5} {A24:intersection M2 M4 M6}\n               {J56:union M5 M6 M7}\n\ttrue.\n\n- : intersection-right-distributes-over-union union/L A24 _ _ intersection/L A24 union/L.\n\n- : intersection-right-distributes-over-union union/R A14 _ _ A14 intersection/L union/R.\n\n- : intersection-right-distributes-over-union _ intersection/R _ _ intersection/R intersection/R union/L.\n\n- : intersection-right-distributes-over-union (union/= M1+M2=M3 D1+D2=D3 nat`eq/) intersection/R\n                                     _ _ intersection/R intersection/R union/L.\n\n- : intersection-right-distributes-over-union (union/= M1+M2=M3 D1+D2=D3 nat`eq/)\n                                     (intersection/= M3*M4=M7 D3*D4=D7 nat`eq/) _ _\n                                     (intersection/= M1*M4=M5 D1*D4=D5 nat`eq/) \n                                     (intersection/= M2*M4=M6 D2*D4=D6 nat`eq/) \n                                     (union/= M5+M6=M7 D5+D6=D7 nat`eq/)\n    <- intersection-right-distributes-over-union M1+M2=M3 M3*M4=M7 _ _\n                                        M1*M4=M5 M2*M4=M6 M5+M6=M7\n    <- nat`intersection-right-distributes-over-union D1+D2=D3 D3*D4=D7 _ _\n                                             D1*D4=D5 D2*D4=D6 D5+D6=D7.\n\n- : intersection-right-distributes-over-union (union/= M1+M2=M3 D1+D2=D3 nat`eq/)\n                                     (intersection/< M7<<N1=S1M7 M3*M744=M7 N7+1+N1=N4)\n                                 _ _ (intersection/< M5<<N1=S1M5 M1*M744=M5 N7+1+N1=N4)\n                                     (intersection/< M6<<N1=S1M6 M2*M744=M6 N7+1+N1=N4)\n                                     S1M5+S1M6=S1M7\n    <- intersection-right-distributes-over-union M1+M2=M3 M3*M744=M7 _ _\n                                        M1*M744=M5 M2*M744=M6 M5+M6=M7\n    <- shift-total M5<<N1=S1M5\n    <- shift-total M6<<N1=S1M6\n    <- shift-preserves-union M5+M6=M7 M5<<N1=S1M5 M6<<N1=S1M6 M7<<N1=S1M7 \n                            S1M5+S1M6=S1M7.\n\n- : intersection-right-distributes-over-union (union/= M1+M2=M3 D1+D2=D3 nat`eq/)\n                                     (intersection/> M7<<N2=S2M7 M733*M4=M7 N7+1+N4=N1)\n                                 _ _ (intersection/> M5<<N2=S2M5 M711*M4=M5 N7+1+N4=N1)\n                                     (intersection/> M6<<N2=S2M6 M722*M4=M6 N7+1+N4=N1)\n                                     S2M5+S2M6=S2M7\n    <- intersection-right-distributes-over-union (union/= M1+M2=M3 D1+D2=D3 nat`eq/)\n                                        M733*M4=M7 _ _ M711*M4=M5 M722*M4=M6\n                                        M5+M6=M7\n    <- shift-total M5<<N2=S2M5\n    <- shift-total M6<<N2=S2M6\n    <- shift-preserves-union M5+M6=M7 M5<<N2=S2M5 M6<<N2=S2M6 M7<<N2=S2M7 \n                            S2M5+S2M6=S2M7.\n\n- : intersection-right-distributes-over-union (union/< M1+M022=M3 N0+1+N1=N2)\n                                     (intersection/= M3*M4=M7 D1*D4=D7 nat`eq/)\n                                 _ _ (intersection/= M1*M4=M5 D1*D4=D7 nat`eq/)\n                                     (intersection/> M6<<N1=S1M6 M022*M4=M6 N0+1+N1=N2)\n                                     M175+S1M6=M177\n    <- intersection-right-distributes-over-union M1+M022=M3 M3*M4=M7 _ _\n                                        M1*M4=M5 M022*M4=M6 M5+M6=M7\n    <- shift-total M6<<N1=S1M6\n    <- shift-right-preserves-union M5+M6=M7 M6<<N1=S1M6 M175+S1M6=M177.\n\n- : intersection-right-distributes-over-union (union/< M1+M022=M3 N0+1+N1=N2)\n                                     (intersection/< M7<<N1=S1M7 M3*M544=M7 N5+1+N1=N4)\n                                 _ _ (intersection/< M5<<N1=S1M5 M1*M544=M5 N5+1+N1=N4)\n                                     M222*M444=S1M6 S1M5+S1M6=S1M7\n    <- intersection-right-distributes-over-union M1+M022=M3 M3*M544=M7 _ _\n                                        M1*M544=M5 M022*M544=M6 M5+M6=M7\n    <- shift-total M5<<N1=S1M5\n    <- shift-total M6<<N1=S1M6\n    <- plus-swap-succ N0+1+N1=N2 N0+N1+1=N2\n    <- plus-commutative N0+N1+1=N2 N1+1+N0=N2\n    <- plus-swap-succ N5+1+N1=N4 N5+N1+1=N4\n    <- plus-commutative N5+N1+1=N4 N1+1+N5=N4\n    <- shift-preserves-intersection M022*M544=M6 (shift/+ N1+1+N0=N2) \n                            (shift/+ N1+1+N5=N4) M6<<N1=S1M6 M222*M444=S1M6\n    <- shift-preserves-union M5+M6=M7 M5<<N1=S1M5 M6<<N1=S1M6 M7<<N1=S1M7\n                            S1M5+S1M6=S1M7.\n\n- : intersection-right-distributes-over-union (union/< M1+M022=M3 N0+1+N1=N2)\n                                     (intersection/> M7<<N4=S4M7 M513*M4=M7 N5+1+N4=N1)\n                                 _ _ (intersection/> M5<<N4=S4M5 M511*M4=M5 N5+1+N4=N1)\n                                     (intersection/> M6<<N4=S4M6 M622*M4=M6 N6+1+N4=N2)\n                                     S4M5+S4M6=S4M7\n    <- plus-swap-succ N5+1+N4=N1 N5+N4+1=N1\n    <- plus-associative-converse N5+N4+1=N1 N0+1+N1=N2 N6 N0+1+N5=N6 N6+N4+1=N2\n    <- plus-swap-succ-converse N6+N4+1=N2 N6+1+N4=N2\n    <- plus-swap-succ N0+1+N5=N6 N0+N5+1=N6\n    <- plus-commutative N0+N5+1=N6 N5+1+N0=N6\n    <- shift-right-preserves-union M1+M022=M3 (shift/+ N5+1+N0=N6) M511*M622=M513\n    <- intersection-right-distributes-over-union M511*M622=M513 M513*M4=M7 _ _\n                                        M511*M4=M5 M622*M4=M6 M5+M6=M7\n    <- shift-total M5<<N4=S4M5\n    <- shift-total M6<<N4=S4M6\n    <- shift-preserves-union M5+M6=M7 M5<<N4=S4M5 M6<<N4=S4M6 M7<<N4=S4M7\n                            S4M5+S4M6=S4M7.\n\n- : intersection-right-distributes-over-union (union/> M311+M2=M3 N3+1+N2=N1)\n                                     (intersection/= M3*M4=M7 D2*D4=D7 nat`eq/)\n                                 _ _ (intersection/> M5<<N2=S2M5 M311*M4=M5 N3+1+N2=N1)\n                                     (intersection/= M2*M4=M6 D2*D4=D7 nat`eq/)\n                                     S2M5+M276=M277\n    <- intersection-right-distributes-over-union M311+M2=M3 M3*M4=M7 _ _\n                                        M311*M4=M5 M2*M4=M6 M5+M6=M7\n    <- shift-total M5<<N2=S2M5\n    <- shift-left-preserves-union M5+M6=M7 M5<<N2=S2M5 S2M5+M276=M277.\n\n- : intersection-right-distributes-over-union (union/> M311+M2=M3 N3+1+N2=N1)\n                                     (intersection/< M7<<N2=S2M7 M3*M644=M7 N6+1+N2=N4)\n                                 _ _ M111*M444=S2M5\n                                     (intersection/< M6<<N2=S2M6 M2*M644=M6 N6+1+N2=N4)\n                                     S2M5+S2M6=S2M7\n    <- intersection-right-distributes-over-union M311+M2=M3 M3*M644=M7 _ _\n                                        M311*M644=M5 M2*M644=M6 M5+M6=M7\n    <- shift-total M5<<N2=S2M5\n    <- shift-total M6<<N2=S2M6    \n    <- plus-swap-succ N3+1+N2=N1 N3+N2+1=N1\n    <- plus-commutative N3+N2+1=N1 N2+1+N3=N1\n    <- plus-swap-succ N6+1+N2=N4 N6+N2+1=N4\n    <- plus-commutative N6+N2+1=N4 N2+1+N6=N4\n    <- shift-preserves-intersection M311*M644=M5 (shift/+ N2+1+N3=N1) \n                            (shift/+ N2+1+N6=N4) M5<<N2=S2M5 M111*M444=S2M5\n    <- shift-preserves-union M5+M6=M7 M5<<N2=S2M5 M6<<N2=S2M6 M7<<N2=S2M7\n                            S2M5+S2M6=S2M7.\n\n- : intersection-right-distributes-over-union (union/> M311+M2=M3 N3+1+N2=N1)\n                                     (intersection/> M7<<N4=S4M7 M623*M4=M7 N6+1+N4=N2)\n                                 _ _ (intersection/> M5<<N4=S4M5 M511*M4=M5 N5+1+N4=N1)\n                                     (intersection/> M6<<N4=S4M6 M622*M4=M6 N6+1+N4=N2)\n                                     S4M5+S4M6=S4M7\n    <- plus-swap-succ N6+1+N4=N2 N6+N4+1=N2\n    <- plus-associative-converse N6+N4+1=N2 N3+1+N2=N1 N5 N3+1+N6=N5 N5+N4+1=N1\n    <- plus-swap-succ-converse N5+N4+1=N1 N5+1+N4=N1\n    <- plus-swap-succ N3+1+N6=N5 N3+N6+1=N5\n    <- plus-commutative N3+N6+1=N5 N6+1+N3=N5\n    <- shift-left-preserves-union M311+M2=M3 (shift/+ N6+1+N3=N5) M511+M622=M623\n    <- intersection-right-distributes-over-union M511+M622=M623 M623*M4=M7 _ _\n                                        M511*M4=M5 M622*M4=M6 M5+M6=M7\n    <- shift-total M5<<N4=S4M5\n    <- shift-total M6<<N4=S4M6\n    <- shift-preserves-union M5+M6=M7 M5<<N4=S4M5 M6<<N4=S4M6 M7<<N4=S4M7\n                            S4M5+S4M6=S4M7.\n\n%worlds () (intersection-right-distributes-over-union _ _ _ _ _ _ _).\n%total (A) (intersection-right-distributes-over-union _ A _ _ _ _ _).\n\n\n\n%theorem intersection-right-distributes-over-union* :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X6} {X7}\n        forall {A12:union X1 X2 X3} {M34:intersection X3 X4 X7}\n               {M14:intersection X1 X4 X5} {M24:intersection X2 X4 X6}\n        exists {A56:union X5 X6 X7}\n\ttrue.\n\n- : intersection-right-distributes-over-union* X1+X2=X3 X3*X4=X7 X1*X4=X5 X2*X4=X6 X5+X6=X7\n    <- intersection-right-distributes-over-union X1+X2=X3 X3*X4=X7 Y5 Y6\n                                      X1*X4=Y5 X2*X4=Y6 Y5+Y6=X7\n    <- intersection-deterministic X1*X4=Y5 X1*X4=X5 eq/ eq/ Y5=X5\n    <- intersection-deterministic X2*X4=Y6 X2*X4=X6 eq/ eq/ Y6=X6\n    <- union-respects-eq Y5+Y6=X7 Y5=X5 Y6=X6 eq/ X5+X6=X7.\n\n%worlds () (intersection-right-distributes-over-union* X1+X2=X3 X3*X4=X7 X1*X4=X5 X2*X4=X6\n                                       X5+X6=X7).\n%total {} (intersection-right-distributes-over-union* _ _ _ _ _).\n\n\n%theorem intersection-left-distributes-over-union* :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X6} {X7}\n        forall {A12:union X2 X4 X6} {M34:intersection X1 X6 X7}\n               {M14:intersection X1 X2 X3} {M24:intersection X1 X4 X5}\n        exists {A56:union X3 X5 X7}\n\ttrue.\n\n- : intersection-left-distributes-over-union* X2+X4=X6 X1*X6=X7 X1*X2=X3 X1*X4=X5 X3+X5=X7\n    <- intersection-commutative X1*X6=X7 X6*X1=X7\n    <- intersection-commutative X1*X2=X3 X2*X1=X3\n    <- intersection-commutative X1*X4=X5 X4*X1=X5\n    <- intersection-right-distributes-over-union* X2+X4=X6 X6*X1=X7 X2*X1=X3 X4*X1=X5\n                                       X3+X5=X7.\n\n%worlds () (intersection-left-distributes-over-union* X2+X4=X6 X1*X6=X7 X1*X2=X3 X1*X4=X5\n                                     X3+X5=X7).\n%total {} (intersection-left-distributes-over-union* _ _ _ _ _).\n\n\n%theorem intersection-left-distributes-over-union :\n\tforall* {X1} {X2} {X4} {X6} {X7}\n        forall {A12:union X2 X4 X6} {M34:intersection X1 X6 X7}\n        exists {X3} {X5} {M14:intersection X1 X2 X3} {M24:intersection X1 X4 X5}\n               {A56:union X3 X5 X7}\n\ttrue.\n\n- : intersection-left-distributes-over-union X2+X4=X6 X1*X6=X7 \n                                  X3 X5 X1*X2=X3 X1*X4=X5 X3+X5=X7\n    <- intersection-total X1*X2=X3\n    <- intersection-total X1*X4=X5\n    <- intersection-left-distributes-over-union* X2+X4=X6 X1*X6=X7 X1*X2=X3 X1*X4=X5\n                                      X3+X5=X7.\n\n%worlds () (intersection-left-distributes-over-union X2+X4=X6 X1*X6=X7 \n                                    X3 X5 X1*X2=X3 X1*X4=X5 X3+X5=X7).\n%total {} (intersection-left-distributes-over-union _ _ _ _ _ _ _).\n\n\n%theorem intersection-right-factors-over-union* :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X6} {X7}\n        forall {M14:intersection X1 X4 X5} {M24:intersection X2 X4 X6} {A56:union X5 X6 X7}\n               {A12:union X1 X2 X3} \n        exists {M34:intersection X3 X4 X7}\n\ttrue.\n\n- : intersection-right-factors-over-union* X1*X4=X5 X2*X4=X6 X5+X6=X7 X1+X2=X3 X3*X4=X7\n    <- intersection-total X3*X4=Y7\n    <- intersection-right-distributes-over-union* X1+X2=X3 X3*X4=Y7 X1*X4=X5 X2*X4=X6 \n                                       X5+X6=Y7\n    <- union-deterministic X5+X6=Y7 X5+X6=X7 eq/ eq/ Y7=X7\n    <- intersection-respects-eq X3*X4=Y7 eq/ eq/ Y7=X7 X3*X4=X7.\n\n%worlds () (intersection-right-factors-over-union* X1*X4=X5 X2*X4=X6 X5+X6=X7 X1+X2=X3\n                                  X3*X4=X7 ).\n%total {} (intersection-right-factors-over-union* _ _ _ _ _).\n\n\n%theorem intersection-left-factors-over-union* :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X6} {X7}\n\tforall {M12:intersection X1 X2 X3} {M14:intersection X1 X4 X5} \n               {A35:union X3 X5 X7} {A24:union X2 X4 X6} \n        exists {M16:intersection X1 X6 X7}\n        true.\n\n- : intersection-left-factors-over-union* X1*X2=X3 X1*X4=X5 X3+X5=X7 X2+X4=X6 \n                               X1*X6=X7\n    <- intersection-total X1*X6=Y7\n    <- intersection-left-distributes-over-union* X2+X4=X6 X1*X6=Y7 X1*X2=X3 X1*X4=X5\n                                      X3+X5=Y7\n    <- union-deterministic X3+X5=Y7 X3+X5=X7 eq/ eq/ Y7=X7\n    <- intersection-respects-eq X1*X6=Y7 eq/ eq/ Y7=X7 X1*X6=X7.\n\n%worlds () (intersection-left-factors-over-union* X1*X2=X3 X1*X4=X5 X3+X5=X7 X2+X4=X6 \n                                X1*X6=X7).\n%total {} (intersection-left-factors-over-union* _ _ _ _ _).\n\n\n\n\n%%%% Definitions\n\n\n\n\ncount : map -> nat -> nat -> type.\n\n\ncount/s : lookup M N C -> count M N (s C).\n\ncount/z : not-member M N -> count M N z.\n\n\n\nadd : map -> nat -> map -> type.\n\n\nadd/0 : not-member M N -> update M N z M' -> add M N M'.\n\nadd/+ : lookup M N C -> update M N (s C) M' -> add M N M'.\n\n\n\n\n%%%% Theorems\n\n\n\n%%% Theorems about count\n\n\n%theorem false-implies-count :\n\tforall* {M} {N} {C}\n\tforall {F:void}\n\texists {MC:count M N C}\n\ttrue.\n\n%worlds () (false-implies-count _ _).\n%total { } (false-implies-count _ _).\n\n\n%theorem count-respects-eq :\n\tforall* {M1} {N1} {C1} {M2} {N2} {C2}\n\tforall {MC1:count M1 N1 C1}\n\t       {EM:eq M1 M2} {EN:nat`eq N1 N2} {EC:nat`eq C1 C2}\n\texists {MC2:count M2 N2 C2}\n\ttrue.\n\n- : count-respects-eq C eq/ nat`eq/ nat`eq/ C.\n\n%worlds () (count-respects-eq _ _ _ _ _).\n%total { } (count-respects-eq _ _ _ _ _).\n\n\n%theorem count-total** :\n\tforall* {M} {N} {B}\n\tforall {D?:member? M N B}\n\texists {C} {MC:count M N C}\n\ttrue.\n\n- : count-total** (member?/in L) _ (count/s L).\n\n- : count-total** (member?/out F) _ (count/z F).\n\n%worlds () (count-total** _ _ _).\n%total { } (count-total** _ _ _).\n\n\n%theorem count-total* :\n\tforall {M} {N}\n\texists {C} {MC:count M N C}\n\ttrue.\n\n- : count-total* M N _ MC\n    <- member?-total M?\n    <- count-total** M? _ MC.\n\n%worlds () (count-total* _ _ _ _).\n%total { } (count-total* _ _ _ _).\n\n\n%abbrev count-total = count-total* _ _ _.\n\n\n%theorem count-deterministic :\n\tforall* {M1} {N1} {C1} {M2} {N2} {C2}\n\tforall {MC1:count M1 N1 C1}\n\t       {MC2:count M2 N2 C2}\n\t       {EM:eq M1 M2} {EN:nat`eq N1 N2} \n\texists {EC:nat`eq C1 C2}\n\ttrue.\n\n- : count-deterministic (count/z _) (count/z _) _ _ nat`eq/.\n\n- : count-deterministic (count/s L) (count/s L') eq/ nat`eq/ SC=sC'\n    <- lookup-deterministic L L' eq/ nat`eq/ C=C'\n    <- succ-deterministic C=C' SC=sC'.\n\n- : count-deterministic (count/z F) (count/s L) eq/ nat`eq/ E\n    <- not-member-lookup-not-equal F L N<>N\n    <- nat`ne-anti-reflexive N<>N V\n    <- nat`false-implies-eq V E.\n\n- : count-deterministic (count/s L) (count/z F) eq/ nat`eq/ E\n    <- not-member-lookup-not-equal F L N<>N\n    <- nat`ne-anti-reflexive N<>N V\n    <- nat`false-implies-eq V E.\n\n%worlds () (count-deterministic _ _ _ _ _).\n%total { } (count-deterministic _ _ _ _ _).\n\n\n%theorem count-empty-is-zero :\n\tforall*\t{N} {M}\n\tforall\t{K:count map/0 N M}\n\texists\t{E:nat`eq M z}\n\ttrue.\n\n- : count-empty-is-zero (count/z _) nat`eq/.\n\n%worlds () (count-empty-is-zero _ _).\n%total { } (count-empty-is-zero _ _).\n\n\n\n%%% Theorems about add\n\n\n%theorem false-implies-add :\n\tforall*\t{M} {N} {M'}\n\tforall\t{F:void}\n\texists\t{A:add M N M'}\n\ttrue.\n\n%worlds () (false-implies-add _ _).\n%total { } (false-implies-add _ _).\n\n\n%theorem add-respects-eq :\n\tforall*\t{M1} {N1} {M1'} \n\t\t{M2} {N2} {M2'}\n\tforall\t{A1: add M1 N1 M1'}\n\t\t{EM: eq M1 M2}\n\t\t{EN: nat`eq N1 N2}\n\t\t{EM': eq M1' M2'}\n\texists\t{A2: add M2 N2 M2'}\n\ttrue.\n\n- : add-respects-eq A eq/ nat`eq/ eq/ A.\n\n%worlds () (add-respects-eq _ _ _ _ _).\n%total { } (add-respects-eq _ _ _ _ _).\n\n\n%theorem add-total* :\n\tforall\t{M} {N}\n\texists\t{M'}\n\t\t{A:add M N M'}\n\ttrue.\n\n%abbrev add-total = add-total* _ _ _.\n\n%theorem add-total/L :\n\tforall*\t{M} {N} {B}\n\tforall\t{M?:member? M N B}\n\texists\t{M'}\n\t\t{A:add M N M'}\n\ttrue.\n\n- : add-total/L (member?/out MF) _ (add/0 MF MU)\n    <- update-total MU.\n\n- : add-total/L (member?/in ML) _ (add/+ ML MU)\n    <- update-total MU.\n\n%worlds () (add-total/L _ _ _).\n%total { } (add-total/L _ _ _).\n\n- : add-total A\n    <- member?-total M\n    <- add-total/L M _ A.\n\n%worlds () (add-total* _ _ _ _).\n%total { } (add-total* _ _ _ _).\n\n\n%theorem add-deterministic:\n\tforall*\t{M1} {N1} {M1'} \n\t\t{M2} {N2} {M2'}\n\tforall\t{A1: add M1 N1 M1'}\n\t\t{A2: add M2 N2 M2'}\n\t\t{EM: eq M1 M2}\n\t\t{EN: nat`eq N1 N2}\n\texists\t{EM': eq M1' M2'}\n\ttrue.\n\n- : add-deterministic (add/0 _ U) (add/0 _ U') eq/ nat`eq/ EM'\n    <- update-deterministic U U' eq/ nat`eq/ nat`eq/ EM'.\n\n- : add-deterministic (add/0 NM _) (add/+ M _) eq/ nat`eq/ EM\n    <- not-member-lookup-not-equal NM M NE\n    <- nat`ne-anti-reflexive NE F\n    <- false-implies-eq F EM.\n\n- : add-deterministic (add/+ M _) (add/0 NM _) eq/ nat`eq/ EM\n    <- not-member-lookup-not-equal NM M NE\n    <- nat`ne-anti-reflexive NE F\n    <- false-implies-eq F EM.\n\n- : add-deterministic (add/+ ML1 U1) (add/+ ML2 U2) EM EN EM'\n    <- lookup-deterministic ML1 ML2 EM EN EC\n    <- succ-deterministic EC SEC\n    <- update-deterministic U1 U2 EM EN SEC EM'.\n\n%worlds () (add-deterministic _ _ _ _ _).\n%total { } (add-deterministic _ _ _ _ _).\n\n\n%theorem add-commutes :\n\tforall* {M0} {N1} {M1} {N2} {M2}\n\tforall\t{A01:add M0 N1 M1}\n\t\t{A12:add M1 N2 M2}\n\texists\t{M3}\n\t\t{A02:add M0 N2 M3}\n\t\t{A32:add M3 N1 M2}\n\ttrue.\n\n%theorem add-commutes/L :\n\tforall* {M0} {N1} {M1} {N2} {M2} {B}\n\tforall\t{A01:add M0 N1 M1}\n\t\t{A12:add M1 N2 M2}\n\t\t{EQ?: nat`eq? N1 N2 B}\n\texists\t{M3}\n\t\t{A02:add M0 N2 M3}\n\t\t{A32:add M3 N1 M2}\n\ttrue.\n\n- : add-commutes/L A0 A1 nat`eq?/yes _ A0 A1.\n\n- : add-commutes/L (add/0 NM1 U01) (add/0 NM2 U12) (nat`eq?/no N1<>N2) _\n\t\t   (add/0 NM2' U02) (add/0 NM1' U32)\n    <- update-preserves-not-member-converse NM2 U01 NM2'\n    <- update-total U02\n    <- update-preserves-not-member NM1 U02 N1<>N2 NM1'\n    <- update-commutes* U01 U12 N1<>N2 U02 U32.\n\n- : add-commutes/L (add/0 NM1 U01) (add/+ L2 U12) (nat`eq?/no N1<>N2) _\n\t\t   (add/+ L2' U02) (add/0 NM1' U32)\n    <- nat`ne-symmetric N1<>N2 N2<>N1\n    <- update-preserves-lookup-converse L2 U01 N2<>N1 L2'\n    <- update-total U02\n    <- update-preserves-not-member NM1 U02 N1<>N2 NM1'\n    <- update-commutes* U01 U12 N1<>N2 U02 U32.\n\n- : add-commutes/L (add/+ L1 U01) (add/0 NM2 U12) (nat`eq?/no N1<>N2) _\n\t\t   (add/0 NM2' U02) (add/+ L1' U32)\n    <- update-preserves-not-member-converse NM2 U01 NM2'\n    <- update-total U02\n    <- update-preserves-lookup L1 U02 N1<>N2 L1'\n    <- update-commutes* U01 U12 N1<>N2 U02 U32.\n\n- : add-commutes/L (add/+ L1 U01) (add/+ L2 U12) (nat`eq?/no N1<>N2) _\n\t\t   (add/+ L2' U02) (add/+ L1' U32)\n    <- nat`ne-symmetric N1<>N2 N2<>N1\n    <- update-preserves-lookup-converse L2 U01 N2<>N1 L2'\n    <- update-total U02\n    <- update-preserves-lookup L1 U02 N1<>N2 L1'\n    <- update-commutes* U01 U12 N1<>N2 U02 U32.\n\n%worlds () (add-commutes/L _ _ _ _ _ _).\n%total { } (add-commutes/L _ _ _ _ _ _).\n\n- : add-commutes A01 A12 _ A02 A23\n    <- nat`eq?-total EQ?\n    <- add-commutes/L A01 A12 EQ? _ A02 A23.\n\n%worlds () (add-commutes _ _ _ _ _).\n%total { } (add-commutes _ _ _ _ _).\n\n\n%theorem count-add-implies-count :\n\tforall* {M} {N} {C} {M'}\n\tforall\t{K:count M N C}\n\t\t{A:add M N M'}\n\texists\t{K':count M' N (s C)}\n\ttrue.\n\n- : count-add-implies-count (count/z NM) A K'\n    <- update-total U    \n    <- add-deterministic (add/0 NM U) A eq/ nat`eq/ EM'\n    <- update-implies-lookup U L\n    <- count-respects-eq (count/s L) EM' nat`eq/ nat`eq/ K'.\n\n- : count-add-implies-count (count/s L) A K'\n    <- update-total U    \n    <- add-deterministic (add/+ L U) A eq/ nat`eq/ EM'\n    <- update-implies-lookup U L'\n    <- count-respects-eq (count/s L') EM' nat`eq/ nat`eq/ K'.\n\n%worlds () (count-add-implies-count _ _ _).\n%total { } (count-add-implies-count _ _ _).\n\n\n %theorem update-preserves-count :\n\tforall* {M} {N} {C} {M'} {N'} {C'}\n\tforall\t{K:count M N C}\n\t\t{A:update M N' C' M'}\n\t\t{NE: nat`ne N N'}\n\texists\t{K':count M' N C}\n\ttrue.\n\n - : update-preserves-count (count/z NM) U NE (count/z NM')\n     <- update-preserves-not-member NM U NE NM'.\n\n - : update-preserves-count (count/s L) U NE (count/s L')\n     <- update-preserves-lookup L U NE L'.\n\n %worlds () (update-preserves-count _ _ _ _).\n %total { } (update-preserves-count _ _ _ _).\n\n\n%theorem add-preserves-count :\n\tforall* {M} {N} {C} {M'} {N'}\n\tforall\t{K:count M N C}\n\t\t{A:add M N' M'}\n\t\t{NE: nat`ne N N'}\n\texists\t{K':count M' N C}\n\ttrue.\n\n- : add-preserves-count K (add/0 _ U) NE K'\n    <- update-preserves-count K U NE K'.\n\n- : add-preserves-count K (add/+ _ U) NE K'\n    <- update-preserves-count K U NE K'.\n\n%worlds () (add-preserves-count _ _ _ _).\n%total { } (add-preserves-count _ _ _ _).\n\n\n%theorem add-preserves-count-converse :\n\tforall* {M} {N} {C} {M'} {N'}\n\tforall\t{K':count M' N C}\n\t\t{A:add M N' M'}\n\t\t{NE: nat`ne N N'}\n\texists\t{K:count M N C}\n\ttrue.\n\t\n- : add-preserves-count-converse K2 A NE K1\n    <- count-total K1'\n    <- add-preserves-count K1' A NE K2'\n    <- count-deterministic K2' K2 eq/ nat`eq/ EQ\n    <- count-respects-eq K1' eq/ nat`eq/ EQ K1.\n\n%worlds () (add-preserves-count-converse _ _ _ _).\n%total { } (add-preserves-count-converse _ _ _ _).\n\n\n%theorem shift-preserves-count-converse :\n\tforall* {N} {M1} {N1} {M2} {N2} {C}\n\tforall\t{C2: count M2 N2 C}\n\t\t{MS: shift N M1 M2}\n\t\t{P: plus (s N) N1 N2}\n\texists\t{C1: count M1 N1 C}\n\ttrue.\n\n- : shift-preserves-count-converse (count/z MF) MS P (count/z MF')\n    <- shift-preserves-not-member-converse* MF MS P MF'.\n\n- : shift-preserves-count-converse (count/s ML) MS P (count/s ML')\n    <- shift-preserves-lookup-converse* ML MS P ML'.\n\n%worlds () (shift-preserves-count-converse _ _ _ _).\n%total { } (shift-preserves-count-converse _ _ _ _).\n\n\n%theorem shift-preserves-add-converse :\n\tforall* {N} {M1} {N1} {M2} {N2} {M2'}\n\tforall\t{A2: add M2 N2 M2'}\n\t\t{MS: shift N M1 M2}\n\t\t{P: plus (s N) N1 N2}\n\texists\t{M1'}\n\t\t{MS': shift N M1' M2'}\n\t\t{A1: add M1 N1 M1'}\n\ttrue.\n\n- : shift-preserves-add-converse (add/+ ML MU) MS P _ MS' (add/+ ML' MU')\n    <- shift-preserves-update-converse MU MS P _ MS' MU'\n    <- shift-preserves-lookup-converse* ML MS P ML'.\n\n- : shift-preserves-add-converse (add/0 MF MU) MS P _ MS' (add/0 MF' MU')\n    <- shift-preserves-update-converse MU MS P _ MS' MU'\n    <- shift-preserves-not-member-converse* MF MS P MF'.\n\n%worlds () (shift-preserves-add-converse _ _ _ _ _ _).\n%total { } (shift-preserves-add-converse _ _ _ _ _ _).\n\n%%%%% multiset-extra.elf\n%%%%% Extra theorems about multisets not derived from map.\n%%%%% This file is part of the multiset.elf signature\n\n\n\n%%%% Theorems\n\n\n%theorem union-right-distributes-over-intersection :\n\tforall* {S1} {S2} {S3} {S4} {S7}\n        forall {I12:intersection S1 S2 S3} {U34:union S3 S4 S7}\n        exists {S5} {S6} {U14:union S1 S4 S5} {U24:union S2 S4 S6}\n               {I56:intersection S5 S6 S7}\n\ttrue.\n\n- : union-right-distributes-over-intersection S1*S2=S3 S3+S4=S7 S5 S6\n                                              S1+S4=S5 S2+S4=S6 S5*S6=S7\n    <- union-total S1+S4=S5\n    <- union-total S2+S4=S6\n    <- intersection-total S5*S6=S7'\n    <- union-implies-leq S2+S4=S6 _ S4<=S6\n    <- leq-implies-intersection S4<=S6 S4*S6=S4\n    <- intersection-total S1*S6=S8\n    <- intersection-total S1*S4=S9\n    <- intersection-right-distributes-over-union* S1+S4=S5 S5*S6=S7'\n                                                  S1*S6=S8 S4*S6=S4 S8+S4=S7'\n    <- intersection-left-distributes-over-union* S2+S4=S6 S1*S6=S8\n                                                 S1*S2=S3 S1*S4=S9 S3+S9=S8\n    <- intersection-implies-leq S1*S4=S9 _ S9<=S4\n    <- leq-implies-union S9<=S4 S9+S4=S4\n    <- union-associative* S3+S9=S8 S8+S4=S7' S9+S4=S4 S3+S4=S7'\n    <- union-deterministic S3+S4=S7' S3+S4=S7 eq/ eq/ S7'=S7 \n    <- intersection-respects-eq S5*S6=S7' eq/ eq/ S7'=S7 S5*S6=S7.\n\n%worlds () (union-right-distributes-over-intersection _ _ _ _ _ _ _).\n%total { } (union-right-distributes-over-intersection _ _ _ _ _ _ _).\n\n\n\n%theorem union-right-distributes-over-intersection* :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X6} {X7}\n        forall {A12:intersection X1 X2 X3} {M34:union X3 X4 X7}\n               {M14:union X1 X4 X5} {M24:union X2 X4 X6}\n        exists {A56:intersection X5 X6 X7}\n\ttrue.\n\n- : union-right-distributes-over-intersection* X1*X2=X3 X3+X4=X7 X1+X4=X5 X2+X4=X6 X5*X6=X7\n    <- union-right-distributes-over-intersection X1*X2=X3 X3+X4=X7 Y5 Y6\n                                      X1+X4=Y5 X2+X4=Y6 Y5*Y6=X7\n    <- union-deterministic X1+X4=Y5 X1+X4=X5 eq/ eq/ Y5=X5\n    <- union-deterministic X2+X4=Y6 X2+X4=X6 eq/ eq/ Y6=X6\n    <- intersection-respects-eq Y5*Y6=X7 Y5=X5 Y6=X6 eq/ X5*X6=X7.\n\n%worlds () (union-right-distributes-over-intersection* X1*X2=X3 X3+X4=X7 X1+X4=X5 X2+X4=X6\n                                       X5*X6=X7).\n%total {} (union-right-distributes-over-intersection* _ _ _ _ _).\n\n\n%theorem union-left-distributes-over-intersection* :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X6} {X7}\n        forall {A12:intersection X2 X4 X6} {M34:union X1 X6 X7}\n               {M14:union X1 X2 X3} {M24:union X1 X4 X5}\n        exists {A56:intersection X3 X5 X7}\n\ttrue.\n\n- : union-left-distributes-over-intersection* X2*X4=X6 X1+X6=X7 X1+X2=X3 X1+X4=X5 X3*X5=X7\n    <- union-commutative X1+X6=X7 X6+X1=X7\n    <- union-commutative X1+X2=X3 X2+X1=X3\n    <- union-commutative X1+X4=X5 X4+X1=X5\n    <- union-right-distributes-over-intersection* X2*X4=X6 X6+X1=X7 X2+X1=X3 X4+X1=X5\n                                       X3*X5=X7.\n\n%worlds () (union-left-distributes-over-intersection* X2*X4=X6 X1+X6=X7 X1+X2=X3 X1+X4=X5\n                                     X3*X5=X7).\n%total {} (union-left-distributes-over-intersection* _ _ _ _ _).\n\n\n%theorem union-left-distributes-over-intersection :\n\tforall* {X1} {X2} {X4} {X6} {X7}\n        forall {A12:intersection X2 X4 X6} {M34:union X1 X6 X7}\n        exists {X3} {X5} {M14:union X1 X2 X3} {M24:union X1 X4 X5}\n               {A56:intersection X3 X5 X7}\n\ttrue.\n\n- : union-left-distributes-over-intersection X2*X4=X6 X1+X6=X7 \n                                  X3 X5 X1+X2=X3 X1+X4=X5 X3*X5=X7\n    <- union-total X1+X2=X3\n    <- union-total X1+X4=X5\n    <- union-left-distributes-over-intersection* X2*X4=X6 X1+X6=X7 X1+X2=X3 X1+X4=X5\n                                      X3*X5=X7.\n\n%worlds () (union-left-distributes-over-intersection X2*X4=X6 X1+X6=X7 \n                                    X3 X5 X1+X2=X3 X1+X4=X5 X3*X5=X7).\n%total {} (union-left-distributes-over-intersection _ _ _ _ _ _ _).\n\n\n%theorem union-right-factors-over-intersection :\n\tforall* {X1} {X2} {X4} {X5} {X6} {X7}\n        forall {M14:union X1 X4 X5} {M24:union X2 X4 X6} {A56:intersection X5 X6 X7}\n        exists {X3} {A12:intersection X1 X2 X3} {M34:union X3 X4 X7}\n\ttrue.\n- : union-right-factors-over-intersection X1+X4=X5 X2+X4=X6 X5*X6=X7 X3 X1*X2=X3 X3+X4=X7\n    <- intersection-total X1*X2=X3\n    <- union-total X3+X4=Y7\n    <- union-right-distributes-over-intersection* X1*X2=X3 X3+X4=Y7 X1+X4=X5 X2+X4=X6 \n                                       X5*X6=Y7\n    <- intersection-deterministic X5*X6=Y7 X5*X6=X7 eq/ eq/ Y7=X7\n    <- union-respects-eq X3+X4=Y7 eq/ eq/ Y7=X7 X3+X4=X7.\n\n%worlds () (union-right-factors-over-intersection X1+X4=X5 X2+X4=X6 X5*X6=X7\n                                 X3 X1*X2=X3 X3+X4=X7 ).\n%total {} (union-right-factors-over-intersection _ _ _ _ _ _).\n\n\n%theorem union-right-factors-over-intersection* :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X6} {X7}\n        forall {M14:union X1 X4 X5} {M24:union X2 X4 X6} {A56:intersection X5 X6 X7}\n               {A12:intersection X1 X2 X3} \n        exists {M34:union X3 X4 X7}\n\ttrue.\n\n- : union-right-factors-over-intersection* X1+X4=X5 X2+X4=X6 X5*X6=X7 X1*X2=X3 X3+X4=X7\n    <- union-total X3+X4=Y7\n    <- union-right-distributes-over-intersection* X1*X2=X3 X3+X4=Y7 X1+X4=X5 X2+X4=X6 \n                                       X5*X6=Y7\n    <- intersection-deterministic X5*X6=Y7 X5*X6=X7 eq/ eq/ Y7=X7\n    <- union-respects-eq X3+X4=Y7 eq/ eq/ Y7=X7 X3+X4=X7.\n\n%worlds () (union-right-factors-over-intersection* X1+X4=X5 X2+X4=X6 X5*X6=X7 X1*X2=X3\n                                  X3+X4=X7 ).\n%total {} (union-right-factors-over-intersection* _ _ _ _ _).\n\n\n%theorem union-left-factors-over-intersection :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X7}\n\tforall {M12:union X1 X2 X3} {M14:union X1 X4 X5} {A35:intersection X3 X5 X7}\n        exists {X6} {A24:intersection X2 X4 X6} {M16:union X1 X6 X7}\n        true.\n\n- : union-left-factors-over-intersection X1+X2=X3 X1+X4=X5 X3*X5=X7 X6 X2*X4=X6 X1+X6=X7\n    <- union-commutative X1+X2=X3 X2+X1=X3\n    <- union-commutative X1+X4=X5 X4+X1=X5\n    <- union-right-factors-over-intersection X2+X1=X3 X4+X1=X5 X3*X5=X7 X6 X2*X4=X6 X6+X1=X7\n    <- union-commutative X6+X1=X7 X1+X6=X7.\n\n%worlds () (union-left-factors-over-intersection X1+X2=X3 X1+X4=X5 X3*X5=X7\n                                X6 X2*X4=X6 X1+X6=X7).\n%total {} (union-left-factors-over-intersection _ _ _ _ _ _).\n\n\n%theorem union-left-factors-over-intersection* :\n\tforall* {X1} {X2} {X3} {X4} {X5} {X6} {X7}\n\tforall {M12:union X1 X2 X3} {M14:union X1 X4 X5} \n               {A35:intersection X3 X5 X7} {A24:intersection X2 X4 X6} \n        exists {M16:union X1 X6 X7}\n        true.\n\n- : union-left-factors-over-intersection* X1+X2=X3 X1+X4=X5 X3*X5=X7 X2*X4=X6 \n                               X1+X6=X7\n    <- union-total X1+X6=Y7\n    <- union-left-distributes-over-intersection* X2*X4=X6 X1+X6=Y7 X1+X2=X3 X1+X4=X5\n                                      X3*X5=Y7\n    <- intersection-deterministic X3*X5=Y7 X3*X5=X7 eq/ eq/ Y7=X7\n    <- union-respects-eq X1+X6=Y7 eq/ eq/ Y7=X7 X1+X6=X7.\n\n%worlds () (union-left-factors-over-intersection* X1+X2=X3 X1+X4=X5 X3*X5=X7 X2*X4=X6 \n                                X1+X6=X7).\n%total {} (union-left-factors-over-intersection* _ _ _ _ _).\n\n\n \n\n%%%% Redefinitions\n\n\n\n%abbrev multiset = map.\n%abbrev multiset/0 = map/0.\n%abbrev multiset/+ = map/+.\n\n\n%abbrev member = [S] [N] lookup S N C.\n\n\n%%% Theorem renamings.\n\n%% using \"member\"\n\n%abbrev false-implies-member = false-implies-lookup.\n%abbrev not-member-member-implies-ne = not-member-lookup-not-equal.\n%abbrev in-implies-member = in-implies-lookup.\n\n%abbrev member-respects-eq = \n    [L:member M N] [EM:eq M MP] [EN:nat`eq N NP] [LP:member MP NP] \n    lookup-respects-eq L EM EN nat`eq/ LP.\n\n\n\n\n\n%abbrev multiset`map = map.\n%abbrev multiset`map/0 = map/0.\n%abbrev multiset`map/+ = map/+.\n%abbrev multiset`eq = eq.\n%abbrev multiset`eq/ = eq/.\n%abbrev multiset`ne = ne.\n%abbrev multiset`ne/L = ne/L.\n%abbrev multiset`ne/R = ne/R.\n%abbrev multiset`ne/N = ne/N.\n%abbrev multiset`ne/D = ne/D.\n%abbrev multiset`ne/+ = ne/+.\n%abbrev multiset`eq? = eq?.\n%abbrev multiset`eq?/yes = eq?/yes.\n%abbrev multiset`eq?/no = eq?/no.\n%abbrev multiset`lookup = lookup.\n%abbrev multiset`lookup/= = lookup/=.\n%abbrev multiset`lookup/> = lookup/>.\n%abbrev multiset`not-member = not-member.\n%abbrev multiset`not-member/0 = not-member/0.\n%abbrev multiset`not-member/< = not-member/<.\n%abbrev multiset`not-member/> = not-member/>.\n%abbrev multiset`member? = member?.\n%abbrev multiset`member?/in = member?/in.\n%abbrev multiset`member?/out = member?/out.\n%abbrev multiset`disjoint = disjoint.\n%abbrev multiset`disjoint/L = disjoint/L.\n%abbrev multiset`disjoint/R = disjoint/R.\n%abbrev multiset`disjoint/< = disjoint/<.\n%abbrev multiset`disjoint/> = disjoint/>.\n%abbrev multiset`disjoint? = disjoint?.\n%abbrev multiset`disjoint?/yes = disjoint?/yes.\n%abbrev multiset`disjoint?/no = disjoint?/no.\n%abbrev multiset`size = size.\n%abbrev multiset`size/0 = size/0.\n%abbrev multiset`size/+ = size/+.\n%abbrev multiset`bound = bound.\n%abbrev multiset`bound/0 = bound/0.\n%abbrev multiset`bound/+ = bound/+.\n%abbrev multiset`shift = shift.\n%abbrev multiset`shift/0 = shift/0.\n%abbrev multiset`shift/+ = shift/+.\n%abbrev multiset`update = update.\n%abbrev multiset`update/0 = update/0.\n%abbrev multiset`update/= = update/=.\n%abbrev multiset`update/< = update/<.\n%abbrev multiset`update/> = update/>.\n%abbrev multiset`meta-eq = meta-eq.\n%abbrev multiset`false-implies-eq = false-implies-eq.\n%abbrev multiset`eq-reflexive = eq-reflexive.\n%abbrev multiset`eq-symmetric = eq-symmetric.\n%abbrev multiset`eq-transitive = eq-transitive.\n%abbrev multiset`map/+-preserves-eq = map/+-preserves-eq.\n%abbrev multiset`map/+-preserves-eq-converse = map/+-preserves-eq-converse.\n%abbrev multiset`eq-no-occur = eq-no-occur.\n%abbrev multiset`eq-contradiction = eq-contradiction.\n%abbrev multiset`false-implies-ne = false-implies-ne.\n%abbrev multiset`ne-respects-eq = ne-respects-eq.\n%abbrev multiset`ne-anti-reflexive = ne-anti-reflexive.\n%abbrev multiset`ne-symmetric = ne-symmetric.\n%abbrev multiset`eq-ne-implies-false = eq-ne-implies-false.\n%abbrev multiset`eq?-total* = eq?-total*.\n%abbrev multiset`eq?-total = eq?-total.\n%abbrev multiset`eq?-total/+ = eq?-total/+.\n%abbrev multiset`false-implies-lookup = false-implies-lookup.\n%abbrev multiset`lookup-respects-eq = lookup-respects-eq.\n%abbrev multiset`lookup-deterministic = lookup-deterministic.\n%abbrev multiset`lookup-contradiction = lookup-contradiction.\n%abbrev multiset`lookup-one-choice = lookup-one-choice.\n%abbrev multiset`lookup-ne-implies-ne = lookup-ne-implies-ne.\n%abbrev multiset`lookup-ne-implies-ne/L = lookup-ne-implies-ne/L.\n%abbrev multiset`false-implies-not-member = false-implies-not-member.\n%abbrev multiset`not-member-respects-eq = not-member-respects-eq.\n%abbrev multiset`not-member-total* = not-member-total*.\n%abbrev multiset`not-member-total = not-member-total.\n%abbrev multiset`not-member-lookup-not-equal = not-member-lookup-not-equal.\n%abbrev multiset`not-member-contradiction = not-member-contradiction.\n%abbrev multiset`ne-implies-unit-map-not-member = ne-implies-unit-map-not-member.\n%abbrev multiset`plus-right-preserves-not-member* = plus-right-preserves-not-member*.\n%abbrev multiset`not-member-lookup-implies-ne = not-member-lookup-implies-ne.\n%abbrev multiset`not-member-lookup-implies-ne/L = not-member-lookup-implies-ne/L.\n%abbrev multiset`false-implies-member? = false-implies-member?.\n%abbrev multiset`member?-respects-eq = member?-respects-eq.\n%abbrev multiset`member?-deterministic = member?-deterministic.\n%abbrev multiset`member?-total* = member?-total*.\n%abbrev multiset`member?-map/+-total = member?-map/+-total.\n%abbrev multiset`member?-map/+-complete = member?-map/+-complete.\n%abbrev multiset`member?-total = member?-total.\n%abbrev multiset`in-implies-lookup = in-implies-lookup.\n%abbrev multiset`out-implies-not-member = out-implies-not-member.\n%abbrev multiset`false-implies-disjoint = false-implies-disjoint.\n%abbrev multiset`disjoint-respects-eq = disjoint-respects-eq.\n%abbrev multiset`disjoint/=-contradiction = disjoint/=-contradiction.\n%abbrev multiset`disjoint/<-inversion = disjoint/<-inversion.\n%abbrev multiset`disjoint/>-inversion = disjoint/>-inversion.\n%abbrev multiset`disjoint-anti-reflexive = disjoint-anti-reflexive.\n%abbrev multiset`disjoint-symmetric = disjoint-symmetric.\n%abbrev multiset`disjoint-lookup-contradiction = disjoint-lookup-contradiction.\n%abbrev multiset`shift-left-preserves-disjoint = shift-left-preserves-disjoint.\n%abbrev multiset`shift-left-preserves-disjoint-converse = shift-left-preserves-disjoint-converse.\n%abbrev multiset`shift-right-preserves-disjoint = shift-right-preserves-disjoint.\n%abbrev multiset`shift-right-preserves-disjoint-converse = shift-right-preserves-disjoint-converse.\n%abbrev multiset`shift-preserves-disjoint = shift-preserves-disjoint.\n%abbrev multiset`shift-preserves-disjoint-converse = shift-preserves-disjoint-converse.\n%abbrev multiset`ne-implies-disjoint = ne-implies-disjoint.\n%abbrev multiset`false-implies-size = false-implies-size.\n%abbrev multiset`size-total* = size-total*.\n%abbrev multiset`size-total = size-total.\n%abbrev multiset`size-deterministic = size-deterministic.\n%abbrev multiset`false-implies-bound = false-implies-bound.\n%abbrev multiset`bound-total* = bound-total*.\n%abbrev multiset`bound-total = bound-total.\n%abbrev multiset`ge-bound-implies-not-member = ge-bound-implies-not-member.\n%abbrev multiset`false-implies-shift = false-implies-shift.\n%abbrev multiset`shift-respects-eq = shift-respects-eq.\n%abbrev multiset`shift-total* = shift-total*.\n%abbrev multiset`shift-total = shift-total.\n%abbrev multiset`shift-deterministic = shift-deterministic.\n%abbrev multiset`shifts-add = shifts-add.\n%abbrev multiset`shifts-add-converse = shifts-add-converse.\n%abbrev multiset`shift-preserves-not-member-converse* = shift-preserves-not-member-converse*.\n%abbrev multiset`shift-preserves-lookup = shift-preserves-lookup.\n%abbrev multiset`shift-preserves-lookup* = shift-preserves-lookup*.\n%abbrev multiset`shift-preserves-lookup-converse = shift-preserves-lookup-converse.\n%abbrev multiset`shift-preserves-lookup-converse* = shift-preserves-lookup-converse*.\n%abbrev multiset`shift-preserves-size = shift-preserves-size.\n%abbrev multiset`disjoint?-total* = disjoint?-total*.\n%abbrev multiset`disjoint?-total*/+ = disjoint?-total*/+.\n%abbrev multiset`disjoint?-total*/< = disjoint?-total*/<.\n%abbrev multiset`disjoint?-total*/> = disjoint?-total*/>.\n%abbrev multiset`disjoint?-total = disjoint?-total.\n%abbrev multiset`false-implies-update = false-implies-update.\n%abbrev multiset`update-respects-eq = update-respects-eq.\n%abbrev multiset`update-eq = update-eq.\n%abbrev multiset`update-eq/ = update-eq/.\n%abbrev multiset`false-implies-update-eq = false-implies-update-eq.\n%abbrev multiset`meta-update-eq = meta-update-eq.\n%abbrev multiset`update/=-inversion = update/=-inversion.\n%abbrev multiset`update/<-inversion = update/<-inversion.\n%abbrev multiset`update/>-inversion = update/>-inversion.\n%abbrev multiset`update-deterministic = update-deterministic.\n%abbrev multiset`update-total* = update-total*.\n%abbrev multiset`update-map/+-total = update-map/+-total.\n%abbrev multiset`update-total = update-total.\n%abbrev multiset`lookup-implies-update = lookup-implies-update.\n%abbrev multiset`update-implies-lookup = update-implies-lookup.\n%abbrev multiset`update-preserves-lookup = update-preserves-lookup.\n%abbrev multiset`update-preserves-lookup-converse = update-preserves-lookup-converse.\n%abbrev multiset`update-preserves-not-member = update-preserves-not-member.\n%abbrev multiset`update-preserves-not-member-converse = update-preserves-not-member-converse.\n%abbrev multiset`update-preserves-not-member-converse-helper = update-preserves-not-member-converse-helper.\n%abbrev multiset`update-is-cause-of-change = update-is-cause-of-change.\n%abbrev multiset`update-is-cause-of-change/L = update-is-cause-of-change/L.\n%abbrev multiset`update-preserves-membership = update-preserves-membership.\n%abbrev multiset`update-preserves-membership-converse = update-preserves-membership-converse.\n%abbrev multiset`lookup-update-preserves-membership = lookup-update-preserves-membership.\n%abbrev multiset`lookup-update-preserves-membership/L = lookup-update-preserves-membership/L.\n%abbrev multiset`lookup-update-preserves-membership-converse = lookup-update-preserves-membership-converse.\n%abbrev multiset`update-preserves-in-member = update-preserves-in-member.\n%abbrev multiset`update-preserves-in-member/L = update-preserves-in-member/L.\n%abbrev multiset`shift-preserves-update = shift-preserves-update.\n%abbrev multiset`shift-preserves-update* = shift-preserves-update*.\n%abbrev multiset`shift-preserves-update-converse = shift-preserves-update-converse.\n%abbrev multiset`update-overwrites = update-overwrites.\n%abbrev multiset`update-overwrites-converse = update-overwrites-converse.\n%abbrev multiset`update-may-have-no-effect = update-may-have-no-effect.\n%abbrev multiset`update-idempotent = update-idempotent.\n%abbrev multiset`update-commutes = update-commutes.\n%abbrev multiset`update-commutes* = update-commutes*.\n%abbrev multiset`can-remove = can-remove.\n%abbrev multiset`leq = leq.\n%abbrev multiset`leq/0 = leq/0.\n%abbrev multiset`leq/= = leq/=.\n%abbrev multiset`leq/> = leq/>.\n%abbrev multiset`false-implies-leq = false-implies-leq.\n%abbrev multiset`leq-respects-eq = leq-respects-eq.\n%abbrev multiset`leq/0-inversion = leq/0-inversion.\n%abbrev multiset`leq/=-inversion = leq/=-inversion.\n%abbrev multiset`leq/>-inversion = leq/>-inversion.\n%abbrev multiset`leq-contradiction = leq-contradiction.\n%abbrev multiset`leq-reflexive = leq-reflexive.\n%abbrev multiset`leq-anti-symmetric = leq-anti-symmetric.\n%abbrev multiset`leq-transitive = leq-transitive.\n%abbrev multiset`map/+-preserves-leq = map/+-preserves-leq.\n%abbrev multiset`lookup-respects-leq = lookup-respects-leq.\n%abbrev multiset`not-member-respects-geq = not-member-respects-geq.\n%abbrev multiset`leq-implies-size-le = leq-implies-size-le.\n%abbrev multiset`leq-implies-bound-le = leq-implies-bound-le.\n%abbrev multiset`shift-left-preserves-leq* = shift-left-preserves-leq*.\n%abbrev multiset`shift-preserves-leq* = shift-preserves-leq*.\n%abbrev multiset`update-left-preserves-leq* = update-left-preserves-leq*.\n%abbrev multiset`update-right-preserves-leq* = update-right-preserves-leq*.\n%abbrev multiset`update-preserves-leq* = update-preserves-leq*.\n%abbrev multiset`not-member-update-implies-leq = not-member-update-implies-leq.\n%abbrev multiset`lookup-update-preserves-leq = lookup-update-preserves-leq.\n%abbrev multiset`union = union.\n%abbrev multiset`union/L = union/L.\n%abbrev multiset`union/R = union/R.\n%abbrev multiset`union/= = union/=.\n%abbrev multiset`union/< = union/<.\n%abbrev multiset`union/> = union/>.\n%abbrev multiset`false-implies-union = false-implies-union.\n%abbrev multiset`union-respects-eq = union-respects-eq.\n%abbrev multiset`union/=-inversion = union/=-inversion.\n%abbrev multiset`union/<-inversion = union/<-inversion.\n%abbrev multiset`union/>-inversion = union/>-inversion.\n%abbrev multiset`union-deterministic = union-deterministic.\n%abbrev multiset`union-total* = union-total*.\n%abbrev multiset`union-map/+-M-total* = union-map/+-M-total*.\n%abbrev multiset`union-M-map/+-total* = union-M-map/+-total*.\n%abbrev multiset`union-map/+-map/+-total* = union-map/+-map/+-total*.\n%abbrev multiset`union-total = union-total.\n%abbrev multiset`disjoint-union-total = disjoint-union-total.\n%abbrev multiset`union-empty-implies-empty = union-empty-implies-empty.\n%abbrev multiset`union-preserves-disjoint* = union-preserves-disjoint*.\n%abbrev multiset`union-preserves-disjoint*/L = union-preserves-disjoint*/L.\n%abbrev multiset`shift-left-preserves-union = shift-left-preserves-union.\n%abbrev multiset`shift-left-preserves-union-converse = shift-left-preserves-union-converse.\n%abbrev multiset`shift-right-preserves-union = shift-right-preserves-union.\n%abbrev multiset`shift-right-preserves-union-converse = shift-right-preserves-union-converse.\n%abbrev multiset`shift-preserves-union = shift-preserves-union.\n%abbrev multiset`shift-preserves-union-converse = shift-preserves-union-converse.\n%abbrev multiset`union-commutative = union-commutative.\n%abbrev multiset`union-associative = union-associative.\n%abbrev multiset`union-associative-union/<-union/< = union-associative-union/<-union/<.\n%abbrev multiset`union-associative* = union-associative*.\n%abbrev multiset`union-associative-converse = union-associative-converse.\n%abbrev multiset`union-associative-converse* = union-associative-converse*.\n%abbrev multiset`union-assoc-commutative* = union-assoc-commutative*.\n%abbrev multiset`union-assoc-commutative = union-assoc-commutative.\n%abbrev multiset`union-double-associative* = union-double-associative*.\n%abbrev multiset`union-double-associative = union-double-associative.\n%abbrev multiset`lookup-implies-union = lookup-implies-union.\n%abbrev multiset`union-joins-lookup = union-joins-lookup.\n%abbrev multiset`union-preserves-not-member* = union-preserves-not-member*.\n%abbrev multiset`not-member-union-left-preserves-lookup* = not-member-union-left-preserves-lookup*.\n%abbrev multiset`not-member-union-left-preserves-lookup-converse = not-member-union-left-preserves-lookup-converse.\n%abbrev multiset`not-member-union-left-preserves-lookup-converse/L = not-member-union-left-preserves-lookup-converse/L.\n%abbrev multiset`union-left-affects-lookup = union-left-affects-lookup.\n%abbrev multiset`union-left-affects-lookup/L = union-left-affects-lookup/L.\n%abbrev multiset`not-member-union-right-preserves-lookup* = not-member-union-right-preserves-lookup*.\n%abbrev multiset`not-member-union-right-preserves-lookup-converse = not-member-union-right-preserves-lookup-converse.\n%abbrev multiset`not-member-union-right-preserves-lookup-converse/L = not-member-union-right-preserves-lookup-converse/L.\n%abbrev multiset`union-right-affects-lookup = union-right-affects-lookup.\n%abbrev multiset`union-right-affects-lookup/L = union-right-affects-lookup/L.\n%abbrev multiset`union-preserves-not-member-converse* = union-preserves-not-member-converse*.\n%abbrev multiset`union-preserves-not-member-converse/L = union-preserves-not-member-converse/L.\n%abbrev multiset`disjoint-union-left-preserves-lookup* = disjoint-union-left-preserves-lookup*.\n%abbrev multiset`disjoint-union-left-preserves-lookup*/L = disjoint-union-left-preserves-lookup*/L.\n%abbrev multiset`disjoint-union-right-preserves-lookup* = disjoint-union-right-preserves-lookup*.\n%abbrev multiset`disjoint-union-right-preserves-lookup*/L = disjoint-union-right-preserves-lookup*/L.\n%abbrev multiset`union-implies-leq* = union-implies-leq*.\n%abbrev multiset`union-implies-leq = union-implies-leq.\n%abbrev multiset`union-is-lub = union-is-lub.\n%abbrev multiset`union-idempotent = union-idempotent.\n%abbrev multiset`leq-implies-union = leq-implies-union.\n%abbrev multiset`disjoint-leq-implies-union-leq* = disjoint-leq-implies-union-leq*.\n%abbrev multiset`union-left-preserves-leq* = union-left-preserves-leq*.\n%abbrev multiset`union-right-preserves-leq* = union-right-preserves-leq*.\n%abbrev multiset`intersection = intersection.\n%abbrev multiset`intersection/L = intersection/L.\n%abbrev multiset`intersection/R = intersection/R.\n%abbrev multiset`intersection/= = intersection/=.\n%abbrev multiset`intersection/< = intersection/<.\n%abbrev multiset`intersection/> = intersection/>.\n%abbrev multiset`false-implies-intersection = false-implies-intersection.\n%abbrev multiset`intersection-respects-eq = intersection-respects-eq.\n%abbrev multiset`intersection/L-inversion = intersection/L-inversion.\n%abbrev multiset`intersection/R-inversion = intersection/R-inversion.\n%abbrev multiset`intersection/=-inversion = intersection/=-inversion.\n%abbrev multiset`intersection/<-inversion = intersection/<-inversion.\n%abbrev multiset`intersection/>-inversion = intersection/>-inversion.\n%abbrev multiset`intersection-implies-ge = intersection-implies-ge.\n%abbrev multiset`intersection-deterministic = intersection-deterministic.\n%abbrev multiset`intersection-total* = intersection-total*.\n%abbrev multiset`intersection-map/+-M-total* = intersection-map/+-M-total*.\n%abbrev multiset`intersection-M-map/+-total* = intersection-M-map/+-total*.\n%abbrev multiset`intersection-map/+-map/+-total* = intersection-map/+-map/+-total*.\n%abbrev multiset`intersection-total = intersection-total.\n%abbrev multiset`intersection-commutative = intersection-commutative.\n%abbrev multiset`shift-left-preserves-intersection = shift-left-preserves-intersection.\n%abbrev multiset`shift-left-preserves-intersection-converse = shift-left-preserves-intersection-converse.\n%abbrev multiset`shift-right-preserves-intersection = shift-right-preserves-intersection.\n%abbrev multiset`shift-right-preserves-intersection-converse = shift-right-preserves-intersection-converse.\n%abbrev multiset`shift-preserves-intersection = shift-preserves-intersection.\n%abbrev multiset`shift-preserves-intersection-converse = shift-preserves-intersection-converse.\n%abbrev multiset`intersection-associativeM = intersection-associativeM.\n%abbrev multiset`intersection-associativeM* = intersection-associativeM*.\n%abbrev multiset`intersection-associative = intersection-associative.\n%abbrev multiset`intersection-associative* = intersection-associative*.\n%abbrev multiset`intersection-associative-converse = intersection-associative-converse.\n%abbrev multiset`intersection-associative-converse* = intersection-associative-converse*.\n%abbrev multiset`intersection-assoc-commutative* = intersection-assoc-commutative*.\n%abbrev multiset`intersection-assoc-commutative = intersection-assoc-commutative.\n%abbrev multiset`intersection-double-associative* = intersection-double-associative*.\n%abbrev multiset`intersection-double-associative = intersection-double-associative.\n%abbrev multiset`intersection-implies-leq* = intersection-implies-leq*.\n%abbrev multiset`intersection-implies-leq = intersection-implies-leq.\n%abbrev multiset`intersection-is-glb = intersection-is-glb.\n%abbrev multiset`intersection-idempotent = intersection-idempotent.\n%abbrev multiset`leq-implies-intersection = leq-implies-intersection.\n%abbrev multiset`intersection-left-preserves-leq* = intersection-left-preserves-leq*.\n%abbrev multiset`intersection-right-preserves-leq* = intersection-right-preserves-leq*.\n%abbrev multiset`intersection-right-distributes-over-union = intersection-right-distributes-over-union.\n%abbrev multiset`intersection-right-distributes-over-union* = intersection-right-distributes-over-union*.\n%abbrev multiset`intersection-left-distributes-over-union* = intersection-left-distributes-over-union*.\n%abbrev multiset`intersection-left-distributes-over-union = intersection-left-distributes-over-union.\n%abbrev multiset`intersection-right-factors-over-union* = intersection-right-factors-over-union*.\n%abbrev multiset`intersection-left-factors-over-union* = intersection-left-factors-over-union*.\n%abbrev multiset`count = count.\n%abbrev multiset`count/s = count/s.\n%abbrev multiset`count/z = count/z.\n%abbrev multiset`add = add.\n%abbrev multiset`add/0 = add/0.\n%abbrev multiset`add/+ = add/+.\n%abbrev multiset`false-implies-count = false-implies-count.\n%abbrev multiset`count-respects-eq = count-respects-eq.\n%abbrev multiset`count-total** = count-total**.\n%abbrev multiset`count-total* = count-total*.\n%abbrev multiset`count-total = count-total.\n%abbrev multiset`count-deterministic = count-deterministic.\n%abbrev multiset`count-empty-is-zero = count-empty-is-zero.\n%abbrev multiset`false-implies-add = false-implies-add.\n%abbrev multiset`add-respects-eq = add-respects-eq.\n%abbrev multiset`add-total* = add-total*.\n%abbrev multiset`add-total = add-total.\n%abbrev multiset`add-total/L = add-total/L.\n%abbrev multiset`add-deterministic = add-deterministic.\n%abbrev multiset`add-commutes = add-commutes.\n%abbrev multiset`add-commutes/L = add-commutes/L.\n%abbrev multiset`count-add-implies-count = count-add-implies-count.\n%abbrev multiset`add-preserves-count = add-preserves-count.\n%abbrev multiset`add-preserves-count-converse = add-preserves-count-converse.\n%abbrev multiset`shift-preserves-count-converse = shift-preserves-count-converse.\n%abbrev multiset`shift-preserves-add-converse = shift-preserves-add-converse.\n%abbrev multiset`union-right-distributes-over-intersection = union-right-distributes-over-intersection.\n%abbrev multiset`union-right-distributes-over-intersection* = union-right-distributes-over-intersection*.\n%abbrev multiset`union-left-distributes-over-intersection* = union-left-distributes-over-intersection*.\n%abbrev multiset`union-left-distributes-over-intersection = union-left-distributes-over-intersection.\n%abbrev multiset`union-right-factors-over-intersection = union-right-factors-over-intersection.\n%abbrev multiset`union-right-factors-over-intersection* = union-right-factors-over-intersection*.\n%abbrev multiset`union-left-factors-over-intersection = union-left-factors-over-intersection.\n%abbrev multiset`union-left-factors-over-intersection* = union-left-factors-over-intersection*.\n%abbrev multiset`multiset = multiset.\n%abbrev multiset`multiset/0 = multiset/0.\n%abbrev multiset`multiset/+ = multiset/+.\n%abbrev multiset`member = member.\n%abbrev multiset`false-implies-member = false-implies-member.\n%abbrev multiset`not-member-member-implies-ne = not-member-member-implies-ne.\n%abbrev multiset`in-implies-member = in-implies-member.\n%abbrev multiset`member-respects-eq = member-respects-eq.\n\n\n\n\n%{ == Definitions == }%\n\n\n\n%{ === The syntax === }%\n\n%{\nHere we define multi-arity functions that are typed to avoid \ntype errors (hence, no higher-order functions in the syntax --\nbut see \"rec\" which is the typed Y combinator).  This syntax is\nrather impoverished, but it would be fairly easily to add \"succ\",\n\"ifzero\" terms.  By \"easy\", I mean the addition would cause no new \ntechnical issues.  It would still change al he arithmetic parts of\nthe proofs dramatically.  For this reason, I would like to\nimplement a tool that would generate such proofs for any HOAS family\nof terms.\n}%\n\n\nterm : nat -> type.\n\n%abbrev t = term z.\n\n\nlit : nat -> t.\n\napp : term (s N) -> t -> term N.\n\nlam : (t -> term N) -> term (s N).\n\nrec : (term (s N) -> term (s N)) -> term (s N).\n\n\n\n%block blocksimple : some {n} block {v:term n}.\n\n\n\n%{ === Equality === }%\n\n\neq : term N1 -> term N2 -> type.\n\n\neq/ : eq T T.\n\n\n\n%{ === Variable levels === }%\n\n%{\nAs with the non-indexed case, \na variable level is the (nonzero) natural number for a variable.\nBut unlike before 'varlevel' is now an abbreviation for a more\ncomplex relation that permits adjustment of the index level.\n}%\n\n\nvaradjlevel : term N -> nat -> nat -> type.\n\n\n%abbrev varlevel : term N -> nat -> type = [T] [L] varadjlevel T N L.\n\n\n%block blockvar : some {n} {l} block {v:term n} {vl:varlevel v (s l)}.\n\n\n\n%{ === Mapping === }%\n\n%{\nThe bijection from terms to nat is called \"tonat\".    There\nis a separate mapping for each index, which makes sense\nbecaue each index represents a different type.\nUnlike the non-indexed case, we need to handle an unbounded\nnumber of different types of variables, so we can't just pass\none extra int, or even a fixed number of ints.  Instead we need\nto pass a structure that represents an unbounded number of ints.\nWe use `multiset' to represent this structure.  The elements of the \nmultiset represent the levels that came \"before\".\n\nAnother interesting aspect is that not all constructors for the \nindexed type are available for all indices.  For instane `lit' is\nonly for the 0-index and rec only for non-zero indices.  On the other\nhand, `app' can occur for any index.  Since the mapping is separate\nfor every index, and the mapping must be one-to-one as well as onto, \nwe must work carefully that every natural number is mapped onto exactly \nonce.  Variables are handled (as before) by reserving the first VN spots \nfor variables, where (unlike before) VN depends on the index.  \nIgnoring variables, `lit' takes the veen numbers and `app' takes the odd\nnumbers for the 0-indexed terms.  For the nonzero-indexed terms, app\ntakes the odd numbers (of course) and lam and rec share the even numbers.\n}%\n\n\ntonat* : {N} multiset -> term N -> nat -> type.\n\n%abbrev tonat = tonat* _ multiset/0.\n\n\ntonat/var : \n\tcount MS N VN ->\n\tvarlevel V L ->\n\tplus M L VN ->\n    tonat* N MS V M.\n\t\ntonat/lit :\n\tcount MS z VN ->\n\ttimes (s (s z)) M TM ->\n\tplus VN TM M' ->\n    tonat* z MS (lit M) M'.\n\ntonat/app :\n\tcount MS N VN ->\n\ttonat* _ MS T1 M1 ->\n        tonat* _ MS T2 M2 ->\n        natpair`pair2nat (natpair/ M1 M2) M ->\n\ttimes (s (s z)) M TM ->\n\tplus VN (s TM) M' ->\n    tonat* N MS (app T1 T2) M'.\n\ntonat/lam :\n\tcount MS (s N) VN ->\n\tcount MS z ZN ->\n\tmultiset`add MS z MS' ->\n\t({v:term z} (varlevel v (s ZN)) ->\n         tonat* N MS' (F v) M) ->\n\ttimes (s (s (s (s z)))) M TM ->\n\tplus VN TM M' ->\n    tonat* (s N) MS (lam F) M'.\n\ntonat/rec :\n\tcount MS (s N) VN ->\n\tmultiset`add MS (s N) MS' ->\n\t({f} (varlevel f (s VN)) ->\n         tonat* (s N) MS' (F f) M) ->\n\ttimes (s (s (s (s z)))) M TM ->\n\tplus VN (s (s TM)) M' ->\n    tonat* (s N) MS (rec F) M'.\n\n\n\n%{ === Utility lemmas === }%\n\n%{\nThe following theorems prove obvious simple things about the\nbasic relations.  They following the conventions established in\nJohn Boyland's library signatures.\n}%\n\n\n%theorem false-implies-eq :\n\tforall* {N1} {N2} {T1:term N1} {T2:term N2}\n\tforall\t{F:void}\n\texists\t{EQ:eq T1 T2}\n\ttrue.\n\n%worlds (blocksimple) (false-implies-eq _ _).\n%total { }  (false-implies-eq _ _).\n\n\n%theorem false-implies-varlevel :\n\tforall*\t{N} {V:term N} {L}\n\tforall\t{F:void}\n\texists\t{VL:varlevel V L}\n\ttrue.\n\n%worlds (blocksimple | blockvar) (false-implies-varlevel _ _).\n%total { } (false-implies-varlevel _ _).\n\n\n%theorem varlevel-respects-eq :\n\tforall* {N} {V:term N} {L1} {L2}\n\tforall\t{VL1:varlevel V L1}\n\t\t{E:nat`eq L1 L2}\n\texists\t{VL2:varlevel V L2}\n\ttrue.\n\n- : varlevel-respects-eq VL nat`eq/ VL.\n\n%worlds (blocksimple | blockvar) (varlevel-respects-eq _ _ _).\n%total { } (varlevel-respects-eq _ _ _).\n\n\n%theorem false-implies-tonat :\n\tforall* {N} {MS} {T} {M}\n\tforall\t{F:void}\n\texists\t{TN:tonat* N MS T M}\n\ttrue.\n\n%worlds (blocksimple | blockvar) (false-implies-tonat _ _).\n%total { } (false-implies-tonat _ _).\n\n\n%theorem tonat-respects-eq :\n\tforall* {N1} {MS1} {T1} {M1}\n\t\t{N2} {MS2} {T2} {M2}\n\tforall\t{TN1:tonat* N1 MS1 T1 M1}\n\t\t{EM: multiset`eq MS1 MS2}\n\t\t{ET: eq T1 T2}\n\t\t{EN: nat`eq M1 M2}\n\texists\t{TN2: tonat* N2 MS2 T2 M2}\n\ttrue.\n\n- : tonat-respects-eq TN multiset`eq/ eq/ nat`eq/ TN.\n\n%worlds (blocksimple | blockvar) (tonat-respects-eq _ _ _ _ _).\n%total { } (tonat-respects-eq _ _ _ _ _).\n\n\n\n\n%{ == Proof of totality of tonat == }%\n\n%{\nAs with the non-indexed case, proving totality is\nsurprisingly tricky.  The problem is that when we get to\na variable, we need to make sure that (1) the variable\nhas a level associated with it and (2) the level is \nin the range 1..VN where VN is the number of variables\nof this index that have been seen in the context.\nTwelf's blocks are useful for (1) but not for (2) because there's\nno way to connect the context with the current nesting level.\n\nFor this proof, I generalized/extended the \"case\" technique\nto handle indexed variables.  The proof is almost the same.\nThe multisets add extra paremeters but the basic structure is the same.\n}%\n\n\n\n%{ === Auxiliary definitions === }%\n\n\n%{ ==== raw variables ==== }%\n\n%{\nA variable is raw if we haven't verified that it has a level in range.\nNon variables are not raw.\n}%\n\nisraw* : {N} term N -> bool -> type.\n\n%abbrev israw = israw* _.\n\n%abbrev rawvar = [T] israw T true.\n\n\nisraw/lit : israw (lit _) false.\n\nisraw/app : israw (app _ _) false.\n\nisraw/lam : israw (lam _) false.\n\nisraw/rec : israw (rec _) false.\n\n\n%{ ==== case analysis ==== }%\n\n%{\nWe case analysis terms with two cases for variables.\nThe raw case is used only internally and can be ignored in\n\"clients\" that don't use israw.\n}%\n\ncase* : {N} multiset -> term N -> type.\n\n%abbrev case = case* _.\n\n\ncase/lit : case _ (lit _).\n\ncase/app : case MS T1 -> case MS T2 -> case MS (app T1 T2).\n\ncase/lam :\n\tcount MS z VN ->\n\tadd MS z MS' ->\n\t({v} varlevel v (s VN) -> \n\t case MS' (F v)) -> \n    case MS (lam F).\n\ncase/rec :\n\tcount MS (s N) VN ->\n\tmultiset`add MS (s N) MS' ->\n\t({f} varlevel f (s VN) ->\n\t case MS' (F f)) ->\n    case* (s N) MS (rec F).\n\ncase/var : \n\tcount MS N VN ->\n\tvarlevel V FL ->\n\tnat`ge VN FL -> \n    case* N MS V.\n\ncase/raw : rawvar V -> case _ V.\n\n\n\n%{ === Theorems about auxiliary definitions === }%\n\n\n\n%theorem israw-total* :\n\tforall* {N}\n\tforall\t{T:term N}\n\texists\t{B} {I:israw T B}\n\ttrue.\n\n%abbrev israw-total = israw-total* _ _.\n\n- : israw-total israw/lit.\n\n- : israw-total israw/app.\n\n- : israw-total israw/lam.\n\n- : israw-total israw/rec.\n\nfake : type.\n- : fake <- {i:israw-total* T B I} israw-total* T' B' I'.\n- : fake <- {i:israw-total* T B I} israw T' B'.\n\n%block blockraw : some {n} block {v:term n} {rv:rawvar v} {irt:israw-total rv}.\n\n%worlds (blockraw) (israw-total* _ _ _).\n%total { } (israw-total* _ _ _).\n\n\n%{\nThe following theorem handles one variable converting it from raw to\nhandle a level that is in the required range.  This is an important\ntechnique for handle variables in Twelf: one at a time.  Unlike the\none2one theorem (see later), we don't have to do extraordinary things\nto handle having multiple types.  (Although we do need some extra lemmas\nto ahndle facts about multisets.)\n}%\n\n%theorem var-gets-level :\n\tforall* {M} {N} {VN} {T:term M -> term N} {L} {MS}\n\tforall\t{F: {v:term M} {rv:rawvar v} {i:israw-total rv} \n\t            case MS (T v)}\n\t\t{MC: count MS M VN}\n\t\t{GE: nat`ge VN L}\n\texists  {F': {v:term M} (varlevel v L) -> case MS (T v)}\n\ttrue.\n\n- : var-gets-level ([f] [r] [i] (case/raw r)) MC GE\n                   ([f] [fl] (case/var MC fl GE)).\n\n- : var-gets-level ([f] [r] [i] (case/raw R)) _ _\n                   ([f] [fl] (case/raw R)).\n\n- : var-gets-level ([f] [r] [i] (case/var MC VL GE)) _ _\n                   ([f] [fl] (case/var MC VL GE)).\n\n- : var-gets-level ([f] [r] [i] (case/lit: case MS (lit O))) _ _\n                   ([f] [fl] (case/lit)).\n\n- : var-gets-level ([f] [r] [i] (case/app (C1 f r i) (C2 f r i))) MC GE\n                   ([f] [fl] (case/app (C1' f fl) (C2' f fl)))\n    <- var-gets-level C1 MC GE C1'\n    <- var-gets-level C2 MC GE C2'.\n\n%theorem var-gets-level/L :\n\tforall* {MS} {N1} {FN1} {N2} {FN2} {MS'} {L1} {B}\n\tforall\t{MC1: multiset`count MS N1 FN1}\n\t\t{MC2: multiset`count MS N2 FN2}\n\t\t{MA2: multiset`add MS N2 MS'}\n\t\t{GE: nat`ge FN1 L1}\n\t\t{EQ?: nat`eq? N1 N2 B}\n\texists\t{FN1'}\n\t\t{MC1': multiset`count MS' N1 FN1'}\n\t\t{GE': nat`ge FN1' L1}\n\ttrue.\n\n- : var-gets-level/L MC _ MA FN>=L nat`eq?/yes _ MC' (ge/> FN+1>L)\n    <- ge-implies-succ-gt FN>=L FN+1>L\n    <- multiset`count-add-implies-count MC MA MC'.\n\n- : var-gets-level/L MC1 _ MA2 GE (nat`eq?/no N1<>N2) _ MC1' GE\n    <- multiset`add-preserves-count MC1 MA2 N1<>N2 MC1'.\n\n%worlds () (var-gets-level/L _ _ _ _ _ _ _ _).\n%total { } (var-gets-level/L _ _ _ _ _ _ _ _).\n\n- : var-gets-level \n\t([f] [r] [i] (case/lam MS^0=FN' MSU ([v] [vl] C v vl f r i))) MC GE\n        ([f] [fl]    (case/lam MS^0=FN' MSU ([v] [vl] C' v vl f fl)))\n    <- nat`eq?-total EQ?\n    <- var-gets-level/L MC MS^0=FN' MSU GE EQ? _ MC' GE'\n    <- ({v} {vl:varlevel v _} (var-gets-level (C v vl) MC' GE' (C' v vl))).\n\n- : var-gets-level \n\t([f] [r] [i] (case/rec MS^N'=FN' MSU ([f'] [fl'] (C f' fl' f r i))))\n        MS^N=FN FN>=L \n        ([f] [fl] (case/rec MS^N'=FN' MSU ([f'] [fl'] (C' f' fl' f fl))))\n    <- nat`eq?-total EQ?\n    <- var-gets-level/L MS^N=FN MS^N'=FN' MSU FN>=L EQ? _ MS'^N=FN'' FN''>=L\n    <- ({f'} {fl'} (var-gets-level (C f' fl') MS'^N=FN'' FN''>=L (C' f' fl'))).\n\n%worlds (blockvar | blockraw) (var-gets-level _ _ _ _).\n%total F (var-gets-level F _ _ _).\n\n\n%{\nWe are now ready to prove that we can always \"case\" a term.\nThis works almost the same as for non-indexed terms.\n}%\n\n%theorem case-total* :\n\tforall* {N}\n\tforall\t{T:term N}\n\texists\t{C:case multiset/0 T}\n\ttrue.\n\n%abbrev case-total = case-total* _.\n\n%theorem case-total/L :\n\tforall* {B} {N} {MS}\n\tforall\t{T:term N} {I:israw T B}\n\texists\t{C:case MS T}\n\ttrue.\n\n- : case-total/L _ _ (case/lit).\n\n- : case-total/L _ _ (case/app C1 C2)\n    <- israw-total I1\n    <- case-total/L _ I1 C1\n    <- israw-total I2\n    <- case-total/L _ I2 C2.\n\n- : case-total/L _ _ (case/lam MC MA ([f] [fl] (C' f fl)))\n    <- multiset`count-total MC\n    <- multiset`add-total MA\n    <- ({v} {r:rawvar v} {i:israw-total r}\n        israw-total (I v r i: israw _ B))\n    <- ({v} {r:rawvar v} {i:israw-total r} \n        case-total/L _ (I v r i) (C v r i))\n    <- multiset`count-add-implies-count MC MA MC'\n    <- var-gets-level C MC' (nat`ge/= nat`eq/) C'.\n\n- : case-total/L _ _ (case/rec MC MA ([f] [fl] (C' f fl)))\n    <- multiset`count-total MC\n    <- multiset`add-total MA\n    <- ({v} {r:rawvar v} {i:israw-total r}\n        israw-total (I v r i: israw _ B))\n    <- ({v} {r:rawvar v} {i:israw-total r} \n        case-total/L _ (I v r i) (C v r i))\n    <- multiset`count-add-implies-count MC MA MC'\n    <- var-gets-level C MC' (nat`ge/= nat`eq/) C'.\n\n- : case-total/L V R (case/raw R).\n\n%worlds (blockraw) (case-total/L _ _ _).\n%total T (case-total/L T _ _).\n\n- : case-total* T C\n    <- israw-total I\n    <- case-total/L T I C.\n\n%worlds () (case-total* _ _).\n%total { } (case-total* _ _).\n\n\n\n%{ === Main theorem === }%\n\n%{\nWe are ready now to prove totality of the relation.\nWe case the term first and then have everything we need\nto push through totality.\n}%\n\n\n%theorem tonat-total* :\n\tforall* {N}\n\tforall\t{T:term N}\n\texists\t{M:nat} {D:tonat T M}\n\ttrue.\n\n%abbrev tonat-total = tonat-total* _ _.\n\n%theorem tonat-total/L :\n\tforall* {N:nat} {T:term N} {MS}\n\tforall  {C:case MS T}\n\texists  {M:nat} {D:tonat* N MS T M}\n\ttrue.\n\n- : tonat-total/L (case/var MC VL GE) _ (tonat/var MC VL P)\n    <- ge-implies-plus GE _ P.\n\n- : tonat-total/L (case/lit) _ (tonat/lit MC T P)\n    <- count-total MC\n    <- times-total T\n    <- plus-total P.\n\n- : tonat-total/L (case/app C1 C2) _ (tonat/app MC TN1 TN2 P2N T P)\n    <- count-total MC\n    <- tonat-total/L C1 _ TN1\n    <- tonat-total/L C2 _ TN2\n    <- pair2nat-total P2N\n    <- times-total T\n    <- plus-total P.\n\n- : tonat-total/L (case/lam MCz MSU ([v] [vl] (C v vl))) _ \n                  (tonat/lam MC MCz MSU ([v] [vl] (TN v vl)) T P)\n    <- ({v} {vl:varlevel v (s N)} tonat-total/L (C v vl) _ (TN v vl))\n    <- count-total MC\n    <- times-total T\n    <- plus-total P.\n\n- : tonat-total/L (case/rec MC MA ([v] [vl] (C v vl))) _ \n                  (tonat/rec MC MA ([v] [vl] (TN v vl)) T P)\n    <- ({v} {vl} tonat-total/L (C v vl) _ (TN v vl))\n    <- times-total T\n    <- plus-total P.\n\n%worlds (blockvar) (tonat-total/L _ _ _).\n%total (C) (tonat-total/L C _ _).\n\n- : tonat-total TN\n    <- case-total C\n    <- tonat-total/L C _ TN.\n\n%worlds () (tonat-total* _ _ _).\n%total { } (tonat-total* _ _ _).\n\n\n\n\n%{ == Proof of the determinicity of the mapping == }%\n\n%{\nAs with the non-indexed case, this aspect is easy to prove.\n}%\n\n\n\n%{ === Auxiliary theorems === }%\n\n\n%{\nWe prove that variable levels are \"unique\" and that they are never zero.\nThe proofs are trivial: Twelf can accept them from the context alone.\n}%\n\n\n%theorem varlevel-deterministic :\n\tforall* {N} {V:term N} {L1} {L2}\n\tforall\t{VL1:varlevel V L1}\n\t\t{VL2:varlevel V L2}\n\texists\t{E:nat`eq L1 L2}\n\ttrue.\n\n- : varlevel-deterministic _ _ nat`eq/.\n\n%worlds (blockvar) (varlevel-deterministic _ _ _).\n%total { } (varlevel-deterministic _ _ _).\n\n\n%theorem varlevel-contradiction :\n\tforall* {N} {V:term N} {L}\n\tforall\t{VL:varlevel V L}\n\t\t{E:nat`eq L z}\n\texists\t{F:void}\n\ttrue.\n\n%worlds (blockvar) (varlevel-contradiction _ _ _).\n%total { }  (varlevel-contradiction _ _ _).\n\n\n\n%{ === Main Theorem === }%\n\n\n%theorem tonat-deterministic :\n\tforall* {N1} {N2} {T1:term N1} {T2:term N2} {M1} {M2}\n\tforall\t{TN1:tonat T1 M1} \n\t\t{TN2:tonat T2 M2}\n\t\t{E: eq T1 T2}\n\texists\t{E: nat`eq M1 M2}\n\ttrue.\n\n%theorem tonat-deterministic/L :\n\tforall* {N} {T:term N} {MS1} {MS2} {M1} {M2}\n\tforall\t{TN1:tonat* N MS1 T M1} \n\t\t{TN2:tonat* N MS2 T M2}\n\t\t{E: multiset`eq MS1 MS2}\n\texists\t{E: nat`eq M1 M2}\n\ttrue.\n\n- : tonat-deterministic/L (tonat/var MC1 VL1 P1) (tonat/var MC2 VL2 P2) _ N1=N2\n    <- count-deterministic MC1 MC2 multiset`eq/ nat`eq/ C1=C2\n    <- varlevel-deterministic VL1 VL2 L1=L2\n    <- plus-right-cancels P1 P2 L1=L2 C1=C2 N1=N2.\n\n- : tonat-deterministic/L (tonat/lit MC1 T1 P1) (tonat/lit MC2 T2 P2) _ M1'=M2'\n    <- count-deterministic MC1 MC2 multiset`eq/ nat`eq/ C1=C2\n    <- times-deterministic T1 T2 nat`eq/ nat`eq/ TM1=TM2\n    <- plus-deterministic P1 P2 C1=C2 TM1=TM2 M1'=M2'.\n\n- : tonat-deterministic/L (tonat/app MC1 TN1a TN1b P2N1 T1 P1) \n                          (tonat/app MC2 TN2a TN2b P2N2 T2 P2) MSE M1'=M2'\n    <- count-deterministic MC1 MC2 multiset`eq/ nat`eq/ C1=C2\n    <- tonat-deterministic/L TN1a TN2a MSE M1a=M2a\n    <- tonat-deterministic/L TN1b TN2b MSE M1b=M2b\n    <- natpair`pair-preserves-eq M1a=M2a M1b=M2b P1=P2\n    <- pair2nat-deterministic P2N1 P2N2 P1=P2 M1=M2\n    <- times-deterministic T1 T2 nat`eq/ M1=M2 TM1=TM2\n    <- succ-deterministic TM1=TM2 TM1+1=TM2+1\n    <- plus-deterministic P1 P2 C1=C2 TM1+1=TM2+1 M1'=M2'.\n\n%theorem tonat-deterministic/L2 :\n\tforall* {N1} {N2} {M1} {M2} {MS} {F:term N1 -> term N2} {M}\n\tforall\t{F1:{f:term N1} {fl:varlevel f (s M1)} \n                    tonat* N2 MS (F f) M}\n\t\t{ME: nat`eq M1 M2}\n\texists\t{F2:{f:term N1} {fl:varlevel f (s M2)}\n\t\t    tonat* N2 MS (F f) M}\n\ttrue.\n\n- : tonat-deterministic/L2 F nat`eq/ F.\n\n%worlds (blockvar) (tonat-deterministic/L2 _ _ _).\n%total { } (tonat-deterministic/L2 _ _ _).\n\n- : tonat-deterministic/L (tonat/lam MC1 MCz1 MA1 ([v] [vl] (TN1 v vl)) T1 P1)\n                          (tonat/lam MC2 MCz2 MA2 ([v] [vl] (TN2 v vl)) T2 P2)\n                          MS1=MS2 M1'=M2'\n    <- multiset`count-deterministic MC1 MC2 MS1=MS2 nat`eq/ VN1=VN2\n    <- multiset`count-deterministic MCz1 MCz2 MS1=MS2 nat`eq/ ZN1=ZN2\n    <- multiset`add-deterministic MA1 MA2 MS1=MS2 nat`eq/ MS1'=MS2'\n    <- tonat-deterministic/L2 TN1 ZN1=ZN2 TN1'\n    <- ({v} {vl:varlevel v (s ZN2)} tonat-deterministic/L (TN1' v vl) (TN2 v vl)\n                                                          MS1'=MS2' M1=M2)\n    <- times-deterministic T1 T2 nat`eq/ M1=M2 TM1=TM2\n    <- plus-deterministic P1 P2 VN1=VN2 TM1=TM2 M1'=M2'.\n\n- : tonat-deterministic/L (tonat/rec MC1 MA1 ([f] [fl] (TN1 f fl)) T1 P1)\n                          (tonat/rec MC2 MA2 ([f] [fl] (TN2 f fl)) T2 P2) \n                          MS1=MS2 M1'=M2'\n    <- multiset`count-deterministic MC1 MC2 MS1=MS2 nat`eq/ FN1=FN2\n    <- multiset`add-deterministic MA1 MA2 MS1=MS2 nat`eq/ MS1'=MS2'\n    <- tonat-deterministic/L2 TN1 FN1=FN2 TN1'\n    <- ({f} {fl:varlevel f (s N)} tonat-deterministic/L (TN1' f fl) (TN2 f fl)\n                                                        MS1'=MS2' M1=M2)\n    <- times-deterministic T1 T2 nat`eq/ M1=M2 TM1=TM2\n    <- succ-deterministic TM1=TM2 TM1'=TM2'\n    <- succ-deterministic TM1'=TM2' TM1''=TM2''\n    <- plus-deterministic P1 P2 FN1=FN2 TM1''=TM2'' M1'=M2'.\n\n%worlds (blockvar) (tonat-deterministic/L _ _ _ _).\n%total (T) (tonat-deterministic/L _ T _ _).\n\n- : tonat-deterministic TN1 TN2 eq/ N1=N2\n    <- tonat-deterministic/L TN1 TN2 multiset`eq/ N1=N2.\n\n%worlds () (tonat-deterministic _ _ _ _).\n%total { } (tonat-deterministic _ _ _ _).\n\n\n\n%{ == Proving that the mapping is onto. == }%\n\n%{\nAgain, this aspect has the same structure as with non-indexed terms.\n}%\n\n\n%{ === Auxiliary definitions === }%\n\n\n\n%{\nWe define a relation that builds on the context relation.\nIn the non-indexed case, it took a nat, here it takes the\nmultiset representing the levels of variables in the context.\n}%\n\n\nupto : multiset -> type.\n\n\nupto/0 : upto multiset/0.\n\nupto/+ : \n\tupto MS -> \n\tmultiset`count MS N FN ->\n\tvarlevel (V:term N) (s FN) -> \n\tmultiset`add MS N MS' ->\n    upto MS'.\n\n\n\n%{ === Lemmas about regular definitions === }%\n\n\n%theorem term-inhabited :\n\tforall {N}\n\texists {T:term N}\n\ttrue.\n\n- : term-inhabited _ (lit z).\n\n- : term-inhabited _ (lam ([x] T))\n    <- term-inhabited _ T.\n\n%worlds (blockvar) (term-inhabited _ _).\n%total (N) (term-inhabited N _).\n\n\n\n%{ === Theorems about auxiliary definitions === }%\n\n\n%{\nThe obvious lemma that makes use of the main purpose of the relation:\nthat a variable is always available.\n}%\n\n%theorem upto-implies-varlevel :\n\tforall* {MS} {N} {L} {FN}\n\tforall\t{U:upto MS}\n\t\t{MC:multiset`count MS N FN}\n\t\t{LT:nat`gt FN L}\n\texists\t{V:term N} {VL:varlevel V (s L)}\n\ttrue.\n\n- : upto-implies-varlevel upto/0 MC FN>L T FL\n    <- count-empty-is-zero MC FN=0\n    <- nat`gt-respects-eq FN>L FN=0 nat`eq/ ZERO>L \n    <- term-inhabited _ T\n    <- nat`gt-contradiction ZERO>L F\n    <- false-implies-varlevel F FL.\n\n%theorem upto-implies-varlevel/L :\n\tforall* {MS1} {N1} {L} {FN1} {MS2} {N2} {FN2} {V1:term N1} {B}\n\tforall\t{U: upto MS1}\n\t\t{MC1: multiset`count MS1 N1 FN1}\n\t\t{FL1: varlevel V1 (s FN1)}\n\t\t{MA: multiset`add MS1 N1 MS2}\n\t\t{MC2: multiset`count MS2 N2 FN2}\n\t\t{LT:nat`gt FN2 L}\n\t\t{EQ?: nat`eq? N1 N2 B}\n\texists\t{V:term N2} {VL:varlevel V (s L)}\n\ttrue.\n\n- : upto-implies-varlevel/L _ MC1 FL1 MA MC2 (gt/1) nat`eq?/yes _ FL2\n    <- count-add-implies-count MC1 MA MC2'\n    <- count-deterministic MC2' MC2 multiset`eq/ nat`eq/ FN1+1=FN2+1\n    <- varlevel-respects-eq FL1 FN1+1=FN2+1 FL2.\n\n- : upto-implies-varlevel/L U MC1 FL1 MA MC2 (gt/> FN2>L) nat`eq?/yes _ FL2\n    <- count-add-implies-count MC1 MA MC2'\n    <- count-deterministic MC2 MC2' multiset`eq/ nat`eq/ FN2+1=FN1+1\n    <- succ-cancels FN2+1=FN1+1 FN2=FN1\n    <- gt-respects-eq FN2>L FN2=FN1 nat`eq/ FN1>L\n    <- upto-implies-varlevel U MC1 FN1>L _ FL2.\n \n- : upto-implies-varlevel/L U _ _ MA MC2 GT (nat`eq?/no N1<>N2) _ FL\n    <- nat`ne-symmetric N1<>N2 N2<>N1\n    <- add-preserves-count-converse MC2 MA N2<>N1 MC1\n    <- upto-implies-varlevel U MC1 GT _ FL.\n\n- : upto-implies-varlevel (upto/+ U MC1 FL1 MA) MC2 GT _ FL\n    <- nat`eq?-total EQ?\n    <- upto-implies-varlevel/L U MC1 FL1 MA MC2 GT EQ? _ FL.\n\n%worlds (blockvar) (upto-implies-varlevel/L _ _ _ _ _ _ _ _ _)\n                   (upto-implies-varlevel _ _ _ _ _).\n\n%total (U V) (upto-implies-varlevel U _ _ _ _)\n             (upto-implies-varlevel/L V _ _ _ _ _ _ _ _).\n\n\n\n%{ === Main theorem === }%\n\n%{\nWe prove the main result using two lemmas that do the case\nanalysis on the number against the nesting level and the\nparity.  (In general, one would use a divisor counting all\ncases that are recursive.)  The proofs are long but simply\narithmetic manipulation.  Proving termination uses meta-gt\nfor strong induction over the natural numbers.\n}%\n\n\n%theorem tonat-onto* :\n\tforall* {N}\n\tforall\t{M:nat}\n\texists\t{T:term N} {TN:tonat T M}\n\ttrue.\n\n%abbrev tonat-onto = tonat-onto* _ _.\n\n\n%theorem tonat-onto/L :\n\tforall* {N} {MS:multiset}\n\tforall\t{U:upto MS}\n\t\t{M:nat}\n\texists\t{T:term N} {TN:tonat* _ MS T M}\n\ttrue.\n\n%theorem tonat-onto/L0 :\n\tforall* {N} {MS:multiset} {VN} {C}\n\tforall\t{U:upto MS}\n\t\t{M:nat}\n\t\t{MC:count MS N VN}\n\t\t{CMP:nat`compare VN M C}\n\texists\t{T} {TN:tonat* N MS T M}\n\ttrue.\n\n- : tonat-onto/L U M _ TN\n    <- multiset`count-total MC\n    <- nat`compare-total CMP\n    <- tonat-onto/L0 U M MC CMP _ TN.\n\n- : tonat-onto/L0 U M MC (compare/> VN>M) _ (tonat/var MC VL M+L+1=VN)\n    <- nat`gt-implies-plus VN>M L L+1+M=VN\n    <- plus-commutative L+1+M=VN M+L+1=VN\n    <- plus-implies-ge M+L+1=VN VN>=L+1\n    <- ge-succ-implies-gt VN>=L+1 VN>L\n    <- upto-implies-varlevel U MC VN>L _ VL.\n\n%theorem tonat-onto/L1 :\n\tforall*\t{TM} {MS} {N} {VN}\n\tforall\t{UF:upto MS}\n\t\t{M:nat}\n\t\t{MC:count MS N VN}\n\t\t{P:plus VN TM M}\n\t\t{Q} {R} {DR:divrem TM (s (s z)) Q R}\n\texists\t{T} {TN:tonat* N MS T M}\n\ttrue.\n\n- : tonat-onto/L0 U M MC (compare/=) _ TN\n    <- plus-right-identity _ P\n    <- divrem-total M/2=Q,R\n    <- tonat-onto/L1 U M MC P Q R M/2=Q,R _ TN.\n\n- : tonat-onto/L0 U M MC (compare/< M>VN) _ TN\n    <- gt-implies-plus M>VN _ Pc\n    <- plus-commutative Pc P\n    <- divrem-total M/2=Q,R\n    <- tonat-onto/L1 U M MC P Q R M/2=Q,R _ TN.\n\n- : tonat-onto/L1 _ _ _ _ _ (s (s _)) DR T TN\n    <- divrem-contradiction DR (plus/s (plus/s plus/z)) F\n    <- term-inhabited _ T\n    <- false-implies-tonat F TN.\n\n- : tonat-onto/L1 U M' MC VN+TM'=M' M (s z) TM'/2=M,1 \n\t\t  _ (tonat/app MC TN1 TN2 P2N TWO*M=TM VN+TM+1=M')\n    <- plus-implies-ge VN+TM'=M' M'>=TM'\n    <- divrem-can-be-inverted TM'/2=M,1 TM M*2=TM TM+ONE=TM'\n    <- times-commutative M*2=TM TWO*M=TM\n    <- plus-commutative (plus/s plus/z) TM+ONE=TM+1\n    <- plus-deterministic TM+ONE=TM' TM+ONE=TM+1 nat`eq/ nat`eq/ TM'=TM+1\n    <- plus-respects-eq VN+TM'=M' nat`eq/ TM'=TM+1 nat`eq/ VN+TM+1=M'\n    <- nat2pair-total P2N\n    <- quotient-of-nonzero-is-smaller TM'/2=M,1 TM'=TM+1 TM'>M\n    <- nat`ge-transitive-gt M'>=TM' TM'>M M'>M\n    <- nat2pair-implies-ge P2N M>=M1 M>=M2\n    <- nat`gt-transitive-ge M'>M M>=M1 M'>M1\n    <- nat`gt-transitive-ge M'>M M>=M2 M'>M2\n    <- meta-gt _ _ M'>M1\n    <- meta-gt _ _ M'>M2\n    <- tonat-onto/L U M1 _ TN1\n    <- tonat-onto/L U M2 _ TN2.\n\n- : tonat-onto/L1 _ M' MC VN+TM=M' M z TM/2=M _ (tonat/lit MC TWO*M=TM VN+TM=M')\n    <- div-can-be-inverted TM/2=M M*2=TM\n    <- times-commutative M*2=TM TWO*M=TM.\n\n%theorem tonat-onto/L2 :\n\tforall*\t{TM} {MS} {N} {VN} {Q2}\n\tforall\t{U:upto MS}\n\t\t{M:nat}\n\t\t{MC:count MS (s N) VN}\n\t\t{P:plus VN TM M}\n\t\t         {DR:divrem TM (s (s z)) Q2 z}\n\t\t{Q4} {R} {DR:divrem Q2 (s (s z)) Q4 R}\n\texists\t{T} {TN:tonat* (s N) MS T M}\n\ttrue.\n\n- : tonat-onto/L1 U M' MC VN+FM=M' TM z FM/2=TM _ TN\n    <- divrem-total TM/2=Q,R\n    <- tonat-onto/L2 U M' MC VN+FM=M' FM/2=TM Q R TM/2=Q,R _ TN.\n\n%abbrev 2*2=4 = (times/s (times/s times/z plus/z) (plus/s (plus/s plus/z))).\n\n- : tonat-onto/L2 _ _ _ _ _ _ (s (s _)) DR T TN\n    <- divrem-contradiction DR (plus/s (plus/s plus/z)) F\n    <- term-inhabited _ T\n    <- false-implies-tonat F TN.\n\n- : tonat-onto/L2 U M' MC VN+FM'=M' FM'/2=TM' M (s z) TM'/2=M,1\n\t\t  _ (tonat/rec MC MA ([f] [fl] (TN f fl)) FOUR*M=FM VN+FM+2=M')\n    <- divrem-can-be-inverted TM'/2=M,1 TM M*2=TM TM+ONE=TM'\n    <- div-can-be-inverted FM'/2=TM' TM'*2=FM'\n    <- times-total* TM (s (s z)) FM TM*2=FM \n    <- times-right-distributes-over-plus* \n\tTM+ONE=TM' TM'*2=FM' TM*2=FM (times/s times/z plus/z) FM+TWO=FM'\n    <- times-associative* M*2=TM TM*2=FM 2*2=4 M*4=FM\n    <- times-commutative M*4=FM FOUR*M=FM\n    <- plus-commutative (plus/s (plus/s plus/z)) FM+TWO=FM+2\n    <- plus-deterministic FM+TWO=FM' FM+TWO=FM+2 nat`eq/ nat`eq/ FM'=FM+2\n    <- plus-respects-eq VN+FM'=M' nat`eq/ FM'=FM+2 nat`eq/ VN+FM+2=M'\n    <- plus-swap-succ-converse VN+FM+2=M' VN+1+FM+1=M'\n    <- plus-swap-succ-converse VN+1+FM+1=M' VN+2+FM=M'\n    <- multiset`add-total MA\n    <- plus-implies-gt VN+2+FM=M' nat`eq/ M'>FM\n    <- times-nonzero-implies-ge M*4=FM FM>=M\n    <- nat`gt-transitive-ge M'>FM FM>=M M'>M\n    <- meta-gt _ _ M'>M\n    <- ({f} {fl} tonat-onto/L (upto/+ U MC fl MA) M _ (TN f fl)).\n\n% 0 needs a special case for termination:\n\n%theorem tonat-onto/0 :\n\tforall*\t{MS}\n\tforall\t{N} {U:upto MS} {VN}\n\t\t{MC:count MS N VN}\n\texists\t{T} {TN:tonat* N MS T z}\n\ttrue.\n\n%abbrev 2*0=0 = (times/s (times/s times/z plus/z) plus/z).\n%abbrev 4*0=0 = (times/s (times/s 2*0=0   plus/z) plus/z).\n\n- : tonat-onto/0 _ U z MC _ (tonat/lit MC 2*0=0 plus/z).\n\n- : tonat-onto/0 _ U z MC _ (tonat/lam MC MCz MA TN 4*0=0 plus/z)\n    <- multiset`count-total MCz\n    <- multiset`add-total MA\n    <- multiset`count-total MC'\n    <- ({v} {vl} (tonat-onto/0 _ (upto/+ U MCz vl MA) _ MC' _ (TN v vl))).\n\n- : tonat-onto/0 N U (s VN-1) MC _ (tonat/var MC VL plus/z)\n    <- upto-implies-varlevel U MC gt/1 _ VL.\n\n%worlds (blockvar) (tonat-onto/0 _ _ _ _ _ _).\n%total (N) (tonat-onto/0 N _ _ _ _ _).\n\n- : tonat-onto/L2 U z MC _ _ _ _ _ _ TN\n    <- tonat-onto/0 _ U _ MC _ TN.\n\n%theorem tonat-onto/L2/L :\n\tforall* {M} {X} {Y} {Z} {XM}\n\tforall\t{T:times M (s (s X)) XM}\n\t\t{P:plus Y XM (s Z)}\n\texists\t{G:gt (s Z) M}\n\ttrue.\n\n- : tonat-onto/L2/L M*2=XM plus/z XM>M\n    <- div-can-be-constructed M*2=XM XM/2=M\n    <- quotient-of-nonzero-is-smaller XM/2=M nat`eq/ XM>M.\n\n- : tonat-onto/L2/L M*2=XM Y+XM=X' X'>M\n    <- plus-implies-gt Y+XM=X' nat`eq/ X'>MX\n    <- times-nonzero-implies-ge M*2=XM XM>=M\n    <- nat`gt-transitive-ge X'>MX XM>=M X'>M.\n\n%worlds () (tonat-onto/L2/L _ _ _).\n%total { } (tonat-onto/L2/L _ _ _).\n\n- : tonat-onto/L2 U (s X) MC VN+FM=M' FM/2=TM M z TM/2=M\n\t\t  _ (tonat/lam MC MCz MA TN FOUR*M=FM VN+FM=M')\n    <- div-can-be-inverted TM/2=M M*2=TM\n    <- div-can-be-inverted FM/2=TM TM*2=FM\n    <- times-associative* M*2=TM TM*2=FM 2*2=4 M*4=FM\n    <- times-commutative M*4=FM FOUR*M=FM\n    <- multiset`count-total MCz\n    <- multiset`add-total MA\n    <- tonat-onto/L2/L M*4=FM VN+FM=M' M'>M\n    <- meta-gt (s X) M M'>M\n    <- ({v} {vl} tonat-onto/L (upto/+ U MCz vl MA) _ _ (TN v vl)).\n\n%worlds (blockvar)  (tonat-onto/L2 _ _ _ _ _ _ _ _ _ _)\n                    (tonat-onto/L1 _ _ _ _ _ _ _ _ _)\n\t\t    (tonat-onto/L0 _ _ _ _ _ _)\n\t\t    (tonat-onto/L  _ _ _ _).\n%total (M2 M1 M0 M) (tonat-onto/L2 _ M2 _ _ _ _ _ _ _ _)\n                    (tonat-onto/L1 _ M1 _ _ _ _ _ _ _)\n\t\t    (tonat-onto/L0 _ M0 _ _ _ _)\n\t\t    (tonat-onto/L  _ M  _ _).\n\n\n\n\n%{ == Proof that mapping is \"one to one\" == }%\n\n%{\nAs with the simple HOAS syntax, this is the hardest of the four theorems \nto prove.  As before, the basic structure is the same: we first show\nthat the terms that result in the same number must be identical\nexcept that two variables may be equal just by having the same level.\n\nAs before we then 'chip' away at variables with low levels and shift \nthe others down.  We need to work at low levels because contexts cannot\nbe parameterized by an 'N' and must be absolute.  The additional problem\nwith indexed terms is that the first variable we encounter may be\nof a higher-index than zero.  In any case, there can be level \n1 variables inside that have a different index than the one we are removing.\nSo the context cannot simply assert that all variables will have level 2 \nor higher, as with did in the non-indexed case.\n\nThe basic idea is that we handle one index level at a time.  But again\nbecause Twelf contexts cannot have be parameterized, we need to\nshift index levels down too.  Of course, we cannot actually change\nindex values.  Instead, we keep a index-adjustment.  Then a variable\nof index type (term N) has two parts to its level M L, where M+A=N\nand L is the original level.  The multiset that keeps track of the\nnext level is similarly shifted.  We then do a shift such as we had\nfor non-indexed terms while removing all variables of adjusted index \nzero (M = z).  Then when these are all removed, we can adjust the indices \none more step until there are no more variables of any index needing\nlevels.\n}%\n\n\n\n%{ === Auxiliary definitions === }%\n\n\n%{\nIn this section, we use the full generality of varadjlevel\nbecause we need to recurse in two different directions:\nthe original var level and the term level.\n}%\n\n%block blockvaradj : some {m} {n} {l}\n\t\t      block {v:term n} {vl:varadjlevel v m (s l)}.\n\n\n%{ ==== Equality (permitting variables with the same level). ==== }%\n\n%{\nSome variables are are bound with levels, others are not given levels.\nWe do this in order to gradually squeeze out those that need levels.\nThe lam1 and rec1 cases use variables that don't need levels, whereas\nthe lam2, rec2 cases handle variables that still need level.\nWe also take a natural number A that indicates the minimum term level\nthat will be used.  Notice that lam2 is only legal while A is still zero.\n}%\n\neql* : {N} {A:nat} multiset -> term N -> term N -> type.\n\n%abbrev eql = eql* _.\n\n\neql/eq : eq T1 T2 -> eql A MS T1 T2.\n\neql/app : eql A MS F1 F2 -> eql A MS A1 A2 -> eql A MS (app F1 A1) (app F2 A2).\n\neql/lam1 : ({v} (eql A MS (F1 v) (F2 v))) -> eql A MS (lam F1) (lam F2).\n\neql/lam2 :\n\tcount MS z VN -> \n\tadd MS z MS' -> \n\t({v} {vl: varadjlevel v z (s VN)} eql z MS' (F1 v) (F2 v)) ->\n    eql z MS (lam F1) (lam F2).\n\neql/rec1 : ({v} (eql A MS (F1 v) (F2 v))) -> eql A MS (rec F1) (rec F2).\n\neql/rec2 :\n\tplus A M (s N) ->\n\tcount MS M VN ->\n\tadd MS M MS' ->\n\t({v} {vl:varadjlevel v M (s VN)} eql A MS' (F1 v) (F2 v)) ->\n    eql A MS (rec F1) (rec F2).\n\neql/var :\n\tplus A M N ->\n\tvaradjlevel V1 M L -> \n\tvaradjlevel V2 M L -> \n    eql* N A MS V1 V2.\n\n\n%{ ==== Measure of eql sizes. ==== }%\n\n%{\nWe use this measure to be able to prove termination.\nWe need eqlsize/var = eqlsize/eq, eqlsize/lam1 = eqlsize/lam2.\n(Less than is ok in each case but would require that we\nrephrase the lemmas.)\nWe have three measures: N B M.\n\n- N is the height of the term\n\n- B is the minimum of any M for a varlevel (or (s z))\n\n- M is greater than the M for any varlevel used.\n\nThe first measure is used to ensure that regular recursion through the\ntree terminates.  We don't use normal structure recursion because\neverytime we change variable levels, the tree changes.\n\nThe second measure is not used for termination, but when non-zero\nmeans there are no variables with that need adjusted index zero.\nOnce this is the case, we can adjust all levels down one notch.\n\nThe third measure is used to ensure that chipping away \nat indices eventually terminates: M is the maximum adjusted\nindex used.  Once M drops to zero, it means no variables\nneed levels for equality and we can convert to an 'eq' proof\neasily.\n}%\n\neqlsize : (eql* A N MS T1 T2) -> nat -> nat -> nat -> type.\n\n\neqlsize/eq : eqlsize (eql/eq _) z (s z) z.\n\neqlsize/app : \n\teqlsize E1 N1 B1 M1 ->\n\teqlsize E2 N2 B2 M2 ->\n\tnat`max N1 N2 N ->\n\tnat`min B1 B2 B ->\n\tnat`max M1 M2 M ->\n    eqlsize (eql/app E1 E2) (s N) B M.\n\t\neqlsize/lam1 : ({v} eqlsize (E v) N B M) -> eqlsize (eql/lam1 E) (s N) B M.\n\neqlsize/lam2 : \n\t({v} {vl} eqlsize (E v vl) N B M) -> \n\tnat`max (s z) M M' ->\n    eqlsize (eql/lam2 _ _ E) (s N) z M'.\n\neqlsize/rec1 : ({v} eqlsize (E v) N B M) -> eqlsize (eql/rec1 E) (s N) B M.\n\neqlsize/rec2 : \n\t({v} {vl:varadjlevel v M _} eqlsize (E v vl) N B1 M1) -> \n\tnat`min M B1 B2 ->\n\tnat`max (s M) M1 M2 ->\n    eqlsize (eql/rec2 _ _ _ E) (s N) B2 M2.\n\neqlsize/var : eqlsize (eql/var _ _ _) z (s z) z.\n\n\n%{ ==== Copied definitions ==== }%\n\n%{\nAs with the non-indexed case, we need to use an alternate form\nfor levels as we shift them down or adjust them down.\n(Remember there are two dimensions to a level!)\n}%\n\n\nvaradjlevel' : term N -> nat -> nat -> type.\n\n\neql*' : {N} {A:nat} multiset -> term N -> term N -> type.\n\n%abbrev eql' = eql*' _.\n\n\neql'/eq : eq T1 T2 -> eql' A MS T1 T2.\n\neql'/app : \n\teql' A MS F1 F2 -> \n\teql' A MS A1 A2 -> \n    eql' A MS (app F1 A1) (app F2 A2).\n\neql'/lam1 : ({v} (eql' A MS (F1 v) (F2 v))) -> eql' A MS (lam F1) (lam F2).\n\neql'/lam2 :\n\tcount MS z VN -> \n\tadd MS z MS' -> \n\t({v} {vl: varadjlevel' v z (s VN)} eql' z MS' (F1 v) (F2 v)) ->\n    eql' z MS (lam F1) (lam F2).\n\neql'/rec1 : ({v} (eql' A MS (F1 v) (F2 v))) -> eql' A MS (rec F1) (rec F2).\n\neql'/rec2 :\n\tplus A M (s N) ->\n\tcount MS M VN ->\n\tadd MS M MS' ->\n\t({v} {vl:varadjlevel' v M (s VN)} eql' A MS' (F1 v) (F2 v)) ->\n    eql' A MS (rec F1) (rec F2).\n\neql'/var :\n\tplus A M N ->\n\tvaradjlevel' V1 M L -> \n\tvaradjlevel' V2 M L -> \n    eql*' N A MS V1 V2.\n\n\n\neqlsize' : (eql*' A N MS T1 T2) -> nat -> nat -> nat -> type.\n\n\neqlsize'/eq : eqlsize' (eql'/eq _) z (s z) z.\n\neqlsize'/app : \n\teqlsize' E1 N1 B1 M1 ->\n\teqlsize' E2 N2 B2 M2 ->\n\tnat`max N1 N2 N ->\n\tnat`min B1 B2 B ->\n\tnat`max M1 M2 M ->\n    eqlsize' (eql'/app E1 E2) (s N) B M.\n\t\neqlsize'/lam1 : ({v} eqlsize' (E v) N B M) -> eqlsize' (eql'/lam1 E) (s N) B M.\n\neqlsize'/lam2 : \n\t({v} {vl} eqlsize' (E v vl) N B M1) -> \n\tnat`max (s z) M1 M2 ->\n    eqlsize' (eql'/lam2 _ _ E) (s N) z M2.\n\neqlsize'/rec1 : ({v} eqlsize' (E v) N B M) -> eqlsize' (eql'/rec1 E) (s N) B M.\n\neqlsize'/rec2 : \n\t({v} {vl:varadjlevel' v M _} eqlsize' (E v vl) N B1 M1) -> \n\tnat`min M B1 B2 ->\n\tnat`max (s M) M1 M2 ->\n    eqlsize' (eql'/rec2 _ _ _ E) (s N) B2 M2.\n\neqlsize'/var : eqlsize' (eql'/var _ _ _) z (s z) z.\n\n\n\n%{ === Theorems about auxiliary definitions === }%\n\n%{\nSome of the lemmas that would normally belong here are\nproved later when we have more blocks available.\n}%\n\n\n%theorem false-implies-eql :\n\tforall* {MS} {N} {A} {T1} {T2} \n\tforall\t{F:void}\n\texists\t{E:eql* N A MS T1 T2}\n\ttrue.\n\n%worlds (blocksimple | blockvaradj) (false-implies-eql _ _).\n%total { }  (false-implies-eql _ _).\n\n\n%theorem false-implies-eqlsize :\n\tforall* {N} {A} {MS} {T1} {T2} {S} {B} {M}\n\t\t{E:eql* N A MS T1 T2}\n\tforall\t{F:void}\n\texists\t{ES1:eqlsize E S B M}\n\ttrue.\n\n%worlds (blocksimple | blockvaradj) (false-implies-eqlsize _ _).\n%total { } (false-implies-eqlsize _ _).\n\n\n%theorem eqlsize-total* :\n\tforall*\t{N} {A} {MS} {T1} {T2}\n\tforall  {E:eql* N A MS T1 T2}\n\texists  {S} {M} {B} {ES:eqlsize E S B M}\n\ttrue.\n\n%abbrev eqlsize-total = eqlsize-total* _ _ _ _.\n\n- : eqlsize-total eqlsize/eq.\n\n- : eqlsize-total (eqlsize/app S1 S2 M B M2)\n    <- eqlsize-total S1\n    <- eqlsize-total S2\n    <- nat`max-total M\n    <- nat`min-total B\n    <- nat`max-total M2.\n\n- : eqlsize-total (eqlsize/lam1 F)\n    <- ({v} eqlsize-total (F v)).\n\n- : eqlsize-total (eqlsize/lam2 F M)\n    <- ({v} {vl} (eqlsize-total (F v vl)))\n    <- nat`max-total M.\n\n- : eqlsize-total (eqlsize/rec1 F)\n    <- ({v} eqlsize-total (F v)).\n\n- : eqlsize-total (eqlsize/rec2 F MN M)\n    <- ({v} {vl} (eqlsize-total (F v vl)))\n    <- nat`min-total MN\n    <- nat`max-total M.\n\n- : eqlsize-total eqlsize/var.\n\n%worlds (blocksimple | blockvaradj) (eqlsize-total* _ _ _ _ _).\n%total (E)  (eqlsize-total* E _ _ _ _).\n\n\n\n%{ === Shifting varlevels down === }%\n\n%{\nNow as with the non-indexed case, we shift variable levels down.\nAs before, we need to use the alternate definitions.\n\nThe astute reader will notice that we don't have a block that\njust handles nonzero (adjusted) index variables being shifted\nover.  Instead we handle a double context \"noshift\" that handles\nboth directions.  That's because when these lemmas are used\nto shift levels down, the outer context may have non-zero (adjusted)\nindex that will need to handle being shifted in both directions.\n}%\n\n\n%theorem varlevel-zero-shifts-down :\n\tforall* {N} {V:term N} {L}\n\tforall\t{VL:varadjlevel V z (s (s L))}\n\texists\t{VL':varadjlevel' V z (s L)}\n\ttrue.\n\n%theorem varlevel-nonzero-shifts-over :\n\tforall* {N} {V:term N} {M} {L}\n\tforall\t{VL:varadjlevel V (s M) (s L)}\n\texists\t{VL':varadjlevel' V (s M) (s L)}\n\ttrue.\n\n%theorem varlevel-shifts-back :\n\tforall* {N} {V:term N} {M} {L}\n\tforall\t{VL':varadjlevel' V M (s L)}\n\texists\t{VL:varadjlevel V M (s L)}\n\ttrue.\n\n\n%block shiftdown : some {l} {n} \n\t\t    block {v:term n} \n\t\t    {vl:varadjlevel v z (s (s l))} \n\t\t    {vl':varadjlevel' v z (s l)}\n\t\t    {vsd:varlevel-zero-shifts-down vl vl'}.\n\n%block noshift : some {l} {m} {n}\n\t\t  block {v:term n}\n\t\t  {vl:varadjlevel v (s m) (s l)}\n\t\t  {vl':varadjlevel' v (s m) (s l)}\n\t\t  {vsd:varlevel-nonzero-shifts-over vl vl'}\n\t\t  {vsd:varlevel-shifts-back vl' vl}.\n\n%block shiftback : some {n} {m} {l} \n\t\t    block {v:term n} \n\t\t    {vl':varadjlevel' v m (s l)} \n\t\t    {vl:varadjlevel v m (s l)}\n\t\t    {vsb:varlevel-shifts-back vl' vl}.\n\nfake : type.\n- : fake <- ({x:varlevel-zero-shifts-down X Y} varlevel-zero-shifts-down X' Y').\n- : fake <- ({x:varlevel-nonzero-shifts-over X Y}\n\t       varlevel-nonzero-shifts-over X' Y').\n- : fake <- ({x:varlevel-shifts-back X Y} varlevel-shifts-back X' Y').\n\n%worlds (blocksimple | shiftdown | noshift) \n\t(varlevel-zero-shifts-down _ _).\n%worlds (blocksimple | shiftdown | noshift) \n\t(varlevel-nonzero-shifts-over _ _).\n%worlds (blocksimple | shiftback | noshift) \n        (varlevel-shifts-back _ _).\n\n%total { } (varlevel-zero-shifts-down _ _).\n%total { } (varlevel-nonzero-shifts-over _ _).\n%total { } (varlevel-shifts-back _ _).\n\n\n\n%theorem shift-varlevel/L1 :\n\tforall* {N} {A} {M0} {M1} {T1} {T2} {S} {MN} {MM}\n\tforall\t{E: eql* N A M1 T1 T2}\n\t\t{ES:eqlsize E S MN MM}\n\t\t{MA:multiset`add M0 z M1}\n\texists\t{E': eql*' N A M0 T1 T2}\n\t\t{ES':eqlsize' E' S MN MM}\n\ttrue.\n\n- : shift-varlevel/L1 (eql/eq eq/) eqlsize/eq _ (eql'/eq eq/) eqlsize'/eq.\n\n- : shift-varlevel/L1 (eql/app E1 E2) (eqlsize/app ES1 ES2 MX MN MX2) MA\n\t\t      (eql'/app E1' E2') (eqlsize'/app ES1' ES2' MX MN MX2)\n    <- shift-varlevel/L1 E1 ES1 MA E1' ES1'\n    <- shift-varlevel/L1 E2 ES2 MA E2' ES2'.\n\n- : shift-varlevel/L1 (eql/lam1 ([v] (F v))) (eqlsize/lam1 FS) MA\n                      (eql'/lam1 ([v] (F' v))) (eqlsize'/lam1 FS')\n    <- {v} shift-varlevel/L1 (F v) (FS v) MA (F' v) (FS' v).\n\n%theorem shift-varlevel/L1/rec :\n\tforall* {N0} {N} {N'} {N1} {F1} {F2} {A} {S} {M1} {M2} {MN} {MM}\n\tforall\t{F: {v:term N0} {vl:varadjlevel v z (s N)}\n\t\t     (eql* N1 A M2 (F1 v) (F2 v))}\n\t\t{FS: {v:term N0} {vl:varadjlevel v z (s N)}\n\t\t      (eqlsize (F v vl) S MN MM)}\n\t\t{MA1: multiset`add M1 z M2}\n\t\t{EQ: nat`eq N (s N')}\n\texists\t{F': {v:term N0} {vl':varadjlevel' v z (s N')}\n\t\t      (eql*' N1 A M1 (F1 v) (F2 v))}\n\t\t{FS': {v:term N0} {vl':varadjlevel' v z (s N')}\n\t\t       (eqlsize' (F' v vl') S MN MM)}\n\ttrue.\n\n- : shift-varlevel/L1/rec F FS MA1 nat`eq/ F' FS'\n    <- {v} {vl} {vl':varadjlevel' v z (s N)} \n       {vsd:varlevel-zero-shifts-down vl vl'}\n       shift-varlevel/L1 (F v vl) (FS v vl) MA1 (F' v vl') (FS' v vl').\n\n- : shift-varlevel/L1 \n\t(eql/lam2 MC1 MA1 ([v] [vl:varadjlevel v z (s N)] (F v vl)))\n\t(eqlsize/lam2 FS MM) MA0\n        (eql'/lam2 MC0 MA0 ([v] [vl:varadjlevel' v z (s N')] (F' v vl)))\n\t(eqlsize'/lam2 FS' MM)\n    <- multiset`count-total MC0\n    <- count-add-implies-count MC0 MA0 MC1'\n    <- count-deterministic MC1 MC1' multiset`eq/ nat`eq/ EQ\n    <- shift-varlevel/L1/rec F FS MA1 EQ F' FS'.\n\n- : shift-varlevel/L1 (eql/rec1 ([v] (F v))) (eqlsize/rec1 FS) MA\n                      (eql'/rec1 ([v] (F' v))) (eqlsize'/rec1 FS')\n    <- {v} shift-varlevel/L1 (F v) (FS v) MA (F' v) (FS' v).\n\n- : shift-varlevel/L1 \n\t(eql/rec2 P MC1 MA1 ([v] [vl:varadjlevel v z (s N)] (F v vl)))\n\t(eqlsize/rec2 FS MN MM) MA0\n        (eql'/rec2 P MC0 MA0 ([v] [vl:varadjlevel' v z (s N')] (F' v vl)))\n\t(eqlsize'/rec2 FS' MN MM)\n    <- multiset`count-total MC0\n    <- count-add-implies-count MC0 MA0 MC1'\n    <- count-deterministic MC1 MC1' multiset`eq/ nat`eq/ EQ\n    <- shift-varlevel/L1/rec F FS MA1 EQ F' FS'.\n\n- : shift-varlevel/L1 \n\t(eql/rec2 P MC1 MA1 ([v] [vl:varadjlevel v (s M) (s N)] (F v vl)))\n\t(eqlsize/rec2 FS MN MM) MA\n        (eql'/rec2 P MC1' MA1' ([v] [vl:varadjlevel' v (s M) (s N)] (F' v vl)))\n\t(eqlsize'/rec2 FS' MN MM)\n    <- add-commutes MA MA1 _ MA1' MA'\n    <- succ-implies-gt-zero _ GT\n    <- add-preserves-count-converse MC1 MA (nat`ne/> GT) MC1'\n    <- {v} {vl} {vl':varadjlevel' v (s M) (s N)} \n       {vsd:varlevel-nonzero-shifts-over vl vl'}\n       {vsb:varlevel-shifts-back vl' vl}\n       shift-varlevel/L1 (F v vl) (FS v vl) MA' (F' v vl') (FS' v vl').\n\n- : shift-varlevel/L1 \n\t(eql/var P VL1 VL2) eqlsize/var MA\n\t(eql'/var P VL1' VL2') eqlsize'/var\n    <- varlevel-zero-shifts-down VL1 VL1'\n    <- varlevel-zero-shifts-down VL2 VL2'.\n\n- : shift-varlevel/L1\n\t(eql/var P VL1 VL2) eqlsize/var MA\n\t(eql'/var P VL1' VL2') eqlsize'/var\n    <- varlevel-nonzero-shifts-over VL1 VL1'\n    <- varlevel-nonzero-shifts-over VL2 VL2'.\n\n%worlds (blocksimple | shiftdown | noshift) \n\t(shift-varlevel/L1 _ _ _ _ _)\n\t(shift-varlevel/L1/rec _ _ _ _ _ _).\n%total (E El) (shift-varlevel/L1 E _ _ _ _)\n              (shift-varlevel/L1/rec El _ _ _ _ _).\n \n\n%theorem shift-varlevel/L2 :\n\tforall* {N} {M} {A} {T1} {T2} {S} {MN} {MM}\n\tforall\t{E': eql*' N M A T1 T2}\n\t\t{ES': eqlsize' E' S MN MM}\n\texists\t{E: eql* N M A T1 T2}\n\t\t{ES: eqlsize E S MN MM}\n\ttrue.\n\n- : shift-varlevel/L2 (eql'/eq eq/) eqlsize'/eq (eql/eq eq/) eqlsize/eq.\n\n- : shift-varlevel/L2\n\t(eql'/app E1' E2') (eqlsize'/app ES1' ES2' MAX MIN MAX2)\n\t(eql/app E1 E2) (eqlsize/app ES1 ES2 MAX MIN MAX2)\n    <- shift-varlevel/L2 E1' ES1' E1 ES1\n    <- shift-varlevel/L2 E2' ES2' E2 ES2.\n\n- : shift-varlevel/L2 (eql'/lam1 ([v] (F v))) (eqlsize'/lam1 FS)\n                      (eql/lam1 ([v] (F' v))) (eqlsize/lam1 FS')\n    <- {v} shift-varlevel/L2 (F v) (FS v) (F' v) (FS' v).\n\n- : shift-varlevel/L2 (eql'/lam2 MC MA ([v] [vl'] (F v vl')))\n\t\t      (eqlsize'/lam2 FS MM)\n                      (eql/lam2 MC MA ([v] [vl] (F' v vl)))\n\t\t      (eqlsize/lam2 FS' MM)\n    <- {v} {vl'} {vl} {vsb:varlevel-shifts-back vl' vl}\n       shift-varlevel/L2 (F v vl') (FS v vl') (F' v vl) (FS' v vl).\n\n- : shift-varlevel/L2 (eql'/rec1 ([v] (F v))) (eqlsize'/rec1 FS)\n                      (eql/rec1 ([v] (F' v))) (eqlsize/rec1 FS')\n    <- {v} shift-varlevel/L2 (F v) (FS v) (F' v) (FS' v).\n\n- : shift-varlevel/L2 (eql'/rec2 P MC MA ([v] [vl'] (F v vl')))\n\t\t      (eqlsize'/rec2 FS MN MM)\n                      (eql/rec2 P MC MA ([v] [vl] (F' v vl)))\n\t\t      (eqlsize/rec2 FS' MN MM)\n    <- {v} {vl'} {vl} {vsb:varlevel-shifts-back vl' vl}\n       shift-varlevel/L2 (F v vl') (FS v vl') (F' v vl) (FS' v vl).\n\n- : shift-varlevel/L2 (eql'/var P VL1 VL2) eqlsize'/var \n                      (eql/var P VL1' VL2') eqlsize/var\n    <- varlevel-shifts-back VL1 VL1'\n    <- varlevel-shifts-back VL2 VL2'.\n\n%worlds (blocksimple | shiftback | noshift) (shift-varlevel/L2 _ _ _ _).\n%total (E)  (shift-varlevel/L2 E _ _ _).\n\n\n%{\nNow we put these two parts into one that hides the alternative definitions.\n}%\n\n%theorem shift-varlevel :\n\tforall* {N} {A} {M0} {M1} {T1} {T2} {S} {MN} {MM}\n\tforall\t{E: eql* N A M1 T1 T2}\n\t\t{ES:eqlsize E S MN MM}\n\t\t{MA:multiset`add M0 z M1}\n\texists\t{E': eql* N A M0 T1 T2}\n\t\t{ES':eqlsize E' S MN MM}\n\ttrue.\n\n- : shift-varlevel E1 ES1 MA E3 ES3\n    <- shift-varlevel/L1 E1 ES1 MA E2 ES2\n    <- shift-varlevel/L2 E2 ES2 E3 ES3.\n\n%worlds (blocksimple | noshift) (shift-varlevel _ _ _ _ _).\n%total { } (shift-varlevel _ _ _ _ _).\n\n\n%{\nNow the whole reason for the two stage var-levels:\nwe have a lemma that says we can adjust the M of\nall variables down if the minimum varlevel used is greater than zero.\nFirst we need some helper lemmas and the ubiquitous blocks.\n}%\n\n%theorem varlevel-adjusts-down :\n\tforall* {N} {V:term N} {M} {L}\n\tforall\t{VL:varadjlevel V (s M) (s L)}\n\texists\t{VL':varadjlevel' V M (s L)}\n\ttrue.\n\n%block adjustdown : some {n} {m} {l}\n\t\t     block {v:term n} \n\t\t      {vl:varadjlevel v (s m) (s l)}\n\t\t      {vl':varadjlevel' v m (s l)}\n\t\t      {vsd:varlevel-adjusts-down vl vl'}.\n\nfake : type.\n- : fake <- ({x:varlevel-adjusts-down X Y} varlevel-adjusts-down X' Y').\n\n%worlds (blocksimple | adjustdown) (varlevel-adjusts-down _ _).\n\n%total { } (varlevel-adjusts-down _ _).\n\n\n%theorem false-implies-eql' :\n\tforall* {MS} {N} {A} {T1} {T2} \n\tforall\t{F:void}\n\texists\t{E:eql*' N A MS T1 T2}\n\ttrue.\n\n%worlds (blocksimple | adjustdown) (false-implies-eql' _ _).\n%total { }  (false-implies-eql' _ _).\n\n\n%theorem false-implies-eqlsize' :\n\tforall* {N} {A} {MS} {T1} {T2} {S} {B} {M}\n\t\t{E:eql*' N A MS T1 T2}\n\tforall\t{F:void}\n\texists\t{ES1:eqlsize' E S B M}\n\ttrue.\n\n%worlds (blocksimple | adjustdown) (false-implies-eqlsize' _ _).\n%total { } (false-implies-eqlsize' _ _).\n\n\n%theorem eqlsize-respects-eq :\n\tforall* {N} {A} {MS} {T1} {T2} \n\t\t{S1} {B1} {M1}\n\t\t{S2} {B2} {M2}\n\t\t{E:eql* N A MS T1 T2}\n\tforall\t{ES1:eqlsize E S1 B1 M1}\n\t\t{SE: nat`eq S1 S2}\n\t\t{BE: nat`eq B1 B2}\n\t\t{ME: nat`eq M1 M2}\n\texists\t{ES2:eqlsize E S2 B2 M2}\n\ttrue.\n\n- : eqlsize-respects-eq ES nat`eq/ nat`eq/ nat`eq/ ES.\n\n%worlds (blocksimple | blockvaradj | adjustdown) \n\t(eqlsize-respects-eq _ _ _ _ _).\n%total { } (eqlsize-respects-eq _ _ _ _ _).\n\n\n%theorem adjust-varlevel/L0 :\n\tforall* {N} {A} {M0} {M1} {T1} {T2} {S} {MN}\n\tforall\t{E: eql* N A M1 T1 T2}\n\t\t{ES:eqlsize E S (s MN) z}\n\texists\t{E': eql*' N (s A) M0 T1 T2} {MN'}\n\t\t{ES':eqlsize' E' S MN' z}\n\ttrue.\n\n- : adjust-varlevel/L0\n\t(eql/eq eq/) (eqlsize/eq) (eql'/eq eq/) _ (eqlsize'/eq).\n\n- : adjust-varlevel/L0\n\t(eql/app E1 E2) (eqlsize/app ES1 ES2 MAX MIN MAX2)\n\t(eql'/app E1' E2') _ (eqlsize'/app ES1'' ES2'' MAX MIN' nat`max/=)\n    <- max-implies-ge MAX2 ZERO>=M1 ZERO>=M2\n    <- ge-zero-always M1 M1>=0\n    <- ge-zero-always M2 M2>=0\n    <- nat`ge-anti-symmetric M1>=0 ZERO>=M1 M1=0\n    <- nat`ge-anti-symmetric M2>=0 ZERO>=M2 M2=0\n    <- min-implies-ge MIN B1>=B+1 B2>=B+1\n    <- ge-succ-implies-gt B1>=B+1 B1>B\n    <- ge-succ-implies-gt B2>=B+1 B2>B\n    <- gt-implies-positive B1>B B1' B1=B1'+1\n    <- gt-implies-positive B2>B B2' B2=B2'+1\n    <- eqlsize-respects-eq ES1 nat`eq/ B1=B1'+1 M1=0 ES1'\n    <- eqlsize-respects-eq ES2 nat`eq/ B2=B2'+1 M2=0 ES2'\n    <- adjust-varlevel/L0 E1 ES1' E1' _ ES1''\n    <- adjust-varlevel/L0 E2 ES2' E2' _ ES2''\n    <- nat`min-total MIN'.\n   \n- : adjust-varlevel/L0 (eql/lam1 ([v] (F v))) (eqlsize/lam1 FS)\n                      (eql'/lam1 ([v] (F' v))) MN' (eqlsize'/lam1 FS')\n    <- {v} adjust-varlevel/L0 (F v) (FS v) (F' v) MN' (FS' v).\n\n- : adjust-varlevel/L0 (eql/rec1 ([v] (F v))) (eqlsize/rec1 FS)\n                      (eql'/rec1 ([v] (F' v))) MN' (eqlsize'/rec1 FS')\n    <- {v} adjust-varlevel/L0 (F v) (FS v) (F' v) MN' (FS' v).\n\n- : adjust-varlevel/L0\n\t(eql/var P VL1 VL2) eqlsize/var\n\t(eql'/var P' VL1' VL2') _ eqlsize'/var\n    <- plus-swap-succ-converse P P'\n    <- varlevel-adjusts-down VL1 VL1'\n    <- varlevel-adjusts-down VL2 VL2'.\n\n%worlds (blocksimple | adjustdown) (adjust-varlevel/L0 _ _ _ _ _).\n%total (E) (adjust-varlevel/L0 E _ _ _ _).\n\n\n%theorem adjust-varlevel/L1 :\n\tforall* {N} {A} {M0} {M1} {T1} {T2} {S} {MN} {MM}\n\tforall\t{E: eql* N A M1 T1 T2}\n\t\t{ES:eqlsize E S (s MN) (s MM)}\n\t\t{MS:multiset`shift z M0 M1}\n\texists\t{E': eql*' N (s A) M0 T1 T2} {MN'}\n\t\t{ES':eqlsize' E' S MN' MM}\n\ttrue.\n\n% MAX2 = max z z case (contradiction)\n- : adjust-varlevel/L1 \n\t(eql/app E1 E2) (eqlsize/app ES1 ES2 MAX MIN (MAX2:nat`max z z (s MM)))\n         _ E' z ES'\n    <- nat`max-deterministic nat`max/= MAX2 nat`eq/ nat`eq/ ZERO=MM+1\n    <- nat`eq-contradiction ZERO=MM+1 F\n    <- false-implies-eql' F E'\n    <- false-implies-eqlsize' F ES'.\n\n% MAX2 = max z (s MM2) (s MM)\n- : adjust-varlevel/L1 \n\t(eql/app E1 E2) (eqlsize/app ES1 ES2 MAX MIN MAX2) MS\n\t(eql'/app E1' E2') _ (eqlsize'/app ES1'' ES2'' MAX MIN' MAX2')\n    <- min-implies-ge MIN B1>=B+1 B2>=B+1\n    <- ge-succ-implies-gt B1>=B+1 B1>B\n    <- ge-succ-implies-gt B2>=B+1 B2>B\n    <- gt-implies-positive B1>B B1' B1=B1'+1\n    <- gt-implies-positive B2>B B2' B2=B2'+1\n    <- eqlsize-respects-eq ES1 nat`eq/ B1=B1'+1 nat`eq/ ES1'\n    <- eqlsize-respects-eq ES2 nat`eq/ B2=B2'+1 nat`eq/ ES2'\n    <- adjust-varlevel/L0 E1 ES1' E1' _ ES1''\n    <- adjust-varlevel/L1 E2 ES2' MS E2' _ ES2''\n    <- succ-implies-gt-zero _ MM2+1>0\n    <- nat`max-deterministic (max/< MM2+1>0) MAX2 nat`eq/ nat`eq/ MM2+1=MM+1\n    <- succ-cancels MM2+1=MM+1 MM2=MM\n    <- nat`ge-zero-always _ MM2>=0\n    <- nat`le-implies-max MM2>=0 MAX2''\n    <- nat`max-respects-eq MAX2'' nat`eq/ nat`eq/ MM2=MM MAX2'\n    <- nat`min-total MIN'.\n\n% MAX2 = max (s MM1) z (s MM)\n- : adjust-varlevel/L1 \n\t(eql/app E1 E2) (eqlsize/app ES1 ES2 MAX MIN MAX2) MS\n\t(eql'/app E1' E2') _ (eqlsize'/app ES1'' ES2'' MAX MIN' MAX2')\n    <- min-implies-ge MIN B1>=B+1 B2>=B+1\n    <- ge-succ-implies-gt B1>=B+1 B1>B\n    <- ge-succ-implies-gt B2>=B+1 B2>B\n    <- gt-implies-positive B1>B B1' B1=B1'+1\n    <- gt-implies-positive B2>B B2' B2=B2'+1\n    <- eqlsize-respects-eq ES1 nat`eq/ B1=B1'+1 nat`eq/ ES1'\n    <- eqlsize-respects-eq ES2 nat`eq/ B2=B2'+1 nat`eq/ ES2'\n    <- adjust-varlevel/L1 E1 ES1' MS E1' _ ES1''\n    <- adjust-varlevel/L0 E2 ES2' E2' _ ES2''\n    <- succ-implies-gt-zero _ MM1+1>0\n    <- nat`max-deterministic (max/> MM1+1>0) MAX2 nat`eq/ nat`eq/ MM1+1=MM+1\n    <- succ-cancels MM1+1=MM+1 MM1=MM\n    <- nat`ge-zero-always _ MM1>=0\n    <- nat`ge-implies-max MM1>=0 MAX2''\n    <- nat`max-respects-eq MAX2'' nat`eq/ nat`eq/ MM1=MM MAX2'\n    <- nat`min-total MIN'.\n\n- : adjust-varlevel/L1 \n\t(eql/app E1 E2) (eqlsize/app ES1 ES2 MAX MIN MAX2) MS\n\t(eql'/app E1' E2') _ (eqlsize'/app ES1'' ES2'' MAX MIN' MAX2')\n    <- min-implies-ge MIN B1>=B+1 B2>=B+1\n    <- ge-succ-implies-gt B1>=B+1 B1>B\n    <- ge-succ-implies-gt B2>=B+1 B2>B\n    <- gt-implies-positive B1>B B1' B1=B1'+1\n    <- gt-implies-positive B2>B B2' B2=B2'+1\n    <- eqlsize-respects-eq ES1 nat`eq/ B1=B1'+1 nat`eq/ ES1'\n    <- eqlsize-respects-eq ES2 nat`eq/ B2=B2'+1 nat`eq/ ES2'\n    <- adjust-varlevel/L1 E1 ES1' MS E1' _ ES1''\n    <- adjust-varlevel/L1 E2 ES2' MS E2' _ ES2''\n    <- succ-preserves-max-converse MAX2 MAX2'\n    <- nat`min-total MIN'.\n\n- : adjust-varlevel/L1 (eql/lam1 ([v] (F v))) (eqlsize/lam1 FS) MS\n                      (eql'/lam1 ([v] (F' v))) MN' (eqlsize'/lam1 FS')\n    <- {v} adjust-varlevel/L1 (F v) (FS v) MS (F' v) MN' (FS' v).\n\n- : adjust-varlevel/L1 (eql/rec1 ([v] (F v))) (eqlsize/rec1 FS) MS\n                      (eql'/rec1 ([v] (F' v))) MN' (eqlsize'/rec1 FS')\n    <- {v} adjust-varlevel/L1 (F v) (FS v) MS (F' v) MN' (FS' v).\n\n- : adjust-varlevel/L1 \n\t(eql/rec2 P MC1 MA1 ([v] [vl:varadjlevel v z (s N)] (F v vl)))\n\t(eqlsize/rec2 FS MN MM) _ EQ z ES\n    <- min-implies-ge MN ZERO>=B+1 _\n    <- ge-succ-implies-gt ZERO>=B+1 ZERO>B\n    <- gt-contradiction ZERO>B V\n    <- false-implies-eql' V EQ\n    <- false-implies-eqlsize' V ES.\n\n- : adjust-varlevel/L1 \n\t(eql/rec2 P MC1 MA1 ([v] [vl:varadjlevel v (s M) (s N)] (F v vl)))\n\t(eqlsize/rec2 FS MN MM) MS\n        (eql'/rec2 P' MC1' MA1' ([v] [vl:varadjlevel' v M (s N)] (F' v vl))) _\n\t(eqlsize'/rec2 FS'' MN' MM')\n    <- plus-swap-succ-converse P P'\n    <- nat`min-implies-ge MN _ B2>=B+1\n    <- ge-succ-implies-gt B2>=B+1 B2>B\n    <- gt-implies-positive B2>B B2' B2=B2'+1    \n    <- ({v} {vl} \n\t  eqlsize-respects-eq (FS v vl) nat`eq/ B2=B2'+1 nat`eq/ (FS' v vl))\n    <- shift-preserves-add-converse MA1 MS (plus/s plus/z) _ MS' MA1'\n    <- ({v} {vl} {vl':varadjlevel' v M (s N)} \n\t  {vsd:varlevel-adjusts-down vl vl'}\n\t  adjust-varlevel/L0 (F v vl) (FS' v vl) (F' v vl') _ (FS'' v vl'))\n    <- shift-preserves-count-converse MC1 MS (plus/s plus/z) MC1'\n    <- succ-implies-gt-zero _ MM1+1>0\n    <- nat`max-deterministic (max/> MM1+1>0) MM nat`eq/ nat`eq/ MM1+1=MM+1\n    <- succ-cancels MM1+1=MM+1 MM1=MM\n    <- nat`ge-zero-always _ MM1>=0\n    <- nat`ge-implies-max MM1>=0 MAX2''\n    <- nat`max-respects-eq MAX2'' nat`eq/ nat`eq/ MM1=MM MM'\n    <- nat`min-total MN'.\n\n- : adjust-varlevel/L1 \n\t(eql/rec2 P MC1 MA1 ([v] [vl:varadjlevel v (s M) (s N)] (F v vl)))\n\t(eqlsize/rec2 FS MN MM) MS\n        (eql'/rec2 P' MC1' MA1' ([v] [vl:varadjlevel' v M (s N)] (F' v vl))) _\n\t(eqlsize'/rec2 FS'' MN' MM')\n    <- plus-swap-succ-converse P P'\n    <- nat`min-implies-ge MN _ B2>=B+1\n    <- ge-succ-implies-gt B2>=B+1 B2>B\n    <- gt-implies-positive B2>B B2' B2=B2'+1    \n    <- ({v} {vl} \n\t  eqlsize-respects-eq (FS v vl) nat`eq/ B2=B2'+1 nat`eq/ (FS' v vl))\n    <- shift-preserves-add-converse MA1 MS (plus/s plus/z) _ MS' MA1'\n    <- ({v} {vl} {vl':varadjlevel' v M (s N)} \n\t  {vsd:varlevel-adjusts-down vl vl'}\n\t  adjust-varlevel/L1 (F v vl) (FS' v vl) MS' (F' v vl') _ (FS'' v vl'))\n    <- shift-preserves-count-converse MC1 MS (plus/s plus/z) MC1'\n    <- nat`min-total MN'\n    <- succ-preserves-max-converse MM MM'.\n\n%worlds (blocksimple | adjustdown) (adjust-varlevel/L1 _ _ _ _ _ _).\n%total (E) (adjust-varlevel/L1 E _ _ _ _ _).\n\n\n%theorem adjust-varlevel :\n\tforall* {N} {A} {M0} {M1} {T1} {T2} {S} {MN} {MM}\n\tforall\t{E: eql* N A M1 T1 T2}\n\t\t{ES:eqlsize E S (s MN) (s MM)}\n\t\t{MS:multiset`shift z M0 M1}\n\texists\t{E': eql* N (s A) M0 T1 T2} {MN'}\n\t\t{ES':eqlsize E' S MN' MM}\n\ttrue.\n\n- : adjust-varlevel E ES MS E'' _ ES''\n    <- adjust-varlevel/L1 E ES MS E' _ ES'\n    <- shift-varlevel/L2 E' ES' E'' ES''.\n\n%worlds (blocksimple) (adjust-varlevel _ _ _ _ _ _).\n%total { } (adjust-varlevel _ _ _ _ _ _).\n\n\n\n%{ === Removing variable levels altogether === }%\n\n%{\nThe following blocks are used when we remove the level for\nthe outermost (level 1) variable of adjusted index zero.\nAll other variables are at least level 2 or non-zero adjusted index.  \n\"blockvar2\" and \"blockvaradj\" makes this context explicit.\n(I probably could substitute noshift for blockvaradj\n}%\n\n\n%block blockvar2 : some {l} {n}  \n\t\t    block {v:term n} {vl:varadjlevel v z (s (s l))}.\n%block blockvaradj : some {m} {l} {n}\n\t\t      block {v:term n} {vl:varadjlevel v (s m) (s l)}.\n\n%theorem remove-one-var :\n\tforall* {N} {N'} {F1} {F2} {S} {A} {M} {NZ} {MN} {MM}\n\tforall  {E:{v:term N} {vl:varadjlevel v z (s z)} \n\t\t     (eql* N' A M (F1 v) (F2 v))}\n\t        {ES:{v} {vl} eqlsize (E v vl) S MN MM}\n\t\t{MC: multiset`count M z (s NZ)}\n\texists\t{E':{v:term N} (eql A M (F1 v) (F2 v))}\n\t\t{ES':{v} eqlsize (E' v) S MN MM}\n\ttrue.\n\n- : remove-one-var ([v] [vl] eql/eq eq/) ([v] [vl] eqlsize/eq) _\n                   ([v] eql/eq eq/) ([v] eqlsize/eq).\n\n- : remove-one-var ([v] [vl] (eql/app (FE v vl) (AE v vl))) \n\t\t   ([v] [vl] (eqlsize/app (ESF v vl) (ESA v vl) MX MN MX2)) MC\n                   ([v] (eql/app (FE' v) (AE' v)))\n                   ([v] (eqlsize/app (ESF' v) (ESA' v) MX MN MX2))\n    <- remove-one-var FE ESF MC FE' ESF'\n    <- remove-one-var AE ESA MC AE' ESA'.\n\n- : remove-one-var ([v] [vl] eql/lam1 ([v'] (F v' v vl)))\n\t\t   ([v] [vl] eqlsize/lam1 ([v'] (FS v' v vl))) MC\n                   ([v] eql/lam1 ([v'] (F' v' v)))\n                   ([v] eqlsize/lam1 ([v'] (FS' v' v)))\n    <- {v'} remove-one-var (F v') (FS v') MC (F' v') (FS' v').\n\n%theorem remove-one-var/lam2 :\n\tforall* {N0} {N1} {N2} {N3} {N1'} {S} {A} {M0} {M1} {F1} {F2} {MN} {MM}\n\tforall\t{E:{v':term N0} {vl':varadjlevel v' z (s N1)}\n\t\t     {v:term N2} {vl:varadjlevel v z (s z)}\n\t\t     (eql* N3 A M1 (F1 v' v) (F2 v' v))}\n\t\t{ES:{v':term N0} {vl':varadjlevel v' z (s N1)}\n\t\t     {v:term N2} {vl:varadjlevel v z (s z)}\n\t\t     (eqlsize (E v' vl' v vl) S MN MM)}\n\t\t{MC: multiset`count M0 z N1}\n\t\t{MA: multiset`add M0 z M1}\n\t\t{EQ: nat`eq N1 (s N1')}\n\texists\t{E': {v':term N0} {vl':varadjlevel v' z (s N1)}\n\t\t      {v:term N2}\n\t\t      (eql* N3 A M1 (F1 v' v) (F2 v' v))}\n\t\t{ES':{v':term N0} {vl':varadjlevel v' z (s N1)}\n\t\t       {v:term N2}\n\t\t       (eqlsize (E' v' vl' v) S MN MM)}\n\ttrue.\n\n- : remove-one-var/lam2 E ES MC0 MA nat`eq/ E' ES'\t\t     \n    <- count-add-implies-count MC0 MA MC1\n    <- {v'} {vl'} remove-one-var (E v' vl') (ES v' vl') MC1 \n                                 (E' v' vl') (ES' v' vl').\n\n- : remove-one-var ([v] [vl] eql/lam2 MC MA  ([v'] [vl'] (F v' vl' v vl)))\n\t\t   ([v] [vl] eqlsize/lam2 ([v'] [vl'] (FS v' vl' v vl)) MM) MC0\n                   ([v] eql/lam2 MC MA ([v'] [vl'] (F' v' vl' v)))\n                   ([v] eqlsize/lam2 ([v'] [vl'] (FS' v' vl' v)) MM)\n    <- count-deterministic MC MC0 multiset`eq/ nat`eq/ EQ\n    <- remove-one-var/lam2 F FS MC (MA:add M0 z M1) EQ F' FS'.\n\n- : remove-one-var ([v] [vl] eql/rec1 ([v'] (F v' v vl)))\n\t\t   ([v] [vl] eqlsize/rec1 ([v'] (FS v' v vl))) MC\n                   ([v] eql/rec1 ([v'] (F' v' v)))\n                   ([v] eqlsize/rec1 ([v'] (FS' v' v)))\n    <- {v'} remove-one-var (F v') (FS v') MC (F' v') (FS' v').\n\n- : remove-one-var ([v] [vl] eql/rec2 P MC MA  ([v'] [vl'] (F v' vl' v vl)))\n\t\t   ([v] [vl] eqlsize/rec2 ([v'] [vl'] (FS v' vl' v vl)) MN MM) MC0\n                   ([v] eql/rec2 P MC MA ([v'] [vl'] (F' v' vl' v)))\n                   ([v] eqlsize/rec2 ([v'] [vl'] (FS' v' vl' v)) MN MM)\n    <- count-deterministic MC MC0 multiset`eq/ nat`eq/ EQ\n    <- remove-one-var/lam2 F FS MC MA EQ F' FS'.\n\n- : remove-one-var ([v] [vl] eql/rec2 P MC MA  ([v'] [vl'] (F v' vl' v vl)))\n\t\t   ([v] [vl] eqlsize/rec2 ([v'] [vl'] (FS v' vl' v vl)) MN MM) MC0\n                   ([v] eql/rec2 P MC MA ([v'] [vl'] (F' v' vl' v)))\n                   ([v] eqlsize/rec2 ([v'] [vl'] (FS' v' vl' v)) MN MM)\n    <- succ-implies-gt-zero _ GT\n    <- add-preserves-count MC0 MA (nat`ne/< GT) MC1\n    <- {v'} {vl'} remove-one-var (F v' vl') (FS v' vl') MC1 \n                                 (F' v' vl') (FS' v' vl').\n\n- : remove-one-var ([v] [vl] eql/var P vl vl) ([v] [vl] eqlsize/var) _\n                   ([v] eql/eq eq/) ([v] eqlsize/eq).\n\n- : remove-one-var ([v] [vl] eql/var P VL1 VL2) ([v] [vl] eqlsize/var) _\n                   ([v] eql/var P VL1 VL2) ([v] eqlsize/var).\n\n%worlds (blocksimple | blockvar2 | blockvaradj | noshift) \n        (remove-one-var _ _ _ _ _) (remove-one-var/lam2 _ _ _ _ _ _ _).\n%total (E El) (remove-one-var E _ _ _ _)\n              (remove-one-var/lam2 El _ _ _ _ _ _).\n\n%{\nWe now have the machinery needed to get rid of all level 0 variables\nin one recursive sweep.\n}%\n\n%theorem remove-zero-index-vars :\n\tforall* {N} {A} {MS} {T1} {T2} {MN} {MM}\n\tforall\t{E: eql* N A MS T1 T2} {S}\n\t\t{ES:eqlsize E S MN MM}\n\t\t{MC:multiset`count MS z z} \n\texists\t{E': eql* N A MS T1 T2} {MN'} {MM'}\n\t\t{ES':eqlsize E' S (s MN') MM'}\n\t\t{G: nat`ge MM MM'}\n\ttrue.\n\n- : remove-zero-index-vars\n\t(eql/eq E) _ (eqlsize/eq) _ (eql/eq E) _ _ (eqlsize/eq) \n\t(nat`ge/= nat`eq/).\n\n- : remove-zero-index-vars\n\t(eql/app E1 E2) (s S) (eqlsize/app ES1 ES2 MAX1 _ MAX2) MC\n\t(eql/app E1' E2') _ _ (eqlsize/app ES1' ES2' MAX1 MIN' MAX2')\n\tGE\n    <- nat`max-implies-ge MAX1 S>=S1 S>=S2\n    <- ge-implies-succ-gt S>=S1 S+1>S1\n    <- ge-implies-succ-gt S>=S2 S+1>S2\n    <- nat`meta-gt _ _ S+1>S1\n    <- nat`meta-gt _ _ S+1>S2\n    <- remove-zero-index-vars E1 S1 ES1 MC E1' _ _ ES1' GE1\n    <- remove-zero-index-vars E2 S2 ES2 MC E2' _ _ ES2' GE2\n    <- nat`min-total MIN\n    <- succ-preserves-min MIN MIN'\n    <- nat`max-total MAX2'\n    <- max-preserves-ge* GE1 GE2 MAX2 MAX2' GE.\n\n- : remove-zero-index-vars\n\t(eql/lam1 FE) _ (eqlsize/lam1 FES) MC\n\t(eql/lam1 FE') _ _ (eqlsize/lam1 FES') GE\n    <- {v} remove-zero-index-vars (FE v) _ (FES v) MC (FE' v) _ _ (FES' v) GE.\n\n- : remove-zero-index-vars \n\t(eql/lam2 MC0 (MA0:add MS0 z MS1) ([v] [vl] FE0 v vl)) _\n\t(eqlsize/lam2 ([v] [vl] FES0 v vl) MAX) MC\n        (eql/lam1 ([v] FE3 v)) _ _ \n\t(eqlsize/lam1 ([v] FES3 v)) GE'\n    <- count-add-implies-count MC0 MA0 MC1\n    <- remove-one-var FE0 FES0 MC1 FE1 FES1\n    <- ({v} shift-varlevel (FE1 v) (FES1 v) MA0 (FE2 v) (FES2 v))\n    <- ({v} remove-zero-index-vars (FE2 v) S' (FES2 v) MC\n\t  (FE3 v) _ _ (FES3 v) GE)\n    <- nat`max-implies-ge MAX _ GE1\n    <- nat`ge-transitive GE1 GE GE'.\n\n- : remove-zero-index-vars \n\t(eql/lam2 (MC0:count MS0 z (s C)) MA0 ([v] [vl] FE0 v vl)) _\n\t(eqlsize/lam2 ([v] [vl] FES0 v vl) MAX) MC\n        EQ z z EQS GE\n    <- multiset`count-deterministic MC MC0 multiset`eq/ nat`eq/ ZERO=C+1\n    <- nat`eq-contradiction ZERO=C+1 F\n    <- false-implies-eql F EQ\n    <- false-implies-eqlsize F EQS\n    <- nat`false-implies-ge F GE.\n\n- : remove-zero-index-vars\n\t(eql/rec1 FE) _ (eqlsize/rec1 FES) MC\n\t(eql/rec1 FE') _ _ (eqlsize/rec1 FES') GE\n    <- {v} remove-zero-index-vars (FE v) _ (FES v) MC (FE' v) _ _ (FES' v) GE.\n\n- : remove-zero-index-vars \n\t(eql/rec2 P MC0 (MA0:add MS0 z MS1) ([v] [vl] FE0 v vl)) _\n\t(eqlsize/rec2 ([v] [vl] FES0 v vl) MIN MAX) MC\n        (eql/rec1 ([v] FE3 v)) _ _\n\t(eqlsize/rec1 ([v] FES3 v)) GE'\n    <- count-add-implies-count MC0 MA0 MC1\n    <- remove-one-var FE0 FES0 MC1 FE1 FES1\n    <- ({v} shift-varlevel (FE1 v) (FES1 v) MA0 (FE2 v) (FES2 v))\n    <- ({v} remove-zero-index-vars (FE2 v) S' (FES2 v) MC\n\t  (FE3 v) _ _ (FES3 v) GE)\n    <- nat`max-implies-ge MAX _ GE1\n    <- nat`ge-transitive GE1 GE GE'.\n\n- : remove-zero-index-vars \n\t(eql/rec2 P MC0 (MA0:add MS0 z MS1) ([v] [vl] FE0 v vl)) _\n\t(eqlsize/rec2 ([v] [vl] FES0 v vl) MIN MAX) MC\n        EQ z z EQS GE\n    <- multiset`count-deterministic MC MC0 multiset`eq/ nat`eq/ ZERO=C+1\n    <- nat`eq-contradiction ZERO=C+1 F\n    <- false-implies-eql F EQ\n    <- false-implies-eqlsize F EQS\n    <- nat`false-implies-ge F GE.\n\n- : remove-zero-index-vars \n\t(eql/rec2 P MC0 (MA0:add MS0 (s M) MS1) ([v] [vl] FE0 v vl)) _\n\t(eqlsize/rec2 ([v] [vl] FES0 v vl) _ (MAX:max (s (s M)) MM2 MM)) MC\n        (eql/rec2 P MC0 MA0 ([v] [vl] FE1 v vl)) _ _\n\t(eqlsize/rec2 ([v] [vl] FES1 v vl) MIN' MAX') GE'\n    <- ge-zero-always M M>=0\n    <- ge-implies-succ-gt M>=0 M+1>0\n    <- add-preserves-count MC MA0 (nat`ne/< M+1>0) MC'\n    <- ({v} {vl} {vl'} (varlevel-nonzero-shifts-over vl vl')\n\t  -> (varlevel-shifts-back vl' vl) \n\t  -> (remove-zero-index-vars (FE0 v vl) S' (FES0 v vl) MC'\n\t\t(FE1 v vl) _ _ (FES1 v vl) GE))\n    <- nat`min-total MIN\n    <- succ-preserves-min MIN MIN'\n    <- nat`max-total MAX'\n    <- max-preserves-ge* (nat`ge/= nat`eq/) GE MAX MAX' GE'.\n\n- : remove-zero-index-vars\n\t(eql/var P VL1 VL2) _ (eqlsize/var) _\n\t(eql/var P VL1 VL2) _ _ (eqlsize/var) (nat`ge/= nat`eq/).\n\n%worlds (blocksimple | noshift) (remove-zero-index-vars _ _ _ _ _ _ _ _ _).\n%total (S) (remove-zero-index-vars _ S _ _ _ _ _ _ _).\n\n\n%theorem lit-preserves-eq :\n\tforall* {M1} {M2}\n\tforall\t{EQ:nat`eq M1 M2}\n\texists\t{EQ':eq (lit M1) (lit M2)}\n\ttrue.\n\n- : lit-preserves-eq nat`eq/ eq/.\n\n%worlds (blocksimple | blockvar) (lit-preserves-eq _ _).\n%total { } (lit-preserves-eq _ _).\n\n\n%theorem app-preserves-eq :\n\tforall* {N1} {N2}\n\t\t{T1:term (s N1)} {T2:term (s N2)} {T3} {T4}\n\tforall\t{E:eq T1 T2} {E: eq T3 T4}\n\texists\t{BE:eq (app T1 T3) (app T2 T4)}\n\ttrue.\n\n- : app-preserves-eq eq/ eq/ eq/.\n\n%worlds (blocksimple) (app-preserves-eq _ _ _).\n%total { } (app-preserves-eq _ _ _).\n\n\n%theorem lam-preserves-eq :\n\tforall* {N1} {N2} {F1:t -> term N1} {F2: t -> term N2}\n\tforall\t{E:{v} eq (F1 v) (F2 v)}\n\texists\t{E:eq (lam F1) (lam F2)}\n\ttrue.\n\n- : lam-preserves-eq ([v] eq/) eq/.\n\n%worlds (blocksimple) (lam-preserves-eq _ _).\n%total { } (lam-preserves-eq _ _).\n\n\n%theorem rec-preserves-eq :\n\tforall* {N}\n\t\t{F1:term (s N) -> term (s N)} \n\t\t{F2:term (s N) -> term (s N)}\n\tforall\t{E:{v} eq (F1 v) (F2 v)}\n\texists\t{E:eq (rec F1) (rec F2)}\n\ttrue.\n\n- : rec-preserves-eq ([v] eq/) eq/.\n\n%worlds (blocksimple) (rec-preserves-eq _ _).\n%total { } (rec-preserves-eq _ _).\n\n\n%{\nNext the main lemma that says we can avoid looking at varlevels in checking\nequality.  We remove the outside variable, shift remaining variables,\nand then recurse (hence the need for tracking eqlsize).  Note that we\nnever put var levels in the context.\n}%\n\n%theorem eql-implies-eq :\n\tforall* {N} {T1:term N} {T2:term N}\n\tforall\t{E:eql z multiset`map/0 T1 T2}\n\texists\t{E':eq T1 T2}\n\ttrue.\n\n%theorem eql-implies-eq/L0 :\n\tforall* {N} {A} {MS} {T1} {T2} {S} {MN}\n\tforall\t{E: eql* N A MS T1 T2}\n\t\t{ES:eqlsize E S MN z}\n\texists\t{E: eq T1 T2}\n\ttrue.\n\n- : eql-implies-eq/L0 (eql/eq E) _ E.\n\n- : eql-implies-eq/L0 (eql/app E1 E2) (eqlsize/app ES1 ES2 MAX1 MIN MAX2) E'\n    <- max-implies-ge MAX2 ZERO>=M1 ZERO>=M2\n    <- ge-zero-always _ M1>=0\n    <- ge-zero-always _ M2>=0\n    <- ge-anti-symmetric M1>=0 ZERO>=M1 M1=0\n    <- ge-anti-symmetric M2>=0 ZERO>=M2 M2=0\n    <- eqlsize-respects-eq ES1 nat`eq/ nat`eq/ M1=0 ES1'\n    <- eqlsize-respects-eq ES2 nat`eq/ nat`eq/ M2=0 ES2'\n    <- eql-implies-eq/L0 E1 ES1' E1'\n    <- eql-implies-eq/L0 E2 ES2' E2'\n    <- app-preserves-eq E1' E2' E'.\n\n- : eql-implies-eq/L0 (eql/lam1 ([v] E v)) (eqlsize/lam1 ([v] ES v)) E''\n    <- ({v} eql-implies-eq/L0 (E v) (ES v) (E' v))\n    <- lam-preserves-eq E' E''.\n\n- : eql-implies-eq/L0 (eql/lam2 _ _ _) (eqlsize/lam2 _ MAX) E\n    <- nat`max-implies-ge MAX ZERO>=ONE _\n    <- ge-succ-implies-gt ZERO>=ONE ZERO>ZERO\n    <- nat`gt-contradiction ZERO>ZERO F\n    <- false-implies-eq F E.\n\n- : eql-implies-eq/L0 (eql/rec1 ([v] E v)) (eqlsize/rec1 ([v] ES v)) E''\n    <- ({v} eql-implies-eq/L0 (E v) (ES v) (E' v))\n    <- rec-preserves-eq E' E''.\n\n- : eql-implies-eq/L0 (eql/rec2 _ _ _ _) (eqlsize/rec2 _ _ MAX) E\n    <- nat`max-implies-ge MAX ZERO>=ONE _\n    <- ge-succ-implies-gt ZERO>=ONE ZERO>ZERO\n    <- nat`gt-contradiction ZERO>ZERO F\n    <- false-implies-eq F E.\n\n%worlds (blocksimple) (eql-implies-eq/L0 _ _ _).\n%total (E) (eql-implies-eq/L0 E _ _).\n\n%theorem eql-implies-eq/L1 :\n\tforall* {N} {A} {T1} {T2} {S} {MN}\n\tforall\t{E: eql* N A multiset`map/0 T1 T2} {MM}\n\t\t{ES:eqlsize E S MN MM}\n\texists\t{E: eq T1 T2}\n\ttrue.\n\n- : eql-implies-eq/L1 EQL z ES E\n    <- eql-implies-eq/L0 EQL ES E. \n\n%theorem eql-implies-eq/L2 :\n\tforall* {N} {A} {T1} {T2} {S} {MN}\n\tforall\t{E: eql* N A multiset`map/0 T1 T2} {MM}\n\t\t{ES:eqlsize E S (s MN) MM}\n\texists\t{E: eq T1 T2}\n\ttrue.\n\n- : eql-implies-eq/L2 EQL z ES E\n    <- eql-implies-eq/L0 EQL ES E. \n\n- : eql-implies-eq/L2 EQL (s M) ES E\n    <- adjust-varlevel EQL ES multiset`shift/0 E' _ ES'\n    <- eql-implies-eq/L1 E' _ ES' E.\n\n- : eql-implies-eq/L1 EQL (s M) ES E\n    <- remove-zero-index-vars EQL _ ES (multiset`count/z multiset`not-member/0)\n\tEQL' _ _ ES' GE\n    <- meta-ge _ _ GE\n    <- eql-implies-eq/L2 EQL' _ ES' E.\n\n%worlds () (eql-implies-eq/L1 _ _ _ _) (eql-implies-eq/L2 _ _ _ _).\n%total (M1 M2) \n\t(eql-implies-eq/L2 _ M2 _ _)\n\t(eql-implies-eq/L1 _ M1 _ _).\n\n- : eql-implies-eq E E'\n    <- eqlsize-total ES\n    <- eql-implies-eq/L1 E _ ES E'.\n\n%worlds () (eql-implies-eq _ _).\n%total { } (eql-implies-eq _ _).\n\n\n%{ === Main Theorem === }%\n\n%{\nFinally the statement of the main theorem of this section.\nAs with the non-indexed case, it is proved by using eql as a between station.\nAgain, as with the non-indexed code, this theorem (or rather \nits main lemma) uses reasoning-from-false extensively because the\ncases cannot be distinguished by Twelf's case analysis.\nIt also uses the \"divrem\" part of the nat signature extensively\nas well as theorems about plus and times.  The proofs of the cases are\nuninteresting arithmetic fiddling.\n}%\n\n\n%theorem tonat-one2one :\n\tforall*\t{N} {T1:term N} {N1} {T2:term N} {N2}\n\tforall\t{TN1:tonat T1 N1}\n\t\t{TN2:tonat T2 N2}\n\t\t{E:nat`eq N1 N2}\n\texists\t{ET:eq T1 T2}\n\ttrue.\n\n%theorem tonat-one2one/L :\n\tforall*\t{N} {MS} {T1} {M1} {T2} {M2}\n\tforall\t{TN1:tonat* N MS T1 M1}\n\t\t{TN2:tonat* N MS T2 M2}\n\t\t{E:nat`eq M1 M2}\n\texists\t{ET:eql* N z MS T1 T2}\n\ttrue.\n\n- : tonat-one2one/L (tonat/var MC1 VL1 P1) (tonat/var MC2 VL2 P2) nat`eq/\n\t\t    (eql/var plus/z VL1' VL2)\n    <- count-deterministic MC1 MC2 multiset`eq/ nat`eq/ VN1=VN2\n    <- plus-left-cancels P1 P2 nat`eq/ VN1=VN2 L1=L2\n    <- varlevel-respects-eq VL1 L1=L2 VL1'.\n\n- : tonat-one2one/L (tonat/var MC VL M+L=VN) \n                    (tonat/lit MC' _ VN'+X=M) nat`eq/ E\n    <- count-deterministic MC' MC multiset`eq/ nat`eq/ VN'=VN\n    <- plus-respects-eq VN'+X=M VN'=VN nat`eq/ nat`eq/ VN+X=M\n    <- plus-commutative VN+X=M X+VN=M\n    <- plus-commutative M+L=VN L+M=VN\n    <- plus-implies-ge X+VN=M M>=VN\n    <- plus-implies-ge L+M=VN VN>=M\n    <- nat`ge-anti-symmetric M>=VN VN>=M M=VN\n    <- plus-right-cancels L+M=VN plus/z M=VN nat`eq/ L=0\n    <- varlevel-contradiction VL L=0 F\n    <- false-implies-eql F E.\n\n- : tonat-one2one/L (tonat/lit MC' _ VN'+X=M) \n                    (tonat/var MC VL M+L=VN) nat`eq/ E\n    <- count-deterministic MC' MC multiset`eq/ nat`eq/ VN'=VN\n    <- plus-respects-eq VN'+X=M VN'=VN nat`eq/ nat`eq/ VN+X=M\n    <- plus-commutative VN+X=M X+VN=M\n    <- plus-commutative M+L=VN L+M=VN\n    <- plus-implies-ge X+VN=M M>=VN\n    <- plus-implies-ge L+M=VN VN>=M\n    <- nat`ge-anti-symmetric M>=VN VN>=M M=VN\n    <- plus-right-cancels L+M=VN plus/z M=VN nat`eq/ L=0\n    <- varlevel-contradiction VL L=0 F\n    <- false-implies-eql F E.\n\n- : tonat-one2one/L (tonat/var MC VL M+L=VN) \n                    (tonat/app MC' _ _ _ _ VN'+X=M) nat`eq/ E\n    <- count-deterministic MC' MC multiset`eq/ nat`eq/ VN'=VN\n    <- plus-respects-eq VN'+X=M VN'=VN nat`eq/ nat`eq/ VN+X=M\n    <- plus-commutative VN+X=M X+VN=M\n    <- plus-commutative M+L=VN L+M=VN\n    <- plus-implies-ge X+VN=M M>=VN\n    <- plus-implies-ge L+M=VN VN>=M\n    <- nat`ge-anti-symmetric M>=VN VN>=M M=VN\n    <- plus-right-cancels L+M=VN plus/z M=VN nat`eq/ L=0\n    <- varlevel-contradiction VL L=0 F\n    <- false-implies-eql F E.\n\n- : tonat-one2one/L (tonat/app MC' _ _ _ _ VN'+X=M) \n                    (tonat/var MC VL M+L=VN) nat`eq/ E\n    <- count-deterministic MC' MC multiset`eq/ nat`eq/ VN'=VN\n    <- plus-respects-eq VN'+X=M VN'=VN nat`eq/ nat`eq/ VN+X=M\n    <- plus-commutative VN+X=M X+VN=M\n    <- plus-commutative M+L=VN L+M=VN\n    <- plus-implies-ge X+VN=M M>=VN\n    <- plus-implies-ge L+M=VN VN>=M\n    <- nat`ge-anti-symmetric M>=VN VN>=M M=VN\n    <- plus-right-cancels L+M=VN plus/z M=VN nat`eq/ L=0\n    <- varlevel-contradiction VL L=0 F\n    <- false-implies-eql F E.\n\n- : tonat-one2one/L (tonat/var MC VL M+L=VN) \n                    (tonat/lam MC' _ _ _ _ VN'+X=M) nat`eq/ E\n    <- count-deterministic MC' MC multiset`eq/ nat`eq/ VN'=VN\n    <- plus-respects-eq VN'+X=M VN'=VN nat`eq/ nat`eq/ VN+X=M\n    <- plus-commutative VN+X=M X+VN=M\n    <- plus-commutative M+L=VN L+M=VN\n    <- plus-implies-ge X+VN=M M>=VN\n    <- plus-implies-ge L+M=VN VN>=M\n    <- nat`ge-anti-symmetric M>=VN VN>=M M=VN\n    <- plus-right-cancels L+M=VN plus/z M=VN nat`eq/ L=0\n    <- varlevel-contradiction VL L=0 F\n    <- false-implies-eql F E.\n\n- : tonat-one2one/L (tonat/lam MC' _ _ _ _ VN'+X=M) \n                    (tonat/var MC VL M+L=VN) nat`eq/ E\n    <- count-deterministic MC' MC multiset`eq/ nat`eq/ VN'=VN\n    <- plus-respects-eq VN'+X=M VN'=VN nat`eq/ nat`eq/ VN+X=M\n    <- plus-commutative VN+X=M X+VN=M\n    <- plus-commutative M+L=VN L+M=VN\n    <- plus-implies-ge X+VN=M M>=VN\n    <- plus-implies-ge L+M=VN VN>=M\n    <- nat`ge-anti-symmetric M>=VN VN>=M M=VN\n    <- plus-right-cancels L+M=VN plus/z M=VN nat`eq/ L=0\n    <- varlevel-contradiction VL L=0 F\n    <- false-implies-eql F E.\n\n- : tonat-one2one/L (tonat/var MC VL M+L=VN) \n                    (tonat/rec MC' _ _ _ VN'+X=M) nat`eq/ E\n    <- count-deterministic MC' MC multiset`eq/ nat`eq/ VN'=VN\n    <- plus-respects-eq VN'+X=M VN'=VN nat`eq/ nat`eq/ VN+X=M\n    <- plus-commutative VN+X=M X+VN=M\n    <- plus-commutative M+L=VN L+M=VN\n    <- plus-implies-ge X+VN=M M>=VN\n    <- plus-implies-ge L+M=VN VN>=M\n    <- nat`ge-anti-symmetric M>=VN VN>=M M=VN\n    <- plus-right-cancels L+M=VN plus/z M=VN nat`eq/ L=0\n    <- varlevel-contradiction VL L=0 F\n    <- false-implies-eql F E.\n\n- : tonat-one2one/L (tonat/rec MC' _ _ _ VN'+X=M) \n                    (tonat/var MC VL M+L=VN) nat`eq/ E\n    <- count-deterministic MC' MC multiset`eq/ nat`eq/ VN'=VN\n    <- plus-respects-eq VN'+X=M VN'=VN nat`eq/ nat`eq/ VN+X=M\n    <- plus-commutative VN+X=M X+VN=M\n    <- plus-commutative M+L=VN L+M=VN\n    <- plus-implies-ge X+VN=M M>=VN\n    <- plus-implies-ge L+M=VN VN>=M\n    <- nat`ge-anti-symmetric M>=VN VN>=M M=VN\n    <- plus-right-cancels L+M=VN plus/z M=VN nat`eq/ L=0\n    <- varlevel-contradiction VL L=0 F\n    <- false-implies-eql F E.\n\n- : tonat-one2one/L (tonat/lit MC1 T1 P1) (tonat/lit MC2 T2 P2) nat`eq/\n\t\t    (eql/eq T1=T2)\n    <- count-deterministic MC1 MC2 multiset`eq/ nat`eq/ VN1=VN2\n    <- plus-left-cancels P1 P2 VN1=VN2 nat`eq/ TM1=TM2\n    <- times-left-cancels T1 T2 nat`eq/ TM1=TM2 M1=M2\n    <- lit-preserves-eq M1=M2 T1=T2.\n\n%abbrev 2>1 = gt/1.\n\n- : tonat-one2one/L (tonat/lit MC T P) (tonat/app MC' _ _ _ T' P') nat`eq/ E\n    <- count-deterministic MC' MC multiset`eq/ nat`eq/ VN'=VN\n    <- plus-left-cancels P' P VN'=VN nat`eq/ TM'+1=TM\n    <- times-commutative T Tc\n    <- div-can-be-constructed Tc DR\n    <- plus-commutative (plus/s plus/z) TM'+ONE=TM'+1\n    <- plus-respects-eq TM'+ONE=TM'+1 nat`eq/ nat`eq/ TM'+1=TM TM'+ONE=TM\n    <- times-commutative T' Tc'\n    <- divrem-can-be-constructed Tc' TM'+ONE=TM 2>1 DR'\n    <- divrem-deterministic DR DR' nat`eq/ nat`eq/ QE ZERO=ONE\n    <- nat`eq-contradiction ZERO=ONE F\n    <- false-implies-eql F E.\n\n- : tonat-one2one/L (tonat/app MC' _ _ _ T' P') (tonat/lit MC T P) nat`eq/ E\n    <- count-deterministic MC' MC multiset`eq/ nat`eq/ VN'=VN\n    <- plus-left-cancels P' P VN'=VN nat`eq/ TM'+1=TM\n    <- times-commutative T Tc\n    <- div-can-be-constructed Tc DR\n    <- plus-commutative (plus/s plus/z) TM'+ONE=TM'+1\n    <- plus-respects-eq TM'+ONE=TM'+1 nat`eq/ nat`eq/ TM'+1=TM TM'+ONE=TM\n    <- times-commutative T' Tc'\n    <- divrem-can-be-constructed Tc' TM'+ONE=TM 2>1 DR'\n    <- divrem-deterministic DR DR' nat`eq/ nat`eq/ QE ZERO=ONE\n    <- nat`eq-contradiction ZERO=ONE F\n    <- false-implies-eql F E.\n\n- : tonat-one2one/L (tonat/app MC1 TN1a TN1b P2N1 T1 P1)\n\t\t    (tonat/app MC2 TN2a TN2b P2N2 T2 P2) nat`eq/ \n\t\t    (eql/app E1 E2)\n    <- count-deterministic MC1 MC2 multiset`eq/ nat`eq/ VN1=VN2\n    <- plus-left-cancels P1 P2 VN1=VN2 nat`eq/ TM1+1=TM2+1\n    <- succ-cancels TM1+1=TM2+1 TM1=TM2\n    <- times-left-cancels T1 T2 nat`eq/ TM1=TM2 (M1=M2:nat`eq M1 M2)\n    <- nat2pair-deterministic P2N1 P2N2 M1=M2 PR1=PR2\n    <- natpair`pair-eq-implies-eq PR1=PR2 EQa EQb\n    <- tonat-one2one/L TN1a TN2a EQa E1\n    <- tonat-one2one/L TN1b TN2b EQb E2.\n\n%abbrev 2+2=4 : plus (s (s z)) (s (s z)) (s (s (s (s z))))\n\t\t = (plus/s (plus/s plus/z)).\n%abbrev 2x2=4 : times (s (s z)) (s (s z)) (s (s (s (s z))))\n\t\t = (times/s (times/s times/z plus/z) 2+2=4).\n \n- : tonat-one2one/L (tonat/app MC1 TN1a TN1b P2N1 T1 P1)\n                    (tonat/lam MC2 MC0 MA0 _ T2 P2) nat`eq/ E\n    <- count-deterministic MC1 MC2 multiset`eq/ nat`eq/ VN1=VN2\n    <- plus-left-cancels P1 P2 VN1=VN2 nat`eq/ TM1+1=TM2\n    <- times-associative 2x2=4 T2 _ T2' T2''\n    <- times-commutative T2'' T2''c\n    <- div-can-be-constructed T2''c DR2\n    <- plus-commutative (plus/s plus/z) TM1+ONE=TM1+1\n    <- plus-respects-eq TM1+ONE=TM1+1 nat`eq/ nat`eq/ TM1+1=TM2 TM1+ONE=TM2\n    <- times-commutative T1 T1c\n    <- divrem-can-be-constructed T1c TM1+ONE=TM2 2>1 DR1\n    <- divrem-deterministic DR2 DR1 nat`eq/ nat`eq/ QE ZERO=ONE\n    <- nat`eq-contradiction ZERO=ONE F\n    <- false-implies-eql F E.\n\n- : tonat-one2one/L (tonat/lam MC2 MC0 MA0 _ T2 P2)\n                    (tonat/app MC1 TN1a TN1b P2N1 T1 P1) nat`eq/ E\n    <- count-deterministic MC1 MC2 multiset`eq/ nat`eq/ VN1=VN2\n    <- plus-left-cancels P1 P2 VN1=VN2 nat`eq/ TM1+1=TM2\n    <- times-associative 2x2=4 T2 _ T2' T2''\n    <- times-commutative T2'' T2''c\n    <- div-can-be-constructed T2''c DR2\n    <- plus-commutative (plus/s plus/z) TM1+ONE=TM1+1\n    <- plus-respects-eq TM1+ONE=TM1+1 nat`eq/ nat`eq/ TM1+1=TM2 TM1+ONE=TM2\n    <- times-commutative T1 T1c\n    <- divrem-can-be-constructed T1c TM1+ONE=TM2 2>1 DR1\n    <- divrem-deterministic DR2 DR1 nat`eq/ nat`eq/ QE ZERO=ONE\n    <- nat`eq-contradiction ZERO=ONE F\n    <- false-implies-eql F E.\n\n- : tonat-one2one/L (tonat/app MC1 _ _ _ T1 P1)\n                    (tonat/rec MC2 _ _ T2 P2) nat`eq/ E\n    <- count-deterministic MC1 MC2 multiset`eq/ nat`eq/ VN1=VN2\n    <- plus-left-cancels P1 P2 VN1=VN2 nat`eq/ TM1+1=TM2+2\n    <- times-associative 2x2=4 T2 _ _ T2'\n    <- times-commutative T2' T2'c\n    <- plus-commutative (plus/s (plus/s plus/z)) P2'c\n    <- div-can-be-constructed (times/s T2'c P2'c) DR2\n    <- plus-commutative (plus/s plus/z) TM1+ONE=TM1+1\n    <- plus-respects-eq TM1+ONE=TM1+1 nat`eq/ nat`eq/ TM1+1=TM2+2 TM1+ONE=TM2+2\n    <- times-commutative T1 T1c\n    <- divrem-can-be-constructed T1c TM1+ONE=TM2+2 2>1 DR1\n    <- divrem-deterministic DR2 DR1 nat`eq/ nat`eq/ QE ZERO=ONE\n    <- nat`eq-contradiction ZERO=ONE F\n    <- false-implies-eql F E.\n\n- : tonat-one2one/L (tonat/rec MC2 _ _ T2 P2) \n                    (tonat/app MC1 _ _ _ T1 P1) nat`eq/ E\n    <- count-deterministic MC1 MC2 multiset`eq/ nat`eq/ VN1=VN2\n    <- plus-left-cancels P1 P2 VN1=VN2 nat`eq/ TM1+1=TM2+2\n    <- times-associative 2x2=4 T2 _ _ T2'\n    <- times-commutative T2' T2'c\n    <- plus-commutative (plus/s (plus/s plus/z)) P2'c\n    <- div-can-be-constructed (times/s T2'c P2'c) DR2\n    <- plus-commutative (plus/s plus/z) TM1+ONE=TM1+1\n    <- plus-respects-eq TM1+ONE=TM1+1 nat`eq/ nat`eq/ TM1+1=TM2+2 TM1+ONE=TM2+2\n    <- times-commutative T1 T1c\n    <- divrem-can-be-constructed T1c TM1+ONE=TM2+2 2>1 DR1\n    <- divrem-deterministic DR2 DR1 nat`eq/ nat`eq/ QE ZERO=ONE\n    <- nat`eq-contradiction ZERO=ONE F\n    <- false-implies-eql F E.\n\n%theorem tonat-one2one/L/eq :\n\tforall*\t{N} {VN1} {VN2} {N1} {MS1} {MS2} {M} {F}\n\tforall\t{FTN: {v:term N} (varlevel v (s VN1)) \n\t\t       -> tonat* N1 MS1 (F v) M}\n\t\t{EQ: nat`eq VN1 VN2}\n\t\t{ME: multiset`eq MS1 MS2}\n\texists\t{FTN': {v:term N} (varlevel v (s VN2))\n\t\t       -> tonat* N1 MS2 (F v) M}\n\ttrue.\n\n- : tonat-one2one/L/eq FTN nat`eq/ multiset`eq/ FTN.\n\n%worlds (blocksimple | blockvar) (tonat-one2one/L/eq _ _ _ _).\n%total { } (tonat-one2one/L/eq _ _ _ _).\n%reduces F1 = F2 (tonat-one2one/L/eq F1 _ _ F2).\n\n- : tonat-one2one/L (tonat/lam MC1 MC01 MA1 ([v] [vl] (F1 v vl)) T1 P1)\n                    (tonat/lam MC2 MC02 MA2 ([v] [vl] (F2 v vl)) T2 P2)\n                    nat`eq/ (eql/lam2 MC02 MA2 FE)\n    <- count-deterministic MC1 MC2 multiset`eq/ nat`eq/ VN1=VN2\n    <- plus-left-cancels P1 P2 VN1=VN2 nat`eq/ TM1=TM2\n    <- times-left-cancels T1 T2 nat`eq/ TM1=TM2 M1=M2\n    <- count-deterministic MC01 MC02 multiset`eq/ nat`eq/ ZN1=ZN2\n    <- add-deterministic MA1 MA2 multiset`eq/ nat`eq/ MS1=MS2\n    <- tonat-one2one/L/eq F1 ZN1=ZN2 MS1=MS2 F1'\n    <- ({v} {vl:varlevel v (s ZN2)} \n        tonat-one2one/L (F1' v vl) (F2 v vl) M1=M2 (FE v vl)).\n\n%abbrev 4>2 : nat`gt (s (s (s (s z)))) (s (s z)) \n\t       = (gt/> gt/1).\n\n- : tonat-one2one/L (tonat/lam MC1 _ _ _ T1 P1)\n                    (tonat/rec MC2 _ _ T2 P2) nat`eq/ E\n    <- count-deterministic MC2 MC1 multiset`eq/ nat`eq/ VN2=VN1\n    <- plus-left-cancels P2 P1 VN2=VN1 nat`eq/ TM2+2=TM1\n    <- times-commutative T1 T1c\n    <- div-can-be-constructed T1c DR1\n    <- plus-commutative (plus/s (plus/s plus/z)) TM2+TWO=TM2+2\n    <- plus-respects-eq TM2+TWO=TM2+2 nat`eq/ nat`eq/ TM2+2=TM1 TM2+TWO=TM1\n    <- times-commutative T2 T2c\n    <- divrem-can-be-constructed T2c TM2+TWO=TM1 4>2 DR2\n    <- divrem-deterministic DR1 DR2 nat`eq/ nat`eq/ QE ZERO=TWO\n    <- nat`eq-contradiction ZERO=TWO F\n    <- false-implies-eql F E.\n\n- : tonat-one2one/L (tonat/rec MC2 _ _ T2 P2) \n                    (tonat/lam MC1 _ _ _ T1 P1) nat`eq/ E\n    <- count-deterministic MC2 MC1 multiset`eq/ nat`eq/ VN2=VN1\n    <- plus-left-cancels P2 P1 VN2=VN1 nat`eq/ TM2+2=TM1\n    <- times-commutative T1 T1c\n    <- div-can-be-constructed T1c DR1\n    <- plus-commutative (plus/s (plus/s plus/z)) TM2+TWO=TM2+2\n    <- plus-respects-eq TM2+TWO=TM2+2 nat`eq/ nat`eq/ TM2+2=TM1 TM2+TWO=TM1\n    <- times-commutative T2 T2c\n    <- divrem-can-be-constructed T2c TM2+TWO=TM1 4>2 DR2\n    <- divrem-deterministic DR1 DR2 nat`eq/ nat`eq/ QE ZERO=TWO\n    <- nat`eq-contradiction ZERO=TWO F\n    <- false-implies-eql F E.\n\n- : tonat-one2one/L (tonat/rec MC1 MA1 ([v] [vl] (F1 v vl)) T1 P1)\n                    (tonat/rec MC2 MA2 ([v] [vl] (F2 v vl)) T2 P2)\n                    nat`eq/ (eql/rec2 plus/z MC2 MA2 FE)\n    <- count-deterministic MC1 MC2 multiset`eq/ nat`eq/ VN1=VN2\n    <- plus-left-cancels P1 P2 VN1=VN2 nat`eq/ TM1+2=TM2+2\n    <- succ-cancels TM1+2=TM2+2 TM1+1=TM2+1\n    <- succ-cancels TM1+1=TM2+1 TM1=TM2\n    <- times-left-cancels T1 T2 nat`eq/ TM1=TM2 M1=M2\n    <- add-deterministic MA1 MA2 multiset`eq/ nat`eq/ MS1=MS2\n    <- tonat-one2one/L/eq F1 VN1=VN2 MS1=MS2 F1'\n    <- ({v} {vl:varlevel v (s VN2)} \n        tonat-one2one/L (F1' v vl) (F2 v vl) M1=M2 (FE v vl)).\n\n%worlds (blockvar) (tonat-one2one/L _ _ _ _).\n%total (T) (tonat-one2one/L T _ _ _).\n\n- : tonat-one2one TN1 TN2 EQ TEQ\n    <- tonat-one2one/L TN1 TN2 EQ EQL\n    <- eql-implies-eq EQL TEQ.\n\n%worlds () (tonat-one2one _ _ _ _).\n%total { } (tonat-one2one _ _ _ _)."
          },
          "sha1": "4af81qqp7goe5hjnvuqzqsb5aegn6vo"
        }
      },
      {
        "title": "Indexed lists",
        "ns": 0,
        "id": 1701,
        "revision": {
          "id": 2991,
          "parentid": 2733,
          "timestamp": "2006-10-20T16:38:31Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "minor": null,
          "comment": "[[Homogeneous lists]] moved to [[Indexed lists]]: Precursor",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 2654,
            "#text": "<twelf check=true>\n% Lists\n% By Carsten Varming 2006\n\ntp : type.         %name tp Tp.\nlist : tp -> type. %name list Ls.\nstuff : tp.\n%freeze tp.\n\ncons : {Tp} list Tp -> list Tp.\nnil : {Tp} list Tp.\n%freeze list.\n\neq : list Tp -> list Tp -> type.\n%mode eq +Ls -Ls'.\neq_ref : eq Ls Ls.\n%worlds () (eq _ _).\n%freeze eq.\n\neq_symm : eq Ls Ls' -> eq Ls' Ls -> type.\n%mode eq_symm +Q -Q'.\neq_symm_rule : eq_symm eq_ref eq_ref.\n%worlds () (eq_symm _ _).\n%freeze eq_symm.\n%total {} (eq_symm _ _).\n\neq_trans : eq Ls Ls' -> eq Ls' Ls'' -> eq Ls Ls'' -> type.\n%mode eq_trans +Q +Q' -Q''.\neq_trans_rule : eq_trans eq_ref eq_ref eq_ref.\n%worlds () (eq_trans _ _ _).\n%freeze eq_trans.\n%total {} (eq_trans _ _ _).\nrev : list Tp -> list Tp -> list Tp -> type.\n%mode rev +Ls +Ls'' -Ls'.\nrev_nil : rev (nil _) Ls' Ls'.\nrev_cons : rev (cons E Ls) Ls'' Ls'\n               <- rev Ls (cons E Ls'') Ls'.\n%worlds () (rev _ _ _).\n%freeze rev.\n%total D (rev D _ _).\n\nrev_exists : {Ls} {Ls'} rev Ls Ls' Ls'' -> type.\n%mode rev_exists +Ls +Ls' -R.\nrev_exists_nil : rev_exists (nil _) _ rev_nil.\nrev_exists_cons : rev_exists (cons E Ls) Ls' (rev_cons Ls'')\n            <- rev_exists Ls (cons E Ls') Ls''.\n%worlds () (rev_exists _ _ _).\n%freeze rev_exists.\n%total D (rev_exists D _ _).\n\nrevDet : rev Ls Ls' Ls3 -> rev Ls Ls' Ls4 -> eq Ls3 Ls4 -> type.\n%mode revDet +R +R' -Q.\nrevDet_nil : revDet rev_nil _ eq_ref.\nrevDet_cons : revDet (rev_cons R) (rev_cons R') Q\n         <- revDet R R' Q.\n%worlds () (revDet _ _ _).\n%freeze revDet.\n%total D (revDet D _ _).\n\nrevrev_id_lem : rev Ls Ls' Ls'' -> rev Ls'' (nil _) Ls4 -> rev Ls' Ls Ls6 -> eq Ls6 Ls4 -> type.\n%mode revrev_id_lem +R +R' +R'' -Q.\n\nrevrev_id_lem_nil : revrev_id_lem rev_nil F F' Q\n          <- revDet F' F Q. \nrevrev_id_lem_cons : revrev_id_lem (rev_cons R) R' R'' Q\n          <- revrev_id_lem R R' (rev_cons R'') Q.\n\n%worlds () (revrev_id_lem _ _ _ _).\n%freeze revrev_id_lem.\n%total D (revrev_id_lem D _ _ _).\n\nrevrev_id : rev Ls (nil Tp) Ls' -> rev Ls' (nil Tp) Ls'' -> eq Ls Ls'' -> type.\n%mode revrev_id +R +R' -Q.\nrevrev_id_rule : revrev_id R R' Q \n      <- revrev_id_lem R R' rev_nil Q.\n%worlds () (revrev_id _ _ _).\n%freeze revrev_id.\n%total {} (revrev_id _ _ _).\n\nrev_injective : rev Ls (nil Tp) Ls' -> rev Ls'' (nil Tp) Ls' -> eq Ls Ls'' -> type.\n%mode rev_injective +R +R' -Q.\nrev_injective_rule : rev_injective (R : rev Ls (nil Tp) Ls') R' Q\n      <- rev_exists Ls' (nil Tp) Rev\n      <- revrev_id R Rev Q'\n      <- eq_symm Q' Q'''\n      <- revrev_id R' Rev Q''\n      <- eq_trans Q'' Q''' Q1\n      <- eq_symm Q1 Q.\n%worlds () (rev_injective _ _ _).\n%freeze rev_injective.\n%total D (rev_injective D _ _).\n\n</twelf>"
          },
          "sha1": "8ujm80bv3w5dqewx06jvgpl0cuw150m"
        }
      },
      {
        "title": "Input coverage",
        "ns": 0,
        "id": 1967,
        "redirect": {
          "@title": "Coverage checking",
          "#text": null
        },
        "revision": {
          "id": 4504,
          "timestamp": "2007-03-20T23:50:40Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "Redirecting to [[Coverage checking]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 31,
            "#text": "#REDIRECT [[Coverage checking]]"
          },
          "sha1": "sou93o37jm6urub0c6na0aklhlcsf0s"
        }
      },
      {
        "title": "Intrinsic and extrinsic encodings",
        "ns": 0,
        "id": 1931,
        "revision": {
          "id": 4844,
          "parentid": 4830,
          "timestamp": "2007-09-27T04:16:12Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "minor": null,
          "comment": "Reverted edits by [[Special:Contributions/209.99.227.70|209.99.227.70]] ([[User_talk:209.99.227.70|Talk]]); changed back to last version by [[User:Tom7|Tom7]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 4664,
            "#text": "It often comes to pass that you have a judgement and a second judgement which picks out some of the subjects of the first. For instance, terms and values, or terms and well-typed terms, or finite maps and well-formed finite maps (e.g. maps without duplicate keys). Depending on what you're doing, you may then have a choice as to whether to encode the judgements ''intrinsically'' or ''extrinsically''.\n\nIn an extrinsic encoding, the second judgement is represented as a refinement of the first: a type family which is indexed by the type family representing the first judgement. For example, the simply-typed lambda calculus, extrinsically:\n\n<twelf>\ntm : type.\n\nlam : (tm -> tm) -> tm.\napp : tm -> tm -> tm.\n\ntp : type.\n\narr : tp -> tp -> tp.\n\nof : tm -> tp -> type.\n\nof-lam : ({x:tm}{d:of x T} of (B x) T') -> of (lam B) (arr T T').\nof-app : of M' (arr T T') -> of M T -> of (app M' M) T'.\n</twelf>\n\nIn an intrinsic encoding, the second judgement is rolled into the definition of the first; there is no representation of subjects of the first judgement which are not subjects of the second. For example, the simply-typed lambda calculus, intrinsically:\n\n<twelf>\ntp : type.\n\narr : tp -> tp -> tp.\n\ntm : tp -> type.\n\nlam : (tm T -> tm T') -> tm (arr T T').\napp : tm (arr T T') -> tm T -> tm T'.\n</twelf>\n\nStrictly speaking this is not just a different encoding; it adequately encodes only the typing judgement, since there are ill-typed terms which can be written down in the previous signature but not in this one.\n\n\n\nYou may wish to work with both judgements (for instance, terms and values). In that case you have the choice of representing values extrinsically, as a judgement indexed by terms, or intrinsically, as a separate judgement. Extrinsically:\n\n<twelf>\ntm : type.\n\nlam : (tm -> tm) -> tm.\napp : tm -> tm -> tm.\n\nval : tm -> type.\n\nval-lam : val (lam B).\n</twelf>\n\nIntrinsically:\n\n<twelf>\ntm : type.\nval : type.\n\nlam : (val -> tm) -> val.\napp : tm -> tm -> tm.\ninj : val -> tm.\n</twelf>\n\nIn this representation values must be explicitly injected into terms with <tt>inj</tt>. (Note that taking <tt>val</tt> as argument to the body of <tt>lam</tt> makes the language call-by-value.) An advantage of the intrinsic encoding is that you need only pass around a single <tt>val</tt> derivation to operate on values, while in the extrinsic encoding you must pass both a <tt>tm</tt> and a <tt>value</tt>. A disadvantage is that you have to deal with the term/value distinction everywhere you work with terms.\n\nAnother possibility is to have a completely separate secondary judgement and inject its subjects into the primary judgement via a metatheorem rather than a constructor:\n\n<twelf>\ntm : type.\n\nlam : (tm -> tm) -> tm.\napp : tm -> tm -> tm.\n\nval : type.\n\nval-lam : (tm -> tm) -> val.\n</twelf>\n\n\n\nAs a final example, consider finite maps. On paper you typically work with finite maps which are implicitly well-defined (they have at most one binding for a key). To encode them as LF terms in Twelf you have the choice of an extrinsic encoding, in which there is a separate well-formedness judgement, or an intrinsic one, in which only well-formed maps can be written down. Extrinsically:\n\n<twelf>\nkey : type. % pretend that key and value have some inhabitants\nvalue : type.\nmap : type.\n\nempty : map.\nbind : map -> key -> value -> map.\n\nkey-neq : key -> key -> type. % holds if keys are not equal\n\nkey-not-in-map : key -> map -> type.\n- : key-not-in-map K empty.\n- : key-not-in-map K (bind M K' V)\n      <- key-neq K K'\n      <- key-not-in-map K M.\n\nwf-map : map -> type.\n\n- : wf-map empty.\n- : wf-map (bind M K V)\n      <- key-not-in-map K M\n      <- wf-map M.\n</twelf>\n\nIntrinsically:\n\n<twelf>\nkey : type. % pretend that key and value have some inhabitants\nvalue : type.\nmap : type.\n\nkey-neq : key -> key -> type. % holds if keys are not equal\n\nempty : map.\nkey-not-in-map : key -> map -> type.\nbind : {M : map} {K : key} value -> key-not-in-map K M -> map.\n\n- : key-not-in-map K empty.\n- : key-not-in-map K (bind M K' V _)\n      <- key-neq K K'\n      <- key-not-in-map K M.\n\n</twelf>\n\nHere the extrinsic encoding has the advantage that you need not prove that well-formedness is maintained as you go (or even maintain it), which may save a lot of work. The intrinsic encoding has the advantage that since only well-formed maps can be written down, you never need to prove that a type-family maintains well-formedness as an invariant, which may save a lot of work.\n\nFor an example of an intrinsic encoding, see [[CPS conversion]], where the distinction between values and expressions is encoded intrinsically, and where all terms are manifestly well-typed."
          },
          "sha1": "bcnzq931hta4kvmp6vgvq96pyg8d1ht"
        }
      },
      {
        "title": "Intrinsic encoding",
        "ns": 0,
        "id": 1957,
        "redirect": {
          "@title": "Intrinsic and extrinsic encodings",
          "#text": null
        },
        "revision": {
          "id": 4475,
          "timestamp": "2007-03-20T21:36:58Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "Redirecting to [[Intrinsic and extrinsic encodings]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 47,
            "#text": "#REDIRECT [[Intrinsic and extrinsic encodings]]"
          },
          "sha1": "2t6p3b99vdruksv3j3zepw2olaogiy5"
        }
      },
      {
        "title": "Introductions to Twelf",
        "ns": 0,
        "id": 1758,
        "revision": {
          "id": 8179,
          "parentid": 7912,
          "timestamp": "2016-12-13T00:20:22Z",
          "contributor": {
            "username": "Boyland",
            "id": 17
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 1066,
            "#text": "The following introductory guides are available:\n\n* [[Proving metatheorems with Twelf]]: if you have some background in programming languages but no prior experience with LF and Twelf, start with this introduction.\n\n* [[POPL Tutorial]] 2009: course materials from a Twelf tutorial at POPL 2009.  This path through the material is the best introduction to Twelf, but it may be harder to follow along with online than [[Proving metatheorems with Twelf|Proving metatheorems]].\n\n* [[Summer school 2008]]: notes from a Twelf course at [http://www.cs.uoregon.edu/research/summerschool/summer08/ the University of Oregon Summer School on Logic and Theorem Proving in Programming Languages, July 2008]\n\nBasic mechanics:\n\n* [[Twelf with Emacs]]: Using Twelf from within Emacs\n\n* [[Twelf without Emacs]]: Running the twelf-server directly from the command line.\n\nWe plan to add other introductory articles for other audiences.  If you have suggestions, please\n[http://twelf.plparty.org/w/index.php?title=Talk:Introductions_to_Twelf&action=edit&section=new leave us a message]."
          },
          "sha1": "r42hmxl4ddddvujk6yayzu8kru1w3ed"
        }
      },
      {
        "title": "Iterated Let Bindings",
        "ns": 0,
        "id": 2215,
        "revision": {
          "id": 6076,
          "parentid": 6014,
          "timestamp": "2010-05-24T21:24:11Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "minor": null,
          "comment": "moved [[Let*]] to [[Iterated Let Bindings]]:&#32;The Let* gets into the regression tests and messes with filenames",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 2333,
            "#text": "%{\n\nLet with iterated bindings.\n\n== Preliminaries ==\n}%\n\nnat : type.\nz : nat.\ns : nat -> nat.\n\nadd : nat -> nat -> nat -> type.\n%mode add +N1 +N2 -N3.\n\nadd/z : add z N N.\nadd/s : add (s N) M (s P)\n         <- add N M P.\n%worlds () (add _ _ _).\n%total M (add M _ _).\n\n%{\n== Syntax ==\n}%\n\nexp   : type.\n\n%% oexp N is morally exp^N -> exp, but curried\noexp  : nat -> type.\n\n%% binds N M is a list of length M - N with types\n%% (oexp N , oexp (s N) , ... , oexp (M - 1))\nbinds : nat -> nat -> type.\n\n\noexp/done : exp -> oexp z.\noexp/bind : (exp -> oexp N) -> oexp (s N).\n\nbinds/done : binds N N.\nbinds/cons : oexp F -> binds (s F) L -> binds F L.\n\nlet* : binds z N   % N terms, with (0, 1, ... N) free vars\n        -> oexp N  % body has N free vars\n        -> exp.\nnum  : nat -> exp.\nplus : exp -> exp -> exp.\n\n%{\n== Evaluation ==\n}%\n\n%% substitute the expression for the first var in each of the binds\nmap-subst : exp -> binds (s N) (s M) -> binds N M -> type.\n%mode map-subst +E +B -B'.\n\n- : map-subst E binds/done binds/done.\n- : map-subst E (binds/cons (oexp/bind OE) B) (binds/cons (OE E) B')\n     <- map-subst E B B'.\n\n%worlds () (map-subst _ _ _).\n%total D (map-subst _ D _).\n\n%% contradict the existence of binds (s N) z;\n%% return a nat\nbinds-imposs : binds (s N) z -> nat -> type.\n%mode binds-imposs +B -E.\n- : binds-imposs (binds/cons _ B) X\n     <- binds-imposs B X.\n%worlds () (binds-imposs _ _).\n%total D (binds-imposs D _).\n\neval : exp -> nat -> type.\n%mode eval +E1 -E2.\n\n- : eval (let* binds/done (oexp/done E)) N\n     <- eval E N.\n- : eval (let* (binds/cons (oexp/done E) Bs)\n               (oexp/bind E')) N\n     <- map-subst E Bs Bs'\n     <- eval (let* Bs' (E' E)) N.\n- : eval (plus E1 E2) N\n     <- eval E1 N1\n     <- eval E2 N2\n     <- add N1 N2 N.\n- : eval (num N) N.\n%% silly contradictory case so it coverage checks\n- : eval (let* (binds/cons _ B)\n               (oexp/done E)) X\n     <- binds-imposs B X.\n\n%worlds () (eval _ _).\n%covers eval +E1 -E2.\n\n%{\n== Example ==\n}%\n\n%% let* x = 3\n%%      y = x + 2\n%%   in x + y\n%% N should be 8\n%solve D : eval (let* (binds/cons (oexp/done (num (s (s (s z)))))\n                      (binds/cons (oexp/bind [x] oexp/done (plus x (num (s (s z)))))\n                       binds/done))\n                      (oexp/bind [x] oexp/bind [y] oexp/done (plus x y)))\n            N."
          },
          "sha1": "p4nx0mjuoi39y4efkjld270egsm8l0u"
        }
      },
      {
        "title": "Iterated inductive definitions and defunctionalization",
        "ns": 0,
        "id": 2214,
        "revision": {
          "id": 6013,
          "timestamp": "2009-08-04T15:03:58Z",
          "contributor": {
            "username": "Noam",
            "id": 66
          },
          "comment": "uploading code, to be filled in with actual article",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 1677,
            "#text": "(The code in this article relies on autoFreeze being set false.)\n<twelf>\n%%%%%%%%%%%%\n% RUN-TIME %\n%%%%%%%%%%%%\n\ni : type.\nz : i.\ns : i -> i.  %prefix 10 s.\n\nadd : i -> i -> i -> type.\nadd/z : add z N N.\nadd/s : add (s M) N (s P) <- add M N P.\n%mode add +M +N -P.\n\n%worlds () (add M _ _).\n%total (M) (add M _ _).\n%unique add +M +N -P.\n\nmult : i -> i -> i -> type.\nmult/z : mult z N z.\nmult/s : mult (s M) N P' <- mult M N P <- add P N P'.\n%mode mult +M +N -P.\n\n%worlds () (mult M _ _).\n%total (M) (mult M _ _).\n%unique mult +M +N -P.\n\n%%%%%%%%%%%%\n%  SYNTAX  %\n%%%%%%%%%%%%\n\ntm : type.\nbinop : type.\n\nn : i -> tm.\nlet : tm -> (tm -> tm) -> tm.\n@ : binop -> tm -> tm -> tm.\n\napply : binop -> i -> i -> i -> type.\n%mode apply +F +M1 +M2 -N.\n\n%worlds () (apply F M1 M2 _).\n%total {F M1 M2} (apply F M1 M2 _).\n%unique apply +F +M1 +M2 -N.\n\n%%%%%%%%%%%%%\n% SEMANTICS %\n%%%%%%%%%%%%%\n\neval : tm -> i -> type.\n%mode eval +E -N.\n\neval/n : eval (n N) N.\neval/let : eval (let E E*) N\n        <- eval (E* E) N.\neval/@ : eval (@ F E1 E2) N\n      <- eval E1 M1\n      <- eval E2 M2\n      <- apply F M1 M2 N.\n\n%worlds () (eval E _).\n%covers eval +E -N.\n%unique eval +E -N.\n\n%%%%%%%%%%%%\n% EXAMPLES %\n%%%%%%%%%%%%\n\nplus : binop.\nplus/_ : apply plus M N P <- add M N P.\n\ntimes : binop.\ntimes/_ : apply times M N P <- mult M N P.\n\n%total (M1) (apply F M1 M2 _).\n%unique apply +F +M1 +M2 -N.\n\n%worlds () (eval E _).\n%covers eval +E -N.\n%unique eval +E -N.\n\n%query 1 * eval (let (n (s s z)) [two]\n\t\t let (n (s s s z)) [three]\n\t\t @ plus two (@ times two three)) N.\n\n</twelf>\n\n<twelflink>All code from this tutorial</twelflink>. <twelflink check=\"true\">Twelf's output from this tutorial</twelflink>."
          },
          "sha1": "60s7ozbh90bcjdqgq5s6v532qbgorgh"
        }
      },
      {
        "title": "Judgement",
        "ns": 0,
        "id": 1773,
        "redirect": {
          "@title": "Judgment",
          "#text": null
        },
        "revision": {
          "id": 3159,
          "timestamp": "2006-10-24T22:10:13Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "comment": "Redirecting to [[Judgment]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 22,
            "#text": "#REDIRECT [[judgment]]"
          },
          "sha1": "3b1xb57le8jnv4nnbymgvxcoy9k66ho"
        }
      },
      {
        "title": "Judgment",
        "ns": 0,
        "id": 1484,
        "revision": {
          "id": 5171,
          "parentid": 4805,
          "timestamp": "2008-06-27T13:00:56Z",
          "contributor": {
            "username": "Saintali",
            "id": 32
          },
          "comment": "/* Judgments as types */",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 2968,
            "#text": "In the context of this wiki, we use the word '''judgment''' (or '''judgement''') to refer to a relation that is defined inductively by a collection of inference rules.  The '''judgments as types principle''' is a name for the methodology by which judgments are represented in LF.\n\n== A judgment in standard notation ==\n\nFor example, we can define a judgment that a [[natural number]] is even. The judgement <math>\\mathsf{even}(n)</math> holds when <math>\\texttt{}n</math> is even.  It is inductively defined by the following inference rules:\n\n<table style=\"margin-left:auto;margin-right:auto\" cellpadding=\"24\">\n<tr><td>\n<math>{\\qquad} \\over {\\mathsf{even}(\\mathsf{zero})}\n</math>\n</td><td>\n<math>\n{\\mathsf{even}(n)} \\over {\\mathsf{even}(\\mathsf{succ}(\\mathsf{succ}(n)))}\n</math>\n</td></tr>\n</table>\n\n== Judgments as types ==\n\nA judgment is represented in LF using the '''judgments as types''' methodology: we represent a judgment with an LF type, where the inhabitants of this type correspond exactly to derivations of the judgement.\n\nFor example, we represent the judgment <math>\\mathsf{even}(n)</math> using the following signature:\n<twelf hidden=\"true\">\nnat : type.\nz   : nat.\ns   : nat -> nat.\n</twelf>\n<twelf>\neven    : nat -> type.\neven-z  : even z.\neven-s  : {N:nat} even N -> even (s (s N)).\n</twelf>\n\nThe first declaration says that <tt>even</tt> is a family of types indexed by a <tt>nat</tt>.  This means that for every term <tt>N : nat</tt>, there is a type <tt>even N</tt>.  Note that the syntax <tt>-></tt> is overloaded: it is used to classify both type-level families and term-level functions.  We then use this type family to define the types of two term constants.\n\nThe first term constant, <tt>even-z</tt>, has type <tt>even z</tt>.  This constant represents the derivation that consists of the first inference rule above, which concludes <math>\\mathsf{even}(\\mathsf{zero})</math>.  \n\nThe second term constant <tt>even-s</tt>, corresponds to the second inference rule above, which, for any <math>\\texttt{}n</math>, constructs a derivation of <math>\\mathsf{even}(\\mathsf{succ}(\\mathsf{succ}(n)))</math> from a derivation of <math>\\mathsf{even}(n)</math>.  To encode this inference rule, the constant <tt>even-s</tt> is given a [[dependent type|dependent function type]].  \n\nFor example, the LF term\n<!-- syntax highlighting looks weird when it's not actually Twelf code -->\n<pre>even-s z even-z\n</pre>\n\nrepresents the derivation\n\n<center>\n<math>\n{\\overline{\\mathsf{even}(\\mathsf{zero})}}\n\\over \n{\\mathsf{even}(\\mathsf{succ}(\\mathsf{succ}(\\mathsf{zero})))}\n</math>\n</center>\n\nThe term <tt>even-s (s (s z)) (even-s z even-z)</tt> represents a derivation that 4 is even, and so on.\n\n== See also ==\n\n* [[Hypothetical judgement]]s can be represented in LF in a [[higher-order judgement|higher-order]] manner, using LF binding to represent hypotheses.  \n* The [[introductions to Twelf]] discuss how judgments are represented in LF in more detail.\n\n{{stub}}"
          },
          "sha1": "he8j999gyhhb1lx9d0y4kdpb3kdb75a"
        }
      },
      {
        "title": "Judgments",
        "ns": 0,
        "id": 1487,
        "redirect": {
          "@title": "Judgment",
          "#text": null
        },
        "revision": {
          "id": 1873,
          "timestamp": "2006-09-24T08:41:23Z",
          "contributor": {
            "username": "DanielKLee",
            "id": 5
          },
          "comment": "[[Judgments]] moved to [[Judgment]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 22,
            "#text": "#REDIRECT [[Judgment]]"
          },
          "sha1": "nrrlr90fun3st2u08lgoorbja8jjbxq"
        }
      },
      {
        "title": "Judgments as types",
        "ns": 0,
        "id": 1485,
        "redirect": {
          "@title": "Judgment",
          "#text": null
        },
        "revision": {
          "id": 4430,
          "parentid": 1995,
          "timestamp": "2007-03-20T16:31:41Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "comment": "redirecting to judgments page, which has a section on this already, rather than copying",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 22,
            "#text": "#REDIRECT [[judgment]]"
          },
          "sha1": "3b1xb57le8jnv4nnbymgvxcoy9k66ho"
        }
      },
      {
        "title": "LF",
        "ns": 0,
        "id": 1938,
        "revision": {
          "id": 5058,
          "parentid": 5054,
          "timestamp": "2008-02-15T03:07:00Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "minor": null,
          "comment": "Reverted edits by [[Special:Contributions/Popik|Popik]] ([[User_talk:Popik|Talk]]); changed back to last version by [[User:Drl|Drl]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 1537,
            "#text": "'''LF''' is the abbreviation commonly used for the '''Edinburgh Logical Framework''' presented by Harper, Honsell, and Plotkin in ''A Framework for Defining Logics''<ref>{{bibtex:hhp93lf}}</ref>. Harper, Honsell, and Plotkin introduce both LF, which is a [[dependent types|dependently typed]] lambda-calculus, and a systematic methodology for representing [[deductive system]]s, such as programming languages and logics, in this lambda-calculus.  This methodology is often called the [[judgments as types]] principle, because a judgment in a deductive system is represented as an LF type family classifiying (the representations of) derivations of the judgement.  Derivations in a deductive system can be checked by type checking their LF representations.  An LF representation is [[adequate]] iff it is isomorphic to the original description of the deductive system.\n\nTwelf includes:\n* an implementation of the LF logical framework, which can be used to type check LF representations\n* a [[logic programming]] language based on LF\n* a [[metatheorem]] checker, which can be used to verify proofs of theorems about LF representations\n\n\n== See also ==\n\n* Read the  [[Introductions to Twelf]] to learn more about LF and Twelf.\n* [[Canonical form]]s: describes the modern way of thinking about the LF type theory.\n* [[Higher-order abstract syntax]]\n* [[Judgments as types]]\n* [[Higher-order judgements]]\n* [[Bibliography of LF]]\n* [[w:LF (logical framework)|LF (logical framework)]] on Wikipedia\n\n\n== References ==\n\n<references />\n\n\n{{stub}}"
          },
          "sha1": "j0htutyz1slavz40s20dltll385a137"
        }
      },
      {
        "title": "Language with references",
        "ns": 0,
        "id": 1920,
        "redirect": {
          "@title": "Mutable state",
          "#text": null
        },
        "revision": {
          "id": 4308,
          "timestamp": "2007-03-19T15:21:57Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "[[Language with references]] moved to [[Mutable state]]: More descriptive name",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 27,
            "#text": "#REDIRECT [[Mutable state]]"
          },
          "sha1": "bywpb9y3ki1ew3kpwy6fvs3568tzomz"
        }
      },
      {
        "title": "Lax logic",
        "ns": 0,
        "id": 2181,
        "revision": {
          "id": 7909,
          "parentid": 7908,
          "timestamp": "2013-05-30T23:11:34Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "minor": null,
          "comment": "Protected \"[[Lax logic]]\" ([edit=sysop] (indefinite) [move=sysop] (indefinite))",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 58986,
            "#text": "%{ In this article, we will take a presentation of a logic very close to \nthat of Fairtlough and Mendler's lax logic<ref >{{bibtex:fm97lax}}</ref> and\nshow a translation into a polarized version of Pfenning and Davies' judgmental\nreconstruction of lax logic.<ref>{{bibtex:pd01modal}}</ref> We will refer to\nthe non-judgmental, non-polarized system as the ''source logic'' and to the\njudgmentally reconstructed, polarized system as the ''target logic.''\nWhile we tend to see ''judgmentally reconstructed'' logics as Good \nThings<sup>TM</sup>, there's nothing inherently interesting about\n''polarization'' of the the target\nlogic on its own -- the target logic is polarized because it will make the\nproof of completeness for [[focused lax logic]] clearer.\n\nTherefore, we have three separate things that are happening simultaneously. \n* First, we are formally establishing the connection between Fairtlough and Mendler's system and Pfenning and Davies' system. \n* Second, because the source logic has a cut rule and the target logic does not, we prove the [[admissibility of cut]] in the target logic and use it to eliminate instances of the cut rule during translation. Alternatively, we could have (presumably) proven cut elimination within Fairtlough and Mendler's system, or we could have left a cut rule in the target logic and then proven cut elimination there.\n* Third, we are showing the connection between a non-polarized system and a polarized one. \nAll three of these things could be done separately, but we did not find that\nit added to the overall complexity to do them all together.\n\nThe third point above, translation into a non-polarized system, \nis where most of the \ntechnical difficulty of the completeness proof happens, because a general\ntranslation from a non-polarized logic to a polarized one may add an \narbitrary number of shift operations. \n\n<references/> \n\n<br/>}%\n\n%{ == Preliminaries == }%\n\n%{ We will be [[using a metric]] to make certain arguments about translation\nsimpler - we can think of this metric as a tree <tt>T</tt> that is either\na leaf (<tt>o</tt>), a parent with one child tree (<tt>x T</tt>), or a parent\nwith two child trees (<tt>T1 | T2</tt>). \n}%\n\nmetric : type.                          %name metric T.\no : metric.\nx : metric -> metric.\n| : metric -> metric -> metric.         %infix right 10 |.\n\nid : metric -> metric -> type.          %name id ID.\nid/refl : id M M.\n\n%{ We will also be, throughout, working in a universe of atomic propositions.\nEach atomic proposition has a defined polarity (<tt>pos</tt> or <tt>neg</tt>), \nthough this is mostly irrelevant in the target logic and totally irrelevant in \nthe source logic. Every theorem we prove will assume a universe of arbitrary\natomic propositions of both polarities, so every <tt>[[%worlds]]</tt> \ndeclaration will include at least the blocks <tt>bl_atmpos</tt> (positive\natomic propositions) and <tt>bl_atmneg</tt> (negative atomic propositions). }%\n\npolarity : type.\t\t\t%name polarity S.\npos : polarity.\nneg : polarity.\natm : polarity -> type.                 %name atm Q q.\n%block bl_atmpos : block {qp:atm pos}.\n%block bl_atmneg : block {qn:atm neg}.\n\n%{ == Fairtlough and Mendler's lax logic == }%\n\n%{ Fairtlough and Mendler's presentation of lax logic has a slight \ninconsistancy: the logic's syntax is defined as \n\n<math>M ::= Q \\mid \\mathsf{true} \\mid \\mathsf{false} \\mid M \\wedge M \\mid M \\vee M \\mid M \\supset M \\mid \\neg M \\mid {\\bigcirc}M</math>\n\nHowever, rules are given for neither <math>\\mathsf{true}</math> nor \n<math>\\mathsf{false}</math>. A reasonable approach seemed to be to define\n<math>\\mathsf{false}</math> as <math>\\neg \\mathsf{true}</math>. }%\n\nprop' : type.                           %name prop' M.\n\natom'  : atm S -> prop'. \ntt'    : prop'.\n/\\     : prop' -> prop' -> prop'.       %infix right 9 /\\.\n\\/     : prop' -> prop' -> prop'.       %infix right 8 \\/.\n=>     : prop' -> prop' -> prop'.       %infix right 7 =>.\nnot'   : prop' -> prop'.\ncirc'  : prop' -> prop'.\nff'    : prop' = not' tt'.\n\n%{ === Sequent calculus === }%\n\n%{ Fairtlough and Mendler present a Genzen-style intuitionstic sequent\ncalculus for propositional lax logic in terms of sequents\n<math>\\Gamma \\vdash \\Delta</math>, where <math>\\Gamma</math> is a finite\nlist of ''hypotheses'' and <math>\\Delta</math> is either 0 or 1 \n''assertions''. To prove <math>\\Gamma \\vdash</math> is to say that the\nhypotheses in <math>\\Gamma</math> are contradictory, to prove\n<math>\\Gamma \\vdash M</math> is to say that the hypotheses in \n<math>\\Gamma</math> establish the proposition <math>M</math>. \n\nWe represent the hypotheses using the LF context; each \n<math>M \\in \\Gamma</math> becomes an LF variable of type <tt>hyp' M</tt>, and\nwe use the world <tt>bl_hyp'</tt> to describe all such contexts. }%\n\nhyp' : prop' -> type.\n%block bl_hyp' : some {M: prop'} block {h: hyp' M}.\n\n%{ We represent the conclusion as <tt>conc' T D</tt>, where \n* <tt>T</tt> is a metric capturing the shape of the derivation\n* <tt>D</tt> = <tt>conc-#'</tt> represents proving a contradiction <math>\\Gamma \\vdash </math>; we abbreviate <tt>conc' T conc-#'</tt> as <tt># T</tt>.\n* <tt>D</tt> = <tt>conc-true' M</tt> represents proving <math>\\Gamma \\vdash M</math>; we abbreviate <tt>conc' T (conc-true' M)</tt> as <tt>true' T M</tt>. }%\n\nconseq' : type.                         %name conseq' D.\nconc-# : conseq'.                       % Contradiction, length 0\nconc-true' : prop' -> conseq'.          % Conclusion, length 1\nconc' : metric -> conseq' -> type.\n\n%abbrev # = [m] conc' m conc-#.\n%abbrev true' = [m][x] conc' m (conc-true' x). \n\n%{ While our use of a [[structural metric]] embedded into the conclusion of\na sequent needs to be justified by [[adequacy]], it is less of an issue than\nother changes we have made to the system. \n\nAs previously mentioned, \nFairtlough and Mendler's system had no rule for <math>\\mathsf{true}</math>,\nand we need no rule for <math>\\mathsf{false}</math> as we defined it in terms\nof <math>\\mathsf{true}</math>. We do not write rules for\nweakening on the left or exchange on the left, as those are provided \"for free\"\nby the encoding into LF. In addition, we embed contraction into every\nleft rule:\n\n<center>F&amp;M left conjunction rule: <math>\\frac{\\Gamma, A, B \\vdash \\Delta}{\\Gamma, A \\wedge B \\vdash \\Delta}</math>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \nOur left conjunction rule: <math>\\frac{\\Gamma, A \\wedge B, A, B \\vdash \\Delta}{\\Gamma, A \\wedge B \\vdash \\Delta}</math></center>\n\nWith those caveats, we will continue to consider our source logic, presented\nhere, to have the essential character of Fairtlough and Mendler's. \n\n==== Rules on paper ====\n\n<center><math>\\frac\n{~~~}\n{\\Gamma \\vdash \\mathsf{true}}\n{\\mathsf{true}}R</math>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<math>\\frac\n{\\Gamma \\vdash M \\qquad \\Gamma \\vdash N}\n{\\Gamma \\vdash M \\wedge N}\n{\\wedge}R</math>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<math>\\frac\n{\\Gamma, M \\wedge N, M, N \\vdash \\Delta}\n{\\Gamma, M \\wedge N \\vdash \\Delta}\n{\\wedge}L</math></center>\n\n<br/>\n\n<center><math>\\frac\n{\\Gamma \\vdash M}\n{\\Gamma \\vdash M \\vee N}\n{\\vee}R_1</math>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<math>\\frac\n{\\Gamma \\vdash N}\n{\\Gamma \\vdash M \\vee N}\n{\\vee}R_2</math>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<math>\\frac\n{\\Gamma, M \\vee N, M \\vdash \\Delta \\qquad \\Gamma, M \\vee N, N \\vdash \\Delta}\n{\\Gamma \\vdash \\Delta}\n{\\vee}L</math></center>\n\n<br/>\n\n<center><math>\\frac\n{\\Gamma, M \\vdash N}\n{\\Gamma \\vdash M \\supset N}\n{\\supset}R</math>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<math>\\frac\n{\\Gamma, M \\supset N \\vdash M \\qquad \\Gamma, M \\supset N, N \\vdash \\Delta}\n{\\Gamma, M \\supset N \\vdash \\Delta}\n{\\supset}L</math>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<math>\\frac\n{\\Gamma, M \\vdash}\n{\\Gamma \\vdash \\neg M}\n{\\neg}R</math>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<math>\\frac\n{\\Gamma, \\neg M \\vdash M}\n{\\Gamma, \\neg M \\vdash}\n{\\neg}L</math></center>\n\n<br/>\n\n<center><math>\\frac\n{\\Gamma \\vdash M}\n{\\Gamma \\vdash {\\bigcirc} M}\n{\\bigcirc}R</math>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<math>\\frac\n{\\Gamma, {\\bigcirc} M, M \\vdash {\\bigcirc} N}\n{\\Gamma, {\\bigcirc} M \\vdash {\\bigcirc} N}\n{\\bigcirc}L</math></center>\n\n<br/>\n\n<center><math>\\frac\n{~~~}\n{\\Gamma, M \\vdash M}\n{id}</math>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<math>\\frac\n{\\Gamma \\vdash M \\qquad \\Gamma, M \\vdash \\Delta}\n{\\Gamma \\vdash \\Delta}\n{cut}</math>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<math>\\frac\n{\\Gamma \\vdash}\n{\\Gamma \\vdash M}\n{weakR}</math></center>}%\n\n%{ ==== Rules in Twelf ==== }%\n\ntrueR' : true' o tt'.\n% no trueL'\n\n/\\R' : true' Tm M\n       -> true' Tn N\n       -> true' (Tm | Tn) (M /\\ N).\n/\\L'  : (hyp' M -> hyp' N -> conc' T D)\n         -> (hyp' (M /\\ N) -> conc' (x (x T)) D).\n\n\\/R1' : true' T M\n        -> true' (x T) (M \\/ N).\n\\/R2' : true' T N\n        -> true' (x T) (M \\/ N).\n\\/L' : (hyp' M -> conc' Tm D)\n       -> (hyp' N -> conc' Tn D)\n       -> (hyp' (M \\/ N) -> conc' (x (Tm | Tn)) D).\n\n=>R' : (hyp' M -> true' T N)\n       -> true' (x T) (M => N).\n=>L' : true' Tm M\n       -> (hyp' N -> conc' Tn D)\n       -> (hyp' (M => N) -> conc' (x (Tm | Tn)) D).\n\nnotR' : (hyp' M -> # T)\n        -> (true' (x T) (not' M)).\nnotL' : true' T M\n        -> (hyp' (not' M) -> # (x (x T))).\n\ncircR' : true' T M \n         -> true' (x T) (circ' M).\ncircL' : (hyp' M -> true' T (circ' N))\n         -> (hyp' (circ' M) -> true' (x (x T)) (circ' N)).\n\nid' : hyp' M -> true' o M.\n\ncut' : true' Ta M \n        -> (hyp' M -> conc' T D)\n        -> conc' (Ta | T) D.\n\nweakR' : # T -> true' (x T) M.\n\n%worlds (bl_atmpos | bl_atmneg | bl_hyp') \n (hyp' M) \n (conc' T M). % = (# T) (true' T A)\n\n\n%{ == Polarized judgmental lax logic == }% \n\n%{ Polarized lax logic loses the <math>\\neg</math> but distinguishes\nbetween two different kinds of conjunction, <math>\\wedge^+</math> and \n<math>\\wedge^-</math>, and two variants of <math>\\mathsf{true}</math>\nwhich are the units of the two kinds of conjunction.\n\n''Every'' proposition has a polarity, not just atomic propositions, and\nthis limits what we can write down. For instance, we cannot\nwrite <math>\\top \\vee 0</math>, because <math>\\vee</math> expectes two\npositive things and <math>\\top</math> is negative. We could either write\n<math>1 \\vee 0</math>, or else we could write \n<math>({\\downarrow}\\top) \\vee 0</math>.\n\nThe full language of propositions is:\n\n<math>A ::= P \\mid N</math>\n\n<math>P ::= Q^+ \\mid {\\downarrow}N \\mid 1 \\mid 0 \\mid P \\wedge^+ P \\mid P \\vee P</math>\n\n<math>N ::= Q^- \\mid {\\uparrow}P \\mid \\top \\mid N \\wedge^- N \\mid P \\supset N \\mid {\\bigcirc}P</math>\n\nThe Twelf versions of the the connectives resemble ones from linear logic, \nbut we mean unrestricted implication <math>P \\supset N</math>\nwhen we write <tt>P -o N</tt>, not linear implication. }%\n\nprop : polarity -> type.                %name prop A.\n\natom : atm S -> prop S.\nup : prop pos -> prop neg.\ndown : prop neg -> prop pos.\ntop : prop neg.\n1 : prop pos.\n0 : prop pos.\n* : prop pos -> prop pos -> prop pos.   %infix right 9 *.\n& : prop neg -> prop neg -> prop neg.   %infix right 8 &.\n+ : prop pos -> prop pos -> prop pos.   %infix right 7 +.\n-o : prop pos -> prop neg -> prop neg.  %infix right 6 -o.\ncirc : prop pos -> prop neg.\n\n%{ === Sequent calculus === }%\n\n%{ Our assumptions are, as before, represented by LF variables, this time\nof type <tt>hyp A</tt>. }%\n\nhyp : prop S -> type.\n%block bl_hyp : some {S: polarity} {A: prop S} block {h: hyp A}.\n\n%{ We are always trying to prove one of two ''judgments,'' and so our \nsequents either take the form <math>\\Gamma \\vdash A~true</math> (<math>A</math>\nis true) or <math>\\Gamma \\vdash A~lax</math> (<math>A</math> is true\nunder a constraint). }%\n\nconseq : type.                          %name conseq J.\nconc-lax : prop S -> conseq.            % A lax\nconc-true : prop S -> conseq.           % A true\nconc : conseq -> type.\n\n%abbrev lax = [x] conc (conc-lax x).\n%abbrev true = [x] conc (conc-true x).\n\n%{ Later on in the proof of soundness we will use identity of ''derivations''\nin order to make a termination argument work; with this one trick, we avoid\nany need for a [[structural metric]] like we used before. }%\n\nidconc : conc C -> conc C' -> type.\nidconc/refl : idconc D D.\n\n%{ ==== Rules on paper ==== \n\n<center><math>\\frac\n{~~~}\n{\\Gamma, Q^+ \\vdash Q^+~true}\n{init}^+</math>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<math>\\frac\n{~~~}\n{\\Gamma, Q^- \\vdash Q^-~true}\n{init}^-</math>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<math>\\frac\n{\\Gamma \\vdash A~true}\n{\\Gamma \\vdash A~lax}\n{lax}R</math></center>\n\n<br/>\n\n<center><math>\\frac\n{\\Gamma \\vdash P~true}\n{\\Gamma \\vdash {\\uparrow}P~true}\n{\\uparrow}R</math>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<math>\\frac\n{\\Gamma, {\\uparrow}P, P \\vdash J}\n{\\Gamma, {\\uparrow}P \\vdash J}\n{\\uparrow}L</math>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<math>\\frac\n{\\Gamma \\vdash N~true}\n{\\Gamma \\vdash {\\downarrow}N~true}\n{\\downarrow}R</math>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<math>\\frac\n{\\Gamma, {\\downarrow}N, N \\vdash J}\n{\\Gamma, {\\downarrow}N \\vdash J}\n{\\downarrow}L</math></center>\n\n<br/>\n\n<center><math>\\frac\n{~~~}\n{\\Gamma \\vdash 1~true}\n{1}R</math>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<math>\\frac\n{\\Gamma \\vdash P_1~true \\qquad \\Gamma \\vdash P_2~true}\n{\\Gamma \\vdash P_1 \\wedge^+ P_2~true}\n{\\wedge^+}R</math>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<math>\\frac\n{\\Gamma, P_1 \\wedge^+ P_2, P_1, P_2 \\vdash J}\n{\\Gamma, P_1 \\wedge^+ P_2 \\vdash J}\n{\\wedge^+}L</math></center>\n\n<br/>\n\n<center><math>\\frac\n{~~~}\n{\\Gamma \\vdash \\top~true}\n{\\top}R</math>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<math>\\frac\n{\\Gamma \\vdash N_1~true \\qquad \\Gamma \\vdash N_2~true}\n{\\Gamma \\vdash N_1 \\wedge^- N_2~true}\n{\\wedge^-}R</math></center>\n\n<br/>\n\n<center><math>\\frac\n{\\Gamma, N_1 \\wedge^+ N_2, N_1 \\vdash J}\n{\\Gamma, N_1 \\wedge^+ N_2 \\vdash J}\n{\\wedge^-}L_1</math>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<math>\\frac\n{\\Gamma, N_1 \\wedge^+ N_2, N_2 \\vdash J}\n{\\Gamma, N_1 \\wedge^+ N_2 \\vdash J}\n{\\wedge^-}L_2</math></center>\n\n<br/>\n\n<center><math>\\frac\n{\\Gamma \\vdash P_1~true}\n{\\Gamma \\vdash P_1 \\vee P_2~true}\n{\\vee}R_1</math>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<math>\\frac\n{\\Gamma \\vdash P_2~true}\n{\\Gamma \\vdash P_1 \\vee P_2~true}\n{\\vee}R_2</math>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<math>\\frac\n{\\Gamma, P_1 \\vee P_2, P_1 \\vdash J \\qquad \\Gamma, P_1 \\vee P_2, P_2 \\vdash J}\n{\\Gamma, P_1 \\vee P_2 \\vdash J}\n{\\vee}R</math></center>\n\n<br/>\n\n<center><math>\\frac\n{\\Gamma, P \\vdash N~true}\n{\\Gamma \\vdash P \\supset N~true}\n{\\supset}R</math>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<math>\\frac\n{\\Gamma, P_1 \\supset P_2 \\vdash P_1 \\qquad \\Gamma, P_1 \\supset P_2, P_2 \\vdash J}\n{\\Gamma, P_1 \\supset P_2 \\vdash J}\n{\\supset}L</math></center>\n\n<br/>\n\n<center><math>\\frac\n{\\Gamma \\vdash P~lax}\n{\\Gamma \\vdash {\\bigcirc}P~true}\n{\\bigcirc}R</math>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<math>\\frac\n{\\Gamma, {\\bigcirc}P, P \\vdash A~lax}\n{\\Gamma, {\\bigcirc}P \\vdash A~lax}\n{\\bigcirc}L</math></center>}%\n\n%{ ==== Rules in Twelf ==== }%\n\ninit+ : hyp (atom Qp) -> true (atom (Qp: atm pos)).\ninit- : hyp (atom Qn) -> true (atom (Qn: atm neg)).\n\nlaxR : true A\n        -> lax A.\n\nupR : true P\n       -> true (up P).\nupL : (hyp P -> conc J)\n       -> (hyp (up P) -> conc J).\n\ndownR : true N\n         -> true (down N).\ndownL : (hyp N -> conc J)\n         -> (hyp (down N) -> conc J).\n\n1R : true 1.\n% no 1L\n\n*R : true P1\n      -> true P2\n      -> true (P1 * P2).\n*L : (hyp P1 -> hyp P2 -> conc J)\n      -> (hyp (P1 * P2) -> conc J).\n\ntopR : true top.\n% no topL\n\n&R : true N1\n      -> true N2\n      -> true (N1 & N2).\n&L1 : (hyp N1 -> conc J)\n       -> (hyp (N1 & N2) -> conc J).\n&L2 : (hyp N2 -> conc J)\n       -> (hyp (N1 & N2) -> conc J).\n\n% no 0R\n0L : (hyp 0 -> conc J).\n\n+R1 : true P1\n       -> true (P1 + P2).\n+R2 : true P2\n       -> true (P1 + P2).\n+L : (hyp P1 -> conc J)\n      -> (hyp P2 -> conc J)\n      -> (hyp (P1 + P2) -> conc J).\n\n-oR : (hyp P -> true N)\n       -> true (P -o N).\n-oL : true P\n       -> (hyp N -> conc J)\n       -> (hyp (P -o N) -> conc J).\n\ncircR : lax P\n         -> true (circ P).\ncircL : (hyp P -> lax A)\n         -> (hyp (circ P) -> lax A).\n\n%worlds (bl_atmpos | bl_atmneg | bl_hyp) (hyp A) (conc J).\n\n%{ == Translation == }%\n\n%{ Now we can define a nondeterminstic translation between our variant of\nFairtlough and Mendler's propositional lax logic and our target logic,\npolarized, judgmental lax logic. We will use a metric that essentially\ncaptures the structure of the term in the target logic (in fact, it would\nbe worth seeing if we could use the term in the target logic in lieu of\nthe metric.) }%\n\n%{ === Propositions === }%\n\n%{ The intent of the first relation we define is to be maximally general, which\nmeans that the <tt>t+-</tt> and <tt>t-+</tt> rules can add an arbitrary \nnumber of shifts. Read in the reverse direction, the translation is not \nvery nondeterminstic; however \"<tt>P -o up 0</tt>\" can still be translated\nto either \"<tt>not M</tt>\" or \"<tt>M => (not' tt')</tt>,\" which are different\nsource logic expressions. }%\n\ntrans : metric -> prop' -> {S} prop S -> type. %name trans TR.\n\nt+- : trans T M pos P -> trans (x T) M neg (up P).\nt-+ : trans T M neg N -> trans (x T) M pos (down N).\n\ntatom : trans o (atom' Q) S (atom Q). \nt+true : trans o tt' pos 1.\nt-true : trans o tt' neg top.\nt+false: trans o ff' pos 0.\nt+and  : trans T1 M1 pos P1\n          -> trans T2 M2 pos P2 \n          -> trans (T1 | T2) (M1 /\\ M2) pos (P1 * P2).\nt-and  : trans T1 M1 neg N1 \n          -> trans T2 M2 neg N2 \n          -> trans (T1 | T2) (M1 /\\ M2) neg (N1 & N2).\nt+or   : trans T1 M1 pos P1 \n          -> trans T2 M2 pos P2\n          -> trans (T1 | T2) (M1 \\/ M2) pos (P1 + P2).\nt-imp  : trans T1 M1 pos P\n          -> trans T2 M2 neg N \n          -> trans (T1 | T2) (M1 => M2) neg (P -o N).\nt+not  : trans T M pos P -> trans (x T) (not' M) neg (P -o up 0).\nt+circ : trans T M pos P -> trans (x T) (circ' M) neg (circ P).\n\n%worlds (bl_atmpos | bl_atmneg) (trans _ _ _ _).\n\n%{ === Conclusions === }%\n\n%{ We additionally define translation between right-hand-sides \n<tt>D</tt> in the source logic and judgments <tt>J</tt> in the target \nlogic. }%\n\ntrans-conc : metric -> conseq' -> conseq -> type. %name trans-conc TC.\n\ntc : trans-conc T (conc-true' M) (conc-true A) <- trans T M S A.\ntc# : trans-conc o conc-# (conc-true (up 0)).\ntclax : trans-conc T (conc-true' (circ' M)) (conc-lax A) \n         <- trans T M S A.\n\n%worlds (bl_atmpos | bl_atmneg) (trans-conc _ _ _).\n\n%{ === Hypotheses === }%\n\n%{ When we are showing soundness and completeness, we will need\nto know that for every hypothesis in the {source, target} logic we have\na hypothesis in the {target, source} logic such that one is the translation\nof the other. \n\nWhat we would like to do is define a single <tt>trans-hyp</tt> that allows us \nto translate from source logic hypotheses to target logic hypotheses, and\nvice versa. However, because we cannot assign multiple modes to the same \nrelation, we'll define two different relations, and use them to define two\ndifferent worlds.\n\n* <tt>trans-soundhyp</tt> takes a target logic hypotheis <tt>H</tt> and obtains a translation <tt>TR</tt> and a source logic hypothesis <tt>H'</tt>.\n* <tt>trans-complhyp</tt> takes a source logic hypothesis <tt>H'</tt> and obtains a translation <tt>TR</tt> and a target logic hypothesis <tt>H</tt>. }%\n\ntrans-soundhyp : hyp H -> trans Mh H' S H -> hyp' H' -> type.\n%mode trans-soundhyp +H' -T -H.\n\n%block bl_trans-soundhyp \n   : some {M: metric}{S: polarity}{A: prop S}{A': prop'}{T: trans M A' S A}\n      block {h: hyp A}{h': hyp' A'}{t: trans-soundhyp h T h'}.\n\n%worlds (bl_atmpos | bl_atmneg | bl_trans-soundhyp)  (trans-soundhyp _ _ _).\n%total [] (trans-soundhyp _ _ _).\n\ntrans-complhyp : hyp' A -> trans Mt A S C -> hyp C -> type.\n%mode trans-complhyp +H' -T -H.\n\n%block bl_trans-complhyp \n   : some {M: metric}{A: prop'}{S: polarity}{C: prop S}{T: trans M A S C}\n      block {h': hyp' A}{h: hyp C}{t: trans-complhyp h' T h}.\n\n%worlds (bl_atmpos | bl_atmneg | bl_trans-complhyp)  (trans-complhyp _ _ _).\n%total [] (trans-complhyp _ _ _).\n\n%{ === Correspondence === }%\n\n%{ A corollary to the  theorem we will state below will say \"If \n<math>\\vdash A~true</math> and <math>M~\\texttt{trans}~A</math>, then \n<math>\\vdash M</math>.\" However, if there is no <math>M</math> such that \n<math>M~\\texttt{trans}~A</math>, then the theorem will be vacuously true, \nwhich is not our intent. Therefore, we need to establish that our translations\nof propositions and conclusions are ''correspondences'' \n(left- and right-total). \n\nTwelf can verify that translation is ''right-total'', that there is an \n<tt>M</tt> for every <tt>A</tt> and a <tt>D</tt> for every <tt>J</tt>, without\nany further work on our part: we just assign modes to the relation\nand state a [[totality assertion]]. }%\n\n%mode trans -T -M +S +A.\n%mode trans-conc -T -D +J.\n%total (A C) (trans _ _ _ A) (trans-conc _ _ C).\n\n%{ However, in the forward direction, to show that the relation is \n''left-total'' we will need to write an \n[[effectiveness lemma]], which we will call <tt>can-trans</tt>.\n\nThe two lemmas <tt>can-switch</tt> are really just case analysis to \nestablish that if you can translate something as a positive formula, you can\napply an up shift to make it a negative formula, and vice versa. }%\n\ncan-switch+ : trans M A S (C: prop S) -> trans N A pos C' -> type.\n- : can-switch+ T T.\n- : can-switch+ T (t-+ T).\n%mode can-switch+ +A -B. \n%worlds (bl_atmpos | bl_atmneg) (can-switch+ _ _). \n%total [] (can-switch+ _ _).\n\ncan-switch- : trans M A S' C -> trans N A neg C' -> type.\n- : can-switch- T T.\n- : can-switch- T (t+- T).\n%mode can-switch- +A -B. \n%worlds (bl_atmpos | bl_atmneg) (can-switch- _ _). \n%total [] (can-switch- _ _).\n\ncan-trans : {A} trans M A S (C: prop S) -> type. \n%mode can-trans +A -T.\n\n- : can-trans (atom' Qp) tatom.\n- : can-trans tt' t-true.\n- : can-trans (A /\\ B) (t-and T1' T2')\n     <- can-trans A T1\n     <- can-switch- T1 T1'\n     <- can-trans B T2\n     <- can-switch- T2 T2'.\n- : can-trans (A \\/ B) (t+or T1' T2')\n     <- can-trans A T1\n     <- can-switch+ T1 T1'\n     <- can-trans B T2\n     <- can-switch+ T2 T2'.\n- : can-trans (A => B) (t-imp T1' T2')\n     <- can-trans A T1\n     <- can-switch+ T1 T1'\n     <- can-trans B T2\n     <- can-switch- T2 T2'.\n- : can-trans (not' A) (t+not T')\n     <- can-trans A T\n     <- can-switch+ T T'.\n- : can-trans (circ' A) (t+circ T')\n     <- can-trans A T\n     <- can-switch+ T T'.\n\n%worlds (bl_atmpos | bl_atmneg) (can-trans _ _).\n%total A (can-trans A _).\n\ncan-trans-conc : {D} trans-conc T D J -> type.\n%mode can-trans-conc +D -T.\n\n- : can-trans-conc conc-# tc#.\n- : can-trans-conc (conc-true' M) (tc TR)\n     <- can-trans M TR.\n\n%worlds (bl_atmpos | bl_atmneg) (can-trans-conc _ _).\n%total A (can-trans-conc A _).\n\n\n%{ == Metatheory of the target logic == }%\n\n%{ The correctness of translation will rest on the standard metatheoretic\nresults: the ''identity principle'' and the ''admissibility of cut''. Note \nthat we could have added a <tt>cut</tt> and <tt>id</tt> rule to the target\nlogic, but we still would have eventually needed to do the work in this \nsection in order to have confidence that our target logic was reasonable. }% \n\n%{ === Identity === }%\n\n%{ For all propositions <math>A</math>, there exists a derivation of\n<math>A \\vdash A~true</math>. \n\nThe proof is by induction on the formula <math>A</math>. }%\n\nidentity : {A} (hyp A -> true A) -> type.\n%mode identity +A -D.\n\n- : identity (atom Q) init+.\n- : identity (atom Q) init-.\n- : identity (up P) ([h] upL ([h'] upR (D h')) h)\n     <- identity P (D: hyp P -> true P).\n- : identity (down N) ([h] downL ([h'] downR (D h')) h)\n     <- identity N (D: hyp N -> true N).\n- : identity top ([_] topR).\n- : identity 1 ([_] 1R).\n- : identity 0 ([h] 0L h).\n- : identity (P1 * P2) ([h] *L ([h1][h2] *R (D1 h1) (D2 h2)) h)\n     <- identity P1 (D1: hyp P1 -> true P1)\n     <- identity P2 (D2: hyp P2 -> true P2).\n- : identity (N1 & N2) ([h] &L1 ([h1] &L2 ([h2] &R (D1 h1) (D2 h2)) h) h)\n     <- identity N1 (D1: hyp N1 -> true N1)\n     <- identity N2 (D2: hyp N2 -> true N2).\n- : identity (P1 + P2) ([h] +L ([h1] +R1 (D1 h1)) ([h2] +R2 (D2 h2)) h)\n     <- identity P1 (D1: hyp P1 -> true P1)\n     <- identity P2 (D2: hyp P2 -> true P2).\n- : identity (P -o N) ([h] -oR ([h1] -oL (D1 h1) ([h2] D2 h2) h))\n     <- identity P (D1: hyp P -> true P)\n     <- identity N (D2: hyp N -> true N).\n- : identity (circ P) ([h] circR (circL ([h'] laxR (D1 h')) h))\n     <- identity P (D1: hyp P -> true P).\n\n%worlds (bl_atmpos | bl_atmneg | bl_hyp) (identity _ _).\n%total T (identity T _).\n\n%{ === Cut admissibility === }%\n\n%{ There are two cut principles which must be proven simultaneously; \n<tt>cut</tt> is the main theorem, and <tt>lcut</tt> is the cut principle\nfor lax truth.\n\n* If <math>\\Gamma \\vdash A~true</math> and <math>\\Gamma, A \\vdash J</math>, then <math>\\Gamma \\vdash J</math> (<tt>cut</tt>)\n* If <math>\\Gamma \\vdash A~lax</math> and <math>\\Gamma, A \\vdash C~lax</math>, then <math>\\Gamma \\vdash C~lax</math> (<tt>lcut</tt>)\n\nThe proofs are by mutual lexographic induction; either the principal cut \nformula <math>A</math> gets smaller, or else the principal cut formula\nstays the same and one or both of the input derivations get smaller. The proof\nis entirely standard other than the need for extra commutative cuts for\n<tt>tlax</tt>; more explanation is available at the article on\nthe [[admissibility of cut]]. }%\n\ncut : {A} true A -> (hyp A -> conc J) -> conc J -> type.\nlcut : {A} lax A -> (hyp A -> lax C) -> lax C -> type.\n%mode cut +A +D +E -F.\n%mode lcut +A +D +E -F.\n\n%{ ==== Principal cuts ==== }%\n\n- : cut (atom Q) (init+ H) ([h] init+ h) (init+ H).\n- : cut (atom Q) (init- H) ([h] init- h) (init- H).\n\n- : cut (up P) (upR (D: true P)) ([h] upL (E h : hyp P -> conc J) h) G\n     <- ({h': hyp P} cut (up P) (upR D) ([h] E h h') (F h'))\n     <- cut P D ([h'] F h') (G: conc J).\n\n- : cut (down N) (downR (D: true N)) ([h] downL (E h : hyp N -> conc J) h) G\n     <- ({h': hyp N} cut (down N) (downR D) ([h] E h h') (F h'))\n     <- cut N D ([h'] F h') (G: conc J).\n\n- : cut (P1 * P2) (*R (D1: true P1) (D2: true P2))\n     ([h] *L (E h : hyp P1 -> hyp P2 -> conc J) h) G\n     <- ({h1: hyp P1}{h2: hyp P2} \n           cut (P1 * P2) (*R D1 D2) ([h] E h h1 h2) (F h1 h2))\n     <- ({h2: hyp P2} cut P1 D1 ([h1] F h1 h2) (F1 h2))\n     <- cut P2 D2 ([h2] F1 h2) (G: conc J).\n\n- : cut (N1 & N2) (&R (D1: true N1) (D2: true N2)) \n     ([h] &L1 (E h : hyp N1 -> conc J) h) G\n     <- ({h1: hyp N1} cut (N1 & N2) (&R D1 D2) ([h] E h h1) (F h1))\n     <- cut N1 D1 ([h1] F h1) (G: conc J).\n\n- : cut (N1 & N2) (&R (D1: true N1) (D2: true N2)) \n     ([h] &L2 (E h : hyp N2 -> conc J) h) G\n     <- ({h2: hyp N2} cut (N1 & N2) (&R D1 D2) ([h] E h h2) (F h2))\n     <- cut N2 D2 ([h2] F h2) (G: conc J).\n\n- : cut (P1 + P2) (+R1 (D1: true P1)) ([h] +L (E1 h : hyp P1 -> conc J) _ h) G\n     <- ({h1: hyp P1} cut (P1 + P2) (+R1 D1) ([h] E1 h h1) (F h1))\n     <- cut P1 D1 ([h1] F h1) G. \n\n- : cut (P1 + P2) (+R2 (D2: true P2)) ([h] +L _ (E2 h : hyp P2 -> conc J) h) G\n     <- ({h2: hyp P2} cut (P1 + P2) (+R2 D2) ([h] E2 h h2) (F h2))\n     <- cut P2 D2 ([h2] F h2) G. \n\n- : cut (P -o N) (-oR (D: hyp P -> true N)) \n     ([h] -oL (E1 h: true P) (E2 h: hyp N -> conc J) h) G\n     <- cut (P -o N) (-oR D) ([h] E1 h) (F1: true P)\n     <- ({h': hyp N} cut (P -o N) (-oR D) ([h] E2 h h') (F2 h' : conc J))\n     <- cut P F1 ([h'] D h') (G1: true N)\n     <- cut N G1 ([h'] F2 h') (G: conc J).\n\n- : cut (circ P) (circR (D: lax P)) ([h] circL (E h : hyp P -> lax C) h) G\n     <- ({h': hyp P} cut (circ P) (circR D) ([h] E h h') (F h': lax C))\n     <- lcut P D ([h'] F h') G.\n\n%{ ==== Left commutative cuts ==== }%\n\n- : lcut P (laxR (D: true P)) E F\n     <- cut P D E F.\n- : cut A (upL D H) E (upL F H)\n     <- {h1} cut A (D h1) E (F h1).\n- : cut A (downL D H) E (downL F H)\n     <- {h1} cut A (D h1) E (F h1).\n- : cut A (0L H) E (0L H).\n- : cut A (*L D H) E (*L F H)\n     <- {h1}{h2} cut A (D h1 h2) E (F h1 h2).\n- : cut A (&L1 D H) E (&L1 F H)\n     <- {h1} cut A (D h1) E (F h1).\n- : cut A (&L2 D H) E (&L2 F H)\n     <- {h2} cut A (D h2) E (F h2).\n- : cut A (+L D1 D2 H) E (+L F1 F2 H)\n     <- ({h1} cut A (D1 h1) E (F1 h1))\n     <- ({h2} cut A (D2 h2) E (F2 h2)).\n- : cut A (-oL D1 D2 H) E (-oL D1 F2 H)\n     <- {h'} cut A (D2 h') E (F2 h').\n\n\n%{ ==== Monadic left commutative cuts ==== }%\n\n- : lcut A (circL ([h] D h) H) E (circL ([h] F h) H)\n     <- {h'} lcut A (D h') E (F h').\n- : lcut A (upL D H) E (upL F H)\n     <- {h1} lcut A (D h1) E (F h1).\n- : lcut A (downL D H) E (downL F H)\n     <- {h1} lcut A (D h1) E (F h1).\n- : lcut A (0L H) E (0L H).\n- : lcut A (*L D H) E (*L F H)\n     <- {h1}{h2} lcut A (D h1 h2) E (F h1 h2).\n- : lcut A (&L1 D H) E (&L1 F H)\n     <- {h1} lcut A (D h1) E (F h1).\n- : lcut A (&L2 D H) E (&L2 F H)\n     <- {h2} lcut A (D h2) E (F h2).\n- : lcut A (+L D1 D2 H) E (+L F1 F2 H)\n     <- ({h1} lcut A (D1 h1) E (F1 h1))\n     <- ({h2} lcut A (D2 h2) E (F2 h2)).\n- : lcut A (-oL D1 D2 H) E (-oL D1 F2 H)\n     <- {h'} lcut A (D2 h') E (F2 h').\n\n%{ ==== Right commutative cuts ==== }%\n\n- : cut A D ([h] init+ H) (init+ H).\n- : cut A D ([h] init- H) (init- H).\n- : cut A D ([h] laxR (E h)) (laxR F)\n     <- cut A D ([h] E h) F.\n- : cut A D ([h] upR (E h)) (upR F)\n     <- cut A D ([h] E h) F.\n- : cut A D ([h] upL ([h'] E h h') H) (upL F H)\n     <- {h'} cut A D ([h] E h h') (F h'). \n- : cut A D ([h] downR (E h)) (downR F)\n     <- cut A D ([h] E h) F.\n- : cut A D ([h] downL ([h'] E h h') H) (downL F H)\n     <- {h'} cut A D ([h] E h h') (F h').\n- : cut A D ([h] topR) topR.\n- : cut A D ([h] 1R) 1R.\n- : cut A D ([h] 0L H) (0L H).\n- : cut A D ([h] *R (E1 h) (E2 h)) (*R F1 F2)\n     <- cut A D ([h] E1 h) F1\n     <- cut A D ([h] E2 h) F2.\n- : cut A D ([h] *L ([h1][h2] E h h1 h2) H) (*L ([h1][h2] F h1 h2) H)\n     <- {h1}{h2} cut A D ([h] E h h1 h2) (F h1 h2).\n- : cut A D ([h] &R (E1 h) (E2 h)) (&R F1 F2)\n     <- cut A D ([h] E1 h) F1\n     <- cut A D ([h] E2 h) F2.\n- : cut A D ([h] &L1 ([h1] E1 h h1) H) (&L1 ([h1] F1 h1) H)\n     <- {h1} cut A D ([h] E1 h h1) (F1 h1).\n- : cut A D ([h] &L2 ([h2] E2 h h2) H) (&L2 ([h2] F2 h2) H)\n     <- {h2} cut A D ([h] E2 h h2) (F2 h2).\n- : cut A D ([h] +R1 (E1 h)) (+R1 F1)\n     <- cut A D ([h] E1 h) F1.\n- : cut A D ([h] +R2 (E2 h)) (+R2 F2)\n     <- cut A D ([h] E2 h) F2.\n- : cut A D ([h] +L ([h1] E1 h h1) ([h2] E2 h h2) H) (+L F1 F2 H)\n     <- ({h1} cut A D ([h] E1 h h1) (F1 h1))\n     <- ({h2} cut A D ([h] E2 h h2) (F2 h2)).\n- : cut A D ([h] -oR [h'] E h h') (-oR [h'] F h')\n     <- {h'} cut A D ([h] E h h') (F h').\n- : cut A D ([h] -oL (E1 h) ([h'] E2 h h') H) (-oL F1 ([h'] F2 h') H)\n     <- cut A D ([h] E1 h) F1\n     <- {h'} cut A D ([h] E2 h h') (F2 h').\n- : cut A D ([h] circR (E h)) (circR F)\n     <- cut A D ([h] E h) F.\n- : cut A D ([h] circL ([h'] E h h') H) (circL ([h'] F h') H)\n     <- {h'} cut A D ([h] E h h') (F h').\n\n%{ ==== Monadic right commutive cuts ==== }%\n\n- : lcut A D ([h] upL ([h'] E h h') H) (upL F H)\n     <- {h'} lcut A D ([h] E h h') (F h'). \n- : lcut A D ([h] downL ([h'] E h h') H) (downL F H)\n     <- {h'} lcut A D ([h] E h h') (F h').\n- : lcut A D ([h] *L ([h1][h2] E h h1 h2) H) (*L ([h1][h2] F h1 h2) H)\n     <- {h1}{h2} lcut A D ([h] E h h1 h2) (F h1 h2).\n- : lcut A D ([h] &L1 ([h1] E1 h h1) H) (&L1 ([h1] F1 h1) H)\n     <- {h1} lcut A D ([h] E1 h h1) (F1 h1).\n- : lcut A D ([h] &L2 ([h2] E2 h h2) H) (&L2 ([h2] F2 h2) H)\n     <- {h2} lcut A D ([h] E2 h h2) (F2 h2).\n- : lcut A D ([h] +L ([h1] E1 h h1) ([h2] E2 h h2) H) (+L F1 F2 H)\n     <- ({h1} lcut A D ([h] E1 h h1) (F1 h1))\n     <- ({h2} lcut A D ([h] E2 h h2) (F2 h2)).\n\n%worlds (bl_atmpos | bl_atmneg | bl_hyp) (cut _ _ _ _) (lcut _ _ _ _).\n%total {(A1 A2) [(D1 D2) (E1 E2)]} (cut A1 D1 E1 F1) (lcut A2 D2 E2 F2).\n\n\n%{ === Inversion lemmas === }%\n\n%{ Proving invertability is an application of both cut and identity; it \nestablishes that that for some rules, whenver the conclusion is true then\nthe premises are always true as well. \n\nIn general, negative propositions are invertible on the right and positive\npropositions are invertible on the left, though in unfocused intutionstic\nlogic <tt>up</tt> and <tt>down</tt> are invertible in both directions and\nboth variants of conjunction are invertible on the right. This is not the full\nset of inversion lemmas, just the ones we needed. }%\n\ninvupR : true (up P) -> true P -> type.\n- : invupR D F\n     <- identity P (EP : hyp P -> true P)\n     <- cut (up P) D (upL ([h] EP h)) F.\n%mode invupR +D -F.\n%worlds (bl_atmpos | bl_atmneg | bl_hyp) (invupR _ _).\n%total [] (invupR _ _).\n\ninvupL : (hyp (up P) -> conc J) -> (hyp P -> conc J) -> type.\n- : invupL ([h] D h) ([h] F h)\n     <- identity P (EP : hyp P -> true P)\n     <- {h: hyp P} cut (up P) (upR (EP h)) D (F h).\n%mode invupL +D -F.\n%worlds (bl_atmpos | bl_atmneg | bl_hyp) (invupL _ _).\n%total [] (invupL _ _).\n\ninvdownR : true (down P) -> true P -> type.\n- : invdownR D F\n     <- identity P (EP : hyp P -> true P)\n     <- cut (down P) D (downL ([h] EP h)) F.\n%mode invdownR +D -F.\n%worlds (bl_atmpos | bl_atmneg | bl_hyp) (invdownR _ _).\n%total [] (invdownR _ _).\n\ninvdownL : (hyp (down P) -> conc J) -> (hyp P -> conc J) -> type.\n- : invdownL ([h] D h) ([h] F h)\n     <- identity P (EP : hyp P -> true P)\n     <- {h: hyp P} cut (down P) (downR (EP h)) D (F h).\n%mode invdownL +D -F.\n%worlds (bl_atmpos | bl_atmneg | bl_hyp) (invdownL _ _).\n%total [] (invdownL _ _).\n\ninv*R : true (P1 * P2) -> true P1 -> true P2 -> type.\n- : inv*R D F1 F2\n     <- identity (P1 * P2) (E : hyp (P1 * P2) -> true (P1 * P2))\n     <- identity P1 (E1 : hyp P1 -> true P1)\n     <- identity P2 (E2 : hyp P2 -> true P2)\n     <- cut (P1 * P2) D (*L [h1][h2] E1 h1) F1\n     <- cut (P1 * P2) D (*L [h1][h2] E2 h2) F2.\n%mode inv*R +D -F1 -F2.\n%worlds (bl_atmpos | bl_atmneg | bl_hyp) (inv*R _ _ _).\n%total [] (inv*R _ _ _).\n\ninv&R : true (N1 & N2) -> true N1 -> true N2 -> type.\n- : inv&R D F1 F2\n     <- identity (N1 & N2) (E : hyp (N1 & N2) -> true (N1 & N2))\n     <- identity N1 (E1 : hyp N1 -> true N1)\n     <- identity N2 (E2 : hyp N2 -> true N2)\n     <- cut (N1 & N2) D (&L1 [h1] E1 h1) F1\n     <- cut (N1 & N2) D (&L2 [h2] E2 h2) F2.\n%mode inv&R +D -F1 -F2.\n%worlds (bl_atmpos | bl_atmneg | bl_hyp) (inv&R _ _ _).\n%total [] (inv&R _ _ _).\n\ninv-oR : true (P -o N) -> (hyp P -> true N) -> type.\n- : inv-oR D ([h] F h)\n     <- identity P (EP : hyp P -> true P)\n     <- identity N (EN : hyp N -> true N)\n     <- {h': hyp P} cut (P -o N) D (-oL (EP h') ([h] EN h)) (F h').\n%mode inv-oR +D -F.\n%worlds (bl_atmpos | bl_atmneg | bl_hyp) (inv-oR _ _).\n%total [] (inv-oR _ _).\n\ninvcircR : true (circ P) -> lax P -> type.\n- : invcircR D F\n     <- identity P (E: hyp P -> true P)\n     <- lcut (circ P) (laxR D) (circL ([h'] laxR (E h'))) F.\n%mode invcircR +A -B.\n%worlds (bl_atmpos | bl_atmneg | bl_hyp) (invcircR _ _).\n%total [] (invcircR _ _).\n\ninvcircL : (hyp (circ P) -> lax C) -> (hyp P -> lax C) -> type.\n- : invcircL D F\n     <- identity P (E: hyp P -> true P)\n     <- {h': hyp P} cut (circ P) (circR (laxR (E h'))) ([h] D h) (F h').\n\n%{ == Correctness of translation == }%\n\n%{ === Equivalence === }%\n\n%{ This is an interesting theorem, because it captures the idea that the\ntranslation, while nondeterminstic (a single source logic proposition \ncorresponds to many target logic propositions), is not significant\n(all target logic propositions in the image of a single source logic\nproposition are equivalent). Equivalence will be necessary for the completeness\ntheorem in order to translate the identity rule in the source logic into the \ntarget logic.\n\n* If <math>M~\\texttt{trans}~A_1</math> and <math>\\Gamma \\vdash A_1~true</math> and <math>M~\\texttt{trans}~A_2</math>, then <math>\\Gamma \\vdash A_2~true</math>.\n\nThe theorem is proved by simultaneous induction on the unordered pair of the \ntwo translations, and therefore suffers from an annoying lack of expressivity\nin the Twelf termination checker. There is no way to express the argument \n\"the unordered pair of X and Y gets smaller,\" and so when we need to switch\nthe position of the arguments in the lambda case, we cannot convince Twelf\nthat something is getting smaller. The only way to do this seems to be to\ncut and paste the lemma into two copies which then call each other at the\ncritical case; Twelf can handle the unordered pair as mutual induction. \n\nFirst we need a minor strenghtening lemma first, that expresses that if a \nhypothesis translated from true, then it isn't needed. }%\n\ntrans-equiv-str : (hyp A -> conc J) -> trans _ tt' pos A -> conc J -> type.\n\n- : trans-equiv-str D (t-+ (t+- TR)) E\n     <- invdownL D D'\n     <- invupL D' D''\n     <- trans-equiv-str D'' TR E.\n- : trans-equiv-str D (t-+ t-true) E\n     <- cut (down top) (downR topR) D E.\n- : trans-equiv-str D t+true E\n     <- cut 1 1R D E.\n\n%mode trans-equiv-str +D +TR -F. \n%worlds (bl_atmpos | bl_atmneg | bl_hyp) (trans-equiv-str _ _ _).\n%total TR (trans-equiv-str _ TR _).\n\ntrans-equiv : trans _ M _ A1 -> true A1 -> trans _ M _ A2 -> true A2 -> type.\ntrans-equivX: trans _ M _ A1 -> true A1 -> trans _ M _ A2 -> true A2 -> type.\n%mode trans-equiv +T1 +D1 +T2 -D2.\n%mode trans-equivX +T1 +D1 +T2 -D2.\n\n- : trans-equiv (t+- T1) D1 T2 D2\n     <- invupR D1 D1'\n     <- trans-equiv T1 D1' T2 D2.\n- : trans-equiv (t-+ T1) D1 T2 D2\n     <- invdownR D1 D1'\n     <- trans-equiv T1 D1' T2 D2.\n- : trans-equiv T1 D1 (t+- T2) (upR D2)\n     <- trans-equiv T1 D1 T2 D2.\n- : trans-equiv T1 D1 (t-+ T2) (downR D2)\n     <- trans-equiv T1 D1 T2 D2.\n\n- : trans-equiv tatom D tatom D.\n- : trans-equiv t+true D t+true D.\n- : trans-equiv t+true D t-true topR.\n- : trans-equiv t-true D t+true 1R.\n- : trans-equiv t-true D t-true D.\n- : trans-equiv t+false D _ E\n     <- cut 0 D ([h] 0L h) E.\n- : trans-equiv (t+not T) D t+false E\n     <- inv-oR D (Da : hyp P1 -> true (up 0))\n     <- ({h} invupR (Da h) (Db h))\n     <- trans-equiv-str Db T E.\n- : trans-equiv (t+and Ta Tb) D (t+and Sa Sb) (*R Ea Eb)\n     <- inv*R D Da Db\n     <- trans-equiv Ta Da Sa Ea\n     <- trans-equiv Tb Db Sb Eb.\n- : trans-equiv (t-and Ta Tb) D (t+and Sa Sb) (*R Ea Eb)\n     <- inv&R D Da Db\n     <- trans-equiv Ta Da Sa Ea\n     <- trans-equiv Tb Db Sb Eb.\n- : trans-equiv (t+and Ta Tb) D (t-and Sa Sb) (&R Ea Eb)\n     <- inv*R D Da Db\n     <- trans-equiv Ta Da Sa Ea\n     <- trans-equiv Tb Db Sb Eb.\n- : trans-equiv (t-and Ta Tb) D (t-and Sa Sb) (&R Ea Eb)\n     <- inv&R D Da Db\n     <- trans-equiv Ta Da Sa Ea\n     <- trans-equiv Tb Db Sb Eb.\n- : trans-equiv (t+or Ta Tb) D (t+or Sa Sb) E\n     <- identity P1 (D1 : hyp P1 -> true P1)\n     <- ({h1} trans-equiv Ta (D1 h1) Sa (E1 h1))\n     <- identity P2 (D2 : hyp P2 -> true P2)\n     <- ({h2} trans-equiv Tb (D2 h2) Sb (E2 h2))\n     <- cut (P1 + P2) D (+L ([h1] +R1 (E1 h1)) ([h2] +R2 (E2 h2))) E.\n- : trans-equiv (t-imp Ta Tb) D (t-imp Sa Sb) (-oR E)\n     <- identity P2 (D1 : hyp P2 -> true P2)\n     <- ({h1} trans-equivX Sa (D1 h1) Ta (E1 h1))\n     <- inv-oR D (D2 : hyp P1 -> true N1)\n     <- ({h1} trans-equiv Tb (D2 h1) Sb (E2 h1))\n     <- ({h2} cut P1 (E1 h2) ([h1] E2 h1) (E h2: true N2)).\n- : trans-equiv (t+not T) D (t+not S) (-oR E)\n     <- identity P2 (D1: hyp P2 -> true P2)\n     <- ({h1} trans-equivX S (D1 h1) T (E1 h1))\n     <- inv-oR D (D2 : hyp P1 -> true (up 0))\n     <- ({h2} cut P1 (E1 h2) ([h1] D2 h1) (E h2: true (up 0))).\n- : trans-equiv (t+circ T) (D: true (circ P)) (t+circ S) (circR F)\n     <- invcircR D (D1 : lax P)\n     <- identity P (D2 : hyp P -> true P)\n     <- ({h1} trans-equiv T (D2 h1) S (E h1: true B))\n     <- lcut P D1 ([h] laxR (E h)) F.\n\n%% Cut and paste:\n\n- : trans-equivX (t+- T1) D1 T2 D2\n     <- invupR D1 D1'\n     <- trans-equivX T1 D1' T2 D2.\n- : trans-equivX (t-+ T1) D1 T2 D2\n     <- invdownR D1 D1'\n     <- trans-equivX T1 D1' T2 D2.\n- : trans-equivX T1 D1 (t+- T2) (upR D2)\n     <- trans-equivX T1 D1 T2 D2.\n- : trans-equivX T1 D1 (t-+ T2) (downR D2)\n     <- trans-equivX T1 D1 T2 D2.\n\n- : trans-equivX tatom D tatom D.\n- : trans-equivX t+true D t+true D.\n- : trans-equivX t+true D t-true topR.\n- : trans-equivX t-true D t+true 1R.\n- : trans-equivX t-true D t-true D.\n- : trans-equivX t+false D _ E\n     <- cut 0 D ([h] 0L h) E.\n- : trans-equivX (t+not T) D t+false E\n     <- inv-oR D (Da : hyp P1 -> true (up 0))\n     <- ({h} invupR (Da h) (Db h))\n     <- trans-equiv-str Db T E.\n- : trans-equivX (t+and Ta Tb) D (t+and Sa Sb) (*R Ea Eb)\n     <- inv*R D Da Db\n     <- trans-equivX Ta Da Sa Ea\n     <- trans-equivX Tb Db Sb Eb.\n- : trans-equivX (t-and Ta Tb) D (t+and Sa Sb) (*R Ea Eb)\n     <- inv&R D Da Db\n     <- trans-equivX Ta Da Sa Ea\n     <- trans-equivX Tb Db Sb Eb.\n- : trans-equivX (t+and Ta Tb) D (t-and Sa Sb) (&R Ea Eb)\n     <- inv*R D Da Db\n     <- trans-equivX Ta Da Sa Ea\n     <- trans-equivX Tb Db Sb Eb.\n- : trans-equivX (t-and Ta Tb) D (t-and Sa Sb) (&R Ea Eb)\n     <- inv&R D Da Db\n     <- trans-equivX Ta Da Sa Ea\n     <- trans-equivX Tb Db Sb Eb.\n- : trans-equivX (t+or Ta Tb) D (t+or Sa Sb) E\n     <- identity P1 (D1 : hyp P1 -> true P1)\n     <- ({h1} trans-equivX Ta (D1 h1) Sa (E1 h1))\n     <- identity P2 (D2 : hyp P2 -> true P2)\n     <- ({h2} trans-equivX Tb (D2 h2) Sb (E2 h2))\n     <- cut (P1 + P2) D (+L ([h1] +R1 (E1 h1)) ([h2] +R2 (E2 h2))) E.\n- : trans-equivX (t-imp Ta Tb) D (t-imp Sa Sb) (-oR E)\n     <- identity P2 (D1 : hyp P2 -> true P2)\n     <- ({h1} trans-equiv Sa (D1 h1) Ta (E1 h1))\n     <- inv-oR D (D2 : hyp P1 -> true N1)\n     <- ({h1} trans-equivX Tb (D2 h1) Sb (E2 h1))\n     <- ({h2} cut P1 (E1 h2) ([h1] E2 h1) (E h2: true N2)).\n- : trans-equivX (t+not T) D (t+not S) (-oR E)\n     <- identity P2 (D1: hyp P2 -> true P2)\n     <- ({h1} trans-equiv S (D1 h1) T (E1 h1))\n     <- inv-oR D (D2 : hyp P1 -> true (up 0))\n     <- ({h2} cut P1 (E1 h2) ([h1] D2 h1) (E h2: true (up 0))).\n- : trans-equivX (t+circ T) (D: true (circ P)) (t+circ S) (circR F)\n     <- invcircR D (D1 : lax P)\n     <- identity P (D2 : hyp P -> true P)\n     <- ({h1} trans-equivX T (D2 h1) S (E h1: true B))\n     <- lcut P D1 ([h] laxR (E h)) F.\n\n%worlds (bl_atmpos | bl_atmneg | bl_hyp)\n  (trans-equiv _ _ _ _) (trans-equivX _ _ _ _).\n%total [(T1 T2) (S1 S2)] (trans-equiv T1 _ S1 _) (trans-equivX S2 _ T2 _).\n\n%{ === Soundness === }%\n\n%{ * If <math>\\Gamma \\vdash J</math> and <math>\\Gamma'~\\texttt{trans}~\\Gamma</math> and <math>\\Delta~\\texttt{trans}~J</math>, then <math>\\Gamma' \\vdash \\Delta</math> (<tt>trans-sound</tt>)\n\nProved by induction on the target logic derivation <math>\\Gamma \\vdash J</math>.  }%\n\ntrans-sound : conc C -> trans-conc Mt C' C -> conc' Mc C' -> type.\n%mode trans-sound +C +T -C'.\n\n%{ Every case of translating a left rule needs to translate a hypothesis, \nand we can usefully predict the form of the output, except in the cases where\nthe reverse translation is not determinstic. The first lemma, \n<tt>trans-init</tt>, is essentally just an [[output factoring]] \nlemma because the case of translating\natomic formula really consists of two cases, the positive atoms and the\nnegative atoms, and this triggers Twelf's [[output freeness]] check. \n\nThe second nondetermistic case is where we are translating an implication\nin the target logic and may encounter either an implication or a \nnegation in the source logic. This case (<tt>trans-imp</tt>)\nbecomes mutually inductive\nwith the main theorem, and establishes a pattern that will continue in the\ncompleteness theorem. \n\nOne case in particular is worth pointing out. We have\n<math>\\Gamma \\vdash {\\uparrow} 0~true</math> in the target logic using the\nrule <tt>upR</tt>, which gives us a subderivation \n<math>\\Gamma \\vdash 0~true</math>, and we are\ntranslating into a contradiction <math>\\Gamma' \\vdash</math> in the \ntarget logic (let <math>\\Gamma'</math> be the translated \n<math>\\Gamma</math>).  \n\nBy the induction hypothesis we have\n<math>\\Gamma' \\vdash \\mathsf{false}</math>, \nwhich we have defined to be <math>\\Gamma' \\vdash \\neg \\mathsf{true}</math>. \nWe need to prove, however, <math>\\Gamma' \\vdash</math>. Let \n[[User:Rsimmons|me]] know if I'm wrong, but the only way I could figure out\nhow to do this was by using the cut rule in the source logic, which means\nthat we do ''not'' get cut elimination \"for free\" in the source logic by virtue\nof cut admissibility in the target logic.\n\n<math>\n\\frac\n{\\frac\n {~~~~}\n {\\Gamma \\vdash \\neg\\mathsf{true}}\n {i.h.}\\qquad \n \\frac\n {\\frac{}{\\Gamma, \\neg\\mathsf{true}\\vdash\\mathsf{true}}{\\mathsf{true}R}}\n {\\Gamma, \\neg\\mathsf{true}\\vdash}}\n {\\neg}L\n{\\Gamma \\vdash}\n{cut}\n</math>\n\nThis awkwardness is a result of the slight mismatch between falsehood in \nthe target logic and contradiction in the source logic, and is part of\nthe reason we didn't include falsehood as a primitive in the source logic. \n}% \n\ntrans-init : trans Mt A' S (atom Q) -> hyp' A' -> hyp' (atom' Q) -> type.\n- : trans-init tatom H H.\n%mode trans-init +T +H -H'.\n%worlds (bl_atmpos | bl_atmneg | bl_trans-soundhyp)  (trans-init _ _ _).\n%total [] (trans-init _ _ _).\n\n- : trans-sound (init+ H) (tc tatom) (id' H'')\n     <- trans-soundhyp H T H'\n     <- trans-init T H' H''.\n- : trans-sound (init- H) (tc tatom) (id' H'')\n     <- trans-soundhyp H T H'\n     <- trans-init T H' H''.\n- : trans-sound (laxR D) (tclax T) (circR' E)\n     <- trans-sound D (tc T) E.\n- : trans-sound (upR D) (tc (t+- T)) E\n     <- trans-sound D (tc T) E. \n- : trans-sound (upR D) tc# (cut' E ([h] notL' trueR' h))\n     <- trans-sound D (tc t+false) E.\n- : trans-sound (upL D H) T (E H')\n     <- trans-soundhyp H (t+- Th) H'\n     <- ({h}{h'} trans-soundhyp h Th h' \n           -> trans-sound (D h) T (E h' : conc' M C)).\n- : trans-sound (downR D) (tc (t-+ T)) E\n     <- trans-sound D (tc T) E.\n- : trans-sound (downL D H) T (E H')\n     <- trans-soundhyp H (t-+ Th) H'\n     <- ({h}{h'} trans-soundhyp h Th h' \n           -> trans-sound (D h) T (E h' : conc' M C)).\n- : trans-sound topR (tc t-true) trueR'.\n- : trans-sound 1R (tc t+true) trueR'.\n- : trans-sound (0L H) _ (notL' trueR' H')\n     <- trans-soundhyp H t+false H'.\n- : trans-sound (0L H) _ (weakR' (notL' trueR' H'))\n     <- trans-soundhyp H t+false H'.\n- : trans-sound (*R D1 D2) (tc (t+and T1 T2)) (/\\R' E1 E2)\n     <- trans-sound D1 (tc T1) E1\n     <- trans-sound D2 (tc T2) E2.\n- : trans-sound (*L D H) T (/\\L' ([h1][h2] E h1 h2) H')\n     <- trans-soundhyp H (t+and Th1 Th2) H'\n     <- ({h1}{h1'} trans-soundhyp h1 Th1 h1'\n           -> {h2}{h2'} trans-soundhyp h2 Th2 h2'\n           -> trans-sound (D h1 h2) T (E h1' h2')).\n- : trans-sound (&R D1 D2) (tc (t-and T1 T2)) (/\\R' E1 E2)\n     <- trans-sound D1 (tc T1) E1\n     <- trans-sound D2 (tc T2) E2.\n- : trans-sound (&L1 D H) T (/\\L' ([h1][h2] E h1) H')\n     <- trans-soundhyp H (t-and Th _) H'\n     <- ({h}{h'} trans-soundhyp h Th h'\n           -> trans-sound (D h) T (E h')).\n- : trans-sound (&L2 D H) T (/\\L' ([h1][h2] E h2) H')\n     <- trans-soundhyp H (t-and _ Th) H'\n     <- ({h}{h'} trans-soundhyp h Th h'\n           -> trans-sound (D h) T (E h')).\n- : trans-sound (+R1 D) (tc (t+or T _)) (\\/R1' E)\n     <- trans-sound D (tc T) E.\n- : trans-sound (+R2 D) (tc (t+or _ T)) (\\/R2' E)\n     <- trans-sound D (tc T) E.\n- : trans-sound (+L D1 D2 H) T (\\/L' E1 E2 H')\n     <- trans-soundhyp H (t+or Th1 Th2) H'\n     <- ({h1}{h1'} trans-soundhyp h1 Th1 h1'\n           -> trans-sound (D1 h1) T (E1 h1'))\n     <- ({h2}{h2'} trans-soundhyp h2 Th2 h2'\n           -> trans-sound (D2 h2) T (E2 h2')).\n- : trans-sound (-oR D) (tc (t-imp T1 T2)) (=>R' E)\n     <- ({h}{h'} trans-soundhyp h T1 h'\n           -> trans-sound (D h) (tc T2) (E h')).\n- : trans-sound (-oR D) (tc (t+not T)) (notR' E)\n     <- ({h: hyp A}{h': hyp' A'} trans-soundhyp h T h'\n           -> trans-sound (D h) tc# (E h')).\n\ntrans-imp : {D: conc C}\n          idconc D (-oL (D1: true A1) (D2: hyp A2 -> conc C) H)\n          -> trans-conc Mt C' C \n          -> trans Mh A' neg (A1 -o A2)\n          -> hyp' A'\n          -> conc' Md C'\n          -> type.\n%mode trans-imp +D +Id +T +Th +H -F.\n- : trans-imp (-oL D1 D2 H) idconc/refl T (t-imp Th1 Th2) H' (=>L' E1 E2 H')\n     <- trans-sound D1 (tc Th1) E1\n     <- ({h}{h'} trans-soundhyp h Th2 h'\n           -> trans-sound (D2 h) T (E2 h')).\n- : trans-imp (-oL D1 D2 H) idconc/refl T (t+not Th) (H': hyp' (not' A')) \n     (weakR' (notL' E1 H'))\n     <- trans-sound D1 (tc Th) (E1: true' Md A').\n- : trans-imp (-oL D1 D2 H) idconc/refl tc# (t+not Th) (H': hyp' (not' A')) \n     (notL' E1 H')\n     <- trans-sound D1 (tc Th) (E1: true' Md A').\n\n- : trans-sound (-oL D1 D2 H) T F\n     <- trans-soundhyp H Th H'\n     <- trans-imp (-oL D1 D2 H) idconc/refl T Th H' F.\n- : trans-sound (circR D) (tc (t+circ T)) E\n     <- trans-sound D (tclax T) E.\n- : trans-sound (circL D H) (tclax T) (circL' E H')\n     <- trans-soundhyp H (t+circ Th) H'\n     <- ({h}{h'} trans-soundhyp h Th h'\n           -> trans-sound (D h) (tclax T) (E h')).\n\n%worlds (bl_atmpos | bl_atmneg | bl_trans-soundhyp) \n  (trans-sound _ _ _) (trans-imp _ _ _ _ _ _).\n%total (D E) (trans-imp E _ _ _ _ _) (trans-sound D _ _).\n\n%{ === Completeness === }% \n\n%{ * If <math>\\Gamma' \\vdash \\Delta</math> and <math>\\Gamma'~\\texttt{trans}~\\Gamma</math> and <math>\\Delta~\\texttt{trans}~J</math>, then <math>\\Gamma \\vdash J</math>.\n\nBy lexographic induction on the first derivation's metric and then\nthe second derivation's metric. For every left rule, we need a mutually\ninductive lemma that strips off any unnecessary shifts from the translation\nof the hypothesis; within these lemmas, the first derivation will always\nstay the same, but the derivation of the translation of the hypothesis\nwill get smaller. }%\n\ntrans-compl : {Td}{Tt}\n               conc' Td D -> trans-conc Tt D J -> conc J -> type.\n%mode trans-compl +Td +Tt +D +T -E.\n\n%abbrev trans-compl'  \n   = [d: conc' Td D][t: trans-conc Tt D J][e: conc J] \n      trans-compl Td Tt d t e.\n\n%{ ==== Shifts ==== }%\n\n- : trans-compl' D (tc (t+- T)) (upR E) \n     <- trans-compl' D (tc T) E.\n\n- : trans-compl' D (tc (t-+ T)) (downR E)\n     <- trans-compl' D (tc T) E.\n\n%{ ==== Truth ==== }%\n\n- : trans-compl' trueR' (tc t+true) 1R.\n- : trans-compl' trueR' (tc t-true) topR.\n\n%{ ==== Conjunction ==== }%\n\n- : trans-compl' (/\\R' D1 D2) (tc (t+and T1 T2)) (*R E1 E2)\n     <- trans-compl' D1 (tc T1) E1\n     <- trans-compl' D2 (tc T2) E2.\n\n- : trans-compl' (/\\R' D1 D2) (tc (t-and T1 T2)) (&R E1 E2)\n     <- trans-compl' D1 (tc T1) E1\n     <- trans-compl' D2 (tc T2) E2.\n\ntrans-andL : {TD}{Th} id TD (x Td)\n              -> (hyp' M1 -> hyp' M2 -> conc' Td D)\n              -> trans-conc Tt D J\n              -> trans Th (M1 /\\ M2) S A\n              -> (hyp A -> conc J) -> type.\n%mode trans-andL +TD +Th +Id +D +T +Th -E.\n- : trans-andL _ _ id/refl (D : hyp' M1 -> hyp' M2 -> conc' Td D')\n     (T: trans-conc Tt D' J) (t-and T1 T2) \n     ([h] (&L1 ([h1] &L2 ([h2] E h1 h2) h) h))\n     <- ({h1'}{h1} trans-complhyp h1' T1 h1\n           -> {h2'}{h2} trans-complhyp h2' T2 h2\n           -> trans-compl' (D h1' h2') T (E h1 h2)).\n- : trans-andL _ _ id/refl (D: hyp' M1 -> hyp' M2 -> conc' Td D') \n     (T: trans-conc Tt D' J) (t+and T1 T2) \n     ([h] (*L ([h1][h2] E h1 h2) h))\n     <- ({h1'}{h1} trans-complhyp h1' T1 h1\n           -> {h2'}{h2} trans-complhyp h2' T2 h2\n           -> trans-compl' (D h1' h2') T (E h1 h2)).\n- : trans-andL _ _ Id D T (t+- Th) (upL E)\n     <- trans-andL _ _ Id D T Th E.\n- : trans-andL _ _ Id D T (t-+ Th) (downL E)\n     <- trans-andL _ _ Id D T Th E.\n\n- : trans-compl' (/\\L' D H') T (E H)\n     <- trans-complhyp H' Th (H: hyp A)\n     <- trans-andL _ _ id/refl D T Th (E: hyp A -> conc D').\n\n%{ ==== Disjunction ==== }%\n\n- : trans-compl' (\\/R1' (D: true' Tt M1)) (tc (t+or T1 _)) (+R1 E)\n     <- trans-compl' D (tc T1) E.\n- : trans-compl' (\\/R2' (D: true' Tt M2)) (tc (t+or _ T2)) (+R2 E)\n     <- trans-compl' D (tc T2) E.\n\ntrans-orL : {TD}{Th} id (TD) (Td1 | Td2)\n             -> (hyp' M1 -> conc' Td1 D')\n             -> (hyp' M2 -> conc' Td2 D')\n             -> trans-conc Tt D' J\n             -> trans Th (M1 \\/ M2) S A\n             -> (hyp A -> conc J) -> type.\n%mode trans-orL +TD +Th +Id +D1 +D2 +T +Th -E.\n- : trans-orL _ _ id/refl D1 D2 T (t+or Th1 Th2) (+L ([h1] E1 h1) ([h2] E2 h2))\n     <- ({h1': hyp' M1}{h1: hyp P1} trans-complhyp h1' Th1 h1\n           -> trans-compl' (D1 h1') T (E1 h1: conc J))\n     <- ({h2': hyp' M2}{h2: hyp P2} trans-complhyp h2' Th2 h2\n           -> trans-compl' (D2 h2') T (E2 h2: conc J)).\n- : trans-orL _ _ id/refl D1 D2 T (t+- Th) (upL E)\n     <- trans-orL _ _ id/refl D1 D2 T Th E.\n- : trans-orL _ _ id/refl D1 D2 T (t-+ Th) (downL E)\n     <- trans-orL _ _ id/refl D1 D2 T Th E.\n\n- : trans-compl' (\\/L' D1 D2 H') T (E H)\n     <- trans-complhyp H' Th H\n     <- trans-orL _ _ id/refl D1 D2 T Th E.\n\n%{ ==== Implication ==== }%\n\n- : trans-compl' (=>R' (D: hyp' M1 -> true' Tt M2)) (tc (t-imp T1 T2)) (-oR E)\n     <- ({h'}{h} trans-complhyp h' T1 h\n           -> trans-compl' (D h') (tc T2) (E h)).\n\ntrans-impL : {TD}{Th} id TD (Td1 | Td2)\n              -> true' Td1 M1\n              -> (hyp' M2 -> conc' Td2 D')\n              -> trans-conc Tt D' J\n              -> trans Th (M1 => M2) S A\n              -> (hyp A -> conc J) -> type.\n%mode trans-impL +TD +Th +Id +D1 +D2 +T +Th -E.\n- : trans-impL _ _ id/refl (D1: true' Td1 M1) (D2: hyp' M2 -> conc' Td2 D')\n     (T: trans-conc Mt D' J) (t-imp T1 T2) (-oL E1 ([h] E2 h))\n     <- trans-compl' D1 (tc T1) (E1: true P)\n     <- ({h': hyp' M2}{h: hyp N}{t: trans-complhyp h' T2 h}\n           trans-compl' (D2 h') T (E2 h: conc J)).\n- : trans-impL _ _ id/refl D1 D2 T (t+- Th) (upL E)\n     <- trans-impL _ _ id/refl D1 D2 T Th E.\n- : trans-impL _ _ id/refl D1 D2 T (t-+ Th) (downL E)\n     <- trans-impL _ _ id/refl D1 D2 T Th E.\n\n- : trans-compl' (=>L' D1 D2 (H': hyp' (M1 => M2))) T (E H)\n     <- trans-complhyp H' Th (H: hyp A)\n     <- trans-impL _ _ id/refl D1 D2 T Th E.\n\n%{ ==== Negation ==== }%\n\n- : trans-compl' (notR' (D: hyp' tt' -> # _)) (tc t+false) G\n     <- ({h'}{h} trans-complhyp h' t+true h\n           -> trans-compl' (D h') tc# (E h))\n     <- cut 1 1R ([h] E h) F\n     <- invupR F G.\n\n- : trans-compl' (notR' (D: hyp' M -> # _)) (tc (t+not T)) (-oR ([h] (E h)))\n     <- ({h'}{h} trans-complhyp h' T h\n           -> trans-compl' (D h') tc# (E h)).\n\ntrans-notL : {TD}{Tt} id TD (x Td)\n              -> true' Td M\n              -> trans Tt (not' M) S A\n              -> (hyp A -> true (up 0)) -> type.\n%mode trans-notL +TD +Tt +Id +D +Th -E.\n- : trans-notL _ _ id/refl (D: true' Td M) (t+not T) (-oL E (upL 0L))\n     <- trans-compl' D (tc T) (E: true P).\n- : trans-notL _ _ id/refl D t+false 0L.\n- : trans-notL _ _ Id D (t+- T) (upL E)\n     <- trans-notL _ _ Id D T E.\n- : trans-notL _ _ Id D (t-+ T) (downL E)\n     <- trans-notL _ _ Id D T E.\n\n- : trans-compl' (notL' (D: true' Td M) (H': hyp' (not' M))) tc# (E H)\n     <- trans-complhyp H' Th (H: hyp A)\n     <- trans-notL _ _ id/refl D Th E.\n\n%{ ==== Lax modality ==== }%\n\n- : trans-compl' (circR' D) (tc (t+circ T)) (circR (laxR E))\n     <- trans-compl' D (tc T) E.\n- : trans-compl' (circR' D) (tclax T) (laxR E)\n     <- trans-compl' D (tc T) E.\n\ntrans-circL : {TD}{Th} id TD (x Td)\n               -> (hyp' M -> true' Td (circ' D'))\n               -> trans Tt D' S C\n               -> trans Th (circ' M) Sh A\n               -> (hyp A -> lax C) -> type.\n%mode trans-circL +TD +Tt +Id +D +T +Th -E. \n- : trans-circL _ _ id/refl D T (t+circ Th) (circL E)\n     <- ({h': hyp' M}{h: hyp P}{t: trans-complhyp h' Th h}\n           trans-compl' (D h') (tclax T) (E h : lax C)).\n- : trans-circL _ _ Id D T (t+- Th) (upL F)\n     <- trans-circL _ _ Id D T Th F.\n- : trans-circL _ _ Id D T (t-+ Th) (downL F)\n     <- trans-circL _ _ Id D T Th F.\n\n- : trans-compl' (circL' (D: hyp' M -> true' Td (circ' D')) H')\n     (tc (t+circ (T: trans Tt D' pos J))) (circR (E H))\n     <- trans-complhyp H' Th (H: hyp A)\n     <- trans-circL _ _ id/refl D T Th E.\n\n- : trans-compl' (circL' (D: hyp' M -> true' Td (circ' D')) H')\n     (tclax (T: trans Tt D' S J)) (E H)\n     <- trans-complhyp H' Th (H: hyp A)\n     <- trans-circL _ _ id/refl D T Th E.\n\n%{ ==== Structural Rules ==== }%\n\n%{ For translating a cut, we need to come up with a translation of a source\nlogc expression to a target logic expression; we have already established\nthis was possible when we proved <tt>can-trans</tt> to show that translation\nwas left-total. }%\n\n- : trans-compl' (cut' (Da: true' _ M) Dc) T F\n     <- can-trans M (TRa: trans _ M S A)\n     <- trans-compl' Da (tc TRa) (Ea: true A)\n     <- ({h'}{h} trans-complhyp h' TRa h\n           -> trans-compl' (Dc h') T (Ec h))\n     <- cut A Ea Ec F.\n\n%{ Due to the mismatch between\nthe lax judgment and the circle, we need three cases for translating identity. \nThe first case is the most important one and is straightforward, however: we\nare translating <math>\\Gamma', M \\vdash M</math> and need to show\n<math>\\Gamma, A_M \\vdash A_M~true</math>, \nwhere <math>M~\\texttt{trans}~A_M</math>. \n\nIdentity is a terminal rule, so we will not use induction here. \nWe know because <math>M</math> is a hypothesis that there is \na hypothesis <math>A</math> such that \n<math>M~\\texttt{trans}~A</math>, and so by the identity principle we can prove\n<math>\\Gamma, A \\vdash A~true</math>; then, <tt>trans-equiv</tt> allows\nus to prove <math>\\Gamma, A_M \\vdash A_M~true</math>, which is what we \nactually need. }%\n\n- : trans-compl' (id' (H': hyp' M)) (tc (T: trans _ M S Am)) E\n     <- trans-complhyp H' Th (H: hyp A)\n     <- identity A (D2: hyp A -> true A)\n     <- trans-equiv Th (D2 H) T (E: true Am).\n\n%{ When we are translating to a lax judgment in the target language, what we\nget out of the translation isn't exactly what we want, we need\n<math>\\Gamma \\vdash A~lax</math> but the best we can get is \n<math>\\Gamma \\vdash {\\bigcirc}P~true</math> or \n<math>\\Gamma \\vdash {\\bigcirc}{\\downarrow}N~true</math>. However, we can \nuse inversion lemmas (and lax cut, in the second case) to get what we need.\n}%\n\n- : trans-compl' (id' (H': hyp' (circ' M))) (tclax (T: trans _ M pos Pm)) F\n     <- trans-complhyp H' Th (H: hyp P)\n     <- identity P (D2: hyp P -> true P)\n     <- trans-equiv Th (D2 H) (t+circ T) (E: true (circ Pm))\n     <- invcircR E (F: lax Pm).\n- : trans-compl' (id' (H': hyp' (circ' M))) (tclax (T: trans _ M neg Nm)) G\n     <- trans-complhyp H' Th (H: hyp N)\n     <- identity N (D2: hyp N -> true N)\n     <- trans-equiv Th (D2 H) (t+circ (t-+ T)) (E: true (circ (down Nm)))\n     <- invcircR E (F: lax (down Nm))\n     <- identity _ (Id: hyp Nm -> true Nm)\n     <- lcut _ F ([h] laxR (downL ([h'] Id h') h)) (G: lax Nm).\n\n- : trans-compl' (weakR' D) _ F\n     <- trans-compl' D tc# E\n     <- cut (up 0) E ([h] upL 0L h) F.\n\n%worlds (bl_atmpos | bl_atmneg | bl_trans-complhyp) \n (trans-compl _ _ _ _ _)\n (trans-andL _ _ _ _ _ _ _)\n (trans-impL _ _ _ _ _ _ _ _)\n (trans-orL _ _ _ _ _ _ _ _)\n (trans-notL _ _ _ _ _ _)\n (trans-circL _ _ _ _ _ _ _).\n\n%total {(D1 D2 D3 D4 D5 D6) (T1 T2 T3 T4 T5 T6)}\n (trans-compl D1 T1 _ _ _)\n (trans-andL D2 T2 _ _ _ _ _)\n (trans-orL D3 T3 _ _ _ _ _ _)\n (trans-impL D4 T4 _ _ _ _ _ _)\n (trans-notL D5 T5 _ _ _ _)\n (trans-circL D6 T6 _ _ _ _ _)."
          },
          "sha1": "hc1zxgu9xz2bnxwplms73zxnj3nwk3y"
        }
      },
      {
        "title": "Let*",
        "ns": 0,
        "id": 2223,
        "redirect": {
          "@title": "Iterated Let Bindings",
          "#text": null
        },
        "revision": {
          "id": 6077,
          "timestamp": "2010-05-24T21:24:11Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "moved [[Let*]] to [[Iterated Let Bindings]]:&#32;The Let* gets into the regression tests and messes with filenames",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 35,
            "#text": "#REDIRECT [[Iterated Let Bindings]]"
          },
          "sha1": "2oduzjtl8flb5ct66rxgd08n6dvg2t1"
        }
      },
      {
        "title": "Letrec",
        "ns": 0,
        "id": 2019,
        "revision": {
          "id": 4974,
          "timestamp": "2007-10-14T01:40:37Z",
          "contributor": {
            "username": "DanielKLee",
            "id": 5
          },
          "comment": "New page: %{ An example of encoding <tt>letrec</tt>, i.e. let-binding a bundle of mutually recursive expressions }%  nat\t: type.  z\t: nat. s\t: nat -> nat.   tp\t: type.   natt\t: tp. arrow\t: tp -> tp ...",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 13048,
            "#text": "%{ An example of encoding <tt>letrec</tt>, i.e. let-binding a bundle of mutually recursive expressions }%\n\nnat\t: type.\n\nz\t: nat.\ns\t: nat -> nat. \n\ntp\t: type. \n\nnatt\t: tp.\narrow\t: tp -> tp -> tp.\n\ntplist\t: nat -> type.\n\ntplist/z\t: tplist z.\ntplist/s\t: tp -> tplist N -> tplist (s N). \n\nexp\t: type. \noexp\t: nat -> type. \nexplist\t: nat -> type. \n\n%{\noexplist N M, is a list of M expressions with N bound variables\n}%\noexplist: nat -> nat -> type. \n\n\nzero\t: exp.\nsucc\t: exp -> exp. \ncase\t: exp -> exp -> (exp -> exp) -> exp. \nlet\t: exp -> (exp -> exp) -> exp. \nletrec\t: oexplist N N -> oexp N -> exp.\nbproj\t: oexplist N N -> nat -> exp. % projecting from a bundle\nlam\t: (exp -> exp) -> exp. \napp\t: exp -> exp -> exp. \n\n\n\noexp/z\t: exp -> oexp z.\noexp/s\t: (exp -> oexp N) -> oexp (s N).\n\n\n\nexplist/z\t: explist z.\nexplist/s\t: exp -> explist N -> explist (s N).\n\n\n\noexplist/z\t: explist N -> oexplist z N.\noexplist/s\t: (exp -> oexplist N M) -> oexplist (s N) M. \n\n\n\ntplist-get\t: nat -> tplist N -> tp -> type. \n\ntplist-get/hit\t: tplist-get z (tplist/s T TL) T.\ntplist-get/miss\t: tplist-get (s N) (tplist/s T TL) T'\n\t\t   <- tplist-get N TL T'. \n\n\n\nof-exp\t\t: exp -> tp -> type. \nof-oexp\t\t: tplist N -> oexp N -> tp -> type. \nof-explist\t: explist N -> tplist N -> type.\nof-oexplist\t: tplist N -> oexplist N M -> tplist M -> type. \n\n\n\nof-exp/zero\t: of-exp zero natt.\n\nof-exp/succ\t: of-exp (succ E) natt\n\t\t   <- of-exp E natt. \n\nof-exp/case\t: of-exp (case E1 E2 E3) T\n\t\t   <- of-exp E1 natt\n\t\t   <- of-exp E2 T\n\t\t   <- ({x} of-exp x natt\n\t\t\t -> of-exp (E3 x) T).\n\nof-exp/let\t: of-exp (let E1 E2) T'\n\t\t   <- of-exp E1 T\n\t\t   <- ({x} of-exp x T\n\t\t\t -> of-exp (E2 x) T'). \n\nof-exp/letrec\t: of-exp (letrec OEL OE) T\n\t\t   <- of-oexplist TL OEL TL\n\t\t   <- of-oexp TL OE T.\n\nof-exp/bproj\t: of-exp (bproj OE N) T\n\t\t   <- of-oexplist TL OE TL\n\t\t   <- tplist-get N TL T. \n\nof-exp/lam\t: of-exp (lam E) (arrow T1 T2)\n\t\t   <- ({x} of-exp x T1\n\t\t\t -> of-exp (E x) T2).\n\nof-exp/app\t: of-exp (app E1 E2) T2\n\t\t   <- of-exp E1 (arrow T1 T2)\n\t\t   <- of-exp E2 T1. \n\n\n\nof-oexp/z\t: of-oexp tplist/z (oexp/z E) T\n\t\t   <- of-exp E T. \nof-oexp/s\t: of-oexp (tplist/s T TL) (oexp/s ([x] EL x)) T'\n\t\t   <- ({x} of-exp x T\n\t\t\t -> of-oexp TL (EL x) T').\n\n\n\nof-explist\t: explist N -> tplist N -> type. \n\nof-explist/z\t: of-explist explist/z tplist/z.\nof-explist/s\t: of-explist (explist/s E EL) (tplist/s T TL)\n\t\t   <- of-exp E T\n\t\t   <- of-explist EL TL. \n\n\n\nof-oexplist/z\t: of-oexplist tplist/z (oexplist/z EL) TL\n\t\t   <- of-explist EL TL.\nof-oexplist/s\t: of-oexplist (tplist/s T TL) (oexplist/s OEL) TL'\n\t\t   <- ({x} of-exp x T\n\t\t\t -> of-oexplist TL (OEL x) TL').\n\n\nvalue\t: exp -> type.\n\nvalue/zero\t: value zero.\n\nvalue/succ\t: value (succ E)\n\t\t   <- value E. \n\nvalue/lam\t: value (lam E).\n\n\n\nsubst-oexp\t: explist N -> oexp N -> exp -> type. \n\nsubst-oexp/z\t: subst-oexp explist/z (oexp/z E) E. \nsubst-oexp/s\t: subst-oexp (explist/s E EL) (oexp/s ([x] OE x)) E'\n\t\t   <- subst-oexp EL (OE E) E'.\n\n\nexpand-oexplist\t: nat -> oexplist M M -> oexplist N M -> explist M -> type. \n\nexpand-oexplist/z\t: expand-oexplist _ _ (oexplist/z EL) EL. \nexpand-oexplist/s\t: expand-oexplist N OEL (oexplist/s OEL') EL\n\t\t\t   <- expand-oexplist (s N) OEL (OEL' (bproj OEL N)) EL.\n\n\n\n\n\nexplist-get\t: nat -> explist N -> exp -> type. \n\nexplist-get/hit\t: explist-get z (explist/s E EL) E.\nexplist-get/miss: explist-get (s N) (explist/s E EL) E'\n\t\t   <- explist-get N EL E'.\n\n\n\nstep\t: exp -> exp -> type. \n\nstep/succ\t: step (succ E) (succ E')\n\t\t   <- step E E'.\n\nstep/case\t: step (case E1 E2 E3) (case E1' E2 E3)\n\t\t   <- step E1 E1'.\n\nstep/case-beta-1: step (case zero E2 E3) E2.\n\nstep/case-beta-2: step (case (succ E1) E2 E3) (E3 E1)\n\t\t   <- value E1. \n\nstep/let\t: step (let E1 E2) (let E1' E2)\n\t\t   <- step E1 E1'.\n\nstep/let-beta\t: step (let E1 E2) (E2 E1)\n\t\t   <- value E1. \n\nstep/letrec\t: step (letrec OEL OE) E\n\t\t   <- expand-oexplist z OEL OEL EL\n\t\t   <- subst-oexp EL OE E.\n\nstep/bproj\t: step (bproj OEL N) E\n\t\t   <- expand-oexplist z OEL OEL EL\n\t\t   <- explist-get N EL E. \n\nstep/app-1\t: step (app E1 E2) (app E1' E2)\n\t\t   <- step E1 E1'.\n\nstep/app-2\t: step (app E1 E2) (app E1 E2')\n\t\t   <- value E1\n\t\t   <- step E2 E2'. \n\nstep/app-beta\t: step (app (lam E) E2) (E E2)\n\t\t   <- value E2. \n\n\n\nnat-plus\t: nat -> nat -> nat -> type.\n\nnat-plus/z\t: nat-plus z N N.\nnat-plus/s\t: nat-plus (s N1) N2 (s N3)\n\t\t   <- nat-plus N1 N2 N3. \n\n\n\nnat-plus-move-s\t: nat-plus (s N1) N2 N3\n\t\t   -> nat-plus N1 (s N2) N3\n\t\t   -> type. \n%mode nat-plus-move-s +D1 -D2.\n\n-\t: nat-plus-move-s (nat-plus/s nat-plus/z) nat-plus/z.\n\n-\t: nat-plus-move-s (nat-plus/s D1) (nat-plus/s D2)\n\t   <- nat-plus-move-s D1 D2.\n\n%worlds () (nat-plus-move-s _ _).\n%total (D1) (nat-plus-move-s D1 _). \n\n\n\ncan-expand-oexplist\t: {N} {OEL : oexplist NN NN} \n\t\t\t   {OEL' : oexplist N NN}\n\t\t\t   nat-plus N N' NN\n\t\t\t   -> expand-oexplist N' OEL OEL' EL\n\t\t\t   -> type. \n%mode can-expand-oexplist +D1 +D2 +D3 +D4 -D5.\n\n-\t: can-expand-oexplist z OEL (oexplist/z EL) nat-plus/z expand-oexplist/z.\n\n-\t: can-expand-oexplist (s N) _ _ NP (expand-oexplist/s DEO)\n\t   <- nat-plus-move-s NP NP'\n\t   <- can-expand-oexplist N _ _ NP' DEO.\n\n%worlds () (can-expand-oexplist _ _ _ _ _).\n%total (D1) (can-expand-oexplist D1 _ _ _ _).\n\n\n\nnat-plus-z\t: {N}\n\t\t   nat-plus N z N\n\t\t   -> type. \n%mode nat-plus-z +D1 -D2.\n\n-\t: nat-plus-z _ nat-plus/z.\n\n-\t: nat-plus-z _ (nat-plus/s D1)\n\t   <- nat-plus-z _ D1.\n\n%worlds () (nat-plus-z _ _).\n%total (D1) (nat-plus-z D1 _).\n\n\n\nnotstuck\t: exp -> type.\n\nnotstuck/value\t: notstuck E\n\t\t   <- value E. \nnotstuck/step\t: notstuck E\n\t\t   <- step E E'. \n\n\n\ncan-subst-oexp\t: {EL : explist N}\n\t\t   {OE : oexp N}\n\t\t   subst-oexp EL OE E\n\t\t   -> type. \n%mode can-subst-oexp +D1 +D2 -D3.\n\n-\t: can-subst-oexp _ _ subst-oexp/z.\n\n-\t: can-subst-oexp (explist/s E EL) _ (subst-oexp/s D1)\n\t   <- can-subst-oexp EL _ D1. \n\n%worlds () (can-subst-oexp _ _ _).\n%total (D1) (can-subst-oexp D1 _ _).\n\n\n\n\n\n\ncan-explist-get\t: {EL : explist N'}\n\t\t   tplist-get N (TL : tplist N') T\n\t\t   -> explist-get N EL E\n\t\t   -> type.\n%mode can-explist-get +D1 +D2 -D3.\n\n-\t: can-explist-get _ tplist-get/hit \n\t   explist-get/hit.\n\n-\t: can-explist-get _ (tplist-get/miss D2) \n\t   (explist-get/miss D')\n\t   <- can-explist-get _ D2 D'.\n\n%worlds () (can-explist-get _ _ _).\n%total (D2) (can-explist-get _ D2 _). \n\n\n\nprogress-case\t: {E1}{E2}\n\t\t   of-exp E natt\n\t\t   -> notstuck E \n\t\t   -> notstuck (case E E1 E2)\n\t\t   -> type. \n%mode progress-case +D1 +D2 +D3 +D4 -D5.\n\n-\t: progress-case _ _ _ (notstuck/step S)\n\t   (notstuck/step (step/case S)).\n\n-\t: progress-case _ _ of-exp/zero (notstuck/value _)\n\t   (notstuck/step step/case-beta-1).\n\n-\t: progress-case _ _ (of-exp/succ _) (notstuck/value (value/succ DV))\n\t   (notstuck/step (step/case-beta-2 DV)).\n\n%worlds () (progress-case _ _ _ _ _). \n%total {} (progress-case _ _ _ _ _).\n\n\n\nprogress-succ\t: notstuck E1\n\t\t   -> notstuck (succ E1)\n\t\t   -> type. \n%mode progress-succ +D1 -D2.\n\n-\t: progress-succ (notstuck/step DS)\n\t   (notstuck/step (step/succ DS)).\n\n-\t: progress-succ (notstuck/value DV1)\n\t   (notstuck/value (value/succ DV1)).\n\n%worlds () (progress-succ _ _).\n%total {} (progress-succ _ _).\n\n\n\nprogress-app\t: of-exp E1 (arrow T1 T2)\n\t\t   -> of-exp E2 T1\n\t\t   -> notstuck E1\n\t\t   -> notstuck E2\n\t\t   -> notstuck (app E1 E2)\n\t\t   -> type. \n%mode progress-app +D1 +D2 +D3 +D4 -D5.\n\n-\t: progress-app _ _ (notstuck/step DS) _\n\t   (notstuck/step (step/app-1 DS)).\n\n-\t: progress-app _ _ (notstuck/value V) (notstuck/step DS)\n\t   (notstuck/step (step/app-2 DS V)).\n\n-\t: progress-app (of-exp/lam DM) D2 (notstuck/value value/lam)\n\t   (notstuck/value DV) (notstuck/step (step/app-beta DV)).\n%worlds () (progress-app _ _ _ _ _).\n%total {} (progress-app _ _ _ _ _).\n\n\n\nprogress-let\t: {E2}\n\t\t   notstuck E1\n\t\t   -> notstuck (let E1 E2)\n\t\t   -> type. \n%mode progress-let +D1 +D2 -D3.\n\n-\t: progress-let _ (notstuck/step S) (notstuck/step (step/let S)).\n\n-\t: progress-let _ (notstuck/value V) (notstuck/step (step/let-beta V)).\n\n%worlds () (progress-let _ _ _).\n%total {} (progress-let _ _ _). \n\n\n\nprogress\t: of-exp E T\n\t\t   -> notstuck E\n\t\t   -> type.\n%mode progress +D1 -D2.\n\n-\t: progress (of-exp/lam _) (notstuck/value value/lam).\n\n-\t: progress (of-exp/app D2 D1) NS3\n\t   <- progress D1 NS1\n\t   <- progress D2 NS2\n\t   <- progress-app D1 D2 NS1 NS2 NS3.\n\n-\t: progress of-exp/zero (notstuck/value value/zero).\n\n-\t: progress (of-exp/succ D1) NS\n\t   <- progress D1 NS1\n\t   <- progress-succ NS1 NS.\n\n-\t: progress (of-exp/case _ _ D1) NS\n\t   <- progress D1 NS1\n\t   <- progress-case _ _ D1 NS1 NS.\n\n-\t: progress (of-exp/let _ D1) NS\n\t   <- progress D1 NS1\n\t   <- progress-let _ NS1 NS.\n\n-\t: progress (of-exp/letrec D2 D1)\n\t   (notstuck/step (step/letrec DS DX))\n\t   <- nat-plus-z _ DNP\n\t   <- can-expand-oexplist _ _ _ DNP DX\n\t   <- can-subst-oexp _ _ DS.\n\n-\t: progress (of-exp/bproj D2 D1)\n\t   (notstuck/step (step/bproj DS DX))\n\t   <- nat-plus-z _ DNP\n\t   <- can-expand-oexplist _ _ _ DNP DX\n\t   <- can-explist-get _ D2 DS.\n\n%worlds () (progress _ _).\n%total (D1) (progress D1 _).\n\n\n\ntplist-prefix\t: nat -> tplist N -> tplist N' -> type. \n\ntplist-prefix/z\t: tplist-prefix z TL TL.\ntplist-prefix/s\t: tplist-prefix (s N) (tplist/s T TL) TL'\n\t\t   <- tplist-prefix N TL TL'.\n\n\n\ntplist-prefix-get\t: tplist-prefix N TL'' (tplist/s T TL')\n\t\t\t   -> tplist-get N TL'' T\n\t\t\t   -> type.\n%mode tplist-prefix-get +D1 -D2.\n\n-\t: tplist-prefix-get tplist-prefix/z tplist-get/hit.\n\n-\t: tplist-prefix-get (tplist-prefix/s D1) (tplist-get/miss D2)\n\t   <- tplist-prefix-get D1 D2.\n\n%worlds () (tplist-prefix-get _ _). \n%total (D1) (tplist-prefix-get D1 _). \n\n\n\ntplist-prefix-s\t: tplist-prefix N TL (tplist/s T TL')\n\t\t   -> tplist-prefix (s N) TL TL'\n\t\t   -> type.\n%mode tplist-prefix-s +D1 -D2.\n\n-\t: tplist-prefix-s tplist-prefix/z (tplist-prefix/s tplist-prefix/z). \n\n-\t: tplist-prefix-s (tplist-prefix/s D1) (tplist-prefix/s D2)\n\t   <- tplist-prefix-s D1 D2.\n\n%worlds () (tplist-prefix-s _ _).\n%total (D1) (tplist-prefix-s D1 _).\n\n\n\npreservation-expand-oexplist\t: tplist-prefix N' TL TL'\n\t\t\t\t   -> of-oexplist TL (OEL : oexplist M M) \n\t\t\t\t      (TL : tplist M)\n\t\t\t\t   -> of-oexplist TL' OEL' TL\n\t\t\t\t   -> expand-oexplist N' OEL OEL' EL\n\t\t\t\t   -> of-explist EL TL\n\t\t\t\t   -> type. \n%mode preservation-expand-oexplist +D1 +D2 +D3 +D4 -D5.\n\n-\t: preservation-expand-oexplist _\n\t   DOE (of-oexplist/z DEL) expand-oexplist/z \n\t   DEL. \n\n-\t: preservation-expand-oexplist \n\t   DO\n\t   DOE\n\t   (of-oexplist/s DOE')\n\t   (expand-oexplist/s DOX)\n\t   DEL\n\t   <- tplist-prefix-s DO DO'\n\t   <- tplist-prefix-get DO DG\n\t   <- preservation-expand-oexplist DO' DOE \n\t      (DOE' _ (of-exp/bproj DG DOE))\n\t      DOX DEL. \n\n%worlds () (preservation-expand-oexplist _ _ _ _ _).\n%total (D1) (preservation-expand-oexplist  _ _ _ D1 _).\n\n\n\npreservation-subst-oexp\t: of-explist EL TL\n\t\t\t   -> of-oexp TL OE T\n\t\t\t   -> subst-oexp EL OE E\n\t\t\t   -> of-exp E T\n\t\t\t   -> type.\n%mode preservation-subst-oexp +D1 +D2 +D3 -D4.\n\n-\t: preservation-subst-oexp _ (of-oexp/z D1) subst-oexp/z D1.\n\n-\t: preservation-subst-oexp (of-explist/s D1 D) (of-oexp/s D2)\n\t   (subst-oexp/s D3) D4\n\t   <- preservation-subst-oexp D1 (D2 _ D) D3 D4.\n\n%worlds () (preservation-subst-oexp _ _ _ _).\n%total (D1) (preservation-subst-oexp _ _ D1 _).\n\n\n\n\npreservation-get\t: of-explist EL TL\n\t\t\t   -> explist-get M EL E\n\t\t\t   -> tplist-get M TL T\n\t\t\t   -> of-exp E T\n\t\t\t   -> type.\n%mode preservation-get +D1 +D2 +D3 -D4.\n\n-\t: preservation-get (of-explist/s _ D) explist-get/hit tplist-get/hit D.\n\n-\t: preservation-get (of-explist/s DL _) (explist-get/miss D') \n\t   (tplist-get/miss D'') D\n\t   <- preservation-get DL D' D'' D.\n\n%worlds () (preservation-get _ _ _ _).\n%total (D1) (preservation-get _ _ D1 _).\n\n\n\npreservation\t: of-exp E T\n\t\t   -> step E E'\n\t\t   -> of-exp E' T\n\t\t   -> type.\n%mode preservation +D1 +D2 -D3.\n\n-\t: preservation (of-exp/app D2 D1) (step/app-1 DS)\n\t   (of-exp/app D2 D1')\n\t   <- preservation D1 DS D1'.\n\n-\t: preservation (of-exp/app D2 D1) (step/app-2 DS V)\n\t   (of-exp/app D2' D1)\n\t   <- preservation D2 DS D2'.\n\n-\t: preservation (of-exp/app D2 (of-exp/lam D1)) (step/app-beta V)\n\t   (D1 _ D2).\n\n\n-\t: preservation (of-exp/succ D1) (step/succ DS)\n\t   (of-exp/succ D1')\n\t   <- preservation D1 DS D1'.\n\n-\t: preservation (of-exp/case D3 D2 D1) (step/case DS)\n\t   (of-exp/case D3 D2 D1')\n\t   <- preservation D1 DS D1'.\n\n-\t: preservation (of-exp/case D3 D2 _) step/case-beta-1\n\t   D2.\n\n-\t: preservation (of-exp/case D3 _ (of-exp/succ D1)) (step/case-beta-2 _)\n\t   (D3 _ D1).\n\n-\t: preservation (of-exp/let D2 D1) (step/let DS)\n\t   (of-exp/let D2 D1')\n\t   <- preservation D1 DS D1'.\n\n-\t: preservation (of-exp/let D2 D1) (step/let-beta _)\n\t   (D2 _ D1).\n\n-\t: preservation (of-exp/letrec D2 D1) (step/letrec DOS DOX)\n\t   D\n\t   <- preservation-expand-oexplist tplist-prefix/z D1 D1 DOX D1'\n\t   <- preservation-subst-oexp D1' D2 DOS D.\n\n-\t: preservation (of-exp/bproj D2 D1) (step/bproj DOS DOX)\n\t   D\n\t   <- preservation-expand-oexplist tplist-prefix/z D1 D1 DOX D1'\n\t   <- preservation-get D1' DOS D2 D.\n\n%worlds () (preservation _ _ _).\n%total (D1) (preservation _ D1 _).\n\n%{ \nTODO: commentary.\n\n{{stub}}\n}%"
          },
          "sha1": "t80wf7ra6qnvlj82fp5cwf4fh51rwpa"
        }
      },
      {
        "title": "Lexicographical orderings with density",
        "ns": 0,
        "id": 1453,
        "revision": {
          "id": 4400,
          "parentid": 4192,
          "timestamp": "2007-03-20T07:31:59Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "minor": null,
          "comment": "case study",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 5104,
            "#text": "This is a fairly advanced example, but it illustrates a number of useful things. First, it adheres very closely to the [[Twelf style guide]]. Second, it has proofs of <tt>nat-less-trans</tt> and <tt>nat-less-immsucc</tt> which you usually need to get any mileage out of the natural numbers. Third, it is an example of how to prove <tt>uninhabited/void/false/absurd</tt> in order to user [[reasoning from false]]. \n\nThis is a lexicographical ordering with the property that it has a less-than relation that is irreflexive and transitive, like the natural numbers. In addition, it has the additional property that the ordering is \"dense\" in that there exists an index between any two indices.  This ordering should be isomorphic to the non-negative rationals. Density is admissible in this ordering without having to deal with multiplication, as would be necessary in a more obvious encoding of the non-negative rationals.\n\n<twelf check=\"true\">\n\n% natural numbers\n\nnat : type.\n\nnat/z : nat.\nnat/s : nat -> nat.\n\n\n\n% a list of natural numbers. we will use it as a lexicographical ordering\n\nlex : nat -> type.\n\nlex/z : lex nat/z.\nlex/s : nat -> lex N -> lex (nat/s N).\n\n\n\n% the less-than relation on natural numbers\n\nnat-less : nat -> nat -> type.\n\nnat-less/z : nat-less nat/z (nat/s N).\n\nnat-less/s : nat-less (nat/s N1) (nat/s N2)\n              <- nat-less N1 N2.\n\n\n\n% the less-than relation on our lexicographical ordering. \n\nlex-less : lex _ -> lex _ -> type.\n\nlex-less/z : lex-less lex/z (lex/s _ _).\n\nlex-less/eq     : lex-less (lex/s N1 NL1) (lex/s N1 NL2)\n                   <- lex-less NL1 NL2.\n\nlex-less/gt     : lex-less (lex/s N1 _) (lex/s N2 _)\n                           <- nat-less N2 N1.\n\n\n\n\nnat-less-trans  : nat-less N1 N2\n                   -> nat-less N2 N3\n                   -> nat-less N1 N3\n                   -> type.\n%mode nat-less-trans  +D1 +D2 -D3.\n\n-       : nat-less-trans nat-less/z _ nat-less/z.\n\n-       : nat-less-trans (nat-less/s N1) (nat-less/s N2) (nat-less/s N3)\n           <- nat-less-trans N1 N2 N3.\n\n%worlds () (nat-less-trans _ _ _).\n%total {D1} (nat-less-trans D1 _ _).\n\n\n\nnat-less-immsucc\t: {N}\n                           nat-less N (nat/s N)\n                           -> type.\n%mode nat-less-immsucc +D1 -D2.\n\n-       : nat-less-immsucc nat/z nat-less/z.\n\n-       : nat-less-immsucc (nat/s N1) (nat-less/s NL)\n           <- nat-less-immsucc N1 NL.\n\n%worlds () (nat-less-immsucc _ _).\n%total {D1} (nat-less-immsucc D1 _).\n\n\n\n\nlex-less-trans  : lex-less NL1 NL2\n\t\t   -> lex-less NL2 NL3\n\t\t   -> lex-less NL1 NL3\n\t\t   -> type.\n%mode lex-less-trans +D1 +D2 -D3.\n\n-       : lex-less-trans lex-less/z _ lex-less/z.\n\n-       : lex-less-trans (lex-less/eq NL1)  (lex-less/eq NL2) (lex-less/eq NL3)\n           <- lex-less-trans NL1 NL2 NL3.\n\n-       : lex-less-trans (lex-less/gt NL1) (lex-less/gt NL2) (lex-less/gt NL3)\n           <- nat-less-trans NL2 NL1 NL3.\n\n-       : lex-less-trans (lex-less/gt NL) (lex-less/eq _) (lex-less/gt NL).\n\n-       : lex-less-trans (lex-less/eq _) (lex-less/gt NL) (lex-less/gt NL).\n\n%worlds () (lex-less-trans _ _ _).\n%total {D1} (lex-less-trans D1 _ _).\n\n\n\n% for any lexicographical index LL, there exists an index LL' that is greater\n\nlex-less-succ   : {LL}\n                   lex-less LL LL'\n                   -> type.\n%mode lex-less-succ +D1 -D2.\n\n-       : lex-less-succ lex/z (lex-less/z : lex-less _ (lex/s nat/z lex/z)).\n\n-       : lex-less-succ (lex/s N NL) (lex-less/eq NLL)\n           <- lex-less-succ NL NLL.\n\n%worlds () (lex-less-succ _ _).\n%total {N} (lex-less-succ N _).\n\n\n\nlex-less-dense\t: lex-less N1 N3\n\t\t   -> lex-less N1 N2\n\t\t   -> lex-less N2 N3\n\t\t   -> type.\n%mode lex-less-dense +D1 -D2 -D3.\n\n-       : lex-less-dense lex-less/z lex-less/z \n           (lex-less/gt NL : lex-less (lex/s (nat/s N) lex/z) _ )\n           <- nat-less-immsucc N NL. \n\n-       : lex-less-dense (lex-less/eq LL) (lex-less/eq LL1) (lex-less/eq LL2)\n           <- lex-less-dense LL LL1 LL2.\n\n-       : lex-less-dense (lex-less/gt NL) (lex-less/eq LL) (lex-less/gt NL)\n           <- lex-less-succ _ LL.\n\n%worlds () (lex-less-dense _ _ _).\n%total {D1} (lex-less-dense D1 _ _).\n\n\n\nuninhabited : type.\n%freeze uninhabited.\n\n\n\n\nnat-less-refl-uninhabited       : nat-less N1 N1\n                                   -> uninhabited\n                                   -> type.\n%mode nat-less-refl-uninhabited +D1 -D2.\n\n-       : nat-less-refl-uninhabited (nat-less/s NL) DU\n           <- nat-less-refl-uninhabited NL DU.\n\n%worlds () (nat-less-refl-uninhabited _ _).\n%total {D1} (nat-less-refl-uninhabited D1 _).\n\n\n\nlex-less-refl-uninhabited       : lex-less LL LL\n                                   -> uninhabited\n                                   -> type.\n%mode lex-less-refl-uninhabited +D1 -D2.\n\n-       : lex-less-refl-uninhabited (lex-less/eq LL) DU\n           <- lex-less-refl-uninhabited LL DU.\n\n-       : lex-less-refl-uninhabited (lex-less/gt DL) DU\n           <- nat-less-refl-uninhabited DL DU.\n\n%worlds () (lex-less-refl-uninhabited _ _).\n%total {DU} (lex-less-refl-uninhabited DU _).\n</twelf>\n\n[[Category:Twelf code]]\n\n{{case study}}"
          },
          "sha1": "a8nneb8ywo6toamrejlw3ridhcab7xn"
        }
      },
      {
        "title": "Lily",
        "ns": 0,
        "id": 1669,
        "revision": {
          "id": 4403,
          "parentid": 2949,
          "timestamp": "2007-03-20T07:34:49Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "minor": null,
          "comment": "case study",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 138061,
            "#text": "This [[case studies|case study]] concerns the metatheory of the [[linear logic|linear]] Lily language. \n\nIt is incomplete; ask [[User:varming]] for updates.\n\n\nIn this example I will show examples of the following:\n# Encoding of a linear type system.\n# Definition of an abstract machine using evaluation frames.\n# Correspondence between the big step semantics and the machine.\n# Complete induction on the height of a derivation.\n\n==Lily - the language==\n===Grammar===\nI define the grammar for the types\n<twelf>\n% Lily meta theory\n% By Carsten Varming 2006\ntp : type. %name tp Tp.\n\nfunc : tp -> tp -> tp.\nall : (tp -> tp) -> tp.\nbang : tp -> tp.\ni : tp.\ntensor : tp -> tp -> tp.\n%freeze tp.\n</twelf>\nand the grammar for the terms and values\n<twelf>\nterm : type. %name term M.\n\nlam : tp -> (term -> term) -> term.\napp : term -> term -> term.\ntlam : (tp -> term) -> term.\ntapp : term -> tp -> term.\nthunk : tp -> (term -> term) -> term.\nletb : term -> (term -> term) -> term.\nunit : term.\nletu : term -> term -> term.\ntens : term -> term -> term.\nlett : term -> (term -> term -> term) -> term.\n%freeze term.\n\nvalue : term -> type.\n%mode value +V.\n\nval_lam : value (lam _ _).\nval_tlam : value (tlam _).\nval_thunk : value (thunk _ _).\nval_unit : value unit.\nval_tens : value (tens _ _).\n\n%worlds () (value _).\n%terminates {} (value _).\n%freeze value.\n</twelf>\nNext I define the call-by-name big step evaluation relation\n<twelf>\n\\n/ : term -> term -> type.\n%mode \\n/ +M -V.\n%name \\n/ EV.\n%infix none 500 \\n/.\n\nev_lam : lam T M  \\n/ lam T M.\nev_tlam : tlam M  \\n/ tlam M.\nev_thunk : thunk T M  \\n/ thunk T M.\nev_unit : unit \\n/ unit.\nev_tens : tens M N \\n/ tens M N.\nev_app : app M N \\n/ V\n       <- M \\n/ lam _ M'\n       <- M' N \\n/ V.\nev_tapp : tapp M T \\n/ V\n       <- M \\n/ tlam M'\n       <- M' T \\n/ V.\nev_letb : letb M N \\n/ V\n       <- M \\n/ thunk T M'\n       <- N (letb (thunk T M') M') \\n/ V.\nev_letu : letu M N \\n/ V\n       <- M \\n/ unit\n       <- N \\n/ V.\nev_lett : lett M N \\n/ V\n       <- M \\n/ tens M' M''\n       <- (N M' M'') \\n/ V.\n%worlds () (\\n/ _ _).\n%covers \\n/ +M -V.\n%freeze \\n/.\n\n\\/ : term -> type.\n%postfix 500 \\/.\n%mode \\/ +M.\nterminate : M \\/\n         <- M \\n/ V.\n%freeze \\/.\n</twelf>\nI also have an strict (call-by-value) evaluation relation for Lily.\n<twelf>\n\\s/ : term -> term -> type.\n%mode \\s/ +M -V.\n%name \\s/ EV.\n%infix none 500 \\s/.\n\nevs_lam : lam T M  \\s/ lam T M.\nevs_tlam : tlam M  \\s/ tlam M.\nevs_thunk : thunk T M  \\s/ thunk T M.\nevs_unit : unit \\s/ unit.\nevs_tens : tens M N \\s/ tens M N.\nevs_app : app M N \\s/ V\n       <- M \\s/ lam _ M'\n       <- N \\s/ V'\n       <- M' V' \\s/ V.\nevs_tapp : tapp M T \\s/ V\n       <- M \\s/ tlam M'\n       <- M' T \\s/ V.\nevs_letb : letb M N \\s/ V\n       <- M \\s/ thunk T M'\n       <- N (letb (thunk T M') M') \\s/ V.\nevs_letu : letu M N \\s/ V\n       <- M \\s/ unit\n       <- N \\s/ V.\nevs_lett : lett M N \\s/ V\n       <- M \\s/ tens M' M''\n       <- (N M' M'') \\s/ V.\n%worlds () (\\s/ _ _).\n%covers \\s/ +M -V.\n%freeze \\s/.\n</twelf>\n\n===Value soundness===\nBy now I can prove value soundness for the two evaluation relations.\n<twelf>\nvalue_soundness : M \\n/ V -> value V -> type.\n%mode value_soundness +D -V.\n\nvs_lam : value_soundness ev_lam val_lam.\nvs_tlam : value_soundness ev_tlam val_tlam.\nvs_thunk : value_soundness ev_thunk val_thunk.\nvs_unit : value_soundness ev_unit val_unit.\nvs_tens : value_soundness ev_tens val_tens.\nvs_app : value_soundness (ev_app D' _) V\n            <- value_soundness D' V.\nvs_tapp : value_soundness (ev_tapp D' _) V\n            <- value_soundness D' V.\nvs_letb : value_soundness (ev_letb D' _) V\n            <- value_soundness D' V.\nvs_letu : value_soundness (ev_letu D' _) V\n            <- value_soundness D' V.\nvs_lett : value_soundness (ev_lett D' _) V\n            <- value_soundness D' V.\n\n%worlds () (value_soundness _ _).\n%freeze value_soundness.\n%total D (value_soundness D _).\n\nvalue_soundness_s : M \\s/ V -> value V -> type.\n%mode value_soundness_s +D -V.\n\nvs_lam : value_soundness_s evs_lam val_lam.\nvs_tlam : value_soundness_s evs_tlam val_tlam.\nvs_thunk : value_soundness_s evs_thunk val_thunk.\nvs_unit : value_soundness_s evs_unit val_unit.\nvs_tens : value_soundness_s evs_tens val_tens.\nvs_app : value_soundness_s (evs_app D' _ _) V\n            <- value_soundness_s D' V.\nvs_tapp : value_soundness_s (evs_tapp D' _) V\n            <- value_soundness_s D' V.\nvs_letb : value_soundness_s (evs_letb D' _) V\n            <- value_soundness_s D' V.\nvs_letu : value_soundness_s (evs_letu D' _) V\n            <- value_soundness_s D' V.\nvs_lett : value_soundness_s (evs_lett D' _) V\n            <- value_soundness_s D' V.\n\n%worlds () (value_soundness_s _ _).\n%freeze value_soundness_s.\n%total D (value_soundness_s D _).\n</twelf>\nIt is also neat to know that values evaluate to themselves.\n<twelf>\nselfeval : value V -> (V \\n/ V) -> type.\n%mode selfeval +V -E.\n\nselfeval_lam : selfeval val_lam ev_lam.\nselfeval_tlam : selfeval val_tlam ev_tlam.\nselfeval_thunk : selfeval val_thunk ev_thunk.\nselfeval_tens : selfeval val_tens ev_tens.\nselfeval_unit : selfeval val_unit ev_unit.\n\n%worlds () (selfeval _ _).\n%freeze selfeval.\n%total V (selfeval V _).\n\nselfevals : value V -> (V \\s/ V) -> type.\n%mode selfevals +V -E.\n\nselfevals_lam : selfevals val_lam evs_lam.\nselfevals_tlam : selfevals val_tlam evs_tlam.\nselfevals_thunk : selfevals val_thunk evs_thunk.\nselfevals_tens : selfevals val_tens evs_tens.\nselfevals_unit : selfevals val_unit evs_unit.\n\n%worlds () (selfevals _ _).\n%freeze selfevals.\n%total V (selfevals V _).\n</twelf>\n\n===Equalities===\nI need some equalities on types and terms:\n<twelf>\neqt : tp -> tp -> type.\n%mode eqt +T -T'.\neqt_ref : eqt T T.\n%worlds () (eqt _ _).\n%freeze eqt.\n%total D (eqt D _).\n\neqt_symm : eqt T T' -> eqt T' T -> type.\n%mode eqt_symm +Q -Q'.\neqt_symm_rule : eqt_symm eqt_ref eqt_ref.\n%worlds () (eqt_symm _ _).\n%freeze eqt_symm.\n%total {} (eqt_symm _ _).\n\neqt_ctx : eqt T T' -> {C : tp -> tp} eqt (C T) (C T') -> type.\n%mode eqt_ctx +E +C -E'.\neqt_ctx_ref : eqt_ctx eqt_ref _ eqt_ref.\n%worlds () (eqt_ctx _ _ _).\n%freeze eqt_ctx.\n%total D (eqt_ctx D _ _).\n\neqt_ctx2 : eqt T T' -> eqt T2 T2' -> {C : tp -> tp -> tp} eqt (C T T2) (C T' T2') -> type.\n%mode eqt_ctx2 +E +E' +C -E''.\neqt_ctx2_ref : eqt_ctx2 eqt_ref eqt_ref _ eqt_ref.\n%worlds () (eqt_ctx2 _ _ _ _).\n%freeze eqt_ctx2.\n%total {} (eqt_ctx2 _ _ _ _).\n\neq : term -> term -> type.\n%mode eq +M -M'.\neq_ref : eq M M.\n%worlds () (eq _ _).\n%freeze eq.\n%total D (eq D _).\n\neq_ctx : eq M M' -> {C : term -> term} eq (C M) (C M') -> type.\n%mode eq_ctx +Q +C -Q'.\neq_ctx_ref : eq_ctx eq_ref _ eq_ref.\n%worlds () (eq_ctx _ _ _).\n%freeze eq_ctx.\n%total D (eq_ctx D _ _).\n\neq_ctx2 : eq M M' -> eq M2 M2' -> {C : term -> term -> term} eq (C M M2) (C M' M2') -> type.\n%mode eq_ctx2 +Q +Q2 +C -Q'.\neq_ctx2_ref : eq_ctx2 eq_ref eq_ref _ eq_ref.\n%worlds () (eq_ctx2 _ _ _ _).\n%freeze eq_ctx2.\n%total D (eq_ctx2 D _ _ _).\n\neq_eval : eq M M' -> (M \\n/ V) -> (M' \\n/ V) -> type.\n%mode eq_eval +Q +E -E'.\neq_eval_rule : eq_eval eq_ref E E.\n%worlds () (eq_eval _ _ _).\n%freeze eq_eval.\n%total D (eq_eval D _ _).\n\neq_eval2 : eq V V' -> (M \\n/ V) -> (M \\n/ V') -> type.\n%mode eq_eval2 +Q +E -E'.\neq_eval2_rule : eq_eval2 eq_ref E E.\n%worlds () (eq_eval2 _ _ _).\n%freeze eq_eval2.\n%total D (eq_eval2 D _ _).\n\neq_res_s : eq V V' -> M \\s/ V -> M \\s/ V' -> type.\n%mode eq_res_s +Q +E -E.\neq_res_s_rile : eq_res_s eq_ref E E.\n%worlds () (eq_res_s _ _ _).\n%freeze eq_res_s.\n%total {} (eq_res_s _ _ _).\n\neq_evaluations : (M \\n/ V) -> (M' \\n/ V') -> type.\n%mode eq_evaluations +EV -EV'.\neq_evaluations_ref : eq_evaluations E E.\n%worlds () (eq_evaluations _ _).\n%freeze eq_evaluations.\n%total D (eq_evaluations D _).\n\neq_tens : eq (tens M1 M2) (tens M1' M2') -> eq M1 M1' -> eq M2 M2' -> type.\n%mode eq_tens +EQ1 -EQ2 -EQ3.\neq_tens_rule : eq_tens eq_ref eq_ref eq_ref.\n%worlds () (eq_tens _ _ _).\n%freeze eq_tens.\n%total D (eq_tens D _ _).\n\neq_thunk : eq (thunk T E) (thunk T' E') -> eq (letb (thunk T E) E) (letb (thunk T' E') E') -> type.\n%mode eq_thunk +EQ -EQ'.\neq_thunk_rule : eq_thunk eq_ref eq_ref.\n%worlds () (eq_thunk _ _).\n%freeze eq_thunk.\n%total D (eq_thunk D _).\n\neq_lam : eq (lam T E) (lam T' E') -> eq X X' -> eq (E X) (E' X') -> type.\n%mode eq_lam +E +E' -E''.\neq_lam_rule : eq_lam eq_ref eq_ref eq_ref.\n%worlds () (eq_lam _ _ _).\n%freeze eq_lam.\n%total D (eq_lam D _ _).\n\neq_tlam : eq (tlam E) (tlam E') -> eqt X X' -> eq (E X) (E' X') -> type.\n%mode eq_tlam +E +E' -E''.\neq_tlam_rule : eq_tlam eq_ref eqt_ref eq_ref.\n%worlds () (eq_tlam _ _ _).\n%freeze eq_tlam.\n%total D (eq_tlam D _ _).\n\neq_sym : eq A B -> eq B A -> type.\n%mode eq_sym +E -Q.\neq_sym_rule : eq_sym eq_ref eq_ref.\n%worlds () (eq_sym _ _).\n%freeze eq_sym.\n%total D (eq_sym D _).\n</twelf>\n\n===Determinism===\nEvaluation is deterministic. \n<twelf>\neval_determ : M \\n/ V -> M \\n/ V' -> eq V V' -> type.\n%mode eval_determ +E +E' -Q.\n\neval_determ_unit : eval_determ ev_unit ev_unit eq_ref.\neval_determ_tens : eval_determ ev_tens ev_tens eq_ref.\neval_determ_tlam : eval_determ ev_tlam ev_tlam eq_ref.\neval_determ_lam : eval_determ ev_lam ev_lam eq_ref.\neval_determ_thunk : eval_determ ev_thunk ev_thunk eq_ref.\neval_determ_app : eval_determ ((ev_app EV2 EV1) : (app M1 M2) \\n/ V)\n                              ((ev_app EV2' EV1') : (app M1 M2 \\n/ V')) Q\n         <- eval_determ EV1 EV1' Q1\n         <- eq_lam Q1 (eq_ref : eq M2 M2) Q3\n         <- eq_sym Q3 Q4\n         <- eq_eval Q4 EV2' EV2s\n         <- eval_determ EV2 EV2s Q.\n\neval_determ_tapp : eval_determ ((ev_tapp EV2 EV1) : (tapp M1 T2) \\n/ V)\n                               ((ev_tapp EV2' EV1') : (tapp M1 T2 \\n/ V')) Q\n         <- eval_determ EV1 EV1' Q1\n         <- eq_tlam Q1 (eqt_ref : eqt T2 T2) Q3\n         <- eq_sym Q3 Q4\n         <- eq_eval Q4 EV2' EV2s\n         <- eval_determ EV2 EV2s Q.\n\neval_determ_letb : eval_determ ((ev_letb EV2 EV1) : (letb M1 M2) \\n/ V)\n                               ((ev_letb EV2' EV1') : (letb M1 M2 \\n/ V')) Q\n         <- eval_determ EV1 EV1' Q1\n         <- eq_thunk Q1 Q2\n         <- eq_ctx Q2 M2 Q3\n         <- eq_sym Q3 Q4\n         <- eq_eval Q4 EV2' EV2s\n         <- eval_determ EV2 EV2s Q.\n\neval_determ_letu : eval_determ ((ev_letu EV2 EV1) : (letu M1 M2) \\n/ V)\n                               ((ev_letu EV2' EV1') : (letu M1 M2 \\n/ V')) Q\n         <- eval_determ EV2 EV2' Q.\n\neval_determ_lett : eval_determ ((ev_lett EV2 EV1) : (lett M1 M2) \\n/ V)\n                               ((ev_lett EV2' EV1') : (lett M1 M2 \\n/ V')) Q\n         <- eval_determ EV1 EV1' Q1\n         <- eq_tens Q1 Q2 Q3\n         <- eq_ctx2 Q2 Q3 M2 Q4\n         <- eq_sym Q4 Q4'\n         <- eq_eval Q4' EV2' EV2s\n         <- eval_determ EV2 EV2s Q.\n\n%worlds () (eval_determ _ _ _).\n%freeze eval_determ.\n%total D (eval_determ D _ _).\n</twelf>\nAnd transitive:\n<twelf>\neval_trans : M \\n/ V -> V \\n/ V' -> M \\n/ V' -> type.\n%mode eval_trans +EV +EV' -EV''.\n\neval_trans_rule : eval_trans EV EV' EV''\n                   <- value_soundness EV Vv\n                   <- selfeval Vv EVv'\n                   <- eval_determ EVv' EV' Q\n                   <- eq_eval2 Q EV EV''.\n\n%worlds () (eval_trans _ _ _).\n%total {} (eval_trans _ _ _).\n\neq_val : eq M M' -> value M -> value M' -> type.\n%mode eq_val +Q +V -V'.\neq_val_rule : eq_val eq_ref V V.\n%worlds () (eq_val _ _ _).\n%freeze eval_trans.\n%total {} (eq_val _ _ _).\n\n</twelf>\n\n==Frame stack semantics==\nThe abstract machine is defined as a relation on tuples consisting of a frame stack and a term to evaluate in that stack.\n\n===Evaluation frames===\nThe frame stack is a stack of evaluation frames that provides a context on which we will continue evaluation after we have computed a value for the current term.\n<twelf>\nframe : (term -> term) -> type. %name frame F.\n\nfletb : {M} frame [a] letb a M.\nfapp :  {M} frame [a] app a M.\nftapp : {T} frame [a] tapp a T.\nfletu : {M} frame [a] letu a M.\nflett : {M} frame [a] lett a M.\n%freeze frame.\n</twelf>\n\nEvaluation frames are functions from terms to terms and sometimes I need to apply such a function to a term.\n<twelf>\nframeapp : frame F -> term -> term -> type.\n%mode frameapp +F +M -M'.\n\nframeapp_app : % {F : frame F'} \n         frameapp (F : frame F') M (F' M).\n\n%worlds () (frameapp _ _ _).\n%freeze frameapp.\n%total D (frameapp D _ _).\n\nframeapp_exists : {F}{M} (frameapp F M M') -> type.\n%mode frameapp_exists +F +M -FM.\nframeapp_exists_rule : frameapp_exists F M frameapp_app.\n%worlds () (frameapp_exists _ _ _).\n%freeze frameapp_exists.\n%total D (frameapp_exists D _ _).\n</twelf>\n\nThe definition of the frame stack and application of frame stacks to terms.\n<twelf>\nframestack : type. %name framestack Fs.\n\ncons : frame F -> framestack -> framestack.\nnil : framestack. %freeze framestack.\n\nframeapply : framestack -> term -> term -> type.\n%mode frameapply +FS +M -M'.\n\nframeapply_nil : frameapply nil M M.\nframeapply_cons : frameapply (cons F Fs) M M'\n                  <- frameapp F M M''\n                  <- frameapply Fs M'' M'.\n\n%worlds () (frameapply _ _ _).\n%freeze frameapply.\n%total D (frameapply D _ _).\n</twelf>\nI should move you:\n<twelf>\n%block blam : block {y:term}.\n</twelf>\n\n===Equalities on frame stacks===\nI also need some equational reasoning on frame stacks:\n<twelf>\neqf : framestack -> framestack -> type.\n%mode eqf +Fs -Fs'.\neqf_ref : eqf Fs Fs.\n%freeze eqf.\n\neqf_symm : eqf Fs Fs' -> eqf Fs' Fs -> type.\n%mode eqf_symm +Q -Q'.\neqf_symm_rule : eqf_symm eqf_ref eqf_ref.\n%worlds (blam) (eqf_symm _ _).\n%freeze eqf_symm.\n%total {} (eqf_symm _ _).\n\neqf_trans : eqf Fs Fs' -> eqf Fs' Fs'' -> eqf Fs Fs'' -> type.\n%mode eqf_trans +Q +Q' -Q''.\neqf_trans_rule : eqf_trans eqf_ref eqf_ref eqf_ref.\n%worlds (blam) (eqf_trans _ _ _).\n%freeze eqf_trans.\n%total {} (eqf_trans _ _ _).\n\neqf_extend : {F} eqf Fs Fs' -> eqf (cons F Fs) (cons F Fs') -> type.\n%mode eqf_extend +F +Q -Q'.\neqf_extend_rule : eqf_extend _ eqf_ref eqf_ref.\n%worlds (blam) (eqf_extend _ _ _).\n%freeze eqf_extend.\n%total {} (eqf_extend _ _ _).\n\nframeapply_eq : eqf Fs Fs' -> frameapply Fs M FsM -> frameapply Fs' M FsM -> type.\n%mode frameapply_eq +Q +FA -FA.\nframeapply_eq_rule : frameapply_eq eqf_ref FA FA.\n%worlds (blam) (frameapply_eq _ _ _).\n%freeze frameapply_eq.\n%total {} (frameapply_eq _ _ _).\n\nframeapply_nil_eq : frameapply nil M M' -> eq M M' -> type.\n%mode frameapply_nil_eq +F -Q.\nframeapply_nil_eq_rule : frameapply_nil_eq frameapply_nil eq_ref.\n%worlds (blam) (frameapply_nil_eq _ _).\n%freeze frameapply_nil_eq.\n%total {} (frameapply_nil_eq _ _).\n</twelf>\n\n====More metatheorems about frame application====\n<twelf>\nframeapply_exists : {Fs}{M} (frameapply Fs M M') -> type.\n%mode frameapply_exists +Fs +M -A.\nframeapply_exists_nil : frameapply_exists nil M frameapply_nil.\nframeapply_exists_cons_letu : frameapply_exists (cons (fletu N) Fs) M\n                                                (frameapply_cons FsA frameapp_app)\n         <- frameapply_exists Fs (letu M N) FsA.\nframeapply_exists_cons_letb : frameapply_exists (cons (fletb N) Fs) M \n                                                (frameapply_cons FsA frameapp_app)\n         <- frameapply_exists Fs (letb M N) FsA.\nframeapply_exists_cons_lett : frameapply_exists (cons (flett N) Fs) M\n                                                (frameapply_cons FsA frameapp_app)\n         <- frameapply_exists Fs (lett M N) FsA.\nframeapply_exists_cons_app : frameapply_exists (cons (fapp N) Fs) M\n                                                (frameapply_cons FsA frameapp_app)\n         <- frameapply_exists Fs (app M N) FsA.\nframeapply_exists_cons_tapp : frameapply_exists (cons (ftapp N) Fs) M\n                                               (frameapply_cons FsA frameapp_app)\n         <- frameapply_exists Fs (tapp M N) FsA.\n%worlds () (frameapply_exists _ _ _).\n%freeze frameapply_exists.\n%total D (frameapply_exists D _ _).\n</twelf>\n\n===Frame stack evaluation===\nHere I define the evaluation relation for the abstract machine.\n<twelf>\n--> : framestack -> term -> framestack -> term -> type.\n%mode --> +Fs +M -Fs' -M'.\n\nevfs_letu : --> Fs (letu M N) (cons (fletu N) Fs) M.\nevfs_letb : --> Fs (letb M N) (cons (fletb N) Fs) M.\nevfs_lett : --> Fs (lett M N) (cons (flett N) Fs) M.\nevfs_app  : --> Fs (app M N) (cons (fapp N) Fs) M.\nevfs_tapp : --> Fs (tapp M T) (cons (ftapp T) Fs) M.\n\nevfs_lam : --> (cons (fapp N) Fs) (lam _ M') Fs (M' N).\nevfs_tlam : --> (cons (ftapp T) Fs) (tlam M') Fs (M' T).\nevfs_unit : --> (cons (fletu N) Fs) unit Fs N.\nevfs_tens : --> (cons (flett N) Fs) (tens M1 M2) Fs (N M1 M2).\nevfs_thunk : --> (cons (fletb N) Fs) (thunk T M) Fs (N (letb (thunk T M) M)).\n\n%worlds () (--> _ _ _ _).\n%covers --> -Fs +M -Fs' -M'.\n%freeze -->.\n\neq_step : eq M M' -> --> Fs M Fs1 M1 -> --> Fs M' Fs1 M1 -> type.\n%mode eq_step +Q +S -S'.\neq_step_rule : eq_step eq_ref S S.\n%worlds () (eq_step _ _ _).\n%total {} (eq_step _ _ _).\n\n-->* : framestack -> term -> framestack -> term -> type.\n\n-->*_ref : -->* Fs M Fs M.\n-->*_step : -->* Fs M Fs' M' \n        <- --> Fs'' M'' Fs' M'\n        <- -->* Fs M Fs'' M''.\n%freeze -->*.\n</twelf>\n\n===Meta theory of the abstract machine===\nHere are some basic properties of the abstract machine:\n<twelf>\nconcat-->* : (-->* Fs M Fs'' M'') -> (-->* Fs'' M'' Fs' M') -> (-->* Fs M Fs' M') -> type.\n%mode concat-->* +S1 +S2 -S.\n\nconcatref : concat-->* S -->*_ref S.\nconcatstep : concat-->* S' (-->*_step Ss S) (-->*_step Sc S)\n       <- concat-->* S' Ss Sc.\n\n%worlds () (concat-->* _ _ _).\n%freeze concat-->*.\n%total D (concat-->* _ D _).\n\n-->*_impossible : --> nil V Fs M -> value V -> -->* Fs' M' Fs'' M'' -> type.\n%mode +{V:term} +{Fs:framestack} +{M:term} +{Fs':framestack} +{M':term}\n   +{Fs'':framestack} +{M'':term} +{S:--> nil V Fs M} +{V1:value V}\n      -{R:-->* Fs' M' Fs'' M''} (-->*_impossible S V1 R).\n%worlds () (-->*_impossible _ _ _).\n%freeze -->*_impossible.\n%total {} (-->*_impossible _ _ _).\n\nlemma44 : {Fs : framestack} {M} frameapply Fs M FsM -> (-->* nil FsM Fs M) -> type.\n%mode lemma44 +Fs +M +FA -E.\n\nlemma44_nil : lemma44 nil M frameapply_nil -->*_ref.\nlemma44_cons_letu : lemma44 (cons (fletu N) Fs) M\n                            (frameapply_cons FA frameapp_app) (-->*_step MS evfs_letu)\n             <- lemma44 Fs (letu M N) FA MS.\nlemma44_cons_letb : lemma44 (cons (fletb N) Fs) M\n                            (frameapply_cons FA frameapp_app) (-->*_step MS evfs_letb)\n             <- lemma44 Fs (letb M N) FA MS.\nlemma44_cons_lett : lemma44 (cons (flett N) Fs) M\n                            (frameapply_cons FA frameapp_app) (-->*_step MS evfs_lett)\n             <- lemma44 Fs (lett M N) FA MS.\nlemma44_cons_app : lemma44 (cons (fapp N) Fs) M\n                           (frameapply_cons FA frameapp_app) (-->*_step MS evfs_app)\n             <- lemma44 Fs (app M N) FA MS.\nlemma44_cons_tapp : lemma44 (cons (ftapp N) Fs) M\n                            (frameapply_cons FA frameapp_app) (-->*_step MS evfs_tapp)\n             <- lemma44 Fs (tapp M N) FA MS.\n%worlds () (lemma44 _ _ _ _).\n%freeze lemma44.\n%total D (lemma44 D _ _ _).\n\nframeApplyUnique : (frameapply Fs M FsM) -> (frameapply Fs M FsM') -> (eq FsM FsM') -> type.\n%mode frameApplyUnique +FA1 +FA2 -Q.\n\nframeApplyUnique_nil : frameApplyUnique frameapply_nil frameapply_nil eq_ref.\nframeApplyUnique_cons : frameApplyUnique (frameapply_cons FsA frameapp_app)\n                                         (frameapply_cons FsA' frameapp_app) Q\n                  <- frameApplyUnique FsA FsA' Q.\n\n%worlds () (frameApplyUnique _ _ _).\n%freeze frameApplyUnique.\n%total D (frameApplyUnique D _ _).\n</twelf>\n\n==Correspondence between the big step semantics and the abstract machine==\n<twelf>\nlemma48 : {Fs} {M} (M \\n/ V) -> (-->* Fs M Fs V) -> type.\n%mode lemma48 +Fs +M +E -Ss.\n\nlemma48_lam : lemma48 _ _ ev_lam -->*_ref.\nlemma48_tens : lemma48 _ _ ev_tens -->*_ref.\nlemma48_thunk : lemma48 _ _ ev_thunk -->*_ref.\nlemma48_tlam : lemma48 _ _ ev_tlam -->*_ref.\nlemma48_unit : lemma48 _ _ ev_unit -->*_ref.\n\nlemma48_app : lemma48 Fs (app M1 M2) (ev_app EM' EM1) Sr\n        <- lemma48 (cons (fapp M2) Fs) M1 (EM1 : M1 \\n/ (lam _ M')) SM1\n        <- lemma48  Fs (M' M2) (EM' : (M' M2) \\n/ V) SM'\n        <- concat-->* (-->*_step SM1 evfs_lam) SM' S\n        <- concat-->* (-->*_step -->*_ref evfs_app) S Sr.\n\nlemma48_tapp : lemma48 Fs (tapp M1 T) (ev_tapp EM' EM1) Sr\n        <- lemma48 (cons (ftapp T) Fs) M1 (EM1 : M1 \\n/ (tlam M')) SM1\n        <- lemma48  Fs (M' T) (EM' : (M' T) \\n/ V) SM'\n        <- concat-->* (-->*_step SM1 evfs_tlam) SM' S\n        <- concat-->* (-->*_step -->*_ref evfs_tapp) S Sr.\n\nlemma48_letu : lemma48 Fs (letu M1 M2) (ev_letu EM' EM1) Sr\n        <- lemma48 (cons (fletu M2) Fs) M1 (EM1 : M1 \\n/ unit) SM1\n        <- lemma48  Fs M2 (EM' : M2 \\n/ V) SM'\n        <- concat-->* (-->*_step SM1 evfs_unit) SM' S\n        <- concat-->* (-->*_step -->*_ref evfs_letu) S Sr.\n\nlemma48_letb : lemma48 Fs (letb M1 M2) (ev_letb EM' EM1) Sr\n        <- lemma48 (cons (fletb M2) Fs) M1 (EM1 : M1 \\n/ (thunk T M')) SM1\n        <- lemma48  Fs (M2 (letb (thunk T M') M')) (EM' : (M2 (letb (thunk T M') M')) \\n/ V) SM'\n        <- concat-->* (-->*_step SM1 evfs_thunk) SM' S\n        <- concat-->* (-->*_step -->*_ref evfs_letb) S Sr.\n\nlemma48_lett : lemma48 Fs (lett M1 M2) (ev_lett EM' EM1) Sr\n        <- lemma48 (cons (flett M2) Fs) M1 (EM1 : M1 \\n/ (tens M' M'')) SM1\n        <- lemma48  Fs (M2 M' M'') (EM' : (M2 M' M'') \\n/ V) SM'\n        <- concat-->* (-->*_step SM1 evfs_tens) SM' S\n        <- concat-->* (-->*_step -->*_ref evfs_lett) S Sr.\n\n%worlds () (lemma48 _ _ _ _).\n%freeze lemma48.\n%total D (lemma48 _ _ D _).\n\nlemma46a : {Fs : framestack} (M' \\n/ V) -> (frameapply Fs M M') ->\n                             (frameapply Fs V' N) -> (M \\n/ V') -> (N \\n/ V) -> type.\nlemma46b : {Fs : framestack} (M \\n/ V') -> (N \\n/ V) -> (frameapply Fs M M') ->\n                             (frameapply Fs V' N) -> (M' \\n/ V) -> type.\n%mode lemma46a +Fs +As +FaM -FV' -Res1 -Res2.\n%mode lemma46b +Fs +As1 +As2 +FaM +FV' -Res1.\n\nlemma46a_nil : lemma46a nil E frameapply_nil frameapply_nil E EV\n        <- (value_soundness E Vv)\n        <- (selfeval Vv EV).\n\nlemma46a_letu : lemma46a (cons (fletu N) Fs) (E : M' \\n/ V) (frameapply_cons FA frameapp_app)\n                         (frameapply_cons FAu frameapp_app) RM E' \n        <- lemma46a Fs E FA FA' (ev_letu (RN : N \\n/ V') RM) (R2 : _ \\n/ V)\n        <- frameapply_exists Fs (letu unit N) FAu\n        <- lemma46b Fs (ev_letu RN ev_unit : letu unit N \\n/ V') R2 FAu FA' E'.\n\nlemma46a_app : lemma46a (cons (fapp N) Fs) (E : M' \\n/ V) (frameapply_cons FA frameapp_app)\n                        (frameapply_cons FAu frameapp_app) RM E' \n        <- lemma46a Fs E FA FA' (ev_app RN (RM : M \\n/ (lam T M1))) R2\n        <- frameapply_exists Fs (app (lam T M1) N) FAu\n        <- lemma46b Fs (ev_app RN ev_lam) R2 FAu FA' E'.\nlemma46a_tapp : lemma46a (cons (ftapp N) Fs) (E : M' \\n/ V) (frameapply_cons FA frameapp_app)\n                         (frameapply_cons FAu frameapp_app) RM E' \n        <- lemma46a Fs E FA FA' (ev_tapp RN (RM : M \\n/ (tlam T))) R2\n        <- frameapply_exists Fs (tapp (tlam T) N) FAu\n        <- lemma46b Fs (ev_tapp RN ev_tlam) R2 FAu FA' E'.\n\nlemma46a_letb : lemma46a (cons (fletb N) Fs) (E : M' \\n/ V) (frameapply_cons FA frameapp_app)\n                         (frameapply_cons FAu frameapp_app) RM E' \n        <- lemma46a Fs E FA FA' (ev_letb RN (RM : M \\n/ (thunk T M1))) R2\n        <- frameapply_exists Fs (letb (thunk T M1) N) FAu\n        <- lemma46b Fs (ev_letb RN ev_thunk) R2 FAu FA' E'.\n\nlemma46a_lett : lemma46a (cons (flett N) Fs) (E : M' \\n/ V) (frameapply_cons FA frameapp_app)\n                         (frameapply_cons FAu frameapp_app) RM E' \n        <- lemma46a Fs E FA FA' (ev_lett RN (RM : M \\n/ (tens M1 M2))) R2\n        <- frameapply_exists Fs (lett (tens M1 M2) N) FAu\n        <- lemma46b Fs (ev_lett RN ev_tens) R2 FAu FA' E'.\n\nlemma46b_nil : lemma46b nil (E : M1 \\n/ M2) E' frameapply_nil frameapply_nil E''\n        <- value_soundness E V\n        <- selfeval V EV\n        <- eval_determ EV E' Q\n        <- eq_eval2 Q E E''.\n\nlemma46b_letu : lemma46b (cons (fletu M6) Fs1) E1 E2 (frameapply_cons X1 frameapp_app)\n                         (frameapply_cons X2 frameapp_app) E3\n        <- lemma46a Fs1 E2 X2 X3 (ev_letu EM6 EM2) EN\n        <- eval_trans E1 EM2 EM1\n        <- lemma46b Fs1 (ev_letu EM6 EM1) EN X1 X3 E3.\n\nlemma46b_lett : lemma46b (cons (flett M6) Fs1) E1 E2 (frameapply_cons X1 frameapp_app)\n                         (frameapply_cons X2 frameapp_app) E3\n        <- lemma46a Fs1 E2 X2 X3 (ev_lett EM6 EM2) EN\n        <- eval_trans E1 EM2 EM1\n        <- lemma46b Fs1 (ev_lett EM6 EM1) EN X1 X3 E3.\n\nlemma46b_app : lemma46b (cons (fapp M6) Fs1) E1 E2 (frameapply_cons X1 frameapp_app)\n                        (frameapply_cons X2 frameapp_app) E3\n        <- lemma46a Fs1 E2 X2 X3 (ev_app EM6 EM2) EN\n        <- eval_trans E1 EM2 EM1\n        <- lemma46b Fs1 (ev_app EM6 EM1) EN X1 X3 E3.\n\nlemma46b_tapp : lemma46b (cons (ftapp M6) Fs1) E1 E2 (frameapply_cons X1 frameapp_app)\n                         (frameapply_cons X2 frameapp_app) E3\n        <- lemma46a Fs1 E2 X2 X3 (ev_tapp EM6 EM2) EN\n        <- eval_trans E1 EM2 EM1\n        <- lemma46b Fs1 (ev_tapp EM6 EM1) EN X1 X3 E3.\n\nlemma46b_letb : lemma46b (cons (fletb M6) Fs1) E1 E2 (frameapply_cons X1 frameapp_app)\n                         (frameapply_cons X2 frameapp_app) E3\n        <- lemma46a Fs1 E2 X2 X3 (ev_letb EM6 EM2) EN\n        <- eval_trans E1 EM2 EM1\n        <- lemma46b Fs1 (ev_letb EM6 EM1) EN X1 X3 E3.\n\n%worlds () (lemma46a _ _ _ _ _ _) (lemma46b _ _ _ _ _ _).\n%freeze lemma46b lemma46a.\n%total (D E) (lemma46a D _ _ _ _ _) (lemma46b E _ _ _ _ _).\n\nlemma47 : (--> Fs M Fs' M') -> (frameapply Fs' M' FsM') -> (frameapply Fs M FsM) ->\n                               (FsM' \\n/ V) -> (FsM \\n/ V) -> type.\n%mode lemma47 +S +FA' -FA +EV' -EV.\n\nlemma47_letu : lemma47 evfs_letu (frameapply_cons X1 frameapp_app) X1 EV' EV'.\nlemma47_letb : lemma47 evfs_letb (frameapply_cons X1 frameapp_app) X1 EV' EV'.\nlemma47_lett : lemma47 evfs_lett (frameapply_cons X1 frameapp_app) X1 EV' EV'.\nlemma47_app : lemma47 evfs_app (frameapply_cons X1 frameapp_app) X1 EV' EV'.\nlemma47_tapp : lemma47 evfs_tapp (frameapply_cons X1 frameapp_app) X1 EV' EV'.\n\nlemma47_unit : lemma47 evfs_unit X1 (frameapply_cons X3 frameapp_app) EV' EV\n         <- lemma46a Fs EV' X1 X2 (EM2 : M2 \\n/ V') EN\n         <- frameapply_exists Fs (letu unit M2) X3\n         <- lemma46b Fs (ev_letu EM2 ev_unit) EN X3 X2 EV.\n\nlemma47_tens : lemma47 evfs_tens X1 (frameapply_cons X3 frameapp_app) EV' EV\n         <- lemma46a Fs EV' X1 X2 EM2  EN\n         <- frameapply_exists Fs (lett (tens M3 M4) M2) X3\n         <- lemma46b Fs (ev_lett EM2 ev_tens) EN X3 X2 EV.\n\nlemma47_thunk : lemma47 evfs_thunk X1 (frameapply_cons X3 frameapp_app) EV' EV\n         <- lemma46a Fs EV' X1 X2 EM2  EN\n         <- frameapply_exists Fs (letb (thunk T M4) M2) X3\n         <- lemma46b Fs (ev_letb EM2 ev_thunk) EN X3 X2 EV.\n\nlemma47_lam : lemma47 evfs_lam X1 (frameapply_cons X3 frameapp_app) EV' EV\n         <- lemma46a Fs EV' X1 X2 EM2  EN\n         <- frameapply_exists Fs (app (lam T M4) M2) X3\n         <- lemma46b Fs (ev_app EM2 ev_lam) EN X3 X2 EV.\n\nlemma47_tlam : lemma47 evfs_tlam X1 (frameapply_cons X3 frameapp_app) EV' EV\n         <- lemma46a Fs EV' X1 X2 EM2  EN\n         <- frameapply_exists Fs (tapp (tlam M4) M2) X3\n         <- lemma46b Fs (ev_tapp EM2 ev_tlam) EN X3 X2 EV.\n\n%worlds () (lemma47 _ _ _ _ _).\n%freeze lemma47.\n%total S (lemma47 S _ _ _ _).\n\n-->r* : framestack -> term -> framestack -> term -> type.\n\n-->r*_ref : -->r* Fs M Fs M.\n-->r*_step : -->r* Fs M Fs' M' \n        <- --> Fs M Fs'' M''\n        <- -->r* Fs'' M'' Fs' M'.\n%freeze -->r*.\n\nconcat-->r* : -->r* Fs M Fs' M' -> -->r* Fs' M' Fs'' M'' -> -->r* Fs M Fs'' M'' -> type.\n%mode concat-->r* +A +B -C.\n\nconcat-->r*_ref : concat-->r* -->r*_ref D D.\nconcat-->r*_step : concat-->r* (-->r*_step R S) D (-->r*_step D' S)\n              <- concat-->r* R D D'.\n\n%worlds () (concat-->r* _ _ _).\n%freeze concat-->r*.\n%total D (concat-->r* D _ _).\n\n-->r*_impossible : --> nil V Fs M -> value V -> -->r* Fs' M' Fs'' M'' -> type.\n%mode +{V:term} +{Fs:framestack} +{M:term} +{Fs':framestack} +{M':term}\n   +{Fs'':framestack} +{M'':term} +{S:--> nil V Fs M} +{V1:value V}\n      -{R:-->r* Fs' M' Fs'' M''} (-->r*_impossible S V1 R).\n%worlds () (-->r*_impossible _ _ _).\n%freeze -->r*_impossible.\n%total {} (-->r*_impossible _ _ _).\n\nconcat-->r*_exists :  {R : -->r* F1 M1 Fs M} \n                      {S : -->r* (Fs : framestack) (M : term) (Fs2 : framestack) (M2 : term)}\n                      (concat-->r* R S RS) -> type.\n%mode concat-->r*_exists +R +S -P.\n\nconcat-->r*_exists_ref : concat-->r*_exists -->r*_ref _ concat-->r*_ref.\nconcat-->r*_exists_step : concat-->r*_exists (-->r*_step R S) B (concat-->r*_step E)\n            <- concat-->r*_exists R B E.\n\n%worlds () (concat-->r*_exists _ _ _).\n%freeze concat-->r*_exists.\n%total D (concat-->r*_exists D _ _).\n\n-->*_to_-->r*_lem : -->* Fs M Fs' M' -> -->r* Fs M Fs' M' -> type.\n%mode -->*_to_-->r*_lem +F -R.\n\n-->*_to_-->r*_lem_ref : -->*_to_-->r*_lem -->*_ref -->r*_ref.\n\n-->*_to_-->r*_lem_step : -->*_to_-->r*_lem (-->*_step R S) R''\n            <- -->*_to_-->r*_lem R R'\n            <- concat-->r* R' (-->r*_step -->r*_ref S) R''.\n\n%worlds () (-->*_to_-->r*_lem _ _).\n%freeze -->*_to_-->r*_lem.\n%total D (-->*_to_-->r*_lem D _).\n\n-->r*_to_-->*_lem : -->r* Fs M Fs' M' -> -->* Fs M Fs' M' -> type.\n%mode -->r*_to_-->*_lem +F -R.\n\n-->r*_to_-->*_lem_ref : -->r*_to_-->*_lem -->r*_ref -->*_ref.\n\n-->r*_to_-->*_lem_step : -->r*_to_-->*_lem (-->r*_step R S) R''\n            <- -->r*_to_-->*_lem R R'\n            <- concat-->* (-->*_step -->*_ref S) R' R''.\n\n%worlds () (-->r*_to_-->*_lem _ _).\n%freeze -->r*_to_-->*_lem.\n%total D (-->r*_to_-->*_lem D _).\n\n-->r*_add_step : (--> Fs M Fs' M') -> (-->r* Fs M nil V) -> (value V) ->\n                                      (-->r* Fs' M' nil V) -> type.\n%mode -->r*_add_step +S +R +V -R'.\n\n-->r*_add_step_ref : -->r*_add_step S -->r*_ref V R\n          <- -->r*_impossible S V R.\n\n-->r*_add_step_step : -->r*_add_step S (-->r*_step Rr S) V Rr.\n\n%worlds () (-->r*_add_step _ _ _ _).\n%freeze -->r*_add_step.\n%total {} (-->r*_add_step _ _ _ _).\n\n-->*_add_step : (--> Fs M Fs' M') -> (-->* Fs M nil V) -> (value V) ->\n                                     (-->* Fs' M' nil V) -> type.\n%mode -->*_add_step +S +R +V -R'.\n\n-->*_add_step_rule : -->*_add_step S R V R'\n            <- -->*_to_-->r*_lem R Rr\n            <- -->r*_add_step S Rr V R'r\n            <- -->r*_to_-->*_lem R'r R'.\n\n%worlds () (-->*_add_step _ _ _ _).\n%freeze -->*_add_step.\n%total {} (-->*_add_step _ _ _ _).\n\n-->*_to_-->r*_lem_exists : {S : -->* _ _ _ _} -->*_to_-->r*_lem S R -> type.\n%mode -->*_to_-->r*_lem_exists +S -P.\n\n-->*_to_-->r*_lem_exists_ref : -->*_to_-->r*_lem_exists -->*_ref -->*_to_-->r*_lem_ref.\n\n-->*_to_-->r*_lem_exists_step : -->*_to_-->r*_lem_exists (-->*_step R S) (-->*_to_-->r*_lem_step R'' R')\n         <- -->*_to_-->r*_lem_exists R (R' : -->*_to_-->r*_lem R Rr)\n         <- concat-->r*_exists Rr (-->r*_step -->r*_ref S) R''.\n\n%worlds () (-->*_to_-->r*_lem_exists _ _).\n%freeze -->*_to_-->r*_lem_exists.\n%total D (-->*_to_-->r*_lem_exists D _).\n\neq_frame_eval_lemma : -->r* Fs M nil V -> value V -> frameapply Fs M FsM -> FsM \\n/ V -> type.\n%mode eq_frame_eval_lemma +V +L -FA -EV.\n\neq_frame_eval_lemma_z : eq_frame_eval_lemma -->r*_ref V frameapply_nil EV\n             <- selfeval V EV.\n\neq_frame_eval_lemma_s : eq_frame_eval_lemma (-->r*_step R S) V FA EV\n             <- eq_frame_eval_lemma R V FA' EV'\n             <- lemma47 S FA' FA EV' EV.\n\n%worlds () (eq_frame_eval_lemma _ _ _ _) .\n%freeze eq_frame_eval_lemma.\n%total D (eq_frame_eval_lemma D _ _ _).\n\neq_frame_eval : -->* Fs M nil V -> value V -> frameapply Fs M FsM -> FsM \\n/ V -> type.\n%mode eq_frame_eval +V +L -FA -EV.\n\neq_frame_eval_rule : eq_frame_eval FE V FA E\n        <- -->*_to_-->r*_lem FE R\n        <- eq_frame_eval_lemma R V FA E.\n\n%worlds () (eq_frame_eval _ _ _ _).\n%freeze eq_frame_eval.\n%total D (eq_frame_eval D _ _ _).\n\n-->*_skew : -->* Fs M nil V -> (value V) -> (-->* Fs M Fs' M') -> (-->* Fs' M' nil V) -> type.\n%mode -->*_skew +R +V +R' -R''.\n\n-->*_skew_ref : -->*_skew R V -->*_ref R.\n\n-->*_skew_step : -->*_skew R V (-->*_step Rest S) RI\n       <- -->*_skew R V Rest RI'\n       <- -->*_add_step S RI' V RI.\n\n%worlds () (-->*_skew _ _ _ _) .\n%freeze -->*_skew.\n%total D (-->*_skew _ _ D _).\n\neq_eval_frame : (frameapply Fs M FsM) -> (FsM \\n/ V) -> (-->* Fs M nil V) -> type.\n%mode eq_eval_frame +FA +EV -R.\n\neq_eval_frame_rule : eq_eval_frame (FA : frameapply Fs M FsM) EV R\n            <- lemma44 Fs M FA R''\n            <- lemma48 nil FsM EV R'\n            <- value_soundness EV V\n            <- -->*_skew R' V R'' R.\n\n%worlds () (eq_eval_frame _ _ _).\n%freeze eq_eval_frame.\n%total {} (eq_eval_frame _ _ _).\n</twelf>\n\n====Termination relation on the abstract machine====\n<twelf>\nframeterm : framestack -> term -> type.\n\nframeterm_val : frameterm nil V <- value V. \nframeterm_app : frameterm Fs (app M1 M2) <- frameterm (cons (fapp M2) Fs) M1.\nframeterm_tapp : frameterm Fs (tapp M T) <- frameterm (cons (ftapp T) Fs) M.\nframeterm_letu : frameterm Fs (letu M1 M2) <- frameterm (cons (fletu M2) Fs) M1.\nframeterm_letb : frameterm Fs (letb M1 M2) <- frameterm (cons (fletb M2) Fs) M1.\nframeterm_lett : frameterm Fs (lett M1 M2) <- frameterm (cons (flett M2) Fs) M1.\nframeterm_lam : frameterm (cons (fapp M2) Fs) (lam T M1) <- frameterm Fs (M1 M2).\nframeterm_tlam : frameterm (cons (ftapp T) Fs) (tlam M1) <- frameterm Fs (M1 T).\nframeterm_tens : frameterm (cons (flett M3) Fs) (tens M1 M2) <- frameterm Fs (M3 M1 M2).\nframeterm_thunk : frameterm (cons (fletb M2) Fs) (thunk T M1) <- frameterm Fs (M2 (letb (thunk T M1) M1)).\nframeterm_unit : frameterm (cons (fletu M3) Fs) unit <- frameterm Fs M3.\n%freeze frameterm.\n\nframeterm_eq_frames : eqf Fs Fs' -> eq M M' -> frameterm Fs M -> frameterm Fs' M' -> type.\n%mode frameterm_eq_frames +Q +Q' +Ft -Ft.\nframeterm_eq_frames_rule : frameterm_eq_frames eqf_ref eq_ref Ft Ft.\n%worlds () (frameterm_eq_frames _ _ _ _).\n%freeze frameterm_eq_frames.\n%total {} (frameterm_eq_frames _ _ _ _).\n\neq_frameterms : frameterm Fs M -> frameterm Fs M -> type.\n%mode eq_frameterms +FT -FT'.\neq_frameterms_ref : eq_frameterms F F.\n%worlds () (eq_frameterms _ _).\n%freeze eq_frameterms.\n%total {} (eq_frameterms _ _).\n\ninverse_ft_app : frameterm Fs (app M1 M2) -> frameterm (cons (fapp M2) Fs) M1 -> type.\n%mode inverse_ft_app +Ft -Ft'.\ninverse_ft_app_rule : inverse_ft_app (frameterm_app Ft) Ft.\n%worlds () (inverse_ft_app _ _).\n%reduces D < E (inverse_ft_app E D).\n%total {} (inverse_ft_app _ _).\n\ninverse_ft_tapp : frameterm Fs (tapp M1 M2) -> frameterm (cons (ftapp M2) Fs) M1 -> type.\n%mode inverse_ft_tapp +Ft -Ft'.\ninverse_ft_tapp_rule : inverse_ft_tapp (frameterm_tapp Ft) Ft.\n%worlds () (inverse_ft_tapp _ _).\n%reduces D < E (inverse_ft_tapp E D).\n%total {} (inverse_ft_tapp _ _).\n\ninverse_ft_letu : frameterm Fs (letu M1 M2) -> frameterm (cons (fletu M2) Fs) M1 -> type.\n%mode inverse_ft_letu +Ft -Ft'.\ninverse_ft_letu_rule : inverse_ft_letu (frameterm_letu Ft) Ft.\n%worlds () (inverse_ft_letu _ _).\n%reduces D < E (inverse_ft_letu E D).\n%total {} (inverse_ft_letu _ _).\n\ninverse_ft_lett : frameterm Fs (lett M1 M2) -> frameterm (cons (flett M2) Fs) M1 -> type.\n%mode inverse_ft_lett +Ft -Ft'.\ninverse_ft_lett_rule : inverse_ft_lett (frameterm_lett Ft) Ft.\n%worlds () (inverse_ft_lett _ _).\n%reduces D < E (inverse_ft_lett E D).\n%total {} (inverse_ft_lett _ _).\n\ninverse_ft_letb : frameterm Fs (letb M1 M2) -> frameterm (cons (fletb M2) Fs) M1 -> type.\n%mode inverse_ft_letb +Ft -Ft'.\ninverse_ft_letb_rule : inverse_ft_letb (frameterm_letb Ft) Ft.\n%worlds () (inverse_ft_letb _ _).\n%reduces D < E (inverse_ft_letb E D).\n%total {} (inverse_ft_letb _ _).\n</twelf>\n\nThe termination relation is really about the machine.\n<twelf>\nframeterm_eq_f : frameterm Fs M -> -->r* Fs M nil V -> value V -> type.\n%mode frameterm_eq_f +FT -R -V.\n\nframeterm_eq_f_val : frameterm_eq_f (frameterm_val V) -->r*_ref V.\nframeterm_eq_f_app : frameterm_eq_f (frameterm_app FT) (-->r*_step R evfs_app) V\n        <- frameterm_eq_f FT R V.\nframeterm_eq_f_tapp : frameterm_eq_f (frameterm_tapp FT) (-->r*_step R evfs_tapp) V\n        <- frameterm_eq_f FT R V.\nframeterm_eq_f_letu : frameterm_eq_f (frameterm_letu FT) (-->r*_step R evfs_letu) V\n        <- frameterm_eq_f FT R V.\nframeterm_eq_f_letb : frameterm_eq_f (frameterm_letb FT) (-->r*_step R evfs_letb) V\n        <- frameterm_eq_f FT R V.\nframeterm_eq_f_lett : frameterm_eq_f (frameterm_lett FT) (-->r*_step R evfs_lett) V\n        <- frameterm_eq_f FT R V.\nframeterm_eq_f_lam : frameterm_eq_f (frameterm_lam FT) (-->r*_step R evfs_lam) V\n        <- frameterm_eq_f FT R V.\nframeterm_eq_f_tlam : frameterm_eq_f (frameterm_tlam FT) (-->r*_step R evfs_tlam) V\n        <- frameterm_eq_f FT R V.\nframeterm_eq_f_tens : frameterm_eq_f (frameterm_tens FT) (-->r*_step R evfs_tens) V\n        <- frameterm_eq_f FT R V.\nframeterm_eq_f_unit : frameterm_eq_f (frameterm_unit FT) (-->r*_step R evfs_unit) V\n        <- frameterm_eq_f FT R V.\nframeterm_eq_f_thunk : frameterm_eq_f (frameterm_thunk FT) (-->r*_step R evfs_thunk) V\n        <- frameterm_eq_f FT R V.\n\n%worlds () (frameterm_eq_f _ _ _).\n%freeze frameterm_eq_f.\n%total D (frameterm_eq_f D _ _).\n\nframeterm_eq1 : frameterm Fs M -> -->* Fs M nil V -> value V -> type.\n%mode frameterm_eq1 +FT -R -V.\nframeterm_eq1_rule : frameterm_eq1 FT R V\n         <- frameterm_eq_f FT R' V\n         <- -->r*_to_-->*_lem R' R.\n%worlds () (frameterm_eq1 _ _ _).\n%freeze frameterm_eq1.\n%total {} (frameterm_eq1 _ _ _).\n\nframeterm_eq2_r : -->r* Fs M nil V -> value V -> frameterm Fs M -> type.\n%mode frameterm_eq2_r +R +V -FT.\n\nframeterm_eq2_r_ref : frameterm_eq2_r -->r*_ref V (frameterm_val V).\nframeterm_eq2_r_app : frameterm_eq2_r (-->r*_step R evfs_app) V (frameterm_app F)\n              <- frameterm_eq2_r R V F.\nframeterm_eq2_r_tapp : frameterm_eq2_r (-->r*_step R evfs_tapp) V (frameterm_tapp F)\n              <- frameterm_eq2_r R V F.\nframeterm_eq2_r_letu : frameterm_eq2_r (-->r*_step R evfs_letu) V (frameterm_letu F)\n              <- frameterm_eq2_r R V F.\nframeterm_eq2_r_letb : frameterm_eq2_r (-->r*_step R evfs_letb) V (frameterm_letb F)\n              <- frameterm_eq2_r R V F.\nframeterm_eq2_r_lett : frameterm_eq2_r (-->r*_step R evfs_lett) V (frameterm_lett F)\n              <- frameterm_eq2_r R V F.\nframeterm_eq2_r_lam : frameterm_eq2_r (-->r*_step R evfs_lam) V (frameterm_lam F)\n              <- frameterm_eq2_r R V F.\nframeterm_eq2_r_tlam : frameterm_eq2_r (-->r*_step R evfs_tlam) V (frameterm_tlam F)\n              <- frameterm_eq2_r R V F.\nframeterm_eq2_r_tens : frameterm_eq2_r (-->r*_step R evfs_tens) V (frameterm_tens F)\n              <- frameterm_eq2_r R V F.\nframeterm_eq2_r_unit : frameterm_eq2_r (-->r*_step R evfs_unit) V (frameterm_unit F)\n              <- frameterm_eq2_r R V F.\nframeterm_eq2_r_thunk : frameterm_eq2_r (-->r*_step R evfs_thunk) V (frameterm_thunk F)\n              <- frameterm_eq2_r R V F.\n\n%worlds () (frameterm_eq2_r _ _ _).\n%freeze frameterm_eq2_r.\n%total D (frameterm_eq2_r D _ _).\n\nframeterm_eq2 : -->* Fs M nil V -> value V -> frameterm Fs M -> type.\n%mode frameterm_eq2 +R +V -FT.\nframeterm_eq2_rule : frameterm_eq2 R V F\n            <- -->*_to_-->r*_lem R R'\n            <- frameterm_eq2_r R' V F.\n%worlds () (frameterm_eq2 _ _ _).\n%freeze frameterm_eq2.\n%total {} (frameterm_eq2 _ _ _).\n\neval_frameterm : M \\n/ V -> frameterm nil M -> type.\n%mode eval_frameterm +EV -FT.\neval_frameterm_rule : eval_frameterm EV FT\n           <- value_soundness EV Vv\n           <- eq_eval_frame frameapply_nil EV R\n           <- frameterm_eq2 R Vv FT.\n%worlds () (eval_frameterm _ _).\n%freeze eval_frameterm.\n%total {} (eval_frameterm _ _).\n\nframeterm_eval : frameterm nil M -> M \\n/ V -> type.\n%mode frameterm_eval +FT -EV.\nframeterm_eval_rule : frameterm_eval FT EV\n      <- frameterm_eq1 FT R V\n      <- eq_frame_eval R V FA EV'\n      <- frameapply_nil_eq FA Q\n      <- eq_sym Q Q'\n      <- eq_eval Q' EV' EV.\n%worlds () (frameterm_eval _ _).\n%freeze frameterm_eval.\n%total {} (frameterm_eval _ _).\n</twelf>\nExcellent. We now know that termination in the frame stack semantics is the same as evaluation in the big step semantics. The nice thing about the termination relation is that it supplies us with an inductive description of termination.\n\n====Termination is invariant under evaluation====\n<twelf>\nlemma413a : -->* Fs M Fs' M' -> frameterm Fs M -> frameterm Fs' M' -> type.\n%mode lemma413a +R +FT -FT'.\n\nlemma413a_ref : lemma413a -->*_ref FT FT.\nlemma413a_thunk : lemma413a (-->*_step R evfs_thunk) FT FT'\n        <- lemma413a R FT (frameterm_thunk FT').\nlemma413a_app : lemma413a (-->*_step R evfs_app) FT FT'\n        <- lemma413a R FT (frameterm_app FT').\nlemma413a_tapp : lemma413a (-->*_step R evfs_tapp) FT FT'\n        <- lemma413a R FT (frameterm_tapp FT').\nlemma413a_letu : lemma413a (-->*_step R evfs_letu) FT FT'\n        <- lemma413a R FT (frameterm_letu FT').\nlemma413a_letb : lemma413a (-->*_step R evfs_letb) FT FT'\n        <- lemma413a R FT (frameterm_letb FT').\nlemma413a_lett : lemma413a (-->*_step R evfs_lett) FT FT'\n        <- lemma413a R FT (frameterm_lett FT').\nlemma413a_lam : lemma413a (-->*_step R evfs_lam) FT FT'\n        <- lemma413a R FT (frameterm_lam FT').\nlemma413a_tlam : lemma413a (-->*_step R evfs_tlam) FT FT'\n        <- lemma413a R FT (frameterm_tlam FT').\nlemma413a_tens : lemma413a (-->*_step R evfs_tens) FT FT'\n        <- lemma413a R FT (frameterm_tens FT').\nlemma413a_unit : lemma413a (-->*_step R evfs_unit) FT FT'\n        <- lemma413a R FT (frameterm_unit FT').\n\n%worlds () (lemma413a _ _ _).\n%freeze lemma413a.\n%total D (lemma413a D _ _).\n\nlemma413b : -->r* Fs M Fs' M' -> frameterm Fs' M' -> frameterm Fs M -> type.\n%mode lemma413b +R +FT -FT'.\n\nlemma413b_ref : lemma413b -->r*_ref FT FT.\nlemma413b_thunk : lemma413b (-->r*_step R evfs_thunk) FT (frameterm_thunk FT')\n        <- lemma413b R FT FT'.\nlemma413b_app : lemma413b (-->r*_step R evfs_app) FT (frameterm_app FT')\n        <- lemma413b R FT FT'.\nlemma413b_tapp : lemma413b (-->r*_step R evfs_tapp) FT (frameterm_tapp FT')\n        <- lemma413b R FT FT'.\nlemma413b_letu : lemma413b (-->r*_step R evfs_letu) FT (frameterm_letu FT')\n        <- lemma413b R FT FT'.\nlemma413b_letb : lemma413b (-->r*_step R evfs_letb) FT (frameterm_letb FT')\n        <- lemma413b R FT FT'.\nlemma413b_lett : lemma413b (-->r*_step R evfs_lett) FT (frameterm_lett FT')\n        <- lemma413b R FT FT'.\nlemma413b_lam : lemma413b (-->r*_step R evfs_lam) FT (frameterm_lam FT')\n        <- lemma413b R FT FT'.\nlemma413b_tlam : lemma413b (-->r*_step R evfs_tlam) FT (frameterm_tlam FT')\n        <- lemma413b R FT FT'.\nlemma413b_tens : lemma413b (-->r*_step R evfs_tens) FT (frameterm_tens FT')\n        <- lemma413b R FT FT'.\nlemma413b_unit : lemma413b (-->r*_step R evfs_unit) FT (frameterm_unit FT')\n        <- lemma413b R FT FT'.\n\n%worlds () (lemma413b _ _ _).\n%freeze lemma413b.\n%total D (lemma413b D _ _).\n\nlemma413c : -->* Fs M Fs' M' -> frameterm Fs' M' -> frameterm Fs M -> type.\n%mode lemma413c +R +FT -FT'.\n\nlemma413b_rule : lemma413c R FT FT'\n        <- -->*_to_-->r*_lem R R'\n        <- lemma413b R' FT FT'.\n\n%worlds () (lemma413c _ _ _).\n%freeze lemma413c.\n%total {} (lemma413c _ _ _).\n</twelf>\n\n==The Lily type system==\n====Linearity====\nI encode linearity as a predicate on LF functions. Thus if linear([x].F) then we know that F is linear in x.\n<twelf>\nlinear : (term -> term) -> type.\n%name linear L.\n% mode linear +E.\n\nlinear_id : linear ([x] x).\n\nlinear_app1 : linear ([x] app (E1 x) E2)\n         <- linear E1.\n\nlinear_app2 : linear ([x] app E1 (E2 x))\n         <- linear E2.\n\nlinear_lam : linear ([x] (lam T ([y] E x y)))\n         <- ({y} linear ([x] E x y)).\n\nlinear_tlam : linear  ([x] (tlam ([y] F x y)))\n         <- ({t : tp} linear ([z] (F z t))).\n\nlinear_tapp : linear ([x] tapp (E x) T)\n         <- linear [y] E y.\n\n% linear_thunk : No Rule as thunks have no free linear variables.\n\nlinear_letb1 : linear ([x] letb (E1 x) E2)\n          <- linear E1.\n\nlinear_letb2 : linear ([x] letb E1 ([y] E2 x y))\n          <- {y} linear ([x] E2 x y).\n\n% linear_unit : No Rule as units has no free linear variables.\n\nlinear_letu1 : linear ([x] letu (E1 x) E2)\n          <- linear [x] E1 x.\n\nlinear_letu2 : linear ([x] letu E1 (E2 x))\n          <- linear [x] E2 x.\n\nlinear_tens1 : linear ([x] tens (E1 x) E2)\n          <- linear [x] E1 x.\n\nlinear_tens2 : linear ([x] tens E1 (E2 x))\n          <- linear [x] E2 x.\n\nlinear_lett1 : linear ([x] lett (E x) F)\n          <- linear [x] E x.\n\nlinear_lett2 : linear ([x] lett E ([y] [z] F x y z))\n          <- ({y} {z} linear [x] F x y z).\n\n%block btlam : block {t:tp}.\n%worlds (blam | btlam) (linear _).\n%freeze linear.\n\nsub_linear : linear M1 -> linear M2 -> linear ([x] M1 (M2 x)) -> type.\n%mode sub_linear +L1 +L2 -L3.\n\nsub_linear_id : sub_linear linear_id L2 L2.\nsub_linear_app1 : sub_linear (linear_app1 L1) L2 (linear_app1 L3)\n       <- sub_linear L1 L2 L3.\nsub_linear_app2 : sub_linear (linear_app2 L1) L2 (linear_app2 L3)\n       <- sub_linear L1 L2 L3.\nsub_linear_lam : sub_linear (linear_lam L1) L2 (linear_lam [y] L3 y)\n       <- {y} sub_linear (L1 y) L2 (L3 y).\nsub_linear_tlam : sub_linear (linear_tlam L1) L2 (linear_tlam [t] L3 t)\n       <- ({t} sub_linear (L1 t) L2 (L3 t)).\nsub_linear_tapp : sub_linear (linear_tapp L1) L2 (linear_tapp L3)\n       <- sub_linear L1 L2 L3.\nsub_linear_letb1 : sub_linear (linear_letb1 L1) L2 (linear_letb1 L3)\n       <- sub_linear L1 L2 L3.\nsub_linear_letb2 : sub_linear (linear_letb2 L1) L2 (linear_letb2 L3)\n       <- ({y} sub_linear (L1 y) L2 (L3 y)).\nsub_linear_letu1 : sub_linear (linear_letu1 L1) L2 (linear_letu1 L3)\n       <- sub_linear L1 L2 L3.\nsub_linear_letu2 : sub_linear (linear_letu2 L1) L2 (linear_letu2 L3)\n       <- sub_linear L1 L2 L3.\nsub_linear_lett1 : sub_linear (linear_lett1 L1) L2 (linear_lett1 L3)\n       <- sub_linear L1 L2 L3.\nsub_linear_lett2 : sub_linear (linear_lett2 L1) L2 (linear_lett2 L3)\n       <- ({y}{z} sub_linear (L1 y z) L2 (L3 y z)).\nsub_linear_tens1 : sub_linear (linear_tens1 L1) L2 (linear_tens1 L3)\n       <- sub_linear L1 L2 L3.\nsub_linear_tens2 : sub_linear (linear_tens2 L1) L2 (linear_tens2 L3)\n       <- sub_linear L1 L2 L3.\n\n%block bsub_linear_lam1 : block {y:term}.\n%block bsub_linear_lam2 : block {y:tp}.\n%worlds (bsub_linear_lam1 | bsub_linear_lam2) (sub_linear _ _ _).\n%freeze sub_linear.\n%total D (sub_linear D _ _).\n</twelf>\n\nSome proofs are easier with relevance than with linearity.\n\n<twelf>\nrelavant : (term -> term) -> type.\n%name relavant R.\n%mode relavant +E.\n\nrelavant_id : relavant ([x] x).\nrelavant_app1 : relavant ([x] app (E1 x) (E2 x))\n        <- relavant E1.\nrelavant_app2 : relavant ([x] app (E1 x) (E2 x))\n        <- relavant E2.\nrelavant_lam : relavant ([x] (lam T ([y] F x y))) \n        <- ({y} relavant ([x] F x y)).\nrelavant_tlam : relavant ([x] (tlam ([y] F x y)))\n        <- ({t:tp} relavant ([z] (F z t))).\nrelavant_tapp : relavant ([x] tapp (E x) T)\n        <- relavant E.\nrelavant_letb1 : relavant ([x] letb (E1 x) ([y] E2 x y))\n        <- relavant E1.\nrelavant_letb2 : relavant ([x] letb (E1 x) ([y] E2 x y))\n        <- ({y} relavant [x] E2 x y).\n% linear_unit : No Rule as units has no free variables.\n\nrelavant_thunk : relavant ([x] thunk T ([y] E x y)) \n        <- ({y} relavant ([x] E x y)).\nrelavant_letu1 : relavant ([x] letu (E1 x) (E2 x))\n        <- relavant E1.\nrelavant_letu2 : relavant ([x] letu (E1 x) (E2 x))\n        <- relavant ([x] E2 x).\nrelavant_tens1 : relavant ([x] tens (E1 x) (E2 x))\n        <- relavant E1.\nrelavant_tens2 : relavant ([x] tens (E1 x) (E2 x))\n        <- relavant E2.\nrelavant_lett1 : relavant ([x] lett (E1 x) ([y][z] E2 x y z))\n        <- relavant E1.\nrelavant_lett2 : relavant ([x] lett (E1 x) ([y][z] E2 x y z))\n        <- ({y}{z} relavant ([x] E2 x y z)).\n\n%worlds (blam | btlam) (relavant _).\n%freeze relavant.\n\nlinear_relavant : linear L -> relavant L -> type.\n%mode linear_relavant +L' -R.\nlinear_relavant_id : linear_relavant linear_id relavant_id.\nlinear_relavant_app1 : linear_relavant (linear_app1 L) (relavant_app1 R)\n          <- linear_relavant L R.\nlinear_relavant_app2 : linear_relavant (linear_app2 L) (relavant_app2 R)\n          <- linear_relavant L R.\nlinear_relavant_lam : linear_relavant (linear_lam L) (relavant_lam R)\n          <- {y} linear_relavant (L y) (R y).\nlinear_relavant_tlam : linear_relavant (linear_tlam L) (relavant_tlam R)\n          <- {y} linear_relavant (L y) (R y).\nlinear_relavant_tapp : linear_relavant (linear_tapp L) (relavant_tapp R)\n          <- linear_relavant L R.\nlinear_relavant_letu1 : linear_relavant (linear_letu1 L) (relavant_letu1 R)\n          <- linear_relavant L R.\nlinear_relavant_letu2 : linear_relavant (linear_letu2 L) (relavant_letu2 R)\n          <- linear_relavant L R.\nlinear_relavant_letb1 : linear_relavant (linear_letb1 L) (relavant_letb1 R)\n          <- linear_relavant L R.\nlinear_relavant_letb2 : linear_relavant (linear_letb2 L) (relavant_letb2 R)\n          <- {y} linear_relavant (L y) (R y).\nlinear_relavant_tens1 : linear_relavant (linear_tens1 L) (relavant_tens1 R)\n          <- linear_relavant L R.\nlinear_relavant_tens2 : linear_relavant (linear_tens2 L) (relavant_tens2 R)\n          <- linear_relavant L R.\nlinear_relavant_lett1 : linear_relavant (linear_lett1 L) (relavant_lett1 R)\n          <- linear_relavant L R.\nlinear_relavant_lett2 : linear_relavant (linear_lett2 L) (relavant_lett2 R)\n          <- {y}{z} linear_relavant (L y z) (R y z).\n%worlds (blam | btlam) (linear_relavant _ _).\n%freeze linear_relavant.\n%total D (linear_relavant D _).\n\neq_relavant : ({m} eq (R m) (R' m)) -> relavant R -> relavant R' -> type.\n%mode eq_relavant +EQ +R -R'.\neq_relavant_rule : eq_relavant ([m] eq_ref) R R.\n%worlds (blam) (eq_relavant _ _ _).\n%freeze eq_relavant.\n%total {} (eq_relavant _ _ _).\n\neq_linear : ({m} eq (R m) (R' m)) -> linear R -> linear R' -> type.\n%mode eq_linear +EQ +R -R'.\neq_linear_rule : eq_linear ([m] eq_ref) R R.\n%worlds (blam) (eq_linear _ _ _).\n%freeze eq_linear.\n%total {} (eq_linear _ _ _).\n</twelf>\n\n====Typing rules====\n<twelf>\n? : term -> tp -> type.\n% mode ? +M -T.\n%name ? D.\n%infix none 500 ?.\n\nof_lam : lam T ([x] M x) ? func T T'\n        <- ({x:term} x ? T -> (M x) ? T')\n        <- linear M.\n\nof_app : app M1 M2 ? T\n        <- M1 ? func T' T\n        <- M2 ? T'.\n\nof_tlam : tlam M ? all T\n        <- ({t:tp} (M t) ? T t).\n\nof_tapp : {t:tp} (tapp M t ? T t\n                    <- M ? all T).\n\nof_thunk : thunk T M ? bang T\n        <- ({x} x ? T -> (M x) ? T).\n\nof_letb : letb M N ? T'\n        <- M ? bang T\n        <- ({x} x ? T -> (N x) ? T').\n\nof_unit : unit ? i.\n\nof_letu : letu M N ? T\n        <- M ? i\n        <- N ? T.\n\nof_tens : tens M N ? tensor T T'\n        <- M ? T\n        <- N ? T'.\n\nof_lett : lett M N ? T''\n        <- M ? tensor T T'\n        <- ({x} x ? T -> {y} y ? T' -> (N x y) ? T'')\n        <- ({y} linear ([x] N x y))\n        <- ({x} linear ([y] N x y)).\n\n%block blam_t : some {T : tp} block {x : term} {u : x ? T}.\n%block btlam_t : block {t : tp}.\n%worlds (blam_t | btlam_t) (? _ _).\n%covers ? +M -T.\n%freeze ?.\n</twelf>\nTake note of how I require functions and products to be linear.\n\n===Type preservation===\nAs we have a type system we should prove soundness of it.\n<twelf>\ntpres : M ? T -> M \\n/ V -> V ? T -> type.\n%mode tpres +D +E -E'.\n\ntpres_lam : tpres (of_lam L D) ev_lam (of_lam L D).\ntpres_tlam : tpres (of_tlam D) ev_tlam (of_tlam D).\ntpres_thunk : tpres (of_thunk D) ev_thunk (of_thunk D).\ntpres_unit : tpres of_unit ev_unit of_unit.\ntpres_tens : tpres (of_tens D' D) ev_tens (of_tens D' D).\n\ntpres_app_aux : lam T1 M ? func T3 T2 -> ({M'} M' ? T3 -> M M' ? T2) -> type.\n%mode tpres_app_aux +D -F.\n\ntpres_app_aux_rule : tpres_app_aux (of_lam _ F) F.\n%worlds () (tpres_app_aux _ _).\n%freeze tpres_app_aux.\n%total D (tpres_app_aux D _).\n\ntpres_app : tpres (of_app D2 D1) (ev_app E' E) D\n           <- tpres D1 E D'\n           <- tpres_app_aux D' F\n           <- tpres (F _ D2) E' D.\ntpres_tapp : {D'' : {t : tp} M t ? T t}\n             tpres (of_tapp _ D') (ev_tapp E' E) D\n           <- tpres D' E (of_tlam D'')\n           <- tpres (D'' _) E' D.\n\ntpres_letb_aux : thunk T3 M ? bang T1 -> ({M'} M' ? T1 -> M M' ? T1) -> type.\n%mode tpres_letb_aux +D -F.\ntpres_letb_aux_rule : tpres_letb_aux (of_thunk F) F.\n\n%worlds () (tpres_letb_aux _ _).\n%freeze tpres_letb_aux.\n%total D (tpres_letb_aux D _).\n\ntpres_letb : tpres (of_letb D' D) (ev_letb E' E) D''\n           <- tpres D E DT\n           <- tpres_letb_aux DT Dt\n           <- tpres (D' _ (of_letb Dt DT)) E' D''.\n\ntpres_letu : tpres (of_letu D' _) (ev_letu E' _) D''\n           <- tpres D' E' D''.\n\ntpres_lett : tpres (of_lett _ _ D' D) (ev_lett E' E) D''\n           <- tpres D E (of_tens Dn Dm)\n           <- tpres (D' _ Dm _ Dn) E' D''.\n\n%worlds () (tpres _ _ _).\n%freeze tpres.\n%total D (tpres _ D _).\n\ntpres_s : M ? T -> M \\s/ V -> V ? T -> type.\n%mode tpres_s +D +E -E'.\n\ntpres_s_lam : tpres_s (of_lam L D) evs_lam (of_lam L D).\ntpres_s_tlam : tpres_s (of_tlam D) evs_tlam (of_tlam D).\ntpres_s_thunk : tpres_s (of_thunk D) evs_thunk (of_thunk D).\ntpres_s_unit : tpres_s of_unit evs_unit of_unit.\ntpres_s_tens : tpres_s (of_tens D' D) evs_tens (of_tens D' D).\n\ntpres_s_app_aux : lam T1 M ? func T3 T2 -> ({M'} M' ? T3 -> M M' ? T2) -> type.\n%mode tpres_s_app_aux +D -F.\n\ntpres_s_app_aux_rule : tpres_s_app_aux (of_lam _ F) F.\n%worlds () (tpres_s_app_aux _ _).\n%freeze tpres_s_app_aux.\n%total D (tpres_s_app_aux D _).\n\ntpres_s_app : tpres_s (of_app D2 D1) (evs_app E3 E2 E1) D\n           <- tpres_s D1 E1 D'\n           <- tpres_s_app_aux D' F\n           <- tpres_s D2 E2 D4\n           <- tpres_s (F _ D4) E3 D.\n\ntpres_s_tapp : {D'' : {t : tp} M t ? T t}\n             tpres_s (of_tapp _ D') (evs_tapp E' E) D\n           <- tpres_s D' E (of_tlam D'')\n           <- tpres_s (D'' _) E' D.\n\ntpres_s_letb_aux : thunk T3 M ? bang T1 -> ({M'} M' ? T1 -> M M' ? T1) -> type.\n%mode tpres_s_letb_aux +D -F.\ntpres_s_letb_aux_rule : tpres_s_letb_aux (of_thunk F) F.\n\n%worlds () (tpres_s_letb_aux _ _).\n%freeze tpres_s_letb_aux.\n%total D (tpres_s_letb_aux D _).\n\ntpres_s_letb : tpres_s (of_letb D' D) (evs_letb E' E) D''\n           <- tpres_s D E DT\n           <- tpres_s_letb_aux DT Dt\n           <- tpres_s (D' _ (of_letb Dt DT)) E' D''.\n\ntpres_s_letu : tpres_s (of_letu D' _) (evs_letu E' _) D''\n           <- tpres_s D' E' D''.\n\ntpres_s_lett : % {D' : {x : term} {y : term} x ? T -> y ? T' -> N x y ? T''}\n             tpres_s (of_lett _ _ D' D) (evs_lett E' E) D''\n           <- tpres_s D E (of_tens Dn Dm)\n           <- tpres_s (D' _ Dm _ Dn) E' D''.\n\n%worlds () (tpres_s _ _ _).\n%freeze tpres_s.\n%total D (tpres_s _ D _).\n</twelf>\n\n===Equalities and inversions===\n<twelf>\n%block bts_tlam : block {t:tp}.\neq_typings : M ? T -> M ? T -> type.\n%mode eq_typings +D -D'.\neq_typings_ref : eq_typings D D.\n%worlds (blam | bts_tlam) (eq_typings _ _).\n%freeze eq_typings.\n%total D (eq_typings D _).\n\neq_type : eq M M' -> M ? T -> M' ? T -> type.\n%mode eq_type +Q +D -D.\neq_typing_rule : eq_type eq_ref D D.\n%worlds () (eq_type _ _ _).\n%freeze eq_type.\n%total {} (eq_type _ _ _).\n\neq_type1 : eqt T1 T2 -> M ? T1 -> M ? T2 -> type.\n%mode eq_type1 +Q +D -D'.\neq_type1_rule : eq_type1 eqt_ref D D.\n%worlds () (eq_type1 _ _ _).\n%freeze eq_type1.\n%total {} (eq_type1 _ _ _).\n\ninverse_lam : lam T M ? func T1 T2 -> ({a} a ? T1 -> (M a) ? T2) -> linear M -> type.\n%mode inverse_lam +D -D' -L.\ninverse_lam_rule : inverse_lam (of_lam L D) D L.\n%worlds () (inverse_lam _ _ _).\n%total {} (inverse_lam _ _ _).\n\ninverse_tapp : tapp M T ? T' -> M ? all T1 -> type.\n%mode inverse_tapp +D -D'.\ninverse_tapp_rule : inverse_tapp (of_tapp T D) D.\n%worlds () (inverse_tapp _ _).\n%total {} (inverse_tapp _ _).\n\neq_thunk_type : thunk T M ? bang T' -> eqt T T' -> type.\n%mode eq_thunk_type +D -Q.\neq_thunk_type_rule : eq_thunk_type (of_thunk _) eqt_ref.\n%worlds () (eq_thunk_type _ _).\n%freeze eq_thunk_type.\n%total {} (eq_thunk_type _ _).\n\neq_val_funs : value M -> M ? func T1 T2 -> eq M (lam T1 M') -> type.\n%mode eq_val_funs +V +D -Q.\neq_val_funs_rule : eq_val_funs val_lam (of_lam _ _) eq_ref.\n%worlds () (eq_val_funs _ _ _).\n%freeze eq_val_funs.\n%total {} (eq_val_funs _ _ _).\n\neq_val_all : value M -> M ? all T1 -> eq M (tlam M') -> type.\n%mode eq_val_all +V +D -Q.\neq_val_all_rule : eq_val_all val_tlam (of_tlam _) eq_ref.\n%worlds () (eq_val_all _ _ _).\n%freeze eq_val_all.\n%total {} (eq_val_all _ _ _).\n\neq_val_unit : value M -> M ? i -> eq M unit -> type.\n%mode eq_val_unit +V +D -Q.\neq_val_unit_rule : eq_val_unit val_unit of_unit eq_ref.\n%worlds () (eq_val_unit _ _ _).\n%freeze eq_val_unit.\n%total {} (eq_val_unit _ _ _).\n\neq_val_tensor : value M -> M ? tensor _ _ -> eq M (tens M1 M2) -> type.\n%mode eq_val_tensor +V +D -Q.\neq_val_tensor_rule : eq_val_tensor val_tens (of_tens _ _) eq_ref.\n%worlds () (eq_val_tensor _ _ _).\n%freeze eq_val_tensor.\n%total {} (eq_val_tensor _ _ _).\n\neq_val_bang : value M -> M ? bang _ -> eq M (thunk T M') -> type.\n%mode eq_val_bang +V +D -Q.\neq_val_bang_rule : eq_val_bang val_thunk (of_thunk _) eq_ref.\n%worlds () (eq_val_bang _ _ _).\n%freeze eq_val_bang.\n%total {} (eq_val_bang _ _ _).\n</twelf>\n\n==Abstract machine types==\n<twelf>\nfstp : framestack -> tp -> tp -> type.\n% mode fstp +FST +T -T'.\n%name fstp FsT.\n\nftp_nil : fstp nil T T.\nftp_cons : fstp (cons (F : frame F') Fs) T T'\n            <- ({a} a ? T -> (F' a) ? T'')\n            <- fstp Fs T'' T'.\n\n%worlds () (fstp _ _ _).\n%covers fstp +FST +T -T'.\n%freeze fstp.\n\neqf_fstp : eqf Fs Fs' -> fstp Fs T T' -> fstp Fs' T T' -> type.\n%mode eqf_fstp +Q +Ft -Ft.\neqf_fstp_rule : eqf_fstp eqf_ref F F.\n%worlds (blam) (eqf_fstp _ _ _).\n%freeze eqf_fstp.\n%total {} (eqf_fstp _ _ _).\n\napplysound : {Fs : framestack} (fstp Fs T T') -> M ? T -> (frameapply Fs M M') -> M' ? T' -> type.\n%mode applysound +Fs +F +D +A -D'.\n\nas_ftp_nil : applysound nil ftp_nil D frameapply_nil D.\nas_ftp_cons_letb :\n           applysound (cons (fletb N) Fs)\n         (ftp_cons FsT (Ft : {m:term} m ? T -> letb m N ? T'')) D1 (frameapply_cons Fap frameapp_app) D2\n             <- applysound Fs FsT (Ft M D1) Fap D2.\n\nas_ftp_cons_app :\n           applysound (cons (fapp N) Fs)\n         (ftp_cons FsT (Ft : {m:term} m ? T -> app m N ? T'')) D1 (frameapply_cons Fap frameapp_app) D2\n             <- applysound Fs FsT (Ft M D1) Fap D2.\n\nas_ftp_cons_fletu :\n           applysound (cons (fletu N) Fs)\n         (ftp_cons FsT (Ft : {m:term} m ? T -> letu m N ? T'')) D1 (frameapply_cons Fap frameapp_app) D2\n             <- applysound Fs FsT (Ft M D1) Fap D2.\n\nas_ftp_cons_flett :\n           applysound (cons (flett N) Fs)\n         (ftp_cons FsT (Ft : {m:term} m ? T -> lett m N ? T'')) D1 (frameapply_cons Fap frameapp_app) D2\n             <- applysound Fs FsT (Ft M D1) Fap D2.\n\nas_ftp_cons_ftapp :\n           applysound (cons (ftapp T3) Fs)\n         (ftp_cons FsT (Ft : {m:term} m ? T1 -> tapp m T3 ? T4)) D1 (frameapply_cons Fap frameapp_app) D2\n             <- applysound Fs FsT (Ft M D1) Fap D2.\n\n%worlds () (applysound _ _ _ _ _).\n%freeze applysound.\n%total D (applysound D _ _ _ _).\neqt_tapp : (tapp M T) ? T' -> M ? all T1 -> eqt (T1 T) T' -> type.\n%mode eqt_tapp +D -D' -Q.\neqt_tapp_rule : eqt_tapp (of_tapp T D) D eqt_ref.\n%worlds () (eqt_tapp _ _ _).\n%freeze eqt_tapp.\n%total {} (eqt_tapp _ _ _).\n</twelf>\n\n===Preservation===\nNow I can prove soundness of the type system for the frame stack semantics:\n<twelf>\n\ntyped_step : (fstp Fs T T') -> M ? T -> --> Fs M Fs' M' -> (fstp Fs' T'' T') -> M' ? T'' -> type.\n%mode typed_step +FsT +D +S -FsT' -D'.\n\ntyped_step_letu : typed_step FsT (of_letu DN Di) evfs_letu (ftp_cons FsT [a][da] of_letu DN da) Di.\ntyped_step_letb : typed_step FsT (of_letb DN DM) evfs_letb (ftp_cons FsT [a][da] of_letb DN da) DM.\ntyped_step_lett : typed_step FsT (of_lett L1 L2 DN DM) evfs_lett (ftp_cons FsT [a][da] of_lett L1 L2 DN da) DM.\ntyped_step_fapp : typed_step FsT (of_app DN DM) evfs_app (ftp_cons FsT [a][da] of_app DN da) DM.\ntyped_step_ftapp : typed_step FsT (of_tapp T DM) evfs_tapp (ftp_cons FsT [a][da] of_tapp T da) DM.\n\ntyped_step_unit : typed_step (ftp_cons FsT Ft) of_unit evfs_unit FsT D\n          <- eq_typings (Ft unit of_unit) (of_letu D _).\n\ntyped_step_lam : typed_step (ftp_cons FsT Ft) D1 evfs_lam FsT (D2 _ D)\n          <- eq_typings (Ft _ D1) (of_app D (of_lam _ D2)).\n\ntyped_step_thunk : typed_step (ftp_cons FsT Ft) (of_thunk D1) evfs_thunk FsT (DN _ (of_letb DT (of_thunk DT)))\n          <- eq_typings (Ft _ (of_thunk D1)) (of_letb DN (of_thunk DT)).\n\ntyped_step_tlam : \n           typed_step (ftp_cons FsT Ft) D1 (evfs_tlam : --> (cons (ftapp T1) Fs) _ _ _) FsT D5\n           <- eqt_tapp (Ft (tlam M1) D1) (of_tlam F) Q\n           <- eq_type1 Q (F T1) D5.\n\ntyped_step_tens : typed_step (ftp_cons FsT Ft) (of_tens D2 D1) evfs_tens FsT (D' M1 D1ss M2 D2ss)\n          <- eq_typings (Ft (tens M1 M2) (of_tens D2 D1)) (of_lett L1 L2 D' (of_tens D2ss D1ss)).\n\n%worlds () (typed_step _ _ _ _ _) .\n%freeze typed_step.\n%total {} (typed_step _ _ _ _ _).\n\nframe_pres_lem : -->r* Fs M Fs' M' -> fstp Fs T Te -> M ? T -> fstp Fs' T' Te -> M' ? T' -> type.\n%mode frame_pres_lem +Ss +FsTp +D -FsTp' -D'.\n\nframe_pres_lem_ref : frame_pres_lem -->r*_ref FsTp D FsTp D.\nframe_pres_lem_step : frame_pres_lem (-->r*_step Ss S) FsTp D FsTp' D'\n                   <- typed_step FsTp D S FsTp'' D''\n                   <- frame_pres_lem Ss FsTp'' D'' FsTp' D'.\n\n%worlds () (frame_pres_lem _ _ _ _ _).\n%total Ss (frame_pres_lem Ss _ _ _ _).\n\nframe_pres : -->* Fs M Fs' M' -> fstp Fs T Te -> M ? T -> fstp Fs' T' Te -> M' ? T' -> type.\n%mode frame_pres +Ss +FsTp +D -FsTp' -D'.\n\nframe_pres_rule : frame_pres Ss FsTp D FsTp' D'\n              <- -->*_to_-->r*_lem Ss Ss'\n              <- frame_pres_lem Ss' FsTp D FsTp' D'.\n\n%worlds () (frame_pres _ _ _ _ _).\n%total Ss (frame_pres Ss _ _ _ _).\n</twelf>\n\n====Progress====\nProgress and preservation seem to be in fashion.\nI will not rely on progress elsewhere.\n<twelf>\nprogress_good : framestack -> term -> type.\n%mode progress_good +Fs +M.\nprogress_good_v : progress_good nil V <- value V.\nprogress_good_s : progress_good Fs M <- --> Fs M Fs' M'.\n%freeze progress_good.\n\nframe_progress : {F' : frame F} {Fs} (F V) ? T -> value V -> --> (cons F' Fs) V Fs M -> type.\n%mode frame_progress +Fr +Fs +D +V -S.\n\nframe_progress_app : frame_progress (fapp M2) Fs (of_app D2 D1) V S\n       <- eq_val_funs V D1 Q\n       <- eq_sym Q Q'\n       <- eq_step Q' evfs_lam S.\n\nframe_progress_tapp : frame_progress (ftapp T) Fs (of_tapp T D1) V S\n       <- eq_val_all V D1 Q\n       <- eq_sym Q Q'\n       <- eq_step Q' evfs_tlam S.\n\nframe_progress_lett : frame_progress (flett M2) Fs (of_lett _ _ _ D1) V S\n       <- eq_val_tensor V D1 Q\n       <- eq_sym Q Q'\n       <- eq_step Q' evfs_tens S.\n\nframe_progress_letb : frame_progress (fletb M2) Fs (of_letb _ D1) V S\n       <- eq_val_bang V D1 Q\n       <- eq_sym Q Q'\n       <- eq_step Q' evfs_thunk S.\n\nframe_progress_letu : frame_progress (fletu M2) Fs (of_letu _ D1) V S\n       <- eq_val_unit V D1 Q\n       <- eq_sym Q Q'\n       <- eq_step Q' evfs_unit S.\n\n%worlds () (frame_progress _ _ _ _ _).\n%total {} (frame_progress _ _ _ _ _).\n\nprogress_val : fstp Fs T T' -> M ? T -> value M -> progress_good Fs M -> type.\n%mode progress_val +Ft +D +V -G.\n\nprogress_nil_val : progress_val ftp_nil D V (progress_good_v V).\n\nprogress_cons_rule : progress_val (ftp_cons FsTp Ftp : fstp (cons F Fs) _ _) D V (progress_good_s S)\n                   <- frame_progress F Fs (Ftp _ D) V S.\n\n%worlds () (progress_val _ _ _ _).\n%total {} (progress_val _ _ _ _).\n\nprogress : fstp Fs T T' -> M ? T -> progress_good Fs M -> type.\n%mode progress +Ft +D -G.\nprogress_lam : progress FsTp D G\n                  <- progress_val FsTp D val_lam G.\nprogress_tlam : progress FsTp D G\n                  <- progress_val FsTp D val_tlam G.\nprogress_thunk : progress FsTp D G\n                  <- progress_val FsTp D val_thunk G.\nprogress_tens : progress FsTp D G\n                  <- progress_val FsTp D val_tens G.\nprogress_unit : progress FsTp D G\n                  <- progress_val FsTp D val_unit G.\nprogress_app : progress _ _ (progress_good_s evfs_app).\nprogress_tapp : progress _ _ (progress_good_s evfs_tapp).\nprogress_letu : progress _ _ (progress_good_s evfs_letu).\nprogress_letb : progress _ _ (progress_good_s evfs_letb).\nprogress_lett : progress _ _ (progress_good_s evfs_lett).\n\n%worlds () (progress _ _ _).\n%total {} (progress _ _ _).\n</twelf>\n\n==Strictness lemma==\n===Stack manipulations===\nThere are two natural ways to define application of a frame stack to a term. I need them both and I need to show how they relate. As stacks are represented as lists this code is a nice example of how to prove classic theorems about lists.\n<twelf>\nframeapply' : framestack -> term -> term -> type.\n%mode frameapply' +Fs +M -M'.\nframeapply'_nil : frameapply' nil M M.\nframeapply'_cons : frameapply' (cons F Fs') M M'\n           <- frameapply' Fs' M M''\n           <- frameapp F M'' M'.\n%worlds () (frameapply' _ _ _).\n%freeze frameapply'.\n%total D (frameapply' D _ _).\n\nframeapply'_exists : {Fs} {M} (frameapply' Fs M M') -> type.\n%mode frameapply'_exists +Fs +M -A.\nframeapply'_exists_nil : frameapply'_exists nil M frameapply'_nil.\nframeapply'_exists_cons_letu : frameapply'_exists (cons (fletu N) Fs) M\n                     (frameapply'_cons frameapp_app FsA)\n         <- frameapply'_exists Fs M FsA.\nframeapply'_exists_cons_letb : frameapply'_exists (cons (fletb N) Fs) M\n                     (frameapply'_cons frameapp_app FsA)\n         <- frameapply'_exists Fs M FsA.\nframeapply'_exists_cons_lett : frameapply'_exists (cons (flett N) Fs) M\n                     (frameapply'_cons frameapp_app FsA)\n         <- frameapply'_exists Fs M FsA.\nframeapply'_exists_cons_app : frameapply'_exists (cons (fapp N) Fs) M\n                     (frameapply'_cons frameapp_app FsA)\n         <- frameapply'_exists Fs M FsA.\nframeapply'_exists_cons_tapp : frameapply'_exists (cons (ftapp N) Fs) M\n                     (frameapply'_cons frameapp_app FsA)\n         <- frameapply'_exists Fs M FsA.\n%worlds (blam) (frameapply'_exists _ _ _).\n%freeze frameapply'_exists.\n%total D (frameapply'_exists D _ _).\n\nframeapply'_eq : eqf Fs Fs' -> frameapply' Fs M FsM -> frameapply' Fs' M FsM -> type.\n%mode frameapply'_eq +Q +FA -FA.\nframeapply'_eq_rule : frameapply'_eq eqf_ref FA FA.\n%worlds (blam) (frameapply'_eq _ _ _).\n%freeze frameapply'_eq.\n%total {} (frameapply'_eq _ _ _).\n\nframeapply'_nil_eq : frameapply' nil M M' -> eq M M' -> type.\n%mode frameapply'_nil_eq +F -Q.\nframeapply'_nil_eq_rule : frameapply'_nil_eq frameapply'_nil eq_ref.\n%worlds (blam) (frameapply'_nil_eq _ _).\n%freeze frameapply'_nil_eq.\n%total {} (frameapply'_nil_eq _ _).\n\nrevFs : framestack -> framestack -> framestack -> type.\n%mode revFs +Fs +Fs'' -Fs'.\nrevFs_nil : revFs nil Fs' Fs'.\nrevFs_cons : revFs (cons F Fs) Fs'' Fs'\n               <- revFs Fs (cons F Fs'') Fs'.\n%worlds () (revFs _ _ _).\n%freeze revFs.\n%total D (revFs D _ _).\n\nrevFs_exists : {Fs} {Fs'} revFs Fs Fs' Fs'' -> type.\n%mode revFs_exists +Fs +Fs' -R.\nrevFs_exists_nil : revFs_exists nil _ revFs_nil.\nrevFs_exists_cons : revFs_exists (cons F Fs) Fs' (revFs_cons Fs'')\n            <- revFs_exists Fs (cons F Fs') Fs''.\n%worlds (blam) (revFs_exists _ _ _).\n%freeze revFs_exists.\n%total D (revFs_exists D _ _).\n\nrevDet : revFs Fs Fs' Fs3 -> revFs Fs Fs' Fs4 -> eqf Fs3 Fs4 -> type.\n%mode revDet +R +R' -Q.\nrevDet_nil : revDet revFs_nil _ eqf_ref.\nrevDet_cons : revDet (revFs_cons R) (revFs_cons R') Q\n         <- revDet R R' Q.\n%worlds (blam) (revDet _ _ _).\n%freeze revDet.\n%total D (revDet D _ _).\n\nrevrev_id_lem : revFs Fs Fs' Fs'' -> revFs Fs'' nil Fs4 -> revFs Fs' Fs Fs6 -> eqf Fs6 Fs4 -> type.\n%mode revrev_id_lem +R +R' +R'' -Q.\n\nrevrev_id_lem_nil : revrev_id_lem revFs_nil F F' Q\n          <- revDet F' F Q. \nrevrev_id_lem_cons : revrev_id_lem (revFs_cons R) R' R'' Q\n          <- revrev_id_lem R R' (revFs_cons R'') Q.\n\n%worlds (blam) (revrev_id_lem _ _ _ _).\n%freeze revrev_id_lem.\n%total D (revrev_id_lem D _ _ _).\n\nrevrev_id : revFs Fs nil Fs' -> revFs Fs' nil Fs'' -> eqf Fs Fs'' -> type.\n%mode revrev_id +R +R' -Q.\nrevrev_id_rule : revrev_id R R' Q \n      <- revrev_id_lem R R' revFs_nil Q.\n%worlds (blam) (revrev_id _ _ _).\n%freeze revrev_id.\n%total {} (revrev_id _ _ _).\n\nrev_injective : revFs Fs nil Fs' -> revFs Fs'' nil Fs' -> eqf Fs Fs'' -> type.\n%mode rev_injective +R +R' -Q.\nrev_injective_rule : rev_injective (R : revFs Fs nil Fs') R' Q\n      <- revFs_exists Fs' nil Rev\n      <- revrev_id R Rev Q'\n      <- eqf_symm Q' Q'''\n      <- revrev_id R' Rev Q''\n      <- eqf_trans Q'' Q''' Q1\n      <- eqf_symm Q1 Q.\n%worlds (blam) (rev_injective _ _ _).\n%freeze rev_injective.\n%total D (rev_injective D _ _).\n\nrev_eq1 : eqf Fs Fs' -> revFs Fs F1 F2 -> revFs Fs' F1 F2 -> type.\n%mode rev_eq1 +Q +R -R.\nrev_eq1_rule : rev_eq1 eqf_ref R R.\n%worlds (blam) (rev_eq1 _ _ _).\n%freeze rev_eq1.\n%total {} (rev_eq1 _ _ _).\n\nrev_eq2 : eqf Fs Fs' -> revFs F1 F2 Fs -> revFs F1 F2 Fs' -> type.\n%mode rev_eq2 +Q +R -R.\nrev_eq2_rule : rev_eq2 eqf_ref R R.\n%worlds (blam) (rev_eq2 _ _ _).\n%freeze rev_eq2.\n%total {} (rev_eq2 _ _ _).\n\nframeapply_e : revFs Fs Fs' Fs'' -> frameapply' Fs' M M'' -> frameapply Fs M'' M' ->\n               frameapply' Fs'' M M' -> type.\n%mode frameapply_e +R +FA +FA'' -FA'.\n\nframeapply_e_nil : frameapply_e revFs_nil FA frameapply_nil FA.\nframeapply_e_cons : frameapply_e (revFs_cons R) FA' (frameapply_cons FA frameapp_app) FA''\n             <- frameapply_e R (frameapply'_cons frameapp_app FA') FA FA''.\n\n%worlds (blam) (frameapply_e _ _ _ _).\n%freeze frameapply_e.\n%total D (frameapply_e _ _ D _).\n\nframeapply_e2 : revFs Fs nil Fs' -> frameapply Fs M M' -> frameapply' Fs' M M' -> type.\n%mode frameapply_e2 +R +FA' -FA.\nframeapply_e2_rule : frameapply_e2 R FA' FA\n         <- frameapply_e R frameapply'_nil FA' FA.\n%worlds (blam) (frameapply_e2 _ _ _).\n%freeze frameapply_e2.\n%total {} (frameapply_e2 _ _ _).\n\nframeapply'_e : revFs Fs Fs' Fs''' -> revFs Fs''' nil Fs'' -> frameapply' Fs' M M'' ->\n                frameapply Fs M'' M' -> frameapply Fs'' M M' -> type.\n%mode frameapply'_e +R +R' +FA +FA'' -FA'.\n\nframeapply'_e_nil : frameapply'_e R R' frameapply'_nil FA FA'\n        <- revrev_id R R' Q\n        <- frameapply_eq Q FA FA'.\nframeapply'_e_cons : frameapply'_e R R' (frameapply'_cons frameapp_app FA') FA FA''\n             <- frameapply'_e (revFs_cons R) R' FA' (frameapply_cons FA frameapp_app) FA''.\n\n%worlds (blam) (frameapply'_e _ _ _ _ _).\n%freeze frameapply'_e.\n%total D (frameapply'_e _ _ D _ _).\n\nframeapply_e1 : revFs Fs nil Fs' -> frameapply' Fs M M' -> frameapply Fs' M M' -> type.\n%mode frameapply_e1 +R +FA' -FA.\nframeapply_e1_rule : frameapply_e1 R FA' FA\n         <- frameapply'_e revFs_nil R FA' (frameapply_nil) FA.\n%worlds (blam) (frameapply_e1 _ _ _).\n%freeze frameapply_e1.\n%total {} (frameapply_e1 _ _ _).\n</twelf>\n\n===Some degenerate lemmas===\nThe next lemma is degenerate and needed to take care of other degenerate cases.\n<twelf>\nlem45 : {M:term -> term} ({m:term} frameapply' (Fs m) (N m) R) ->\n                         ({m:term} frameapply' (Fs m) (M (N m)) R') -> type.\n%mode lem45 +M +FA -FA'.\n\nlem45_nil : lem45 _ ([m] frameapply'_nil) ([m] frameapply'_nil) .\nlem45_app : lem45 M ([m] frameapply'_cons (frameapp_app : frameapp (fapp (_)) _ _)\n                    (FA m)) ([m] frameapply'_cons (frameapp_app) (FA' m))\n             <- lem45 M FA FA'.\nlem45_tapp : lem45 M ([m] frameapply'_cons (frameapp_app : frameapp (ftapp (_)) _ _)\n                     (FA m)) ([m] frameapply'_cons (frameapp_app) (FA' m))\n             <- lem45 M FA FA'.\nlem45_letb : lem45 M ([m] frameapply'_cons (frameapp_app : frameapp (fletb (_)) _ _)\n                     (FA m)) ([m] frameapply'_cons (frameapp_app) (FA' m))\n             <- lem45 M FA FA'.\nlem45_lett : lem45 M ([m] frameapply'_cons (frameapp_app : frameapp (flett (_)) _ _)\n                     (FA m)) ([m] frameapply'_cons (frameapp_app) (FA' m))\n             <- lem45 M FA FA'.\nlem45_letu : lem45 M ([m] frameapply'_cons (frameapp_app : frameapp (fletu (_)) _ _)\n                     (FA m)) ([m] frameapply'_cons (frameapp_app) (FA' m))\n             <- lem45 M FA FA'.\n%worlds (blam) (lem45 _ _ _).\n%freeze lem45.\n%total D (lem45 _ D _).\n</twelf>\n\n===Frames are linear===\n<twelf>\nredex : term -> term -> type. %name redex R.\n% mode redex +M +M'.\nredex_app  : redex (app (lam T M1) M2) (M1 M2).\nredex_tapp : redex (tapp (tlam M) T) (M T).\nredex_lett : redex (lett (tens M1 M2) M3) (M3 M1 M2).\nredex_letu : redex (letu unit M) M.\nredex_letb : redex (letb (thunk T M1) M2) (M2 (letb (thunk T M1) M1)).\n%freeze redex.\n\nctp : type.\nctp_0 : ctp.\nctp_1 : linear M -> ctp.\nctp_2 : ({m:term} linear ([n:term] M n m)) -> ({m:term} linear ([n:term] M m n)) -> ctp.\n%freeze ctp.\n\nredex_tp : ({m:term} redex (M m) (M' m)) -> ctp -> type.\nredex_tp_app : {L:linear (M N)} redex_tp ([m:term] redex_app : redex (app (lam T (M m)) (M2 m)) _)\n                                (ctp_1 L).\nredex_tp_tapp : redex_tp ([m] redex_tapp : (redex (tapp (tlam (M m)) T) (M m T))) ctp_0.\nredex_tp_lett : {L1 : {m:term} linear ([n:term] M3 N n m)}\n                {L2 : {m:term} linear ([n:term] M3 N m n)}\n                  redex_tp ([m:term] redex_lett : redex (lett (tens (M1 m) (M2 m)) (M3 m)) _)\n                           (ctp_2 L1 L2).\nredex_tp_letu : redex_tp ([m] redex_letu) ctp_0.\nredex_tp_letb : redex_tp ([m] redex_letb : redex (letb (thunk T (M1 m)) (M2 m)) (M2 m (letb (thunk T (M1 m)) (M1 m)))) ctp_0.\n%freeze redex_tp.\n\nlem33 : ({m:term} redex (M m) (M' m)) -> ({m:term} frameapply' (Fs m) (M m) R) ->\n                                         ({m:term} frameapply' (Fs m) (M' m) R') -> type.\n%mode lem33 +C +FA -FA.\nlem33_nil : lem33 C ([m] frameapply'_nil) ([m] frameapply'_nil) .\nlem33_app : lem33 C ([m] frameapply'_cons (frameapp_app : frameapp (fapp (_)) _ _) (FA m))\n                                          ([m] frameapply'_cons (frameapp_app) (FA' m))\n             <- lem33 C FA FA'.\nlem33_tapp : lem33 C ([m] frameapply'_cons (frameapp_app : frameapp (ftapp (_)) _ _) (FA m))\n                                           ([m] frameapply'_cons (frameapp_app) (FA' m))\n             <- lem33 C FA FA'.\nlem33_letb : lem33 C ([m] frameapply'_cons (frameapp_app : frameapp (fletb (_)) _ _) (FA m))\n                                           ([m] frameapply'_cons (frameapp_app) (FA' m))\n             <- lem33 C FA FA'.\nlem33_lett : lem33 C ([m] frameapply'_cons (frameapp_app : frameapp (flett (_)) _ _) (FA m))\n                                           ([m] frameapply'_cons (frameapp_app) (FA' m))\n             <- lem33 C FA FA'.\nlem33_letu : lem33 C ([m] frameapply'_cons (frameapp_app : frameapp (fletu (_)) _ _) (FA m))\n                                           ([m] frameapply'_cons (frameapp_app) (FA' m))\n             <- lem33 C FA FA'.\n%worlds (blam) (lem33 _ _ _).\n%total D (lem33 _ D _).\n\nlem31 : ({m:term} value (M m)) -> ({a:term} frameapply' (Fs a) (N a) (M a)) ->\n                                  ({a} eq (N a) (M a)) -> type.\n%mode lem31 +V +FA -Q.\nlem31_rule : lem31 _ ([m] frameapply'_nil) ([m] eq_ref).\n%worlds (blam) (lem31 _ _ _).\n%total {} (lem31 _ _ _).\n\nlem32 : {Fs}{M} ({m} value (B m)) -> ({m:term} redex (N1 m) (N2 m)) -> ({m:term} eq (N1 m) (B m)) -> \n            ({m:term} frameapply' (Fs m) (N2 m) (M m)) -> type.\n%mode lem32 +Fs +M +V +C +Q -FA.\n%worlds (blam) (lem32 _ _ _ _ _ _).\n%total {} (lem32 _ _ _ _ _ _).\n\nlem34 :  ({a:term} frameapply' (Fs a) (N a) a) -> ({a} eqf (Fs a) nil) -> type.\n%mode lem34 +FA -Q.\nlem34_rule : lem34 ([m] frameapply'_nil) ([m] eqf_ref).\n%worlds (blam) (lem34 _ _).\n%total {} (lem34 _ _).\n\nlem35 : {Fs}{M} ({m:term} redex (N1 m) (N2 m)) -> ({m:term} eq (N1 m) m) -> \n            ({m:term} frameapply' (Fs m) (N2 m) (M m)) -> type.\n%mode lem35 +Fs +M +C +Q -FA.\n%worlds (blam) (lem35 _ _ _ _ _).\n%total {} (lem35 _ _ _ _ _).\n</twelf>\n\nHere I am building up rather technical lemmas that are needed in the strictness lemma.\nTake note of how easy it is to deal with linearity.\n<twelf>\nframe_linear_lem2 : \n                    redex_tp (C : {m:term} redex (M m) (M' m)) Ct ->\n                   ({m:term} frameapply' (Fs m) (M m) (R m)) -> linear R ->\n                   ({m} frameapply' (Fs m) (M' m) (R' m)) -> linear R' -> type.\n%mode frame_linear_lem2 +C +FA +L -FA' -L'.\n\nframe_linear_lem2_nil1 : frame_linear_lem2 _ ([m] frameapply'_nil : frameapply' _ (app _ M2) _) \n                                              (linear_app1 (linear_lam L)) ([m] frameapply'_nil) (L M2).\n\nframe_linear_lem2_nil2 : frame_linear_lem2 (redex_tp_app L2)\n                                                   ([m] frameapply'_nil : frameapply' _ (app _ (M' m)) _)\n                                                   (linear_app2 L) ([m] frameapply'_nil) L'\n                      <- sub_linear L2 L L'.\n\nframe_linear_tens_lem2_nil1 : frame_linear_lem2 (redex_tp_lett L1 L2)\n                                           ([m] frameapply'_nil : frameapply' _ (lett (tens _ M2) M3) _)\n                                           (linear_lett1 (linear_tens1 L)) ([m] frameapply'_nil) L'\n                                            <- sub_linear (L1 M2) L L'.\n\nframe_linear_tens_lem2_nil2 : frame_linear_lem2 (redex_tp_lett L1 L2)\n                                           ([m] frameapply'_nil : frameapply' _ (lett (tens M1 _) M3) _)\n                                           (linear_lett1 (linear_tens2 L)) ([m] frameapply'_nil) L'\n                                            <- sub_linear (L2 M1) L L'.\n\nframe_linear_tens_lem2_nil3 : frame_linear_lem2 C\n                                 ([m] frameapply'_nil : frameapply' _ (lett (tens M1 M2) (M3 m)) _)\n                                 (linear_lett2 L) ([m] frameapply'_nil) (L M1 M2).\n\nframe_linear_unit_lem_nil2 : frame_linear_lem2 C\n                                 ([m] frameapply'_nil : frameapply' _ (letu unit (M3 m)) _)\n                                 (linear_letu2 L) ([m] frameapply'_nil) L.\n\nframe_linear_thunk_lem_nil2 : frame_linear_lem2 C\n                                 ([m] frameapply'_nil : frameapply' _ (letb (thunk T M1) (M2 m)) _)\n                                 (linear_letb2 L) ([m] frameapply'_nil) (L (letb (thunk T M1) M1)).\n\nframe_linear_tlam_lem_nil1 : frame_linear_lem2 C\n                                 ([m] frameapply'_nil : frameapply' _ (tapp _ T) _)\n                                 (linear_tapp (linear_tlam L)) ([m] frameapply'_nil) (L T).\n\nframe_linear_cons_app1 : frame_linear_lem2 C \n                             ([m] frameapply'_cons (frameapp_app : frameapp (fapp M2) (M1 m) _) (FA m))\n                             (linear_app1 L) ([m] frameapply'_cons frameapp_app (FA' m)) (linear_app1 L')\n                      <- frame_linear_lem2 C FA L FA' L'.\n\nframe_linear_cons_tapp1 : frame_linear_lem2 C\n                             ([m] frameapply'_cons (frameapp_app : frameapp (ftapp T) (M1 m) _) (FA m))\n                             (linear_tapp L) ([m] frameapply'_cons frameapp_app (FA' m)) (linear_tapp L')\n                      <- frame_linear_lem2 C FA L FA' L'.\n\nframe_linear_cons_letu1 : frame_linear_lem2 C\n                             ([m] frameapply'_cons (frameapp_app : frameapp (fletu T) (M1 m) _) (FA m))\n                             (linear_letu1 L) ([m] frameapply'_cons frameapp_app (FA' m)) (linear_letu1 L')\n                      <- frame_linear_lem2 C FA L FA' L'.\n\nframe_linear_cons_letb1 : frame_linear_lem2 C\n                             ([m] frameapply'_cons (frameapp_app : frameapp (fletb T) (M1 m) _) (FA m))\n                             (linear_letb1 L) ([m] frameapply'_cons frameapp_app (FA' m)) (linear_letb1 L')\n                      <- frame_linear_lem2 C FA L FA' L'.\n\nframe_linear_cons_lett1 : frame_linear_lem2 C\n                             ([m] frameapply'_cons (frameapp_app : frameapp (flett T) (M1 m) _) (FA m))\n                             (linear_lett1 L) ([m] frameapply'_cons frameapp_app (FA' m)) (linear_lett1 L')\n                      <- frame_linear_lem2 C FA L FA' L'.\n\nframe_linear_cons_letu2 : frame_linear_lem2 (C : redex_tp C' _)\n                             ([m] frameapply'_cons (frameapp_app : frameapp (fletu (M2 m)) M1 _) (FA m))\n                             (linear_letu2 L) ([m] frameapply'_cons frameapp_app (FA' m)) (linear_letu2 L)\n                      <- lem33 C' FA FA'.\n\nframe_linear_cons_letb2 : frame_linear_lem2 (C : redex_tp C' _)\n                             ([m] frameapply'_cons (frameapp_app : frameapp (fletb (M2 m)) M1 _) (FA m))\n                             (linear_letb2 L) ([m] frameapply'_cons frameapp_app (FA' m)) (linear_letb2 L)\n                      <- lem33 C' FA FA'.\n\nframe_linear_cons_lett2 : frame_linear_lem2 (C : redex_tp C' _)\n                             ([m] frameapply'_cons (frameapp_app : frameapp (flett (M2 m)) M1 _) (FA m))\n                             (linear_lett2 L) ([m] frameapply'_cons frameapp_app (FA' m)) (linear_lett2 L)\n                      <- lem33 C' FA FA'.\n\nframe_linear_cons_app2 : frame_linear_lem2 (C : redex_tp C' _)\n                             ([m] frameapply'_cons (frameapp_app : frameapp (fapp (M2 m)) M1 _) (FA m))\n                             (linear_app2 L) ([m] frameapply'_cons frameapp_app (FA' m)) (linear_app2 L)\n                      <- lem33 C' FA FA'.\n\nframe_linear_cons_tens1 : frame_linear_lem2 (C : redex_tp C' _)\n                              (FA:{m} frameapply' (Fs m) (M1 m) (tens (M3 m) M4))\n                              (linear_tens1 L) FA' (linear_tens1 L)\n                      <- lem31 ([m] val_tens) FA Q\n                      <- lem32 Fs ([m] tens (M3 m) M4) ([m] val_tens) C' Q FA'.\n\nframe_linear_cons_tens2 : frame_linear_lem2 (C : redex_tp C' _)\n                              (FA:{m} frameapply' (Fs m) (M1 m) (tens M3 (M4 m)))\n                              (linear_tens2 L) FA' (linear_tens2 L)\n                      <- lem31 ([m] val_tens) FA Q\n                      <- lem32 Fs ([m] tens M3 (M4 m)) ([m] val_tens) C' Q FA'.\n\nframe_linear_cons_tlam : frame_linear_lem2 (C : redex_tp C' _)\n                              (FA:{m} frameapply' (Fs m) (M1 m) (tlam (M4 m)))\n                              (linear_tlam L) FA' (linear_tlam L)\n                      <- lem31 ([m] val_tlam) FA Q\n                      <- lem32 Fs ([m] tlam (M4 m)) ([m] val_tlam) C' Q FA'.\n\nframe_linear_cons_lam_lem2 : frame_linear_lem2 (C : redex_tp C' _)\n                              (FA:{m:term} frameapply' (Fs m) (M1 m) (lam T1 (M4 m)))\n                              (linear_lam L) FA' (linear_lam L)\n                      <- lem31 ([m] val_lam) FA Q\n                      <- lem32 Fs ([m] lam T1 (M4 m)) ([m] val_lam) C' Q FA'.\n\nframe_linear_lam_lem2_id : frame_linear_lem2 (C : redex_tp C' _)\n                              (FA:{m} frameapply' (Fs m) (M1 m) m) linear_id FA' linear_id\n                      <- lem34 FA Q\n                      <- ({m} frameapply'_eq (Q m) (FA m) (FA'' m))\n                      <- ({m} frameapply'_nil_eq (FA'' m) (Q' m))\n                      <- lem35 Fs ([m] m) C' Q' FA'.\n\n%worlds (blam) (frame_linear_lem2 _ _ _ _ _).\n%total FA (frame_linear_lem2 _ FA _ _ _).\n\nframe_linear_lem1 :\n               redex_tp (C : {m:term} redex (M m) (M' m)) Ct ->\n               ({m:term} frameapply (Fs m) (M m) (R m)) -> linear R ->\n               ({m} frameapply (Fs m) (M' m) (R' m)) -> linear R' -> type.\n               \n%mode frame_linear_lem1 +C +FA +L -FA' -L'.\n\nframe_linear_lem1_rule : frame_linear_lem1 C (FA : {m} frameapply (Fs m) _ _) LR FA' LR'\n               <- ({m} revFs_exists (Fs m) nil (Rev m : revFs (Fs m) nil (Fs' m)))\n               <- ({m} frameapply_e2 (Rev m) (FA m) (FA'' m))\n               <- frame_linear_lem2 C FA'' LR FA3 LR'\n               <- ({m} revFs_exists (Fs' m) nil (Rev' m))\n               <- ({m} revrev_id (Rev m) (Rev' m) (Q m))\n               <- ({m} frameapply_e1 (Rev' m) (FA3 m) (FA4 m))\n               <- ({m} eqf_symm (Q m) (Q' m))\n               <- ({m} frameapply_eq (Q' m) (FA4 m) (FA' m)).\n\n%worlds (blam) (frame_linear_lem1 _ _ _ _ _).\n%total {} (frame_linear_lem1 _ _ _ _ _).\n\nframe_linear : ({m} redex (M m) (M' m)) -> (M A) ? T ->\n                ({m:term} frameapply (Fs m) (M m) (R m)) -> linear R -> \n                ({m} frameapply (Fs m) (M' m) (R' m)) -> linear R' -> type.\n%mode frame_linear +R +D +FA +L -FA' -L'.\n\nframe_linear_app : frame_linear ([m] redex_app) (of_app D2 (of_lam LM _)) FA LR FA' LR'\n                <- frame_linear_lem1 (redex_tp_app LM\n                                  : redex_tp ([m:term] (redex_app : redex (app (lam T (M1 m)) _) _)) _)\n                      FA LR FA' LR'.\n\nframe_linear_lett : frame_linear ([m] redex_lett) (of_lett L1 L2 _ _) FA LR FA' LR'\n                <- frame_linear_lem1 (redex_tp_lett L2 L1\n                      : redex_tp ([m:term] (redex_lett : redex (lett (tens (M1 m) (M2 m)) (M3 m)) _)) _)\n                      FA LR FA' LR'.\n\nframe_linear_letu : frame_linear ([m] redex_letu) _ FA LR FA' LR'\n                <- frame_linear_lem1 redex_tp_letu FA LR FA' LR'.\n\nframe_linear_letb : frame_linear ([m] redex_letb) _ FA LR FA' LR'\n                <- frame_linear_lem1 redex_tp_letb FA LR FA' LR'.\n\nframe_linear_tapp : frame_linear ([m] redex_tapp) _ FA LR FA' LR'\n                <- frame_linear_lem1 redex_tp_tapp FA LR FA' LR'.\n\n%worlds () (frame_linear _ _ _ _ _ _).\n%total {} (frame_linear _ _ _ _ _ _).\n</twelf>\n\n===Termination is invariant to redexes===\n<twelf>\nadd_redex_steps : redex M M' -> frameterm Fs M' -> frameterm Fs M -> type.\n%mode add_redex_steps +R +Ft -Ft'.\nadd_redex_steps_app : add_redex_steps redex_app Ft (frameterm_app (frameterm_lam Ft)).\nadd_redex_steps_tapp : add_redex_steps redex_tapp Ft (frameterm_tapp (frameterm_tlam Ft)).\nadd_redex_steps_lett : add_redex_steps redex_lett Ft (frameterm_lett (frameterm_tens Ft)).\nadd_redex_steps_letu : add_redex_steps redex_letu Ft (frameterm_letu (frameterm_unit Ft)).\nadd_redex_steps_letb : add_redex_steps redex_letb Ft (frameterm_letb (frameterm_thunk Ft)).\n%worlds () (add_redex_steps _ _ _).\n%total {} (add_redex_steps _ _ _).\n\nlem42 : {Fs} {N} redex M M' -> frameterm (Fs M') (N M') -> frameterm (Fs M) (N M) -> type.\n%mode lem42 +Fs +N +R +Ft -Ft'.\n\nlem42_val : lem42 ([a] nil) ([a] a) R (frameterm_val V) Ft\n                <- add_redex_steps R (frameterm_val V) Ft.\n\nlem42_base1 : lem42 ([a:term] nil) ([a] (lam T _))   _ (frameterm_val _) (frameterm_val val_lam).\nlem42_base2 : lem42 ([a:term] nil) ([a] (tlam _))    _ (frameterm_val _) (frameterm_val val_tlam).\nlem42_base3 : lem42 ([a:term] nil) ([a] (tens _ _))  _ (frameterm_val _) (frameterm_val val_tens).\nlem42_base4 : lem42 ([a:term] nil) ([a] (thunk T _)) _ (frameterm_val _) (frameterm_val val_thunk).\nlem42_base5 : lem42 ([a:term] nil) ([a] unit)        _ (frameterm_val _) (frameterm_val val_unit).\n\nlem42_app : lem42 Fs ([a] a) R (frameterm_app Ft) Ft'\n                 <- lem42 ([a] cons (fapp M2) (Fs a)) ([a] M1) R Ft Ft''\n                 <- add_redex_steps R (frameterm_app Ft'') Ft'.\n\nlem42_tapp : lem42 Fs ([a] a) R (frameterm_tapp Ft) Ft'\n                 <- lem42 ([a] cons (ftapp T) (Fs a)) ([a] M1) R Ft Ft''\n                 <- add_redex_steps R (frameterm_tapp Ft'') Ft'.\n\nlem42_lett : lem42 Fs ([a] a) R (frameterm_lett Ft) Ft'\n                 <- lem42 ([a] cons (flett T) (Fs a)) ([a] M1) R Ft Ft''\n                 <- add_redex_steps R (frameterm_lett Ft'') Ft'.\n\nlem42_letu : lem42 Fs ([a] a) R (frameterm_letu Ft) Ft'\n                 <- lem42 ([a] cons (fletu T) (Fs a)) ([a] M1) R Ft Ft''\n                 <- add_redex_steps R (frameterm_letu Ft'') Ft'.\n\nlem42_letb : lem42 Fs ([a] a) R (frameterm_letb Ft) Ft'\n                 <- lem42 ([a] cons (fletb T) (Fs a)) ([a] M1) R Ft Ft''\n                 <- add_redex_steps R (frameterm_letb Ft'') Ft'.\n\nlem42_unit : lem42 ([a] cons (fletu (M2 a)) (Fs a)) ([a] a) R (frameterm_unit Ft) Ft'\n                 <- lem42 Fs ([a] M2 a) R Ft Ft''\n                 <- add_redex_steps R (frameterm_unit Ft'') Ft'.\n\nlem42_tlam : lem42 ([a] cons (ftapp T) (Fs a)) ([a] a) R\n                   (frameterm_tlam Ft : frameterm _ (tlam M)) Ft'\n                 <- lem42 Fs ([a] M T) R Ft Ft''\n                 <- add_redex_steps R (frameterm_tlam Ft'') Ft'.\n\nlem42_lam : lem42 ([a] cons (fapp (M2 a)) (Fs a)) ([a] a) R\n                  (frameterm_lam Ft : frameterm _ (lam T M1')) Ft'\n                 <- lem42 Fs ([a] M1' (M2 a)) R Ft Ft''\n                 <- add_redex_steps R (frameterm_lam Ft'') Ft'.\n\nlem42_tens : lem42 ([a] cons (flett (M3 a)) (Fs a)) ([a] a) R\n                   (frameterm_tens Ft : frameterm _ (tens M1 M2)) Ft'\n                 <- lem42 Fs ([a] M3 a M1 M2) R Ft Ft''\n                 <- add_redex_steps R (frameterm_tens Ft'') Ft'.\n\nlem42_thunk : lem42 ([a] cons (fletb (M2 a)) (Fs a)) ([a] a) R\n                    (frameterm_thunk Ft : frameterm _ (thunk T M1)) Ft'\n                 <- lem42 Fs ([a] M2 a (letb (thunk T M1) M1)) R Ft Ft''\n                 <- add_redex_steps R (frameterm_thunk Ft'') Ft'.\n\nlem42_lam2 : lem42 ([a] cons (fapp (M2 a)) (Fs a)) ([a] lam T (M1' a)) R\n                   (frameterm_lam Ft) (frameterm_lam Ft')\n               <- lem42 Fs ([a] M1' a (M2 a)) R Ft Ft'.\n\nlem42_tens2 : lem42 ([a] cons (flett (M3 a)) (Fs a)) ([a] tens (M1 a) (M2 a)) R\n                    (frameterm_tens Ft) (frameterm_tens Ft')\n               <- lem42 Fs ([a] M3 a (M1 a) (M2 a)) R Ft Ft'.\n\nlem42_tlam2 : lem42 ([a] cons (ftapp T) (Fs a)) ([a] tlam (M1' a)) R\n                    (frameterm_tlam Ft) (frameterm_tlam Ft')\n               <- lem42 Fs ([a] M1' a T) R Ft Ft'.\n\nlem42_unit2 : lem42 ([a] cons (fletu (M2 a)) (Fs a)) ([a] unit) R\n                    (frameterm_unit Ft) (frameterm_unit Ft')\n               <- lem42 Fs ([a] (M2 a)) R Ft Ft'.\n\nlem42_thunk2 : lem42 ([a] cons (fletb (M2 a)) (Fs a)) ([a] thunk T (M1 a)) R\n                     (frameterm_thunk Ft) (frameterm_thunk Ft')\n               <- lem42 Fs ([a] (M2 a (letb (thunk T (M1 a)) (M1 a)))) R Ft Ft'.\n\nlem42_app2 : lem42 Fs ([a] app (M1 a) (M2 a)) R Ft (frameterm_app Ft')\n               <- inverse_ft_app Ft Ft2\n               <- lem42 ([a] cons (fapp (M2 a)) (Fs a)) M1 R Ft2 Ft'.\n\nlem42_tapp2 : lem42 Fs ([a] tapp (M1 a) T) R Ft (frameterm_tapp Ft')\n               <- inverse_ft_tapp Ft Ft2\n               <- lem42 ([a] cons (ftapp T) (Fs a)) M1 R Ft2 Ft'.\n\nlem42_letu2 : lem42 Fs ([a] letu (M1 a) (M2 a)) R Ft (frameterm_letu Ft')\n               <- inverse_ft_letu Ft Ft2\n               <- lem42 ([a] cons (fletu (M2 a)) (Fs a)) M1 R Ft2 Ft'.\n\nlem42_letb2 : lem42 Fs ([a] letb (M1 a) (M2 a)) R Ft (frameterm_letb Ft')\n               <- inverse_ft_letb Ft Ft2\n               <- lem42 ([a] cons (fletb (M2 a)) (Fs a)) M1 R Ft2 Ft'.\n\nlem42_lett2 : lem42 Fs ([a] lett (M1 a) (M2 a)) R Ft (frameterm_lett Ft')\n               <- inverse_ft_lett Ft Ft2\n               <- lem42 ([a] cons (flett (M2 a)) (Fs a)) M1 R Ft2 Ft'.\n\n%worlds () (lem42 _ _ _ _ _).\n%total D (lem42 _ _ _ D _).\n\nlem20 : {M:term}{M':term} ({a:term} value (B a)) -> ({a} frameapply' (Fs a) (N a) (B a)) ->\n                          eqf (Fs M) (Fs M') -> type.\n%mode lem20 +M +M' +V +FA -Q.\nlem20_rule : lem20 M M' _ ([a] frameapply'_nil) eqf_ref.\n%worlds (blam) (lem20 _ _ _ _ _).\n%freeze lem20.\n%total {} (lem20 _ _ _ _ _).\n\nlem26 : {F1}{F2} ({m} frameapp (F m) m M1) -> eqf F1 F2 -> type.\n%mode lem26 +F +F' +FA -Q.\n%worlds (blam) (lem26 _ _ _ _).\n%freeze lem26.\n%total {} (lem26 _ _ _ _).\n</twelf>\n\n===More on linear frames===\n<twelf>\nlem27 : relavant ([m] N) -> {Fs}{Fs'} eqf Fs Fs' -> type.\n%mode lem27 +R +Fs +Fs' -Q.\nlem27_app1 : lem27 (relavant_app1 R) M M' Q\n       <- lem27 R M M' Q.\nlem27_app2 : lem27 (relavant_app2 R) M M' Q\n       <- lem27 R M M' Q.\nlem27_lam : lem27 (relavant_lam R) M M' Q\n       <- lem27 (R unit) M M' Q.\nlem27_tlam : lem27 (relavant_tlam R) M M' Q\n       <- lem27 (R i) M M' Q.\nlem27_tapp : lem27 (relavant_tapp R) M M' Q\n       <- lem27 R M M' Q.\nlem27_letb1 : lem27 (relavant_letb1 R) M M' Q\n       <- lem27 R M M' Q.\nlem27_leb2 : lem27 (relavant_letb2 R) M M' Q\n       <- lem27 (R unit) M M' Q.\nlem27_thunk : lem27 (relavant_thunk R) M M' Q\n       <- lem27 (R unit) M M' Q.\nlem27_letu1 : lem27 (relavant_letu1 R) M M' Q\n       <- lem27 R M M' Q.\nlem27_letu2 : lem27 (relavant_letu2 R) M M' Q\n       <- lem27 R M M' Q.\nlem27_tens1 : lem27 (relavant_tens1 R) M M' Q\n       <- lem27 R M M' Q.\nlem27_tens2 : lem27 (relavant_tens2 R) M M' Q\n       <- lem27 R M M' Q.\nlem27_lett1 : lem27 (relavant_lett1 R) M M' Q\n       <- lem27 R M M' Q.\nlem27_lett2 : lem27 (relavant_lett2 R) M M' Q\n       <- lem27 (R unit unit) M M' Q.\n%worlds (blam) (lem27 _ _ _ _).\n%freeze lem27.\n%total D (lem27 D _ _ _).\n\nlem28 : {Fs'}{Fs''} ({m:term} frameapply (Fs m) (N m) M1) -> relavant N -> eqf Fs' Fs'' -> type.\n%mode lem28 +Fs' +Fs'' +FA +R -Q.\nlem28_id : lem28 Fs' Fs'' ([m] frameapply_cons _ (F m)) _ Q\n         <- lem26 _ _ F Q.\nlem28_app1 : lem28 Fs' Fs'' ([m] frameapply_cons (FA m)\n                   (frameapp_app : frameapp (fapp (N m)) (M3 m) (app (M3 m) (N m)))) R Q\n         <- lem28 Fs' Fs'' FA (relavant_app1 R) Q.\nlem28_tapp : lem28 Fs' Fs'' ([m] frameapply_cons (FA m)\n                   (frameapp_app : frameapp (ftapp T) (M3 m) (tapp (M3 m) T))) R Q\n         <- lem28 Fs' Fs'' FA (relavant_tapp R) Q.\nlem28_letb : lem28 Fs' Fs'' ([m] frameapply_cons (FA m)\n                   (frameapp_app : frameapp (fletb (N m)) (M3 m) (letb (M3 m) (N m)))) R Q\n         <- lem28 Fs' Fs'' FA (relavant_letb1 R) Q.\nlem28_lett : lem28 Fs' Fs'' ([m] frameapply_cons (FA m)\n                   (frameapp_app : frameapp (flett (N m)) (M3 m) (lett (M3 m) (N m)))) R Q\n         <- lem28 Fs' Fs'' FA (relavant_lett1 R) Q.\nlem28_letu : lem28 Fs' Fs'' ([m] frameapply_cons (FA m)\n                   (frameapp_app : frameapp (fletu (N m)) (M3 m) (letu (M3 m) (N m)))) R Q\n         <- lem28 Fs' Fs'' FA (relavant_letu1 R) Q.\nlem28_nil : lem28 Fs' Fs'' ([m:term] (FA m) : frameapply nil (N2 m) N1) R Q\n         <- ({m} frameapply_nil_eq (FA m) (Q' m))\n         <- eq_relavant Q' R R'\n         <- lem27 R' Fs' Fs'' Q.\n%worlds (blam) (lem28 _ _ _ _ _).\n%freeze lem28.\n%total D (lem28 _ _ D _ _).\n\nlem19 : {M':term}{M:term} ({a} frameapply' (Fs a) a (R a)) -> linear R ->\n                           eqf (Fs M') (Fs M) -> type.\n%mode lem19 +M +M' +FA +L -Q.\n\nlem19_nil : lem19 M M' ([a] frameapply'_nil) L eqf_ref.\n\nlem19_app1 : lem19 M M' ([a] frameapply'_cons (frameapp_app : frameapp (fapp N2) _ _)\n                        (FA a)) (linear_app1 L) Q\n             <- lem19 M M' FA L Q'\n             <- eqf_extend (fapp N2) Q' Q.\n\nlem19_letu1 : lem19 M M' ([a] frameapply'_cons (frameapp_app : frameapp (fletu N2) _ _)\n                         (FA a)) (linear_letu1 L) Q\n             <- lem19 M M' FA L Q'\n             <- eqf_extend (fletu N2) Q' Q.\n\nlem19_lett1 : lem19 M M' ([a] frameapply'_cons (frameapp_app : frameapp (flett N2) _ _)\n                         (FA a)) (linear_lett1 L) Q\n             <- lem19 M M' FA L Q'\n             <- eqf_extend (flett N2) Q' Q.\n\nlem19_letb1 : lem19 M M' ([a] frameapply'_cons (frameapp_app : frameapp (fletb N2) _ _)\n                         (FA a)) (linear_letb1 L) Q\n             <- lem19 M M' FA L Q'\n             <- eqf_extend (fletb N2) Q' Q.\n\nlem19_tapp : lem19 M M' ([a] frameapply'_cons (frameapp_app : frameapp (ftapp N2) _ _) \n                        (FA a)) (linear_tapp L) Q\n             <- lem19 M M' FA L Q'\n             <- eqf_extend (ftapp N2) Q' Q.\n\nlem19_tens1 : lem19 M M' FA (linear_tens1 L) Q\n             <- lem20 M M' ([a] val_tens) FA Q.\n\nlem19_tens2 : lem19 M M' FA (linear_tens2 L) Q\n             <- lem20 M M' ([a] val_tens) FA Q.\n\nlem19_lam : lem19 M M' FA (linear_lam L) Q\n             <- lem20 M M' ([a] val_lam) FA Q.\n\nlem19_tlam : lem19 M M' FA (linear_tlam L) Q\n             <- lem20 M M' ([a] val_tlam) FA Q.\n\nlem19_app2 : lem19 M M' ([a] frameapply'_cons (frameapp_app : frameapp (fapp (N2 a)) _ _)\n                        (FA a : frameapply' (Fs a) a M1)) (linear_app2 L) Q\n            <- ({y:term} revFs_exists (Fs y) nil (Rev y))\n            <- ({y:term} frameapply_e1 (Rev y) (FA y) (FA' y))\n            <- lem28 _ _ FA' relavant_id Q.\n\nlem19_letb2 : lem19 M M' ([a] frameapply'_cons (frameapp_app : frameapp (fletb (N2 a)) _ _)\n                         (FA a : frameapply' (Fs a) a M1)) (linear_letb2 L) Q\n            <- ({y:term} revFs_exists (Fs y) nil (Rev y))\n            <- ({y:term} frameapply_e1 (Rev y) (FA y) (FA' y))\n            <- lem28 _ _ FA' relavant_id Q.\n\nlem19_letu2 : lem19 M M' ([a] frameapply'_cons (frameapp_app : frameapp (fletu (N2 a)) _ _)\n                         (FA a : frameapply' (Fs a) a M1)) (linear_letu2 L) Q\n            <- ({y:term} revFs_exists (Fs y) nil (Rev y))\n            <- ({y:term} frameapply_e1 (Rev y) (FA y) (FA' y))\n            <- lem28 _ _ FA' relavant_id Q.\n\nlem19_lett2 : lem19 M M' ([a] frameapply'_cons (frameapp_app : frameapp (flett (N2 a)) _ _)\n                         (FA a : frameapply' (Fs a) a M1)) (linear_lett2 L) Q\n            <- ({y:term} revFs_exists (Fs y) nil (Rev y))\n            <- ({y:term} frameapply_e1 (Rev y) (FA y) (FA' y))\n            <- lem28 _ _ FA' relavant_id Q.\n\n%worlds (blam) (lem19 _ _ _ _ _).\n%total D (lem19 _ _ _ D _).\n\nlem18 : {M':term}{M:term} ({a} frameapply (Fs a) a (R a)) -> linear R -> eqf (Fs M') (Fs M) -> type.\n%mode lem18 +M +M' +FA +L -Q.\n\nlem18_rule : lem18 M M' (FA : {a} frameapply (Fs a) _ _) L Q\n        <- ({a} revFs_exists (Fs a) nil (Rev a))\n        <- ({a} frameapply_e2 (Rev a) (FA a) (FA' a))\n        <- lem19 M M' FA' L Q'\n        <- rev_eq2 Q' (Rev M) R\n        <- rev_injective R (Rev M') Q.\n\n%worlds (blam) (lem18 _ _ _ _ _).\n%total {} (lem18 _ _ _ _ _).\n\napply_linear : linear M -> linear N -> linear R -> ({a} frameapply' (Fs a) (N a) (R a)) ->\n                      ({a} frameapply' (Fs a) (M (N a)) (R' a)) -> linear R' -> type.\n%mode apply_linear +LM +LN +LR +FA -FA' -LR'.\n\napply_linear_nil : apply_linear LM LN LR ([a:term] frameapply'_nil) ([a:term] frameapply'_nil) LR'\n                       <- sub_linear LM LN LR'.\n\napply_linear_app1 : apply_linear LM LN (linear_app1 L)\n                                 ([a:term] frameapply'_cons (frameapp_app : frameapp (fapp M2) _ _)\n                                                            (FA a))\n                                 ([a:term] frameapply'_cons (frameapp_app) (FA' a))\n                                 (linear_app1 LR')\n                          <- apply_linear LM LN L FA FA' LR'.\n\napply_linear_tapp1 : apply_linear LM LN (linear_tapp L)\n                                  ([a:term] frameapply'_cons (frameapp_app : frameapp (ftapp M2) _ _)\n                                                             (FA a))\n                                  ([a:term] frameapply'_cons (frameapp_app) (FA' a))\n                                  (linear_tapp LR')\n                          <- apply_linear LM LN L FA FA' LR'.\n\napply_linear_letu1 : apply_linear LM LN (linear_letu1 L)\n                                  ([a:term] frameapply'_cons (frameapp_app : frameapp (fletu M2) _ _)\n                                                             (FA a)) \n                                  ([a:term] frameapply'_cons (frameapp_app) (FA' a)) (linear_letu1 LR')\n                          <- apply_linear LM LN L FA FA' LR'.\n\napply_linear_letb1 : apply_linear LM LN (linear_letb1 L) \n                                  ([a:term] frameapply'_cons (frameapp_app : frameapp (fletb M2) _ _)\n                                                             (FA a)) \n                                  ([a:term] frameapply'_cons (frameapp_app) (FA' a)) (linear_letb1 LR')\n                          <- apply_linear LM LN L FA FA' LR'.\n\napply_linear_lett1 : apply_linear LM LN (linear_lett1 L)\n                                  ([a:term] frameapply'_cons (frameapp_app : frameapp (flett M2) _ _)\n                                                             (FA a)) \n                                  ([a:term] frameapply'_cons (frameapp_app) (FA' a)) (linear_lett1 LR')\n                          <- apply_linear LM LN L FA FA' LR'.\n\napply_linear_app2 : apply_linear (LM : linear M) LN (linear_app2 L)\n                                  ([a:term] frameapply'_cons (frameapp_app : frameapp (fapp _) _ _)\n                                                             (FA a)) \n                                  ([a:term] frameapply'_cons (frameapp_app) (FA' a)) (linear_app2 L)\n                          <- lem45 M FA FA'.\n\napply_linear_letu2 : apply_linear (LM : linear M) LN (linear_letu2 L)\n                                  ([a:term] frameapply'_cons (frameapp_app : frameapp (fletu _) _ _)\n                                                             (FA a)) \n                                  ([a:term] frameapply'_cons (frameapp_app) (FA' a)) (linear_letu2 L)\n                          <- lem45 M FA FA'.\n\napply_linear_letb2 : apply_linear (LM : linear M) LN (linear_letb2 L)\n                                  ([a:term] frameapply'_cons (frameapp_app : frameapp (fletb _) _ _)\n                                                             (FA a)) \n                                  ([a:term] frameapply'_cons (frameapp_app) (FA' a)) (linear_letb2 L)\n                          <- lem45 M FA FA'.\n\napply_linear_lett2 : apply_linear (LM : linear M) LN (linear_lett2 L)\n                                  ([a:term] frameapply'_cons (frameapp_app : frameapp (flett _) _ _)\n                                                             (FA a)) \n                                  ([a:term] frameapply'_cons (frameapp_app) (FA' a)) (linear_lett2 L)\n                          <- lem45 M FA FA'.\n\n%worlds () (apply_linear _ _ _ _ _ _).\n%freeze apply_linear.\n%total D (apply_linear _ _ _ D _ _).\n\napply_lin : linear M -> linear N -> linear R -> ({a} frameapply (Fs a) (N a) (R a)) ->\n                      ({a} frameapply (Fs a) (M (N a)) (R' a)) -> linear R' -> type.\n%mode apply_lin +LM +LN +LR +FA -FA' -LR'.\n\napply_lin_rule : apply_lin LM LN LR (FA : {m} frameapply (Fs m) (N m) _) FA4 L2\n          <- ({m} revFs_exists (Fs m) nil (Rev m : revFs (Fs m) nil (Fs' m)))\n          <- ({m} frameapply_e2 (Rev m) (FA m) (FA' m))\n          <- apply_linear LM LN LR FA' FA2 L2\n          <- ({m} revFs_exists (Fs' m) nil (Rev' m))\n          <- ({m} frameapply_e1 (Rev' m) (FA2 m) (FA3 m))\n          <- ({m} revrev_id (Rev m) (Rev' m) (Q m))\n          <- ({m} eqf_symm (Q m) (Q' m))\n          <- ({m} frameapply_eq (Q' m) (FA3 m) (FA4 m)).\n\n%worlds () (apply_lin _ _ _ _ _ _).\n%freeze apply_lin.\n%total D (apply_lin _ _ _ D _ _).\n\nadd_frame : {F} ({m:term} frameapply (Fs m) m (R m)) -> linear R -> \n            ({m:term} frameapply (cons F (Fs m)) m (R' m)) -> linear R' -> type.\n%mode add_frame +M +FA +L -FA' -L'.\n\nadd_frame_app : add_frame (fapp M) FA LR ([m] frameapply_cons (FA' m) frameapp_app) L'\n              <- apply_lin (linear_app1 linear_id : linear ([a] app a M)) linear_id LR FA FA' L'.\n\nadd_frame_tapp : add_frame (ftapp T) FA LR ([m] frameapply_cons (FA' m) frameapp_app) L'\n              <- apply_lin (linear_tapp linear_id : linear ([a] tapp a T)) linear_id LR FA FA' L'.\n\nadd_frame_lett : add_frame (flett M) FA LR ([m] frameapply_cons (FA' m) frameapp_app) L'\n              <- apply_lin (linear_lett1 linear_id : linear ([a] lett a M)) linear_id LR FA FA' L'.\n\nadd_frame_letb : add_frame (fletb M) FA LR ([m] frameapply_cons (FA' m) frameapp_app) L'\n              <- apply_lin (linear_letb1 linear_id : linear ([a] letb a M)) linear_id LR FA FA' L'.\n\nadd_frame_letu : add_frame (fletu M) FA LR ([m] frameapply_cons (FA' m) frameapp_app) L'\n              <- apply_lin (linear_letu1 linear_id : linear ([a] letu a M)) linear_id LR FA FA' L'.\n\n%worlds () (add_frame _ _ _ _ _).\n%freeze add_frame.\n%total {} (add_frame _ _ _ _ _).\n</twelf>\n\n===Strictness lemma preparations===\nNow we are ready for the strictness lemma.\n\n===Height preservation===\nThe proof relies on complete induction on the height of a derivation which is a little troublesome in Twelf.\n<twelf>\nnat : type.\n\nzero : nat.\nsucc : nat -> nat.\n\nheight_ok : frameterm _ _ -> nat -> type.\nheight_ok_bot : height_ok (frameterm_val _) N.\nheight_ok_app : height_ok (frameterm_app F)     ((succ N)) <- height_ok F (N).\nheight_ok_tapp : height_ok (frameterm_tapp F)   ((succ N)) <- height_ok F (N).\nheight_ok_letu : height_ok (frameterm_letu F)   ((succ N)) <- height_ok F (N).\nheight_ok_lett : height_ok (frameterm_lett F)   ((succ N)) <- height_ok F (N).\nheight_ok_letb : height_ok (frameterm_letb F)   ((succ N)) <- height_ok F (N).\nheight_ok_lam : height_ok (frameterm_lam F)     ((succ N)) <- height_ok F (N).\nheight_ok_tlam : height_ok (frameterm_tlam F)   ((succ N)) <- height_ok F (N).\nheight_ok_unit : height_ok (frameterm_unit F)   ((succ N)) <- height_ok F (N).\nheight_ok_tens : height_ok (frameterm_tens F)   ((succ N)) <- height_ok F (N).\nheight_ok_thunk : height_ok (frameterm_thunk F) ((succ N)) <- height_ok F (N).\n\nheight_ok_exists : {ft:frameterm Fs M} height_ok ft N -> type.\n%mode height_ok_exists +FT -H.\nheight_ok_exists_bot : height_ok_exists (frameterm_val _) (height_ok_bot : height_ok _ zero).\nheight_ok_exists_app : height_ok_exists (frameterm_app Ft) (height_ok_app H)\n                          <- height_ok_exists Ft H.\nheight_ok_exists_tapp : height_ok_exists (frameterm_tapp Ft) (height_ok_tapp H)\n                          <- height_ok_exists Ft H.\nheight_ok_exists_letu : height_ok_exists (frameterm_letu Ft) (height_ok_letu H)\n                          <- height_ok_exists Ft H.\nheight_ok_exists_lett : height_ok_exists (frameterm_lett Ft) (height_ok_lett H)\n                          <- height_ok_exists Ft H.\nheight_ok_exists_letb : height_ok_exists (frameterm_letb Ft) (height_ok_letb H)\n                          <- height_ok_exists Ft H.\nheight_ok_exists_lam : height_ok_exists (frameterm_lam Ft) (height_ok_lam H)\n                          <- height_ok_exists Ft H.\nheight_ok_exists_tlam : height_ok_exists (frameterm_tlam Ft) (height_ok_tlam H)\n                          <- height_ok_exists Ft H.\nheight_ok_exists_unit : height_ok_exists (frameterm_unit Ft) (height_ok_unit H)\n                          <- height_ok_exists Ft H.\nheight_ok_exists_tens : height_ok_exists (frameterm_tens Ft) (height_ok_tens H)\n                          <- height_ok_exists Ft H.\nheight_ok_exists_thunk : height_ok_exists (frameterm_thunk Ft) (height_ok_thunk H)\n                          <- height_ok_exists Ft H.\n%worlds () (height_ok_exists _ _).\n%total D (height_ok_exists D _).\n\nsucc_height_ok : height_ok Ft N -> height_ok Ft (succ N) -> type.\n%mode succ_height_ok +H -H'.\nsucc_height_ok_bot : succ_height_ok height_ok_bot height_ok_bot.\nsucc_height_ok_app : succ_height_ok (height_ok_app H) (height_ok_app H')\n                         <- succ_height_ok H H'.\nsucc_height_ok_tapp : succ_height_ok (height_ok_tapp H) (height_ok_tapp H')\n                         <- succ_height_ok H H'.\nsucc_height_ok_letu : succ_height_ok (height_ok_letu H) (height_ok_letu H')\n                         <- succ_height_ok H H'.\nsucc_height_ok_lett : succ_height_ok (height_ok_lett H) (height_ok_lett H')\n                         <- succ_height_ok H H'.\nsucc_height_ok_letb : succ_height_ok (height_ok_letb H) (height_ok_letb H')\n                         <- succ_height_ok H H'.\nsucc_height_ok_lam : succ_height_ok (height_ok_lam H) (height_ok_lam H')\n                         <- succ_height_ok H H'.\nsucc_height_ok_tlam : succ_height_ok (height_ok_tlam H) (height_ok_tlam H')\n                         <- succ_height_ok H H'.\nsucc_height_ok_unit : succ_height_ok (height_ok_unit H) (height_ok_unit H')\n                         <- succ_height_ok H H'.\nsucc_height_ok_tens : succ_height_ok (height_ok_tens H) (height_ok_tens H')\n                         <- succ_height_ok H H'.\nsucc_height_ok_thunk : succ_height_ok (height_ok_thunk H) (height_ok_thunk H')\n                         <- succ_height_ok H H'.\n%worlds () (succ_height_ok _ _).\n%total D (succ_height_ok D _).\n\nframeterm_eq_framesNum : eqf Fs Fs' -> eq M M' -> {Ft : frameterm Fs M} height_ok Ft Num ->\n                                                  {Ft':frameterm Fs' M'} height_ok Ft' Num -> type.\n%mode frameterm_eq_framesNum +Q +Q' +Ft +H -Ft' -H'.\nframeterm_eq_framesNum_rule : frameterm_eq_framesNum eqf_ref eq_ref Ft H Ft H.\n%worlds () (frameterm_eq_framesNum _ _ _ _ _ _).\n%total {} (frameterm_eq_framesNum _ _ _ _ _ _).\n</twelf>\n\n====Height reducing inversions====\n<twelf>\nup_app : {ft:frameterm Fs (app M1 M2)} height_ok ft (succ N) ->\n         {ft':frameterm (cons (fapp M2) Fs) M1} height_ok ft' N -> type.\n%mode up_app +FT +H -FT' -H'.\nup_app_rule : up_app (frameterm_app F) (height_ok_app H) F H.\n%worlds () (up_app _ _ _ _).\n%total D (up_app D _ _ _).\n\nup_tapp : {ft:frameterm Fs (tapp M T)} height_ok ft (succ N) -> \n          {ft':frameterm (cons (ftapp T) Fs) M} height_ok ft' N -> type.\n%mode up_tapp +FT +H -FT' -H'.\nup_tapp_rule : up_tapp (frameterm_tapp F) (height_ok_tapp H) F H.\n%worlds () (up_tapp _ _ _ _).\n%total D (up_tapp D _ _ _).\n\nup_lett : {ft:frameterm Fs (lett M1 M2)} height_ok ft (succ N) ->\n          {ft':frameterm (cons (flett M2) Fs) M1} height_ok ft' N -> type.\n%mode up_lett +FT +H -FT' -H'.\nup_lett_rule : up_lett (frameterm_lett F) (height_ok_lett H) F H.\n%worlds () (up_lett _ _ _ _).\n%total D (up_lett D _ _ _).\n\nup_letu : {ft:frameterm Fs (letu M1 M2)} height_ok ft (succ N) ->\n          {ft':frameterm (cons (fletu M2) Fs) M1} height_ok ft' N -> type.\n%mode up_letu +FT +H -FT' -H'.\nup_letu_rule : up_letu (frameterm_letu F) (height_ok_letu H) F H.\n%worlds () (up_letu _ _ _ _).\n%total D (up_letu D _ _ _).\n\nup_letb : {ft:frameterm Fs (letb M1 M2)} height_ok ft (succ N) ->\n          {ft':frameterm (cons (fletb M2) Fs) M1} height_ok ft' N -> type.\n%mode up_letb +FT +H -FT' -H'.\nup_letb_rule : up_letb (frameterm_letb F) (height_ok_letb H) F H.\n%worlds () (up_letb _ _ _ _).\n%total D (up_letb D _ _ _).\n\nup_lam : {ft:frameterm (cons (fapp M2) Fs) (lam T M1')} height_ok ft (succ N) ->\n         {ft':frameterm Fs (M1' M2 )} height_ok ft' N -> type.\n%mode up_lam +FT +H -FT' -H'.\nup_lam_rule : up_lam (frameterm_lam F) (height_ok_lam H) F H.\n%worlds () (up_lam _ _ _ _).\n%total D (up_lam D _ _ _).\n\nup_tlam : {ft:frameterm (cons (ftapp T) Fs) (tlam M)} height_ok ft (succ N) ->\n          {ft':frameterm Fs (M T)} height_ok ft' N -> type.\n%mode up_tlam +FT +H -FT' -H'.\nup_tlam_rule : up_tlam (frameterm_tlam F) (height_ok_tlam H) F H.\n%worlds () (up_tlam _ _ _ _).\n%total D (up_tlam D _ _ _).\n\nup_tens : {ft:frameterm (cons (flett M3) Fs) (tens M1 M2)} height_ok ft (succ N) ->\n          {ft':frameterm Fs (M3 M1 M2)} height_ok ft' N -> type.\n%mode up_tens +FT +H -FT' -H'.\nup_tens_rule : up_tens (frameterm_tens F) (height_ok_tens H) F H.\n%worlds () (up_tens _ _ _ _).\n%total D (up_tens D _ _ _).\n\nup_unit : {ft:frameterm (cons (fletu M) Fs) unit} height_ok ft (succ N) ->\n          {ft':frameterm Fs M} height_ok ft' N -> type.\n%mode up_unit +FT +H -FT' -H'.\nup_unit_rule : up_unit (frameterm_unit F) (height_ok_unit H) F H.\n%worlds () (up_unit _ _ _ _).\n%total D (up_unit D _ _ _).\n\nup_thunk : {ft:frameterm (cons (fletb M2) Fs) (thunk T M1)} height_ok ft (succ N) ->\n           {ft':frameterm Fs (M2 (letb (thunk T M1) M1))} height_ok ft' N -> type.\n%mode up_thunk +FT +H -FT' -H'.\nup_thunk_rule : up_thunk (frameterm_thunk F) (height_ok_thunk H) F H.\n%worlds () (up_thunk _ _ _ _).\n%total D (up_thunk D _ _ _).\n</twelf>\n\n===Special cases of type preservation===\n<twelf>\ntypes_pres_app1_s : M \\s/ V -> app M N ? T -> app V N ? T -> type.\n%mode types_pres_app1_s +E +D -D'.\ntypes_pres_app1_s_rule : types_pres_app1_s E (of_app D2 D1) (of_app D2 D1')\n          <- tpres_s D1 E D1'.\n%worlds () (types_pres_app1_s _ _ _).\n%total {} (types_pres_app1_s _ _ _).\n\ntypes_pres_app2_s : M \\s/ V -> app N M ? T -> app N V ? T -> type.\n%mode types_pres_app2_s +E +D -D'.\ntypes_pres_app2_s_rule : types_pres_app2_s E (of_app D2 D1) (of_app D2' D1)\n          <- tpres_s D2 E D2'.\n%worlds () (types_pres_app2_s _ _ _).\n%total {} (types_pres_app2_s _ _ _).\n\ntypes_pres_tapp_s :M \\s/ V -> tapp M T ? T' -> tapp V T ? T' -> type.\n%mode types_pres_tapp_s +E +D -D'.\ntypes_pres_tapp_s_rule : types_pres_tapp_s E (of_tapp T D1) (of_tapp T D1')\n                    <- tpres_s D1 E D1'.\n%worlds () (types_pres_tapp_s _ _ _).\n%total {} (types_pres_tapp_s _ _ _).\n\ntypes_pres_letu_s : M \\s/ V -> letu M N ? T -> letu V N ? T -> type.\n%mode types_pres_letu_s +E +D -D'.\ntypes_pres_letu_s_rule : types_pres_letu_s E (of_letu D2 D1) (of_letu D2 D1')\n          <- tpres_s D1 E D1'.\n%worlds () (types_pres_letu_s _ _ _).\n%total {} (types_pres_letu_s _ _ _).\n\ntypes_pres_lett_s : M \\s/ V -> lett M N ? T -> lett V N ? T -> type.\n%mode types_pres_lett_s +E +D -D'.\ntypes_pres_lett_s_rule : types_pres_lett_s E (of_lett L1 L2 D2 D1) (of_lett L1 L2 D2 D1')\n          <- tpres_s D1 E D1'.\n%worlds () (types_pres_lett_s _ _ _).\n%total {} (types_pres_lett_s _ _ _).\n\ntypes_pres_letb_s : M \\s/ V -> letb M N ? T -> letb V N ? T -> type.\n%mode types_pres_letb_s +E +D -D'.\ntypes_pres_letb_s_rule : types_pres_letb_s E (of_letb D2 D1) (of_letb D2 D1')\n          <- tpres_s D1 E D1'.\n%worlds () (types_pres_letb_s _ _ _).\n%freeze types_pres_letb_s.\n%total {} (types_pres_letb_s _ _ _).\n\nredex_rev_type : redex M M' -> M ? T -> M' ? T -> type.\n%mode redex_rev_type +R +D -D'.\n\nredex_rev_type_app : redex_rev_type redex_app (of_app D2 D1) (D1' _ D2)\n         <- inverse_lam D1 D1' _.\n\nredex_rev_type_tapp : redex_rev_type redex_tapp (of_tapp T (of_tlam D1)) (D1 T).\n\nredex_rev_type_letu : redex_rev_type redex_letu (of_letu D2 D1) D2.\n\nredex_rev_type_lett : redex_rev_type redex_lett (of_lett _ _ D3 (of_tens D2 D1)) (D3 _ D1 _ D2).\n\nredex_rev_type_letb : redex_rev_type redex_letb (of_letb D2 (of_thunk D1)) (D2 _ (of_letb D1 (of_thunk D1))).\n\n%worlds () (redex_rev_type _ _ _).\n%total {} (redex_rev_type _ _ _).\n</twelf>\n\n===The actual lemma===\n<twelf>\nstrictness_base : {N}{M} (N M) ? bang T -> linear N -> value (N M) -> value M -> type.\n%mode strictness_base +N +M +D +L +V -V'.\nstrictness_base_rule : strictness_base _ _ _ linear_id V V.\n%worlds () (strictness_base _ _ _ _ _ _).\n%total {} (strictness_base _ _ _ _ _ _).\n\nstrictness_lem1 :\n      % Assumptions:\n             {N} {Fs} {Num : nat} {Ft:frameterm (Fs M) (N M)} height_ok Ft Num -> \n             ({a} frameapply (Fs a) (N a) (FsN a)) -> linear FsN ->\n             fstp (Fs M) T1 (bang T2) -> N M ? T1 -> % frameterm (Fs M) (N M) -> \n      % Conclusion:\n             {Ft2 : frameterm (Fs V) (N V)}  M \\s/ V -> \n             height_ok Ft2 Num -> type.\n\n%mode strictness_lem1 +N +Fs +Num +FtM +H +FA +L +FsT +DNM -FtV -EVs -H2.\n\nstrictness_lem1_base : strictness_lem1 N ([a] nil) Num (frameterm_val V) H FA L FsTp DNM \n                                       (frameterm_val V) Evs H\n         <- frameapply_nil_eq (FA M) Q\n         <- eq_val Q V V'\n         <- applysound nil FsTp DNM (FA M) DNMB\n         <- strictness_base _ M DNMB L V' VM\n         <- selfevals VM Evs.\n\nstrictness_lem1_app2 : strictness_lem1 ([a] a) Fs _ (frameterm_app Ft) (height_ok_app H)\n                                        FA L FsTp\n                                        D3 Ft6 (evs_app EvM12 EvM2 EvM1') H7\n                <- lem18 (app M1 M2) M1 FA L Q\n                <- frameterm_eq_framesNum Q eq_ref (frameterm_app Ft) (height_ok_app H) Ft1 H1\n                <- up_app Ft1 H1 Ft2 H2\n                <- eqf_fstp Q FsTp FsTp1\n                <- typed_step FsTp1 D3 evfs_app FsTp' D3'\n                <- add_frame (fapp M2) FA L FA' L'\n                <- eq_typings D3 (of_app _ D1)\n                <- strictness_lem1 ([a] a) ([a] cons (fapp M2) (Fs a)) _ Ft2 H2 FA' L' FsTp' D3' \n                                    Ft2' (EvM1 : M1 \\s/ V1) H2'\n                <- tpres_s D1 EvM1 D1'\n                <- value_soundness_s EvM1 Val1\n                <- eq_val_funs Val1 D1' Q1\n                <- eq_type Q1 D1' D1''\n                <- eq_typings D1'' (of_lam (L1 : linear M1') D1''')\n                <- succ_height_ok H2' H2''\n                <- frameterm_eq_framesNum eqf_ref Q1 Ft2' H2'' Ft3 H3\n                <- up_lam Ft3 H3 Ft3' H3'\n                <- lem18 V1 M2 FA L Q2\n                <- frameterm_eq_framesNum Q2 eq_ref Ft3' H3' Ft4 H4\n                <- apply_lin L1 linear_id L FA FA2 L2\n                <- types_pres_app1_s EvM1 D3 D3''\n                <- eq_ctx Q1 ([a] app a M2) Q1'\n                <- eq_type Q1' D3'' D4\n                <- redex_rev_type redex_app D4 D4'\n                <- lem18 (app M1 M2) M2 FA L Q3\n                <- eqf_fstp Q3 FsTp FsTp2\n                <- strictness_lem1 M1' Fs _ Ft4 H4 FA2 L2 FsTp2 D4' Ft4' (EvM2 : M2 \\s/ V2) H4'\n                <- lem18 V2 (M1' V2) FA L Q5\n                <- frameterm_eq_framesNum Q5 eq_ref Ft4' H4' Ft5 H5\n                <- types_pres_app2_s EvM2 D4 D5\n                <- redex_rev_type redex_app D5 D5'\n                <- lem18 M2 (M1' V2) FA L Q6\n                <- eqf_fstp Q6 FsTp2 FsTp3\n                <- strictness_lem1 ([a] a) Fs _ Ft5 H5 FA L FsTp3 D5' Ft6 EvM12 H6\n                <- eq_res_s Q1 EvM1 EvM1'\n                <- succ_height_ok H6 H7.\n\nstrictness_lem1_tapp2 : strictness_lem1 ([a] a) Fs _ Ft H FA L FsTp D2\n                                         Ft4' (evs_tapp EvM1'T EvM1') H5\n                <- lem18 (tapp M1 T1) M1 FA L Q\n                <- frameterm_eq_framesNum Q eq_ref Ft H Ft1 H1\n                <- up_tapp Ft1 H1 Ft2 H2\n                <- eqf_fstp Q FsTp FsTp1\n                <- inverse_tapp D2 D1\n                <- typed_step FsTp1 D2 evfs_tapp FsTp' D2'\n                <- add_frame (ftapp T1) FA L FA' L'\n                <- strictness_lem1 ([a] a) ([a] cons (ftapp T1) (Fs a)) _ Ft2 H2 FA' L' FsTp' D2'\n                                    Ft2' (EvM1 : M1 \\s/ V1) H2'\n                <- tpres_s D1 EvM1 D1'\n                <- value_soundness_s EvM1 Val1\n                <- eq_val_all Val1 D1' Q1\n                <- eq_type Q1 D1' D1''\n                <- eq_typings D1'' (of_tlam (D1''' : {t:tp} M1' t ? _))\n                <- succ_height_ok H2' H2''\n                <- frameterm_eq_framesNum eqf_ref Q1 Ft2' H2'' Ft2'' H2'''\n                <- up_tlam Ft2'' H2''' Ft3 H3\n                <- types_pres_tapp_s EvM1 D2 D3\n                <- eq_ctx Q1 ([a] tapp a T1) Q1'\n                <- eq_type Q1' D3 D4\n                <- redex_rev_type redex_tapp D4 D4'\n                <- lem18 M1 (M1' T1) FA L Q2\n                <- eqf_fstp Q2 FsTp1 FsTp1'\n                <- lem18 V1 (M1' T1) FA L Q3\n                <- frameterm_eq_framesNum Q3 eq_ref Ft3 H3 Ft4 H4\n                <- strictness_lem1 ([a] a) Fs _ Ft4 H4 FA L FsTp1' D4' Ft4' EvM1'T H4'\n                <- eq_res_s Q1 EvM1 EvM1'\n                <- succ_height_ok H4' H5.\n\nstrictness_lem1_lett2 : strictness_lem1 ([a] a) Fs _ Ft H\n                        FA L FsTp D3 Ft4' (evs_lett EvM2 EvM1') H5\n                <- lem18 (lett M1 M2) M1 FA L Q\n                <- frameterm_eq_framesNum Q eq_ref Ft H Ft1 H1\n                <- up_lett Ft1 H1 Ft2 H2\n                <- eqf_fstp Q FsTp FsTp1\n                <- typed_step FsTp1 D3 evfs_lett FsTp' D3'\n                <- add_frame (flett M2) FA L FA' L'\n                <- strictness_lem1 ([a] a) ([a] cons (flett M2) (Fs a)) _ Ft2 H2 FA' L' FsTp' D3'\n                                    Ft2' (EvM1 : M1 \\s/ V1) H2'\n                <- eq_typings D3 (of_lett _ _ _ D1)\n                <- tpres_s D1 EvM1 D1'\n                <- value_soundness_s EvM1 Val1\n                <- eq_val_tensor Val1 D1' Q1\n                <- eq_type Q1 D1' D1''\n                <- eq_typings D1'' (of_tens (Dt2 : Mt2 ? _) (Dt1 : Mt1 ? _))\n                <- succ_height_ok H2' H2''\n                <- frameterm_eq_framesNum eqf_ref Q1 Ft2' H2'' Ft3 H3\n                <- up_tens Ft3 H3 Ft3' H3'\n                <- types_pres_lett_s EvM1 D3 D4\n                <- eq_ctx Q1 ([a] lett a M2) Q1'\n                <- eq_type Q1' D4 D4''\n                <- redex_rev_type redex_lett D4'' D4'\n                <- lem18 M1 (M2 Mt1 Mt2) FA L Q2\n                <- eqf_fstp Q2 FsTp1 FsTp1'\n                <- lem18 V1 (M2 Mt1 Mt2) FA L Q3\n                <- frameterm_eq_framesNum Q3 eq_ref Ft3' H3' Ft4 H4\n                <- strictness_lem1 ([a] a) Fs _ Ft4 H4 FA L FsTp1' D4' Ft4' EvM2 H4'\n                <- eq_res_s Q1 EvM1 EvM1'\n                <- succ_height_ok H4' H5.\n\nstrictness_lem1_letu2 : strictness_lem1 ([a] a) Fs _ Ft H \n                                        FA L FsTp D3 Ft4' (evs_letu EvM2 EvM1') H5\n                <- lem18 (letu M1 M2) M1 FA L Q\n                <- frameterm_eq_framesNum Q eq_ref Ft H Ft1 H1\n                <- up_letu Ft1 H1 Ft2 H2\n                <- eqf_fstp Q FsTp FsTp1\n                <- typed_step FsTp1 D3 evfs_letu FsTp' D3'\n                <- add_frame (fletu M2) FA L FA' L'\n                <- strictness_lem1 ([a] a) ([a] cons (fletu M2) (Fs a)) _ Ft2 H2 FA' L' FsTp' D3' Ft2'\n                                   (EvM1: M1 \\s/ V1) H2'\n                <- eq_typings D3 (of_letu _ D1)\n                <- tpres_s D1 EvM1 D1'\n                <- value_soundness_s EvM1 Val1\n                <- eq_val_unit Val1 D1' Q1\n                <- succ_height_ok H2' H2''\n                <- frameterm_eq_framesNum eqf_ref Q1 Ft2' H2'' Ft3 H3\n                <- up_unit Ft3 H3 Ft3' H3'\n                <- lem18 V1 M2 FA L Q2\n                <- lem18 M1 M2 FA L Q2'\n                <- frameterm_eq_framesNum Q2 eq_ref Ft3' H3' Ft4 H4\n                <- eqf_fstp Q2' FsTp1 FsTp1'\n                <- types_pres_letu_s EvM1 D3 D3''\n                <- eq_ctx Q1 ([a] letu a M2) Q3\n                <- eq_type Q3 D3'' D4\n                <- redex_rev_type redex_letu D4 D4'\n                <- strictness_lem1 ([a] a) Fs _ Ft4 H4 FA L FsTp1' D4' Ft4' EvM2 H4'\n                <- succ_height_ok H4' H5\n                <- eq_res_s Q1 EvM1 EvM1'.\n\nstrictness_lem1_letb2 : strictness_lem1 ([a] a) Fs _ Ft H \n                                        FA L FsTp D3 Ft4' (evs_letb EvM2 EvM1') H5\n                <- lem18 (letb M1 M2) M1 FA L Q\n                <- frameterm_eq_framesNum Q eq_ref Ft H Ft1 H1\n                <- up_letb Ft1 H1 Ft2 H2\n                <- eqf_fstp Q FsTp FsTp1\n                <- typed_step FsTp1 D3 evfs_letb FsTp' D3'\n                <- add_frame (fletb M2) FA L FA' L'\n                <- strictness_lem1 ([a] a) ([a] cons (fletb M2) (Fs a)) _ Ft2 H2 FA' L' FsTp' D3' Ft2'\n                                   (EvM1 : M1 \\s/ V1) H2'\n                <- eq_typings D3 (of_letb _ D1)\n                <- tpres_s D1 EvM1 D1'\n                <- value_soundness_s EvM1 Val1\n                <- eq_val_bang Val1 D1' Q1\n                <- eq_type Q1 D1' D1''\n                <- eq_thunk_type D1'' Q'\n                <- eqt_symm Q' Q''\n                <- eqt_ctx Q'' ([t] bang t) Q'''\n                <- eq_type1 Q''' D1'' D1'''\n                <- eq_typings D1''' (of_thunk (Dt1 : {m:term}{d:m ? _} (Mt1 m) ? _) : thunk Ty _ ? _)\n                <- succ_height_ok H2' H2''\n                <- frameterm_eq_framesNum eqf_ref Q1 Ft2' H2'' Ft3 H3\n                <- up_thunk Ft3 H3 Ft3' H3'\n                <- types_pres_letb_s EvM1 D3 D4\n                <- eq_ctx Q1 ([a] letb a M2) Q1'\n                <- eq_type Q1' D4 D4''\n                <- redex_rev_type redex_letb D4'' D4'\n                <- lem18 M1 (M2 (letb (thunk Ty Mt1) Mt1)) FA L Q2\n                <- eqf_fstp Q2 FsTp1 FsTp1'\n                <- lem18 V1 (M2 (letb (thunk Ty Mt1) Mt1)) FA L Q3\n                <- frameterm_eq_framesNum Q3 eq_ref Ft3' H3' Ft4 H4\n                <- strictness_lem1 ([a] a) Fs _ Ft4 H4 FA L FsTp1' D4' Ft4' EvM2 H4'\n                <- succ_height_ok H4' H5\n                <- eq_res_s Q1 EvM1 EvM1'.\n\nstrictness_lem1_app1 : strictness_lem1 ([a] app (N1 a) (N2 a)) Fs _ (frameterm_app Ft)\n                                       (height_ok_app H) FA L FsTp (of_app DN2 DN1)\n                                       (frameterm_app Ft') Evs (height_ok_app H')\n         <- strictness_lem1 N1 ([a] cons (fapp (N2 a)) (Fs a)) _ Ft H \n                            ([a] frameapply_cons (FA a) (frameapp_app : frameapp _ _ _))\n                            L (ftp_cons FsTp [a][da] of_app DN2 da) DN1 Ft' Evs H'.\n\nstrictness_lem1_tapp1 : strictness_lem1 ([a] tapp (N1 a) T) Fs _ (frameterm_tapp Ft)\n                                        (height_ok_tapp H) FA L FsTp (of_tapp _ DN1)\n                                        (frameterm_tapp Ft') Evs (height_ok_tapp H')\n         <- strictness_lem1 N1 ([a] cons (ftapp T) (Fs a)) _ Ft H \n                               ([a] frameapply_cons (FA a) (frameapp_app : frameapp _ _ _))\n                               L (ftp_cons FsTp [a][da] of_tapp _ da) DN1 Ft' Evs H'.\n\nstrictness_lem1_letu1 : strictness_lem1 ([a] letu (N1 a) (N2 a)) Fs _ (frameterm_letu Ft)\n                                        (height_ok_letu H) FA L FsTp (of_letu DN2 DN1)\n                                        (frameterm_letu Ft') Evs (height_ok_letu H')\n         <- strictness_lem1 N1 ([a] cons (fletu (N2 a)) (Fs a)) _ Ft H \n                           ([a] frameapply_cons (FA a) (frameapp_app : frameapp _ _ _))\n                           L (ftp_cons FsTp [a][da] of_letu DN2 da) DN1 Ft' Evs H'.\n\nstrictness_lem1_letb1 : strictness_lem1 ([a] letb (N1 a) (N2 a)) Fs _ (frameterm_letb Ft)\n                                        (height_ok_letb H) FA L FsTp (of_letb DN2 DN1)\n                                        (frameterm_letb Ft') Evs (height_ok_letb H')\n         <- strictness_lem1 N1 ([a] cons (fletb (N2 a)) (Fs a)) _ Ft H \n                               ([a] frameapply_cons (FA a) (frameapp_app : frameapp _ _ _))\n                               L (ftp_cons FsTp [a][da] of_letb DN2 da) DN1 Ft' Evs H'.\n\nstrictness_lem1_lett1 : strictness_lem1 ([a] lett (N1 a) (N2 a)) Fs _ (frameterm_lett Ft)\n                                        (height_ok_lett H) FA L FsTp (of_lett L1 L2 DN2 DN1)\n                                        (frameterm_lett Ft') Evs (height_ok_lett H')\n         <- strictness_lem1 N1 ([a] cons (flett (N2 a)) (Fs a)) _ Ft H \n                            ([a] frameapply_cons (FA a) (frameapp_app : frameapp _ _ _))\n                            L (ftp_cons FsTp [a][da] of_lett L1 L2 DN2 da) DN1 Ft' Evs H'.\n\nstrictness_lem1_lam : strictness_lem1 ([a] lam T (M4 a)) ([a] cons (fapp (M5 a)) (Fs a))\n                                      _ (frameterm_lam Ft) (height_ok_lam H)\n                         ([a] frameapply_cons (FA a) (frameapp_app : frameapp (fapp (M5 a)) _ _))\n                          L (ftp_cons FsTp FTp) D2 (frameterm_lam Ft') Evs (height_ok_lam H')\n                <- eq_typings ((FTp : {m} m ? func _ _ -> app m _ ? T2) _ D2) D1\n                <- redex_rev_type redex_app D1 D'\n                <- frame_linear ([m] redex_app) D1 FA L FA1 L1\n                <- strictness_lem1 ([a] M4 a (M5 a)) Fs _ Ft H FA1 L1 FsTp D' Ft' Evs H'.\n\nstrictness_lem1_tens : strictness_lem1 ([a] tens (M3 a) (M4 a)) ([a] cons (flett (M5 a)) \n                           (Fs a)) _ (frameterm_tens Ft) (height_ok_tens H) \n                           ([a] frameapply_cons (FA a) (frameapp_app : frameapp (flett (M5 a)) _ _))\n                            L (ftp_cons FsTp FTp) D2 (frameterm_tens Ft') Evs (height_ok_tens H')\n                <- eq_typings ((FTp : {m} m ? tensor _ _ -> lett m _ ? T2) _ D2) Dt\n                <- redex_rev_type redex_lett Dt D'\n                <- frame_linear ([m] redex_lett) Dt FA L FA1 L'\n                <- strictness_lem1 ([a] M5 a (M3 a) (M4 a)) Fs _ Ft H FA1 L' FsTp D' Ft' Evs H'.\n\nstrictness_lem1_unit : strictness_lem1 ([a] unit) ([a] cons (fletu (M5 a)) (Fs a)) _\n                           (frameterm_unit Ft) (height_ok_unit H) \n                           ([a] frameapply_cons (FA a) (frameapp_app : frameapp (fletu (M5 a)) _ _))\n                            L (ftp_cons FsTp FTp) D2 (frameterm_unit Ft') Evs (height_ok_unit H')\n                <- eq_typings ((FTp : {m} m ? i -> letu m _ ? T2) _ D2) Dt\n                <- redex_rev_type redex_letu Dt D'\n                <- frame_linear ([m] redex_letu) Dt FA L FA1 L'\n                <- strictness_lem1 ([a] M5 a) Fs _ Ft H FA1 L' FsTp D' Ft' Evs H'.\n\nstrictness_lem1_thunk : strictness_lem1 ([a] thunk T (M4 a)) ([a] cons (fletb (M5 a)) (Fs a))\n                           _ (frameterm_thunk Ft) (height_ok_thunk H) \n                           ([a] frameapply_cons (FA a) (frameapp_app : frameapp (fletb (M5 a)) _ _))\n                           L (ftp_cons FsTp FTp) D2 (frameterm_thunk Ft') Evs (height_ok_thunk H')\n                <- eq_typings ((FTp : {m} m ? bang _ -> letb m _ ? T2) _ D2) Dt\n                <- redex_rev_type redex_letb Dt D'\n                <- frame_linear ([m] redex_letb) Dt FA L FA1 L'\n                <- strictness_lem1 ([a] M5 a (letb (thunk T (M4 a)) (M4 a))) Fs _ Ft H FA1 L'\n                                    FsTp D' Ft' Evs H'.\n\nstrictness_lem1_tlam : strictness_lem1 ([a] tlam (M4 a)) ([a] cons (ftapp T) (Fs a))\n                           _ (frameterm_tlam Ft) (height_ok_tlam H) \n                           ([a] frameapply_cons (FA a) (frameapp_app : frameapp (ftapp T) _ _))\n                           L (ftp_cons FsTp FTp) D2 (frameterm_tlam Ft') Evs (height_ok_tlam H')\n                <- eq_typings ((FTp : {m} m ? all _ -> tapp m _ ? T2) _ D2) D1\n                <- redex_rev_type redex_tapp D1 D'\n                <- frame_linear ([m] redex_tapp) D1 FA L FA1 L1\n                <- strictness_lem1 ([a] M4 a T) Fs _ Ft H FA1 L1 FsTp D' Ft' Evs H'.\n\nstrictness_lem1_unit2 : strictness_lem1 ([a] a) Fs _ Ft H FA L FsTp D2 Ft Evs H\n                <- selfevals val_unit Evs.\n\nstrictness_lem1_lam2 : strictness_lem1 ([a] a) Fs _ Ft H FA L FsTp D2 Ft Evs H\n                <- selfevals val_lam Evs.\n\nstrictness_lem1_tlam2 : strictness_lem1 ([a] a) Fs _ Ft H FA L FsTp D2 Ft Evs H\n                <- selfevals val_tlam Evs.\n\nstrictness_lem1_tens2 : strictness_lem1 ([a] a) Fs _ Ft H FA L FsTp D2 Ft Evs H\n                <- selfevals val_tens Evs.\n\nstrictness_lem1_thunk2 : strictness_lem1 ([a] a) Fs _ Ft H FA L FsTp D2 Ft Evs H\n                <- selfevals val_thunk Evs.\n\n%worlds () (strictness_lem1 _ _ _ _ _ _ _ _ _ _ _ _).\n% covers strictness_lem1 +N +Fs +Num +FtM +H +FA +L +FD +FsT -FtV -EVs -H'. \n% terminates D (strictness_lem1 _ _ D _ _ _ _ _ _ _ _ _).\n%total D (strictness_lem1 _ _ D _ _ _ _ _ _ _ _ _).\n\nstrictness1 : (N M) ? bang T' -> linear N -> \n              (N M) \\/ -> M \\s/ V' -> (N V') \\/ -> type.\n%mode strictness1 +D +L +Ev -S -Term.\nstrictness1_rule : strictness1 D1 L (terminate Ev) Evs (terminate Ev')\n           <- eval_frameterm Ev Ft\n           <- height_ok_exists Ft (H : height_ok _ Num)\n           <- strictness_lem1 N ([a:term] nil) Num Ft H ([a] frameapply_nil) L ftp_nil D1 Ft' Evs H'\n           <- frameterm_eval Ft' Ev'.\n%worlds () (strictness1 _ _ _ _ _).\n% covers strictness1 +D +L +Ev -S -Term.\n%total {} (strictness1 _ _ _ _ _).\n\nframeterm_eq_frames : eqf Fs Fs' -> eq M M' -> frameterm Fs M ->\n                                               frameterm Fs' M' -> type.\n%mode frameterm_eq_frames +Q +Q' +Ft -Ft'.\nframeterm_eq_frames_rule : frameterm_eq_frames eqf_ref eq_ref Ft Ft.\n%worlds () (frameterm_eq_frames _ _ _ _).\n%total {} (frameterm_eq_frames _ _ _ _).\n\nstrictness2_lem1 :\n      % Assumptions:\n             {N} {Fs} frameterm (Fs V) (N V) -> M \\s/ V -> \n      % Conclusion:\n             frameterm (Fs M) (N M) -> type.\n             \n\n%mode strictness2_lem1 +N +Fs +FtV +EVs -FtM.\n\nstrictness2_lem1_tens_val  : strictness2_lem1 ([a] tens _ _) ([a] nil) (frameterm_val _) _\n                                              (frameterm_val val_tens).\n\nstrictness2_lem1_unit_val  : strictness2_lem1 ([a] unit) ([a] nil)  (frameterm_val _) _\n                                              (frameterm_val val_unit).\n\nstrictness2_lem1_lam_val   : strictness2_lem1 ([a] lam T _) ([a] nil) (frameterm_val _) _\n                                              (frameterm_val val_lam).\n\nstrictness2_lem1_tlam_val  : strictness2_lem1 ([a] tlam _) ([a] nil) (frameterm_val _) _\n                                              (frameterm_val val_tlam).\n\nstrictness2_lem1_thunk_val : strictness2_lem1 ([a] thunk T _) ([a] nil) (frameterm_val _) _ \n                                              (frameterm_val val_thunk).\n\nstrictness2_lem1_unit2 : strictness2_lem1 ([a] a) Fs Ft evs_unit Ft.\n\nstrictness2_lem1_lam2 : strictness2_lem1 ([a] a) Fs Ft evs_lam Ft.\n\nstrictness2_lem1_tlam2 : strictness2_lem1 ([a] a) Fs Ft evs_tlam Ft.\n\nstrictness2_lem1_tens2 : strictness2_lem1 ([a] a) Fs Ft evs_tens Ft. \n\nstrictness2_lem1_thunk2 : strictness2_lem1 ([a] a) Fs Ft evs_thunk Ft.\n\nstrictness2_lem1_app1 : strictness2_lem1 ([a] app (N1 a) (N2 a)) Fs (frameterm_app Ft) Evs \n                                         (frameterm_app Ft') \n         <- strictness2_lem1 N1 ([a] cons (fapp (N2 a)) (Fs a)) Ft Evs Ft'.\n\nstrictness2_lem1_tapp1 : strictness2_lem1 ([a] tapp (N1 a) T) Fs (frameterm_tapp Ft) Evs \n                                          (frameterm_tapp Ft')\n         <- strictness2_lem1 N1 ([a] cons (ftapp T) (Fs a)) Ft Evs Ft'.\n\nstrictness2_lem1_letu1 : strictness2_lem1 ([a] letu (N1 a) (N2 a)) Fs (frameterm_letu Ft) Evs \n                                          (frameterm_letu Ft') \n         <- strictness2_lem1 N1 ([a] cons (fletu (N2 a)) (Fs a)) Ft Evs Ft'.\n\nstrictness2_lem1_letb1 : strictness2_lem1 ([a] letb (N1 a) (N2 a)) Fs (frameterm_letb Ft) Evs\n                                          (frameterm_letb Ft')\n         <- strictness2_lem1 N1 ([a] cons (fletb (N2 a)) (Fs a)) Ft Evs Ft'.\n\nstrictness2_lem1_lett1 : strictness2_lem1 ([a] lett (N1 a) (N2 a)) Fs (frameterm_lett Ft) Evs\n                                          (frameterm_lett Ft')\n         <- strictness2_lem1 N1 ([a] cons (flett (N2 a)) (Fs a)) Ft Evs Ft'.\n\nstrictness2_lem1_lam : strictness2_lem1 ([a] lam T (M4 a)) ([a] cons (fapp (M5 a)) (Fs a))\n                                        (frameterm_lam Ft) Evs (frameterm_lam Ft') \n                <- strictness2_lem1 ([a] M4 a (M5 a)) Fs Ft Evs Ft'.\n\nstrictness2_lem1_tens : strictness2_lem1 ([a] tens (M3 a) (M4 a)) ([a] cons (flett (M5 a)) (Fs a))\n                                         (frameterm_tens Ft) Evs (frameterm_tens Ft')\n                <- strictness2_lem1 ([a] M5 a (M3 a) (M4 a)) Fs Ft Evs Ft'.\n\nstrictness2_lem1_unit : strictness2_lem1 ([a] unit) ([a] cons (fletu (M5 a)) (Fs a))\n                                         (frameterm_unit Ft) Evs (frameterm_unit Ft')\n                <- strictness2_lem1 ([a] M5 a) Fs Ft Evs Ft'.\n\nstrictness2_lem1_thunk : strictness2_lem1 ([a] thunk T (M4 a)) ([a] cons (fletb (M5 a)) (Fs a))\n                                          (frameterm_thunk Ft) Evs (frameterm_thunk Ft')\n                <- strictness2_lem1 ([a] M5 a (letb (thunk T (M4 a)) (M4 a))) Fs Ft Evs Ft'.\n\nstrictness2_lem1_tlam : strictness2_lem1 ([a] tlam (M4 a)) ([a] cons (ftapp T) (Fs a))\n                                         (frameterm_tlam Ft) Evs (frameterm_tlam Ft')\n                <- strictness2_lem1 ([a] M4 a T) Fs Ft Evs Ft'.\n\nstrictness2_lem1_app2 : strictness2_lem1 ([a] a) Fs Ft1 (evs_app EvM12 EvM2 EvM1) (frameterm_app Ft7)\n                <- strictness2_lem1 ([a] a) Fs Ft1 EvM12 Ft2 \n                <- strictness2_lem1 ([a] M1' a) ([a] (Fs (M1' a))) Ft2 EvM2 Ft4 \n                <- lem42 ([a] Fs a) ([a] a) (redex_app : redex (app (lam T M1') M2) _) Ft4 Ft5\n                <- inverse_ft_app Ft5 Ft6\n                <- strictness2_lem1 ([a] a) ([a] cons (fapp M2) (Fs (app a M2))) Ft6 EvM1 Ft7.\n\nstrictness2_lem1_tapp2 : strictness2_lem1 ([a] a) Fs Ft1 (evs_tapp EvM12 EvM1) (frameterm_tapp Ft5)\n                <- strictness2_lem1 ([a] a) Fs Ft1 EvM12 Ft2 \n                <- lem42 ([a] Fs a) ([a] a) (redex_tapp : redex (tapp (tlam M1') T) _) Ft2 Ft3\n                <- inverse_ft_tapp Ft3 Ft4\n                <- strictness2_lem1 ([a] a) ([a] cons (ftapp T) (Fs (tapp a T))) Ft4 EvM1 Ft5.\n\nstrictness2_lem1_letu2 : strictness2_lem1 ([a] a) Fs Ft1 (evs_letu EvM2 EvM1) (frameterm_letu Ft5)\n                <- strictness2_lem1 ([a] a) Fs Ft1 EvM2 Ft2 \n                <- lem42 ([a] Fs a) ([a] a) (redex_letu : redex (letu unit M2) _) Ft2 Ft3\n                <- inverse_ft_letu Ft3 Ft4\n                <- strictness2_lem1 ([a] a) ([a] cons (fletu M2) (Fs (letu a M2))) Ft4 EvM1 Ft5.\n\nstrictness2_lem1_lett2 : strictness2_lem1 ([a] a) Fs Ft1 (evs_lett EvM2 EvM1) (frameterm_lett Ft5)\n                <- strictness2_lem1 ([a] a) Fs Ft1 EvM2 Ft2 \n                <- lem42 ([a] Fs a) ([a] a) (redex_lett : redex (lett (tens M1 M2) M3) _) Ft2 Ft3\n                <- inverse_ft_lett Ft3 Ft4\n                <- strictness2_lem1 ([a] a) ([a] cons (flett M3) (Fs (lett a M3))) Ft4 EvM1 Ft5.\n\nstrictness2_lem1_letb2 : strictness2_lem1 ([a] a) Fs Ft1 (evs_letb EvM2 EvM1) (frameterm_letb Ft5)\n                <- strictness2_lem1 ([a] a) Fs Ft1 EvM2 Ft2 \n                <- lem42 ([a] Fs a) ([a] a) (redex_letb : redex (letb (thunk T M1) M2) _) Ft2 Ft3\n                <- inverse_ft_letb Ft3 Ft4\n                <- strictness2_lem1 ([a] a) ([a] cons (fletb M2) (Fs (letb a M2))) Ft4 EvM1 Ft5.\n\n%worlds () (strictness2_lem1 _ _ _ _ _).\n% covers strictness2_lem1 +N +Fs +FtV +EVs -FtM. \n% terminates {E D} (strictness2_lem1 _ _ D E _).\n%total {E D} (strictness2_lem1 _ _ D E _).\n\nstrictness21 : {N} (N V) \\/ -> M \\s/ V -> (N M) \\/ -> type.\n%mode strictness21 +N +Term +Ev -Term'.\nstrictness21_rule : strictness21 N (terminate Ev) Evs (terminate Ev')\n           <- eval_frameterm Ev Ft\n           <- strictness2_lem1 N ([a:term] nil) Ft Evs Ft'\n           <- frameterm_eval Ft' Ev'.\n%worlds () (strictness21 _ _ _ _).\n% covers strictness21 +N +Ev -S -Term.\n%total {} (strictness21 _ _ _ _).\n \n\n</twelf>\n\n<twelflink>See all code for this case study</twelflink>. <twelflink check=\"true\">See Twelf's output</twelflink>.\n\n[[Category:Twelf code]]\n{{case study}}"
          },
          "sha1": "8vg57or8gy6dpa3yqzrfa6yxb3h61hz"
        }
      },
      {
        "title": "Linear logic",
        "ns": 0,
        "id": 1732,
        "revision": {
          "id": 4392,
          "parentid": 2921,
          "timestamp": "2007-03-20T07:26:22Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "minor": null,
          "comment": "case study",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 47508,
            "#text": "The fact that the LF type theory uses only unrestricted assumptions has led some to assume that it cannot encode substructural logics such as linear logic.  In fact, LF admits a very elegant encoding of linear logic, given below.  The key idea is a judgement used to enforce the linear use of each linear assumption.\n\n===  The Encoding  ===\n\n==== Syntax ====\n\n<twelf hidden=\"true\">\n%%%%%  Syntax  %%%%%\n\n</twelf>\n<twelf>\n%%%  Types  %%%\ntp\t: type.  %name tp T.\n\n-o\t: tp -> tp -> tp.  %infix right 7 -o.\n*\t: tp -> tp -> tp.  %infix right 10 *.\n&\t: tp -> tp -> tp.  %infix right 9 &.\n+\t: tp -> tp -> tp.  %infix right 8 +.\n!\t: tp -> tp.\nzero\t: tp.\ntop\t: tp.\n\n%% 1 need not be primitive.\none\t: tp\n        = ! top.\n\n\n%%%  Terms  %%%\n\nterm\t: type.  %name term M.\n\nlam\t: (term -> term) -> term.\napp\t: term -> term -> term.\n\ntensor\t: term -> term -> term.\nlett\t: term -> (term -> term -> term) -> term.\n\npair\t: term -> term -> term.\npi1\t: term -> term.\npi2\t: term -> term.\n\nin1\t: term -> term.\nin2\t: term -> term.\ncase\t: term -> (term -> term) -> (term -> term) -> term.\n\nbang\t: term -> term.\nletb\t: term -> (term -> term) -> term.\n\nany\t: term -> term.\n\nunit\t: term.\n\n%% derived syntax for 1\nstar\t: term\n\t= bang unit.\nleto\t: term -> term -> term\n\t= [t1] [t2] letb t1 ([x] t2).\n</twelf>\n\n====  Linearity  ====\n\nLinearity is enforced by employing a linearity judgement for each linear assumption.  The linearity judgement ensures that a variable is used linearly (roughly speaking, exactly once) within its scope.  (For an example of its use, see the rule <tt>of/lam</tt> for linear lambda abstraction below, which ensures that its argument is used linearly within its body.)\n\n<twelf hidden=\"true\">\n\n\n\n%%%%%  Linearity  %%%%%\n</twelf>\n<twelf>\nlinear : (term -> term) -> type.\n</twelf>\n\nFor example, a variable is used linearly in a single occurrence of that variable:\n<twelf>\nlinear/var\t: linear ([x] x).\n</twelf>\n\nA variable is used linearly in a lambda abstraction if it is used linearly in the body.  (The abstraction's argument must also be used linearly in the body, but that is handled separately, by the abstraction's typing rule.)\n\n<twelf>\nlinear/lam\t: linear ([x] lam (M x))\n\t\t   <- ({y} linear ([x] M x y)).\n</twelf>\n\nA variable is used linearly in application, if it is used linearly in one of the two subterms and does not appear at all in the other:\n\n<twelf>\nlinear/app1\t: linear ([x] app (M1 x) M2)\n\t\t   <- linear M1.\nlinear/app2\t: linear ([x] app M1 (M2 x))\n\t\t   <- linear M2.\n</twelf>\n\nThe remaining constructs use the same technique.  Note that there is no rule for <tt>bang</tt>; no linear variable may appear within a <tt>bang</tt>.  Also note that a linear variable need not appear within an <tt>any</tt> (as with <tt>unit</tt>); however, if it does appear, it must be used linearly.\n\n<twelf>\nlinear/tensor1\t: linear ([x] tensor (M1 x) M2)\n\t\t   <- linear M1.\nlinear/tensor2\t: linear ([x] tensor M1 (M2 x))\n\t\t   <- linear M2.\n\nlinear/lett1\t: linear ([x] lett (M1 x) M2)\n\t\t   <- linear M1.\nlinear/lett2\t: linear ([x] lett M1 (M2 x))\n\t\t   <- ({y} {z} linear ([x] M2 x y z)).\n\nlinear/pair\t: linear ([x] pair (M1 x) (M2 x))\n\t\t   <- linear M1\n\t\t   <- linear M2.\n\nlinear/pi1\t: linear ([x] pi1 (M x))\n\t\t   <- linear M.\n\nlinear/pi2\t: linear ([x] pi2 (M x))\n\t\t   <- linear M.\n\nlinear/in1\t: linear ([x] in1 (M x))\n\t\t   <- linear M.\n\nlinear/in2\t: linear ([x] in2 (M x))\n\t\t   <- linear M.\n\nlinear/case1\t: linear ([x] case (M x) M1 M2)\n\t\t   <- linear M.\nlinear/case2\t: linear ([x] case M (M1 x) (M2 x))\n\t\t   <- ({y} linear ([x] M1 x y))\n\t\t   <- ({y} linear ([x] M2 x y)).\n\nlinear/letb1\t: linear ([x] letb (M1 x) M2)\n\t\t   <- linear M1.\nlinear/letb2\t: linear ([x] letb M1 (M2 x))\n\t\t   <- ({y} linear ([x] M2 x y)).\n\nlinear/any1\t: linear ([x] any (M x))\n\t\t   <- linear M.\nlinear/any2\t: linear ([x] any M).\n\nlinear/unit\t: linear ([x] unit).\n\n%% derived rules for 1\nlinear/leto1\t: linear ([x] leto (M1 x) M2)\n\t\t   <- linear M1\n\t\t= [d] linear/letb1 d.\nlinear/leto2\t: linear ([x] leto M1 (M2 x))\n\t\t   <- linear M2\n\t\t= [d] linear/letb2 ([y] d).\n</twelf>\n\n====  Typing rules  ====\n\nThe typing rules are standard for linear logic, except that they must check that the linearity invariants are maintained.  Thus, the typing rule for any construct that binds a linear variable (<tt>lam</tt>, for example) has a premise (or premises) ensuring that such variable(s) are used linearly in their scope.  However, <tt>letb</tt>, which binds an unrestricted variable, does not check for linear usage of that variable.\n\n<twelf hidden=\"true\">\n\n\n\n%%%%%  Typing Rules  %%%%%\n</twelf>\n<twelf>\nof : term -> tp -> type.\n\nof/lam\t\t: of (lam M) (T1 -o T2)\n\t\t   <- ({x} of x T1 -> of (M x) T2)\n\t\t   <- linear M.\n\nof/app\t\t: of (app M1 M2) T2\n\t\t   <- of M1 (T1 -o T2)\n\t\t   <- of M2 T1.\n\nof/tensor\t: of (tensor M1 M2) (T1 * T2)\n\t\t   <- of M1 T1\n\t\t   <- of M2 T2.\n\nof/lett\t\t: of (lett M1 M2) T\n\t\t   <- of M1 (T1 * T2)\n\t\t   <- ({x} of x T1 -> {y} of y T2 -> of (M2 x y) T)\n\t\t   <- ({y} linear ([x] M2 x y))\n\t\t   <- ({x} linear ([y] M2 x y)).\n\nof/pair\t\t: of (pair M1 M2) (T1 & T2)\n\t\t   <- of M1 T1\n\t\t   <- of M2 T2.\n\nof/pi1\t\t: of (pi1 M) T1\n\t\t   <- of M (T1 & T2).\n\nof/pi2\t\t: of (pi2 M) T2\n\t\t   <- of M (T1 & T2).\n\nof/in1\t\t: of (in1 M) (T1 + T2)\n\t\t   <- of M T1.\n\nof/in2\t\t: of (in2 M) (T1 + T2)\n\t\t   <- of M T2.\n\nof/case\t\t: of (case M M1 M2) T\n\t\t   <- of M (T1 + T2)\n\t\t   <- ({x} of x T1 -> of (M1 x) T)\n\t\t   <- ({x} of x T2 -> of (M2 x) T)\n\t\t   <- linear M1\n\t\t   <- linear M2.\n\nof/bang\t\t: of (bang M) (! T)\n\t\t   <- of M T.\n\nof/letb\t\t: of (letb M1 M2) T2\n\t\t   <- of M1 (! T1)\n\t\t   <- ({x} of x T1 -> of (M2 x) T2).\n\nof/any\t\t: of (any M) T\n\t\t   <- of M zero.\n\nof/unit\t\t: of unit top.\n\n%% derived rules for 1\nof/star\t\t: of star one\n\t\t= of/bang of/unit.\n\nof/leto\t\t: of (leto M1 M2) T\n\t\t   <- of M1 one\n\t\t   <- of M2 T\n\t\t= [d2] [d1] of/letb ([x] [d] d2) d1.\n</twelf>\n\n\n===  Subject Reduction  ===\n\nAs a metatheoretic example, we may prove the subject reduction property using this encoding.  First we define the relevant worlds:\n\n<twelf hidden=\"true\">\n\n\n\n%%%%%  Worlds  %%%%%\n</twelf>\n<twelf>\n%block block\t: block {x:term}.\n%block bind\t: some {t:tp} block {x:term} {d:of x t}.\n</twelf>\n\nNext we define reduction:\n\n<twelf hidden=\"true\">\n\n\n\n%%%%%  Reduction  %%%%%\n</twelf>\n<twelf>\nreduce : term -> term -> type.\n\nred/refl\t: reduce M M.\nred/trans\t: reduce M1 M3\n\t\t   <- reduce M1 M2\n\t\t   <- reduce M2 M3.\n\n%% beta rules\nred/beta\t: reduce (app (lam M1) M2) (M1 M2).\nred/beta*\t: reduce (lett (tensor M1 M2) M) (M M1 M2).\nred/beta&1\t: reduce (pi1 (pair M1 M2)) M1.\nred/beta&2\t: reduce (pi2 (pair M1 M2)) M2.\nred/beta+1\t: reduce (case (in1 M) M1 M2) (M1 M).\nred/beta+2\t: reduce (case (in2 M) M1 M2) (M2 M).\nred/beta!\t: reduce (letb (bang M1) M2) (M2 M1).\n\n%% compatibility\nred/lam\t\t: reduce (lam M) (lam M')\n\t\t   <- ({x} reduce (M x) (M' x)).\nred/app\t\t: reduce (app M1 M2) (app M1' M2')\n\t\t   <- reduce M1 M1'\n\t\t   <- reduce M2 M2'.\nred/tensor\t: reduce (tensor M1 M2) (tensor M1' M2')\n\t\t   <- reduce M1 M1'\n\t\t   <- reduce M2 M2'.\nred/lett\t: reduce (lett M1 M2) (lett M1' M2')\n\t\t   <- reduce M1 M1'\n\t\t   <- ({x} {y} reduce (M2 x y) (M2' x y)).\nred/pair\t: reduce (pair M1 M2) (pair M1' M2')\n\t\t   <- reduce M1 M1'\n\t\t   <- reduce M2 M2'.\nred/pi1\t\t: reduce (pi1 M) (pi1 M')\n\t\t   <- reduce M M'.\nred/pi2\t\t: reduce (pi2 M) (pi2 M')\n\t\t   <- reduce M M'.\nred/in1\t\t: reduce (in1 M) (in1 M')\n\t\t   <- reduce M M'.\nred/in2\t\t: reduce (in2 M) (in2 M')\n\t\t   <- reduce M M'.\nred/case        : reduce (case M M1 M2) (case M' M1' M2')\n\t\t   <- reduce M M'\n\t\t   <- ({x} reduce (M1 x) (M1' x))\n\t\t   <- ({x} reduce (M2 x) (M2' x)).\nred/bang\t: reduce (bang M) (bang M')\n\t\t   <- reduce M M'.\nred/letb        : reduce (letb M1 M2) (letb M1' M2')\n\t\t   <- reduce M1 M1'\n\t\t   <- ({x} reduce (M2 x) (M2' x)).\nred/any\t\t: reduce (any M) (any M')\n\t\t   <- reduce M M'.\n\n%% commuting conversions\nred/app/lett\t: reduce\n\t\t   (app (lett M1 M2) M3)\n\t\t   (lett M1 ([x] [y] app (M2 x y) M3)).\nred/app/case\t: reduce\n\t\t   (app (case M1 M2a M2b) M3)\n\t\t   (case M1 ([x] app (M2a x) M3) ([x] app (M2b x) M3)).\nred/app/letb\t: reduce\n\t\t   (app (letb M1 M2) M3)\n\t\t   (letb M1 ([x] app (M2 x) M3)).\nred/app/any\t: reduce\n\t\t   (app (any M1) M2)\n\t\t   (any M1).\n\nred/pi1/lett\t: reduce\n\t\t   (pi1 (lett M1 M2))\n\t\t   (lett M1 ([x] [y] pi1 (M2 x y))).\nred/pi1/case\t: reduce\n\t\t   (pi1 (case M1 M2a M2b))\n\t\t   (case M1 ([x] pi1 (M2a x)) ([x] pi1 (M2b x))).\nred/pi1/letb\t: reduce\n\t\t   (pi1 (letb M1 M2))\n\t\t   (letb M1 ([x] pi1 (M2 x))).\nred/pi1/any\t: reduce\n\t\t   (pi1 (any M))\n\t\t   (any M).\n\nred/pi2/lett\t: reduce\n\t\t   (pi2 (lett M1 M2))\n\t\t   (lett M1 ([x] [y] pi2 (M2 x y))).\nred/pi2/case\t: reduce\n\t\t   (pi2 (case M1 M2a M2b))\n\t\t   (case M1 ([x] pi2 (M2a x)) ([x] pi2 (M2b x))).\nred/pi2/letb\t: reduce\n\t\t   (pi2 (letb M1 M2))\n\t\t   (letb M1 ([x] pi2 (M2 x))).\nred/pi2/any\t: reduce\n\t\t   (pi2 (any M))\n\t\t   (any M).\n\nred/lett/lett\t: reduce\n\t\t   (lett (lett M1 M2) M3)\n\t\t   (lett M1 ([x] [y] lett (M2 x y) M3)).\nred/lett/case\t: reduce\n\t\t   (lett (case M1 M2a M2b) M3)\n\t\t   (case M1 ([x] lett (M2a x) M3) ([x] lett (M2b x) M3)).\nred/lett/letb\t: reduce\n\t\t   (lett (letb M1 M2) M3)\n\t\t   (letb M1 ([x] lett (M2 x) M3)).\nred/lett/any\t: reduce\n\t\t   (lett (any M1) M2)\n\t\t   (any M1).\n\nred/case/lett\t: reduce\n\t\t   (case (lett M1 M2) M3a M3b)\n\t\t   (lett M1 ([x] [y] case (M2 x y) M3a M3b)).\nred/case/case\t: reduce\n\t\t   (case (case M1 M2a M2b) M3a M3b)\n\t\t   (case M1 ([x] case (M2a x) M3a M3b) ([x] case (M2b x) M3a M3b)).\nred/case/letb\t: reduce\n\t\t   (case (letb M1 M2) M3a M3b)\n\t\t   (letb M1 ([x] case (M2 x) M3a M3b)).\nred/case/any\t: reduce\n\t\t   (case (any M1) M2a M2b)\n\t\t   (any M1).\n\nred/letb/lett\t: reduce\n\t\t   (letb (lett M1 M2) M3)\n\t\t   (lett M1 ([x] [y] letb (M2 x y) M3)).\nred/letb/case\t: reduce\n\t\t   (letb (case M1 M2a M2b) M3)\n\t\t   (case M1 ([x] letb (M2a x) M3) ([x] letb (M2b x) M3)).\nred/letb/letb\t: reduce\n\t\t   (letb (letb M1 M2) M3)\n\t\t   (letb M1 ([x] letb (M2 x) M3)).\nred/letb/any\t: reduce\n\t\t   (letb (any M1) M2)\n\t\t   (any M1).\n\nred/any/lett\t: reduce\n\t\t   (any (lett M1 M2))\n\t\t   (lett M1 ([x] [y] any (M2 x y))).\nred/any/case\t: reduce\n\t\t   (any (case M1 M2a M2b))\n\t\t   (case M1 ([x] any (M2a x)) ([x] any (M2b x))).\nred/any/letb\t: reduce\n\t\t   (any (letb M1 M2))\n\t\t   (letb M1 ([x] any (M2 x))).\nred/any/any\t: reduce\n\t\t   (any (any M))\n\t\t   (any M).\n</twelf>\n\n\nNext we define syntactic equality and establish some uninteresting properties about it.\n\n<twelf hidden=\"true\">\n\n\n\n%%%%%  Equality  %%%%%\n</twelf>\n<twelf>\ntp-eq : tp -> tp -> type.\ntp-eq/i\t\t: tp-eq T T.\n\nterm-eq : term -> term -> type.\nterm-eq/i\t: term-eq M M.\n</twelf>\n\n<twelf hidden=\"true\">\n\n\n\n%%%%%  Cons Lemmas  %%%%%\n\nany-resp : term-eq M M' -> term-eq (any M) (any M') -> type.\n%mode any-resp +X1 -X2.\n\n-\t: any-resp term-eq/i term-eq/i.\n\n%worlds (block | bind) (any-resp _ _).\n%total {} (any-resp _ _).\n\n\n\napp-resp : term-eq M1 M1' -> term-eq M2 M2' -> term-eq (app M1 M2) (app M1' M2') -> type.\n%mode app-resp +X1 +X2 -X3.\n\n-\t: app-resp term-eq/i term-eq/i term-eq/i.\n\n%worlds (block | bind) (app-resp _ _ _).\n%total {} (app-resp _ _ _).\n\n\n\nbang-resp : term-eq M M' -> term-eq (bang M) (bang M') -> type.\n%mode bang-resp +X1 -X2.\n\n-\t: bang-resp term-eq/i term-eq/i.\n\n%worlds (block | bind) (bang-resp _ _).\n%total {} (bang-resp _ _).\n\n\n\ncase-resp : term-eq M1 M1' -> ({x} term-eq (M2 x) (M2' x)) -> ({x} term-eq (M3 x) (M3' x)) -> term-eq (case M1 M2 M3) (case M1' M2' M3') -> type.\n%mode case-resp +X1 +X2 +X3 -X4.\n\n-\t: case-resp term-eq/i ([_] term-eq/i) ([_] term-eq/i) term-eq/i.\n\n%worlds (block | bind) (case-resp _ _ _ _).\n%total {} (case-resp _ _ _ _).\n\n\n\nin1-resp : term-eq M M' -> term-eq (in1 M) (in1 M') -> type.\n%mode in1-resp +X1 -X2.\n\n-\t: in1-resp term-eq/i term-eq/i.\n\n%worlds (block | bind) (in1-resp _ _).\n%total {} (in1-resp _ _).\n\n\n\nin2-resp : term-eq M M' -> term-eq (in2 M) (in2 M') -> type.\n%mode in2-resp +X1 -X2.\n\n-\t: in2-resp term-eq/i term-eq/i.\n\n%worlds (block | bind) (in2-resp _ _).\n%total {} (in2-resp _ _).\n\n\n\nlam-resp : ({x} term-eq (M x) (M' x)) -> term-eq (lam M) (lam M') -> type.\n%mode lam-resp +X1 -X2.\n\n-\t: lam-resp ([x] term-eq/i) term-eq/i.\n\n%worlds (block | bind) (lam-resp _ _).\n%total {} (lam-resp _ _).\n\n\n\nletb-resp : term-eq M1 M1' -> ({x} term-eq (M2 x) (M2' x)) -> term-eq (letb M1 M2) (letb M1' M2') -> type.\n%mode letb-resp +X1 +X2 -X3.\n\n-\t: letb-resp term-eq/i ([x] term-eq/i) term-eq/i.\n\n%worlds (block | bind) (letb-resp _ _ _).\n%total {} (letb-resp _ _ _).\n\n\n\nlett-resp : term-eq M1 M1' -> ({x} {y} term-eq (M2 x y) (M2' x y)) -> term-eq (lett M1 M2) (lett M1' M2') -> type.\n%mode lett-resp +X1 +X2 -X3.\n\n-\t: lett-resp term-eq/i ([x] [y] term-eq/i) term-eq/i.\n\n%worlds (block | bind) (lett-resp _ _ _).\n%total {} (lett-resp _ _ _).\n\n\n\npair-resp : term-eq M1 M1' -> term-eq M2 M2' -> term-eq (pair M1 M2) (pair M1' M2') -> type.\n%mode pair-resp +X1 +X2 -X3.\n\n-\t: pair-resp term-eq/i term-eq/i term-eq/i.\n\n%worlds (block | bind) (pair-resp _ _ _).\n%total {} (pair-resp _ _ _).\n\n\n\npi1-resp : term-eq M M' -> term-eq (pi1 M) (pi1 M') -> type.\n%mode pi1-resp +X1 -X2.\n\n-\t: pi1-resp term-eq/i term-eq/i.\n\n%worlds (block | bind) (pi1-resp _ _).\n%total {} (pi1-resp _ _).\n\n\n\npi2-resp : term-eq M M' -> term-eq (pi2 M) (pi2 M') -> type.\n%mode pi2-resp +X1 -X2.\n\n-\t: pi2-resp term-eq/i term-eq/i.\n\n%worlds (block | bind) (pi2-resp _ _).\n%total {} (pi2-resp _ _).\n\n\n\ntensor-resp : term-eq M1 M1' -> term-eq M2 M2' -> term-eq (tensor M1 M2) (tensor M1' M2') -> type.\n%mode tensor-resp +X1 +X2 -X3.\n\n-\t: tensor-resp term-eq/i term-eq/i term-eq/i.\n\n%worlds (block | bind) (tensor-resp _ _ _).\n%total {} (tensor-resp _ _ _).\n\n\n\n\n%%%%%  Respects Lemmas  %%%%%\n\nlinear-resp : ({x} term-eq (M1 x) (M2 x)) -> linear M1 -> linear M2 -> type.\n%mode linear-resp +X1 +X2 -X3.\n\n-\t: linear-resp ([x] term-eq/i) D D.\n\n%worlds (block | bind) (linear-resp _ _ _).\n%total {} (linear-resp _ _ _).\n\n\n\nreduce-resp : term-eq M1 M1' -> term-eq M2 M2' -> reduce M1 M2 -> reduce M1' M2' -> type.\n%mode reduce-resp +X1 +X2 +X3 -X4.\n\n-\t: reduce-resp term-eq/i term-eq/i D D.\n\n%worlds (block | bind) (reduce-resp _ _ _ _).\n%total {} (reduce-resp _ _ _ _).\n%reduces D1 <= D2 (reduce-resp _ _ D2 D1).\n\n\n\n%%%%%  Down to Business  %%%%%\n</twelf>\n\nNext we prove an important lemma: when a variable x is used linearly in a term M1, and M1 is substituted for a linear variable in a term M2 that does not mention x, than x is used linearly in the result.\n\n<twelf>\ncompose-linear : linear M1 -> linear M2 -> linear ([x] M1 (M2 x)) -> type.\n%mode compose-linear +X1 +X2 -X3.\n</twelf>\n\n<twelf hidden=\"true\">\n-\t: compose-linear linear/var D D.\n\n-\t: compose-linear (linear/lam D1) D2 (linear/lam D)\n\t   <- ({y} compose-linear (D1 y) D2 (D y)).\n\n-\t: compose-linear (linear/app1 D1) D2 (linear/app1 D)\n\t   <- compose-linear D1 D2 D.\n-\t: compose-linear (linear/app2 D1) D2 (linear/app2 D)\n\t   <- compose-linear D1 D2 D.\n\n-\t: compose-linear (linear/tensor1 D1) D2 (linear/tensor1 D)\n\t   <- compose-linear D1 D2 D.\n-\t: compose-linear (linear/tensor2 D1) D2 (linear/tensor2 D)\n\t   <- compose-linear D1 D2 D.\n\n-\t: compose-linear (linear/lett1 D1) D2 (linear/lett1 D)\n\t   <- compose-linear D1 D2 D.\n-\t: compose-linear (linear/lett2 D1) D2 (linear/lett2 D)\n\t   <- ({y} {z} compose-linear (D1 y z) D2 (D y z)).\n\n-\t: compose-linear (linear/pair D1b D1a) D2 (linear/pair Db Da)\n\t   <- compose-linear D1a D2 Da\n\t   <- compose-linear D1b D2 Db.\n\n-\t: compose-linear (linear/pi1 D1) D2 (linear/pi1 D)\n\t   <- compose-linear D1 D2 D.\n\n-\t: compose-linear (linear/pi2 D1) D2 (linear/pi2 D)\n\t   <- compose-linear D1 D2 D.\n\n-\t: compose-linear (linear/in1 D1) D2 (linear/in1 D)\n\t   <- compose-linear D1 D2 D.\n\n-\t: compose-linear (linear/in2 D1) D2 (linear/in2 D)\n\t   <- compose-linear D1 D2 D.\n\n-\t: compose-linear (linear/case1 D1) D2 (linear/case1 D)\n\t   <- compose-linear D1 D2 D.\n-\t: compose-linear (linear/case2 D1b D1a) D2 (linear/case2 Db Da)\n\t   <- ({y} compose-linear (D1a y) D2 (Da y))\n\t   <- ({y} compose-linear (D1b y) D2 (Db y)).\n\n-\t: compose-linear (linear/letb1 D1) D2 (linear/letb1 D)\n\t   <- compose-linear D1 D2 D.\n-\t: compose-linear (linear/letb2 D1) D2 (linear/letb2 D)\n\t   <- ({y} compose-linear (D1 y) D2 (D y)).\n\n-\t: compose-linear (linear/any1 D1) D2 (linear/any1 D)\n\t   <- compose-linear D1 D2 D.\n-\t: compose-linear linear/any2 _ linear/any2.\n\n-\t: compose-linear linear/unit _ linear/unit.\n\n%worlds (block | bind) (compose-linear _ _ _).\n%total D (compose-linear D _ _).\n\n\n\n</twelf>\n\nNext we prove a technical lemma.  It states that if x does not appear in M1, and M1 reduces to M2, then x does not appear in M2.\n\n<twelf>\nreduce-closed : ({x:term} reduce M1 (M2 x)) -> ({x:term} term-eq M2' (M2 x)) -> type.\n%mode reduce-closed +X1 -X2.\n</twelf>\n\n<twelf hidden=\"true\">\n-\t: reduce-closed ([x] red/refl) ([x] term-eq/i).\n\nreduce-closed!trans : ({x:term} term-eq M1' (M1 x)) -> ({x:term} reduce (M1 x) (M2 x)) -> ({x:term} term-eq M2' (M2 x)) -> type.\n%mode reduce-closed!trans +X1 +X2 -X3.\n\n-\t: reduce-closed ([x] red/trans (D2 x) (D1 x)) Deq2\n\t   <- reduce-closed D1 Deq1\n\t   <- reduce-closed!trans Deq1 D2 Deq2.\n-\t: reduce-closed!trans ([x] term-eq/i) D Deq\n\t   <- reduce-closed D Deq.\n\n-\t: reduce-closed ([x] red/beta) ([x] term-eq/i).\n-\t: reduce-closed ([x] red/beta*) ([x] term-eq/i).\n-\t: reduce-closed ([x] red/beta&1) ([x] term-eq/i).\n-\t: reduce-closed ([x] red/beta&2) ([x] term-eq/i).\n-\t: reduce-closed ([x] red/beta+1) ([x] term-eq/i).\n-\t: reduce-closed ([x] red/beta+2) ([x] term-eq/i).\n-\t: reduce-closed ([x] red/beta!) ([x] term-eq/i).\n\n-\t: reduce-closed ([x] red/lam (Dred x)) Deq'\n\t   <- ({y} reduce-closed ([x] Dred x y) ([x] Deq x y))\n\t   <- ({x} lam-resp (Deq x) (Deq' x)).\n-\t: reduce-closed ([x] red/app (Dred2 x) (Dred1 x)) Deq\n\t   <- reduce-closed Dred1 Deq1\n\t   <- reduce-closed Dred2 Deq2\n\t   <- ({x} app-resp (Deq1 x) (Deq2 x) (Deq x)).\n\n-\t: reduce-closed ([x] red/tensor (Dred2 x) (Dred1 x)) Deq\n\t   <- reduce-closed Dred1 Deq1\n\t   <- reduce-closed Dred2 Deq2\n\t   <- ({x} tensor-resp (Deq1 x) (Deq2 x) (Deq x)).\n-\t: reduce-closed ([x] red/lett (Dred2 x) (Dred1 x)) Deq\n\t   <- reduce-closed Dred1 Deq1\n\t   <- ({y} {z} reduce-closed ([x] Dred2 x y z) ([x] Deq2 x y z))\n\t   <- ({x} lett-resp (Deq1 x) (Deq2 x) (Deq x)).\n\n-\t: reduce-closed ([x] red/pair (Dred2 x) (Dred1 x)) Deq\n\t   <- reduce-closed Dred1 Deq1\n\t   <- reduce-closed Dred2 Deq2\n\t   <- ({x} pair-resp (Deq1 x) (Deq2 x) (Deq x)).\n-\t: reduce-closed ([x] red/pi1 (Dred x)) Deq'\n\t   <- reduce-closed Dred Deq\n\t   <- ({x} pi1-resp (Deq x) (Deq' x)).\n-\t: reduce-closed ([x] red/pi2 (Dred x)) Deq'\n\t   <- reduce-closed Dred Deq\n\t   <- ({x} pi2-resp (Deq x) (Deq' x)).\n\n-\t: reduce-closed ([x] red/in1 (Dred x)) Deq'\n\t   <- reduce-closed Dred Deq\n\t   <- ({x} in1-resp (Deq x) (Deq' x)).\n-\t: reduce-closed ([x] red/in2 (Dred x)) Deq'\n\t   <- reduce-closed Dred Deq\n\t   <- ({x} in2-resp (Deq x) (Deq' x)).\n-\t: reduce-closed ([x] red/case (Dred3 x) (Dred2 x) (Dred1 x)) Deq'\n\t   <- reduce-closed Dred1 Deq1\n\t   <- ({y} reduce-closed ([x] Dred2 x y) ([x] Deq2 x y))\n\t   <- ({y} reduce-closed ([x] Dred3 x y) ([x] Deq3 x y))\n\t   <- ({x} case-resp (Deq1 x) (Deq2 x) (Deq3 x) (Deq' x)).\n\n-\t: reduce-closed ([x] red/bang (Dred x)) Deq'\n\t   <- reduce-closed Dred Deq\n\t   <- ({x} bang-resp (Deq x) (Deq' x)).\n-\t: reduce-closed ([x] red/letb (Dred2 x) (Dred1 x)) Deq\n\t   <- reduce-closed Dred1 Deq1\n\t   <- ({y} reduce-closed ([x] Dred2 x y) ([x] Deq2 x y))\n\t   <- ({x} letb-resp (Deq1 x) (Deq2 x) (Deq x)).\n\n-\t: reduce-closed ([x] red/any (Dred x)) Deq'\n\t   <- reduce-closed Dred Deq\n\t   <- ({x} any-resp (Deq x) (Deq' x)).\n\n-\t: reduce-closed ([x] red/app/lett) ([x] term-eq/i).\n-\t: reduce-closed ([x] red/app/case) ([x] term-eq/i).\n-\t: reduce-closed ([x] red/app/letb) ([x] term-eq/i).\n-\t: reduce-closed ([x] red/app/any) ([x] term-eq/i).\n-\t: reduce-closed ([x] red/pi1/lett) ([x] term-eq/i).\n-\t: reduce-closed ([x] red/pi1/case) ([x] term-eq/i).\n-\t: reduce-closed ([x] red/pi1/letb) ([x] term-eq/i).\n-\t: reduce-closed ([x] red/pi1/any) ([x] term-eq/i).\n-\t: reduce-closed ([x] red/pi2/lett) ([x] term-eq/i).\n-\t: reduce-closed ([x] red/pi2/case) ([x] term-eq/i).\n-\t: reduce-closed ([x] red/pi2/letb) ([x] term-eq/i).\n-\t: reduce-closed ([x] red/pi2/any) ([x] term-eq/i).\n-\t: reduce-closed ([x] red/lett/lett) ([x] term-eq/i).\n-\t: reduce-closed ([x] red/lett/case) ([x] term-eq/i).\n-\t: reduce-closed ([x] red/lett/letb) ([x] term-eq/i).\n-\t: reduce-closed ([x] red/lett/any) ([x] term-eq/i).\n-\t: reduce-closed ([x] red/case/lett) ([x] term-eq/i).\n-\t: reduce-closed ([x] red/case/case) ([x] term-eq/i).\n-\t: reduce-closed ([x] red/case/letb) ([x] term-eq/i).\n-\t: reduce-closed ([x] red/case/any) ([x] term-eq/i).\n-\t: reduce-closed ([x] red/letb/lett) ([x] term-eq/i).\n-\t: reduce-closed ([x] red/letb/case) ([x] term-eq/i).\n-\t: reduce-closed ([x] red/letb/letb) ([x] term-eq/i).\n-\t: reduce-closed ([x] red/letb/any) ([x] term-eq/i).\n-\t: reduce-closed ([x] red/any/lett) ([x] term-eq/i).\n-\t: reduce-closed ([x] red/any/case) ([x] term-eq/i).\n-\t: reduce-closed ([x] red/any/letb) ([x] term-eq/i).\n-\t: reduce-closed ([x] red/any/any) ([x] term-eq/i).\n\n%worlds (block | bind) (reduce-closed _ _) (reduce-closed!trans _ _ _).\n%total (D1 D2) (reduce-closed D1 _) (reduce-closed!trans _ D2 _).\n\n\n\n</twelf>\n\nWith these lemmas in hand, we can prove the subject reduction theorem.  In fact, there are two theorems to be proved simultaneously.  One (<tt>sr</tt>) states that types are preserved by reduction, and the other (<tt>srl</tt>) states that linearity is preserved by reduction.\n\n<twelf>\nsrl : ({x} reduce (M x) (M' x)) \n       -> ({x} of x T -> of (M x) T') \n       -> linear M \n%%\n       -> linear M' -> type.\n\nsr : reduce M M' \n      -> of M T\n%%\n      -> of M' T -> type.\n%mode srl +X1 +X2 +X3 -X4.\n%mode sr +X1 +X2 -X3.\n</twelf>\n\n<twelf hidden=\"true\">\n-refl\t: srl ([x] red/refl) _ D D.\n\n-trans\t: srl ([x] red/trans (Dred23 x) (Dred12 x)) Dof1 Dlin1 Dlin3\n\t   <- srl Dred12 Dof1 Dlin1 Dlin2\n\t   <- ({x} {d} sr (Dred12 x) (Dof1 x d) (Dof2 x d))\n\t   <- srl Dred23 Dof2 Dlin2 Dlin3.\n\n-beta1\t: srl ([x] red/beta : reduce (app (lam (M1 x)) M2) _)\n\t   ([x] [d] of/app (Dof2 x d : of _ T2) (of/lam (Dlin1 x) (Dof1 x d)))\n\t   (linear/app1 (linear/lam Dlin))\n\t   (Dlin M2).\n-beta2\t: srl ([x] red/beta : reduce (app (lam M1) (M2 x)) _)\n\t   ([x] [d] of/app (Dof2 x d : of _ T2) (of/lam (Dlin1 x) (Dof1 x d)))\n\t   (linear/app2 Dlin)\n\t   Dlin'\n\t   <- compose-linear (Dlin1 unit) Dlin Dlin'.\n\t  \n-bet*11\t: srl ([x] red/beta* : reduce (lett (tensor (M1 x) M2) M) _)\n\t   ([x] [d] of/lett (Dlin2 x) (Dlin1 x) (Dof2 x d) (Dof1 x d : of _ (T1 * T2)))\n\t   (linear/lett1 (linear/tensor1 Dlin))\n\t   Dlin'\n\t   <- compose-linear (Dlin1 unit M2) Dlin Dlin'.\n-bet*12\t: srl ([x] red/beta* : reduce (lett (tensor M1 (M2 x)) M) _)\n\t   ([x] [d] of/lett (Dlin2 x) (Dlin1 x) (Dof2 x d) (Dof1 x d : of _ (T1 * T2)))\n\t   (linear/lett1 (linear/tensor2 Dlin))\n\t   Dlin'\n\t   <- compose-linear (Dlin2 unit M1) Dlin Dlin'.\n-bet*2\t: srl ([x] red/beta* : reduce (lett (tensor M1 M2) (M x)) _)\n\t   ([x] [d] of/lett (Dlin2 x) (Dlin1 x) (Dof2 x d) (Dof1 x d : of _ (T1 * T2)))\n\t   (linear/lett2 Dlin)\n\t   (Dlin M1 M2).\n\n-beta&1\t: srl ([x] red/beta&1 : reduce (pi1 (pair (M1 x) (M2 x))) _)\n\t   ([x] [d] of/pi1 (of/pair (Dof2 x d : of _ T1) (Dof1 x d : of _ T2)))\n\t   (linear/pi1 (linear/pair Dlin2 Dlin1))\n\t   Dlin1.\n-beta&2\t: srl ([x] red/beta&2 : reduce (pi2 (pair (M1 x) (M2 x))) _)\n\t   ([x] [d] of/pi2 (of/pair (Dof2 x d : of _ T1) (Dof1 x d : of _ T2)))\n\t   (linear/pi2 (linear/pair Dlin2 Dlin1))\n\t   Dlin2.\n\n-bt+1-1\t: srl ([x] red/beta+1 : reduce (case (in1 (M x)) M1 M2) _)\n\t   ([x] [d] of/case (Dlin2 x) (Dlin1 x) _ _ (_ : of _ (T1 + T2)))\n\t   (linear/case1 (linear/in1 Dlin))\n\t   Dlin'\n\t   <- compose-linear (Dlin1 unit) Dlin Dlin'.\n-bt+1-2\t: srl ([x] red/beta+1 : reduce (case (in1 M) (M1 x) (M2 x)) _)\n\t   ([x] [d] of/case (Dlin2 x) (Dlin1 x) _ _ (_ : of _ (T1 + T2)))\n\t   (linear/case2 Dlin2' Dlin1')\n\t   (Dlin1' M).\n\n-bt+2-1\t: srl ([x] red/beta+2 : reduce (case (in2 (M x)) M1 M2) _)\n\t   ([x] [d] of/case (Dlin2 x) (Dlin1 x) _ _ (_ : of _ (T1 + T2)))\n\t   (linear/case1 (linear/in2 Dlin))\n\t   Dlin'\n\t   <- compose-linear (Dlin2 unit) Dlin Dlin'.\n-bt+2-2\t: srl ([x] red/beta+2 : reduce (case (in2 M) (M1 x) (M2 x)) _)\n\t   ([x] [d] of/case (Dlin2 x) (Dlin1 x) _ _ (_ : of _ (T1 + T2)))\n\t   (linear/case2 Dlin2' Dlin1')\n\t   (Dlin2' M).\n\n-beta!\t: srl ([x] red/beta! : reduce (letb (bang M1) (M2 x)) _)\n\t   ([x] [d] of/letb (Dof2 x d) (of/bang (Dof1 x d : of _ T)))\n\t   (linear/letb2 Dlin)\n\t   (Dlin M1).\n\n-lam\t: srl ([x] red/lam (Dred x))\n\t   ([x] [d] of/lam (Dlin1 x) (Dof x d))\n\t   (linear/lam Dlin)\n\t   (linear/lam Dlin')\n\t   <- ({y} {e} srl ([x] Dred x y) ([x] [d] Dof x d y e) (Dlin y) (Dlin' y)).\n\n-app1\t: srl ([x] red/app (Dred2 x) (Dred1 x))\n\t   ([x] [d] of/app (Dof2 x d) (Dof1 x d))\n\t   (linear/app1 Dlin)\n\t   Dlin''\n\t   <- srl Dred1 Dof1 Dlin Dlin'\n\t   <- reduce-closed Dred2 Deq\n\t   <- ({x} app-resp term-eq/i (Deq x) (Deq' x))\n\t   <- linear-resp Deq' (linear/app1 Dlin') Dlin''.\n-app2\t: srl ([x] red/app (Dred2 x) (Dred1 x))\n\t   ([x] [d] of/app (Dof2 x d) (Dof1 x d))\n\t   (linear/app2 Dlin)\n\t   Dlin''\n\t   <- srl Dred2 Dof2 Dlin Dlin'\n\t   <- reduce-closed Dred1 Deq\n\t   <- ({x} app-resp (Deq x) term-eq/i (Deq' x))\n\t   <- linear-resp Deq' (linear/app2 Dlin') Dlin''.\n\n-tens1\t: srl ([x] red/tensor (Dred2 x) (Dred1 x))\n\t   ([x] [d] of/tensor (Dof2 x d) (Dof1 x d))\n\t   (linear/tensor1 Dlin)\n\t   Dlin''\n\t   <- srl Dred1 Dof1 Dlin Dlin'\n\t   <- reduce-closed Dred2 Deq\n\t   <- ({x} tensor-resp term-eq/i (Deq x) (Deq' x))\n\t   <- linear-resp Deq' (linear/tensor1 Dlin') Dlin''.\n-tens2\t: srl ([x] red/tensor (Dred2 x) (Dred1 x))\n\t   ([x] [d] of/tensor (Dof2 x d) (Dof1 x d))\n\t   (linear/tensor2 Dlin)\n\t   Dlin''\n\t   <- srl Dred2 Dof2 Dlin Dlin'\n\t   <- reduce-closed Dred1 Deq\n\t   <- ({x} tensor-resp (Deq x) term-eq/i (Deq' x))\n\t   <- linear-resp Deq' (linear/tensor2 Dlin') Dlin''.\n\n-lett1\t: srl ([x] red/lett (Dred2 x) (Dred1 x))\n\t   ([x] [d] of/lett (Dlin2 x) (Dlin1 x) (Dof2 x d) (Dof1 x d))\n\t   (linear/lett1 Dlin)\n\t   Dlin''\n\t   <- srl Dred1 Dof1 Dlin Dlin'\n\t   <- ({y} {z} reduce-closed ([x] Dred2 x y z) ([x] Deq x y z))\n\t   <- ({x} lett-resp term-eq/i (Deq x) (Deq' x))\n\t   <- linear-resp Deq' (linear/lett1 Dlin') Dlin''.\n-lett2\t: srl ([x] red/lett (Dred2 x) (Dred1 x))\n\t   ([x] [d] of/lett (Dlin2 x) (Dlin1 x) (Dof2 x d) (Dof1 x d))\n\t   (linear/lett2 Dlin)\n\t   Dlin''\n\t   <- ({y} {e:of y T1} {z} {f:of z T2} srl ([x] Dred2 x y z) ([x] [d] Dof2 x d y e z f) (Dlin y z) (Dlin' y z))\n\t   <- reduce-closed Dred1 Deq\n\t   <- ({x} lett-resp (Deq x) ([_] [_] term-eq/i) (Deq' x))\n\t   <- linear-resp Deq' (linear/lett2 Dlin') Dlin''.\n\n-pair\t: srl ([x] red/pair (Dred2 x) (Dred1 x))\n\t   ([x] [d] of/pair (Dof2 x d) (Dof1 x d))\n\t   (linear/pair Dlin2 Dlin1)\n\t   (linear/pair Dlin2' Dlin1')\n\t   <- srl Dred1 Dof1 Dlin1 Dlin1'\n\t   <- srl Dred2 Dof2 Dlin2 Dlin2'.\n\n-pi1\t: srl ([x] red/pi1 (Dred x))\n\t   ([x] [d] of/pi1 (Dof x d))\n\t   (linear/pi1 Dlin)\n\t   (linear/pi1 Dlin')\n\t   <- srl Dred Dof Dlin Dlin'.\n\n-pi2\t: srl ([x] red/pi2 (Dred x))\n\t   ([x] [d] of/pi2 (Dof x d))\n\t   (linear/pi2 Dlin)\n\t   (linear/pi2 Dlin')\n\t   <- srl Dred Dof Dlin Dlin'.\n\n-in1\t: srl ([x] red/in1 (Dred x))\n\t   ([x] [d] of/in1 (Dof x d))\n\t   (linear/in1 Dlin)\n\t   (linear/in1 Dlin')\n\t   <- srl Dred Dof Dlin Dlin'.\n\n-in2\t: srl ([x] red/in2 (Dred x))\n\t   ([x] [d] of/in2 (Dof x d))\n\t   (linear/in2 Dlin)\n\t   (linear/in2 Dlin')\n\t   <- srl Dred Dof Dlin Dlin'.\n\n-case1\t: srl ([x] red/case (Dred3 x) (Dred2 x) (Dred1 x))\n\t   ([x] [d] of/case (Dlin3 x) (Dlin2 x) (Dof3 x d) (Dof2 x d) (Dof1 x d))\n\t   (linear/case1 Dlin)\n\t   Dlin''\n\t   <- srl Dred1 Dof1 Dlin Dlin'\n\t   <- ({y} reduce-closed ([x] Dred2 x y) ([x] Deq2 x y))\n\t   <- ({y} reduce-closed ([x] Dred3 x y) ([x] Deq3 x y))\n\t   <- ({x} case-resp term-eq/i (Deq2 x) (Deq3 x) (Deq' x))\n\t   <- linear-resp Deq' (linear/case1 Dlin') Dlin''.\n-case2\t: srl ([x] red/case (Dred3 x) (Dred2 x) (Dred1 x))\n\t   ([x] [d] of/case (Dlin3 x) (Dlin2 x) (Dof3 x d) (Dof2 x d) (Dof1 x d))\n\t   (linear/case2 Dlin3' Dlin2')\n\t   Dlin''\n\t   <- ({x'} {d'} srl ([x] Dred2 x x') ([x] [d] Dof2 x d x' d') (Dlin2' x') (Dlin2'' x'))\n\t   <- ({x'} {d'} srl ([x] Dred3 x x') ([x] [d] Dof3 x d x' d') (Dlin3' x') (Dlin3'' x'))\n\t   <- reduce-closed Dred1 Deq\n\t   <- ({x} case-resp (Deq x) ([y] term-eq/i) ([y] term-eq/i) (Deq' x))\n\t   <- linear-resp Deq' (linear/case2 Dlin3'' Dlin2'') Dlin''.\n\n-letb1\t: srl ([x] red/letb (Dred2 x) (Dred1 x))\n\t   ([x] [d] of/letb (Dof2 x d) (Dof1 x d))\n\t   (linear/letb1 Dlin)\n\t   Dlin''\n\t   <- srl Dred1 Dof1 Dlin Dlin'\n\t   <- ({y} reduce-closed ([x] Dred2 x y) ([x] Deq x y))\n\t   <- ({x} letb-resp term-eq/i (Deq x) (Deq' x))\n\t   <- linear-resp Deq' (linear/letb1 Dlin') Dlin''.\n-letb1\t: srl ([x] red/letb (Dred2 x) (Dred1 x))\n\t   ([x] [d] of/letb (Dof2 x d) (Dof1 x d))\n\t   (linear/letb2 Dlin)\n\t   Dlin''\n\t   <- ({x'} {d'} srl ([x] Dred2 x x') ([x] [d] Dof2 x d x' d') (Dlin x') (Dlin' x'))\n\t   <- reduce-closed Dred1 Deq\n\t   <- ({x} letb-resp (Deq x) ([y] term-eq/i) (Deq' x))\n\t   <- linear-resp Deq' (linear/letb2 Dlin') Dlin''.\n\n-any1\t: srl ([x] red/any (Dred x))\n\t   ([x] [d] of/any (Dof x d))\n\t   (linear/any1 Dlin)\n\t   (linear/any1 Dlin')\n\t   <- srl Dred Dof Dlin Dlin'.\n-any2\t: srl ([x] red/any (Dred x))\n\t   ([x] [d] of/any (Dof x d))\n\t   linear/any2\n\t   Dlin\n\t   <- reduce-closed Dred Deq\n\t   <- ({x} any-resp (Deq x) (Deq' x))\n\t   <- linear-resp Deq' linear/any2 Dlin.\n\n-Cl*11\t: srl ([x] red/app/lett : reduce (app (lett (M1 x) M2) M3) _) _\n\t   (linear/app1 (linear/lett1 Dlin))\n\t   (linear/lett1 Dlin).\n-Cl*12\t: srl ([x] red/app/lett : reduce (app (lett M1 (M2 x)) M3) _) _\n\t   (linear/app1 (linear/lett2 Dlin))\n\t   (linear/lett2 ([x] [y] linear/app1 (Dlin x y))).\n-Cl*2\t: srl ([x] red/app/lett : reduce (app (lett M1 M2) (M3 x)) _) _\n\t   (linear/app2 Dlin)\n\t   (linear/lett2 ([x] [y] linear/app2 Dlin)).\n\n-Cl+11\t: srl ([x] red/app/case : reduce (app (case (M1 x) M2a M2b) M3) _) _\n\t   (linear/app1 (linear/case1 Dlin))\n\t   (linear/case1 Dlin).\n-Cl+12\t: srl ([x] red/app/case : reduce (app (case M1 (M2a x) (M2b x)) M3) _) _\n\t   (linear/app1 (linear/case2 DlinB DlinA))\n\t   (linear/case2 ([y] linear/app1 (DlinB y)) ([y] linear/app1 (DlinA y))).\n-Cl+2\t: srl ([x] red/app/case : reduce (app (case M1 M2a M2b) (M3 x)) _) _\n\t   (linear/app2 Dlin)\n\t   (linear/case2 ([y] linear/app2 Dlin) ([y] linear/app2 Dlin)).\n\n-Cl!11\t: srl ([x] red/app/letb : reduce (app (letb (M1 x) M2) M3) _) _\n\t   (linear/app1 (linear/letb1 Dlin))\n\t   (linear/letb1 Dlin).\n-Cl!12\t: srl ([x] red/app/letb : reduce (app (letb M1 (M2 x)) M3) _) _\n\t   (linear/app1 (linear/letb2 Dlin))\n\t   (linear/letb2 ([y] linear/app1 (Dlin y))).\n-Cl!2\t: srl ([x] red/app/letb : reduce (app (letb M1 M2) (M3 x)) _) _\n\t   (linear/app2 Dlin)\n\t   (linear/letb2 ([y] linear/app2 Dlin)).\n\n-Cl011\t: srl ([x] red/app/any : reduce (app (any (M1 x)) M2) _) _\n\t   (linear/app1 (linear/any1 Dlin))\n\t   (linear/any1 Dlin).\n-Cl012\t: srl ([x] red/app/any : reduce (app (any M1) M2) _) _\n\t   (linear/app1 linear/any2)\n\t   linear/any2.\n-Cl02\t: srl ([x] red/app/any : reduce (app (any M1) (M2 x)) _) _\n\t   (linear/app2 _)\n\t   linear/any2.\n\n-C&1*1\t: srl ([x] red/pi1/lett : reduce (pi1 (lett (M1 x) M2)) _) _\n\t   (linear/pi1 (linear/lett1 Dlin))\n\t   (linear/lett1 Dlin).\n-C&1*2\t: srl ([x] red/pi1/lett : reduce (pi1 (lett M1 (M2 x))) _) _\n\t   (linear/pi1 (linear/lett2 Dlin))\n\t   (linear/lett2 ([x] [y] linear/pi1 (Dlin x y))).\n\n-C&1+1\t: srl ([x] red/pi1/case : reduce (pi1 (case (M1 x) M2a M2b)) _) _\n\t   (linear/pi1 (linear/case1 Dlin))\n\t   (linear/case1 Dlin).\n-C&1+2\t: srl ([x] red/pi1/case : reduce (pi1 (case M1 (M2a x) (M2b x))) _) _\n\t   (linear/pi1 (linear/case2 DlinB DlinA))\n\t   (linear/case2 ([x] linear/pi1 (DlinB x)) ([x] linear/pi1 (DlinA x))).\n\n-C&1!1\t: srl ([x] red/pi1/letb : reduce (pi1 (letb (M1 x) M2)) _) _\n\t   (linear/pi1 (linear/letb1 Dlin))\n\t   (linear/letb1 Dlin).\n-C&1!2\t: srl ([x] red/pi1/letb : reduce (pi1 (letb M1 (M2 x))) _) _\n\t   (linear/pi1 (linear/letb2 Dlin))\n\t   (linear/letb2 ([x] linear/pi1 (Dlin x))).\n\n-C&101\t: srl ([x] red/pi1/any : reduce (pi1 (any (M x))) _) _\n\t   (linear/pi1 (linear/any1 Dlin))\n\t   (linear/any1 Dlin).\n-C&102\t: srl ([x] red/pi1/any : reduce (pi1 (any M)) _) _\n\t   (linear/pi1 linear/any2)\n\t   linear/any2.\n\n-C&2*1\t: srl ([x] red/pi2/lett : reduce (pi2 (lett (M1 x) M2)) _) _\n\t   (linear/pi2 (linear/lett1 Dlin))\n\t   (linear/lett1 Dlin).\n-C&2*2\t: srl ([x] red/pi2/lett : reduce (pi2 (lett M1 (M2 x))) _) _\n\t   (linear/pi2 (linear/lett2 Dlin))\n\t   (linear/lett2 ([x] [y] linear/pi2 (Dlin x y))).\n\n-C&2+1\t: srl ([x] red/pi2/case : reduce (pi2 (case (M1 x) M2a M2b)) _) _\n\t   (linear/pi2 (linear/case1 Dlin))\n\t   (linear/case1 Dlin).\n-C&2+2\t: srl ([x] red/pi2/case : reduce (pi2 (case M1 (M2a x) (M2b x))) _) _\n\t   (linear/pi2 (linear/case2 DlinB DlinA))\n\t   (linear/case2 ([x] linear/pi2 (DlinB x)) ([x] linear/pi2 (DlinA x))).\n\n-C&2!1\t: srl ([x] red/pi2/letb : reduce (pi2 (letb (M1 x) M2)) _) _\n\t   (linear/pi2 (linear/letb1 Dlin))\n\t   (linear/letb1 Dlin).\n-C&2!2\t: srl ([x] red/pi2/letb : reduce (pi2 (letb M1 (M2 x))) _) _\n\t   (linear/pi2 (linear/letb2 Dlin))\n\t   (linear/letb2 ([x] linear/pi2 (Dlin x))).\n\n-C&201\t: srl ([x] red/pi2/any : reduce (pi2 (any (M x))) _) _\n\t   (linear/pi2 (linear/any1 Dlin))\n\t   (linear/any1 Dlin).\n-C&202\t: srl ([x] red/pi2/any : reduce (pi2 (any M)) _) _\n\t   (linear/pi2 linear/any2)\n\t   linear/any2.\n\n-C**11\t: srl ([x] red/lett/lett : reduce (lett (lett (M1 x) M2) M3) _) _\n\t   (linear/lett1 (linear/lett1 Dlin))\n\t   (linear/lett1 Dlin).\n-C**12\t: srl ([x] red/lett/lett : reduce (lett (lett M1 (M2 x)) M3) _) _\n\t   (linear/lett1 (linear/lett2 Dlin))\n\t   (linear/lett2 ([x] [y] linear/lett1 (Dlin x y))).\n-C**2\t: srl ([x] red/lett/lett : reduce (lett (lett M1 M2) (M3 x)) _) _\n\t   (linear/lett2 Dlin)\n\t   (linear/lett2 ([x] [y] linear/lett2 Dlin)).\n\n-C*+11\t: srl ([x] red/lett/case : reduce (lett (case (M1 x) M2a M2b) M3) _) _\n\t   (linear/lett1 (linear/case1 Dlin))\n\t   (linear/case1 Dlin).\n-C*+12\t: srl ([x] red/lett/case : reduce (lett (case M1 (M2a x) (M2b x)) M3) _) _\n\t   (linear/lett1 (linear/case2 DlinB DlinA))\n\t   (linear/case2 ([y] linear/lett1 (DlinB y)) ([y] linear/lett1 (DlinA y))).\n-C*+2\t: srl ([x] red/lett/case : reduce (lett (case M1 M2a M2b) (M3 x)) _) _\n\t   (linear/lett2 Dlin)\n\t   (linear/case2 ([y] linear/lett2 Dlin) ([y] linear/lett2 Dlin)).\n\n-C*!11\t: srl ([x] red/lett/letb : reduce (lett (letb (M1 x) M2) M3) _) _\n\t   (linear/lett1 (linear/letb1 Dlin))\n\t   (linear/letb1 Dlin).\n-C*!12\t: srl ([x] red/lett/letb : reduce (lett (letb M1 (M2 x)) M3) _) _\n\t   (linear/lett1 (linear/letb2 Dlin))\n\t   (linear/letb2 ([x] linear/lett1 (Dlin x))).\n-C*!2\t: srl ([x] red/lett/letb : reduce (lett (letb M1 M2) (M3 x)) _) _\n\t   (linear/lett2 Dlin)\n\t   (linear/letb2 ([x] linear/lett2 Dlin)).\n\n-C*011\t: srl ([x] red/lett/any : reduce (lett (any (M1 x)) M2) _) _\n\t   (linear/lett1 (linear/any1 Dlin))\n\t   (linear/any1 Dlin).\n-C*012\t: srl ([x] red/lett/any : reduce (lett (any M1) M2) _) _\n\t   (linear/lett1 linear/any2)\n\t   linear/any2.\n-C*02\t: srl ([x] red/lett/any : reduce (lett (any M1) (M2 x)) _) _\n\t   (linear/lett2 Dlin)\n\t   linear/any2.\n\n-C+*11\t: srl ([x] red/case/lett : reduce (case (lett (M1 x) M2) M3a M3b) _) _\n\t   (linear/case1 (linear/lett1 Dlin))\n\t   (linear/lett1 Dlin).\n-C+*12\t: srl ([x] red/case/lett : reduce (case (lett M1 (M2 x)) M3a M3b) _) _\n\t   (linear/case1 (linear/lett2 Dlin))\n\t   (linear/lett2 ([y] [z] linear/case1 (Dlin y z))).\n-C+*2\t: srl ([x] red/case/lett : reduce (case (lett M1 M2) (M3a x) (M3b x)) _) _\n\t   (linear/case2 DlinB DlinA)\n\t   (linear/lett2 ([y] [z] linear/case2 DlinB DlinA)).\n\n-C++11\t: srl ([x] red/case/case : reduce (case (case (M1 x) M2a M2b) M3a M3b) _) _\n\t   (linear/case1 (linear/case1 Dlin))\n\t   (linear/case1 Dlin).\n-C++12\t: srl ([x] red/case/case : reduce (case (case M1 (M2a x) (M2b x)) M3a M3b) _) _\n\t   (linear/case1 (linear/case2 DlinB DlinA))\n\t   (linear/case2 ([y] linear/case1 (DlinB y)) ([y] linear/case1 (DlinA y))).\n-C++2\t: srl ([x] red/case/case : reduce (case (case M1 M2a M2b) (M3a x) (M3b x)) _) _\n\t   (linear/case2 DlinB DlinA)\n\t   (linear/case2 ([y] linear/case2 DlinB DlinA) ([y] linear/case2 DlinB DlinA)).\n\n-C+!11\t: srl ([x] red/case/letb : reduce (case (letb (M1 x) M2) M3a M3b) _) _\n\t   (linear/case1 (linear/letb1 Dlin))\n\t   (linear/letb1 Dlin).\n-C+!12\t: srl ([x] red/case/letb : reduce (case (letb M1 (M2 x)) M3a M3b) _) _\n\t   (linear/case1 (linear/letb2 Dlin))\n\t   (linear/letb2 ([x] linear/case1 (Dlin x))).\n-C+!2\t: srl ([x] red/case/letb : reduce (case (letb M1 M2) (M3a x) (M3b x)) _) _\n\t   (linear/case2 DlinB DlinA)\n\t   (linear/letb2 ([x] linear/case2 DlinB DlinA)).\n\n-C+011\t: srl ([x] red/case/any : reduce (case (any (M1 x)) M2a M2b) _) _\n\t   (linear/case1 (linear/any1 Dlin))\n\t   (linear/any1 Dlin).\n-C+012\t: srl ([x] red/case/any : reduce (case (any M1) M2a M2b) _) _\n\t   (linear/case1 linear/any2)\n\t   linear/any2.\n-C+02\t: srl ([x] red/case/any : reduce (case (any M1) (M2a x) (M2b x)) _) _\n\t   (linear/case2 DlinB DlinA)\n\t   linear/any2.\n\n-C!*11\t: srl ([x] red/letb/lett : reduce (letb (lett (M1 x) M2) M3) _) _\n\t   (linear/letb1 (linear/lett1 Dlin))\n\t   (linear/lett1 Dlin).\n-C!*12\t: srl ([x] red/letb/lett : reduce (letb (lett M1 (M2 x)) M3) _) _\n\t   (linear/letb1 (linear/lett2 Dlin))\n\t   (linear/lett2 ([x] [y] linear/letb1 (Dlin x y))).\n-C!*2\t: srl ([x] red/letb/lett : reduce (letb (lett M1 M2) (M3 x)) _) _\n\t   (linear/letb2 Dlin)\n\t   (linear/lett2 ([x] [y] linear/letb2 Dlin)).\n\n-C!+11\t: srl ([x] red/letb/case : reduce (letb (case (M1 x) M2a M2b) M3) _) _\n\t   (linear/letb1 (linear/case1 Dlin))\n\t   (linear/case1 Dlin).\n-C!+12\t: srl ([x] red/letb/case : reduce (letb (case M1 (M2a x) (M2b x)) M3) _) _\n\t   (linear/letb1 (linear/case2 DlinB DlinA))\n\t   (linear/case2 ([x] linear/letb1 (DlinB x)) ([x] linear/letb1 (DlinA x))).\n-C!+2\t: srl ([x] red/letb/case : reduce (letb (case M1 M2a M2b) (M3 x)) _) _\n\t   (linear/letb2 Dlin)\n\t   (linear/case2 ([x] linear/letb2 Dlin) ([x] linear/letb2 Dlin)).\n\n-C!!11\t: srl ([x] red/letb/letb : reduce (letb (letb (M1 x) M2) M3) _) _\n\t   (linear/letb1 (linear/letb1 Dlin))\n\t   (linear/letb1 Dlin).\n-C!!12\t: srl ([x] red/letb/letb : reduce (letb (letb M1 (M2 x)) M3) _) _\n\t   (linear/letb1 (linear/letb2 Dlin))\n\t   (linear/letb2 ([x] linear/letb1 (Dlin x))).\n-C!!2\t: srl ([x] red/letb/letb : reduce (letb (letb M1 M2) (M3 x)) _) _\n\t   (linear/letb2 Dlin)\n\t   (linear/letb2 ([x] linear/letb2 Dlin)).\n\n-C!011\t: srl ([x] red/letb/any : reduce (letb (any (M1 x)) M2) _) _\n\t   (linear/letb1 (linear/any1 Dlin))\n\t   (linear/any1 Dlin).\n-C!012\t: srl ([x] red/letb/any : reduce (letb (any M1) M2) _) _\n\t   (linear/letb1 linear/any2)\n\t   linear/any2.\n-C!02\t: srl ([x] red/letb/any : reduce (letb (any M1) (M2 x)) _) _\n\t   (linear/letb2 Dlin)\n\t   linear/any2.\n\n-C0*11\t: srl ([x] red/any/lett : reduce (any (lett (M1 x) M2)) _) _\n\t   (linear/any1 (linear/lett1 Dlin))\n\t   (linear/lett1 Dlin).\n-C0*12\t: srl ([x] red/any/lett : reduce (any (lett M1 (M2 x))) _) _\n\t   (linear/any1 (linear/lett2 Dlin))\n\t   (linear/lett2 ([x] [y] linear/any1 (Dlin x y))).\n-C0*2\t: srl ([x] red/any/lett : reduce (any (lett M1 M2)) _) _\n\t   linear/any2\n\t   (linear/lett2 ([x] [y] linear/any2)).\n\n-C0+11\t: srl ([x] red/any/case : reduce (any (case (M1 x) M2a M2b)) _) _\n\t   (linear/any1 (linear/case1 Dlin))\n\t   (linear/case1 Dlin).\n-C0+12\t: srl ([x] red/any/case : reduce (any (case M1 (M2a x) (M2b x))) _) _\n\t   (linear/any1 (linear/case2 DlinB DlinA))\n\t   (linear/case2 ([x] linear/any1 (DlinB x)) ([x] linear/any1 (DlinA x))).\n-C0+2\t: srl ([x] red/any/case : reduce (any (case M1 M2a M2b)) _) _\n\t   linear/any2\n\t   (linear/case2 ([x] linear/any2) ([x] linear/any2)).\n\n-C0!11\t: srl ([x] red/any/letb : reduce (any (letb (M1 x) M2)) _) _\n\t   (linear/any1 (linear/letb1 Dlin))\n\t   (linear/letb1 Dlin).\n-C0!12\t: srl ([x] red/any/letb : reduce (any (letb M1 (M2 x))) _) _\n\t   (linear/any1 (linear/letb2 Dlin))\n\t   (linear/letb2 ([x] linear/any1 (Dlin x))).\n-C0!2\t: srl ([x] red/any/letb : reduce (any (letb M1 M2)) _) _\n\t   linear/any2\n\t   (linear/letb2 ([x] linear/any2)).\n\n-C0011\t: srl ([x] red/any/any : reduce (any (any (M x))) _) _\n\t   (linear/any1 (linear/any1 Dlin))\n\t   (linear/any1 Dlin).\n-C0012\t: srl ([x] red/any/any : reduce (any (any M)) _) _\n\t   (linear/any1 linear/any2)\n\t   linear/any2.\n-C002\t: srl ([x] red/any/any : reduce (any (any M)) _) _\n\t   linear/any2\n\t   linear/any2.\n\n\n\n-refl\t: sr red/refl D D.\n-trans\t: sr (red/trans Dred23 Dred12) D1 D3\n\t   <- sr Dred12 D1 D2\n\t   <- sr Dred23 D2 D3.\n\n-beta\t: sr red/beta (of/app Dof2 (of/lam _ Dof1)) (Dof1 _ Dof2).\n-beta*\t: sr red/beta* (of/lett Dlin2 Dlin1 Dof (of/tensor Dof2 Dof1)) (Dof _ Dof1 _ Dof2).\n-beta&1\t: sr red/beta&1 (of/pi1 (of/pair Dof2 Dof1)) Dof1.\n-beta&2\t: sr red/beta&2 (of/pi2 (of/pair Dof2 Dof1)) Dof2.\n-beta+1\t: sr red/beta+1 (of/case _ _ Dof2 Dof1 (of/in1 Dof)) (Dof1 _ Dof).\n-beta+2\t: sr red/beta+2 (of/case _ _ Dof2 Dof1 (of/in2 Dof)) (Dof2 _ Dof).\n-beta!\t: sr red/beta! (of/letb Dof2 (of/bang Dof1)) (Dof2 _ Dof1).\n\n-lam\t: sr (red/lam Dred) (of/lam Dlin Dof) (of/lam Dlin' Dof')\n\t   <- ({x} {d} sr (Dred x) (Dof x d) (Dof' x d))\n\t   <- srl Dred Dof Dlin Dlin'.\n-app\t: sr (red/app Dred2 Dred1) (of/app Dof2 Dof1) (of/app Dof2' Dof1')\n\t   <- sr Dred1 Dof1 Dof1'\n\t   <- sr Dred2 Dof2 Dof2'.\n-tensor\t: sr (red/tensor Dred2 Dred1) (of/tensor Dof2 Dof1) (of/tensor Dof2' Dof1')\n\t   <- sr Dred1 Dof1 Dof1'\n\t   <- sr Dred2 Dof2 Dof2'.\n-lett\t: sr (red/lett Dred2 Dred1) (of/lett Dlin2 Dlin1 Dof2 Dof1) (of/lett Dlin2' Dlin1' Dof2' Dof1')\n\t   <- sr Dred1 Dof1 Dof1'\n\t   <- ({x} {d:of x T1} {y} {e:of y T2} sr (Dred2 x y) (Dof2 x d y e) (Dof2' x d y e))\n\t   <- ({y} {e:of y T2}\n\t\t srl ([x] Dred2 x y) ([x] [d] Dof2 x d y e) (Dlin1 y) (Dlin1' y))\n\t   <- ({x} {d:of x T1}\n\t\t srl ([y] Dred2 x y) ([y] [e] Dof2 x d y e) (Dlin2 x) (Dlin2' x)).\n-pair\t: sr (red/pair Dred2 Dred1) (of/pair Dof2 Dof1) (of/pair Dof2' Dof1')\n\t   <- sr Dred1 Dof1 Dof1'\n\t   <- sr Dred2 Dof2 Dof2'.\n-pi1\t: sr (red/pi1 Dred) (of/pi1 Dof) (of/pi1 Dof')\n\t   <- sr Dred Dof Dof'.\n-pi2\t: sr (red/pi2 Dred) (of/pi2 Dof) (of/pi2 Dof')\n\t   <- sr Dred Dof Dof'.\n-in1\t: sr (red/in1 Dred) (of/in1 Dof) (of/in1 Dof')\n\t   <- sr Dred Dof Dof'.\n-in2\t: sr (red/in2 Dred) (of/in2 Dof) (of/in2 Dof')\n\t   <- sr Dred Dof Dof'.\n-case\t: sr (red/case Dred3 Dred2 Dred1) (of/case Dlin3 Dlin2 Dof3 Dof2 Dof1) (of/case Dlin3' Dlin2' Dof3' Dof2'\n Dof1')\n\t   <- sr Dred1 Dof1 Dof1'\n\t   <- ({x} {d} sr (Dred2 x) (Dof2 x d) (Dof2' x d))\n\t   <- ({x} {d} sr (Dred3 x) (Dof3 x d) (Dof3' x d))\n\t   <- srl Dred2 Dof2 Dlin2 Dlin2'\n\t   <- srl Dred3 Dof3 Dlin3 Dlin3'.\n-letb\t: sr (red/letb Dred2 Dred1) (of/letb Dof2 Dof1) (of/letb Dof2' Dof1')\n\t   <- sr Dred1 Dof1 Dof1'\n\t   <- ({x} {d} sr (Dred2 x) (Dof2 x d) (Dof2' x d)).\n-bang\t: sr (red/bang Dred) (of/bang Dof) (of/bang Dof')\n\t   <- sr Dred Dof Dof'.\n-any\t: sr (red/any Dred) (of/any Dof) (of/any Dof')\n\t   <- sr Dred Dof Dof'.\n\n-Cl*\t: sr red/app/lett (of/app Dof3 (of/lett Dlin2 Dlin1 Dof2 Dof1))\n\t   (of/lett\n\t      ([x] linear/app1 (Dlin2 x)) ([x] linear/app1 (Dlin1 x))\n\t      ([x1] [d1] [x2] [d2] of/app Dof3 (Dof2 x1 d1 x2 d2)) Dof1).\n-Cl+\t: sr red/app/case (of/app Dof3 (of/case DlinB DlinA Dof2b Dof2a Dof1))\n\t   (of/case\n\t      (linear/app1 DlinB) (linear/app1 DlinA)\n\t      ([x] [d] of/app Dof3 (Dof2b x d)) ([x] [d] of/app Dof3 (Dof2a x d)) Dof1).\n-Cl!\t: sr red/app/letb (of/app Dof3 (of/letb Dof2 Dof1))\n\t   (of/letb ([x] [d] of/app Dof3 (Dof2 x d)) Dof1).\n-Cl0\t: sr red/app/any (of/app _ (of/any Dof)) (of/any Dof).\n-C&1*\t: sr red/pi1/lett (of/pi1 (of/lett Dlin2' Dlin2 Dof2 Dof1))\n\t   (of/lett\n\t      ([x] linear/pi1 (Dlin2' x)) ([x] linear/pi1 (Dlin2 x))\n\t      ([x1] [d1] [x2] [d2] of/pi1 (Dof2 x1 d1 x2 d2))\n\t      Dof1).\n-C&1+\t: sr red/pi1/case (of/pi1 (of/case Dlin2b Dlin2a Dof2b Dof2a Dof1))\n\t   (of/case\n\t      (linear/pi1 Dlin2b) (linear/pi1 Dlin2a)\n\t      ([x] [d] of/pi1 (Dof2b x d)) ([x] [d] of/pi1 (Dof2a x d))\n\t      Dof1).\n-C&1!\t: sr red/pi1/letb (of/pi1 (of/letb Dof2 Dof1))\n\t   (of/letb ([x] [d] of/pi1 (Dof2 x d)) Dof1).\n-C&10\t: sr red/pi1/any (of/pi1 (of/any Dof)) (of/any Dof).\n-C&2*\t: sr red/pi2/lett (of/pi2 (of/lett Dlin2' Dlin2 Dof2 Dof1))\n\t   (of/lett\n\t      ([x] linear/pi2 (Dlin2' x)) ([x] linear/pi2 (Dlin2 x))\n\t      ([x1] [d1] [x2] [d2] of/pi2 (Dof2 x1 d1 x2 d2))\n\t      Dof1).\n-C&2+\t: sr red/pi2/case (of/pi2 (of/case Dlin2b Dlin2a Dof2b Dof2a Dof1))\n\t   (of/case\n\t      (linear/pi2 Dlin2b) (linear/pi2 Dlin2a)\n\t      ([x] [d] of/pi2 (Dof2b x d)) ([x] [d] of/pi2 (Dof2a x d))\n\t      Dof1).\n-C&2!\t: sr red/pi2/letb (of/pi2 (of/letb Dof2 Dof1))\n\t   (of/letb ([x] [d] of/pi2 (Dof2 x d)) Dof1).\n-C&20\t: sr red/pi2/any (of/pi2 (of/any Dof)) (of/any Dof).\n-C**\t: sr red/lett/lett (of/lett Dlin3' Dlin3 Dof3 (of/lett Dlin2' Dlin2 Dof2 Dof1))\n\t   (of/lett\n\t      ([x] linear/lett1 (Dlin2' x)) ([x] linear/lett1 (Dlin2 x))\n\t      ([x1] [d1] [x2] [d2] of/lett Dlin3' Dlin3 Dof3 (Dof2 x1 d1 x2 d2))\n\t      Dof1).\n-C*+\t: sr red/lett/case (of/lett Dlin3' Dlin3 Dof3 (of/case Dlin2b Dlin2a Dof2b Dof2a Dof1))\n\t   (of/case (linear/lett1 Dlin2b) (linear/lett1 Dlin2a)\n\t      ([x] [d] of/lett Dlin3' Dlin3 Dof3 (Dof2b x d))\n\t      ([x] [d] of/lett Dlin3' Dlin3 Dof3 (Dof2a x d))\n\t      Dof1).\n-C*!\t: sr red/lett/letb (of/lett Dlin3' Dlin3 Dof3 (of/letb Dof2 Dof1))\n\t   (of/letb\n\t      ([x] [d] of/lett Dlin3' Dlin3 Dof3 (Dof2 x d))\n\t      Dof1).\n-C*0\t: sr red/lett/any (of/lett _ _ _ (of/any Dof)) (of/any Dof).\n-C+*\t: sr red/case/lett (of/case Dlin3b Dlin3a Dof3b Dof3a (of/lett Dlin2' Dlin2 Dof2 Dof1))\n\t   (of/lett ([x] linear/case1 (Dlin2' x)) ([y] linear/case1 (Dlin2 y))\n\t      ([x1] [d1] [x2] [d2] of/case Dlin3b Dlin3a Dof3b Dof3a (Dof2 x1 d1 x2 d2))\n\t      Dof1).\n-C++\t: sr red/case/case (of/case Dlin3b Dlin3a Dof3b Dof3a (of/case Dlin2b Dlin2a Dof2b Dof2a Dof1))\n\t   (of/case (linear/case1 Dlin2b) (linear/case1 Dlin2a)\n\t      ([x] [d] of/case Dlin3b Dlin3a Dof3b Dof3a (Dof2b x d))\n\t      ([x] [d] of/case Dlin3b Dlin3a Dof3b Dof3a (Dof2a x d))\n\t      Dof1).\n-C+!\t: sr red/case/letb (of/case Dlin3b Dlin3a Dof3b Dof3a (of/letb Dof2 Dof1))\n\t   (of/letb\n\t      ([x] [d] of/case Dlin3b Dlin3a Dof3b Dof3a (Dof2 x d))\n\t      Dof1).\n-C+0\t: sr red/case/any (of/case _ _ _ _ (of/any Dof)) (of/any Dof).\n-C!*\t: sr red/letb/lett (of/letb Dof3 (of/lett Dlin2' Dlin2 Dof2 Dof1))\n\t   (of/lett\n\t      ([x] linear/letb1 (Dlin2' x)) ([x] linear/letb1 (Dlin2 x))\n\t      ([x1] [d1] [x2] [d2] of/letb Dof3 (Dof2 x1 d1 x2 d2))\n\t      Dof1).\n-C!+\t: sr red/letb/case (of/letb Dof3 (of/case Dlin2b Dlin2a Dof2b Dof2a Dof1))\n\t   (of/case\n\t      (linear/letb1 Dlin2b) (linear/letb1 Dlin2a)\n\t      ([x] [d] of/letb Dof3 (Dof2b x d)) ([x] [d] of/letb Dof3 (Dof2a x d))\n\t      Dof1).\n-C!!\t: sr red/letb/letb (of/letb Dof3 (of/letb Dof2 Dof1))\n\t   (of/letb ([x] [d] of/letb Dof3 (Dof2 x d)) Dof1).\n-C!0\t: sr red/letb/any (of/letb _ (of/any Dof)) (of/any Dof).\n-C0*\t: sr red/any/lett (of/any (of/lett Dlin2' Dlin2 Dof2 Dof1))\n\t   (of/lett\n\t      ([x] linear/any1 (Dlin2' x)) ([x] linear/any1 (Dlin2 x))\n\t      ([x1] [d1] [x2] [d2] of/any (Dof2 x1 d1 x2 d2))\n\t      Dof1).\n-C0+\t: sr red/any/case (of/any (of/case Dlin2b Dlin2a Dof2b Dof2a Dof1))\n\t   (of/case\n\t      (linear/any1 Dlin2b) (linear/any1 Dlin2a)\n\t      ([x] [d] of/any (Dof2b x d)) ([x] [d] of/any (Dof2a x d))\n\t      Dof1).\n-C0!\t: sr red/any/letb (of/any (of/letb Dof2 Dof1))\n\t   (of/letb ([x] [d] of/any (Dof2 x d)) Dof1).\n-C00\t: sr red/any/any (of/any (of/any Dof)) (of/any Dof).\n\n%worlds (bind) (srl _ _ _ _) (sr _ _ _).\n%total (D1 D2) (srl D1 _ _ _) (sr D2 _ _).\n</twelf>\n\n<twelflink>\nShow complete code.\n</twelflink>\n\n<twelflink check=\"true\">\nShow Twelf output.\n</twelflink>\n\n{{case study}}"
          },
          "sha1": "o4v0eall9u95081g796edyunbhrb3j6"
        }
      },
      {
        "title": "Lists",
        "ns": 0,
        "id": 1700,
        "revision": {
          "id": 5061,
          "parentid": 5050,
          "timestamp": "2008-02-15T03:07:05Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "minor": null,
          "comment": "Reverted edits by [[Special:Contributions/Popik|Popik]] ([[User_talk:Popik|Talk]]); changed back to last version by [[User:Rsimmons|Rsimmons]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 11049,
            "#text": "This page describes the data structure of lists as well as a large number of operations and theorems about them.\n\n==Definition==\n\nThis standard definition of lists in Twelf . We first define what the list elements are: in this example they are just an arbitrary type <tt>elem</tt>. This example is parametric in the type of the elements, so you can change this definition to anything you like.\n\n<math>e ::= \\texttt{a} \\,|\\, \\texttt{b} \\,|\\, \\texttt{c}(e)</math>\n\n<twelf hidden=\"true\">\n% Lists\n% By Carsten Varming 2006\n</twelf><twelf>\n\nelem: type.\n\na : elem.\nb : elem.\nc : elem -> elem.\n</twelf>\n\nThe important defintion is the one of lists. There are two ways of constructing a Twelf object of type <tt>list</tt>. The first is the constructor for the empty list <tt>nil</tt>. The second is the constructor <tt>cons</tt> that given an object of type <tt>elem</tt> and an object of type <tt>list</tt> creates a list with elem as head and list as tail.\n\n<math>l ::= \\texttt{nil} \\,|\\, e :: l</math>\n\n<twelf>\nlist : type. %name list Ls.\n\nnil : list.\ncons : elem -> list -> list.\n%freeze list.\n</twelf>\n\n==Equalities==\n\nEquality is defined as [[identity]], which makes the symmetry and transitivity proofs entirely trivial. One [[congruence lemma]] needs to be defined <tt>eq-cong-cons</tt>, expressing that if the tails of two lists are equal, and the heads of the lists are identical, the lists are equal. \n\n<twelf>\neq : list -> list -> type.\n%mode eq +Ls -Ls'.\neq/ref : eq Ls Ls.\n%worlds () (eq _ _).\n%freeze eq.\n\neq-symm : eq Ls Ls' -> eq Ls' Ls -> type.\n%mode eq-symm +Q -Q'.\n- : eq-symm eq/ref eq/ref.\n%worlds () (eq-symm _ _).\n%freeze eq-symm.\n%total {} (eq-symm _ _).\n\neq-trans : eq Ls Ls' -> eq Ls' Ls'' -> eq Ls Ls'' -> type.\n%mode eq-trans +Q +Q' -Q''.\n- : eq-trans eq/ref eq/ref eq/ref.\n%worlds () (eq-trans _ _ _).\n%freeze eq-trans.\n%total {} (eq-trans _ _ _).\n\neq-cong-cons : {E} eq L1 L2 -> eq (cons E L1) (cons E L2) -> type.\n%mode eq-cong-cons +E1 +E2 -E3.\n- : eq-cong-cons _ eq/ref eq/ref.\n%worlds () (eq-cong-cons _ _ _).\n%total {} (eq-cong-cons _ _ _).\n</twelf>\n\n==Reversal==\nThere are at least two very common operations on lists: Reverse and Append. Lists form a semigroup with the opeation append <math>\\cdot \\diamonds \\cdot</math> and the empty list as right and left unit. If we define an operation <math>f(x,y) = y \\diamonds x</math> then reverse <math>(\\cdot)^\\top</math> is an isomorphism between the semigroups (lists,<math>\\diamonds</math>,nil) and (lists,f,nil).\n===Definition===\nI will use the standard logic programming way of encoding reversal. In the following <tt>rev</tt> will be a ternary relation where the first two elements are input and the third is output. The invariant is <math>\\forall a,b,c. a^\\top \\bowtie b = c</math>, where <math>\\bowtie</math> is concatenation, thus <math>a^\\top=b</math> is obtained by <tt>rev a nil b</tt>. We will later see that <math>\\bowtie</math> can be thought of as <math>\\diamonds</math>.\n<twelf>\nrev : list -> list -> list -> type.\n%mode rev +Ls +Ls'' -Ls'.\nrev/nil : rev nil Ls' Ls'.\nrev/cons : rev (cons E Ls) Ls'' Ls'\n               <- rev Ls (cons E Ls'') Ls'.\n%worlds () (rev _ _ _).\n%freeze rev.\n%total D (rev D _ _).\n\ncan-rev : {Ls} {Ls'} rev Ls Ls' Ls'' -> type.\n%mode can-rev +Ls +Ls' -R.\n- : can-rev nil _ rev/nil.\n- : can-rev (cons E Ls) Ls' (rev/cons Ls'')\n            <- can-rev Ls (cons E Ls') Ls''.\n%worlds () (can-rev _ _ _).\n%freeze can-rev. \n%total D (can-rev D _ _).\n</twelf>\n\n===Equality===\n<twelf>\nrev-eq : eq L1 L2 -> eq L3 L4 -> eq L5 L6 -> rev L1 L3 L5 -> rev L2 L4 L6 -> type.\n%mode rev-eq +E1 +E2 +E3 +R1 -R2.\n- : rev-eq eq/ref eq/ref eq/ref R R.\n%worlds () (rev-eq _ _ _ _ _).\n%total {} (rev-eq _ _ _ _ _).\n</twelf>\n\n===Determinism===\nAs the Twelf definition only states that rev is a relation we need to prove that it indeed is a function. Namely <math>\\forall a,b,c,d. a^\\top \\diamonds b = c \\land a^\\top \\diamonds b = d \\Rightarrow c = d</math>.\n<twelf>\nrev-determ : rev Ls Ls' Ls3 -> rev Ls Ls' Ls4 -> eq Ls3 Ls4 -> type.\n%mode rev-determ +R +R' -Q.\n- : rev-determ rev/nil _ eq/ref.\n- : rev-determ (rev/cons R) (rev/cons R') Q\n         <- rev-determ R R' Q.\n%worlds () (rev-determ _ _ _).\n%freeze rev-determ.\n%total D (rev-determ D _ _).\n</twelf>\n\n===Double reversal===\nReverse is an isomorphism that turn out to be its own inverse.\n<math>\\forall a,b,c. a^\\top = b \\land b^\\top = c \\Rightarrow a = c</math>.\n<twelf>\nrevrev-id-lem : rev Ls Ls' Ls'' -> rev Ls'' nil Ls4 -> rev Ls' Ls Ls6 -> eq Ls6 Ls4 -> type.\n%mode revrev-id-lem +R +R' +R'' -Q.\n\n- : revrev-id-lem rev/nil F F' Q\n          <- rev-determ F' F Q.\n- : revrev-id-lem (rev/cons R) R' R'' Q\n          <- revrev-id-lem R R' (rev/cons R'') Q.\n\n%worlds () (revrev-id-lem _ _ _ _).\n%freeze revrev-id-lem.\n%total D (revrev-id-lem D _ _ _).\n\nrevrev-id : rev A nil B -> rev B nil A -> type.\n%mode revrev-id +R -R'.\n- : revrev-id R R'\n  <- can-rev _ nil R1\n  <- revrev-id-lem R R1 rev/nil E\n  <- eq-symm E E'\n  <- rev-eq eq/ref eq/ref E' R1 R'.\n%worlds () (revrev-id _ _).\n%freeze revrev-id.\n%total {} (revrev-id _ _).\n</twelf>\n\n===Injectivity===\nAs reverse has an inverse it is injective <math>\\forall a,b,c. a^\\top = c \\land b^\\top = c \\Rightarrow a = b</math>.\n<twelf>\nrev-injective : rev Ls nil Ls' -> rev Ls'' nil Ls' -> eq Ls Ls'' -> type.\n%mode rev-injective +R +R' -Q.\n- : rev-injective (R : rev Ls nil Ls') R' Q\n      <- revrev-id R R1\n      <- revrev-id R' R1'\n      <- rev-determ R1 R1' Q.\n%worlds () (rev-injective _ _ _).\n%freeze rev-injective.\n%total D (rev-injective D _ _).\n</twelf>\n\n==Append==\n\n===Definition===\n<twelf>\nappend : list -> list -> list -> type.  %name append A.\n\nappend/nil : append nil L L.\nappend/cons : append (cons E L1) L2 (cons E L3)\n     <- append L1 L2 L3.\n\n%freeze append.\n\ncan-append : {L1}{L2} append L1 L2 L3 -> type.\n%mode can-append +L1 +L2 -A.\n\n- : can-append nil L append/nil.\n- : can-append (cons E L1) L2 (append/cons A)\n     <- can-append L1 L2 A.\n\n%worlds () (can-append _ _ _).\n%total D (can-append D _ _).\n</twelf>\n\n===Equality===\n<twelf>\nappend-eq : eq L1 L2 -> eq L3 L4 -> eq L5 L6 -> append L1 L3 L5 -> append L2 L4 L6 -> type.\n%mode append-eq +E1 +E2 +E3 +A1 -A2.\n\n- : append-eq eq/ref eq/ref eq/ref A A.\n\n%worlds () (append-eq _ _ _ _ _).\n%total {} (append-eq _ _ _ _ _).\n</twelf>\n===Units===\nWe need to prove that <tt>nil</tt> is the right and left unit of the semigroup <math>\\forall a. a \\diamonds nil = nil \\diamonds a = a</math>. The later is by axiom and the former is by this lemma.\n<twelf>\nappend-eq-nil : {L1} append L1 nil L1 -> type.\n%mode append-eq-nil +L -A.\n\n- : append-eq-nil nil append/nil.\n- : append-eq-nil (cons E L) (append/cons A) \n     <- append-eq-nil L A.\n\n%worlds () (append-eq-nil _ _).\n%total D (append-eq-nil D _).\n</twelf>\nSometimes it is helpful to reason with equalities like <math>\\forall a b. a \\diamonds nil = b \\Rightarrow a = b</math>.\n<twelf>\nappend-eq-nil : append L1 nil L2 -> eq L1 L2 -> type.\n%mode append-eq-nil +A -E.\n\n- : append-eq-nil append/nil eq/ref.\n- : append-eq-nil (append/cons A) E\n     <- append-eq-nil A E1\n     <- eq-cong-cons _ E1 E.\n%worlds () (append-eq-nil _ _).\n%total D (append-eq-nil D _).\n</twelf>\n\n===Determinism===\nAs with reverse we need to show that append is indeed a function <math>\\forall a,b,c,c'. a \\diamonds b = c \\land a \\diamonds b = c' \\Rightarrow c = c'</math>.\n<twelf>\nappend-determ : append L1 L2 L3 -> append L1 L2 L4 -> eq L3 L4 -> type.\n%mode append-determ +A1 +A2 -E.\n\n- : append-determ append/nil append/nil eq/ref.\n- : append-determ (append/cons A1) (append/cons A2) E\n       <- append-determ A1 A2 E2\n       <- eq-cong-cons _ E2 E.\n\n%worlds () (append-determ _ _ _).\n%total D (append-determ D _ _).\n</twelf>\n\n===Associativity===\nWe need to prove that append is associative <math>\\forall a,b,c.(a \\diamonds b) \\diamonds c = a \\diamonds (b \\diamonds c)</math>.\n<twelf>\nappend-assoc1 : append L1 L2 L3 -> append L3 L4 L5 -> append L2 L4 L6 -> append L1 L6 L5 -> type.\n%mode append-assoc1 +A1 +A2 -A3 -A4.\n\n- : append-assoc1 append/nil A1 A1 append/nil.\n- : append-assoc1 (append/cons A1) (append/cons A2) A3 (append/cons A4)\n      <- append-assoc1 A1 A2 A3 A4.\n\n%worlds () (append-assoc1 _ _ _ _).\n%total D (append-assoc1 D _ _ _).\n\nappend-assoc2 : append L1 L2 L3 -> append L3 L4 L5 -> append L2 L4 L6 -> append L1 L6 L7 -> eq L5 L7 -> type.\n%mode append-assoc2 +A1 +A2 +A3 +A4 -E.\n\n- : append-assoc2 A1 A2 A3 A4 E\n      <- append-assoc1 A1 A2 A3' A4'\n      <- append-determ A3 A3' E3\n      <- append-eq eq/ref E3 eq/ref A4 A4''\n      <- append-determ A4' A4'' E.\n\n%worlds () (append-assoc2 _ _ _ _ _).\n%total {} (append-assoc2 _ _ _ _ _).\n</twelf>\n\n==Append and reversal==\nI promissed to prove that <tt>rev</tt> is an isomorphism. Lets start by a few lemmas.\nFirst <math>\\forall a,b,c.b^\\top \\bowtie (a^\\top \\bowtie c) = (a \\diamonds b)^\\top \\bowtie c</math>.\n<twelf>\nappend-rev1 : append L1 L2 L3 -> rev L1 L4 L5 -> rev L2 L5 L6 -> rev L3 L4 L6 -> type.\n%mode append-rev1 +A +R1 +R2 -R3.\n\n- : append-rev1 append/nil rev/nil R R.\n- : append-rev1 (append/cons A) (rev/cons R1) R3 (rev/cons R2) \n <- append-rev1 A R1 R3 R2.\n\n%worlds () (append-rev1 _ _ _ _).\n%total D (append-rev1 D _ _ _).\n</twelf>\nAnd second <math>\\forall a,b,c.(a^\\top \\bowtie b)\\diamonds c = a^\\top \\bowtie (b \\diamonds c)</math>. If we let <math>b = nil</math> then we get <math>a^\\top \\diamonds c = a^\\top \\bowtie c</math>, which shows how we can think of <math>\\bowtie</math> as <math>\\diamonds</math>.\n<twelf>\nappend-rev2 : rev L1 L2 L3 -> append L2 L4 L5 -> append L3 L4 L6 -> rev L1 L5 L6 -> type.\n%mode append-rev2 +R +A +A' -R'.\n\n- : append-rev2 rev/nil A1 A2 R\n  <- append-determ A1 A2 E\n  <- rev-eq eq/ref eq/ref E rev/nil R.\n\n- : append-rev2 (rev/cons R) A1 A2 (rev/cons R2)\n  <- append-rev2 R (append/cons A1) A2 R2.\n\n%worlds () (append-rev2 _ _ _ _).\n%total D (append-rev2 D _ _ _).\n</twelf>\nAnd here we go. <math>\\forall a,b,c,d. (a^\\top \\bowtie b) \\diamonds (c^\\top \\bowtie d)\n= ((d^\\top \\bowtie c) \\diamonds (b^\\top \\bowtie a))^\\top </math> which boils down to \n<math>\\forall a,c.a^\\top \\diamonds c^\\top = (c \\diamonds a)^\\top = f(c^\\top,a^\\top) </math>, whence reverse is a homeomorphism. This combined with the fact that reverse is its own inverse we get that reverse is an isomorphism.\n<twelf>\nappend-rev : rev L1 L2 L3 -> rev LA LB LC -> append LC L3 LT -> rev L2 L1 L3' -> \n             rev LB LA LC' -> append L3' LC' LT' -> rev LT' nil LT -> type.\n%mode append-rev +R1 +R2 +A1 +R3 +R4 +A2 -R3.\n\n- : append-rev R1 (rev/cons R2) A1 R3 R4 A2 R5\n    <- append-rev R1 R2 A1 R3 (rev/cons R4) A2 R5.\n\n- : append-rev (rev/cons R1) rev/nil A1 R2 R3 A2 R5\n    <- append-rev R1 rev/nil A1 (rev/cons R2) R3 A2 R5.\n\n- : append-rev rev/nil rev/nil A1 R3 R4 A2 R5\n  <- append-rev2 R3 append/nil A2 RC\n  <- append-rev1 A1 R4 RC RB \n  <- revrev-id RB R5.\n\n%worlds () (append-rev _ _ _ _ _ _ _).\n%total [D E] (append-rev E D _ _ _ _ _).\n</twelf>\n<twelflink>See the Twelf code for this example</twelflink> - <twelflink check=true>See Twelf's output</twelflink>\n\n{{case study}}"
          },
          "sha1": "0dtg4o3kcpcv2uwcp4t4uttcz2jfhxq"
        }
      },
      {
        "title": "Logic program",
        "ns": 0,
        "id": 1970,
        "redirect": {
          "@title": "Logic programming",
          "#text": null
        },
        "revision": {
          "id": 4510,
          "timestamp": "2007-03-21T00:03:11Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "Redirecting to [[Logic programming]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 31,
            "#text": "#REDIRECT [[Logic programming]]"
          },
          "sha1": "3w3z54p3cfhh4ixbm466ndnqjz7izwn"
        }
      },
      {
        "title": "Logic programming",
        "ns": 0,
        "id": 1918,
        "revision": {
          "id": 7988,
          "parentid": 6570,
          "timestamp": "2014-03-06T00:38:18Z",
          "contributor": {
            "ip": "195.249.186.31"
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 2198,
            "#text": "Most of the articles and examples on this wiki are focused towards using Twelf as a specification language, useful for encoding an [[object logic]] and then stating and proving [[metatheorems]] about that object logic. However, Twelf originated from [[Elf]], and like Elf it is a dependently-typed, higher-order '''logic programming language''' based on the logic [[LF]].\n\nA Twelf [[signature]] may contain, among other things, some '''type family''' declarations and some '''constants''' inhabiting those type families. A logic programming language takes a ''type'' as an input, and it then uses a simple search strategy to try and discover a term that has that type using the constants that have been defined. By the [[judgments as types]] principle, this means that Twelf is searching for a derivation - a '''proof witness''' - of a particular judgment.\n\nTwelf's logic programming engine is activated by <tt>[[%solve]]</tt> and <tt>[[%query]]</tt> directives. It can also be activated directly inside ML; see the section on {{guide|title=interactive queries|chapter=5|section=22}} for more information. Twelf's [[tabled logic programming]] engine is activated by the <tt>[[%querytabled]]</tt> directive.\n\n== Uses of logic programming in Twelf ==\n\n* '''Implementing a reference typechecker/evaluator''' - If the static and dynamic semantics of a programming language are written correctly, then the specification of the static semantics can be . This was a component to the [[poplmark:The POPLmark Challenge|The POPLmark Challenge]] challenge; the case study of a [[language with references]], among other examples, demonstarte Twelf in this capacity.\n* Writing  programs and then proving things about them: The TALT project <ref>{{bibtex:crary03talt}}</ref> includes a code checker written as a Twelf logic program, along with a proof in Twelf that code that passes the checker is safe according to a safety policy.\n* [[Tactical theorem proving]] - in the style described by Appel and Felty in <ref>{{bibtex:af04dependent}}</ref>.\n\n== See also == \n* {{guide|title=Logic Programming|chapter=5|section=22}}\n* [[w:Logic programming|Logic programming]] at Wikipedia\n\n== References ==\n\n<references />"
          },
          "sha1": "ad3sadc4dki5dh2yestlhk8cgkyyvli"
        }
      },
      {
        "title": "Mailing lists",
        "ns": 0,
        "id": 1525,
        "revision": {
          "id": 2049,
          "timestamp": "2006-09-28T03:02:22Z",
          "contributor": {
            "username": "DanielKLee",
            "id": 5
          },
          "comment": "Stealing more content from twelf.org",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 602,
            "#text": "We maintain two mailing lists for the Twelf project through mailman. The moderated mailing list which is used for announcments related to Twelf is called '''twelf-list'''. The other is called '''twelf-developer'''. It serves as discussion forum for people who are working on the Twelf implementation.\n\nIf you want to join twelf mailing list visit [http://www.itu.dk/mailman/listinfo/twelf-list http://www.itu.dk/mailman/listinfo/twelf-list].\n\nIf you want to join twelf-developer mailing list visit [http://www.itu.dk/mailman/listinfo/twelf-developer http://www.itu.dk/mailman/listinfo/twelf-developer]."
          },
          "sha1": "36hnvbpnp6fy4ly1l6vap542150x6po"
        }
      },
      {
        "title": "Main Page",
        "ns": 0,
        "id": 1,
        "revision": {
          "id": 5871,
          "parentid": 5440,
          "timestamp": "2009-02-10T14:26:21Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "Kill POPL tutorial upcoming, as it is no longer upcoming",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 2649,
            "#text": "<!-- \n\nHi there!   \n\nYou probably want to edit the content of this page, but you should know that most of the stuff on the front page isn't actually in this file.\n\nThe contents of the four sections on this page are four separate pages. You can find and edit them by clicking on the \"discussion\" link below. Then click on the page for the section you want to edit, and edit that page, not this one. (They are also linked from the bottom of the edit page, under \"templates used on this page.\")\n\n\n\nIf you do want to edit things besides those four sections of content, you're in the right place.\n\n\n - Rob\n\n\n--><!-- Beginning of header section -->{|style=\"width:100%;margin-top:+.7em;background-color:#fcfcfc;border:1px solid #ccc\"\n|style=\"width:56%;color:#000\"|\n{|style=\"width:280px;border:solid 0px;background:none\"\n|-\n|style=\"width:280px;text-align:center;white-space:nowrap;color:#000\" |\n<div style=\"font-size:162%;border:none;margin: 0;padding:.1em;color:#000\">Welcome to [[The_Twelf_Project:About|The Twelf Project]]</div>\n<div id=\"articlecount\" style=\"width:100%;text-align:center;font-size:85%;\">[[Special:allpages|{{NUMBEROFARTICLES}}]] articles and counting...</div>\n|}<!-- Portals Follow -->\n|style=\"width:11%;font-size:95%;color:#000\"|\n|}<!-- End Portals -->\n\n<!-- Start of left-column -->\n{|style=\"border-spacing:8px;margin:0px -8px\"\n|class=\"MainPageBG\" style=\"width:55%;border:1px solid #cef2e0;background-color:#f5fffa;vertical-align:top;color:#000\"|\n{|width=\"100%\" cellpadding=\"2\" cellspacing=\"5\" style=\"vertical-align:top;background-color:#f5fffa\"\n! <h2 style=\"margin:0;background-color:#cef2e0;font-size:120%;font-weight:bold;border:1px solid #a3bfb1;text-align:left;color:#000;padding:0.2em 0.4em;\">What is Twelf?</h2>\n|-\n|style=\"color:#000\"|{{The Twelf Project/Introduction}}\n|-\n! <div style=\"margin:0;background-color:#cef2e0;font-size:120%;font-weight:bold;border:1px solid #a3bfb1;text-align:left;color:#000;padding:0.2em 0.4em;\">\n<div style=\"float:right\">{{click-inline | image=disk download.gif | link = download | width = 23px | height = 20px}}</div>\nDownload and Learn Twelf</div>\n|-\n|style=\"color:#000\"|{{The Twelf Project/Getting Started}}\n|-\n|}\n<!-- Start of right-column -->\n|class=\"MainPageBG\" style=\"width:45%;border:1px solid #f2dfce;background-color:#fffaf5;vertical-align:top\"|\n{| width=\"100%\" cellpadding=\"2\" cellspacing=\"5\" style=\"vertical-align:top;background-color:#fffaf5\"\n! <h2 style=\"margin:0;background:#f2dfce;font-size:120%;font-weight:bold;border:1px solid #bfb0a3;text-align:left;color:#000;padding:0.2em 0.4em;\">What's new?</h2>\n|- \n|style=\"color:#000\"|{{:What's new}}\n|-\n|}\n|}\n__NOTOC__\n__NOEDITSECTION__"
          },
          "sha1": "kphc7ri327c24656et28ylpw9kc0py0"
        }
      },
      {
        "title": "Main page",
        "ns": 0,
        "id": 1475,
        "redirect": {
          "@title": "Main Page",
          "#text": null
        },
        "revision": {
          "id": 1811,
          "timestamp": "2006-09-23T02:00:40Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 23,
            "#text": "#REDIRECT [[Main Page]]"
          },
          "sha1": "modmu9pqjk76od7mzb24xgw5a8qpfof"
        }
      },
      {
        "title": "Manipulating proof witnesses",
        "ns": 0,
        "id": 1714,
        "redirect": {
          "@title": "Manipulating proof witnesses as inputs",
          "#text": null
        },
        "revision": {
          "id": 2808,
          "timestamp": "2006-10-14T04:41:11Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "Redirecting to [[Manipulating proof witnesses as inputs]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 52,
            "#text": "#REDIRECT [[Manipulating proof witnesses as inputs]]"
          },
          "sha1": "4sjxcyiqjlnghp8zay4tf7xtyrodkur"
        }
      },
      {
        "title": "Manipulating proof witnesses as inputs",
        "ns": 0,
        "id": 1713,
        "revision": {
          "id": 4841,
          "parentid": 4824,
          "timestamp": "2007-09-27T04:13:28Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "minor": null,
          "comment": "Reverted edits by [[Special:Contributions/192.115.104.88|192.115.104.88]] ([[User_talk:192.115.104.88|Talk]]); changed back to last version by [[User:67.171.64.112|67.171.64.112]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 6824,
            "#text": "Christopher asks...\n<blockquote>\nThere are things which I can express as a sequence of two \"%solve\"\ncommands that I can't express in one:\ne.g.\n<twelf discard=true>\n%solve A : foo.\n%solve B : bar A.\n</twelf>\n\nI'd like to be able to write a type quux which combines the two\nsearches, like:\n\n<twelf discard=true>\nquux : { A : foo } bar A -> type.\n%mode quux -A -B.\nquux_con : { A : foo } { B : foo A } quux A B\n% or maybe if there was syntax like\n% quux_con2 : quux A B <- A : foo <- B : foo A\n</twelf>\n</blockquote>\n== Response ==\n\nI believe what you want to do is doable - you were on the right track with introducing A as an [[explicit parameter]] here. However, I would caution you against what you're suggesting, because - as far as I know, what you're asking requires essentially duplicating your entire program as [[effectiveness lemmas]].\n\nI had trouble working out what the meaning of the example was based on abstract examples, so included the natural numbers with plus. We also encode the metatheorem for the commutivity of plus, but we're not interested in the fact that it is a metatheorem here - <tt>plus</tt> here is our analog for <tt>foo</tt> above, and so <tt>plus-comm</tt> is our <tt>bar</tt>.\n<twelf hidden=\"true\">\nnat : type.\nz : nat. \ns : nat -> nat.\n\n\n\nplus : nat -> nat -> nat -> type.\n%mode plus +N1 +N2 -N3.\n\nplus/z : plus z N N.\n\nplus/s : plus (s N1) N2 (s N3) \n          <- plus N1 N2 N3.\n\n\n\nplus-zero : {N} plus N z N -> type.\n%mode plus-zero +N -D.\n\nplus-zero/z : plus-zero z plus/z.\n\nplus-zero/s : plus-zero (s N) (plus/s D) <- plus-zero N D.\n\n\n\nplus-succ : plus N1 N2 N3 -> plus N1 (s N2) (s N3) -> type.\n%mode plus-succ +D1 -D2.\n\nplus-succ/z : plus-succ plus/z plus/z.\n\nplus-succ/s : plus-succ (plus/s D1) (plus/s D2)\n               <- plus-succ D1 D2.\n\n\n</twelf><twelf>\nplus-comm : plus A B C -> plus B A C -> type.\n%mode plus-comm +A -B.\n\nplus-comm/z : plus-comm plus/z (D: plus N z N)\n               <- plus-zero N D.\nplus-comm/s : plus-comm (plus/s D1) D2\n               <- plus-comm D1 D3\n               <- plus-succ D3 D2.\n</twelf> \n\nIf you want to see the code leading up to that point, you can <twelflink>see it here</twelflink>.\n\nNow, in our example, we have a new version of the first code example:\n\n<twelf check=\"decl\" noinclude=\"true\">\n%solve derivA : plus (s (s z)) (s z) _.\n%solve derivB : plus-comm derivA C.\n</twelf>\n\nAs far as I can tell, the equivalent of your relation above in my example is one that takes two natural numbers <tt>A</tt> and <tt>B</tt> and produces\n\n* The natural number <tt>C</tt> that is the sum of <tt>A</tt> and <tt>B</tt>\n* A derivation <tt>D</tt> of <tt>plus A B C</tt>\n* A derivation of the commuted sum <tt>D'</tt>, i.e. <tt>plus B A C</tt>\n* A derivation of <tt>plus-comm D D'</tt> of that \n\nThis is realized in the following relation:\n\n<twelf discard=true>\ntwoplus : {A}{B}{C}{D: plus A B C}{D': plus B A C} plus-comm D D' -> type.\n%mode twoplus +A +B -C -D -D' -D''.\n</twelf>\n\n=== Lots of effectiveness lemmas ===\n\nIn order to get what we want, we are going to have to encode a bunch of [[effectiveness lemmas]]&mdash;not having written them those may have been what was giving you trouble before. In your example you seem to indicate that the relations you were working with were not necessarily total relations from inputs to outputs - if that is the case, then you will define what could more accurately be called ''effectiveness relations''. What effectiveness lemmas/relations do is express ''how to build a proof witness given certain inputs'' - in some sense making the proof search process explicit rather than letting <tt>%solve</tt> handle it.\n\nOur effectivness lemma for <tt>plus</tt> looks like this. Pay careful attention to what is an input and what is an output.\n\n<twelf>\ncan-plus : {A}{B}{C} plus A B C -> type.\n%mode can-plus +A +B -C -D.\n\ncan-plus/z : can-plus z B B plus/z.\n\ncan-plus/s : can-plus (s A) B (s C) (plus/s D)\n              <- can-plus A B C D.\n\n%worlds () (can-plus _ _ _ _).\n%total T (can-plus T _ _ _).\n</twelf>\n\nThe totality checks on these and the other effectiveness lemmas are just a sanity check here - this technique would work even if you were working with relations which were not total. As before, I will skip over the effectivenes lemmas for <tt>plus-zero</tt> and <tt>plus-succ</tt> and skip to the proof for \n\n<twelf hidden=true>\n\ncan-plus-zero : {N}{D: plus N z N} plus-zero N D -> type.\n%mode can-plus-zero +N -D -DZ.\n\ncan-plus-zero/z : can-plus-zero z plus/z plus-zero/z.\n\ncan-plus-zero/s : can-plus-zero (s N) (plus/s D) (plus-zero/s DZ)\n\t\t   <- can-plus-zero N D DZ.\n\n%worlds () (can-plus-zero _ _ _).\n%total T (can-plus-zero T _ _).\n\n\n\ncan-plus-succ : {D:plus A B C}{D': plus A (s B) (s C)} plus-succ D D' -> type.\n%mode can-plus-succ +D -D' -DS.\n\ncan-plus-succ/z : can-plus-succ plus/z plus/z plus-succ/z.\n\ncan-plus-succ/s : can-plus-succ (plus/s D) (plus/s D') (plus-succ/s DS)\n\t\t   <- can-plus-succ D D' DS.\n\n%worlds () (can-plus-succ _ _ _).\n%total T (can-plus-succ T _ _).\n\n</twelf><twelf>\ncan-plus-comm : {D: plus A B C}{D': plus B A C} plus-comm D D' -> type.\n%mode can-plus-comm +D -D' -DC.\n\ncan-plus-comm/z : can-plus-comm plus/z (D: plus N z N) (plus-comm/z DZ)\n\t\t   <- can-plus-zero N D (DZ: plus-zero N D).\n\ncan-plus-succ/s : can-plus-comm (plus/s D) D'' (plus-comm/s DS DC)\n\t\t   <- can-plus-comm D D' DC\n\t\t   <- can-plus-succ D' D'' DS.\n\n%worlds () (can-plus-comm _ _ _).\n%total T (can-plus-comm T _ _).\n</twelf>\n\nTo see all of the code with effectiveness lemmas included, <twelflink>click here</twelflink>.\n\n=== Putting together the <tt>twoplus</tt> relation ===\n\nNow that we have all the effectiveness lemmas we could ever need or want, it is relatively simple to define twoplus. Furthermore, because we established totality of <tt>plus</tt> and <tt>plus-comm</tt>, it is simple to establish totality of <tt>twoplus</tt>.\n\n<twelf>\ntwoplus : {A}{B}{C}{D: plus A B C}{D': plus B A C} plus-comm D D' -> type.\n%mode twoplus +A +B -C -D -D' -D''.\n\ntwoplus/i : twoplus A B C D D' DC\n             <- can-plus A B C D\n\t     <- can-plus-comm D D' DC.\n\n%worlds () (twoplus _ _ _ _ _ _).\n%total {} (twoplus _ _ _ _ _ _).\n</twelf>\n\nYou can <twelflink>see all the code</twelflink> or <twelflink check=\"true\">see Twelf's response</twelflink> to checking it.\n\n== Side note about <tt>%define</tt> ==\n\nAs a side note, look at Twelf's output when we solved <tt>%solve B : plus-comm A C.</tt> It didn't allow us to see the type of <tt>C</tt>, and it didn't allow us to use <tt>C</tt> later in the program. We can bind outputs of functions and use them later in the signature by using [[define declaration|%define]], as the following example shows:\n\n<twelf check=\"decl\">\n%solve deriv1 : plus (s (s z)) (s z) _.\n%define deriv2 = C \n%solve deriv3 : plus-comm deriv1 C.\n\ntest = plus/s deriv2. \n</twelf>"
          },
          "sha1": "rsytqsgejcr126gnmxhrqjh57z5h1h9"
        }
      },
      {
        "title": "MediaWiki formatting description",
        "ns": 0,
        "id": 2280,
        "revision": {
          "id": 6302,
          "timestamp": "2011-09-08T07:42:03Z",
          "contributor": {
            "username": "Amepu",
            "id": 149
          },
          "comment": "Created page with \"Guide for writing in mediawiki syntax will be posted here  [http://www.mediawiki.com Official Mediawiki Site]\"",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 109,
            "#text": "Guide for writing in mediawiki syntax will be posted here\n\n[http://www.mediawiki.com Official Mediawiki Site]"
          },
          "sha1": "sbax2ouer801q5xsdytb3kkkw3d7w07"
        }
      },
      {
        "title": "Meta-language",
        "ns": 0,
        "id": 1832,
        "redirect": {
          "@title": "Meta-logic",
          "#text": null
        },
        "revision": {
          "id": 3468,
          "timestamp": "2006-12-29T21:33:28Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "meta-meta-nonsense...",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 24,
            "#text": "#REDIRECT [[meta-logic]]"
          },
          "sha1": "g7x6ffc4gzleqdwjq0t3ibn6jwxp8ef"
        }
      },
      {
        "title": "Meta-logic",
        "ns": 0,
        "id": 1490,
        "revision": {
          "id": 3757,
          "parentid": 3472,
          "timestamp": "2007-02-26T14:43:20Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "minor": null,
          "comment": "fix redlink and syntax",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 681,
            "#text": "A '''meta-logic''' is a logic for reasoning about another logic. When working with Twelf, there are two common usages for the term \"meta-logic.\"\n\nThe first meaning of this term is \"a logic used to encode a [[object logic]].\" When using Twelf, [[LF]] is the meta-logic used to create an [[adequacy|adequate]] encoding of an object logic. When used this way, a meta-logic may also be called a '''meta-language.''' \n\nThe second meaning of the term is that a meta-logic is a logic in which we state and prove [[metatheorem]]s. In this case Twelf's facility used to state and verify [[totality assertion]]s is the meta-logic used to reason about derivations in object logics. \n\n{{stub}}"
          },
          "sha1": "qxq8e46lv0ys6x4dbqw6pcffmjr01ek"
        }
      },
      {
        "title": "Metatheorem",
        "ns": 0,
        "id": 1823,
        "revision": {
          "id": 6121,
          "parentid": 3901,
          "timestamp": "2010-09-06T10:31:48Z",
          "contributor": {
            "ip": "217.157.225.12"
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 11291,
            "#text": "A '''metatheorem''' is a theorem about an [[object language]]. This is a very general statement, but '''metatheorem''' is a very general term. Many interesting metatheorems can be posed as ''{{forall}}{{exists}}-statements,'' and these are the kind of metatheorems that can be verified in Twelf. Another kind of metatheorem is a ''[[totality assertion]]''; these are more limited because any totality assertion can also be posed as a {{forall}}{{exists}}-statement. \n\nTwelf can prove {{forall}}{{exists}}-metatheorems in one of two ways. The first method, the [[theorem prover]], is incomplete and not currently recommended for use. It allows the user to directly specify a {{forall}}{{exists}}-statement about LF terms, and then ask Twelf to verify that statement. The other method is to write out a proof of the {{forall}}{{exists}} statement in Twelf, and then use Twelf's ability to state and verify [[totality assertions]] to show that the proof is correct.\n\n== Object language ==\n\nThe object language is \"the object of study\": a logic, programming language, or other deductive system that the user wishes to reason about with Twelf. Simple examples of object languages are [[natural numbers]] and the [[simply-typed lambda calculus]], more complex examples can be found in the [[case studies]] or [[research projects using Twelf]]. Object languages like the simply-typed lambda calculus and first-order logic demonstrate the power of Twelf's [[higher-order abstract syntax]], but the example of natural numbers with addition is used here for its simplicity. The syntax and judgments over the natural numbers can be simply presented in [[w: Backus-Naur form| Backus-Naur form]]:\n\n<math>\\textit{nat} ::= 0 \\,|\\, \\texttt{s}(\\textit{nat})</math>\n\nWe then declare <math>\\texttt{plus}(\\textit{nat},\\textit{nat},\\textit{nat})</math> to be a judgment that relates three natural numbers. We can define what kind of judgments we are allowed to relate by using inference rules:\n\n<math>{\\qquad \\over \\texttt{plus}(0,N,N)}{\\mbox{p-z}}</math> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <math>{\\texttt{plus}(N_1,N_2,N_3) \\over \\texttt{plus}(\\texttt{s}(N_1),N_2,\\texttt{s}(N_3))}{\\mbox{p-s}}</math>\n\n== Theorems == \n\nThe usual interpretation of inference rules like the ones above is that we can consider some fact ''A'' to be true if we can create a complete derivation that has ''A'' a result. Truths that can be verified by writing a derivation are called ''theorems.'' If the object language is the [[natural numbers]], then the following is a theorem theorem proving that 2 + 1 = 3.\n\n<math> {{{\\;} \\over {\n\\texttt{plus}(0,\\;\\;\\texttt{s}(0),\\;\\;\\texttt{s}(0))}}{\\mbox{p-z}} \\over {{\n\\texttt{plus}(\\texttt{s}(0),\\;\\;\\texttt{s}(0),\\;\\;\\texttt{s}(\\texttt{s}(0)))} \\over {\n\\texttt{plus}(\\texttt{s}(\\texttt{s}(0)),\\;\\;\\texttt{s}(0),\\;\\;\\texttt{s}(\\texttt{s}(\\texttt{s}(0))))}}{\\mbox{p-s}}}{\\mbox{p-s}} </math>\n\nSimilarly, if the object language is the [[simply-typed lambda calculus]], then a theorem might state that the expression <math>(\\lambda x : \\texttt{unit}. x) \\langle\\rangle</math> steps to <math>\\texttt{}\\langle\\rangle</math>. This can be shown by using the rules <tt>step_app_beta</tt> and <tt>value_empty</tt>.\n\n== Totality assertions ==\n\nThe term \"metatheorem,\" as previously stated, is a very general term. We first want to think about a specific kind of metatheorem, a [[totality assertion]]. \n\nA totality assertion for the informal deductive system presented above might be that, for any two natural numbers <math>\\texttt{}N_1</math> and <math>\\texttt{}N_2</math>, there is a natural number <math>\\texttt{}N_3</math> for which <math>\\texttt{plus}(N_1,N_2,N_3)</math> is derivable. This means that the judgment <math>\\texttt{plus}(N_1,N_2,N_3)</math> forms a total relation, mapping any inputs in the first and second positions of the relation to some output in the third position. Note that the output need not be unique; the totality assertion holds even if there are many such numbers.\n\nThe totality assertions in Twelf establish a stronger property. The Twelf [[encoding]] of the <math>\\texttt{plus}(N_1,N_2,N_3)</math> judgment can be run as a logic program, and totality assertions that are verified by <tt>[[%total]]</tt> directives verify that, if an encoding is run as a higher-order logic program in Twelf, it will act as a function that, given appropriate inputs, will find an output in a finite amount of time. Twelf's totality analysis is incomplete in that some relations that are total cannot be verified by a <tt>%total</tt> declaration.\n\nTwelf, when used in this way, can be thought of as a \"theorem prover\" in the limited sense that it ''proves'' that a relation is total by doing a program analysis that shows that, given appropriate inputs, it produces outputs when run as a logic program in Twelf.  However, it is more common to describe Twelf as ''verifying'' the totality assertions, both because Twelf does not produce a proof witness and because the analysis is not as sophisticated as most theorem proving procedures. Usually, the relations about which programmers intend to prove totality assertions are specifically constructed to be analyzable by Twelf's <tt>%total</tt> directive. These relations often correspond closely to an informal proof by structural induction of the same fact, making Twelf's process of verifying totality similar to the human process of verifying that a proof is valid.\n\n== {{forall}}{{exists}}-statements ==\n\nTotality assertions seem very limited in scope. We have merely shown that, given a judgment like <math>\\texttt{plus}</math>, we can interpret as the judgment as a relation from some inputs to some outputs and prove that the relation, given inputs, have rules that will always allow us to find outputs. But we can't, for instance, write a totality assertion on <math>\\texttt{plus}</math> that will allow us to prove that the relation is commutative or associative.\n\nThe theorem \"addition is commutative\" can be specified more precisely like this: for all natural numbers <math>\\texttt{}N_1</math>, <math>\\texttt{}N_2</math>, <math>\\texttt{}N_3</math> and derivation of the judgment <math>\\texttt{plus}(N_1,N_2,N_3)</math>, there exists a derivation of the judgment <math>\\texttt{plus}(N_2,N_1,N_3)</math>. The previous statement, at a high level, said \"for all (some things) there exist (some other things.\" Statement with this forms are called {{forall}}{{exists}}-statement.\n\nThe page about Twelf's [[theorem prover]] shows how the theorem prover could be used to state, and prove, this statement, but the currently recommended way of doing this is by using a totality assertion. The series of tutorials on [[proving metatheorems with Twelf]] explain in detail how to do this; the remainder of this article will only give a very general view based on the notes from [http://www.cs.cmu.edu/~fp/courses/lp/lectures/18-proofs.html Lecture 18] of Frank Pfenning's course on Logic Programming.\n\n=== Simple types ===\n\nFirst, think back at our presentation of the structure of natural numbers:\n\n<math>\\textit{nat} ::= 0 \\,|\\, \\texttt{s}(\\textit{nat})</math>\n\nWe will now think of this BNF grammar as defining the members of the ''type'' <math>\\texttt{}\\textit{nat}</math>. In this view <math>\\texttt{}0</math> is an object of type <math>\\textit{nat}</math>, and <math>\\texttt{s}</math> is a constructor that, given an object of type <math>\\textit{nat}</math>, produces an object of type <math>\\textit{nat}</math>.\n\n=== Proof terms ===\n\nNow, look back at this derivation\n\n<math> {{{\\;} \\over {\n\\texttt{plus}(0,\\;\\;\\texttt{s}(0),\\;\\;\\texttt{s}(0))}}{\\mbox{p-z}} \\over {{\n\\texttt{plus}(\\texttt{s}(0),\\;\\;\\texttt{s}(0),\\;\\;\\texttt{s}(\\texttt{s}(0)))} \\over {\n\\texttt{plus}(\\texttt{s}(\\texttt{s}(0)),\\;\\;\\texttt{s}(0),\\;\\;\\texttt{s}(\\texttt{s}(\\texttt{s}(0))))}}{\\mbox{p-s}}}{\\mbox{p-s}} </math>\n\nand notice that applying the rule <math>\\texttt{p-s}</math> twice to the rule <math>\\texttt{p-z}</math>, as we do here, gives us a way to derive <math>\\texttt{plus}(\\texttt{s}(\\texttt{s}(0)),\\;N,\\;\\texttt{s}(\\texttt{s}(N)))</math> for ''any'' natural number <tt>N</tt>; in the example above, <tt>N</tt> happens to be <math>\\texttt{s}(0)</math>.\n\nNatural numbers are objects, and we can think of derivations as objects as well: we can represent this process of applying the rule <math>\\texttt{p-s}</math> twice to the rule <math>\\texttt{p-z}</math> using standard notation for application: <math>\\texttt{p-s}(\\texttt{p-s}(\\texttt{p-z}))</math>. These objects are called generally called ''proof terms'', and the ''type'' of a proof term is the judgment it can produce. This idea that judgments can be types is one of the important observations of the [[w:Curry-Howard isomorphism|Curry-Howard isomorphism]].\n\nThe proof term <math>\\texttt{p-s}(\\texttt{p-s}(\\texttt{p-z}))</math> can be thought of as having the type <math>\\texttt{plus}(\\texttt{s}(\\texttt{s}(0)),\\;\\texttt{s}(0),\\;\\texttt{s}(\\texttt{s}(\\texttt{s}(0))))</math>, but it can also be thought of as having the type\n<math>\\texttt{plus}(\\texttt{s}(\\texttt{s}(0)),\\;0,\\;\\texttt{s}(\\texttt{s}(0)))</math>. Remembering our analysis above, we can see that the most general type we can give the proof object <math>\\texttt{p-s}(\\texttt{p-s}(\\texttt{p-z}))</math> is <math>(\\forall N:\\textit{nat}.\\;\\texttt{plus}(\\texttt{s}(\\texttt{s}(0)),\\;N,\\;\\texttt{s}(\\texttt{s}(N))))</math>.\n\n=== Proving {{forall}}{{exists}}-statements using totality assertions ===\n\nRecall that when we first defined the judgment <math>\\texttt{plus}</math>, we mentioned the type of objects that it related:\n\n<math>\\texttt{plus}(\\textit{nat},\\textit{nat},\\textit{nat})</math>\n\nWe will now write a judgment that, instead of relating objects with type <math>\\texttt{}\\textit{nat}</math>, relates derivations of <math>\\texttt{plus}(N_1,N_2,N_3)</math> and <math>\\texttt{plus}(N_2,N_1,N_3)</math>. Call this derivation <math>\\texttt{plus-comm}</math>. \n\n<math>\\forall N_1:\\textit{nat} . \\;\\forall N_2:\\textit{nat} . \\;\\forall N_3:\\textit{nat} . \\;\\texttt{plus-comm}(\\texttt{plus}(N_1,N_2,N_3),\\;\\;\\texttt{plus}(N_2,N_1,N_3))</math> \n\nDescribing the rules that define this judgment is beyond the scope of this article; see Frank Pfenning's notes [http://www.cs.cmu.edu/~fp/courses/lp/lectures/18-proofs.html notes] for a continuation of this approach, or [[proving metatheorems with Twelf]] for a description that is closer to how Twelf is used in practice. However, without describing these rules, if they were written and written correctly, we could verify a totality assertion that stated that <tt>plus-comm</tt> is a total relation with derivations of <math>\\texttt{plus}(N_1,N_2,N_3)</math> as an input and derivations of <math>\\texttt{plus}(N_2,N_1,N_3)</math> as an output.\n\nThis means that, for any three natural numbers <math>\\texttt{}N_1</math>, <math>\\texttt{}N_2</math>, and <math>\\texttt{}N_3</math>, and any proof object with the type <math>\\texttt{plus}(N_1,N_2,N_3)</math>, there is a proof object with type <math>\\texttt{plus}(N_2,N_1,N_3)</math>. This is equivalent to the {{forall}}{{exists}}-statement for the commutativity of addition that we started out with; the only difference is that we are now speaking in terms of proof objects and types instead of derivations and judgments."
          },
          "sha1": "6jiv2pbzpy7gjr9j01jh6v1tq6uf7np"
        }
      },
      {
        "title": "Metatheorems",
        "ns": 0,
        "id": 1834,
        "redirect": {
          "@title": "Metatheorem",
          "#text": null
        },
        "revision": {
          "id": 3475,
          "timestamp": "2006-12-29T22:20:08Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "minor": null,
          "comment": "Redirecting to [[Metatheorem]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 25,
            "#text": "#REDIRECT [[metatheorem]]"
          },
          "sha1": "730t5knuh85p30s2lyh9dwy17dizmll"
        }
      },
      {
        "title": "MinMLToMinHaskell",
        "ns": 0,
        "id": 2216,
        "revision": {
          "id": 6018,
          "timestamp": "2009-10-22T21:56:57Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "comment": "Created page with '%{  Translation from MinML (unencapsulated effects) to MiniHaskell (monadic effects). Uses third-order coverage checking.  }%  %{  == MiniHaskell ==  }%  tp : type.  unit : tp. a...'",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 4335,
            "#text": "%{\n\nTranslation from MinML (unencapsulated effects) to MiniHaskell (monadic effects).\nUses third-order coverage checking.\n\n}%\n\n%{\n\n== MiniHaskell ==\n\n}%\n\ntp : type.\n\nunit : tp.\narr  : tp -> tp -> tp.\nplus : tp -> tp -> tp.\ncirc : tp -> tp.\n\nconc : type.\n\ntrue : tp -> conc.\nlax  : tp -> conc.\n\n| : conc -> type.\n%prefix 0 |.\n\n<> : | true unit.\nlam : (| true A -> | true B) -> | true (arr A B).\napp : | true (arr A B) -> | true A -> | true B.\ninl : | true A -> | true (plus A B).\ninr : | true B -> | true (plus A B).\ncase : | true (plus A B) -> (| true A -> | J) -> (| true B -> | J) -> | J.\ncomp : | lax A -> | true (circ A).\n\nreturn : | true A -> | lax A.\nlet    : | true (circ A) -> (| true A -> | lax C) -> | lax C.  \nprint  : | lax C -> | lax C.\n\n%block trueb : some {A : _} block {x : | true A}.\n%worlds (trueb) (| _).\n\n%{\n\n== MinML ==\n\n}%\n\nmtp : type.\n\nmunit : mtp.\nmarr  : mtp -> mtp -> mtp.\nmplus : mtp -> mtp -> mtp.\n\nmtrue : mtp -> type.\nm<> : mtrue munit.\nmlam : (mtrue A -> mtrue B) -> mtrue (marr A B).\nmapp : mtrue (marr A B) -> mtrue A -> mtrue B.\nminl : mtrue A -> mtrue (mplus A B).\nminr : mtrue B -> mtrue (mplus A B).\nmcase : mtrue (mplus A B) -> (mtrue A -> mtrue C) -> (mtrue B -> mtrue C) -> mtrue C.\nmprint : mtrue C -> mtrue C.\n\n%{\n\n== Translation ==\n\n}%\n\ntptrans : mtp -> tp -> type.\n%mode tptrans +A -B.\n\ntptrans/unit : tptrans munit unit.\ntptrans/arr : tptrans (marr A B) (arr A' (circ B'))\n\t     <- tptrans A A'\n\t     <- tptrans B B'.\ntptrans/plus : tptrans (mplus A B) (plus A' B')\n\t     <- tptrans A A'\n\t     <- tptrans B B'.\n \n%worlds () (tptrans _ _).\n%total A (tptrans A _).\n%unique tptrans +A -1A'.\n\nid-tp : tp -> tp -> type.\nid-tp/refl : id-tp A A.\n\ntrueresp : | true A -> id-tp A A' -> | true A' -> type.\n%mode trueresp +X1 +X2 -X3.\n- : trueresp E id-tp/refl E.\n%worlds (trueb) (trueresp _ _ _).\n%total {} (trueresp _ _ _).\n\nlaxresp : | lax A -> id-tp A A' -> | lax A' -> type.\n%mode laxresp +X1 +X2 -X3.\n- : laxresp E id-tp/refl E.\n%worlds (trueb) (laxresp _ _ _).\n%total {} (laxresp _ _ _).\n\ncan-tptrans : {A} tptrans A A' -> type.\n%mode can-tptrans +A -D.\n%worlds () (can-tptrans _ _).\n%trustme %total A (can-tptrans A _).\n\ntptrans-unique : tptrans A A' -> tptrans A A'' -> id-tp A' A'' -> type.\n%mode tptrans-unique +D1 +D2 -D3.\n%worlds () (tptrans-unique _ _ _).\n%trustme %total D (tptrans-unique D _ _).\n\n\ntrans : mtrue A -> tptrans A A' -> | lax A' -> type.\n%mode trans +E +TT -E'.\n\n- : trans m<> tptrans/unit (return <>).\n- : trans \n     (mlam E) \n     (tptrans/arr (DB : tptrans B B') DA) \n     (return (lam ([x] (comp (E' x)))))\n     <- ({x : mtrue A} {x' : | true A'} \n\t   {_ : {A'' : _} {DA'' : tptrans A A''} {Did : id-tp A' A''} {E'' : | lax A''}\n\t\t trans x DA'' E''\n\t\t <- tptrans-unique DA DA'' Did\n\t\t <- laxresp (return x') Did E''}\n\t   trans (E x) DB (E' x')).\n- : trans (mapp (E1 : mtrue (marr A B)) E2)\n     DB\n     (let (comp E1') \n\t[x1] (let (comp E2') \n\t\t[x2] (let (app x1 x2) \n\t\t\t([r] (return r)))))\n     <- can-tptrans A DA\n     <- trans E1 (tptrans/arr DB DA) E1'\n     <- trans E2 DA E2'.\n- : trans (minl E) (tptrans/plus DB DA) (let (comp E') [x] (return (inl x)))\n     <- trans E DA E'.\n- : trans (minr E) (tptrans/plus DB DA) (let (comp E') [x] (return (inr x)))\n     <- trans E DB E'.\n- : trans \n     (mcase (E : mtrue (mplus A B)) E1 E2)\n     DC\n     (let (comp E') ([x] case x E1' E2'))\n     <- can-tptrans A DA\n     <- can-tptrans B DB\n     <- trans E (tptrans/plus DB DA) E'\n     <- ({x : mtrue A} {x' : | true A'} \n\t   {_ : {A'' : _} {DA'' : tptrans A A''} {Did : id-tp A' A''} {E'' : | lax A''}\n\t\t trans x DA'' E''\n\t\t <- tptrans-unique DA DA'' Did\n\t\t <- laxresp (return x') Did E''}\n\t   trans (E1 x) DC (E1' x'))\n     <- ({x : mtrue B} {x' : | true B'} \n\t   {_ : {B'' : _} {DB'' : tptrans B B''} {Did : id-tp B' B''} {E'' : | lax B''}\n\t\t trans x DB'' E''\n\t\t <- tptrans-unique DB DB'' Did\n\t\t <- laxresp (return x') Did E''}\n\t   trans (E2 x) DC (E2' x')).\n- : trans (mprint E) DC (print E')\n     <- trans E DC E'.\n     \n%block transb : some {A : _} {A' : _} {DA : tptrans A A'}\n\t\t block \n\t\t {x : mtrue A} {x' : | true A'} \n\t\t {_ : {A'' : _} {DA'' : tptrans A A''} {Did : id-tp A' A''} {E'' : | lax A''}\n\t\t       trans x DA'' E''\n\t\t       <- tptrans-unique DA DA'' Did\n \t\t       <- laxresp (return x') Did E''}.\n%worlds (transb) (trans _ _ _).\n%total E (trans E _ _)."
          },
          "sha1": "j9ykyzsp30so4x5jrnux2lt3xavrrvi"
        }
      },
      {
        "title": "Modal logic",
        "ns": 0,
        "id": 2087,
        "revision": {
          "id": 6547,
          "parentid": 5714,
          "timestamp": "2012-10-05T16:46:25Z",
          "contributor": {
            "ip": "159.149.151.26"
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 4330,
            "#text": "In this page we show how to encode modal logic in LF. Similarly to [[linear logic]], the main idea here is to define a judgment that explicitly restricts the use of non-necessity assumptions (any assumption of a proof for a judgment that is not necessary). \n\n== The Encoding ==\n=== Syntax ===\n<twelf>\n% Terms\ntm : type.\n\nunit : tm.\napp : tm -> tm -> tm.\nlam : (tm -> tm) -> tm.\nbx : tm -> tm.\nletbox : tm -> ( tm -> tm) -> tm.\n\n% Types\ntp:type.\no:tp.\narrow: tp -> tp -> tp.\nbox: tp -> tp.\ndia: tp -> tp.\n\n</twelf>\n\n=== Local Judgment ===\nThe correct use of an assumption inside a proof term can be enforced by a <tt>local</tt> judgment. This jugment ensures that a variable is never used inside any term <tt> bx M </tt> that exists within its scope (we say that the variable is local). \n\n<twelf>\nlocal : (tm -> tm) -> type.\n</twelf>\n\nThe simplest cases are the one for variables.\n\n<twelf>\nlocal/var:  local ([x] x).\n</twelf>\n\n<twelf>\nlocal/closed:  local ([x] M).\n</twelf>\n\n\nA variable is local in an abstraction if it is local inside the abstraction's body. Note that the abstraction's argument (which must be local as well) is handled separately by the abstraction's typing rule.   \n\n<twelf>\nlocal/lam: local ( [x] lam ([y] N x y))\n      \t  <- {y} local ([x] N x y).\n</twelf>\n\nA variable is local in an application if it is local inside its subterms.\n\n<twelf>\nlocal/app : local ([x] app (M x) (N x))\n\t<- local ([x] M x)\n\t<- local ([x] N x).\n</twelf>\n\nThe same idea applies to letbox.\n\n<twelf>\nlocal/letbox: local ([x] letbox (M x) ([y] N x y))\n       \t   <- local ([x] M x)\n           <- {y} local ([x] N x y).\n</twelf>\n\nSignificantly, there is no rule for bx.  Local variables are not permitted to appear within box terms.\n\n=== Typing rules ===\nThe key idea introduced by our enconding of modal logic is that typing rules need to check (using the local judgment described above) that non-necessary assumptions are never used inside a term <tt>bx M </tt>. In our case, abstractions are the only terms that bind restricted (non-necessary) variables, and therefore the rule for <tt>letbox</tt> does not need to check whether its variable is local or not. \n\n\n<twelf>\nof : tm -> tp -> type. \n\nof/unit: of unit o.\n\nof/bx:  of ( bx M ) ( box T ) \n\t <- of M T.\n\nof/lam:  of (lam M) (arrow A  B) \n\t <- ( {n:tm} of n A -> of ( M n) B )\n\t <- local M.\n\nof/letbox: of ( letbox N M ) B \n\t   <- of N (box A) \n\t   <- ( {n:tm} of n  A -> of ( M n) B ). \n\nof/app: (of M (arrow T1  T2)) ->  (of N T1) -> (of ( app M N ) T2).\n</twelf>\n\n<twelflink>Source code for the encoding</twelflink>\n\n= Type Preservation =\nAs an example, we can prove preservation using our encoding.\n\n== Evaluation Rules ==\nFirst, we define the <tt>value</tt> judgment and evaluation rules.\n\n<twelf>\nvalue: tm -> type.\n\nvalue/unit: value (unit).\nvalue/lam: value (lam M).\nvalue/bx: value (bx M)\n\t   <- value M.\n\n\n%%%%%% Evaluation rules %%%%%%\nstep : tm -> tm -> type.\n\nstep/beta: step ( app (lam N ) M) (N M)\n\t    <- value M.\n\nstep/app1: step (app M N) (app M1 N) \n\t    <- step M M1\n\t   <- value N.\n\nstep/app2: step (app M N) (app M N1) \n       <- step N N1.\n      \n\nstep/bx: step (bx M) (bx N) \n     <- step M N.\n\nstep/letbox: step (letbox M N) ( letbox M' N) \n\t  <- step M M'.\n\n\nstep/letbox/beta: step (letbox (bx M) N) ( N M)\n\t\t   <- value M.\n\n</twelf>\n\n== Type Preservation Proof ==\n<twelf>\nstep-type: of M A -> step M N -> of N A -> type.\n%mode step-type +M +R -N.\n\nstep-type/beta: step-type  ( of/app (of/lam LN P) OM)\n\t \t      ( step/beta _ : step (app (lam N) M) (N M))\n\t\t      ( P M OM  ).\n\n\n\n\n\nstep-type/app1 : step-type (of/app OM ON)\n\t  \t       (step/app1 _ R )\n\t\t       (of/app OM1 ON) \n\t\t <-\n\t\t step-type OM R OM1. \n\n\nstep-type/app2: step-type (of/app ON OM)\n\t  \t       (step/app2 R )\n\t\t       (of/app ON OM1) \n\t\t <-\n\t\t step-type OM R OM1. \n\n\nstep-type/bx: step-type (of/bx PM)\n\t \t      (step/bx S)\n\t\t      (of/bx PN)\n\t\t      <- step-type PM S PN.\n\nstep-type/letbox : step-type (of/letbox ON OM)\n\t  \t       (step/letbox R )\n\t\t       (of/letbox ON OM1) \n\t\t <-\n\t\t step-type OM R OM1. \n\nstep-type/letbox/beta: step-type ( of/letbox P (of/bx OM)) \n\t \t      (step/letbox/beta _)\n\t\t      (P M OM).\n\n%worlds ()  (step-type _ _ _ ).\n%total (R)(step-type R   _ _ ).\n\n</twelf>\n\n\n<twelflink>Complete Source code</twelflink>\n\n<twelflink check=true>Twelf Output</twelflink>"
          },
          "sha1": "n8u9bw05i04kbkdsxlba6l7rveaumjk"
        }
      },
      {
        "title": "Modally Propositional Logic",
        "ns": 0,
        "id": 2219,
        "revision": {
          "id": 6056,
          "timestamp": "2010-03-01T16:10:30Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "comment": "Created page with '%{   == Modally-Propositional Logic ==   }%  world : type.  %name world W. world1 : world. succ : world -> world. %% so it doesn't split worlds, which makes the coverage checking...'",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 4656,
            "#text": "%{ \n\n== Modally-Propositional Logic == \n\n}%\n\nworld : type.  %name world W.\nworld1 : world.\nsucc : world -> world. %% so it doesn't split worlds, which makes the coverage checking output annoying\n\n%block worldb : block {w : world}.\n%worlds (worldb) (world).\n\nacc : world -> world -> type.\nrefl : acc W W.\ntrans : acc W1 W2 -> acc W2 W3 -> acc W1 W3.\n%block accb : some {W1 : _}{W2 : _}\n\t       block {a : acc W1 W2}.\n%worlds (worldb | accb) (acc _ _).\n\nprop : world -> type. %name prop A.\n\n%abbrev boxprop : world -> type = [w] {w'} acc w w' -> prop w'.\n\nbox  : boxprop W -> prop W.\nimp  : prop W -> prop W -> prop W.\nat   : prop W' -> prop W.\ndown : boxprop W -> prop W.\n\n%block propb : some {W : world}\n\t\tblock {a : prop W}.\n%worlds (worldb | accb | propb ) (prop _).\n\nhyp  : prop W -> type.\nconc : prop W -> type.\n\nimpL : conc C\n\t<- hyp (imp A B) \n\t<- conc A\n\t<- (hyp B -> conc C).\nimpR : conc (imp A B)\n\t<- (hyp A -> conc B).\n\natL : conc C\n       <- hyp (at A)\n       <- (hyp A -> conc C).\natR : conc (at A)\n       <- conc A.\n\nboxR : conc (box (A : boxprop W))\n\t<- {w'} {a : acc W w'} conc (A w' a).\nboxL : {a : acc W W'}\n\tconc C\n\t<- hyp (box (A : boxprop W))\n\t<- (hyp (A W' a) -> conc C).\n\ndownR : conc ((down A) : prop W)\n\t <- conc (A W refl).\ndownL : conc C\n\t <- hyp ((down A) : prop W)\n\t <- (hyp (A W refl) -> conc C).\n\n%block hypb : some {W : _} {A : prop W}\n\t       block {x : hyp A}.\n%block prophypb : some {W : _} \n\t\t   block {a : prop W} {h : hyp a -> conc a}.\n \n%worlds (worldb | accb | prophypb | hypb ) (hyp _) (conc _).\n\nid : {A : prop W} (hyp A -> conc A) -> type.\n%mode id +X1 -X2.\n\n- : id (imp A B) ([f] impR [x] impL E' (E x) f)\n     <- id A E\n     <- id B E'.\n\n- : id (box (A : boxprop W)) ([b] boxR [w'] [a] boxL a (E w' a) b)\n     <- {w} {a : acc W w} id (A w a) (E w a).\n\n- : id (down A) ([d] downR (downL (E _ refl) d))\n     <- {w} {a : acc W w} id (A w a) (E w a).\n%% ambipolar: \n% - : id (down A) ([d] downL ([x] downR (E _ refl x)) d)\n%      <- {w} {a : acc W w} id (A w a) (E w a).\n\n- : id (at A) ([a] (atR (atL E a)))\n     <- id A E.\n%% ambipolar: \n% - : id (at A) ([a] (atL ([x1] atR (E x1)) a))\n%      <- id A E.\n\n%block idcase : some {W : _} \n\t\t block {a : prop W} {h : hyp a -> conc a}\n\t\t {_ : id a h}.\n\n%worlds (worldb | accb | idcase | hypb) (id _ _).\n%total A (id A _).\n\nca : {A}\n      conc A \n      -> (hyp A -> conc C)\n      -> conc C\n      -> type.\n%mode ca +A +D +E -F.\n\n- : ca _ (atR D) ([x] atL ([y] E x y) x) E''\n     <- ({y} ca _ (atR D) ([x] E x y) (E' y))\n     <- ca _ D E' E''.\n\n- : ca _ (boxR D) ([x] boxL A ([y] E x y) x) E''\n     <- ({y} ca _ (boxR D) ([x] E x y) (E' y))\n     <- ca _ (D _ A) E' E''.\n\n- : ca _ (downR D) ([x] downL ([y] E x y) x) E''\n     <- ({y} ca _ (downR D) ([x] E x y) (E' y))\n     <- ca _ D E' E''.\n\n- : ca ((imp A B) : prop WAB) (impR D) ([x] impL ([y] E x y) (Arg x) x) (E'' : conc (C : prop WC))\n     <- ({y} ca (imp A B) (impR D) ([x] E x y) (E' y))\n     <- (ca (imp A B) (impR D) ([x] Arg x) Arg')\n     <- ca A Arg' D D'\n     <- ca B D' E' E''.\n\n%% left commutative\n\n- : ca _ (atL D D') E (atL D1 D') \n     <- ({y} ca _ (D y) E (D1 y)).\n\n- : ca _ (boxL A D D') E (boxL A D1 D') \n     <- ({y} ca _ (D y) E (D1 y)).\n\n- : ca _ (impL D A D') E (impL D1 A D') \n     <- ({y} ca _ (D y) E (D1 y)).\n\n- : ca _ (downL D D') E (downL D1 D') \n     <- ({y} ca _ (D y) E (D1 y)).\n\n%% right commutative\n\n- : ca _ D ([x] (impR ([y] E x y))) (impR F)\n     <- {y} ca _ D ([x] E x y) (F y).\n\n- : ca _ D ([x] (atR (E x))) (atR F)\n     <- ca _ D ([x] E x) F.\n\n- : ca _ D ([x] (downR (E x))) (downR F)\n     <- ca _ D ([x] E x) F.\n\n- : ca _ D ([x] (boxR [w'] [a] (E w' a x))) (boxR F)\n     <- {w'}{a} ca _ D ([x] E w' a x) (F w' a).\n\n- : ca _ D ([x] (boxL A ([y] E x y) Y)) (boxL A F Y)\n     <- {y} ca _ D ([x] E x y) (F y).\n\n- : ca _ D ([x] (downL ([y] E x y) Y)) (downL F Y)\n     <- {y} ca _ D ([x] E x y) (F y).\n\n- : ca _ D ([x] (atL ([y] E x y) Y)) (atL F Y)\n     <- {y} ca _ D ([x] E x y) (F y).\n\n- : ca _ D ([x] (impL ([y] E x y) (Arg x) Y)) (impL F Arg' Y)\n     <- ({y} ca _ D ([x] E x y) (F y))\n     <- ca _ D ([x] Arg x) Arg'.\n\n%block capropb : some {W : _} \n\t\t   block {a : prop W} {init : hyp a -> conc a}\n\t\t   %% principal\n \t\t   {_ : {y : hyp a} ca a (init y) init (init y)}\n\t\t   %% right commutative\n\t\t   {_ : {W' : world} {A : prop W'} {D : conc A} {y : hyp a} \n\t\t\t ca A D ([_] (init y)) (init y)}.\n\n%% FIXME: this shouldn't pass:\n%% propb is not equivalent to prophypb for hyp and conc.\n%% does twelf only check world subsumption on subgoals?\n%% %worlds (worldb | accb | propb | hypb) (ca _ _ _ _). \n\n%worlds (worldb | accb | capropb | hypb) (ca _ _ _ _). \n%total {A D E} (ca A D E _)."
          },
          "sha1": "b8e8jm729oqobedfut1j77f66snd6gj"
        }
      },
      {
        "title": "Mode",
        "ns": 0,
        "id": 1851,
        "redirect": {
          "@title": "%mode",
          "#text": null
        },
        "revision": {
          "id": 3660,
          "timestamp": "2007-02-21T14:33:38Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "comment": "mode",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 19,
            "#text": "#REDIRECT [[%mode]]"
          },
          "sha1": "ttkuc0y26rgkbiqzf1wul463ab8em1b"
        }
      },
      {
        "title": "Mode checking",
        "ns": 0,
        "id": 1983,
        "redirect": {
          "@title": "%mode",
          "#text": null
        },
        "revision": {
          "id": 4668,
          "timestamp": "2007-04-01T00:17:02Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "Redirecting to [[%mode]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 19,
            "#text": "#REDIRECT [[%mode]]"
          },
          "sha1": "ttkuc0y26rgkbiqzf1wul463ab8em1b"
        }
      },
      {
        "title": "Modes of use",
        "ns": 0,
        "id": 1986,
        "revision": {
          "id": 4710,
          "parentid": 4695,
          "timestamp": "2007-04-12T05:38:07Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 5443,
            "#text": "%{ \n\nTwelf is a very flexible system that lends itself to a wide variety of [[deductive systems]]. This flexibility can be confusing, as different uses of Twelf look very different from one another. Here, we attempt to describe a number of the major modes of use of Twelf.\n\n* '''[[#A framework for defining logics|A framework for defining logics]]''' - The judgments of a logic are encoded in Twelf so that Twelf's type checker can check the correctness of proofs. The Foundational Proof Carrying Code project at Princeton used this method extensively to write proofs about programs that could be verified by a small, trusted checker. The primary tutorial for this style is Andrew Appel's [http://www.cs.princeton.edu/~appel/twelf-tutorial/ Hints on Proving Theorems in Twelf]\n* '''[[#Proving properties about deductive systems|Proving properties about deductive systems]] - This is a relatively recent use of Twelf, but it is also perhaps the most widespread. The judgments of a deductive system, typically a programming language, are encoded in Twelf, and then Twelf is used to verify [[metatheorems]] about that deductive system. The primary tutorial for this style is [[User:Drl|Dan Licata's]] [[Proving metatheorems with Twelf]], though several others can be found on the [[Documentation]] page.\n* Typed logic programming - Twelf can also be used as an advanced typed logic programming language, a variant of Lambda Prolog with dependent types.\n\nMost large projects integrate several of these modes of use. There are some limitations to this integration, particularly in that the [[constraint domains]] and [[type level definitions]] cannot be used in projects that want to prove [[metatheorems]]. \n\n\n== A framework for defining logics ==\n\nThe \"theorem style\" use of Twelf described in Andrew Appel's notes defines a deductive system, typically a '''logic''': first a set of propositions (propositions often have type <tt>o</tt> for historical reasons), and then axioms about how propositions can be proven. Appel's FPCC project uses higher-order logic, but here we define a much simpler propositional logic.\n\n}%\n\no : type.\n\n% Propositions\n\ntrue : o.\nimp : o -> o -> o. %infix right 10 imp.\nand : o -> o -> o. %infix right 11 and.\n\n% Judgments\n\npf : o -> type.\n\ntrue-i : pf true.\n\nimp-i : (pf A -> pf B) -> pf (A imp B).\nimp-e : pf (A imp B) -> pf A -> pf B.\n\nand-i : pf A -> pf B -> pf (A and B).\nand-e1 : pf (A and B) -> pf A.\nand-e2 : pf (A and B) -> pf B.\n\n%{ Having defined this a logic, the point of the exercise is to write out proofs by hand (perhaps with the assistance of [[tactical theorem proving]]). These proofs can then be automatically verified by Twelf, or by an extremely small independent checker.\n\nHere are some examples from the first lecture of Hints on Proving Theorems in Twelf: }%\n\nsymm-and: pf (A and B) -> pf (B and A) = \n  [p1 : pf (A and B)] \n  and-i (and-e2 p1) (and-e1 p1).\n\nand-l : pf (A and B) -> (pf A -> pf B -> pf C) -> pf C = \n  [p1 : pf (A and B)]\n  [p2 : pf A -> pf B -> pf C]\n  imp-e (imp-e (imp-i [p3] imp-i (p2 p3)) (and-e1 p1)) (and-e2 p1).\n\nexample-abc: pf (A and B) ->\n              pf C ->\n               pf ((B and C) and (A and C)) =\n [p1: pf (A and B)]        \n [p2: pf C]               \n and-l p1            \n        [p3: pf A]  \n        [p4: pf B]   \n and-i                \n (and-i p4           \n  p2)              \n (and-i p3 p2).        \n\n%{ Even this logic allows us to prove a number of interesting theorems; the definition of a more complex logic (without much commentary)  can be found at [[Zermelo Frankel]].\n\n\n== Proving properties about deductive systems == \n\nThe \"metatheorem style\" use of Twelf defines a deductive system, typically a '''programming language''': first the abstract syntax of the language, and then the static and dynamic semantics. Here is an example of a simple lambda calculus with product types (we don't define the dynamic semantics here, see {{proving|title=Representing the judgements of the STLC}} for a similar example). \n}%\n\n\nexp : type.\ntp  : type.\n\n\n% Expressions\n\nexp/unit : exp.\nexp/lam : tp -> (exp -> exp) -> exp.\nexp/app : exp -> exp -> exp.\nexp/pair : exp -> exp -> exp.\nexp/fst : exp -> exp.\nexp/snd : exp -> exp.\n\n\n% Types\n\nunit : tp.\narrow : tp -> tp -> tp.  %infix right 10 arrow.\npair : tp -> tp -> tp.   %infix right 11 pair.\n\n\n% Static semantics\n\nof : exp -> tp -> type.\n\nof/unit : of exp/unit unit.\n\nof/lam : of (exp/lam T1 ([x] E x)) (T1 arrow T2)\n          <- ({x: exp} of x T1 -> of (E x) T2).\nof/app : of (exp/app E E') T\n          <- of E' T'\n          <- of E (T' arrow T).\n\nof/pair : of (exp/pair E1 E2) (T1 pair T2)\n           <- of E2 T2\n           <- of E1 T1.\nof/fst : of (exp/fst E) T1\n          <- of E (T1 pair T2).\nof/snd : of (exp/snd E) T2\n          <- of E (T1 pair T2).\n\n\n% Dynamic semantics\n\nstep : exp -> exp -> type.\n\n% ... and so on\n\n%{ \n\nHaving defined this programming language, we are generally interested in proving [[metatheorems]] relating that programming language to a particular dynamic semantics - showing, for instance, that a certain evaluation strategy will preserve the type of the terms it evaluates, and that if a closed can be given a type, it can either be reduced or it is already a value. We also may be interested in using the [[logic programming]] engine of Twelf to ''run'' our typing judgments as a logic program, giving our language a reference type checker.\n\n\n=== Discussion === \n\n\n\n}%"
          },
          "sha1": "ovujqy6b9sjbvp32t8m5qmqkvwx63xd"
        }
      },
      {
        "title": "Mutable state",
        "ns": 0,
        "id": 1907,
        "revision": {
          "id": 5144,
          "parentid": 4936,
          "timestamp": "2008-04-08T03:40:04Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "add that this isn't an inherent limitation",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 23976,
            "#text": "%{\nThis article presents a simple language with mutable state—it has \n<tt>let</tt>-statements but, unlike many other examples such as the \n[[simply-typed lambda calculus]], it does not have functions, though this is for simplicity and is not an inherent limitation. It is based on \nChapter 2 of [[User:Rsimmons|Rob Simmons's]] undergraduate thesis,<ref><bibtex>@TechReport{simmons05thesis,\n author =       {Robert J. Simmons},\n title =        {Twelf as a Unified Framework for Language Formalization and Implementation},\n Institution =  {Princeton University},\n year =         {2005},\n note =   {Undergraduate Senior Thesis 18679},\n}</bibtex></ref> which contains more commentary—this account includes a simple extension, the ability to update state. That  account is in turn based on Pierce's description in TAPL.<ref>{{bibtex:pierce02tapl}}</ref>  This example can be seen as an extension of the one from the tutorial on [[strengthening]]; that example defines a language with references but no way to use them.\n\n== Language definition ==\n\n=== Natural numbers ===\n\nFirst we need [[natural numbers]], which we will use in the object language \nto represent both locations and actual numbers (this is why we define \n<tt>sum</tt> as well.)\n}%\n\nnat : type.\nz : nat. \ns : nat -> nat. \n\nsum : nat -> nat -> nat -> type. \n%mode sum +A +B -C. \nsum-z : sum z N N. \nsum-s : sum (s N1) N2 (s N3) \n\t <- sum N1 N2 N3. \n%worlds () (sum A B C). \n%total A (sum A B C). \n\n\n%{\n=== Syntax ===\n\nUsing this we can define the syntax of the language; natural numbers will be \nused both for locations (which the programmer cannot access) and as numbers, \nwhich can be added—the typing rules will ensure that natural numbers \nrepresenting heap locations cannot be confused with natural numbers that may \nbe added.\n\n* <tt>n N</tt> - integrates natural numbers into the language as <math>\\mathsf{n}(n)</math>, where <math>\\texttt{}n</math> is a natural number 0, 1, 2...\n* <tt>E1 + E2</tt> - addition, <math>\\texttt{}e_1 + e_2</math>\n* <tt>ref E</tt> - creating a reference cell, <math>\\mathsf{ref}(e)</math>\n* <tt>! E</tt> - dereferencing a reference cell, <math>\\texttt{}!e</math>\n* <tt>gets E1 E2</tt> - updating a reference cell, <math>\\texttt{}e_1 := e_2</math>\n* <tt>loc L</tt> - locations (not available to the programmer), <math>\\mathsf{loc}(l)</math>, where <math>\\texttt{}l</math> is an abstract location.\n* <tt>let E1 ([x] E2 x)</tt> - let statements <math>\\mathsf{let~} x = e_1 \\mathsf{~in~} e_2</math>\n}%\n\n%abbrev location = nat. \nexp : type. \nn : nat -> exp. \n+ : exp -> exp -> exp. %infix left 10 +. \nref : exp -> exp. \n! : exp -> exp. \ngets : exp -> exp -> exp. \nloc : location -> exp. \nlet : exp -> (exp -> exp) -> exp. \n\n%{ \n=== Types ===\n\nBecause we do not have functions, our language has a very simple language of types, only integers and references to other types.\n}%\n\ntp : type. \nint-tp : tp. \nref-tp : tp -> tp. \n\n%{\n=== Lists ===\n\nWe will represent the store as a list of expressions, and define several \noperations on lists—projecting the ''n''th element from a list, appending a new element to the end of a list, updating the ''n''th element of the list, and having a list that is the subset of another list. We also define a similar list of types that is omitted.\n}%\n\nexplist : type. \n\n$exp : exp -> explist -> explist.  %infix right 5 $exp. \nnil-exp : explist. \n\n\nproj-exp : explist -> nat -> exp -> type. \n%mode proj-exp +EL +N -E. \nproj-exp-z : proj-exp (E $exp EL) z E. \nproj-exp-s : proj-exp (E $exp EL) (s N) E’ \n\t     <- proj-exp EL N E’. \n\n\nappend-exp : explist -> exp -> explist -> nat -> type. \n%mode append-exp +EL +E -EL’ -N. \nappend-exp-z : append-exp nil-exp E (E $exp nil-exp) z. \nappend-exp-s : append-exp (E’ $exp EL) E (E’ $exp EL’) (s N) \n\t\t<- append-exp EL E EL’ N. \n\n\nsubset-exp : explist -> explist -> type. \n%mode subset-exp +EL +EL'.\nsubset-exp-z : subset-exp nil-exp E. \nsubset-exp-s : subset-exp (E $exp EL) (E $exp EL’) \n\t\t<- subset-exp EL EL’. \n\n\nupdate-exp : explist -> nat -> exp -> explist -> type.\n%mode update-exp +EL +N +E -EL'.\nupdate-exp-z : update-exp (E $exp EL) z E' (E' $exp EL).\nupdate-exp-s : update-exp (E $exp EL) (s N) E' (E $exp EL')\n\t       <- update-exp EL N E' EL'.\n\n%{|hidden=true}%\n\n\ntplist : type. \n\n$tp : tp -> tplist -> tplist. %infix right 5 $tp. \nnil-tp : tplist. \n\n\nproj-tp : tplist -> nat -> tp -> type. \n%mode proj-tp +TL +N -T. \nproj-tp-z : proj-tp (T $tp TL) z T. \nproj-tp-s : proj-tp (T $tp TL) (s N) T’ \n\t     <- proj-tp TL N T’. \n\n\nappend-tp : tplist -> tp -> tplist -> nat -> type. \n%mode append-tp +TL +T -TL’ -N. \nappend-tp-z : append-tp nil-tp T (T $tp nil-tp) z. \nappend-tp-s : append-tp (T’ $tp TL) T (T’ $tp TL’) (s N) \n\t       <- append-tp TL T TL’ N.\n\n \nsubset-tp : tplist -> tplist -> type. \nsubset-tp-z : subset-tp nil-tp T. \nsubset-tp-s : subset-tp (T $tp TL) (T $tp TL’) \n\t       <- subset-tp TL TL’. \n\n\nupdate-tp : tplist -> nat -> tp -> tplist -> type.\n%mode update-tp +TL +N +T -TL'.\nupdate-tp-z : update-tp (T $tp TL) z T' (T' $tp TL).\nupdate-tp-s : update-tp (T $tp TL) (s N) T' (T $tp TL')\n\t       <- update-tp TL N T' TL'.\n\n\n%{ \nWe create abbreviations to indicate that we are using expression\nlists to represent stores and type lists to represent store typings.\n}%\n\n%abbrev store = explist. \n%abbrev storetp = tplist. \n\n%{\n=== Values and evaluation ===\n\nThe predicate <tt>isval</tt> \n}%\n\nisval : exp -> type. \n%mode isval +E. \nv-int : isval (n N). \nv-loc : isval (loc L). \n\nisval-list : explist -> type. \n%mode isval-list +E. \nvl-z : isval-list nil-exp. \nvl-s : isval-list (E $exp EL) \n\t<- isval E \n\t<- isval-list EL. \n\neval : store -> exp -> store -> exp -> type. \n%mode eval +S +E -S’ -E’. \n\ns1-add : eval S (E1 + E2) S’ (E1’ + E2) \n\t  <- eval S E1 S’ E1’. \ns2-add : eval S (E1 + E2) S’ (E1 + E2’) \n\t  <- isval E1 \n\t  <- eval S E2 S’ E2’. \ne-add : eval S (n N1 + n N2) S (n N3) \n\t <- sum N1 N2 N3. \ns-ref : eval S (ref E) S’ (ref E’) \n\t <- eval S E S’ E’. \ne-ref : eval S (ref E) S’ (loc L) \n\t <- isval E \n\t <- append-exp S E S’ L. \ns-bang : eval S (! E) S’ (! E’) \n\t  <- eval S E S’ E’. \ne-bang : eval S (! (loc L)) S E \n\t  <- proj-exp S L E. \ns1-gets : eval S (gets E1 E2) S' (gets E1' E2)\n\t   <- eval S E1 S' E1'.\ns2-gets : eval S (gets E1 E2) S' (gets E1 E2')\n\t   <- isval E1\n\t   <- eval S E2 S' E2'.\ne-gets : eval S (gets (loc L1) E) S' E\n\t  <- isval E\n\t  <- update-exp S L1 E S'.\ns-let : eval S (let E EF) S’ (let E’ EF) \n\t <- eval S E S’ E’. \ne-let : eval S (let E EF) S (EF E) \n\t <- isval E. \n\n\n%{\n=== Typing judgment ===\n\nAs we do in the article on [[strengthening]], we need to define a separate \njudgment <tt>var-of</tt> that we will use to represent hypothetical typing\njudgments—the hypothetical judgment simply associates an expression with \na type, whereas the typing judgment <tt>of</tt> associates an expression with\na type in a specific store typing.\n}%\n\nvar-of : exp -> tp -> type. \n%mode var-of +E -T. \nof : storetp -> exp -> tp -> type. \n%mode of +ST +E -T. \nof-list : storetp -> explist -> tplist -> type. \n%mode of-list +ST +E -T. \n\n\ntl-z : of-list ST nil-exp nil-tp. \ntl-s : of-list ST (E $exp EL) (T $tp TL) \n\t<- of ST E T \n\t<- of-list ST EL TL. \n\n\nt-int : of ST (n N) int-tp. \nt-add : of ST (E1 + E2) int-tp \n\t <- of ST E1 int-tp \n\t <- of ST E2 int-tp. \nt-ref : of ST (ref E) (ref-tp T) \n\t <- of ST E T. \nt-bang : of ST (! E) T \n\t  <- of ST E (ref-tp T). \nt-gets : of ST (gets E1 E2) T\n\t  <- of ST E1 (ref-tp T)\n\t  <- of ST E2 T.\nt-loc : of ST (loc L) (ref-tp T) \n\t <- proj-tp ST L T. \nt-let : of ST (let E EF) T \n\t <- of ST E T’ \n\t <- ({x} var-of x T’ -> of ST (EF x) T). \nt-var : of ST E T \n\t <- var-of E T. \n\n\n%{ The typing judgment exists in an LF context where new expression\nvariables can be introduced if they are related with <tt>var-of</tt>\nto a well-formed type. This requirement is expressed by the [[block]] \n<tt>var-tp</tt>. }%\n\n%block var-tp : some {T:tp} block {x:exp}{v:var-of x T}.\n\n%{\nWe also define a judgment <tt>of-store</tt>, that expresses a store being\nwell-typed and containing only values.\n}%\n\nof-store : storetp -> store -> type. \n&of-store : of-store TL EL \n\t     <- isval-list EL \n\t     <- of-list TL EL TL. \n\n\n%{ === Multi-step evaluation === }%\n\nrun : store -> exp \n\t    -> store -> exp -> type. \n%mode run +S +E -S’ -E’. \nrun-step : run S E S’’ E’’ \n\t    <- eval S E S’ E’ \n\t    <- run S’ E’ S’’ E’’. \nrun-end : run S E S E.\n\n\n\n%{ == Language theory == }%\n\n%{\n=== Effectiveness lemmas ===\n\nWe need a few [[effectiveness lemmas]] that show that the <tt>sum</tt> and <tt>append</tt> judgments are always derivable. \n\nThe <tt>can-update</tt> theorem is slightly different, establishing that if a particular store has a particular type, then any index that has a corresponding type can be updated.\n}%\n\ncan-sum : {A: nat}{B: nat} sum A B C -> type. \n%mode can-sum +A +B -SUM. \n& : can-sum z N sum-z. \n& : can-sum (s N1) N2 (sum-s SUM) \n<- can-sum N1 N2 SUM. \n%worlds () (can-sum _ _ _). \n%total T (can-sum T _ _). \n\n\ncan-append-exp : {EL:explist}{E:exp} append-exp EL E EL' N -> type.\n%mode can-append-exp +EL +E -APPEND.\n& : can-append-exp nil-exp E append-exp-z.\n& : can-append-exp (E $exp EL) E' (append-exp-s APPEND)\n     <- can-append-exp EL E' APPEND.\n%worlds () (can-append-exp _ _ _).\n%total T (can-append-exp T _ _).\n\n\n%{ === Other auxillary lemmas === }%\n\nof-projection : of-list ST EL TL \n\t\t -> proj-tp TL N T \n\t\t %% implies\n\t\t -> proj-exp EL N E \n\t\t -> of ST E T -> type. \n%mode of-projection +TL +PT -PE -T. \n& : of-projection (tl-s TL T) proj-tp-z proj-exp-z T. \n& : of-projection (tl-s TL T’) (proj-tp-s PT) (proj-exp-s PE) T \n<- of-projection TL PT PE T. \n%worlds () (of-projection _ _ _ _). \n%total PT (of-projection _ PT _ _). \n\nof-projection' : of-list ST EL TL \n\t\t -> proj-tp TL N T \n\t\t %% implies\n\t\t -> proj-exp EL N E \n\t\t -> of ST E T -> type. \n%mode of-projection' +TL +PT +PE -T. \n& : of-projection' (tl-s TL T) proj-tp-z proj-exp-z T. \n& : of-projection' (tl-s TL T’) (proj-tp-s PT) (proj-exp-s PE) T \n<- of-projection' TL PT PE T. \n%worlds () (of-projection' _ _ _ _). \n%total PT (of-projection' _ PT _ _). \n\nsubset-projectable : proj-tp ST N T \n\t\t      -> subset-tp ST ST’ \n\t\t      -> proj-tp ST’ N T -> type. \n%mode subset-projectable +P +S -P’. \n& : subset-projectable proj-tp-z (subset-tp-s SUB) proj-tp-z. \n& : subset-projectable (proj-tp-s P) (subset-tp-s SUB) (proj-tp-s P’) \n     <- subset-projectable P SUB P’. \n%worlds () (subset-projectable _ _ _). \n%total P (subset-projectable P S P’). \n\n\nsubset-refl : {ST} subset-tp ST ST -> type. \n%mode subset-refl +ST -S. \n& : subset-refl nil-tp subset-tp-z.\n& : subset-refl (T $tp ST) (subset-tp-s SUB)\n     <- subset-refl ST SUB.\n%worlds () (subset-refl _ _).\n%total T (subset-refl T _).\n\nof-update : of-list ST EL TL \n\t     -> proj-tp TL L T\n\t     %% implies\n\t     -> {E} update-exp EL L E EL' \n\t     -> type.\n%mode of-update +T +PT +E -PE.\n& : of-update (tl-s _ _) proj-tp-z _ update-exp-z.\n& : of-update (tl-s T _) (proj-tp-s PT) E (update-exp-s PE)\n     <- of-update T PT E PE.\n%worlds () (of-update _ _ _ _).\n%total T (of-update T _ _ _).\n\n\n\nappend-lemma : isval E \n\t\t-> of ST E T \n\t\t-> isval-list EL \n\t\t-> of-list ST EL TL \n\t\t-> append-exp EL E EL’ N \n\t\t%% implies\n\t\t-> subset-tp TL TL’ \n\t\t-> isval-list EL’ \n\t\t-> of-list ST EL’ TL’ \n\t\t-> proj-tp TL’ N T -> type. \n%mode append-lemma +V +T +VL +TL +AE -S -VL’ -TL’ -P. \n& : append-lemma V T vl-z tl-z append-exp-z subset-tp-z (vl-s vl-z V) (tl-s tl-z T) proj-tp-z. \n& : append-lemma V T (vl-s VL V*) (tl-s TL T*) (append-exp-s AE) (subset-tp-s S) (vl-s VL’ V*) (tl-s TL’ T*) (proj-tp-s P) \n     <- append-lemma V T VL TL AE S VL’ TL’ P. \n%worlds () (append-lemma _ _ _ _ _ _ _ _ _). \n%total [VL TL AE] (append-lemma V T VL TL AE AT VL’ TL’ P). \n\n\n\nupdate-lemma : isval E\n\t\t-> of ST E T\n\t\t-> isval-list EL\n\t\t-> of-list ST EL TL \n\t\t-> proj-tp TL N T\n\t\t-> update-exp EL N E EL'\n\t\t%% implies\n\t\t-> isval-list EL'\n\t\t-> of-list ST EL' TL -> type.\n%mode update-lemma +V +T +VL +TL +P +UE -TL' -VL'.\n& : update-lemma V T (vl-s VL V*) (tl-s TL T*) proj-tp-z  update-exp-z (vl-s VL V) (tl-s TL T).\n& : update-lemma V T (vl-s VL V*) (tl-s TL T*) (proj-tp-s P) (update-exp-s UE) (vl-s VL' V*) (tl-s TL' T*)\n     <- update-lemma V T VL TL P UE VL' TL'.\n%worlds () (update-lemma _ _ _ _ _ _ _ _).\n%total T (update-lemma _ _ T _ _ _ _ _).\n\n\n\n%{\n=== Progress ===\n\nProgress, as usual, relies on an auxillary notion of what it means for an\nexpression to not be stuck that is captured by the judgement <tt>notstuck</tt>,\nwhich states that in a certain store <tt>S</tt> an expression <tt>E</tt> is \neither a value or can take a step.\n}%\n\nnotstuck : store -> exp -> type. \nns-steps : notstuck S E \n\t    <- eval S E S’ E’. \nns-isval : notstuck S E \n\t    <- isval E. \n\n%{ The statement of the progress theorem then utilizes the progress\ntheorem in a straightforward manner. }%\n\nprogress : of ST E T \n\t    -> of-store ST S \n\t    %% implies\n\t    -> notstuck S E -> type. \n%mode progress +T +TS -NS. \n\n%{ A natural number is already a value }%\n\nprog-int : progress t-int _ (ns-isval v-int). \n\n%{ To show progress for references, we show that a new reference cell can \nalways be created on the end of the list we use to represent the heap. }%\n\nlemma : notstuck S E -> notstuck S (ref E) -> type. \n%mode lemma +NS1 -NS. \n& : lemma (ns-steps E) (ns-steps (s-ref E)). \n& : lemma (ns-isval V) (ns-steps (e-ref APPEND V)) \n     <- can-append-exp EL E APPEND. \n%worlds () (lemma _ _). %total NS (lemma NS _). \nprog-ref : progress (t-ref T) TS NS \n\t    <- progress T TS NS1 \n\t    <- lemma NS1 NS. \n\n\n%{ To prove progress for addition, we will need to use the fact that the subexpressions both have type <tt>int-tp</tt>—that way, once they are reduced to values, they must be numbers, not locations. }%\n\nlemma : of ST E1 int-tp\n\t -> notstuck S E1 \n\t -> of ST E2 int-tp\n\t -> notstuck S E2 \n\t %% implies\n\t -> notstuck S (E1 + E2) -> type. \n%mode lemma +T1 +NS1 +T2 +NS2 -NS. \n& : lemma _ (ns-steps E) _ _ (ns-steps (s1-add E)). \n& : lemma _ (ns-isval V) _ (ns-steps E) (ns-steps (s2-add E V)). \n& : lemma t-int (ns-isval v-int) t-int (ns-isval v-int) (ns-steps (e-add SUM)) \n     <- can-sum N1 N2 SUM. \n%worlds () (lemma _ _ _ _ _). %total [NS1 NS2] (lemma T1 NS1 T2 NS2 NS). \nprog-add : progress (t-add T2 T1) TS NS\n\t    <- progress T1 TS NS1\n\t    <- progress T2 TS NS2\n\t    <- lemma T1 NS1 T2 NS2 NS.\n\n%{ We use both the notstuckness of the subexpressions and the ability to always project from a well-typed store (<tt>of-projection</tt>) to prove the <tt>gets</tt> case. }%\n\nlemma : of-store ST S \n\t -> of ST E (ref-tp T) \n\t -> notstuck S E \n\t %% implies\n\t -> notstuck S (! E) -> type. \n%mode lemma +ST +T +NS1 -NS. \n& : lemma _ _ (ns-steps E) (ns-steps (s-bang E)). \n& : lemma (&of-store TL VL) (t-loc PROJ-T) (ns-isval v-loc) (ns-steps (e-bang PROJ-E)) \n     <- of-projection TL PROJ-T PROJ-E _. \n%worlds () (lemma _ _ _ _). %total NS1 (lemma ST T NS1 NS). \nprog-bang : progress (t-bang T) TS NS \n\t     <- progress T TS NS1 \n\t     <- lemma TS T NS1 NS. \n\n%{ A location is already a value. }%\n\nprog-loc : progress (t-loc PROJ-T) TS (ns-isval v-loc). \n\n%{ We use both the notstuckness of the subexpressions and the ability to always update from a well-typed store (<tt>of-update</tt>) to prove the <tt>gets</tt> case. }%\n\nlemma : of-store ST S \n\t -> of ST E1 (ref-tp T) \n\t -> notstuck S E1\n\t -> notstuck S E2\n\t %% implies\n\t -> notstuck S (gets E1 E2) -> type.\n%mode lemma +TL +T +NS1 +NS2 -NS.\n& : lemma _ _ (ns-steps E) _ (ns-steps (s1-gets E)).\n& : lemma _ _ (ns-isval V) (ns-steps E) (ns-steps (s2-gets E V)).\n& : lemma (&of-store TL _) (t-loc PROJ) (ns-isval v-loc) \n     (ns-isval (V:isval E)) (ns-steps (e-gets UPD V))\n     <- of-update TL PROJ E UPD.\n%worlds () (lemma _ _ _ _ _).\n%total {} (lemma _ _ _ _ _).\nproj-gets : progress (t-gets T2 T1) TS NS\n\t     <- progress T1 TS NS1\n\t     <- progress T2 TS NS2\n\t     <- lemma TS T1 NS1 NS2 NS.\n\n%{ We use a lemma about the nonstuckness of the subexpression to prove the <tt>let</tt> case. }%\n\nlemma : {EF: exp -> exp} notstuck S E -> notstuck S (let E EF) -> type. \n%mode lemma +EF +NS1 -NS. \n& : lemma _ (ns-steps E) (ns-steps (s-let E)). \n& : lemma _ (ns-isval V) (ns-steps (e-let V)). \n%worlds () (lemma _ _ _). %total NS1 (lemma T NS1 NS). \nprog-let : progress (t-let _ T) TS NS \n\t    <- progress T TS NS1 \n\t    <- lemma EF NS1 NS. \n\n\n\n%worlds () (progress _ _ _). \n%total T (progress T TS NS). \n\n%{ \n=== Substitution ===\n\nAs in the article on [[strengthening]], progress will need to appeal to a simple substitution lemma.\n}%\n\nsubstitute : ({x} var-of x Tp -> of ST (EF x) T) \n\t      -> of ST E Tp \n\t      %% implies\n\t      -> of ST (EF E) T -> type. \n%mode substitute +F +T -T’. \n\nsub-refl : substitute ([x][v: var-of x Tp] T) T* T. \nsub-sum : substitute ([x][v: var-of x Tp] t-add (T2 x v) (T1 x v)) T* (t-add T2’ T1’) \n\t   <- substitute ([x][v: var-of x Tp] T2 x v) T* T2’ \n\t   <- substitute ([x][v: var-of x Tp] T1 x v) T* T1’. \nsub-ref : substitute ([x][v: var-of x Tp] t-ref (T x v)) T* (t-ref T’) \n\t   <- substitute ([x][v: var-of x Tp] T x v) T* T’. \nsub-bang : substitute ([x][v: var-of x Tp] t-bang (T x v)) T* (t-bang T’) \n\t    <- substitute ([x][v: var-of x Tp] T x v) T* T’. \nsub-gets : substitute ([x][v: var-of x Tp] t-gets (T2 x v) (T1 x v)) T* (t-gets T2' T1')\n\t    <- substitute ([x][v: var-of x Tp] T2 x v) T* T2'\n\t    <- substitute ([x][v: var-of x Tp] T1 x v) T* T1'. \nsub-let : substitute ([x][v: var-of x Tp] t-let (F x v) (T x v)) T* (t-let F’ T’) \n\t   <- substitute ([x][v: var-of x Tp] T x v) T* T’ \n\t   <- {x’}{v’: var-of x’ Tp2} \n\t      substitute ([x][v: var-of x Tp] F x v x’ v’) T* (F’ x’ v’). \nsub-var : substitute ([x][v: var-of x Tp] t-var v) T* T*. \n%worlds (var-tp) (substitute _ _ _). \n%total F (substitute F T T’). \n\n\n%{ \n=== Weakening === \n\nIn order to be able to evaluate reference cells, we need to be able to show \nthat adding new things to the store typing will leave all current programs \nwell-typed. The only interesting case is <tt>weak-loc</tt>.\n}%\n\nweakening : of ST E T -> subset-tp ST ST’ -> of ST’ E T -> type. \n%mode weakening +T +SUB -T’. \n\nweak-var : weakening (t-var V) _ (t-var V).\nweak-int : weakening (t-int) _ (t-int).\nweak-ref : weakening (t-ref T) S (t-ref T')\n\t    <- weakening T S T'.\nweak-sum : weakening (t-add T2 T1) S (t-add T2’ T1’) \n\t    <- weakening T1 S T1’ \n\t    <- weakening T2 S T2’. \nweak-bang : weakening (t-bang T) S (t-bang T')\n\t     <- weakening T S T'.\nweak-loc : weakening (t-loc PROJ) S (t-loc PROJ’) \n\t    <- subset-projectable PROJ S PROJ’. \nweak-gets : weakening (t-gets T2 T1) S (t-gets T2' T1')\n\t     <- weakening T2 S T2'\n\t     <- weakening T1 S T1'.\nweak-let : weakening (t-let F T) S (t-let F’ T’) \n\t    <- weakening T S T’ \n\t    <- {x}{v: var-of x Tp} weakening (F x v) S (F’ x v). \n%worlds (var-tp) (weakening _ _ _). \n%total T (weakening T S T’). \n\n%{ A comparable notion of weakening must be defined for lists: }%\n\nweakening-list : of-list ST EL TL \n\t\t  -> subset-tp ST ST’ \n\t\t  -> of-list ST’ EL TL -> type. \n%mode weakening-list +T +SUB -T’. \nweak-z : weakening-list tl-z S tl-z. \nweak-s : weakening-list (tl-s TL T) S (tl-s TL’ T’) \n\t  <- weakening T S T’ \n\t  <- weakening-list TL S TL’. \n%worlds () (weakening-list _ _ _). \n%total T (weakening-list T S T’). \n\n%{ \n=== Preservation ===\n\n}%\n\npreservation : of ST E T \n\t\t-> of-store ST S \n\t\t-> eval S E S’ E’ \n\t\t%% implies\n\t\t-> subset-tp ST ST’ \n\t\t-> of ST’ E’ T \n\t\t-> of-store ST’ S’ -> type. \n%mode preservation +T +TS +E -S -T’ -TS’. \n\n%{ In the cases where evaluation is passed on to a later step, the cases are mostly a straightforward call to the induction hypothesis and the weakening lemma. }%\n\npres-s1-add : preservation (t-add T2 T1) ST (s1-add E) S (t-add T2’ T1’) ST’ \n\t       <- preservation T1 ST E S T1’ ST’ \n\t       <- weakening T2 S T2’. \npres-s2-add : preservation (t-add T2 T1) ST (s2-add E V) S (t-add T2’ T1’) ST’ \n\t       <- preservation T2 ST E S T2’ ST’ \n\t       <- weakening T1 S T1’. \npres-s-ref : preservation (t-ref T) ST (s-ref E) S (t-ref T’) ST’ \n\t      <- preservation T ST E S T’ ST’. \npres-s-bang : preservation (t-bang T) ST (s-bang E) S (t-bang T’) ST’ \n\t       <- preservation T ST E S T’ ST’. \npres-s1-gets : preservation (t-gets T2 T1) ST (s1-gets E) S (t-gets T2' T1') ST'\n\t\t<- preservation T1 ST E S T1' ST'\n\t\t<- weakening T2 S T2'.\npres-s2-gets : preservation (t-gets T2 T1) ST (s2-gets E V) S (t-gets T2' T1') ST'\n\t\t<- preservation T2 ST E S T2' ST'\n\t\t<- weakening T1 S T1'.\npres-s-let : preservation (t-let F T) ST (s-let E) S (t-let F’ T’) ST’ \n\t      <- preservation T ST E S T’ ST’ \n\t      <- {x}{v} weakening (F x v) S (F’ x v). \n\n%{ The cases where evaluation happens are more involved—for instance, the <tt>ref</tt> case relies on the very involved <tt>append-lemma</tt> from the auxillary lemmas. }%\n\n\n\npres-e-add : preservation (t-add t-int t-int) ST (e-add SUM) S t-int ST \n\t      <- subset-refl _ S. \npres-e-ref : preservation (t-ref T) \n\t      (&of-store TL VL) \n\t      (e-ref AE V) S (t-loc P) \n\t      (&of-store TL’ VL’) \n\t      <- append-lemma V T VL TL AE S VL’ TL’’ P \n\t      <- weakening-list TL’’ S TL’. \npres-e-bang : preservation (t-bang (t-loc PROJ-T)) \n\t       (&of-store TL VL) (e-bang PROJ-E) \n\t       S T (&of-store TL VL) \n\t       <- subset-refl _ S\n\t       <- of-projection' TL PROJ-T PROJ-E T.\npres-e-gets : preservation (t-gets T (t-loc PROJ-T))\n\t       (&of-store TL VL)\n\t       (e-gets UL V) S T \n\t       (&of-store TL' VL')\n\t       <- subset-refl _ S\n\t       <- update-lemma V T VL TL PROJ-T UL VL' TL'.\npres-e-let : preservation (t-let F T’) ST (e-let V) S T ST \n\t      <- substitute F T’ T \n\t      <- subset-refl _ S. \n%worlds () (preservation _ _ _ _ _ _). \n%total T (preservation T ST E S T’ ST’). \n\n\n\n%{ === Safety === }%\n\nsafety : of ST E T \n\t  -> of-store ST S \n\t  -> run S E S’ E’ \n\t  -> notstuck S’ E’ -> type. \n%mode safety +T +TS +R -NS. \nsafe-end : safety T ST run-end NS \n\t    <- progress T ST NS. \nsafe-step : safety T ST (run-step R E) NS \n\t     <- preservation T ST E S T’ ST’ \n\t     <- safety T’ ST’ R NS. \n%worlds () (safety _ _ _ _). \n%total R (safety T TS R NS). \n\n\n\n%{\n== Example ==\n\nWe will define the following simple program as <tt>prog1</tt>, and use Twelf's [[logic programming]] abilities to actually run the typechecker <tt>of E T</tt> and multi-step evaluation <tt>run S E S' E'</tt>. Because <tt>gets</tt> returns the result of the assignment in the same way C does, <math>\\texttt{}y</math> should have the same value as <math>\\texttt{}!x</math> at the end of the program, namely 4.\n\n<math>\\begin{array}{l}\\mathsf{let~}x = \\mathsf{ref}(2 + 1) \\mathsf{~in}\\\\\n\\mathsf{let~}y = x := !x + 1\\mathsf{~in~}\\\\\n!x + 1\\end{array}</math>\n}%\n\nprog1 = \nlet (ref (n (s (s z)) + n (s z))) \n   [x] \nlet (gets x (! x + n (s z)))\n   [y]\n! x + n (s z).\n\n\n%{ We can typecheck the program (in the empty store typing <tt>nil-tp</tt>). The syntax we use for <tt>[[%query]]</tt> indicates that we only expect there to be one solution (because type checking should be syntax directed): |check=decl}%\n\n%query 1 * (of nil-tp prog1 T).\n\n%{ We can then run the program to completion (starting in the empty store <tt>nil-exp</tt>). We expect the final state <tt>S</tt> to include the number 4, and we expect the program to evaluate to value <tt>V</tt> 5. The multi-step evaluation judgment <tt>run</tt> is defined to run arbitrarily until stopping, so we only want the first solution—it will be the solution resulting in running <tt>run-step</tt> as many times as possible: |check=decl}%\n\n%query 1 1 (run nil-exp prog1 S V).\n\n%.\n\n== References ==\n\n<references />\n\n{{case study}}"
          },
          "sha1": "qp72xo27w6hiypfynaq6mnamz262oqt"
        }
      },
      {
        "title": "Mutual induction",
        "ns": 0,
        "id": 1912,
        "revision": {
          "id": 7951,
          "parentid": 4970,
          "timestamp": "2013-08-09T14:06:29Z",
          "contributor": {
            "username": "Namin",
            "id": 10184
          },
          "comment": "/* Motivating example */ remove name option",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 4323,
            "#text": "It is common to write two or more mutually recursive type families.  For example, an object language may have mutually recursive judgements, or a proof may require mutually recursive theorems.  To check the totality of mutually recursive type families, you need to usual a mutual termination metric. This tutorial presents an example of doing so.\n\n== Motivating example ==\n\nAs a motivating example, we define a simple subtyping relation on the types of a programming language.  The language includes integers, floating point numbers, and functions.  We consider <tt>int</tt> to be a subtype of <tt>float</tt>, and we give the usual contravariant rule for functions:\n\n<twelf>\ntp    : type.\nint   : tp.\nfloat : tp.\narrow : tp -> tp -> tp.\n\nsub       : tp -> tp -> type.\nsub-ii    : sub int int.\nsub-ff    : sub float float.\nsub-if    : sub int float.\nsub-arrow : sub (arrow T S) (arrow T' S')\n\t     <- sub T' T\n\t     <- sub S S'.\n</twelf>\n\nLet's prove that this subtyping relation is transitive.  Our first proof attempt goes as follows:\n\n<twelf>\nsub-trans : sub T1 T2 -> sub T2 T3 -> sub T1 T3 -> type.\n%mode sub-trans +X1 +X2 -X3.\n\n- : sub-trans (D : sub T T) (D' : sub T T) D.\n- : sub-trans sub-ii sub-if sub-if.\n- : sub-trans sub-if sub-ff sub-if.\n\n- : sub-trans \n     (sub-arrow \n\t(DS12 : sub S1 S2)\n\t(DT21 : sub T2 T1))\n     (sub-arrow \n\t(DS23 : sub S2 S3)\n\t(DT32 : sub T3 T2))\n     (sub-arrow DS13 DT31)\n     <- sub-trans DT32 DT21 DT31\n     <- sub-trans DS12 DS23 DS13.\n</twelf>\n\nThe base cases do the appropriate thing.  The case for <tt>sub-arrow</tt> against <tt>sub-arrow</tt> makes two inductive calls, corresponding to the two components of the arrow type.\n\nHowever, this proof is incorrect:\n<twelf check=\"decl\">\n%total D (sub-trans D _ _).\n</twelf>\n\nTo deal with the contravariance, we swapped the two argument derivations in the first inductive call of <tt>sub-arrow</tt>.  However, this means that we have not given a proof by induction on the derivation of <tt>sub T1 T2</tt>, since in this premise that derivation is not a subterm of the input.  This relation cannot be regarded as a proof by induction on the second derivation for the same reason.  \n\nOne solution would be to induct over the sum of the sizes of the two derivations, which certainly gets smaller in this case.\n\n== Mutual induction ==\n\nHowever, a simpler solution, which happens to work in this case, is to prove the transitivity theorem ''twice'', once by induction on the first input, and again by induction on the second input, in a mutually inductive loop.  These two proofs will call each other in the contravariant premise, so the induction will go through.  Here's what the revised proof looks like:\n\n<twelf check=\"true\">\nsub-trans : sub T1 T2 -> sub T2 T3 -> sub T1 T3 -> type.\n%mode sub-trans +X1 +X2 -X3.\n\nsub-trans' : sub T1 T2 -> sub T2 T3 -> sub T1 T3 -> type.\n%mode sub-trans' +X1 +X2 -X3.\n\n%% normal\n\n- : sub-trans (D : sub T T) (D' : sub T T) D.\n\n- : sub-trans sub-ii sub-if sub-if.\n\n- : sub-trans sub-if sub-ff sub-if.\n\n- : sub-trans \n     (sub-arrow \n\t(DS12 : sub S1 S2)\n\t(DT21 : sub T2 T1))\n     (sub-arrow \n\t(DS23 : sub S2 S3)\n\t(DT32 : sub T3 T2))\n     (sub-arrow DS13 DT31)\n     <- sub-trans' DT32 DT21 DT31\n     <- sub-trans DS12 DS23 DS13.\n\n%% prime\n\n- : sub-trans' D D D.\n\n- : sub-trans' sub-ii sub-if sub-if.\n\n- : sub-trans' sub-if sub-ff sub-if.\n\n- : sub-trans' \n     (sub-arrow \n\t(DS12 : sub S1 S2)\n\t(DT21 : sub T2 T1))\n     (sub-arrow \n\t(DS23 : sub S2 S3)\n\t(DT32 : sub T3 T2))\n     (sub-arrow DS13 DT31)\n     <- sub-trans DT32 DT21 DT31\n     <- sub-trans' DS12 DS23 DS13.\n          \n%worlds () (sub-trans _ _ _) (sub-trans' _ _ _).\n%total (D D') (sub-trans D _ _) (sub-trans' _ D' _).\n</twelf>\n\nBecause each relation refers to the other, we must use a mutual termination metric.  A mutual termination metric has the form <tt>(D1 D2 ... Dn)</tt>, where there must be as many variables in the termination metric as there are mutual relations.  Then, the remainder of the <tt>%total</tt> lists each mutual relation, and identifies which argument to each relation is considered to be the induction position.  In this case, we say that <tt>sum-trans</tt> is by induction on the first argument, whereas <tt>sum-trans'</tt> is by induction on the second (though the symmetric declaration would also work).\n\n{{tutorial}}"
          },
          "sha1": "mrcnqhmoatk9qye9m5iiln835qcua1b"
        }
      },
      {
        "title": "Naming conventions",
        "ns": 0,
        "id": 1519,
        "revision": {
          "id": 4803,
          "parentid": 4790,
          "timestamp": "2007-09-26T12:27:07Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 4739,
            "#text": "{{needswork|Incomplete commentary; furthermore, a consensus needs to exist around this document before we present it generally}}\n\nThese are '''naming conventions''' for Twelf code. This article should be considered an appendix to/chapter of the [[style guide]].\n\n== Syntax ==\n\n=== The uninhabited type ===\n\nDefining an uninhabited type is important for [[reasoning from false]] - however, the name of that type varies from user to user, with <tt>void</tt>, <tt>false</tt>, and <tt>absurd</tt> perhaps being the most common.\n\nStandard usage is to use <tt>void</tt>, and to freeze the type immediately after its introduction, like this:\n\n<twelf>void : type. %freeze void.</twelf>\n\n== Judgments ==\n\n=== Factored judgments ===\n\n[[Factoring]] is a technique used to reduce backtracking. If a rule does some computation, it might then sends the result to another rule that continues based on the output of its computation. The style introduced here works well with factoring - if you are creating \"helper judgment,\" just replace the forward slash in the primary [[judgment]] with a hyphen to come up with the name.\n\n<twelf>eval : state -> state -> type.\n\neval-branch-if-nil : list -> state -> state -> type.\n\n...\n\neval-branch-if-nil/nil : eval-branch-if-nil list/nil ...\neval-branch-if-nil/cons : eval-branch-if-nil (list/cons _ _) ...\n\neval/branch-if-nil : eval S1 S2\n                      <- do-some-computation-on-state S1 L\n                      <- eval-branch-if-nil L S1 S2.</twelf>\n\n=== Introduction rules ===\n\nIf a type family is inhabited by exactly one rule, it is recommended to use <tt>i</tt> (short for introduction) as the case name for the lone inference rule. For example, the [[identity]] (syntactic equality) [[relation]] for natural numbers would be defined in the following way.\n\n<twelf>seq-nat : nat -> nat -> type.\n\nseq-nat/i : seq-nat N N.</twelf>\n\nThis also applies to pieces of syntax in the [[object language]], but it appears less frequently there.\n\n=== A note on word order ===\n\nHere as in the previous section, there is a legitimate case for reversing the word order, calling a list of natural numbers <tt>nat-list</tt> instead of <tt>list-nat</tt> on the other, and for calling the three-place relation implementing addition of natural numbers <tt>nat-plus</tt> instead of <tt>plus-nat</tt>\n\nThe construction that is not used here looks more like declarations would look were a module system is in place (i.e. <tt>nat::list</tt>, but the first is more readable after combination - for instance <tt>list-list-nat</tt> can be read out loud as \"a list of lists of nats,\" whereas the equivalent formulation does not compose as well - <tt>nat-list-list</tt> can best be read as \"a natlist list.\"\n\nInternal consistancy is most important here, but the construction <tt><nowiki>(structure)-(object)</nowiki></tt> for syntax (i.e. <tt>list-nat</tt>) and <tt><nowiki>(adjective/verb/operation)-(object)</nowiki></tt> (i.e. <tt>wellformed-env</tt>, <tt>sort-list</tt>, or <tt>plus-nat</tt>) is preferred.\n\n=== Different types of equality ===\n\n\n== Metatheorems ==\n\n=== Metatheorem names ===\n\nOne way to think about a naming strategy for many metatheorems is that many simple theorems act like admissibility arguments for other rules. For instance, imagine an alternate form of <tt>plus-nat/z</tt> that has the zero in the ''second'' place instead of the first. It might be written like this if it were a real definition: \n<twelf>plus-nat/z-alt : plus N z N.</twelf> \nFollowing that logic, a lemma establishing the admissibility argument might be titled \n<twelf>plus-nat-z-alt : {N} plus-nat N z N -> type.</twelf>\n\nBeyond that suggestion, the properties that we wish to prove about our inference rules vary to the point where some measure of consistency is the only reasonable guideline.\n\n=== <tt>can-</tt> and <tt>-unique</tt> metatheorems ===\n\nA judgment behaves like a function (in the meta-logical sense) on particular \"input\" derivations if it satisfies two properties. The first is that given the \"input\" derivations, the judgment can be derived, i.e. an [[effectiveness lemma]]. The second is that given two derivations of the judgments with the same \"input\" derivations, the results are actually the same, i.e. a [[uniqueness lemma]]. It is common practice to name the metatheorems proving the first property <tt>can-judgmentname</tt> and the second property <tt>judgmentname-unique</tt>.\n\n<twelf>\ncan-plus-nat : {N1:nat} {N2:nat} \n                 plus-nat N1 N2 N3 \n                -> type.\n%mode can-plus-nat +D1 +D2 -D3.\n\n...\n\nplus-nat-unique : plus-nat N1 N2 N3\n                   -> plus-nat N1 N2 N3'\n                   -> seq-nat N3 N3\n                   -> type.\n%mode plus-nat-unique +D1 +D2 -D3.\n\n...</twelf>"
          },
          "sha1": "bjlpahz0jvxncvnjh6aicv4sukqp7c4"
        }
      },
      {
        "title": "Natural number",
        "ns": 0,
        "id": 1850,
        "redirect": {
          "@title": "Natural numbers",
          "#text": null
        },
        "revision": {
          "id": 3657,
          "timestamp": "2007-02-21T14:27:35Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "comment": "s->p",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 29,
            "#text": "#REDIRECT [[natural numbers]]"
          },
          "sha1": "rc753ip5egku32ym3u8hp0fpyftr6e2"
        }
      },
      {
        "title": "Natural numbers",
        "ns": 0,
        "id": 1492,
        "revision": {
          "id": 6449,
          "parentid": 6179,
          "timestamp": "2011-10-17T21:12:54Z",
          "contributor": {
            "username": "Sully",
            "id": 87
          },
          "comment": "rv vandalism?",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 3755,
            "#text": "The '''natural numbers''' are the numbers 0, 1, 2, etc. The term is generally used to indicate a specific technique of representing natural numbers as either zero or the successor of some other natural number - 0, s(0), s(s(0)), etc - as in [[w:Peano arithmetic|Peano arithmetic]], a technique also sometimes referred to as '''unary numbers.'''\n\n== Natural numbers in Twelf ==\n\nNatural numbers in Twelf are usually defined in a similar way. Mathematically, natural numbers can be defined as zero or the successor of some other natural number:\n\n<math>\\texttt{}n ::= 0 \\,|\\, \\texttt{s}(n)</math>\n\nThis representation translates easily into Twelf:\n\n<twelf>\nnat: type.\nz: nat.\ns: nat -> nat.\n</twelf>\n\nThe first line declares that <tt>nat</tt> is a type. The second line declares <tt>z</tt> (zero) to be an object of type <tt>nat</tt>, and the third line declars <tt>s</tt> (successor) to be a type constructor that takes an object <tt>N</tt> of type <tt>nat</tt> and produces another object <tt>(s N)</tt> of type <tt>nat</tt>.\n\n== Addition of natural numbers in Twelf ==\n\nThe addition of these natural numbers is defined by the judgment <math>\\texttt{plus}(N_1,N_2,N_3)</math>, where <math>N_1</math>, <math>N_2</math>, and <math>N_3</math> are natural numbers. In the definition below, capital letters stand for metavariables that can range over all natural numbers. \n\n<math>{\\qquad \\over \\texttt{plus}(0,N,N)}{\\mbox{p-z}}</math> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <math>{\\texttt{plus}(N_1,N_2,N_3) \\over \\texttt{plus}(\\texttt{s}(N_1),N_2,\\texttt{s}(N_3))}{\\mbox{p-s}}</math>\n\nThese judgments also translate cleanly into Twelf:\n\n<twelf>\nplus: nat -> nat -> nat -> type.\np-z: plus z N N.\np-s: plus (s N1) N2 (s N3)\n      <- plus N1 N2 N3.\n</twelf>\n\nThe first line defines the judgment, declaring <tt>plus</tt> to be a type family indexed by three terms of type <tt>nat</tt>. \n\nThe second line declares that for any natural number <tt>N</tt>, <tt>p-z</tt> is an object of type <tt>plus z N N</tt>, which corresponds to the axiom p-z above. The <tt>N</tt> is an [[implicit parameter]] - it is treated as a bound variable by Twelf, which you can see by <twelflink check=\"true\">looking at Twelf's output</twelflink> after checking the above code. \n\nThe third line says that <tt>p-s</tt> is a type constructor that, given an object <tt>D</tt> of type <tt>plus N1 N2 N3</tt> (where <tt>N1</tt>, <tt>N2</tt>, and <tt>N3</tt> are all implicit parameters that can\nbe treated as metavariables), produces an object, <tt>p-s D</tt>, with type <tt>plus (s N1) N2 (s N3)</tt>. This corresponds to the rule p-s, which given a derivation of <math>\\texttt{plus}(N_1,N_2,N_3)</math> allows us to conclude <math>\\texttt{plus}(\\texttt{s}(N_1),N_2,\\texttt{s}(N_3))</math>.\n\nConsider this derivation which encodes the fact that <math>2 + 1 = 3</math>:\n\n<math> {{{\\;} \\over {\n\\texttt{plus}(0,\\;\\;\\texttt{s}(0),\\;\\;\\texttt{s}(0))}}{\\mbox{p-z}} \\over {{\n\\texttt{plus}(\\texttt{s}(0),\\;\\;\\texttt{s}(0),\\;\\;\\texttt{s}(\\texttt{s}(0)))} \\over {\n\\texttt{plus}(\\texttt{s}(\\texttt{s}(0)),\\;\\;\\texttt{s}(0),\\;\\;\\texttt{s}(\\texttt{s}(\\texttt{s}(0))))}}{\\mbox{p-s}}}{\\mbox{p-s}} </math>\n\nThis can be represented in Twelf by applying the type constructor <tt>p-s</tt> to the object <tt>p-z</tt> twice:\n\n<twelf check=decl>\n2+1=3 : plus (s (s z)) (s z) (s (s (s z))) = p-s (p-s p-z).\n</twelf>\n\n== See also ==\n\n* [[Natural numbers with inequality]]\n* [[Division over the natural numbers]]\n* [[Proving metatheorems with Twelf]], which uses natural numbers as an example, and also discusses the [[adequacy]] of the encoding.\n\n== External link ==\n\n* [http://en.wikipedia.org/wiki/Natural_numbers Natural numbers at Wikipedia]"
          },
          "sha1": "0e5kgmm60v363wt50acdxu6wvqdpomr"
        }
      },
      {
        "title": "Natural numbers with inequality",
        "ns": 0,
        "id": 1400,
        "revision": {
          "id": 4823,
          "parentid": 4819,
          "timestamp": "2007-09-26T17:24:21Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "rv vandal",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 7523,
            "#text": "%{ \nA signature for natural numbers, adapted from a number of sources,\nin particular the TALT project.\nThere is no arithmetic, just the theory of inequality.\nThis code uses an uninhabited type, \"void\", in order to express\n[[proofs by reductio ad absurdum]].\n}%\n\n%{ == Syntax == }%\n\n%{ === Natural numbers === }%\n\nnat: type.\nz: nat.\ns: nat -> nat.\n\n%{ === The uninhabited type === }%\n\nvoid: type. %freeze void.\n\n%{ === Constants === }%\n\n0 = z.\n1 = s 0.\n%{... and continuing on to 25 |hidden = true}%\n2 = s 1.\n3 = s 2.\n4 = s 3.\n5 = s 4.\n6 = s 5.\n7 = s 6.\n8 = s 7.\n9 = s 8.\n10 = s 9.\n11 = s 10.\n12 = s 11.\n13 = s 12.\n14 = s 13.\n15 = s 14.\n16 = s 15.\n17 = s 16.\n18 = s 17.\n19 = s 18.\n20 = s 19.\n21 = s 20.\n22 = s 21.\n23 = s 22.\n24 = s 23.\n25 = s 24.\n\n\n%{ == Equality and inequality == }%\n\n%{ === Definitions === }%\n\n%% equality\nid-nat\t    : nat -> nat -> type.\nid-nat/refl : id-nat N N.\n\n%% less than\nlt-nat   : nat -> nat -> type.\nlt-nat/z : lt-nat z (s N).\nlt-nat/s : lt-nat (s N1) (s N2)\n\t    <- lt-nat N1 N2.\n\n%% less than or equal to\nleq-nat    : nat -> nat -> type.\nleq-nat/eq : leq-nat N1 N2\n\t      <- id-nat N1 N2.\nleq-nat/lt : leq-nat N1 N2\n\t      <- lt-nat N1 N2.\n\n%% not equal\nneq-nat : nat -> nat -> type.\nneq-nat/gt : neq-nat N1 N2\n\t      <- lt-nat N2 N1.\nneq-nat/lt : neq-nat N1 N2\n\t      <- lt-nat N1 N2.\n\n\n\n\n%{ === Theorems === }%\n\n%{ ====False implies anything==== }%\n\nfalse-imp-id-nat : void -> {N1}{N2} id-nat N1 N2 -> type.\n%mode false-imp-id-nat +X +N1 +N2 -D. \n%worlds () (false-imp-id-nat _ _ _ _).\n%total {} (false-imp-id-nat _ _ _ _).\n\n\n\nfalse-imp-neq-nat : void -> {N1}{N2} neq-nat N1 N2 -> type.\n%mode false-imp-neq-nat +X +N1 +N2 -D. \n%worlds () (false-imp-neq-nat _ _ _ _).\n%total {} (false-imp-neq-nat _ _ _ _).\n\n\n\nfalse-imp-lt-nat : void -> {N1}{N2} lt-nat N1 N2 -> type.\n%mode false-imp-lt-nat +X +N1 +N2 -D. \n%worlds () (false-imp-lt-nat _ _ _ _).\n%total {} (false-imp-lt-nat _ _ _ _).\n\n\n\nfalse-imp-leq-nat : void -> {N1}{N2} leq-nat N1 N2 -> type.\n%mode false-imp-leq-nat +X +N1 +N2 -D. \n%worlds () (false-imp-leq-nat _ _ _ _).\n%total {} (false-imp-leq-nat _ _ _ _).\n\n\n\n%{ ====Basic properties==== }%\n\nlt-nat-succ : {N} lt-nat N (s N) -> type.\n%mode lt-nat-succ +N -D.\n\n- : lt-nat-succ z lt-nat/z.\n- : lt-nat-succ (s N) (lt-nat/s D)\n     <- lt-nat-succ N D.\n\n%worlds () (lt-nat-succ _ _).\n%total T (lt-nat-succ T _).\n\n%{ ====Reflexivity and symmetry==== }%\n\nid-nat/symm : id-nat N1 N2 -> id-nat N2 N1 -> type.\n%mode id-nat/symm +D1 -D2.\n\n- : id-nat/symm id-nat/refl id-nat/refl.\n\n%worlds () (id-nat/symm _ _).\n%total {} (id-nat/symm _ _).\n\n\n\nid-nat/trans : id-nat N1 N2 -> id-nat N2 N3 -> id-nat N1 N3 -> type.\n%mode id-nat/trans +D1 +D2 -D3.\n\n- : id-nat/trans id-nat/refl id-nat/refl id-nat/refl.\n\n%worlds () (id-nat/trans _ _ _).\n%total {} (id-nat/trans _ _ _).\n\n\n\nneq-nat/symm : neq-nat N1 N2 -> neq-nat N2 N1 -> type.\n%mode neq-nat/symm +D1 -D2.\n\n- : neq-nat/symm (neq-nat/lt D) (neq-nat/gt D).\n- : neq-nat/symm (neq-nat/gt D) (neq-nat/lt D).\n\n%worlds () (neq-nat/symm _ _).\n%total {} (neq-nat/symm _ _).\n\n\n\nlt-nat/trans : lt-nat N1 N2 -> lt-nat N2 N3 -> lt-nat N1 N3 -> type.\n%mode lt-nat/trans +D1 +D2 -D3.\n\n- : lt-nat/trans lt-nat/z _ lt-nat/z.\n- : lt-nat/trans (lt-nat/s D1) (lt-nat/s D2) (lt-nat/s D3)\n     <- lt-nat/trans D1 D2 D3.\n\n%worlds () (lt-nat/trans _ _ _).\n%total T (lt-nat/trans T _ _).\n\n\n\nleq-nat/trans : leq-nat N1 N2 -> leq-nat N2 N3 -> leq-nat N1 N3 -> type.\n%mode leq-nat/trans +D1 +D2 -D3.\n\n- : leq-nat/trans (leq-nat/eq _) D D.\n- : leq-nat/trans D (leq-nat/eq _) D.\n- : leq-nat/trans (leq-nat/lt D1) (leq-nat/lt D2) (leq-nat/lt D3)\n     <- lt-nat/trans D1 D2 D3.\n\n%worlds () (leq-nat/trans _ _ _).\n%total {} (leq-nat/trans _ _ _).\n\n\n%{ ==== Respects lemmas==== }%\n\n%{ This is an instance of the generalization technique \ndescribed in the page on [[respects lemma]]s. }%\n\nid-nat/compat : {F: nat -> nat} id-nat N1 N2 -> id-nat (F N1) (F N2) -> type.\n%mode id-nat/compat +F +D1 -D2.\n\n- : id-nat/compat _ id-nat/refl id-nat/refl.\n\n%worlds () (id-nat/compat _ _ _).\n%total {} (id-nat/compat _ _ _).\n\n\n\n%abbrev\nid-nat/inc : id-nat N1 N2 -> id-nat (s N1) (s N2) -> type = id-nat/compat s.\n\n\n\nid-nat/dec : id-nat (s N1) (s N2) -> id-nat N1 N2 -> type.\n%mode id-nat/dec +D1 -D2.\n\n- : id-nat/dec id-nat/refl id-nat/refl.\n\n%worlds () (id-nat/dec _ _).\n%total {} (id-nat/dec _ _).\n\n\n\nleq-nat-resp : id-nat N1 N1' \n\t\t-> id-nat N2 N2' -> leq-nat N1 N2 -> leq-nat N1' N2' -> type.\n%mode leq-nat-resp +X1 +X2 +X3 -X4.\n\n- : leq-nat-resp id-nat/refl id-nat/refl D D.\n\n%worlds () (leq-nat-resp _ _ _ _).\n%total {} (leq-nat-resp _ _ _ _).\n\n\n\nlt-nat-resp : id-nat N1 N1' \n\t       -> id-nat N2 N2' -> lt-nat N1 N2 -> lt-nat N1' N2' -> type.\n%mode lt-nat-resp +D1 +D2 +D3 -D.\n\n- : lt-nat-resp id-nat/refl id-nat/refl D D.\n\n%worlds () (lt-nat-resp _ _ _ _).\n%total {} (lt-nat-resp _ _ _ _).\n\n\n\nneq-nat-resp : id-nat N1 N1' \n\t\t-> id-nat N2 N2' -> neq-nat N1 N2 -> neq-nat N1' N2' -> type.\n%mode neq-nat-resp +X1 +X2 +X3 -X4.\n\n- : neq-nat-resp id-nat/refl id-nat/refl D D.\n\n%worlds () (neq-nat-resp _ _ _ _).\n%total {} (neq-nat-resp _ _ _ _).\n\n%{ ==== Contradictions ==== }%\n\nlt-nat-contr : lt-nat N N -> void -> type.\n%mode lt-nat-contr +D -F.\n\n- : lt-nat-contr (lt-nat/s D) F\n     <- lt-nat-contr D F.\n\n%worlds () (lt-nat-contr _ _).\n%total T (lt-nat-contr T _).\n\n\n\nneq-nat-contr : neq-nat N N -> void -> type.\n%mode neq-nat-contr +D -F.\n\n- : neq-nat-contr (neq-nat/lt D) F\n     <- lt-nat-contr D F.\n- : neq-nat-contr (neq-nat/gt D) F\n     <- lt-nat-contr D F.\n\n%worlds () (neq-nat-contr _ _).\n%total T (neq-nat-contr T _).\n\n\n\nlt-gt-nat-contr : lt-nat N1 N2 -> lt-nat N2 N1 -> void -> type.\n%mode lt-gt-nat-contr +D1 +D2 -F.\n\n- : lt-gt-nat-contr (lt-nat/s D1) (lt-nat/s D2) F\n     <- lt-gt-nat-contr D1 D2 F.\n\n%worlds () (lt-gt-nat-contr _ _ _).\n%total T (lt-gt-nat-contr T _ _).\n\n\n\nlt-leq-nat-contr : lt-nat N1 N2 -> leq-nat N2 N1 -> void -> type.\n%mode lt-leq-nat-contr +D1 +D2 -F.\n\n- : lt-leq-nat-contr D1 (leq-nat/lt D2) F\n     <- lt-gt-nat-contr D1 D2 F.\n- : lt-leq-nat-contr D1 (leq-nat/eq D2) F\n     <- lt-nat-contr D1 F.\n\n%worlds () (lt-leq-nat-contr _ _ _).\n%total T (lt-leq-nat-contr T _ _).\n\n\n\n%{ ==== Dichotomy ==== }%\n\n%{ The property that any two numbers are comparable by lt, eq, or lt\nthe other way around. Because leq and neq are defined in terms of lt and eq,\nthis should allow relatively simple assessment of these cases as well. }%\n\ndichotomy-nat : nat -> nat -> type.\ndichotomy-nat/lt : lt-nat N1 N2 -> dichotomy-nat N1 N2.\ndichotomy-nat/gt : lt-nat N1 N2 -> dichotomy-nat N2 N1.\ndichotomy-nat/id : id-nat N1 N2 -> dichotomy-nat N1 N2.\n\ncan-dichotomy-nat/s : dichotomy-nat N1 N2 \n\t\t       -> dichotomy-nat (s N1) (s N2) -> type.\n%mode can-dichotomy-nat/s +D1 -D2.\n\n- : can-dichotomy-nat/s (dichotomy-nat/gt D) (dichotomy-nat/gt (lt-nat/s D)).\n- : can-dichotomy-nat/s (dichotomy-nat/lt D) (dichotomy-nat/lt (lt-nat/s D)).\n- : can-dichotomy-nat/s (dichotomy-nat/id D) (dichotomy-nat/id D')\n     <- id-nat/inc D D'.\n\n%worlds () (can-dichotomy-nat/s _ _).\n%total {} (can-dichotomy-nat/s _ _).\n\ncan-dichotomy-nat : {N1}{N2} dichotomy-nat N1 N2 -> type.\n%mode can-dichotomy-nat +N1 +N2 -D.\n\n- : can-dichotomy-nat z z     (dichotomy-nat/id id-nat/refl).\n- : can-dichotomy-nat (s _) z (dichotomy-nat/gt lt-nat/z).\n- : can-dichotomy-nat z (s _) (dichotomy-nat/lt lt-nat/z).\n- : can-dichotomy-nat (s N1) (s N2) D'\n     <- can-dichotomy-nat N1 N2 D\n     <- can-dichotomy-nat/s D D'.\n\n%worlds () (can-dichotomy-nat _ _ _).\n%total T (can-dichotomy-nat T _ _).\n\n%{ {{case study}} }%"
          },
          "sha1": "s6mw6utxc3847frh3pnfq9u86jh1o2x"
        }
      },
      {
        "title": "Negation as failure",
        "ns": 0,
        "id": 2003,
        "revision": {
          "id": 4869,
          "parentid": 4862,
          "timestamp": "2007-10-02T22:13:46Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "minor": null,
          "comment": "typos and style",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 3005,
            "#text": "%{\nNegation as failure. It is possible to do negation-as-failure using Twelf's [[logic programming]] engine, with the use of [[deterministic declaration|%deterministic]]. As an example, we will define logic programs to compute the less-than and greater-than-or-equal-to functions. The less-than function will be defined in a standard way. The greater-than-or-equal-to function will be defined using a negation-as-failure interpretation of the less-function.\n}%\n\n%{\n=== Definitions ===\n\nNatural numbers and booleans.\n}%\n\nnat\t: type. \n\nz\t: nat.\ns\t: nat -> nat.\n\n\n\nbool\t: type. \n\ntrue\t: bool. \nfalse\t: bool. \n\n\n\n%{\n<tt>less</tt> is defined inductively in the standard way.\n}%\n\nless\t: nat -> nat -> type. \n%mode less +D1 +D2. \n\nless/z\t: less z (s _).\nless/s\t: less (s N1) (s N2)\n\t   <- less N1 N2. \n\n\n%{\nWe will need a judgment that tests whether a boolean is <tt>false</tt> in order to use negation-as-failure.\n}%\n\n\nisfalse\t: bool -> type. \n%mode isfalse +D.\n\nisfalse/i\t: isfalse false. \n\n\n\n%{\n=== Coding negation-as-failure ===\n\nWe define a logic program that when given two numbers returns <tt>true</tt> if the first is less than the second, and <tt>false</tt> otherwise. We use <tt>%deterministic</tt> to make the logic programming engine commit to the first solution it finds. \n}%\n\nless-bool\t: nat -> nat -> bool -> type. \n%mode less-bool +D1 +D2 -D3. \n%deterministic less-bool. \n\n%{\nBecause the <tt>less-bool/true</tt> case is first, it will attempt to find a proof that the first number is less than the second. \n}%\nless-bool/true\t: less-bool N1 N2 true\n\t\t   <- less N1 N2. \n\n%{ \nBecause of the <tt>%deterministic</tt> declaration, when searching for a proof of <tt>less N1 N2 B</tt>, only executes when <tt>less-bool/true</tt> fails. However, because of pattern matching a search for a proof of <tt>less N1 N2 false</tt> always succeeds. \n}%\n\nless-bool/false\t: less-bool N1 N2 false. \n\n\n%{\nWe will now define <tt>gte</tt> using <tt>less-bool</tt>. It has only one rule, which makes a call to <tt>less-bool N1 N2 B</tt>. It is important to make sure that the result <tt>B</tt> is not directly identified as <tt>false</tt> so that it executes <tt>less-bool</tt> in the appropriate order. We use the call to <tt>isfalse B</tt> to verify that the output really is <tt>false</tt>.\n}%\n\ngte\t: nat -> nat -> type. \n%mode gte +D1 +D2. \n\ngte/i\t: gte N1 N2\n\t   <- less-bool N1 N2 B\n \t   <- isfalse B. \n\n%{\nWe can use a number of <tt>%solve</tt> declarations to test our <tt>less</tt> and <tt>gte</tt> judgments. \n}%\n\n%solve deriv : less (s z) (s (s z)).\n%solve deriv1 : gte (s (s z)) (s z).\n%solve deriv2 : gte z z.\n% solve deriv3 : gte (s z) (s (s z)). % should fail\n\n\n%{\nIt is important to note that while these definitions work as intended as logic programs, proving appropriate [[meta-theorems]] about judgments that use negation as failure is problematic or impossible. \n\n'''Note from dklee: I had to run home to take care of some stuff. I will finish documenting this later in the evening.'''\n\n{{stub}}\n\n}%"
          },
          "sha1": "pone2ksfipa0vtth6nqiturcpcjyww8"
        }
      },
      {
        "title": "Numeric termination metric",
        "ns": 0,
        "id": 2062,
        "redirect": {
          "@title": "Numeric termination metrics",
          "#text": null
        },
        "revision": {
          "id": 5235,
          "parentid": 5234,
          "timestamp": "2008-07-19T02:35:00Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "comment": "Redirecting to [[Numeric termination metrics]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 41,
            "#text": "#REDIRECT [[Numeric termination metrics]]"
          },
          "sha1": "5n1mb5fam7zpkbryrha730cg2oyowzy"
        }
      },
      {
        "title": "Numeric termination metrics",
        "ns": 0,
        "id": 1904,
        "revision": {
          "id": 4156,
          "parentid": 4155,
          "timestamp": "2007-03-15T20:56:52Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 7762,
            "#text": "Sometimes, a proof proceeds not by a direct induction on some assumption, but by induction on some size function computed from an assumption.  To mechanize such a proof in Twelf, you must make the size function explicit in the statement of the theorem.  \n\nThis tutorial presents an example of such a proof. We show a fragment of a proof of confluence for a λ-calculus with typed η-expansion.  The proof inducts on the size of a reduction derivation.  Moreover, the proof uses [[%reduces]] to tell the termination checker that addends are subterms of their sum. In general, a [[%reduces]] declaration is necessary whenever the computation of a numeric termination metric uses an auxiliary relation like addition or maximum.  See the tutorial on [[structural termination metrics]] for another approach to termination metrics.\n\n== Language Definition == \n\nThe syntax, typing judgement, and reduction relation for the language are straightforward:\n\n<twelf>\n%% Syntax\n\ntp  : type.  %name tp T.\no\t: tp.\narrow\t: tp -> tp -> tp.\n\nexp : type.  %name exp E.\nlam\t: tp -> (exp -> exp) -> exp.\napp\t: exp -> exp -> exp.\n\n%% Static Semantics\n\nof : exp -> tp -> type.\nof_lam\t: of (lam T1 E) (arrow T1 T2)\n\t   <- ({x:exp} of x T1 -> of (E x) T2).\nof_app\t: of (app E1 E2) T2\n\t   <- of E1 (arrow T1 T2)\n\t   <- of E2 T1.\n\n%% Dynamic Semantics\n\nreduce : exp -> exp -> type.\n\nreduce_id\t: reduce E E.\nreduce_lam\t: reduce (lam T E) (lam T E')\n\t\t   <- ({x:exp} of x T -> reduce (E x) (E' x)).\nreduce_app\t: reduce (app E1 E2) (app E1' E2')\n\t\t   <- reduce E1 E1'\n\t\t   <- reduce E2 E2'.\nreduce_beta\t: reduce (app (lam T E1) E2) (E1' E2')\n\t\t   <- ({x:exp} of x T -> reduce (E1 x) (E1' x))\n\t\t   <- reduce E2 E2'.\nreduce_eta\t: reduce E (lam T1 ([x] app E' x))\n\t\t   <- of E (arrow T1 T2)\n\t\t   <- reduce E E'.\n</twelf>\n\nThe judgement <tt>reduce</tt> defines a parallel, reflexive reduction relation with typed η-expansion.  \n\n== Facts about numbers ==\n\nIn the proof below, we induct on the size of a reduction derivation.  To get this induction to go through, we require some facts about addition on natural numbers.\n\nFirst, we define addition:\n<twelf>\nnat : type.  %name nat N.\n\n0 : nat.\ns : nat -> nat.\n\n1 : nat = s 0.\n\nsum : nat -> nat -> nat -> type.\n\nsum_0\t\t: sum 0 N N.\nsum_s\t\t: sum (s N1) N2 (s N3)\n\t\t   <- sum N1 N2 N3.\n</twelf>\n\nFor the proof below, we need a way to tell Twelf's termination checker that summands are subterms of their sum.  We do that by proving a lemma with a [[%reduces]] declaration.  \n\nWe prove the lemma for the second summand first.  Note that all arguments of this lemma are inputs; the only \"output\" is the fact that the <tt>%reduces</tt> holds:\n<twelf>\nsum_reduces2 : {N1:nat} {N2:nat} {N3:nat} sum N1 N2 N3 -> type.\n%mode sum_reduces2 +X1 +X2 +X3 +X4.\n\n-: sum_reduces2 _ _ _ sum_0.\n-: sum_reduces2 (s N1) N2 (s N3) (sum_s D)\n    <- sum_reduces2 N1 N2 N3 D.\n\n%worlds () (sum_reduces2 _ _ _ _).\n%total D (sum_reduces2 _ _ _ D).\n%reduces N2 <= N3 (sum_reduces2 N1 N2 N3 _).\n</twelf>\n\nThe easiest way to prove the lemma for the first summand is to commute the addition and appeal to the previous lemma.  We elide the proof of commutativity:\n<twelf hidden=\"true\">\nsum_ident : {n:nat} sum n 0 n -> type.\n%mode sum_ident +N -E.\n\n-0\t: sum_ident 0 sum_0.\n-s\t: sum_ident (s N) (sum_s D)\n\t   <- sum_ident N D.\n\n%worlds () (sum_ident _ _).\n%total N (sum_ident N _).\n\nsum_inc : sum N1 N2 N3 -> sum N1 (s N2) (s N3) -> type.\n%mode sum_inc +D1 -D2.\n\n-0\t: sum_inc sum_0 sum_0.\n-s\t: sum_inc (sum_s D) (sum_s D')\n\t   <- sum_inc D D'.\n\n%worlds () (sum_inc _ _).\n%total D (sum_inc D _).\n\nsum_commute : sum N1 N2 N3 -> sum N2 N1 N3 -> type.\n%mode sum_commute +D1 -D2.\n\n-0\t: sum_commute (sum_0 : sum 0 N N) D\n\t   <- sum_ident N D.\n-s\t: sum_commute (sum_s D : sum (s N1) N2 (s N3)) D''\n\t   <- sum_commute D (D' : sum N2 N1 N3)\n\t   <- sum_inc D' D''.\n\n%worlds () (sum_commute _ _).\n%total D (sum_commute D _).\n</twelf>\n<twelf name=\"_\">\nsum_commute : sum N1 N2 N3 -> sum N2 N1 N3 -> type.\n%mode sum_commute +D1 -D2.\n%worlds () (sum_commute _ _).\n</twelf>\n\n<twelf>\nsum_reduces1 : {N1:nat} {N2:nat} {N3:nat} sum N1 N2 N3 -> type.\n%mode sum_reduces1 +X1 +X2 +X3 +X4.\n\n-\t: sum_reduces1 N1 N2 N3 Dsum\n\t   <- sum_commute Dsum Dsum'\n\t   <- sum_reduces2 N2 N1 N3 Dsum'.\n\n%worlds () (sum_reduces1 _ _ _ _).\n%total {} (sum_reduces1 _ _ _ _).\n%reduces N1 <= N3 (sum_reduces1 N1 N2 N3 _).\n</twelf>\n\n== Proof of confluence ==\n\nWe now show part of the proof of the diamond property for this notion of reduction.  The proof requires a metric computing the size of a reduction derivation.\n\n{{needs|to recreate why you need a metric}}\n\n=== Definition of the metric ===\n\n<twelf>\nreduce_metric : reduce E E' -> nat -> type.\n\nreduce_metric_id\t: reduce_metric reduce_id 1.\nreduce_metric_lam\t: reduce_metric (reduce_lam D) (s N)\n\t\t\t   <- ({x:exp} {d:of x T} reduce_metric (D x d) N).\nreduce_metric_app\t: reduce_metric (reduce_app D2 D1) (s N)\n\t\t\t   <- reduce_metric D1 N1\n\t\t\t   <- reduce_metric D2 N2\n\t\t\t   <- sum N1 N2 N.\nreduce_metric_beta\t: reduce_metric (reduce_beta D2 D1) (s N)\n\t\t\t   <- ({x:exp} {d:of x T} reduce_metric (D1 x d) N1)\n\t\t\t   <- reduce_metric D2 N2\n\t\t\t   <- sum N1 N2 N.\nreduce_metric_eta\t: reduce_metric (reduce_eta D _) (s N)\n\t\t\t   <- reduce_metric D N.\n</twelf>\t\t\t   \n\n=== Excerpt of the proof ===\n\n<twelf check=\"true\">\ndiamond : {N1:nat} {N2:nat}\n\t   {D1:reduce E E1}\n\t   {D2:reduce E E2} \n\t   reduce_metric D1 N1 \n\t   -> reduce_metric D2 N2\n%%\n\t   -> reduce E1 E'\n\t   -> reduce E2 E' -> type.\n%mode diamond +X1 +X2 +X3 +X4 +X5 +X6 -X7 -X8.\n\n-: diamond _ _ reduce_id D _ _ D reduce_id.\n-: diamond _ _ D reduce_id _ _ reduce_id D.\n\n-: diamond (s N1) (s N2)\n    (reduce_lam D1) (reduce_lam D2) \n    (reduce_metric_lam DM1) (reduce_metric_lam DM2)\n    (reduce_lam D1') (reduce_lam D2')\n    <- ({x:exp} {d:of x T}\n\t  diamond N1 N2 (D1 x d) (D2 x d) (DM1 x d) (DM2 x d) (D1' x d) (D2' x d)).\n\n-: diamond \n    (s N1)\n    (s N2)\n    (reduce_app\n       (D21 : reduce E2 E21)\n       (D11 : reduce E1 E11))\n    (reduce_app \n       (D22 : reduce E2 E22)\n       (D12 : reduce E1 E12)) \n    (reduce_metric_app\n       (Dsum1 : sum N11 N21 N1)\n       (DM21 : reduce_metric D21 N21)\n       (DM11 : reduce_metric D11 N11))\n    (reduce_metric_app\n       (Dsum2 : sum N12 N22 N2)\n       (DM22 : reduce_metric D22 N22)\n       (DM12 : reduce_metric D12 N12))\n    (reduce_app D21' D11') (reduce_app D22' D12')\n    <- sum_reduces1 N11 N21 N1 Dsum1\n    <- sum_reduces2 N11 N21 N1 Dsum1\n    <- sum_reduces1 N12 N22 N2 Dsum2\n    <- sum_reduces2 N12 N22 N2 Dsum2\n    <- diamond N11 N12 D11 D12 DM11 DM12 D11' D12'\n    <- diamond N21 N22 D21 D22 DM21 DM22 D21' D22'.\n\n%% fill in remaining cases\n\n%block bind : some {t:tp} block {x:exp} {d:of x t}.\n%worlds (bind) (diamond _ _ _ _ _ _ _ _).\n%terminates [N1 N2] (diamond N1 N2 _ _ _ _ _ _).\n</twelf>\n\nThe <tt>reduce_app</tt> against <tt>reduce_app</tt> case illustrates why we need to know that summands are subterms of their sum: the inductive calls are on the summands that add up to the size of the overall derivation.  If we elided the calls to <tt>sum_reduces*</tt>, the case would not termination-check, because Twelf would not be able to tell that, for example, <tt>N11 < (s N1)</tt>.  \n\nIn other cases, which we have elided, the termination metric gets smaller but the reduction derivations themselves do not.  \n\n{{needs|to show one such case.}}\n\n=== Cleanup === \n\nWe would like an overall theorem:\n\n<twelf>\ndiamond/clean : reduce E E1\n    \t       -> reduce E E2\n  \t       -> reduce E1 E'\n\t       -> reduce E2 E' -> type.\n%mode diamond/clean +X1 +X2 -X3 -X4.\n%worlds (bind) (diamond/clean _ _ _ _ _ _ _ _).\n</twelf>\n\nIt is simple to prove this theorem using the above if we prove an [[effectiveness lemma]] for <tt>reduce_metric</tt>.  \n\n{{tutorial}}"
          },
          "sha1": "0r6wdn5c0g0490r6omtyvfcvx3zkn3c"
        }
      },
      {
        "title": "Object language",
        "ns": 0,
        "id": 1652,
        "redirect": {
          "@title": "Object logic",
          "#text": null
        },
        "revision": {
          "id": 2327,
          "timestamp": "2006-10-02T01:08:38Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "comment": "Redirecting to [[Object logic]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 26,
            "#text": "#REDIRECT [[object logic]]"
          },
          "sha1": "9a5iv0v07ci9usy3iu8ueu0px9fzh29"
        }
      },
      {
        "title": "Object logic",
        "ns": 0,
        "id": 1489,
        "revision": {
          "id": 5324,
          "parentid": 5323,
          "timestamp": "2008-07-20T17:31:12Z",
          "contributor": {
            "username": "TestUser",
            "id": 3
          },
          "comment": "test non-partyelf (rob)",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 798,
            "#text": "An '''object logic''' is a logic encoded as an [[LF]] signature, with the intent of studying it with Twelf. The term \"logic\" is used very broadly here, as it can refer to any '''deductive system''' with an [[abstract syntax]] and a set of [[relation]]s that can be encoded in LF. We use the term '''object language''' as a synonym.  Examples of object logics include arithmetic over [[natural numbers]], a theory of [[lists]], propositional logic, [[linear logic]], or programming languages like the [[simply-typed lambda calculus]].  \n\nIn general, anything defined using an LF signature is an object logic of some form. The term object logic is used to contrast the logic from the [[meta-logic]] used to encode  it.\n\n== See also ==\n\n* [[Proving metatheorems with Twelf]]\n* [[Meta-logic]]\n\n{{stub}}"
          },
          "sha1": "memf22cvibnc5vb1x32m6tzyhqv9784"
        }
      },
      {
        "title": "Object logic syntax",
        "ns": 0,
        "id": 1520,
        "redirect": {
          "@title": "Syntax (Object logic)",
          "#text": null
        },
        "revision": {
          "id": 2034,
          "timestamp": "2006-09-28T01:52:40Z",
          "contributor": {
            "username": "DanielKLee",
            "id": 5
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 35,
            "#text": "#REDIRECT [[Syntax (Object logic)]]"
          },
          "sha1": "daf0000lwwdwozfui9wohsrtf4jv3vi"
        }
      },
      {
        "title": "Output coverage",
        "ns": 0,
        "id": 1968,
        "redirect": {
          "@title": "Coverage checking",
          "#text": null
        },
        "revision": {
          "id": 4505,
          "timestamp": "2007-03-20T23:50:56Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "Redirecting to [[Coverage checking]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 31,
            "#text": "#REDIRECT [[Coverage checking]]"
          },
          "sha1": "sou93o37jm6urub0c6na0aklhlcsf0s"
        }
      },
      {
        "title": "Output factoring",
        "ns": 0,
        "id": 1408,
        "revision": {
          "id": 6190,
          "parentid": 6009,
          "timestamp": "2010-11-23T06:08:42Z",
          "contributor": {
            "username": "Sully",
            "id": 87
          },
          "comment": "Fix to not use deprecated TwelfTags that produce warnings",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 7268,
            "#text": "When checking coverage of [[metatheorem]]s, a common problem arises because the [[output coverage]] checker only considers each rule in isolation. The proof transformation technique for addressing this problem is known as '''output factoring'''.\n \nThe primary symptom of the problem is if Twelf fails when checking an %total declaration and gives this sort of error:\n<code>Totality: Output of subgoal not covered\nOutput coverage error ...</code>\n\n== Even and odd ==\n\nIn this section, we prove that every natural number is even or odd.  First, we define the judgements:\n\n<twelf>\nnat : type.\nz : nat.\ns : nat -> nat.\n\nodd : nat -> type.\neven : nat -> type. \n\nz-e : even z.\ns-o : odd (s X) <- even X.\ns-e : even (s X) <- odd X.\n\neven_or_odd : nat -> type. \n\neoo-e : even_or_odd X <- even X.\neoo-o : even_or_odd X <- odd X. \n</twelf>\n\n=== Incorrect proof ===\n\nNext, we attempt the following theorem:\n\n<twelf>\nalways_even_or_odd : {N:nat} even_or_odd N -> type.\n%mode always_even_or_odd +D -P.   \n\naeo_zero : always_even_or_odd z (eoo-e z-e). \n\naeo_even : always_even_or_odd (s X) (eoo-e (s-e Y))\n\t    <- always_even_or_odd X (eoo-o Y).\n\naeo_odd  : always_even_or_odd (s X) (eoo-o (s-o Y))\n\t    <- always_even_or_odd X (eoo-e Y).\n\n%worlds () (always_even_or_odd D P). \n</twelf>\n\nUnfortunately, totality check fails:\n<twelf check=\"true\" discard=true>\n%total D (always_even_or_odd D _). \n</twelf>\n\nThe line number in Twelf's error message points to the premise of <tt>aeo_even</tt>.  The output of  <tt>always_even_or_odd</tt> can be either <tt>eoo-o _</tt> or <tt>eoo-e _</tt>, but this premise pattern-matches as if the output is always <tt>eoo-o _</tt>. The constant <tt>aeo_odd</tt> covers the alternative case when the output is <tt>eoo-e _</tt>.  \n\nUnfortunately, Twelf's output-coverage checker does not notice this sort of multiple-constant output coverage: the output-coverage checker only accepts a relation if each constant covers all outputs of its premises.\n\n=== Correct proof ===\n\nNonetheless, we need to case-analyze this output in order to complete the proof.  How can we do so?  Well, Twelf does not allow output coverage to be split across constants, but it certainly allows '''input coverage''' to be split across constants.  Thus, we can solve the problem by turning an output-coverage checking problem into an input-coverage checking problem.  We do this by writing an additional helper lemma.\n\nLooking at what the two constants do with the output of the inductive call, we can see that in each case they turn a derivation of <tt>even_or_odd X</tt> into a derivation of <tt>even_or_odd (s X)</tt>—it's just that they do it differently depending on what the output is.  Thus, we factor this reasoning into a lemma:\n\n<twelf>\nlemma : even_or_odd X -> even_or_odd (s X) -> type.\n%mode lemma +X -Y. \n- : lemma (eoo-o Y) (eoo-e (s-e Y)).\n- : lemma (eoo-e Y) (eoo-o (s-o Y)).\n%worlds () (lemma _ _). \n%total X (lemma X _).\t\t\t\t\t       \n</twelf>\n\nUsing this lemma, we complete the proof as follows:\n\n<twelf check=\"true\">\nalways_even_or_odd : {N:nat} even_or_odd N -> type.\n%mode always_even_or_odd +D -P.   \n\naeo_zero : always_even_or_odd z (eoo-e z-e). \n\naeo_succ : always_even_or_odd (s X) D'\n\t    <- always_even_or_odd X D\n            <- lemma D D'.\n\n%worlds () (always_even_or_odd D P). \n%total D (always_even_or_odd D _). \n</twelf>\n\n== Progress ==\n\nAnother example where output factoring comes up is the progress theorem for a programming language:\n\n: If <math>\\mathsf{}e : \\tau</math> then <math>e \\; \\mathsf{value}</math> or <math>e \\mapsto e'</math>.\n\nA typical case of progress makes an inductive call on a subderivation and then case-analyzes whether the result is a value or takes a step.  This reasoning must be factored off into lemmas to avoid output coverage problems.  \n\nUsing the simply typed λ-calculus defined in {{proving|title=Representing the judgements of the STLC}}, we now show how output factoring is used to prove progress.  For review, here is the LF signature for the STLC:\n\n<twelf>\n%% Syntax\ntp    : type.\n\nunit  : tp.\narrow : tp -> tp -> tp.\n\ntm    : type.\nempty : tm.\nlam   : tp -> (tm -> tm) -> tm.\napp   : tm -> tm -> tm.\n\n%% Static Semantics \n\nof       : tm -> tp -> type.\nof_empty : of empty unit.\nof_lam   : of (lam T2 ([x] (E x))) (arrow T2 T)\n            <- ({x:tm} {dx : of x T2} of (E x) T).\nof_app   : of (app E1 E2) T\n            <- of E2 T2\n            <- of E1 (arrow T2 T).\n\n%% Dynamic Semantics\n\nvalue       : tm -> type.\nvalue_empty : value empty.\nvalue_lam   : value (lam T2 ([x] E x)).\n             \nstep          : tm -> tm -> type.\nstep_app_1    : step (app E1 E2) (app E1' E2)\n                 <- step E1 E1'.\nstep_app_2    : step (app E1 E2) (app E1 E2')\n                 <- step E2 E2'\n                 <- value E1.\n\nstep_app_beta : step (app (lam T2 ([x] E x)) E2) (E E2)\n                 <- value E2.\n</twelf>\n\nThe result of progress is represented by the following sum type:\n<twelf>\nval_or_step : tm -> type.\nvos_val : val_or_step E\n           <- value E.\nvos_step : val_or_step E\n            <- step E E'.\n</twelf>\n\nAs discussed above, we first prove a factoring lemma that does all the work after the inductive call of the application case:\n\n<twelf check=\"true\">\nprogress/app : of E1 (arrow T2 T)\n                -> val_or_step E1\n                -> val_or_step E2\n                -> val_or_step (app E1 E2)\n                -> type.\n%mode progress/app +DofE1 +DvosE1 +DvosE2 -DvosApp.\n\npa_step_1 : progress/app \n             _\n             (vos_step DstepE1)\n             _\n             (vos_step (step_app_1 DstepE1)).\n\npa_val_1_step_2 : progress/app\n                   _\n                   (vos_val DvalE1)\n                   (vos_step DstepE2)\n                   (vos_step (step_app_2 DvalE1 DstepE2)).\n\npa_val_val : progress/app\n              (DofE1 : of (lam T2' ([x] E x)) (arrow T2 T))\n              (vos_val \n                 (DvalE1 : value (lam T2' ([x] E x))))\n              (vos_val DvalE2)\n              (vos_step (step_app_beta DvalE2)).\n              \n%worlds () (progress/app _ _ _ _).\n%total {} (progress/app _ _ _ _).\n</twelf>\n\nWe give this lemma the typing derivation for <tt>E1</tt> so that we can learn in the case <tt>pa_val_val</tt> that the <tt>E1</tt> is a <tt>lam</tt>, which is necessary to apply <tt>step_app_beta</tt>.  Note that there is no need for an explicit value inversion/canonical forms lemma: in the case <tt>pa_val_val</tt>, we simply assume that <tt>E1</tt> is a <tt>lam</tt>, and the coverage checker justifies this assumption because it is both a <tt>value</tt> and has type <tt>arrow T2 T</tt>.\n\nUsing this lemma, the proof of progress is quite simple:\n<twelf check=\"true\">\nprogress : of E T -> val_or_step E -> type. \n%mode progress +Dof -Dvos.\n\nprog_empty : progress of_empty (vos_val value_empty).\n\nprog_lam : progress (of_lam ([x] [dx] DofE x dx)) (vos_val value_lam).\n\nprog_app : progress (of_app (DofE1 : of E1 (arrow T2 T)) \n                            (DofE2 : of E2 T2))\n            DvosApp\n            <- progress DofE1 (DvosE1 : val_or_step E1)\n            <- progress DofE2 (DvosE2 : val_or_step E2)\n            <- progress/app DofE1 DvosE1 DvosE2 DvosApp.\n\n%worlds () (progress _ _).             \n%total D (progress D _).\n</twelf>\n\n{{tutorial}}"
          },
          "sha1": "bd57i1pkpikngvdxi6wqo0u8jdsohv7"
        }
      },
      {
        "title": "Output freeness",
        "ns": 0,
        "id": 1455,
        "revision": {
          "id": 6154,
          "parentid": 4270,
          "timestamp": "2010-09-21T01:28:55Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "update twelftag",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 4250,
            "#text": "{{undocumented}}\nWhen Twelf [[%total|proves that an LF type family defines a total relation]], it checks that the output of each premise of each constant can never fail to unify with an output that is actually produced.  This is called [[output coverage]] checking.  One way in which a premise can fail output coverage checking is if its output is a metavariable that is constrained by appearing elsewhere in the constant.  \n\n'''Output freeness checking''' ensures that no outputs are constrained in such a manner.  More precisely, the output freeness check ensures that a metavariable in an output position does not occur in any previous input or output (where \"previous\" is the same order used in [[%mode]] checking—i.e., the search order of the [[logic programming]] operational semantics).  \n\nPrior to Twelf 1.5, output freeness checking was not implemented, allowing some false metatheorems to check. \n\n== Simple example ==\n\nAs a first output freeness violation, consider the following buggy definition of the addition relation on natural numbers:\n\n<twelf export=\"nat\">\nnat : type.\ns : nat -> nat.\nz : nat.\n</twelf>\n\n<twelf export=\"ex1\" import=\"nat\">\nadd : nat -> nat -> nat -> type.\n%mode add +M +N -O.\n\nadd/z : add M z M.\n\nadd/s-incorrect : add M (s N) (s N)\n                   <- add M N N.\n\n%worlds () (add _ _ _).\n</twelf>\n\nThis type family <tt>add</tt> clearly does not define a total relation: the constant <tt>add/s-incorrect</tt> only applies when <tt>add M N N</tt>, but in general it is possible to derive <tt>add M N O</tt> for <tt>O</tt> not equal to <tt>N</tt> (and the constant <tt>add-s-incorrect</tt> is the only constant that covers the case when the second number is a successor, so the relation is clearly not total without this constant).  \n\nThus, Twelf reports an output coverage error on this constant when we attempt to check totality:\n\n<twelf check=\"decl\" import=\"ex1\">\n%total N (add _ N _).\n</twelf>\n\nTwelf reports an output freeness error: the output metavariable <tt>N</tt> occurs previously because <tt>N</tt> is an input to the relation.\n\n== Uniqueness example ==\n\nIt is common to encounter output freeness errors when working with relations that have unique outputs.  For example, consider a correct definition of <tt>add</tt>:\n\n<twelf export=\"ex3\" import=\"nat\">\nadd : nat -> nat -> nat -> type.\n%mode add +M +N -O.\n\nadd/z : add M z M.\n\nadd/s-incorrect : add M (s N) (s O)\n                   <- add M N O.\n%worlds () (add _ _ _).\n%total N (add _ N _).\n</twelf>\n\nThis relation satisfies a [[uniqueness lemma]] stating that the first two indices (the summands) uniquely determine the third (the sum).\n\nNow, suppose we use <tt>add</tt> to define another relation:\n\n<twelf import=\"ex3\">\nadd2 : nat -> nat -> type.\n%mode add2 +N -O.\n\n- : add2 N O\n      <- add (s (s z)) N O\n      <- add (s (s z)) N O.\n\n%worlds () (add2 _ _).\n</twelf>\n\nHere, we have unnecessarily copied the <tt>add</tt> premise twice.  However, because <tt>add</tt> satisfies the aforementioned uniqueness lemma, it is, in fact, correct to insist that we get the same output <tt>O</tt> in each case.  Unfortunately, Twelf is not aware of this uniqueness lemma, so it flags an error:\n\n<twelf import=\"ex3\" check=\"decl\">\n%total {} (add2 _ _).\n</twelf>\n\nThe second output occurrence of <tt>O</tt> occurs previously in the first one.\n\nThis example, where we explicitly repeat a premise, is clearly avoidable.  However, analogous situations do come up in practice, and to work around them, you must prove and use the [[uniqueness lemma]] explicitly.  \n\n== Non-free implicit outputs ==\n\nAnother common source of output freeness errors is constraining implicit outputs that appear in the types of other outputs.\n\n{{needs|an example of this point}}\n\nThis is where output freeness violations usually come up in connection with unique relations: if we have a derivation <tt>D : add M N O</tt> and a premise that returns another derivation of <tt>D' : add M N O'</tt>, a common error is to insist that <tt>O'</tt> be <tt>O</tt> (which in fact it must be, but Twelf doesn't know this).  Even though we match the output derivation <tt>D'</tt> with a fresh metavariable, we get an output freeness error because we constrain the type of <tt>D'</tt>.  \n\n{{tutorial}}"
          },
          "sha1": "g9dsehsth8o8wj68jisqw70ix8x00c3"
        }
      },
      {
        "title": "PLTheory:Introduction to Twelf",
        "ns": 0,
        "id": 2082,
        "revision": {
          "id": 5417,
          "parentid": 5380,
          "timestamp": "2008-11-01T03:12:21Z",
          "contributor": {
            "username": "Twilson",
            "id": 15
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 961,
            "#text": "This article is an introduction to Twelf and how it can be used to represent basic data structures and logical systems&mdash;in particular the judgment-based syntax and semantics of programming languages&mdash;as well as represent and check proofs of their properties.  Additional [[introductions to Twelf]] and many [[tutorials]] that explain representation and proof techniques can be found elsewhere.  These notes assume that you have already installed Twelf and are familiar with the process of starting and interacting with a Twelf server.  Additional information on getting started with Twelf can be found in the [[Documentation]] section, and in particular the [[User's Guide]] (which also comes with the Twelf distribution).\n\n== Table of Contents for Part 1 ==\n\n# [[First-order encodings]]\n# [[Signatures as logic programs]]\n# [[Signature checking]]: modes, termination, coverage, totality\n# [[Higher-order encodings]]\n# [[Common patterns and pitfalls]]"
          },
          "sha1": "q7js54g2w3h3dz24ka110uq9vf822pg"
        }
      },
      {
        "title": "POPL Tutorial",
        "ns": 0,
        "id": 2084,
        "revision": {
          "id": 6223,
          "parentid": 6042,
          "timestamp": "2011-03-02T23:44:16Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "/* Get Twelf before the tutorial! */",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 3413,
            "#text": "<!--\n<div style=\"font-size:162%;border:none;margin: 0;padding:.1em;color:#F00\">'''''We want your input!'''''</div>\n\nHelp us out by filling out our handy dandy [http://spreadsheets.google.com/viewform?key=pff4VF1v6KVNcwC_c2qFAGA feedback form]!\n-->\n\n== Mechanizing Metatheory with LF and Twelf ==\n\nDo you want to learn how to use [[Main page|Twelf]] to specify, implement, and prove\nproperties about programming languages?  \n\nCome to the Twelf tutorial on '''January 19, 2009''', co-located with POPL 2009, in\n'''Savannah, Georgia'''.\n\nLearn to:\n* Represent [[deductive systems|languages and logics]] in [[LF]]\n* Prove [[metatheorem]]s with [[Main page|Twelf]]\nunder the helpful guidance of Twelf experts.  \n\nThe tutorial will be a highly interactive introduction to LF and Twelf\naimed at programming languages researchers. No prior experience with LF\nand Twelf is presumed.  Participants will leave the workshop with\nexperience in reading and writing LF representations of programming\nlanguages, and experience reading, writing, and debugging Twelf proofs.\n\nRegister at the [http://www.regmaster.com/conf/popl2009.html POPL 2009 registration site]!  \n                                                                                                                                                            \nThe tutorial is organized and presented by the CMU Principles of Programming group.  The presenters and TAs at POPL will be Dan Licata, William Lovas, Chris Martens, Rob Simmons, Bob Harper, and Karl Crary.  \n\n== Schedule ==\n\nThe tutorial will begin at '''9:00AM'''. Get [http://twelf.plparty.org/tutorialslides/lectures.pdf the slides]!\n\n* Part 1: [[POPL_Tutorial/Basics|Basic Twelf Skills]]\n* Part 2: [[POPL_Tutorial/MinML|Mechanizing MinML]]\n* Part 3: [[POPL_Tutorial/Combinators|Combinators: Worlds and Adequacy]]\n* Coda: [[POPL_Tutorial/Next|What's next?]]\n\nThere will be a morning coffee break (10AM), lunch (12:30PM-1:30PM), and an afternoon coffee break (3PM).\n\n== Get Twelf before the tutorial! ==\n\nThe tutorial will be interactive, with participants writing Twelf code, so you should come with Twelf installed on your laptop.\n\nPre-built binaries of Twelf are available for most operating systems: see the [[Download|download page]].\n\nOtherwise:\n* you can build Twelf from the [http://twelf.plparty.org/builds/twelf-src.tar.gz source tarball].  You will need [http://www.mlton.org MLton] or [http://www.smlnj.org sml/nj]. \n* you can make yourself an account on the wiki, and do the exercises on your User:<login> page (linked at the top after you log in).\n\nThen see [[Twelf with Emacs]] for the basics of interacting with Twelf.  (You can also use [[Twelf without Emacs]], by interacting with the Twelf server directly.)\n\n== Sponsors ==\n\nThanks to our sponsors: \n[http://www.cs.cmu.edu Carnegie Mellon School of Computer Science],\n[http://www.research.ibm.com IBM Research], \n[http://research.microsoft.com/ Microsoft Research], \n[http://www.intel.com/ Intel],\n[http://www.docomolabs-usa.com/ DOCOMO USA Labs],\n[http://www.mozilla.org/ Mozilla],\n[http://www.google.com/ Google].\n\n[[Image:POPL_Tutorial-cmu.gif|250px]] [[Image:POPL_Tutorial-scslogo.gif]]\n\n[[Image:POPL_Tutorial-IBM.jpg|600px]]\n\n[[Image:POPL Tutorial-msr.jpg]] [[Image:POPL Tutorial-intel.jpg|300px]]\n\n\n[[Image:POPL_Tutorial-docomo-logo.gif|250px]] [[Image:POPL Tutorial-mozilla.jpg|300px]]\n\n[[Image:POPL Tutorial-google-logo.gif]]"
          },
          "sha1": "l9vh9ibpigem6hp5blaotb72khte92y"
        }
      },
      {
        "title": "POPL Tutorial/Basic error messages",
        "ns": 0,
        "id": 2161,
        "revision": {
          "id": 6097,
          "parentid": 6096,
          "timestamp": "2010-09-01T18:30:48Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "Fix twelftag bugs",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 9399,
            "#text": "==How Twelf checks assertions==\n\nTwelf proves a totality assertion for a type family such as\n<tt>mult</tt> by checking several properties.  These properties, taken\ntogether, constitute a proof by induction on canonical forms that the\ntype family defines a total relation.\n\n===Running Example ===\n\nWe'll start from the following code:\n\n<twelf import=\"base\">\nnat : type.  \nzero : nat.\nsucc : nat -> nat.\n\nadd : nat -> nat -> nat -> type.\n%mode add +M +N -P.\n\nadd/z : add zero N N.\nadd/s : add (succ M) N (succ P) \n\t <- add M N P.\n\n%worlds () (add _ _ _).\n%total M (add M _ _).\n</twelf>\n\n<twelf import=\"base\" export=\"mult\">\nmult : nat -> nat -> nat -> type.\n%mode mult +M +N -P.\n\nmult/z : mult zero N zero.\nmult/s : mult (succ M) N P'\n\t  <- mult M N P\n\t  <- add N P P'.\n</twelf>\n\n===Mode=== \n\nTwelf checks that each constant inhabiting the type family is\n''well-moded''.  Roughly, this means that the inputs to the conclusion\nof a constant determine the inputs of the first premise, and that these\ntogether with the outputs of the first premise determine the inputs of\nthe second premise, and so on, until the outputs of all the premises\ndetermine the outputs of the conclusion.\nFor example, the constant\n<twelf import=\"mult\" discard=true>\nmult/s : mult (succ M) N P'\n\t  <- mult M N P\n\t  <- add N P P'.\n</twelf>\n\nhas mode <tt>+M +N -P</tt> because the input <tt>M</tt> and <tt>N</tt>\nin the conclusion determine the inputs of the premise, and the\n<tt>P</tt> output by the premise determines the first input to the second\npremise (add), and the output of that determines the conclusion.  \nOn the other hand, a constant\n\n<twelf import=\"mult\" check=decl discard=true>\nmult/bad-mode-output : mult zero N P.\n</twelf>\nis not well-moded---the output <tt>P</tt> is not determined by the\ninputs.  Similarly, \n<twelf import=\"mult\" check=decl discard=true>\nmult/bad-mode-input : mult (succ M) N zero\n \t\t       <- mult M Q P.\n</twelf> \nis not well-moded---the second input to the premise is not determined\nby the inputs of the conclusion.\n\nNote that subgoal order matters: \n\n<twelf import=\"mult\" check=decl discard=true>\nmult/s : mult (succ M) N Q\n\t  <- add P N Q\n\t  <- mult M N P.\n</twelf>\n\nThe premises are mode-checked in order; the outputs from one subgoal are\nconsider ground in subsequent premises.\n\n===Worlds===\n\nTwelf checks that each constant inhabiting the type family obeys the\nworlds declaration.  Because we are only proving theorems about closed\nterms right now, we will not run across any problems with world\nchecks.  \n\n===Termination===\n\nTwelf checks that each constant inhabiting the type family obeys the\ninduction order specified in the <tt>%total</tt> declaration.  In each\ninductive premise of a constant, the specified induction position must\nbe a strict subterm of the corresponding argument in the conclusion.\nFor example, the constant\n\n<twelf import=\"mult\" discard=true>\nmult/s : mult (s M) N Q\n\t  <- mult M N P\n\t  <- add P N Q.\n</twelf>\nobeys the induction order <tt>M</tt> specified in the above totality\nassertion because the term <tt>M</tt> is a strict subterm of the term\n<tt>(s M)</tt>.\n\nRecuring on exactly the same term is obviously a termination error:\n<twelf import=\"mult\" check=decl discard=true>\nmult/bad-termination-1 : mult M N P\n\t\t\t  <- mult M N P.\n%total M (mult M _ _).\n</twelf>\n\nAs is recuring on an entirely unrelated argumenet:\n\n<twelf import=\"mult\" check=decl discard=true>\nmult/bad-termination-2 : mult M N P\n\t\t\t  <- mult N N P.\n%total M (mult M _ _).\n</twelf>\n\nFor example Twelf would not accept the totality of <tt>mult</tt>\nif <tt>N</tt> were used as the induction order&mdash;the same term\n<tt>N</tt> in the conclusion of this constant appears in the premise:\n\n<twelf import=\"mult\" check=decl discard=true>\n%total N (mult _ N _).\n</twelf>\n\nIn addition to the subterm ordering on a single argument, Twelf supports\n[[mutual induction]] and [[lexicographic induction]].\n\n===Output coverage===\n\nIn the definition of a type family, you may pattern-match the outputs of\na premise.  For example, we might write\n<twelf import=\"mult\" check=decl discard=true>\nmult/bad-output-cov : mult (succ M) N zero\n\t\t       <- mult M N (succ P).\n%worlds () (mult _ _ _).\n%total N1 (mult N1 N2 N3).\n</twelf>\n\nHere we have insisted that the output of the premise has the form\n<tt>succ P</tt> for some <tt>P</tt>.  Twelf correctly reports an output\ncoverage error because this condition can fail.\n\nPattern-matching the output of a premise is like an [[inversion]] step\nin a proof: you're insisting that the premise derivation must conclude a\nparticular fact that is more specific than the judgement form itself.\nFor Twelf to accept a relation as total, Twelf must notice that all of\nthese inversions are permissible.  Twelf permits such inversions when it\nis readily apparent that they are justified, and those inversions that\nTwelf does not accept can be proved explicitly.\n\nIn this example, we got an output coverage error because we constrained\nthe output of the premise by insisting it be formed by a particular\nconstant.  The other way to get output coverage errors is to insist that\nthe output of a premise be a variable that occurs elsewhere in the type.\nFor example:\n\n<twelf import=\"mult\" check=decl discard=true>\nmult/bad-output-free : mult (succ M) N zero\n\t\t\t<- mult M N N.\n%worlds () (mult _ _ _).\n%total N1 (mult N1 N2 N3).\n</twelf>\n\nHere, we insisted that the output of the premise be the number\n<tt>N</tt> that we put in.  Twelf is very conservative in checking\n[[output freeness]]: a type family will not be judged total if you\nconstrain the outputs of any premise at all in this manner.\n\n===Input coverage===\n\nMode, worlds, termination, and output coverage ensure that each constant\nreally does cover the part of the relation indicated by its conclusion.\nFor example, if <tt>mult</tt> passes these four checks, we know that\n<tt>mult/z</tt> and <tt>mult/s</tt> cover <tt>(zero, N, _)</tt> and <tt>(succ M,\nN, _)</tt>, respectively.  What else is necessary to know that\n<tt>mult</tt> defines a total relation?  We need to know that all the\nconstants inhabiting <tt>mult</tt>, taken together, cover all of the\ninputs.  Input coverage checks exactly this.\n\nFor example, if we forgot <tt>mult/z</tt>, input coverage for\n<tt>mult</tt> would fail.  For example:\n\n<twelf import=\"base\" check=decl discard=true>\nmult' : nat -> nat -> nat -> type.\n%mode mult' +N1 +N2 -X3.\n\nmult'/s : mult' (succ M) N Q\n\t  <- mult' M N P\n\t  <- add P N Q.\n\n%worlds () (mult' _ _ _).\n%total M (mult' M _ _).\n</twelf>\n\nHere's an analogy that might be helpful: You can think of each constant\nof a type as being a clause in an ML pattern matching declaration.  Then\ninput coverage is like the exhaustiveness checker for pattern matching.\n\nTwelf checks input coverage by [[splitting]] the input types to\ncase-analyze the various constants that could have been used to inhabit\nthem.  For <tt>add</tt>, Twelf splits the first <tt>nat</tt> argument\n<tt>M</tt>, and then checks that the cases <tt>plus z N N</tt> and\n<tt>add (succ M) N P</tt> are covered.  Fortunately, these are exactly\nthe cases we wrote down.  If we had case-analyzed further in the\ndefinition of the judgement (e.g., if the definition of <tt>plus</tt>\ncase-analyzed the second argument as well), Twelf would continue\nsplitting the input space.  Because Twelf separates termination checking\nand coverage checking, the constants defining a type family do not need\nto follow any particular primitive recursion schema-the constants may\npattern-match the inputs in a general manner.\n\n==When Twelf checks what==\n\nTo a first approximation, you can think of the <tt>%mode</tt> and <tt>%worlds</tt> declarations as specifying a totality assertion and the <tt>%total</tt> declaration as checking it.  This isn't exactly how Twelf works, though:\n\n# When a <tt>%mode</tt> declaration is entered, Twelf checks that all previous constants inhabiting the specified type family are well-moded; further, it then mode-checks any subsequent constants inhabiting that family.  \n# When a <tt>%worlds</tt> declaration is entered, Twelf world-checks the type family; further, it then reports an error if any new constants contributing to the family at all are added.\n# When a <tt>%total</tt> declaration is entered, Twelf checks termination, then input coverage, then output coverage.  When checking output coverage, Twelf checks for unjustified constant pattern-matching in a first pass and then output freeness problems in a second pass.\n\nThis separation allows you to, for example, check that each constant in a family is well-moded (i.e., takes specified inputs to specified outputs) without checking that the entire type family is total.  You can also use the declarations [[%terminates]] and [[%covers]] to check termination and input coverage independently.\n\nIf any constant in a type family fails mode, worlds, or output coverage, then mode, worlds, or totality checking fails for the whole type family.  One could imagine that Twelf instead would just disregard the offending constant: it is possible that the type family as a whole satisfies a totality assertion without that constant, and, in a mathematical sense, adding additional constants never invalidates the fact a totality assertion is true of a family.    The reason Twelf does not work this way is that <tt>%total</tt> actually has a more specific meaning, as we discuss in the next section."
          },
          "sha1": "6eusoegqax55kmlqc0bp3wt5am24t91"
        }
      },
      {
        "title": "POPL Tutorial/Basics",
        "ns": 0,
        "id": 2156,
        "revision": {
          "id": 7949,
          "parentid": 7948,
          "timestamp": "2013-08-08T11:45:00Z",
          "contributor": {
            "username": "Namin",
            "id": 10184
          },
          "comment": "fix link",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 286,
            "#text": "* [[POPL Tutorial/Basic error messages|Examples of basic error messages]]\n* [http://twelf.org/w/index.php?title=POPL_Tutorial/Basics_Starter&action=raw&ctype=text/css Starter code]: start from here if you don't want to type along\n* [[POPL Tutorial/Basics Answer|Solutions to exercises]]"
          },
          "sha1": "p6k0whld836jilqlrw1do2pm1lay048"
        }
      },
      {
        "title": "POPL Tutorial/Basics Answer",
        "ns": 0,
        "id": 2155,
        "revision": {
          "id": 5753,
          "timestamp": "2009-01-17T03:07:52Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "comment": "New page: %{   == Natural numbers ==  }%  nat : type.  zero : nat. succ : nat -> nat.  %{  == Addition ==  }%  add : nat -> nat -> nat -> type.  add/z : add zero N N.  add/s : add (succ M) N (succ P...",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 2450,
            "#text": "%{ \n\n== Natural numbers ==\n\n}%\n\nnat : type.\n\nzero : nat.\nsucc : nat -> nat.\n\n%{\n\n== Addition ==\n\n}%\n\nadd : nat -> nat -> nat -> type.\n\nadd/z : add zero N N.\n\nadd/s : add (succ M) N (succ P)\n\t <- add M N P.\n\n%{\n\n=== Example derivations ===\n\n}%\n\n1 : nat = succ zero.\n2 : nat = succ 1.\n1+1is2 : add 1 1 2 = add/s (add/z).\n\n%% explicit version of add/z\n%% add/z-explicit  : {n:nat} add zero n n.\n%% 1+1is2-explicit : add 1 1 2 = add/s (add/z-explicit 1).\n\n%{\n\n== Exercise: Multiplication ==\n\n}%\n\nmult : nat -> nat -> nat -> type.\n\nmult/z : mult zero N zero.\n\nmult/s : mult (succ M) N P'\n\t  <- mult M N P\n\t  <- add N P P'.\n\n%% note that the arguments are \"backwards\"\n1*2is2 : mult 1 2 2 = mult/s (add/s (add/s add/z)) mult/z.\n\n%{\n\n== Mode, worlds total ==\n\n}%\n\n%mode add +M +N -P.\n%worlds () (add _ _ _).\n%total M (add M _ _).\n\n%solve 1+1is2' : add 1 1 N.\n\n%% Examples of errors:\n%% \n%% mult/bad-mode-output : mult zero N Q.\n%% \n%% mult/bad-mode-input : mult (succ M) N zero\n%% \t\t       <- mult M Q P.\n%% \n%% %% do input coverage by removing cases\n%% \n%% mult/bad-termination-1 : mult M N P\n%% \t\t\t  <- mult M N P.\n%% mult/bad-termination-2 : mult M N P\n%% \t\t\t  <- mult N N P.\n%% \n%% mult/bad-output-free : mult (succ M) N zero\n%% \t\t\t<- mult M N N.\n%% mult/bad-output-cov : mult (succ M) N zero\n%% \t\t       <- mult M N (succ P).\n\n%mode mult +M +N -P.\n%worlds () (mult _ _ _).\n%total M (mult M _ _).\n\n%{\n\n== Right-hand zero ==\n\n}%\n\nrhzero : {M : nat} add M zero M -> type.\n%mode rhzero +M -D.\n\n- : rhzero zero add/z.\n- : rhzero (succ M) (add/s D)\n     <- rhzero M (D : add M zero M).\n     \n%worlds () (rhzero _ _).\n%total M (rhzero M _).\n\n%{\n\n== Right-hand succ ==\n\n}%\n\nrhsucc : add M N P -> add M (succ N) (succ P) -> type.\n%mode rhsucc +D1 -D2.\n\n- : rhsucc (add/z : add zero M M) (add/z : add zero (succ M) (succ M)).\n- : rhsucc (add/s (D1 : add M N P)) (add/s D2)\n     <- rhsucc D1 (D2 : add M (succ N) (succ P)).\n\n%% remark that type annotations are optional:\n%% - : rhsucc add/z add/z.\n%% - : rhsucc (add/s D1) (add/s D2)\n%%      <- rhsucc D1 D2.\n     \n%worlds () (rhsucc _ _).\n%total M (rhsucc M _).\n\n%{\n\n== Exercise: addition is commutative ==\n\n}%\n\ncommute : add M N P -> add N M P -> type.\n%mode commute +D1 -D2.\n\n- : commute (add/z : add zero M M) D\n     <- rhzero M D.\n\n- : commute (add/s (D : add M N P)) D''\n     <- commute D  (D' : add N M P)\n     <- rhsucc D' (D'' : add N (succ M) (succ P)).\n\n%worlds () (commute _ _).\n%total D (commute D _)."
          },
          "sha1": "1du2ian8rdknyotmllfz2ure861ec84"
        }
      },
      {
        "title": "POPL Tutorial/Basics Starter",
        "ns": 0,
        "id": 2153,
        "revision": {
          "id": 5751,
          "parentid": 5750,
          "timestamp": "2009-01-17T03:06:51Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "minor": null,
          "comment": "[[POPL Tutorial/Nat Starter]] moved to [[POPL Tutorial/Basics Starter]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 1483,
            "#text": "%{ \n\n== Natural numbers ==\n\n}%\n\nnat : type.\n\nzero : nat.\nsucc : nat -> nat.\n\n%{\n\n== Addition ==\n\n}%\n\nadd : nat -> nat -> nat -> type.\n\nadd/z : add zero N N.\n\nadd/s : add (succ M) N (succ P)\n\t <- add M N P.\n\n%{\n\n=== Example derivations ===\n\n}%\n\n1 : nat = succ zero.\n2 : nat = succ 1.\n1+1is2 : add 1 1 2 = add/s (add/z).\n\n%{\n\n== Exercise: Multiplication ==\n\n}%\n\nmult : nat -> nat -> nat -> type.\n\n\n\n\n\n\n\n\n%% The syntax '% .' (without the space)\n%% causes Twelf to stop processing the file at this point\n%% remove once you have completed the exercise\n%.\n\n%% note that the arguments are \"backwards\"\n1*2is2 : mult 1 2 2 = mult/s (add/s (add/s add/z)) mult/z.\n\n%{\n\n== Mode, worlds total ==\n\n}%\n\n%mode add +M +N -P.\n%worlds () (add _ _ _).\n%total M (add M _ _).\n\n%solve 1+1is2' : add 1 1 N.\n\n%mode mult +M +N -P.\n%worlds () (mult _ _ _).\n%total M (mult M _ _).\n\n%{\n\n== Right-hand zero ==\n\n}%\n\nrhzero : {M : nat} add M zero M -> type.\n%mode rhzero +M -D.\n\n- : rhzero zero add/z.\n- : rhzero (succ M) (add/s D)\n     <- rhzero M (D : add M zero M).\n     \n%worlds () (rhzero _ _).\n%total M (rhzero M _).\n\n%{\n\n== Right-hand succ ==\n\n}%\n\nrhsucc : add M N P -> add M (succ N) (succ P) -> type.\n%mode rhsucc +D1 -D2.\n\n- : rhsucc (add/z : add zero M M) (add/z : add zero (succ M) (succ M)).\n- : rhsucc (add/s (D1 : add M N P)) (add/s D2)\n     <- rhsucc D1 (D2 : add M (succ N) (succ P)).\n     \n%worlds () (rhsucc _ _).\n%total M (rhsucc M _).\n\n%{\n\n== Exercise: Prove that addition is commutative ==\n\n}%"
          },
          "sha1": "5n8r3obkgt4ofoies3yiqvl3ply7yxg"
        }
      },
      {
        "title": "POPL Tutorial/Big step, small step",
        "ns": 0,
        "id": 2122,
        "revision": {
          "id": 5821,
          "parentid": 5820,
          "timestamp": "2009-01-18T08:02:34Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 13631,
            "#text": "%{ In this exercise, we explore the relationship between big-step evaluation and \nsmall-step transition semantics for the MinML language we worked with before. \nThe theroem we want to establish is that an expression e evaluates\nto a value v in many little steps if and only if it evaluates to v in one \nbig step.\n\nThere are five tasks:\n* Complete a compatibility lemma that if <math>e \\mapsto^* e'</math>, then <math>v~e \\mapsto^* v~e'</math>\n* Prove the backward direction (big-step evaluation implies small-step evaluation)\n* Prove three cases of the expansion lemma.\n* Prove the forward direction (small-step evaluation implies big-step evaluation) for a \"convienent\" definition of multi-step.\n* Prove the forward direction for the original definition of multi-step.\n\nThe solution is [[POPL Tutorial/Big step, small step: Solution|here]].\n\n== Syntax ==\n\nTypes:\n\n}%\n\ntp : type.\t\t\t\t%name tp T.\nnat : tp.\narr : tp -> tp -> tp.\n\n%{\n\nExpressions\n\n}%\n\nexp : type.\t\t\t\t%name exp E.\nfn : tp -> (exp -> exp) -> exp.\napp : exp -> exp -> exp.\nz : exp.\ns : exp -> exp.\nifz : exp -> exp -> (exp -> exp) -> exp.\n\n\n%{\n\n== Small-step dynamic semantics ==\n\n}%\n\nvalue : exp -> type.\t\t\t%name value Dval.\n%mode value +E.\n\nvalue/z : value z.\nvalue/s : value (s E) \n\t   <- value E.\nvalue/fn : value (fn _ _).\n\nstep : exp -> exp -> type.\t\t%name step Dstep.\n%mode step +E1 -E2.\n\nstep/app/fn : step (app E1 E2) (app E1' E2)\n\t       <- step E1 E1'.\nstep/app/arg : step (app E1 E2) (app E1 E2')\n\t\t<- value E1 <- step E2 E2'.\nstep/app/beta : step (app (fn _ ([x] E x)) E2) (E E2)\n\t\t <- value E2.\nstep/s : step (s E) (s E') \n\t  <- step E E'.\nstep/ifz/arg : step (ifz E E1 ([x] E2 x)) (ifz E' E1 ([x] E2 x))\n\t\t<- step E E'.\nstep/ifz/z : step (ifz z E1 ([x] E2 x)) E1.\nstep/ifz/s : step (ifz (s E) E1 ([x] E2 x)) (E2 E)\n\t      <- value E.\n\n%{\n\n=== Multi-step ===\n\n}%\n\nstep* : exp -> exp -> type.             %name step* Dstep*.\n\nstep*/step : step* E E'\n              <- step E E'.\nstep*/refl : step* E E.\nstep*/trans : step* E E''\n               <- step* E' E''\n               <- step* E E'.\n\n%{\n\nWe can define <tt>D1 @ D2</tt> to be an abbreviation for <tt>step*/trans\nD1 D2</tt>.  This is convenient for chaining together several derivations\nusing transitivity.\n\n}%\n\n%abbrev @ : step* E E' -> step* E' E'' -> step* E E''\n          = [d1] [d2] step*/trans d1 d2.\n\n%infix right 10 @.\n\n\n%{\n\n== Big-step dynamic semantics ==\n\n}%\n\neval : exp -> exp -> type.              %name eval Deval.\n\neval/z : eval z z.\neval/s : eval (s E) (s V)\n          <- eval E V.\neval/ifz/z : eval (ifz E E0 ([x] E1 x)) V0\n              <- eval E z\n              <- eval E0 V0.\neval/ifz/s : eval (ifz E E0 ([x] E1 x)) V1\n              <- eval E (s V)\n              <- eval (E1 V) V1.\neval/fn : eval (fn T1 ([x] E x)) (fn T1 ([x] E x)).\n\neval/app : eval (app E1 E2) V\n            <- eval E1 (fn T1 ([x] E x))\n            <- eval E2 V2\n            <- eval (E V2) V.\n\n%{\n\n== Lemmas ==\n\nThere are two easy lemmas we'll need later that relate evaluation to\nthe value judgement from above.\n\n=== Evaluation returns a value ===\n\n}%\n\neval-val : eval E V -> value V -> type.\n%mode eval-val +D1 -D2.\n\n- : eval-val eval/z value/z.\n- : eval-val (eval/s D) (value/s Dval)\n     <- eval-val D Dval.\n- : eval-val (eval/ifz/z (D0 : eval E0 V0)\n                         (Dz : eval E z))\n        Dval0\n     <- eval-val D0 (Dval0 : value V0).\n- : eval-val (eval/ifz/s (D1 : eval (E1 V) V1)\n                         (Ds : eval E (s V))\n                : eval (ifz E E0 [x] E1 x) V1)\n        Dval1\n     <- eval-val D1 (Dval1 : value V1).\n- : eval-val eval/fn value/fn.\n- : eval-val (eval/app (Dsub : eval (E V2) V)\n                       (D2 : eval E2 V2)\n                       (D1 : eval E1 (fn T1 ([x] E x))))\n        DvalV\n     <- eval-val Dsub (DvalV : value V).\n\n%worlds () (eval-val _ _).\n%total D (eval-val D _).\n\n%{\n\n=== Values evaluate to themselves ===\n\n}%\n\nval-eval : value V -> eval V V -> type.\n%mode val-eval +Dval -Dev.\n\n- : val-eval value/z eval/z.\n- : val-eval (value/s Dval) (eval/s Dev)\n     <- val-eval Dval Dev.\n- : val-eval value/fn eval/fn.\n\n%worlds () (val-eval _ _).\n%total D (val-eval D _).\n\n\n\n%{\n\n== Big-step implies multi-step ==\n\nOur first main theorem is to show that big-step evaluation implies\nmulti-step evaluation, i.e. that if <tt>eval E V</tt> then <tt>step*\nE V</tt>.\n\n=== Compatibility lemmas ===\n\nTo prove this, we'll need some compatibility lemmas for multi-step\ntransition which say that multi-step transitions in a sub-term of a\nterm can be bubbled up to the term itself.\n\nEach argument proceeds by induction on the derivation that\n<tt>step* E E'</tt>.\n\n}%\n\nstep*/s : step* E E' -> step* (s E) (s E') -> type.\n%mode step*/s +D* -D*s.\n\n- : step*/s (step*/step (D : step E E')) (step*/step (step/s D)).\n- : step*/s (step*/refl : step* E E) (step*/refl : step* (s E) (s E)).\n- : step*/s (step*/trans (D* : step* E E') (D*' : step* E' E''))\n            (step*/trans D*s D*'s)\n     <- step*/s D* (D*s : step* (s E) (s E'))\n     <- step*/s D*' (D*'s : step* (s E') (s E'')).\n\n%worlds () (step*/s _ _).\n%total D (step*/s D _).\n\nstep*/ifz/arg : step* E E' -> step* (ifz E E0 [x] E1 x) (ifz E' E0 [x] E1 x)\n                 -> type.\n%mode +{E:exp} +{E':exp} +{E0:exp} +{E1:exp -> exp} +{D:step* E E'}\n   -{Difz:step* (ifz E E0 ([x:exp] E1 x)) (ifz E' E0 ([x:exp] E1 x))}\n   (step*/ifz/arg D Difz).\n\n- : step*/ifz/arg (step*/step (D : step E E')) (step*/step (step/ifz/arg D)).\n- : step*/ifz/arg step*/refl step*/refl.\n- : step*/ifz/arg (step*/trans D* D*') (step*/trans D*ifz D*'ifz)\n     <- step*/ifz/arg D* D*ifz\n     <- step*/ifz/arg D*' D*'ifz.\n\n%worlds () (step*/ifz/arg _ _).\n%total D (step*/ifz/arg D _).\n\nstep*/app/fn : step* E1 E1' -> step* (app E1 E2) (app E1' E2) -> type.\n%mode +{E1:exp} +{E1':exp} +{E2:exp} +{D1:step* E1 E1'}\n    -{Dapp:step* (app E1 E2) (app E1' E2)}\n    (step*/app/fn D1 Dapp).\n\n- : step*/app/fn (step*/step (D1 : step E1 E1'))\n                  (step*/step (step/app/fn D1)).\n- : step*/app/fn step*/refl step*/refl.\n- : step*/app/fn (step*/trans D* D*') (step*/trans D*app D*'app)\n     <- step*/app/fn D* D*app\n     <- step*/app/fn D*' D*'app.\n\n%worlds () (step*/app/fn _ _).\n%total D (step*/app/fn D _).\n\n%{ ==== TASK 1: Fill in the cases of the unfinished compatibility proof ==== }%\n\nstep*/app/arg : step* E2 E2' -> value V1 -> step* (app V1 E2) (app V1 E2')\n                 -> type.\n%mode step*/app/arg +D2 +DvalV1 -Dapp.\n\n%%% fill in here.\n\n%worlds () (step*/app/arg _ _ _).\n%total D (step*/app/arg D _ _).\n\n\n%{\n=== Main theorem === \n\nNow we can prove our first main theorem by induction on the derivation\nof <tt>eval E V</tt> using the multi-step compatibility lemmas above.\n\n==== TASK 2: Fill in the missing cases of the theorem ====\n\n}%\n\neval-multi : eval E V -> step* E V -> type.\n%mode eval-multi +D -D*.\n\n- : eval-multi (eval/z : eval z z) step*/refl.\n\n- : eval-multi (eval/s D : eval (s E) (s V)) D*s\n     <- eval-multi D (D* : step* E V)\n     <- step*/s D* (D*s : step* (s E) (s V)).\n\n- : eval-multi (eval/ifz/z (D0 : eval E0 V0) (Dz : eval E z))\n        (Difz* @ step*/step step/ifz/z @ D0*)\n     <- eval-multi Dz (Dz* : step* E z)\n     <- eval-multi D0 (D0* : step* E0 V0)\n     <- step*/ifz/arg Dz* (Difz* : step* (ifz E E0 [x] E1 x)\n                                         (ifz z E0 [x] E1 x)).\n\n- : eval-multi (eval/ifz/s (D1 : eval (E1 V) V1) (Ds : eval E (s V)))\n        (Difz* @ step*/step (step/ifz/s DvalV) @ D1*)\n     <- eval-multi Ds (Ds* : step* E (s V))\n     <- eval-multi D1 (D1* : step* (E1 V) V1)\n     <- step*/ifz/arg Ds* (Difz* : step* (ifz E E0 [x] E1 x)\n                                         (ifz (s V) E0 [x] E1 x))\n     <- eval-val Ds (value/s (DvalV : value V)).\n\n- : eval-multi \n     eval/fn \n     XXX. %%% fill in here.\n\n- : eval-multi \n     (eval/app (Dsub : eval (E (fn T1 T2 [f] [x] E f x) V2) V)\n        (D2 : eval E2 V2)\n        (D1 : eval E1 (fn T1 T2 [f] [x] E f x)))\n     XXX. %%% fill in here.\n\n%worlds () (eval-multi _ _). \n%total D (eval-multi D _).\n\n\n%{\n\n== Multi-step implies big step ==\n\n=== Left-linearized multi-step ===\n\nFor the reverse direction, it turns out we'd rather have the inductive\ndefinition of the multi-step relation be a little bit different. We call\nthe more convienent direction \"left-linearlized multi-step\" and\nprove it equivlaent to the previous definition of multi-step.\n\n}%\n\nstep** : exp -> exp -> type.            %name step** Dstep**.\n\nstep**/refl : step** E E.\nstep**/cons : step** E E''\n               <- step** E' E''\n               <- step E E'.\n\n%{\n\nLemma: Multi-step implies linearized multi-step.  This is tantamount\nto showing that transitivity is admissible for linearized derivations.\n\n}%\n\nstep**/trans : step** E E' -> step** E' E'' -> step** E E'' -> type.\n%mode step**/trans +D1 +D2 -D3.\n\n- : step**/trans step**/refl (Dstep** : step** E E'') Dstep**.\n- : step**/trans (step**/cons (Dstep1 : step E E1)\n                              (Dstep**1 : step** E1 E'))\n                 (Dstep**2 : step** E' E'')\n        (step**/cons Dstep1 Dstep**)\n     <- step**/trans Dstep**1 Dstep**2 (Dstep** : step** E1 E'').\n\n%worlds () (step**/trans _ _ _).\n%total D (step**/trans D _ _).\n\n%{\n\nLemma: Multi-step implies linearized multi-step.  This is tantamount\nto showing that transitivity is admissible for linearized derivations.\n\n}%\n\nmulti-step** : step* E E' -> step** E E' -> type.\n%mode multi-step** +D* -D**.\n\n- : multi-step** (step*/step Dstep) (step**/cons Dstep step**/refl).\n- : multi-step** step*/refl step**/refl.\n- : multi-step** (step*/trans (D1 : step* E E') (D2 : step* E' E'')) D**\n     <- multi-step** D1 (D1** : step** E E')\n     <- multi-step** D2 (D2** : step** E' E'')\n     <- step**/trans D1** D2** (D** : step** E E'').\n\n%worlds () (multi-step** _ _).\n%total D (multi-step** D _).\n\n\n%{\n\n=== Expansion lemma ===\n\nThe main lemma is that evaluation is closed under single-step expansion.\nThis is a key lemma in the proof that evaluation in the small-step\nsemantics implies evaluation in the big-step evaluation. \n\nWe proceed by induction on the second derivation, the derivation\nthat <tt>step E E'</tt>.\n\n==== TASK 3: Prove the three missing cases of the expansion lemma ====\n\n}%\n\nexpansion : eval E' V -> step E E' -> eval E V -> type.\n%mode expansion +D1 +D2 -D3.\n\n%{ Case <tt>step/s</tt>: }%\n\n- : expansion (eval/s (Deval' : eval E' V) : eval (s E') (s V))\n              (step/s (Dstep  : step E E') : step (s E) (s E'))\n              (eval/s (Deval  : eval E V)  : eval (s E) (s V))\n     <- expansion Deval' Dstep (Deval : eval E V).\n\n%{ Case <tt>step/ifz/arg</tt>: }%\n\n%% By inversion, either eval E' V by eval/ifz/z or by eval/ifz/s.\n- : expansion (eval/ifz/z (D0 : eval E0 V0) (Dz' : eval E' z)\n                  : eval (ifz E' E0 [x] E1 x) V0)\n              (step/ifz/arg (Dstep : step E E')\n                  : step (ifz E E0 [x] E1 x) (ifz E' E0 [x] E1 x))\n              (eval/ifz/z D0 Dz\n                  : eval (ifz E E0 [x] E1 x) V0)\n     <- expansion Dz' Dstep (Dz : eval E z).\n\n- : expansion \n     XXX %%% fill in here.\n     (step/ifz/arg (Dstep : step E E')\n        : step (ifz E E0 [x] E1 x) (ifz E' E0 [x] E1 x))\n     YYY. %%% fill in here.\n\n%{ Case <tt>step/ifz/z</tt>: }%\n\n- : expansion (Deval' : eval E0 V0)\n              (step/ifz/z : step (ifz z E0 [x] E1 x) E0)\n              (eval/ifz/z Deval' eval/z).\n\n%{ Case <tt>step/ifz/s</tt>: }%\n\n- : expansion (Deval' : eval (E1 V) V1)\n              (step/ifz/s (Dval : value V)\n                  : step (ifz (s V) E0 ([x] E1 x)) (E1 V))\n              (eval/ifz/s Deval' (eval/s DevalV))\n     <- val-eval Dval (DevalV : eval V V).\n\n%{ Case <tt>step/app/fn</tt>: }%\n\n- : expansion (eval/app (Dsub : eval (E V2) V)\n                        (D2 : eval E2 V2)\n                        (D1' : eval E1' (fn T1 ([x] E x)))\n                  : eval (app E1' E2) V)\n              (step/app/fn (Dstep1 : step E1 E1')\n                  : step (app E1 E2) (app E1' E2))\n              (eval/app Dsub D2 D1)\n     <- expansion D1' Dstep1 (D1 : eval E1 (fn T1 ([x] E x))).\n\n%{ Case <tt>step/app/arg</tt>: }%\n\n- : expansion \n     XXX %%% fill in here.\n     (step/app/arg (Dstep2 : step E2 E2') (Dval1 : value V1)\n        : step (app V1 E2) (app V1 E2'))\n     YYY. %%% fill in here.\n\n%{ Case <tt>step/app/beta-v</tt>: }%\n\n- : expansion \n     XXX %%% fill in here.\n     (step/app/beta-v (Dval2 : value V2)\n        : step (app (fn T1 T2 [f] [x] E f x) V2)\n           (E (fn T1 T2 [f] [x] E f x) V2))\n     YYY. %%% fill in here.\n\n%worlds () (expansion _ _ _).\n%total D (expansion _ D _).\n\n\n%{\n\n=== Main theorem === \n\nNow we will use our \"more convienent\" left-linearized multi-step definition\nand induct over it in order to prove the forward direction of our primary\ntheorem, that small step evaluation implies big step evaluation.\n\nThe proof is by induction on the derivation that <tt>step** E V</tt>,\nusing closure under single-step expansion. There are only two cases\ndue to the simple definition of <tt>step**</tt>.\n\n==== TASK 4: Prove main theorem in the forward direction ====\n\n}%\n\nmulti**-eval : step** E V -> value V -> eval E V -> type.\n%mode multi**-eval +D1 +D2 -D3.\n\n%%% fill in here.\n\n%worlds () (multi**-eval _ _ _).\n%total D (multi**-eval D _ _).\n\n\n%{\n\n=== Corollary ===\n\nUsing one of the theorems we proved about left-linearized multi-step, \nwe can easly show the final result; our proof needs to have only one case\nand does not use induction.\n\n==== TASK 5: Complete proof by composing previous lemmas ====\n\n}%\n\nmulti-eval : step* E V -> value V -> eval E V -> type.\n%mode multi-eval +D1 +D2 -D3.\n\n%%% fill in here.\n\n%worlds () (multi-eval _ _ _).\n%total {} (multi-eval _ _ _)."
          },
          "sha1": "57vjr27yct4tobbue3ko6jkzaw3dtoc"
        }
      },
      {
        "title": "POPL Tutorial/Big step, small step: Solution",
        "ns": 0,
        "id": 2110,
        "revision": {
          "id": 5823,
          "parentid": 5822,
          "timestamp": "2009-01-18T08:03:46Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 12131,
            "#text": "%{This is the solution to [[POPL Tutorial/Big step, small step | this exercise]].\n|hidden = true}%\n\n%% Syntax %%\n\ntp : type.\t\t\t\t%name tp T.\nnat : tp.\narr : tp -> tp -> tp.\n\nexp : type.\t\t\t\t%name exp E.\nfn : tp -> (exp -> exp) -> exp.\napp : exp -> exp -> exp.\nz : exp.\ns : exp -> exp.\nifz : exp -> exp -> (exp -> exp) -> exp.\n\n%% Small-step dynamic semantics %%\n\nvalue : exp -> type.\t\t\t%name value Dval.\n%mode value +E.\n\nvalue/z : value z.\nvalue/s : value (s E) \n\t   <- value E.\nvalue/fn : value (fn _ _).\n\nstep : exp -> exp -> type.\t\t%name step Dstep.\n%mode step +E1 -E2.\n\nstep/app/fn : step (app E1 E2) (app E1' E2)\n\t       <- step E1 E1'.\nstep/app/arg : step (app E1 E2) (app E1 E2')\n\t\t<- value E1 <- step E2 E2'.\nstep/app/beta : step (app (fn _ ([x] E x)) E2) (E E2)\n\t\t <- value E2.\nstep/s : step (s E) (s E') \n\t  <- step E E'.\nstep/ifz/arg : step (ifz E E1 ([x] E2 x)) (ifz E' E1 ([x] E2 x))\n\t\t<- step E E'.\nstep/ifz/z : step (ifz z E1 ([x] E2 x)) E1.\nstep/ifz/s : step (ifz (s E) E1 ([x] E2 x)) (E2 E)\n\t      <- value E.\n\n%%% Multi-step %%%\n\nstep* : exp -> exp -> type.             %name step* Dstep*.\n\nstep*/step : step* E E'\n              <- step E E'.\nstep*/refl : step* E E.\nstep*/trans : step* E E''\n               <- step* E' E''\n               <- step* E E'.\n\n%abbrev @ : step* E E' -> step* E' E'' -> step* E E''\n          = [d1] [d2] step*/trans d1 d2.\n\n%infix right 10 @.\n\n%% Big-step dynamic semantics %%\n\neval : exp -> exp -> type.              %name eval Deval.\n\neval/z : eval z z.\neval/s : eval (s E) (s V)\n          <- eval E V.\neval/ifz/z : eval (ifz E E0 ([x] E1 x)) V0\n              <- eval E z\n              <- eval E0 V0.\neval/ifz/s : eval (ifz E E0 ([x] E1 x)) V1\n              <- eval E (s V)\n              <- eval (E1 V) V1.\neval/fn : eval (fn T1 ([x] E x)) (fn T1 ([x] E x)).\n\neval/app : eval (app E1 E2) V\n            <- eval E1 (fn T1 ([x] E x))\n            <- eval E2 V2\n            <- eval (E V2) V.\n\n%%% Lemmas about big-step dynamic semantics and values %%%\n\neval-val : eval E V -> value V -> type.\n%mode eval-val +D1 -D2.\n\n- : eval-val eval/z value/z.\n- : eval-val (eval/s D) (value/s Dval)\n     <- eval-val D Dval.\n- : eval-val (eval/ifz/z (D0 : eval E0 V0)\n                         (Dz : eval E z))\n        Dval0\n     <- eval-val D0 (Dval0 : value V0).\n- : eval-val (eval/ifz/s (D1 : eval (E1 V) V1)\n                         (Ds : eval E (s V))\n                : eval (ifz E E0 [x] E1 x) V1)\n        Dval1\n     <- eval-val D1 (Dval1 : value V1).\n- : eval-val eval/fn value/fn.\n- : eval-val (eval/app (Dsub : eval (E V2) V)\n                       (D2 : eval E2 V2)\n                       (D1 : eval E1 (fn T1 ([x] E x))))\n        DvalV\n     <- eval-val Dsub (DvalV : value V).\n\n%worlds () (eval-val _ _).\n%total D (eval-val D _).\n\nval-eval : value V -> eval V V -> type.\n%mode val-eval +Dval -Dev.\n\n- : val-eval value/z eval/z.\n- : val-eval (value/s Dval) (eval/s Dev)\n     <- val-eval Dval Dev.\n- : val-eval value/fn eval/fn.\n\n%worlds () (val-eval _ _).\n%total D (val-eval D _).\n\n%{ == Big-step implies multi-step == }%\n%{ === Compatibility lemmas === |hidden=true}%\n\nstep*/s : step* E E' -> step* (s E) (s E') -> type.\n%mode step*/s +D* -D*s.\n\n- : step*/s (step*/step (D : step E E')) (step*/step (step/s D)).\n- : step*/s (step*/refl : step* E E) (step*/refl : step* (s E) (s E)).\n- : step*/s (step*/trans (D* : step* E E') (D*' : step* E' E''))\n            (step*/trans D*s D*'s)\n     <- step*/s D* (D*s : step* (s E) (s E'))\n     <- step*/s D*' (D*'s : step* (s E') (s E'')).\n\n%worlds () (step*/s _ _).\n%total D (step*/s D _).\n\nstep*/ifz/arg : step* E E' -> step* (ifz E E0 [x] E1 x) (ifz E' E0 [x] E1 x)\n                 -> type.\n%mode +{E:exp} +{E':exp} +{E0:exp} +{E1:exp -> exp} +{D:step* E E'}\n   -{Difz:step* (ifz E E0 ([x:exp] E1 x)) (ifz E' E0 ([x:exp] E1 x))}\n   (step*/ifz/arg D Difz).\n\n- : step*/ifz/arg (step*/step (D : step E E')) (step*/step (step/ifz/arg D)).\n- : step*/ifz/arg step*/refl step*/refl.\n- : step*/ifz/arg (step*/trans D* D*') (step*/trans D*ifz D*'ifz)\n     <- step*/ifz/arg D* D*ifz\n     <- step*/ifz/arg D*' D*'ifz.\n\n%worlds () (step*/ifz/arg _ _).\n%total D (step*/ifz/arg D _).\n\nstep*/app/fn : step* E1 E1' -> step* (app E1 E2) (app E1' E2) -> type.\n%mode +{E1:exp} +{E1':exp} +{E2:exp} +{D1:step* E1 E1'}\n    -{Dapp:step* (app E1 E2) (app E1' E2)}\n    (step*/app/fn D1 Dapp).\n\n- : step*/app/fn (step*/step (D1 : step E1 E1'))\n                  (step*/step (step/app/fn D1)).\n- : step*/app/fn step*/refl step*/refl.\n- : step*/app/fn (step*/trans D* D*') (step*/trans D*app D*'app)\n     <- step*/app/fn D* D*app\n     <- step*/app/fn D*' D*'app.\n\n%worlds () (step*/app/fn _ _).\n%total D (step*/app/fn D _).\n\n%{ ==== TASK 1: Fill in the cases of the unfinished compatibility proof ==== }%\n\nstep*/app/arg : step* E2 E2' -> value V1 -> step* (app V1 E2) (app V1 E2')\n                 -> type.\n%mode step*/app/arg +D2 +DvalV1 -Dapp.\n\n- : step*/app/arg (step*/step (D2 : step E2 E2'))\n                  (DvalV1 : value V1)\n                  (step*/step (step/app/arg D2 DvalV1)).\n- : step*/app/arg step*/refl _ step*/refl.\n- : step*/app/arg (step*/trans D* D*')\n                  (DvalV1 : value V1)\n                  (step*/trans D*app D*'app)\n     <- step*/app/arg D* DvalV1 D*app\n     <- step*/app/arg D*' DvalV1 D*'app.\n\n%worlds () (step*/app/arg _ _ _).\n%total D (step*/app/arg D _ _).\n\n%{|hidden=true}%\n\n%{ === Main theorem === }%\n%{ ==== TASK 2: Fill in the missing cases of the theorem ==== }%\n\neval-multi : eval E V -> step* E V -> type.\n%mode eval-multi +D -D*.\n\n%{|hidden=true}%\n- : eval-multi (eval/z : eval z z) step*/refl.\n\n- : eval-multi (eval/s D : eval (s E) (s V)) D*s\n     <- eval-multi D (D* : step* E V)\n     <- step*/s D* (D*s : step* (s E) (s V)).\n\n- : eval-multi (eval/ifz/z (D0 : eval E0 V0) (Dz : eval E z))\n        (Difz* @ step*/step step/ifz/z @ D0*)\n     <- eval-multi Dz (Dz* : step* E z)\n     <- eval-multi D0 (D0* : step* E0 V0)\n     <- step*/ifz/arg Dz* (Difz* : step* (ifz E E0 [x] E1 x)\n                                         (ifz z E0 [x] E1 x)).\n\n- : eval-multi (eval/ifz/s (D1 : eval (E1 V) V1) (Ds : eval E (s V)))\n        (Difz* @ step*/step (step/ifz/s DvalV) @ D1*)\n     <- eval-multi Ds (Ds* : step* E (s V))\n     <- eval-multi D1 (D1* : step* (E1 V) V1)\n     <- step*/ifz/arg Ds* (Difz* : step* (ifz E E0 [x] E1 x)\n                                         (ifz (s V) E0 [x] E1 x))\n     <- eval-val Ds (value/s (DvalV : value V)).\n\n%{...snip...}%\n\n- : eval-multi \n     eval/fn \n     step*/refl.\n\n- : eval-multi \n     (eval/app (Dsub : eval (E V2) V)\n        (D2 : eval E2 V2)\n        (D1 : eval E1 (fn T1 ([x] E x))))\n        (Dfun* @ Darg* @ step*/step (step/app/beta DvalV2) @ Dsub*)\n     <- eval-multi D1 (D1* : step* E1 (fn T1 ([x] E x)))\n     <- eval-multi D2 (D2* : step* E2 V2)\n     <- eval-multi Dsub (Dsub* : step* (E V2) V)\n     <- step*/app/fn D1* (Dfun* : step* (app E1 E2)\n                                         (app (fn T1 ([x] E x)) E2))\n     <- step*/app/arg D2* value/fn\n                          (Darg* : step* (app (fn T1 ([x] E x)) E2)\n                                         (app (fn T1 ([x] E x)) V2))\n     <- eval-val D2 DvalV2.\n\n%worlds () (eval-multi _ _). \n%total D (eval-multi D _).\n\n\n%{ == Multi-step implies big step == |hidden=true}%\n\nstep** : exp -> exp -> type.            %name step** Dstep**.\n\nstep**/refl : step** E E.\nstep**/cons : step** E E''\n               <- step** E' E''\n               <- step E E'.\n\nstep**/trans : step** E E' -> step** E' E'' -> step** E E'' -> type.\n%mode step**/trans +D1 +D2 -D3.\n\n- : step**/trans step**/refl (Dstep** : step** E E'') Dstep**.\n- : step**/trans (step**/cons (Dstep1 : step E E1)\n                              (Dstep**1 : step** E1 E'))\n                 (Dstep**2 : step** E' E'')\n        (step**/cons Dstep1 Dstep**)\n     <- step**/trans Dstep**1 Dstep**2 (Dstep** : step** E1 E'').\n\n%worlds () (step**/trans _ _ _).\n%total D (step**/trans D _ _).\n\nmulti-step** : step* E E' -> step** E E' -> type.\n%mode multi-step** +D* -D**.\n\n- : multi-step** (step*/step Dstep) (step**/cons Dstep step**/refl).\n- : multi-step** step*/refl step**/refl.\n- : multi-step** (step*/trans (D1 : step* E E') (D2 : step* E' E'')) D**\n     <- multi-step** D1 (D1** : step** E E')\n     <- multi-step** D2 (D2** : step** E' E'')\n     <- step**/trans D1** D2** (D** : step** E E'').\n\n%worlds () (multi-step** _ _).\n%total D (multi-step** D _).\n\n\n%{ === Expansion lemma === }%\n\n%{ ==== TASK 3: Prove the three missing cases of the expansion lemma ==== }%\n\nexpansion : eval E' V -> step E E' -> eval E V -> type.\n%mode expansion +D1 +D2 -D3.\n\n%{|hidden=true}%\n\n- : expansion (eval/s (Deval' : eval E' V) : eval (s E') (s V))\n              (step/s (Dstep  : step E E') : step (s E) (s E'))\n              (eval/s (Deval  : eval E V)  : eval (s E) (s V))\n     <- expansion Deval' Dstep (Deval : eval E V).\n\n- : expansion (eval/ifz/z (D0 : eval E0 V0) (Dz' : eval E' z)\n                  : eval (ifz E' E0 [x] E1 x) V0)\n              (step/ifz/arg (Dstep : step E E')\n                  : step (ifz E E0 [x] E1 x) (ifz E' E0 [x] E1 x))\n              (eval/ifz/z D0 Dz\n                  : eval (ifz E E0 [x] E1 x) V0)\n     <- expansion Dz' Dstep (Dz : eval E z).\n\n%{...snip...}%\n\n- : expansion\n     (eval/ifz/s (D1 : eval (E1 V) V1) (Ds' : eval E' (s V))\n        : eval (ifz E' E0 [x] E1 x) V1)\n     (step/ifz/arg (Dstep : step E E')\n        : step (ifz E E0 [x] E1 x) (ifz E' E0 [x] E1 x))\n     (eval/ifz/s D1 Ds\n        : eval (ifz E E0 [x] E1 x) V1)\n     <- expansion Ds' Dstep (Ds : eval E (s V)).\n\n%{|hidden=true}%\n\n- : expansion (Deval' : eval E0 V0)\n              (step/ifz/z : step (ifz z E0 [x] E1 x) E0)\n              (eval/ifz/z Deval' eval/z).\n\n- : expansion\n     (Deval' : eval (E1 V) V1)\n     (step/ifz/s (Dval : value V)\n        : step (ifz (s V) E0 ([x] E1 x)) (E1 V))\n     (eval/ifz/s Deval' (eval/s DevalV))\n     <- val-eval Dval (DevalV : eval V V).\n\n- : expansion (Deval' : eval (E1 V) V1)\n              (step/ifz/s (Dval : value V)\n                  : step (ifz (s V) E0 ([x] E1 x)) (E1 V))\n              (eval/ifz/s Deval' (eval/s DevalV))\n     <- val-eval Dval (DevalV : eval V V).\n\n- : expansion (eval/app (Dsub : eval (E V2) V)\n                        (D2 : eval E2 V2)\n                        (D1' : eval E1' (fn T1 ([x] E x)))\n                  : eval (app E1' E2) V)\n              (step/app/fn (Dstep1 : step E1 E1')\n                  : step (app E1 E2) (app E1' E2))\n              (eval/app Dsub D2 D1)\n     <- expansion D1' Dstep1 (D1 : eval E1 (fn T1 ([x] E x))).\n\n%{...snip...}%\n\n- : expansion \n     (eval/app (Dsub : eval (E V2) V)\n        (D2' : eval E2' V2)\n        (D1 : eval V1 (fn T1 ([x] E x)))\n        : eval (app V1 E2') V)\n     (step/app/arg (Dstep2 : step E2 E2') (Dval1 : value V1)\n        : step (app V1 E2) (app V1 E2'))\n     (eval/app Dsub D2 D1)\n     <- expansion D2' Dstep2 (D2 : eval E2 V2).\n\n- : expansion \n     (Deval' : eval (E V2) V)\n     (step/app/beta (Dval2 : value V2)\n        : step (app (fn T1 ([x] E x)) V2) (E V2))\n     (eval/app Deval' DevalV2 eval/fn)\n     <- val-eval Dval2 (DevalV2 : eval V2 V2).\n\n%worlds () (expansion _ _ _).\n%total D (expansion _ D _).\n\n\n%{ === Main theorem === }%\n\n%{ ==== TASK 4: Prove main theorem in the forward direction ==== }%\n\nmulti**-eval : step** E V -> value V -> eval E V -> type.\n%mode multi**-eval +D1 +D2 -D3.\n\n- : multi**-eval step**/refl (Dval : value V) Deval\n     <- val-eval Dval (Deval : eval V V).\n\n- : multi**-eval (step**/cons (Dstep : step E E') (Dstep** : step** E' V))\n                 (Dval : value V)\n                 Deval\n     <- multi**-eval Dstep** Dval (Deval' : eval E' V)\n     <- expansion Deval' Dstep (Deval : eval E V).\n\n%worlds () (multi**-eval _ _ _).\n%total D (multi**-eval D _ _).\n\n%{ ==== TASK 5: Complete proof by composing previous lemmas ==== }%\n\nmulti-eval : step* E V -> value V -> eval E V -> type.\n%mode multi-eval +D1 +D2 -D3.\n\n- : multi-eval (D* : step* E V) (Dval : value V) Dev\n     <- multi-step** D* (D** : step** E V)\n     <- multi**-eval D** Dval (Dev : eval E V).\n\n%worlds () (multi-eval _ _ _).\n%total {} (multi-eval _ _ _)."
          },
          "sha1": "3249pq4y9p10rswrjokai63ynlm0km0"
        }
      },
      {
        "title": "POPL Tutorial/CPS",
        "ns": 0,
        "id": 2093,
        "revision": {
          "id": 5447,
          "timestamp": "2008-11-17T19:48:33Z",
          "contributor": {
            "ip": "128.2.216.188"
          },
          "comment": "Intrinsic encoding of CPS conversion based on the CPS conversion and Double-negation translation tutorials.",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 4441,
            "#text": "== CPS Conversion ==\n\n\n<twelf>\n\n%% Intuitionistic logic\n\niprop : type.                     %name iprop A'.\n\nitop : iprop.\niimp : iprop -> iprop -> iprop.\n\n%block ipb : block {X : iprop}.\n%worlds (ipb) (iprop).\n\nitrue : iprop -> type.\n\nimt : itrue itop.\nilam : (itrue A -> itrue B) -> itrue (iimp A B).\niapp : itrue (iimp A B) -> itrue A -> itrue B.\n\n%block itb : some {A : iprop} block {D : itrue A}.\n%worlds (ipb | itb) (itrue _).\n\n%% Classical logic\n\nprop : type.                     %name prop A.\n\ntop : prop.\nand : prop -> prop -> prop.\nnot : prop -> prop.\n\n%block pb : block {X : prop}.\n%worlds (pb) (prop).\n\nconc : type.\ntrue : prop -> conc. %prefix 2 true.\ncontra : conc.\n\n>> : conc -> type. %prefix 3 >>.\n\nmt : >> true top.\npair : >> true A -> >> true B -> >> true (and A B).\nfst : >> true (and A B) -> >> true A.\nsnd : >> true (and A B) -> >> true B.\nnoti    : (>> true A -> >> contra) -> >> true (not A).\nnotcase : >> true (not A) -> ((>> true A -> >> contra) -> >> J) -> >> J.\n\nletcc : ((>> true A -> >> contra) -> >> contra) -> >> true A.\n\n%block tb : some {A : prop} block {D : >> true A}.\n%block fb : some {A : prop} block {D : (>> true A -> >> contra)}.\n%worlds (pb | tb | fb) (>> _).\n\n%% Proposition translation\n\n* : iprop -> prop -> type.\n%mode * +A' -A.\n\n*/top : * itop top.\n\n*/imp : * (iimp A1' A2') (not (and A1 (not A2)))\n         <- * A1' A1\n         <- * A2' A2.\n\n%worlds () (* _ _).\n%total D (* D _).\n\n%% Lemmas\n\neqprop : prop -> prop -> type.\neqprop_ : eqprop A A.\n\neqprop/and : eqprop A1 A2 -> eqprop A3 A4 -> eqprop (and A1 A3) (and A2 A4) -> type.\n%mode eqprop/and +A +B -C.\n- : eqprop/and eqprop_ eqprop_ eqprop_.\n\neqprop/not : eqprop A1 A2 -> eqprop (not A1) (not A2) -> type.\n\n%mode eqprop/not +A -B.\n- : eqprop/not eqprop_ eqprop_.\n\ntrue_resp : >> true A -> eqprop A A' -> >> true A' -> type.\n%mode true_resp +Dtrue +EQ -Dtrue'.\n- : true_resp D eqprop_ D.\n\n*_fun : * A' A1 -> * A' A2 -> eqprop A1 A2 -> type.\n%mode *_fun +X +Y -Z.\n\n- : *_fun */top */top eqprop_.\n\n- : *_fun (*/imp (DB1:* B' B1) (DA1:* A' A1)) (*/imp (DB2:* B' B2) (DA2:* A' A2))\n     (EQ:eqprop (not (and A1 (not B1))) (not (and A2 (not B2))))\n     <- *_fun DA1 DA2 (EQA:eqprop A1 A2)\n     <- *_fun DB1 DB2 (EQB:eqprop B1 B2)\n     <- eqprop/not EQB (EQnotB:eqprop (not B1) (not B2))\n     <- eqprop/and EQA EQnotB (EQand:eqprop (and A1 (not B1)) (and A2 (not B2)))\n     <- eqprop/not EQand EQ.\n\n*_gimme : {A1':iprop} {A1:prop} * A1' A1 -> type.\n%mode *_gimme +A1' -A1 -DA1.\n\n- : *_gimme itop top */top.\n\n- : *_gimme (iimp A1' A2') (not (and A1 (not A2))) (*/imp DA2 DA1)\n     <- *_gimme A1' A1 (DA1:* A1' A1)\n     <- *_gimme A2' A2 (DA2:* A2' A2).\n\n%worlds () (*_fun _ _ _) (eqprop/and _ _ _) (eqprop/not _ _).\n\n%total D (eqprop/and D _ _).\n%total D (eqprop/not D _).\n%total D (*_fun D _ _).\n\n%% CPS conversion\n\ntocps : {Ditrue : itrue A'}\n        {DA : * A' A}\n        {Dtrue : >> true A}\n        type.\n%mode tocps +Ditrue -DA -Dtrue.\n\ncps/top : tocps imt */top mt.\n\ncps/lam : tocps (ilam (Ditrue : itrue A1' -> itrue A2'))\n           (*/imp (DA2 : * A2' A2) (DA1 : * A1' A1))\n           (noti ([Dtruep : >> true (and A1 (not A2))]\n                    notcase (snd Dtruep) ([Dfalse : >> true A2 -> >> contra]\n                                            Dfalse (Dtrue (fst Dtruep)))))\n           <- *_gimme A1' A1 DA1\n           <- ({Ditrue1 : itrue A1'}\n                 {Dtrue1 : >> true A1}\n                 {thm:tocps Ditrue1 DA1 Dtrue1}\n                 tocps (Ditrue Ditrue1) DA2 (Dtrue Dtrue1)).\n\ncps/app : tocps (iapp (Ditrue:itrue (iimp A1' A2')) (Ditrue1:itrue A1'))\n           DA2\n           (letcc [Ddn:>> true A2 -> >> contra]\n              (notcase Dtrue ([Dfalse:>> true (and A1 (not A2)) -> >> contra]\n                                Dfalse (pair Dtrue1 (noti Ddn)))))\n           <- tocps Ditrue (*/imp DA2 DA1) (Dtrue:>> true (not (and A1 (not A2))))\n           <- tocps Ditrue1 (DA10:* A1' A10) (Dtrue1':>> true A10)\n           <- *_fun DA10 DA1 EQ\n           <- true_resp Dtrue1' EQ (Dtrue1:>> true A1).\n\n%block blocktrue :\n              some {A' : iprop} {A : prop} {DA : * A' A}\n              block\n               {Ditrue : itrue A'}\n               {Dtrue : >> true A}\n               {thm:tocps Ditrue DA Dtrue}.\n\n%worlds (blocktrue)\n                 (tocps _ _ _)\n                 (true_resp _ _ _)\n                 (*_gimme _ _ _).\n\n%total A (true_resp _ A _).\n%total A (*_gimme A _ _).\n\n%total A (tocps A _ _).\n</twelf>"
          },
          "sha1": "ka162jthvaxa334z5mpxp5ib4zxxj1m"
        }
      },
      {
        "title": "POPL Tutorial/CPS Solution2",
        "ns": 0,
        "id": 2121,
        "revision": {
          "id": 5577,
          "timestamp": "2008-11-21T19:25:54Z",
          "contributor": {
            "ip": "128.2.216.188"
          },
          "comment": "New page: %{ == Problem 2: Elimination of Administrative Redices ==  }% tp : type. o : tp. => : tp -> tp -> tp.           %infix right 3 =>.  exp   : tp -> type. value : tp -> type. app   : exp (A =...",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 1711,
            "#text": "%{\n== Problem 2: Elimination of Administrative Redices ==\n\n}%\ntp : type.\no : tp.\n=> : tp -> tp -> tp.           %infix right 3 =>.\n\nexp   : tp -> type.\nvalue : tp -> type.\napp   : exp (A => B) -> exp A -> exp B.\nlam   : (value A -> exp B) -> value (A => B).\nret   : value A -> exp A.\n%block sourceb : some {A : tp} block {x : value A}.\n%worlds (sourceb) (exp _) (value _).\n\ncontra : type.\ncvalue : tp -> type.\ncapp   : cvalue (A => B) -> cvalue A -> (cvalue B -> contra) -> contra.\nclam   : (cvalue A -> (cvalue B -> contra) -> contra) -> cvalue (A => B).\n%block targetb1 : some {A : tp} block {x : cvalue A}.\n%block targetb2 : some {A : tp} block {y : cvalue A -> contra}.\n%worlds (targetb1 | targetb2) (contra) (cvalue _).\n\ncps : value A -> cvalue A -> type.\n%mode cps +X1 -X2.\n\ncpse : exp A -> ((cvalue A -> contra) -> contra) -> type.\n%mode cpse +X1 -X2.\n\ncps/lam : cps (lam (E : value A -> exp B))\n              (clam (E' : cvalue A -> (cvalue B -> contra) -> contra))\n              <- ({x:value A}{x':cvalue A} cps x x' -> cpse (E x) (E' x')).\ncpse/app : cpse (app (E1:exp (B => A)) (E2:exp B))\n                ([c : (cvalue A -> contra)] E1' ([f:cvalue (B => A)]\n                                                   E2' ([x:cvalue B]\n                                                          capp f x c)))\n                <- cpse E1 (E1':(cvalue (B => A) -> contra) -> contra)\n                <- cpse E2 (E2':(cvalue B -> contra) -> contra).\ncpse/ret : cpse (ret (V:value A)) ([c:(cvalue A -> contra)] c V')\n                <- cps V (V':cvalue A).\n\n%block cpsb : some {A : tp} block {x : value A} {x' : cvalue A} {d : cps x x'}.\n%worlds (cpsb) (cps _ _) (cpse _ _).\n%total (E V) (cps E _) (cpse V _).\n%{\n}%"
          },
          "sha1": "966hfwdpywsgc6b16ttvopnxkaoa98l"
        }
      },
      {
        "title": "POPL Tutorial/CPS Solutions",
        "ns": 0,
        "id": 2114,
        "revision": {
          "id": 5578,
          "parentid": 5530,
          "timestamp": "2008-11-21T19:27:13Z",
          "contributor": {
            "ip": "128.2.216.188"
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 1793,
            "#text": "%{\n\n== Problem 1: CPS Conversion with Administrative Redices ==\n\n}%\ntp : type.\no  : tp.\n=> : tp -> tp -> tp.           %infix right 3 =>.\n\nexp   : tp -> type.\nvalue : tp -> type.\napp   : exp (A => B) -> exp A -> exp B.\nlam   : (value A -> exp B) -> value (A => B).\nret   : value A -> exp A.\n%block sourceb : some {A : tp} block {x : value A}.\n%worlds (sourceb) (exp _) (value _).\n\ncontra : type.\ncvalue : tp -> type.\nccont  : tp -> type.\ncapp   : cvalue (A => B) -> cvalue A -> ccont B -> contra.\nclam   : (cvalue A -> ccont B -> contra) -> cvalue (A => B).\ncconti : (cvalue A -> contra) -> ccont A.\ncthrow : ccont A -> cvalue A -> contra.\n%block targetb1 : some {A : tp} block {x : cvalue A}.\n%block targetb2 : some {A : tp} block {x : ccont A}.\n%worlds (targetb1 | targetb2) (contra) (cvalue _) (ccont _).\n\ncps : value A -> cvalue A -> type.\n%mode cps +X1 -X2.\n\ncpse : exp A -> (ccont A -> contra) -> type.\n%mode cpse +X1 -X2.\n\ncps/lam : cps (lam (E:value A -> exp B))\n              (clam (E':cvalue A -> ccont B -> contra))\n           <- ({x:value A}{x':cvalue A} cps x x' -> cpse (E x) (E' x')).\ncpse/app : cpse (app (E1:exp (B => A)) (E2:exp B))\n                ([c:ccont A] E1' (cconti ([f:cvalue (B => A)]\n                                            E2' (cconti([x:cvalue B]\n                                                          capp f x c)))))\n            <- cpse E1 (E1':ccont (B => A) -> contra)\n            <- cpse E2 (E2':ccont B -> contra).\ncpse/ret : cpse (ret (V:value A)) ([c:ccont A] cthrow c V')\n            <- cps V (V':cvalue A).\n\n%block cpsb : some {A : tp} block {x : value A} {x' : cvalue A} {d : cps x x'}.\n%worlds (cpsb) (cps _ _) (cpse _ _).\n%total (E V) (cps E _) (cpse V _).\n\n%{\nSee [[POPL Tutorial/CPS_Solution2]] for the solution to the second CPS problem.\n}%"
          },
          "sha1": "me9bbpp1rynh7em6lq5wi4n2d2adw7t"
        }
      },
      {
        "title": "POPL Tutorial/Church Rosser",
        "ns": 0,
        "id": 2138,
        "redirect": {
          "@title": "Church-Rosser (w/ identity reduction)",
          "#text": null
        },
        "revision": {
          "id": 5684,
          "timestamp": "2008-11-22T23:06:20Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "[[POPL Tutorial/Church Rosser]] moved to [[Church-Rosser (w/ identity reduction)]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 51,
            "#text": "#REDIRECT [[Church-Rosser (w/ identity reduction)]]"
          },
          "sha1": "gxyl7hlphcxods588t6scxwd67u0h2t"
        }
      },
      {
        "title": "POPL Tutorial/Church Rosser (Problem)",
        "ns": 0,
        "id": 2124,
        "revision": {
          "id": 5615,
          "timestamp": "2008-11-21T21:28:55Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "New page: %{  In this exercise, we will prove the [[w:Church-Rosser theorem|]]. You are  provided with a syntax and two substitution lemmas, and your task will be to implement two cases of the diamo...",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 11492,
            "#text": "%{\n\nIn this exercise, we will prove the [[w:Church-Rosser theorem|Church-Rosser theorem]]. You are \nprovided with a syntax and two substitution lemmas, and your task will be\nto implement two cases of the diamond lemma - the \n'''Application-Application''' case, and the '''Beta-Application''' case. \n\nYou will be able to uncomment the <tt>%total</tt> at the end when you are \ndone.\n\nThe solution is [[POPL Tutorial/Church Rosser|here]].\n\n}%\n\n%{ == Syntax == }%\n\nexp : type.  %name exp E.\nlam : (exp -> exp) -> exp.\napp : exp -> exp -> exp.\n\n%{ \n\nWhen we use this <tt>%block</tt>, it expresses that we can be working in a \ncontext with arbitrary expression variables. This will be the only world we \nwill need for this exercise. \n\n}%\n\n%block exps : block {x: exp}.\n\n\n%{ == Reduction == }%\n%{ \n\nWe can always reduce an expression to itself (which means that we don't \nexplicitly need a case to handle variables). We can reduce under binders and \nreduce both sides of an application \"in parallel.\" If we have a β-redex \n<tt>(λx.ea) eb</tt>, then after reducing <tt>ea</tt> (with <tt>x</tt> free) to \n<tt>ea'</tt> (with <tt>x</tt> free) and reducing <tt>eb</tt> to <tt>eb'</tt>,\nwe can return <tt>[eb'/x]ea'</tt>, the substitution of <tt>eb'</tt> into\n<tt>ea'</tt>.\n\nThe <tt>%worlds</tt> explicitly states that we will be reducing in a setting \nwith free variables. \n\n}%\n\nreduce : exp -> exp -> type.\n\nreduce/id : reduce E E.\n\nreduce/lam : reduce (lam E) (lam E')\n              <- ({x:exp} reduce (E x) (E' x)).\n\nreduce/app : reduce (app E1 E2) (app E1' E2')\n              <- reduce E1 E1'\n              <- reduce E2 E2'.\n\nreduce/beta : reduce (app (lam E1) E2) (E1' E2')\n              <- ({x:exp} reduce (E1 x) (E1' x))\n              <- reduce E2 E2'.\n\n%worlds (exps) (reduce _ _).\n\n%{ == Substitution == }%\n%{ \n\nThe first substitution theorem says that if we have a term <tt>e1</tt> with \n<tt>x</tt> free and a term <tt>e2</tt> that reduces to term <tt>e2'</tt>, \nthen <tt>[e2/x]e1</tt> reduces to <tt>[e2'/x]e1</tt>. \n\nThe interesting cases are really the first two - if the term is just the free \nvariable being substituted for, the result follows from the hypothesis. In the \ncase that the free variable is ''not'' free (i.e. the term has no hole), then \nthe result follows from the reflexivity of reduction. This is more than \nsufficient to handle the case of a variable that is not the distinguished free \nvariable, and all other cases are covered.\n\nThe proof is by induction on the structure of the term with the free variable.\n\n}%\n\nsubstitute1 : {E1:exp -> exp} reduce E2 E2' -> reduce (E1 E2) (E1 E2') -> type.\n%mode substitute1 +X1 +X2 -X3.\n\n- : substitute1 ([x] x) D D.\n\n- : substitute1 ([x] E) _ reduce/id.\n\n- : substitute1 ([x] lam ([y] E x y)) D (reduce/lam D')\n     <- ({y} substitute1 ([x] E x y) D (D' y)).\n\n- : substitute1 ([x] app (E1 x) (E2 x)) D (reduce/app D2 D1)\n     <- substitute1 E1 D D1\n     <- substitute1 E2 D D2.\n\n%worlds (exps) (substitute1 _ _ _).\n%total E (substitute1 E _ _).\n\n%{ \n\nThe second substitution theorem is similar, except that we are reducing \n<tt>e1</tt> with <tt>x</tt> free to <tt>e1'</tt> as well as by reducing\n<tt>e2</tt> to <tt>e2'</tt>, showing that <tt>[e2/x]e1</tt> reduces to\n<tt>[e2'/x]e1'</tt>.\n\nProof is by induction on the structure of the reduction of <tt>e1</tt> to \n<tt>e1'</tt>. We call to the <tt>substitute1</tt> lemma \nwhen we \"bottom out\" at the reflexive case <tt>reduce/id</tt>.\n\n}%\n\nsubstitute2 \n   : ({x:exp} reduce (E1 x) (E1' x)) \n      -> reduce E2 E2' \n      -> reduce (E1 E2) (E1' E2') \n      -> type.\n%mode substitute2 +X1 +X2 -X3.\n\n- : substitute2 ([x] reduce/id : reduce (E x) (E x)) D D'\n     <- substitute1 E D D'.\n\n- : substitute2 ([x] reduce/lam ([y] D1 x y)) D2 (reduce/lam D)\n     <- ({y} substitute2 ([x] D1 x y) D2 (D y)).\n\n- : substitute2 ([x] reduce/app (D2 x) (D1 x)) D (reduce/app D2' D1')\n     <- substitute2 D1 D D1'\n     <- substitute2 D2 D D2'.\n\n- : substitute2 ([x] reduce/beta (D2 x) ([y] D1 x y)) D (reduce/beta D2' D1')\n     <- ({y} substitute2 ([x] D1 x y) D (D1' y))\n     <- substitute2 D2 D D2'.\n\n%worlds (exps) (substitute2 _ _ _).\n%total D (substitute2 D _ _).\n\n%{ == The Diamond Property == }%\n%{\n\nNow we come to the interesting part: the diamond property.\n\n    E\n   / \\\n  /   \\\n E1   E2\n  \\   /\n   \\ /\n    E'\n\nIf <tt>E</tt> reduces to both <tt>E1</tt>, and <tt>E2</tt>, then there is a \ncommon E' such that <tt>E1</tt> and <tt>E2</tt> both reduce to it.\n\n}%\n\ndiamond : reduce E E1 -> reduce E E2 -> reduce E1 E' -> reduce E2 E' -> type.\n%mode diamond +X1 +X2 -X3 -X4.\n\n%{ === Identity === }%\n%{ \n\nIf either case is the identity, then we are done. \n\n id:    E  D:       D:     E  id:\n e=>e  / \\ e=>e2    e=>e1 / \\ e=>e\n      /   \\              /   \\\n     E    E2            E1    E\n D:   \\   /id:      id:  \\   /D:\n e=>e2 \\ / e2=>e2   e1=>e1\\ / e=>e1\n        e2                 E1\n\n}%\n\n- : diamond reduce/id D D reduce/id.\n- : diamond D reduce/id reduce/id D.\n\n%{ === Lambda-Lambda === }%\n%{ \n\nIf both cases are reductions under a binder, we pull the result straight \nfrom the induction hypothesis. \n\n             λx.e              by induction:\n reduce/lam   / \\  reduce/lam    D1, D2 ---> D1': e1'=>e'\n (D1: e=>e1) /   \\ (D2: e=>e2)               D2': e2'=>e'\n            /     \\\n         λx.e1   λx.e2\n            \\     /\n reduce/lam  \\   / reduce/lam\n D1'          \\ /  D2'\n             λx.e' \n\nNote the oversimplification being made in the graphical presentation, in that\nthe subterms and sub-derivations are not clearly shown to have a free variable.\nTwelf will, of course, not allow this sloppiness.\n\n}%\n\n- : diamond \n     (reduce/lam (D1 : {x: exp} reduce (E x) (E1 x))\n        : reduce (lam E) (lam E1))\n     (reduce/lam (D2 : {x: exp} reduce (E x) (E2 x))\n        : reduce (lam E) (lam E2))\n     (reduce/lam D1') (reduce/lam D2')\n     <- ({x: exp} diamond (D1 x) (D2 x) \n          (D1' x : reduce (E1 x) (E' x))\n          (D2' x : reduce (E2 x) (E' x))).\n\n%{ === Application-Application === }%\n%{\n\nIf both cases are applications, we pull the result straight from the \ninduction hypothesis. \n\n                  ea eb                by induction\n reduce/app       /   \\   reduce/app     D1a, D2a ---> D1a': e1a=>ea'\n (D1b: eb=>e1b)  /     \\  (D2b: eb=>e2b)               D2a': e2a=>ea'\n (D1a: ea=>e1a) /       \\ (D2a: ea=>e2a) D1b, D2b ---> D1b': e1b=>eb' \n            e1a e1b   e2a e2b                          D2b': e2b=>eb'\n                \\       /\n reduce/app      \\     /  reduce/app\n D1b' D1a'        \\   /   D2b' D2a'\n                 ea' eb'\n}%\n\n%% WRITE THIS CASE\n\n%{ === Beta-Beta === }%\n%{\n\nIf both cases are beta reductions, we get the result from performing two \nsubstitutions. \n\n               (λx.ea) eb            by induction\n reduce/beta      / \\   reduce/beta    D1a, D2a ---> D1a': e1a=>ea'\n (D1b: eb=>e1b)  /   \\  (D2b: eb=>e2b)               D2a': e2a=>ea'\n (D1a: ea=>e1a) /     \\ (D2a: ea=>e1a) D1b, D2b ---> D1b': e1b=>eb'\n         [e1b/x]e1a  [e2b/x]e2a                      D2b': e2b=>eb'\n                \\     /\n substitute      \\   /  substitute\n D1b' into D1a'   \\ /   D2b' into D2a'\n              [eb'/x]ea\n}% \n\n- : diamond \n     (reduce/beta \n          (D1b : reduce Eb E1b)\n          (D1a : {x} reduce (Ea x) (E1a x))\n        : reduce (app (lam Ea) Eb) (E1a E1b))\n     (reduce/beta\n          (D2b : reduce Eb E2b)\n          (D2a : {x} reduce (Ea x) (E2a x))\n        : reduce (app (lam Ea) Eb) (E2a E2b))\n     D1 D2\n     <- ({x} diamond (D1a x) (D2a x)\n          (D1a' x : reduce (E1a x) (Ea' x))\n          (D2a' x : reduce (E2a x) (Ea' x)))\n     <- diamond D1b D2b\n          (D1b'   : reduce E1b Eb')\n          (D2b'   : reduce E2b Eb')\n     <- substitute2 D1a' D1b' \n          (D1     : reduce (E1a E1b) (Ea' Eb'))\n     <- substitute2 D2a' D2b'\n          (D2     : reduce (E2a E2b) (Ea' Eb')).\n\n%{ === Beta-Application === }%\n%{\n\nIf the left-hand side is a β-reduction \n<tt>(λx.ea) eb => [e1b/x] e1a</tt> but the right-hand side is not, then we \nknow that the right-hand side reduction must be \n<tt>(λx.ea) eb => (λx.e2a) e2b</tt>.\n\nUnfortunately, then we have two options - either <tt>λx.ea => λx.e2a</tt> by\n<tt>reduce/refl</tt> and <tt>reduce/lam</tt>. The <tt>reduce/refl</tt> case\nis essentially just an inconvenience caused by allowing identity reductions\nanywhere (not just at variables).\n\nThe first subcase:\n\n              (λx.ea) eb              by induction  \n reduce/beta      / \\   reduce/app      D1a, D2a ---> D1a': e1a=>ea'\n (D1b: eb=>e1b)  /   \\  (D2b: eb=>e2b)                D2a': e2a=>ea'\n (D1a: ea=>e1a) /     \\ (reduce/lam     D1b, D2b ---> D1b': e1b=>eb'\n               /       \\  (D2a: ea=>e2a))             D2b': e1b=>eb'\n        [e1b/x]e1a  (λx.e2a) e2b\n               \\       /\n substitute     \\     / reduce/beta     \n D1b' into D2a'  \\   /  D2b' D2a'      \n                  \\ /   \n               [eb'/x]ea'              \n}%\n\n%% WRITE THIS CASE\n\n%{\n\nThe second subcase:\n\n              (λx.ea) eb              by induction  \n reduce/beta      / \\   reduce/app      D1b, D2b ---> D1b': e1b=>eb'\n (D1b: eb=>e1b)  /   \\  (D2b: eb=>e2b)                D2b': e1b=>eb'\n (D1a: ea=>e1a) /     \\ (reduce/id      \n               /       \\   ea=>ea))     \n        [e1b/x]e1a   (λx.ea) e2b\n               \\       /\n substitute     \\     / reduce/beta     \n D1b' into e1a   \\   /  D2b' D1a   \n                  \\ /   \n               [eb'/x]e1a        \n}%\n\n- : diamond\n     (reduce/beta \n          (D1b : reduce Eb E1b) \n          (D1a : {x} reduce (Ea x) (E1a x))\n        : reduce (app (lam Ea) Eb) (E1a E1b))\n     (reduce/app \n          (D2b : reduce Eb E2b) \n          (reduce/id : reduce (lam Ea) (lam Ea))\n        : reduce (app (lam Ea) Eb) (app (lam Ea) E2b))\n     D1 (reduce/beta D2b' D1a) \n     <- diamond D1b D2b\n          (D1b'   : reduce E1b Eb')\n          (D2b'   : reduce E2b Eb')\n     <- substitute1 E1a D1b' \n          (D1     : reduce (E1a E1b) (E1a Eb')).\n\n\n%{ === Application-Beta === }%\n%{ \n\nIf the right-hand hand side is a β-reduction but the left-hand side is not, we \nhave to do the same two cases in reverse; we omit the graphics for those \ntwo cases as they are symmetric.\n\n}% \n\n- : diamond\n     (reduce/app \n          (D1b : reduce Eb E1b) \n          (reduce/id : reduce (lam Ea) (lam Ea))\n        : reduce (app (lam Ea) Eb) (app (lam Ea) E1b))\n     (reduce/beta \n          (D2b : reduce Eb E2b) \n          (D2a : {x} reduce (Ea x) (E2a x))\n        : reduce (app (lam Ea) Eb) (E2a E2b))\n     (reduce/beta D1b' D2a) D2\n     <- diamond D1b D2b\n          (D1b'   : reduce E1b Eb')\n          (D2b'   : reduce E2b Eb')\n     <- substitute1 E2a D2b' \n          (D2     : reduce (E2a E2b) (E2a Eb')).\n\n- : diamond\n     (reduce/app\n          (D1b : reduce Eb E1b)\n          (reduce/lam (D1a : {x} reduce (Ea x) (E1a x)))\n        : reduce (app (lam Ea) Eb) (app (lam E1a) E1b))\n     (reduce/beta \n          (D2b : reduce Eb E2b)\n          (D2a : {x} reduce (Ea x) (E2a x))\n        : reduce (app (lam Ea) Eb) (E2a E2b))\n     (reduce/beta D1b' D1a') D2\n     <- ({x} diamond (D1a x) (D2a x)\n          (D1a' x : reduce (E1a x) (Ea' x))\n          (D2a' x : reduce (E2a x) (Ea' x)))\n     <- diamond D1b D2b\n          (D1b'   : reduce E1b Eb')\n          (D2b'   : reduce E2b Eb')\n     <- substitute2 D2a' D2b' \n          (D2     : reduce (E2a E2b) (Ea' Eb')).\n\n%{ Now we are done! We check in the <tt>exps</tt> world with free variables.}%\n\n%worlds (exps) (diamond _ _ _ _).\n%% %total D1 (diamond D1 D2 _ _)."
          },
          "sha1": "hvzcgszl25ah3i60ecxnbuwr9y0mtoh"
        }
      },
      {
        "title": "POPL Tutorial/Combinators",
        "ns": 0,
        "id": 2157,
        "revision": {
          "id": 5796,
          "parentid": 5780,
          "timestamp": "2009-01-18T06:15:26Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 126,
            "#text": "* [[POPL Tutorial/Combinators Support|Support code]]\n* [[POPL Tutorial/Combinators Answer|Solutions to interactive exercises]]"
          },
          "sha1": "m27lltzyh2dj6bt072hcm4fqed0qltg"
        }
      },
      {
        "title": "POPL Tutorial/Combinators (karl)",
        "ns": 0,
        "id": 2107,
        "revision": {
          "id": 5760,
          "parentid": 5501,
          "timestamp": "2009-01-17T03:24:03Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "minor": null,
          "comment": "[[POPL Tutorial/Combinators]] moved to [[POPL Tutorial/Combinators (karl)]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 8057,
            "#text": "%{  == Lambda Terms ==  }%\n\nexp : type.  %name exp E.\n\nlam : (exp -> exp) -> exp.\napp : exp -> exp -> exp.\n\n\n\n\n%{  == Reduction ==  }%\n\nreduce : exp -> exp -> type.\n\nreduce/refl\t: reduce E E.\n\nreduce/trans\t: reduce E1 E3\n\t\t   <- reduce E1 E2\n\t\t   <- reduce E2 E3.\n\nreduce/lam\t: reduce (lam ([x] E x)) (lam ([x] E' x))\n\t\t   <- ({x} reduce (E x) (E' x)).\n\nreduce/app\t: reduce (app E1 E2) (app E1' E2')\n\t\t   <- reduce E1 E1'\n\t\t   <- reduce E2 E2'.\n\nreduce/beta\t: reduce (app (lam ([x] E1 x)) E2) (E1 E2).\n\n\n\n\n\n%{  == Combinators ==  }%\n\ns : exp = lam ([a] lam ([b] lam ([x] app (app a x) (app b x)))).\n\nk : exp = lam ([x] lam ([y] x)).\n\ni : exp = lam ([x] x).\n\n\n\n\n%{ == Bracket Abstraction ==  }%\n\nabstract : (exp -> exp) -> exp -> type.\n%mode abstract +E -E'.\n\nabstract/var\t: abstract ([x] x) i.\n\nabstract/closed\t: abstract ([x] E) (app k E).\n\nabstract/app\t: abstract ([x] app (E1 x) (E2 x)) (app (app s E1') E2')\n\t\t   <- abstract E1 E1'\n\t\t   <- abstract E2 E2'.\n\n\n\ntranslate : exp -> exp -> type.\n%mode translate +E -E'.\n\ntranslate/lam\t: translate (lam ([x] E x)) E''\n\t\t   <- ({x:exp} \n\t\t\t translate x x\n\t\t\t -> translate (E x) (E' x))\n\t\t   <- abstract ([x] E' x) E''.\n\ntranslate/app\t: translate (app E1 E2) (app E1' E2')\n\t\t   <- translate E1 E1'\n\t\t   <- translate E2 E2'.\n\n\n\n\n%{  == Soundness ==  }%\n\nabstract-sound : abstract ([x] E x) E'\n%%\n\t\t  -> reduce E' (lam ([x] E x))\n\t\t  -> type.\n%mode abstract-sound +X1 -X2.\n\n%block abstract-sound-block\n   : block {x:exp}.\n\n-\t: abstract-sound\n\t   (abstract/var : abstract ([x] x) i)\n\t   %%\n\t   (reduce/refl\n\t      : reduce i (lam ([x] x))).\n\n-\t: abstract-sound\n\t   (abstract/closed : abstract ([x] E) (app k E))\n\t   %%\n\t   (reduce/beta\n\t      : reduce (app k E) (lam ([x] E))).\n\n-\t: abstract-sound\n\t   (abstract/app\n\t      (Dabstract2 : abstract ([x] E2 x) E2')\n\t      (Dabstract1 : abstract ([x] E1 x) E1'))\n\t   %%\n\t   (reduce/trans\n\t      (reduce/lam\n\t\t ([x] reduce/app reduce/beta reduce/beta))\n\t      (reduce/trans\n\t\t reduce/beta\n\t\t (reduce/app\n\t\t    Dreduce2\n\t\t    (reduce/trans\n\t\t       reduce/beta\n\t\t       (reduce/app\n\t\t\t  Dreduce1\n\t\t\t  reduce/refl)))))\n\t   <- abstract-sound Dabstract1\n\t      (Dreduce1 : reduce E1' (lam ([x] E1 x)))\n\t   <- abstract-sound Dabstract2\n\t      (Dreduce2 : reduce E2' (lam ([x] E2 x))).\n\t\t \n%worlds (abstract-sound-block) (abstract-sound _ _).\n%total D (abstract-sound D _).\n\n\n\ntranslate-sound : translate E E'\n%%\n\t\t   -> reduce E' E\n\t\t   -> type.\n%mode translate-sound +X1 -X2.\n\n%block translate-sound-block\n   : block \n      {x:exp}\n      {d_translate:translate x x}\n      {_:translate-sound d_translate reduce/refl}.\n\n-\t: translate-sound\n\t   (translate/lam\n\t      (Dabstract : abstract ([x] E' x) E'')\n\t      (Dtranslate : {x:exp}\n\t\t\t     translate x x\n\t\t\t     -> translate (E x) (E' x))\n\t      : translate (lam ([x] E x)) E'')\n\t   %%\n\t   (reduce/trans\n\t      (reduce/lam ([x] Dreduce1 x))\n\t      Dreduce2)\n\t   <- ({x} {d_translate:translate x x}\n\t\t translate-sound d_translate reduce/refl\n\t\t -> translate-sound (Dtranslate x d_translate)\n\t\t    (Dreduce1 x : reduce (E' x) (E x)))\n\t   <- abstract-sound Dabstract\n\t      (Dreduce2 : reduce E'' (lam ([x] E' x))).\n\n-\t: translate-sound\n\t   (translate/app\n\t      (Dtranslate2 : translate E2 E2')\n\t      (Dtranslate1 : translate E1 E1')\n\t      : translate (app E1 E2) (app E1' E2'))\n\t   %%\n\t   (reduce/app Dreduce2 Dreduce1)\n\t   <- translate-sound Dtranslate1\n\t      (Dreduce1 : reduce E1' E1)\n\t   <- translate-sound Dtranslate2\n\t      (Dreduce2 : reduce E2' E2).\n\n%worlds (translate-sound-block) (translate-sound _ _).\n%total D (translate-sound D _).\n\n\n\n\n%{ == Completeness ==  }%\n\nclean : exp -> type.\n\nclean/s\t\t: clean s.\n\nclean/k\t\t: clean k.\n\nclean/i\t\t: clean i.\n\nclean/app\t: clean (app E1 E2)\n\t\t   <- clean E1\n\t\t   <- clean E2.\n\n\n\nabstract-clean : ({x} clean x -> clean (E x))\n\t\t  -> abstract ([x] E x) E'\n%%\n\t\t  -> clean E'\n\t\t  -> type.\n%mode abstract-clean +X1 +X2 -X3.\n\n%block abstract-clean-block\n   : block {x:exp} {d_clean:clean x}.\n\n-\t: abstract-clean \n\t   _ \n\t   (abstract/var : abstract ([x] x) i)\n\t   %%\n\t   clean/i.\n\n-\t: abstract-clean\n\t   (Dclean : {x} clean x -> clean E)  %% NOTE not \"clean (E x)\"\n\t   abstract/closed\n\t   %%\n\t   (clean/app\n\t      (Dclean i clean/i : clean E)  %% strengthening via substitution here\n\t      clean/k).\n\n-\t: abstract-clean \n\t   ([x] [d_clean:clean x]\n\t      clean/app\n\t      (Dclean2 x d_clean : clean (E2 x))\n\t      (Dclean1 x d_clean : clean (E1 x)))\n\t   (abstract/app\n\t      (Dabstract2 : abstract ([x] E2 x) E2')\n\t      (Dabstract1 : abstract ([x] E1 x) E1'))\n\t   %%\n\t   (clean/app Dclean2' (clean/app Dclean1' clean/s)\n\t      : clean (app (app s E1') E2'))\n\t   <- abstract-clean Dclean1 Dabstract1 (Dclean1' : clean E1')\n\t   <- abstract-clean Dclean2 Dabstract2 (Dclean2' : clean E2').\n\n%worlds (abstract-clean-block) (abstract-clean _ _ _).\n%total D (abstract-clean _ D _).\n\n\n\ntranslate-clean : translate E E'\n%%\n\t\t   -> clean E'\n\t\t   -> type.\n%mode translate-clean +X1 -X2.\n\n%block translate-clean-block\n   : block\n      {x:exp}\n      {d_translate:translate x x}\n      {d_clean:clean x}\n      {_:translate-clean d_translate d_clean}.\n\n-\t: translate-clean\n\t   (translate/lam\n\t      (Dabstract : abstract ([x] E' x) E'')\n\t      (Dtranslate : {x:exp}\n\t\t\t     translate x x\n\t\t\t     -> translate (E x) (E' x))\n\t      : translate (lam ([x] E x)) E'')\n\t   %%\n\t   Dclean'\n\t   <- ({x} \n\t\t {d_translate:translate x x} \n\t\t {d_clean:clean x}\n\t\t translate-clean d_translate d_clean\n\t\t -> translate-clean (Dtranslate x d_translate)\n\t\t    (Dclean x d_clean : clean (E' x)))\n\t   <- abstract-clean Dclean Dabstract\n\t      (Dclean' : clean E'').\n\n-\t: translate-clean\n\t   (translate/app\n\t      (Dtranslate2 : translate E2 E2')\n\t      (Dtranslate1 : translate E1 E1')\n\t      : translate (app E1 E2) (app E1' E2'))\n\t   %%\n\t   (clean/app Dclean2 Dclean1\n\t      : clean (app E1' E2'))\n\t   <- translate-clean Dtranslate1\n\t      (Dclean1 : clean E1')\n\t   <- translate-clean Dtranslate2\n\t      (Dclean2 : clean E2').\n\n%worlds (translate-clean-block) (translate-clean _ _).\n%total D (translate-clean D _).\n\n\n\ncan-abstract : ({x} clean x -> clean (E x))\n%%\n\t\t-> abstract ([x] E x) E'\n\t\t-> type.\n%mode can-abstract +X1 -X2.\n\n%block can-abstract-block\n   : block {x:exp} {d_clean:clean x}.\n\n-\t: can-abstract\n\t   ([x] [d:clean x] d)\n\t   %%\n\t   abstract/var.\n\n-\t: can-abstract\n\t   (_ : {x} clean x -> clean E)\n\t   %%\n\t   abstract/closed.\n\n-\t: can-abstract\n\t   ([x] [d_clean:clean x]\n\t      clean/app\n\t      (Dclean2 x d_clean : clean (E2 x))\n\t      (Dclean1 x d_clean : clean (E1 x)))\n\t   %%\n\t   (abstract/app Dabstract2 Dabstract1)\n\t   <- can-abstract Dclean1\n\t      (Dabstract1 : abstract ([x] E1 x) E1')\n\t   <- can-abstract Dclean2\n\t      (Dabstract2 : abstract ([x] E2 x) E2').\n\n%worlds (can-abstract-block) (can-abstract _ _).\n%total D (can-abstract D _).\n\n\n\ncan-translate : {E:exp}\n%%\n\t\t translate E E'\n\t\t -> type.\n%mode can-translate +E -X.\n\n%block can-translate-block\n   : block\n      {x:exp}\n      {d_translate:translate x x}\n      {d_clean:clean x}\n      {_:translate-clean d_translate d_clean}\n      {_:can-translate x d_translate}.\n\n-\t: can-translate\n\t   (lam ([x] E x))\n\t   %%\n\t   (translate/lam Dabstract Dtranslate\n\t      : translate (lam ([x] E x)) E'')\n\t   <- ({x} \n\t\t {d_translate:translate x x} \n\t\t {d_clean:clean x}\n\t\t translate-clean d_translate d_clean\n\t\t -> can-translate x d_translate\n\t\t -> can-translate (E x)\n\t\t    (Dtranslate x d_translate : translate (E x) (E' x)))\n\t   <- ({x} \n\t\t {d_translate:translate x x} \n\t\t {d_clean:clean x}\n\t\t translate-clean d_translate d_clean\n\t\t -> translate-clean (Dtranslate x d_translate)\n\t\t    (Dclean x d_clean : clean (E' x)))\n\t   <- can-abstract Dclean\n\t      (Dabstract : abstract ([x] E' x) E'').\n\n-\t: can-translate\n\t   (app E1 E2)\n\t   %%\n\t   (translate/app Dtranslate2 Dtranslate1\n\t      : translate (app E1 E2) (app E1' E2'))\n\t   <- can-translate E1\n\t      (Dtranslate1 : translate E1 E1')\n\t   <- can-translate E2\n\t      (Dtranslate2 : translate E2 E2').\n\n%worlds (can-translate-block) (can-translate _ _).\n%total E (can-translate E _)."
          },
          "sha1": "i9z5xulw4y7qt3v0gj1kpzgwzdllyy7"
        }
      },
      {
        "title": "POPL Tutorial/Combinators Answer",
        "ns": 0,
        "id": 2160,
        "revision": {
          "id": 5830,
          "parentid": 5788,
          "timestamp": "2009-01-19T15:36:01Z",
          "contributor": {
            "username": "William Lovas",
            "id": 11
          },
          "comment": "added worlds to syntax",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 4024,
            "#text": "%{\nAdapted from the case study on [[Typed combinators soundness and completeness]].\n\n== Syntax ==\n\n}%\n\n% lambda calculus\n\nterm : type.                    %name term M x.\n\napp : term -> term -> term.\nlam : (term -> term) -> term.\n\n%block term-block : block {x:term}.\n%worlds (term-block) (term).\n\n% combinator calculus\n\ncomb : type.                    %name comb A y.\n\ns : comb.\nk : comb.\ni : comb.\ncapp : comb -> comb -> comb.\n\n%block comb-block : block {y:comb}.\n%worlds (comb-block) (comb).\n\n%{\n\n== Translation ==\n\n}%\n\n% bracket abstraction\n\nbracket : (comb -> comb) -> comb -> type.\n%mode bracket +A -A'.\n\nbracket/var : bracket ([y] y) i.\n\nbracket/i : bracket ([y] i) (capp k i).\nbracket/k : bracket ([y] k) (capp k k).\nbracket/s : bracket ([y] s) (capp k s).\n\nbracket/app : bracket ([y] capp (A y) (B y)) (capp (capp s A') B')\n               <- bracket ([y] A y) A'\n               <- bracket ([y] B y) B'.\n\n%block bracket-block : block {y:comb} {bracket/y:bracket ([z] y) (capp k y)}.\n\n%worlds (bracket-block) (bracket _ _).\n%total A (bracket A _).\n\n\n% translation\n\ntranslate : term -> comb -> type.\n%mode translate +M -A.\n\ntranslate/app : translate (app M N) (capp A B)\n                 <- translate M A\n                 <- translate N B.\n\ntranslate/lam : translate (lam ([x] M x)) A'\n                 <- ({x} {y} bracket ([z] y) (capp k y)\n                            -> translate x y\n                            -> translate (M x) (A y))\n                 <- bracket ([y] A y) A'.\n\n%block translate-block\n        : block {x:term} {y:comb}\n                {bracket/y: bracket ([z] y) (capp k y)}\n                {translate/x: translate x y}.\n%worlds (translate-block) (translate _ _).\n%total M (translate M _).\n\n%{\n\n== Equational theory ==\n\n}%\n\n% lambda term equality\n\nteq : term -> term -> type.\n\n% beta\nteq/beta : teq (app (lam ([x] M x)) N) (M N).\n\n% extensionality (eta)\nteq/ext : teq M M'\n           <- ({x:term} teq (app M x) (app M' x)).\n\n% compatibilities\nteq/app : teq (app M N) (app M' N')\n           <- teq M M'\n           <- teq N N'.\n\nteq/lam : teq (lam ([x] M x)) (lam ([x] M' x))\n           <- ({x:term} teq (M x) (M' x)).\n\n% equivalence\nteq/refl : teq M M.\n\nteq/symm : teq M M'\n            <- teq M' M.\n\nteq/trans : teq M M'\n             <- teq M N\n             <- teq N M'.\n\n%worlds (term-block) (teq _ _).\n\n\n% combinator equality\n\nceq : comb -> comb -> type.\n\n% betas\nceq/i : ceq (capp i A) A.\nceq/k : ceq (capp (capp k A) B) A.\nceq/s : ceq (capp (capp (capp s A) B) C) (capp (capp A C) (capp B C)).\n\n% extensionality\nceq/ext : ceq A A'\n           <- ({y:comb} ceq (capp A y) (capp A' y)).\n\n% compatibility\nceq/app : ceq (capp A B) (capp A' B')\n           <- ceq A A'\n           <- ceq B B'.\n\n% equivalence\nceq/refl : ceq A A.\n\nceq/symm : ceq A A'\n            <- ceq A' A.\n\nceq/trans : ceq A A'\n             <- ceq A B\n             <- ceq B A'.\n\n%worlds (comb-block) (ceq _ _).\n\n\n\n%{\n\n== Correctness of the translation ==\n\n}%\n\n% substitution lemma\n\nsubst : bracket ([y] A y) A' -> {C:comb} ceq (capp A' C) (A C) -> type.\n%mode subst +Dbrack +C -Dceq.\n\n- : subst (bracket/var : bracket ([y] y) i)\n          C\n          (ceq/i : ceq (capp i C) C).\n\n- : subst (bracket/i : bracket ([y] i) (capp k i))\n          C\n          (ceq/k : ceq (capp (capp k i) C) i).\n\n- : subst (bracket/k : bracket ([y] k) (capp k k))\n          C\n          (ceq/k : ceq (capp (capp k k) C) k).\n\n- : subst (bracket/s : bracket ([y] s) (capp k s))\n          C\n          (ceq/k : ceq (capp (capp k s) C) s).\n\n- : subst (bracket/app (Dbrack2 : bracket ([y] B y) B')\n                       (Dbrack1 : bracket ([y] A y) A'))\n          C\n          (ceq/trans\n              (ceq/app Dceq2 Dceq1)\n              ceq/s)\n     <- subst Dbrack1 C (Dceq1 : ceq (capp A' C) (A C))\n     <- subst Dbrack2 C (Dceq2 : ceq (capp B' C) (B C)).\n\n%block subst-block : block {y:comb} {dbrack: bracket ([z] y) (capp k y)}\n                           {thm-subst: {C:comb} subst dbrack C ceq/k}.\n%worlds (subst-block) (subst _ _ _).\n%total D (subst D _ _)."
          },
          "sha1": "1l3c3gdz8uki4ilmqtish4j1lp645op"
        }
      },
      {
        "title": "POPL Tutorial/Combinators Starter",
        "ns": 0,
        "id": 2162,
        "redirect": {
          "@title": "POPL Tutorial/Combinators Support",
          "#text": null
        },
        "revision": {
          "id": 5793,
          "timestamp": "2009-01-18T06:11:22Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "comment": "[[POPL Tutorial/Combinators Starter]] moved to [[POPL Tutorial/Combinators Support]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 47,
            "#text": "#REDIRECT [[POPL Tutorial/Combinators Support]]"
          },
          "sha1": "pspo2e07glm45686mkcck3c5qgp8v6x"
        }
      },
      {
        "title": "POPL Tutorial/Combinators Support",
        "ns": 0,
        "id": 2159,
        "revision": {
          "id": 5792,
          "parentid": 5786,
          "timestamp": "2009-01-18T06:11:22Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "minor": null,
          "comment": "[[POPL Tutorial/Combinators Starter]] moved to [[POPL Tutorial/Combinators Support]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 1215,
            "#text": "%{\nAdapted from the case study on [[Typed combinators soundness and completeness]].\n\n== Syntax ==\n\n}%\n\n% lambda calculus\n\nterm : type.                    %name term M x.\n\napp : term -> term -> term.\nlam : (term -> term) -> term.\n\n\n% combinator calculus\n\ncomb : type.                    %name comb A y.\n\ns : comb.\nk : comb.\ni : comb.\ncapp : comb -> comb -> comb.\n\n\n\n%{\n\n== Translation ==\n\n}%\n\n% bracket abstraction\n% XXX fill in\n\n% translation\n% XXX fill in\n\n\n%{\n\n== Equational theory ==\n\n}%\n\n% lambda term equality\n\n% (elided)\n\n% combinator equality\n\nceq : comb -> comb -> type.\n\n% betas\nceq/i : ceq (capp i A) A.\nceq/k : ceq (capp (capp k A) B) A.\nceq/s : ceq (capp (capp (capp s A) B) C) (capp (capp A C) (capp B C)).\n\n% extensionality\nceq/ext : ceq A A'\n           <- ({y:comb} ceq (capp A y) (capp A' y)).\n\n% compatibility\nceq/app : ceq (capp A B) (capp A' B')\n           <- ceq A A'\n           <- ceq B B'.\n\n% equivalence\nceq/refl : ceq A A.\n\nceq/symm : ceq A A'\n            <- ceq A' A.\n\nceq/trans : ceq A A'\n             <- ceq A B\n             <- ceq B A'.\n\n%block comb-block : block {y:comb}.\n%worlds (comb-block) (ceq _ _).\n\n%{\n\n== Correctness of the translation ==\n\n}%\n\n% substitution lemma\n% XXX fill in"
          },
          "sha1": "7jnwtsm1ldzuid2bn5pp9zm8ii9mvqg"
        }
      },
      {
        "title": "POPL Tutorial/Combinators session",
        "ns": 0,
        "id": 2150,
        "revision": {
          "id": 5776,
          "parentid": 5774,
          "timestamp": "2009-01-17T04:57:32Z",
          "contributor": {
            "username": "William Lovas",
            "id": 11
          },
          "comment": "add betas and extensionality to the template",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 1284,
            "#text": "%{\nAdapted from the case study on [[Typed combinators soundness and completeness]].\n\n== Syntax ==\n\n}%\n\n% lambda calculus\n\nterm : type.                    %name term M x.\n\napp : term -> term -> term.\nlam : (term -> term) -> term.\n\n\n% combinator calculus\n\ncomb : type.                    %name comb A y.\n\ns : comb.\nk : comb.\ni : comb.\ncapp : comb -> comb -> comb.\n\n\n\n%{\n\n== Translation ==\n\n}%\n\n% bracket abstraction\n% XXX fill in\n\n% translation\n% XXX fill in\n\n\n%{\n\n== Equational theory ==\n\n}%\n\n% lambda term equality\n\n% (elided)\n\n% combinator equality\n\nceq : comb -> comb -> type.\n\n% betas\nceq/i : ceq (capp i A) A.\nceq/k : ceq (capp (capp k A) _) A.\nceq/s : ceq (capp (capp (capp s A) B) C) (capp (capp A C) (capp B C)).\n\n% extensionality\nceq/ext : ceq A A'\n           <- ({y:comb} ceq (capp A y) (capp A' y)).\n\n% compatibility\nceq/app : ceq (capp A B) (capp A' B')\n           <- ceq A A'\n           <- ceq B B'.\n\n% equivalence\nceq/refl : ceq A A.\n\nceq/symm : ceq A A'\n            <- ceq A' A.\n\nceq/trans : ceq A A'\n             <- ceq A B\n             <- ceq B A'.\n\n%block comb-block : block {y:comb}.\n%worlds (comb-block) (ceq _ _).\n\n%{\n\n== Correctness of the translation ==\n\n}%\n\n% substitution lemma\n% XXX fill in\n\n%{\n\n\n[[POPL Tutorial/Combinators session (answers) | Solution]]\n\n}%"
          },
          "sha1": "azj4kkqlm667nvc80tqag3j405vf199"
        }
      },
      {
        "title": "POPL Tutorial/Combinators session (answers)",
        "ns": 0,
        "id": 2149,
        "revision": {
          "id": 5777,
          "parentid": 5775,
          "timestamp": "2009-01-17T04:59:00Z",
          "contributor": {
            "username": "William Lovas",
            "id": 11
          },
          "comment": "missed one N -> A",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 3966,
            "#text": "%{\nAdapted from the case study on [[Typed combinators soundness and completeness]].\n\n== Syntax ==\n\n}%\n\n% lambda calculus\n\nterm : type.                    %name term M x.\n\napp : term -> term -> term.\nlam : (term -> term) -> term.\n\n\n% combinator calculus\n\ncomb : type.                    %name comb A y.\n\ns : comb.\nk : comb.\ni : comb.\ncapp : comb -> comb -> comb.\n\n\n%{\n\n== Translation ==\n\n}%\n\n% bracket abstraction\n\nbracket : (comb -> comb) -> comb -> type.\n%mode bracket +A -A'.\n\nbracket/var : bracket ([y] y) i.\n\nbracket/i : bracket ([y] i) (capp k i).\nbracket/k : bracket ([y] k) (capp k k).\nbracket/s : bracket ([y] s) (capp k s).\n\nbracket/app : bracket ([y] capp (A y) (B y)) (capp (capp s A') B')\n               <- bracket ([y] A y) A'\n               <- bracket ([y] B y) B'.\n\n%block bracket-block : block {y:comb} {bracket/y:bracket ([z] y) (capp k y)}.\n\n%worlds (bracket-block) (bracket _ _).\n%total A (bracket A _).\n\n\n% translation\n\ntranslate : term -> comb -> type.\n%mode translate +M -A.\n\ntranslate/app : translate (app M N) (capp A B)\n                 <- translate M A\n                 <- translate N B.\n\ntranslate/lam : translate (lam ([x] M x)) A'\n                 <- ({x} {y} bracket ([z] y) (capp k y)\n                            -> translate x y\n                            -> translate (M x) (A y))\n                 <- bracket ([y] A y) A'.\n\n%block translate-block\n        : block {x:term} {y:comb}\n                {bracket/y: bracket ([z] y) (capp k y)}\n                {translate/x: translate x y}.\n%worlds (translate-block) (translate _ _).\n%total M (translate M _).\n\n%{\n\n== Equational theory ==\n\n}%\n\n% lambda term equality\n\nteq : term -> term -> type.\n\n% beta\nteq/beta : teq (app (lam ([x] M x)) N) (M N).\n\n% extensionality (eta)\nteq/ext : teq M M'\n           <- ({x:term} teq (app M x) (app M' x)).\n\n% compatibilities\nteq/app : teq (app M N) (app M' N')\n           <- teq M M'\n           <- teq N N'.\n\nteq/lam : teq (lam ([x] M x)) (lam ([x] M' x))\n           <- ({x:term} teq (M x) (M' x)).\n\n% equivalence\nteq/refl : teq M M.\n\nteq/symm : teq M M'\n            <- teq M' M.\n\nteq/trans : teq M M'\n             <- teq M N\n             <- teq N M'.\n\n%block term-block : block {x:term}.\n%worlds (term-block) (teq _ _).\n\n\n% combinator equality\n\nceq : comb -> comb -> type.\n\n% betas\nceq/i : ceq (capp i A) A.\nceq/k : ceq (capp (capp k A) _) A.\nceq/s : ceq (capp (capp (capp s A) B) C) (capp (capp A C) (capp B C)).\n\n% extensionality\nceq/ext : ceq A A'\n           <- ({y:comb} ceq (capp A y) (capp A' y)).\n\n% compatibility\nceq/app : ceq (capp A B) (capp A' B')\n           <- ceq A A'\n           <- ceq B B'.\n\n% equivalence\nceq/refl : ceq A A.\n\nceq/symm : ceq A A'\n            <- ceq A' A.\n\nceq/trans : ceq A A'\n             <- ceq A B\n             <- ceq B A'.\n\n%block comb-block : block {y:comb}.\n%worlds (comb-block) (ceq _ _).\n\n\n\n%{\n\n== Correctness of the translation ==\n\n}%\n\n% substitution lemma\n\nsubst : bracket ([y] A y) A' -> {C:comb} ceq (capp A' C) (A C) -> type.\n%mode subst +Dbrack +C -Dceq.\n\n- : subst (bracket/var : bracket ([y] y) i)\n          C\n          (ceq/i : ceq (capp i C) C).\n\n- : subst (bracket/i : bracket ([y] i) (capp k i))\n          C\n          (ceq/k : ceq (capp (capp k i) C) i).\n\n- : subst (bracket/k : bracket ([y] k) (capp k k))\n          C\n          (ceq/k : ceq (capp (capp k k) C) k).\n\n- : subst (bracket/s : bracket ([y] s) (capp k s))\n          C\n          (ceq/k : ceq (capp (capp k s) C) s).\n\n- : subst (bracket/app (Dbrack2 : bracket ([y] B y) B')\n                       (Dbrack1 : bracket ([y] A y) A'))\n          C\n          (ceq/trans\n              (ceq/app Dceq2 Dceq1)\n              ceq/s)\n     <- subst Dbrack1 C (Dceq1 : ceq (capp A' C) (A C))\n     <- subst Dbrack2 C (Dceq2 : ceq (capp B' C) (B C)).\n\n%block subst-block : block {y:comb} {dbrack: bracket ([z] y) (capp k y)}\n                           {thm-subst: {C:comb} subst dbrack C ceq/k}.\n%worlds (subst-block) (subst _ _ _).\n%total D (subst D _ _)."
          },
          "sha1": "6dxg7z3m7rpd7rms438dw2yogqiw05o"
        }
      },
      {
        "title": "POPL Tutorial/Control machine",
        "ns": 0,
        "id": 2100,
        "revision": {
          "id": 5467,
          "parentid": 5466,
          "timestamp": "2008-11-18T00:01:31Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 3828,
            "#text": "%{}%\n\nexp : type.\n\nlam : (exp -> exp) -> exp.\napp : exp -> exp -> exp.\n\nev : exp -> exp -> type.\nev_lam : ev (lam [x] E x) (lam [x] E x).\nev_app : ev (app E1 E2) V\n         <- ev E1 (lam [x] E x)\n         <- ev E2 V2\n         <- ev (E V2) V.\n\nstack : type.\n# : stack.\napp1 : exp -> stack -> stack.\napp2 : exp -> stack -> stack.\n\nstate : type.\neval : stack -> exp -> state.\nreturn : stack -> exp -> state.\n\nstep : state -> state -> type.\n\nstep_lam : step (eval K (lam E)) (return K (lam E)).\nstep_app1 : step (eval K (app E1 E2)) (eval (app1 E2 K) E1).\nstep_app2 : step (return (app1 E2 K) V) (eval (app2 V K) E2).\nstep_red : step (return (app2 (lam E) K) V) (eval K (E V)).\n\nsteps : state -> state -> type.\nsteps_refl : steps S S.\nsteps_trans : step S S' -> steps S' S'' -> steps S S''.\n\nsteps_steps : steps S S' -> steps S' S'' -> steps S S'' -> type.\n- : steps_steps steps_refl W W.\n- : steps_steps (steps_trans W Ws) Ws' (steps_trans W Ws'')\n    <- steps_steps Ws Ws' Ws''.\n%mode steps_steps +A +B -C.\n%worlds () (steps_steps _ _ _).\n%total T (steps_steps T _ _).\n\nsound : ev E V -> steps (eval K E) (return K V) -> type.\n%mode\n +{E:exp} +{V:exp} +{K:stack} +{E1:ev E V} -{V1:steps (eval K E) (return K V)}\n  (sound E1 V1).\n\n- : sound ev_lam (steps_trans step_lam steps_refl).\n- : sound (ev_app D D2 D1) W123\n    <- sound D1 (W1: steps\n                      (eval (app1 E2 K) E1)\n                      (return (app1 E2 K) (lam E)))\n    <- sound D2 (W2: steps\n                      (eval (app2 (lam E) K) E2)\n                      (return (app2 (lam E) K) V2))\n    <- sound D (W3: steps\n                    (eval K (E V2))\n                    (return K V))\n    <- steps_steps (steps_trans step_app1 W1) (steps_trans step_app2 W2)\n       (W12: steps (eval K (app E1 E2)) (return (app2 (lam E) K) V2))\n    <- steps_steps W12 (steps_trans step_red W3)\n       (W123: steps (eval K (app E1 E2)) (return K V)).\n\n%worlds () (sound _ _).\n%total T (sound T _).\n\ninvert_app2 : steps (return (app1 E2 K) V) (return # V')\n              -> steps (eval (app2 V K) E2) (return # V') -> type.\n\n- : invert_app2 (steps_trans step_app2 W) W.\n\n%mode invert_app2 +A -B.\n%worlds () (invert_app2 _ _).\n%total {} (invert_app2 _ _).\n%reduces C < A (invert_app2 A C).\n\nid : exp -> exp -> type.\nrefl : id E E.\n\ninvert_red : steps (return (app2 Vlam K) V) (return # V')\n             -> id Vlam (lam E)\n             -> steps (eval K (E V)) (return # V') -> type.\n\n- : invert_red (steps_trans step_red W) refl W.\n\n%mode invert_red +A -B -C.\n%worlds () (invert_red _ _ _).\n%total {} (invert_red _ _ _).\n%reduces C < A (invert_red A _ C).\n\nuse_id : id V1 (lam E)\n         -> ev E1 V1\n         -> ev E2 V2\n         -> ev (E V2) V\n         -> ev (app E1 E2) V\n         -> type.\n- : use_id refl E1 E2 E (ev_app E E2 E1).\n%mode use_id +A +B +C +D -E.\n%worlds () (use_id _ _ _ _ _).\n%total {} (use_id _ _ _ _ _).\n\ncomplete : steps (eval K E) (return # V0)\n           -> ev E V\n           -> steps (return K V) (return # V0) -> type.\n%mode complete +A -B -C.\n\n- : complete (steps_trans step_lam W: steps (eval K (lam E)) (return # V0))\n    ev_lam W.\n- : complete (steps_trans step_app1 W\n               : steps (eval K (app E1 E2)) (return # V0))\n    D' W5\n    <- complete (W: steps (eval (app1 E2 K) E1) (return # V0))\n       (D1: ev E1 V1)\n       (W1: steps (return (app1 E2 K) V1) (return # V0))\n    <- invert_app2 W1 (W2: steps (eval (app2 V1 K) E2) (return # V0))\n    <- complete W2\n       (D2: ev E2 V2)\n       (W3: steps (return (app2 V1 K) V2) (return # V0))\n    <- invert_red W3 (ID: id V1 (lam E))\n       (W4: steps (eval K (E V2)) (return # V0))\n    <- complete W4\n       (D: ev (E V2) V)\n       (W5: steps (return K V) (return # V0))\n    <- use_id ID D1 D2 D D'.\n\n%worlds () (complete _ _ _).\n%reduces C < A (complete A _ C).\n%total T (complete T _ _)."
          },
          "sha1": "5k87ed9la3clnfoh4ed58g1qxcvt3fq"
        }
      },
      {
        "title": "POPL Tutorial/Cost Semantics",
        "ns": 0,
        "id": 2106,
        "redirect": {
          "@title": "POPL Tutorial/Cost semantics",
          "#text": null
        },
        "revision": {
          "id": 5498,
          "timestamp": "2008-11-19T22:53:18Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "comment": "[[POPL Tutorial/Cost Semantics]] moved to [[POPL Tutorial/Cost semantics]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 42,
            "#text": "#REDIRECT [[POPL Tutorial/Cost semantics]]"
          },
          "sha1": "10l5uscwbu845uatrbveemp9s9kajg0"
        }
      },
      {
        "title": "POPL Tutorial/Cost semantics",
        "ns": 0,
        "id": 2099,
        "revision": {
          "id": 5645,
          "parentid": 5644,
          "timestamp": "2008-11-22T00:07:27Z",
          "contributor": {
            "username": "Mpa",
            "id": 42
          },
          "comment": "_",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 10497,
            "#text": "%{ == Syntax == }%\n\ntp : type.\t\t\t\t%name tp T.\ntunit : tp.\narr : tp -> tp -> tp.\n\nexp : type.\t\t\t\t%name exp E.\nunit : exp.\nfun : tp -> tp -> (exp -> exp -> exp) -> exp.\napp : exp -> exp -> exp.\n\n%{ == Series-parallel graphs == }%\n\ngraph : type.\n0 : graph.\n1 : graph.\n+ : graph -> graph -> graph. %infix right 5 +.\n* : graph -> graph -> graph. %infix right 5 *.\n\n%{}% \n\nnat : type.\nz : nat.\ns : nat -> nat.\n\n%{ === Size of graphs === }%\n\nplus : nat -> nat -> nat -> type.\nplus/z : plus z N N.\nplus/s : plus (s N1) N2 (s N3)\n\t  <- plus N1 N2 N3.\n\nsizeof : graph -> nat -> type.\n\nsizeof/0 : sizeof 0 z.\nsizeof/1 : sizeof 1 (s z).\nsizeof/+ : sizeof (G1 + G2) C3\n          <- sizeof G1 C1\n          <- sizeof G2 C2\n          <- plus C2 C1 C3.\nsizeof/* : sizeof (G1 * G2) C3\n          <- sizeof G1 C1\n          <- sizeof G2 C2\n          <- plus C2 C1 C3.\n\n%{ === Depth of graphs === }%\n\nmax : nat -> nat -> nat -> type.\n\nmax/zz : max z z z.\nmax/sz : max (s N) z (s M) \n          <- max N z M.\nmax/zs : max z (s N) (s M)\n          <- max z N M.\nmax/ss : max (s N) (s M) (s P)\n          <- max N M P.\n\ndepthof : graph -> nat -> type.\n\ndepthof/0 : depthof 0 z.\ndepthof/1 : depthof 1 (s z).\ndepthof/+ : depthof (G1 + G2) C\n          <- depthof G1 C1\n          <- depthof G2 C2\n          <- plus C1 C2 C.\ndepthof/* : depthof (G1 * G2) C\n          <- depthof G1 C1\n          <- depthof G2 C2\n          <- max C1 C2 C.\n\n%{ == Cost Semantics == }%\n\nevcost : exp -> exp -> graph -> type. \n\nevcost/unit \n    : evcost unit unit 0.\n\nevcost/fun\n    : evcost (fun T1 T2 E) (fun T1 T2 E) 0.\n\nevcost/app\n    : evcost (app E1 E2) V ((G1 * G2) + 1 + G)\n       <- evcost E1 (fun T1 T2 ([f][x] E f x)) G1\n       <- evcost E2 V2 G2\n       <- evcost (E (fun T1 T2 ([f][x] E f x)) V2) V G.\n\n%{ == Sequential Evaluation == }%\n\nvalue : exp -> type.\t\t\t%name value Dval.\n%mode value +E.\n\nvalue/unit : value unit.\nvalue/fun : value (fun _ _ _).\n\nstep : exp -> exp -> type.\t\t%name step Dstep.\n%mode step +E1 -E2.\n\nstep/app/fun\n   : step (app E1 E2) (app E1' E2)\n      <- step E1 E1'.\nstep/app/arg\n   : step (app E1 E2) (app E1 E2')\n      <- value E1 <- step E2 E2'.\nstep/app/beta-v\n   : step\n      (app (fun T1 T2 ([f] [x] E f x)) E2)\n      (E (fun T1 T2 ([f] [x] E f x)) E2)\n      <- value E2.\n\n%{}%\n\nsteps : exp -> exp -> nat -> type.\n%mode steps +X1 -X2 -X3.\n\nsteps/refl : steps E E z.\n\nsteps/trans : steps E E'' (s C)\n    <- step E E'\n    <- steps E' E'' C.\n\n%{ == Parallel Evaluation == }%\n\npstep : exp -> exp -> type.\n\npstep/app/\n   : pstep (app E1 E2) (app E1' E2')\n      <- pstep E1 E1'\n      <- pstep E2 E2'.\npstep/app/fun\n   : pstep (app E1 E2) (app E1' E2)\n      <- pstep E1 E1'\n      <- value E2.\npstep/app/arg\n   : pstep (app E1 E2) (app E1 E2')\n      <- pstep E2 E2'\n      <- value E1.\npstep/app/beta-v\n   : pstep\n      (app (fun T1 T2 ([f] [x] E f x)) E2)\n      (E (fun T1 T2 ([f] [x] E f x)) E2)\n      <- value E2.\n\n%{}%\n\npsteps : exp -> exp -> nat -> type.\n\npsteps/refl : psteps E E z.\n\npsteps/trans : psteps E E'' (s C)\n          <- pstep E E'\n          <- psteps E' E'' C.\n\n%{ === Cost of parallel evaluation === }%\n\npar_app \n   :  max C1 C2 Cmax \n      -> psteps E1 V1 C1 \n      -> value V1\n      -> psteps E2 V2 C2\n      -> value V2\n      -> psteps (app E1 E2) (app V1 V2) Cmax\n      -> type.\n%mode par_app +M +P1 +V1 +P2 +V2 -P.\n\n- : par_app max/zz psteps/refl Val1 psteps/refl Val2 psteps/refl.\n\n- : par_app \n     (max/sz (Max: max C1 z Cmax))\n     (psteps/trans (P1s: psteps E1' V1 C1) (Step1: pstep E1 E1'))\n     (Val1: value V1)\n     (psteps/refl: psteps V2 V2 z)\n     (Val2: value V2)\n     (psteps/trans Psteps (pstep/app/fun Val2 Step1))\n     <- par_app Max P1s Val1 psteps/refl Val2 \n        (Psteps: psteps (app E1' V2) (app V1 V2) Cmax).\n\n- : par_app \n     (max/zs (Max: max z C2 Cmax))\n     (psteps/refl: psteps V1 V1 z)\n     (Val1: value V1)\n     (psteps/trans (P2s: psteps E2' V2 C2) (Step2: pstep E2 E2'))\n     (Val2: value V2)\n     (psteps/trans Psteps (pstep/app/arg Val1 Step2))\n     <- par_app Max psteps/refl Val1 P2s Val2 \n        (Psteps: psteps (app V1 E2') (app V1 V2) Cmax).\n\n- : par_app \n     (max/ss (Max: max C1 C2 Cmax))\n     (psteps/trans (P1s: psteps E1' V1 C1) (Step1: pstep E1 E1'))\n     (Val1: value V1)\n     (psteps/trans (P2s: psteps E2' V2 C2) (Step2: pstep E2 E2'))\n     (Val2: value V2)\n     (psteps/trans Psteps (pstep/app/ Step2 Step1))\n     <- par_app Max P1s Val1 P2s Val2 \n        (Psteps: psteps (app E1' E2') (app V1 V2) Cmax).\n\n%worlds () (par_app _ _ _ _ _ _).\n%total T (par_app T _ _ _ _ _).\n\ncompose \n   : plus C1 C2 C3 \n      -> psteps E1 E2 C1 \n      -> psteps E2 E3 C2 \n      -> psteps E1 E3 C3 \n      -> type.\n\n%mode compose +D +P1 +P2 -P.\n\n- : compose plus/z psteps/refl Psteps Psteps.\n- : compose (plus/s D) (psteps/trans Ps S) Ps' (psteps/trans Ps'' S)\n     <- compose D Ps Ps' Ps''.\n\n%worlds () (compose _ _ _ _).\n%total T (compose T _ _ _).\n\nschedule_parallel \n   : evcost E V G \n      -> depthof G N \n      -> psteps E V N\n      -> value V \n      -> type.\n%mode schedule_parallel +E +D -S -V.\n\n- : schedule_parallel evcost/unit depthof/0 psteps/refl value/unit.\n\n- : schedule_parallel evcost/fun depthof/0 psteps/refl value/fun.\n\n- : schedule_parallel \n     (evcost/app \n        (Dcost:  evcost (E (fun T1 T2 E) V2) V G)\n        (Dcost2: evcost E2 V2 G2) \n        (Dcost1: evcost E1 (fun T1 T2 E) G1)) \n     (depthof/+ \n        (Dplus : plus DepthMax (s DepthG) Depth) \n        (depthof/+ \n           (plus/s plus/z)\n           (DdepthG : depthof G DepthG) \n           depthof/1)\n        (depthof/*\n           (Dmax : max Depth1 Depth2 DepthMax)\n           (DdepthG2 : depthof G2 Depth2)\n           (DdepthG1 : depthof G1 Depth1)))\n     Dstep'' Val\n   <- schedule_parallel Dcost1 DdepthG1 \n      (Dstep1: psteps E1 (fun T1 T2 E) Depth1) \n      (Val1: value (fun T1 T2 E))\n   <- schedule_parallel Dcost2 DdepthG2 \n      (Dstep2: psteps E2 V2 Depth2) \n      (Val2: value V2)\n   <- schedule_parallel Dcost DdepthG \n      (Dstep: psteps (E (fun T1 T2 E) V2) V DepthG)\n      (Val: value V)\n   <- par_app Dmax Dstep1 Val1 Dstep2 Val2 \n      (Dstep': psteps (app E1 E2) (app (fun T1 T2 E) V2) DepthMax)\n   <- compose Dplus Dstep' (psteps/trans Dstep (pstep/app/beta-v Val2)) \n      (Dstep'' : psteps (app E1 E2) V Depth). \n\n%worlds () (schedule_parallel _ _ _ _).\n%total T (schedule_parallel T _ _ _).\n\n%{ === Random Plus Lemmas === }%\n\nplus_lemma : plus (s N1) N2 N3\n\t      -> plus N1 (s N2) N3\n\t      -> type.\n%mode plus_lemma -X1 +X2.\n\n-: plus_lemma \n    (plus/s Dplus)\n    (plus/s Dplus')\n    <- plus_lemma Dplus Dplus'.\n\n-: plus_lemma\n    (plus/s plus/z)\n    plus/z.\n\n%worlds () (plus_lemma _ _).\n%total [D] (plus_lemma _ D).\n\n\nplus_lemma' : plus (s N1) N2 N3\n\t       -> plus N1 (s N2) N3\n\t       -> type.\n%mode plus_lemma' +X1 -X2.\n\n-: plus_lemma' \n    (plus/s Dplus)\n    (plus/s Dplus')\n    <- plus_lemma' Dplus Dplus'.\n\n-: plus_lemma'\n    (plus/s plus/z)\n    plus/z.\n\n%worlds () (plus_lemma' _ _).\n%total [D] (plus_lemma' D _).\n\n\nplus_zero : {N} plus N z N -> type.\n%mode plus_zero +N -D.\n\n-: plus_zero z plus/z.\n\n-: plus_zero (s N) (plus/s Dplus)\n    <- plus_zero N Dplus.\n\n%worlds () (plus_zero _ _).\n%total [N] (plus_zero N _).\n\nplus_commute : plus N1 N2 N3\n\t\t-> plus N2 N1 N3\n\t\t-> type.\n%mode plus_commute +D1 -D2.\n\n-: plus_commute\n    (plus/s Dplus)\n    Dplus''\n    <- plus_commute Dplus Dplus'\n    <- plus_lemma' (plus/s Dplus') Dplus''.\n\n-: plus_commute\n    plus/z\n    Dplus\n    <- plus_zero _ Dplus.\n\n%worlds () (plus_commute _ _).\n%total [D] (plus_commute D _).\n\n\n\n%{ === Cost of sequential evaluation === }%\n\n\n\nsteps_lemma : steps E E' C\n\t      -> step E' E''\n\t      -> steps E E'' (s C) -> type.\n%mode steps_lemma +X1 +X2 -X3.\n\n-: steps_lemma \n    steps/refl\n    E'step\n    (steps/trans steps/refl E'step).\n\n-: steps_lemma\n    (steps/trans\n       E'steps\n       Estep)\n    E''step\n    (steps/trans E'steps' Estep)\n    <- steps_lemma E'steps E''step E'steps'.\n\n%worlds () (steps_lemma _ _ _).\n%total [D] (steps_lemma D _ _).\n\n\nsteps_lemma2 : steps E E' C1\n\t      -> steps E' E'' C2\n\t      -> plus C2 C1 C\n\t      -> steps E E'' C -> type.\n%mode steps_lemma2 +X1 +X2 -X3 -X4.\n\n-: steps_lemma2\n    Esteps\n    steps/refl\n    plus/z\n    Esteps.\n\n-: steps_lemma2\n    Esteps\n    (steps/trans\n       E''steps\n       E'step)\n    Dplus'\n    Esteps''\n    <- steps_lemma Esteps E'step Esteps'\n    <- steps_lemma2 Esteps' E''steps Dplus Esteps''\n    <- plus_lemma Dplus' Dplus.\n\n%worlds () (steps_lemma2 _ _ _ _).\n%total [D] (steps_lemma2 _ D _ _).\n\n\n\napp_lemma1 : steps E1 E1' C\n\t      -> steps (app E1 E2) (app E1' E2) C\n\t      -> type.\n%mode +{E1:exp} +{E1':exp} +{E2:exp} +{C:nat} +{D:steps E1 E1' C}\n-{D':steps (app E1 E2) (app E1' E2) C} app_lemma1 D D'.\n\n-: app_lemma1 steps/refl steps/refl.\n\n-: app_lemma1\n    (steps/trans\n       E'steps\n       Estep)\n    (steps/trans\n       E'steps'\n       (step/app/fun Estep))\n    <- app_lemma1 E'steps E'steps'.\n\n%worlds () (app_lemma1 _ _).\n%total [D] (app_lemma1 D _).\n\n\napp_lemma2 : value V1\n\t      -> steps E2 E2' C\n\t      -> steps (app V1 E2) (app V1 E2') C\n\t      -> type.\n%mode +{V1:exp} +{E2:exp} +{E2':exp} +{C:nat} +{D:value V1} +{D':steps E2 E2' C}\n-{D'':steps (app V1 E2) (app V1 E2') C} app_lemma2 D D' D''.\n\n-: app_lemma2 _ steps/refl steps/refl.\n\n-: app_lemma2\n    Vvalue\n    (steps/trans\n       E'steps\n       Estep)\n    (steps/trans\n       E'steps'\n       (step/app/arg Estep Vvalue))\n    <- app_lemma2 Vvalue E'steps E'steps'.\n\n%worlds () (app_lemma2 _ _ _).\n%total [D] (app_lemma2 _ D _).\n\n\nschedule_serial : evcost E1 E2 G -> sizeof G C -> steps E1 E2 C -> value E2 -> type.\n%mode schedule_serial +X1 -X2 -X3 -X4.\n\n-: schedule_serial\n    evcost/unit sizeof/0 steps/refl value/unit.\n\n-: schedule_serial\n    evcost/fun sizeof/0 steps/refl value/fun.\n\n-: schedule_serial\n    (evcost/app \n       (Ecost)\n       (E2cost)\n       (E1cost))\n    ((sizeof/+\n       Dplus'\n       (sizeof/+\n\t  Dplus''\n\t  Esize\n\t  sizeof/1)\n       (sizeof/*\n\t  Dplus\n\t  E2size\n\t  E1size)))\n    E1steps'''\n    E'value\n    <- schedule_serial E1cost E1size E1steps _\n    <- schedule_serial E2cost E2size E2steps E2'value\n    <- schedule_serial Ecost Esize Esteps E'value\n    <- app_lemma1 E1steps E1steps'\n    <- app_lemma2 value/fun E2steps E2steps'\n    <- steps_lemma2 E1steps' E2steps' Dplus E1steps''\n    <- steps_lemma2 E1steps'' (steps/trans Esteps (step/app/beta-v E2'value)) Dplus' E1steps'''\n    <- plus_commute (plus/s plus/z) Dplus''.\n\n%worlds () (schedule_serial _ _ _ _).\n%total [D] (schedule_serial D _ _ _)."
          },
          "sha1": "28x82uoto32egcn914onmkwdn156qbc"
        }
      },
      {
        "title": "POPL Tutorial/Evaluation Contexts Intrinsic",
        "ns": 0,
        "id": 2125,
        "revision": {
          "id": 5617,
          "timestamp": "2008-11-21T21:32:57Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "comment": "New page: %{   == Evaluation Contexts, Intrinsically Typed ==  }%  tp : type. b : tp. arr : tp -> tp -> tp.  tm : tp -> type. val : tp -> type.  app : tm (arr A B) -> tm A -> tm B. ret : val A -> tm...",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 2130,
            "#text": "%{ \n\n== Evaluation Contexts, Intrinsically Typed ==\n\n}%\n\ntp : type.\nb : tp.\narr : tp -> tp -> tp.\n\ntm : tp -> type.\nval : tp -> type.\n\napp : tm (arr A B) -> tm A -> tm B.\nret : val A -> tm A.\nlam : (val A -> tm B) -> val (arr A B).\n\n%block tmb : some {A : tp} block {x : val A}.\n%worlds (tmb) (tm _) (val _).\n\nec : (tm A -> tm C) -> type.\nec/var  : ec ([x] x).\nec/app1 : ec ([x] app (E x) M)\n\t   <- ec E.\nec/app2 : ec ([x] app (ret V) (E x))\n\t   <- ec E.\n\nredex  : tm A -> type.\n%mode redex +X1.\nredex/beta : redex (app (ret V1) (ret V2)).\n\nfactored : tm A -> type.\nf/val : factored (ret V).\nf/ec  : factored (E M0)\n\t <- ec E\n\t <- redex M0.\n\nfactorapp : factored M1 -> factored M2 -> factored (app M1 M2) -> type.\n%mode factorapp +X1 +X2 -X3.\n\n- : factorapp\n     f/val\n     f/val \n     (f/ec redex/beta ec/var).\n\n- : factorapp\n     (f/ec (Dred0 : redex M0) (Dec : ec E))\n     (_ : factored M2)\n     (f/ec Dred0 (ec/app1 Dec)).\n\n- : factorapp\n     f/val\n     (f/ec (Dred0 : redex M0) (Dec : ec E))\n     (f/ec Dred0 (ec/app2 Dec)).\n\n%worlds () (factorapp _ _ _).\n%total {} (factorapp _ _ _).\n%unique factorapp +X1 +X2 -1X3.\n\nfactor : {M : tm A} factored M -> type.\n%mode factor +X1 -X2.\nfactor/val : factor (ret V) (f/val).\nfactor/app : factor (app E1 E2) F\n\t      <- factor E1 F1\n\t      <- factor E2 F2\n\t      <- factorapp F1 F2 F.\n%worlds () (factor _ _).\n%total M (factor M _).\n%unique factor +X1 -1X2.\n\nresult  : (tm A) -> type.\ndone    : result (ret V).\nstepped : tm A -> result M.\n\ncontract : redex (M : tm A) -> tm A -> type.\n%mode contract +X1 -X2.\n\n- : contract (redex/beta : redex (app (ret (lam M)) (ret V))) (M V).\n\n%worlds () (contract _ _).\n%total {} (contract _ _).\n%unique contract +X1 -1X2.\n\nstepf : factored (M : tm A) -> result M -> type.\n%mode stepf +X1 -X2.\n\n- : stepf f/val done.\n- : stepf (f/ec Dr (Dec : ec E)) (stepped (E Mred))\n     <- contract Dr Mred.\n\n%worlds () (stepf _ _).\n%total {} (stepf _ _).\n%unique stepf +X1 -1X2.\n\nstep : {M : tm A} result M -> type.\n%mode step +X1 -X2.\n\nstep/i : step M M'\n\t  <- factor M F\n\t  <- stepf F M'.\n\n%worlds () (step _ _).\n%total {} (step _ _).\n%unique step +X1 -1X2."
          },
          "sha1": "b3o4mc2is5hf19s58l8otnh8ddcxwds"
        }
      },
      {
        "title": "POPL Tutorial/Exceptions",
        "ns": 0,
        "id": 2116,
        "revision": {
          "id": 5828,
          "parentid": 5545,
          "timestamp": "2009-01-19T02:46:51Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 7019,
            "#text": "%{\n\nType safety for MinML: call-by-value, with recursive functions, in extrinsic form, with exceptions\n\n== Syntax ==\n\nTypes:\n\n}%\n\ntp : type.\t\t\t\t%name tp T.\nnat : tp.\narr : tp -> tp -> tp.\n\n%{\n\nRaw expressions, which admit ill-typed terms\n\n}%\n\nexp : type.\t\t\t\t%name exp E.\nz : exp.\ns : exp -> exp.\nifz : exp -> exp -> (exp -> exp) -> exp.\nfun : tp -> tp -> (exp -> exp -> exp) -> exp.\napp : exp -> exp -> exp.\nraise : tp -> exp.\nhandle : exp -> exp -> exp. \n\n%{\n\n== Static semantics ==\n\nA judgement picking out the well-typed terms:\n\n}%\n\nof : exp -> tp -> type.\t\t\t%name of Dof.\n%mode of +E -T.\n\nof/z\n   : of z nat.\nof/s\n   : of (s E) nat <- of E nat.\nof/ifz\n   : of (ifz E E1 ([x] E2 x)) T\n      <- of E nat\n      <- of E1 T\n      <- ({x:exp} of x nat -> of (E2 x) T).\nof/fun\n   : of (fun T1 T2 ([f] [x] E f x)) (arr T1 T2)\n      <- ({f:exp} of f (arr T1 T2) -> {x:exp} of x T1 -> of (E f x) T2).\nof/app\n   : of (app E1 E2) T\n      <- of E1 (arr T2 T)\n      <- of E2 T2.\nof/raise\n   : of (raise T) T.\nof/handle\n   : of (handle E1 E2) T\n      <- of E1 T\n      <- of E2 T. \n\n%{\n\n== Dynamic semantics ==\n\n}%\n\nvalue : exp -> type.\t\t\t%name value Dval.\n%mode value +E.\n\nvalue/z : value z.\nvalue/s : value (s E) <- value E.\nvalue/fun : value (fun _ _ _).\n\nraises : exp -> type.\n%mode raises +E.\n\nraises/raise   \n   : raises (raise T).\nraises/app/fun\n   : raises (app E1 E2)\n      <- raises E1.\nraises/app/arg\n   : raises (app E1 E2)\n      <- value E1 \n      <- raises E2.\nraises/s\n   : raises (s E)\n      <- raises E.\nraises/ifz\n   : raises (ifz E1 E2 E3)\n      <- raises E1. \n\nstep : exp -> exp -> type.\t\t%name step Dstep.\n%mode step +E1 -E2.\n\nstep/s\n   : step (s E) (s E') <- step E E'.\nstep/ifz/arg\n   : step (ifz E E1 ([x] E2 x)) (ifz E' E1 ([x] E2 x))\n      <- step E E'.\nstep/ifz/z\n   : step (ifz z E1 ([x] E2 x)) E1.\nstep/ifz/s\n   : step (ifz (s E) E1 ([x] E2 x)) (E2 E)\n      <- value E.\nstep/app/fun\n   : step (app E1 E2) (app E1' E2)\n      <- step E1 E1'.\nstep/app/arg\n   : step (app E1 E2) (app E1 E2')\n      <- value E1 <- step E2 E2'.\nstep/app/beta-v\n   : step\n      (app (fun T1 T2 ([f] [x] E f x)) E2)\n      (E (fun T1 T2 ([f] [x] E f x)) E2)\n      <- value E2.\nstep/handle/body\n   : step\n      (handle E1 E2)\n      (handle E1' E2)\n      <- step E1 E1'.\nstep/handle/raise\n   : step\n      (handle E1 E2)\n      E2\n      <- raises E1. \nstep/handle/body-v\n   : step\n      (handle E1 E2)\n      E1\n      <- value E1. \n\n%{\n\n== Preservation ==\n\nWith this encoding, we have to prove preservation explicitly, as the\ntype of <tt>step</tt> doesn't guarantee it.\n\n}%\n\npres : step E E' -> of E T -> of E' T -> type. %name pres Dpres.\n%mode pres +Dstep +Dof -Dof.\n\n- : pres\n     (step/s Dstep)\n     (of/s Dof)\n     (of/s Dof')\n     <- pres Dstep Dof Dof'.\n\n- : pres\n     (step/ifz/arg Dstep)\n     (of/ifz ([x] [dx] Dof2 x dx) Dof1 Dof)\n     (of/ifz ([x] [dx] Dof2 x dx) Dof1 Dof')\n     <- pres Dstep Dof Dof'.\n\n- : pres\n     step/ifz/z\n     (of/ifz _ Dof1 _)\n     Dof1.\n\n- : pres\n     (step/ifz/s (_ : value E))\n     (of/ifz ([x] [dx] Dof2 x dx) _ (of/s Dof))\n     (Dof2 E Dof).\n\n- : pres\n     (step/app/fun Dstep1)\n     (of/app Dof2 Dof1)\n     (of/app Dof2 Dof1')\n     <- pres Dstep1 Dof1 Dof1'.\n\n- : pres\n     (step/app/arg Dstep2 _)\n     (of/app Dof2 Dof1)\n     (of/app Dof2' Dof1)\n     <- pres Dstep2 Dof2 Dof2'.\n\n- : pres\n     (step/app/beta-v _)\n     (of/app\n\tDof2\n\t(of/fun [f] [df] [x] [dx] (Dof1 f df x dx)))\n     (Dof1\n\t_\n\t(of/fun [f] [df] [x] [dx] (Dof1 f df x dx))\n\t_\n\tDof2).\n\n- : pres \n     (step/handle/body Dstep)\n     (of/handle Dof2 Dof1)\n     (of/handle Dof2 Dof1')\n     <- pres Dstep Dof1 Dof1'.\n\n- : pres\n     (step/handle/raise Draise)\n     (of/handle Dof2 Dof1)\n     Dof2.\n\n- : pres\n     (step/handle/body-v Dval)\n     (of/handle Dof2 Dof1)\n     Dof1.\n\n%worlds () (pres Dstep Dof Dof').\n%total Dstep (pres Dstep _ _).\n\n%{\n\n== Progress ==\n\n}%\n\nval-or-raises-or-step : exp -> type.\t\t%name val-or-raises-or-step Dvrs.\nvrs/val : val-or-raises-or-step E <- value E.\nvrs/step : val-or-raises-or-step E <- step E _.\nvrs/raises : val-or-raises-or-step E <- raises E. \n%{\n\n=== [[Output factoring|Factoring lemmas]] ===\n\n}%\n\nprog/s\n   : val-or-raises-or-step E -> val-or-raises-or-step (s E) -> type.\n%mode prog/s +Dvrs1 -Dvrs2.\n\n- : prog/s\n     (vrs/step Dstep)\n     (vrs/step (step/s Dstep)).\n\n- : prog/s\n     (vrs/val Dval)\n     (vrs/val (value/s Dval)).\n\n- : prog/s\n     (vrs/raises Draises)\n     (vrs/raises (raises/s Draises)).\n\n%worlds () (prog/s _ _).\n%total {} (prog/s _ _).\n\nprog/ifz\n   :  of E nat\n      -> val-or-raises-or-step E\n      -> {E1} {E2} (val-or-raises-or-step (ifz E E1 ([x] E2 x)))\n      -> type.\n%mode prog/ifz +Dof +Dvrs +E1 +E2 -Dstep.\n\n- : prog/ifz _ (vrs/step Dstep) _ _ (vrs/step (step/ifz/arg Dstep)).\n- : prog/ifz _ (vrs/val value/z) _ _ (vrs/step step/ifz/z).\n- : prog/ifz _ (vrs/val (value/s Dval)) _ _ (vrs/step (step/ifz/s Dval)).\n- : prog/ifz _ (vrs/raises Draises) _ _ (vrs/raises (raises/ifz Draises)).\n%worlds () (prog/ifz _ _ _ _ _).\n%total {} (prog/ifz _ _ _ _ _).\n\nprog/app\n   : of E1 (arr T2 T)\n      -> val-or-raises-or-step E1\n      -> val-or-raises-or-step E2\n      -> val-or-raises-or-step (app E1 E2)\n      -> type.\n%mode prog/app +Dof +Dvrs1 +Dvrs2 -Dstep.\n\n- : prog/app\n     _\n     (vrs/step Dstep1)\n     _\n     (vrs/step (step/app/fun Dstep1)).\n\n- : prog/app\n     _\n     (vrs/val Dval1)\n     (vrs/step Dstep2)\n     (vrs/step (step/app/arg Dstep2 Dval1)).\n\n- : prog/app\n     _\n     (vrs/val Dval1)\n     (vrs/val Dval2)\n     (vrs/step (step/app/beta-v Dval2)).\n\n- : prog/app\n     _\n     (vrs/raises Draise1)\n     _\n     (vrs/raises (raises/app/fun Draise1)).\n\n- : prog/app\n     _\n     (vrs/val Dval1)\n     (vrs/raises Draise2)\n     (vrs/raises (raises/app/arg Draise2 Dval1)).\n\n%worlds () (prog/app _ _ _ _).\n%total {} (prog/app _ _ _ _).\n\nprog/handle\n   : val-or-raises-or-step E1\n      -> {E2} val-or-raises-or-step (handle E1 E2)\n      -> type.\n%mode prog/handle +Dvrs1 +E2 -Dvrs2.\n\n- : prog/handle (vrs/val Dval) _\n     (vrs/step (step/handle/body-v Dval)).\n\n- : prog/handle (vrs/raises Draise) _\n     (vrs/step (step/handle/raise Draise)).\n\n- : prog/handle (vrs/step Dstep) _\n     (vrs/step (step/handle/body Dstep)).\n\n%worlds () (prog/handle _ _ _).\n%total {} (prog/handle _ _ _). \n   \n%{\n\n=== Main theorem ===\n\n}%\n\nprog : of E T -> val-or-raises-or-step E -> type. %name prog Dprog.\n%mode prog +Dof -Dvrs.\n\n- : prog of/z (vrs/val value/z).\n\n- : prog (of/s Dof) Dvrs'\n     <- prog Dof Dvrs\n     <- prog/s Dvrs Dvrs'.\n\n- : prog (of/ifz ([x] [dx] Dof2 x dx) Dof1 Dof) Dvrs'\n     <- prog Dof Dvrs\n     <- prog/ifz Dof Dvrs _ _ Dvrs'.\n\n- : prog (of/fun _) (vrs/val value/fun).\n\n- : prog (of/app Dof2 Dof1) Dvrs3\n     <- prog Dof1 Dvrs1\n     <- prog Dof2 Dvrs2\n     <- prog/app Dof1 Dvrs1 Dvrs2 Dvrs3.\n\n- : prog (of/handle Dof2 Dof1) Dvrs2\n     <- prog Dof1 Dvrs1\n     <- prog/handle Dvrs1 _ Dvrs2.\n\n- : prog of/raise (vrs/raises raises/raise).\n\n%worlds () (prog _ _).\n%total Dof (prog Dof _).\n\n%{\n\nAnd thus we have proved type safety for minml with exceptions!\n\n}%"
          },
          "sha1": "ajra7693ky5sw5t6dtyrw7h4mypt6ug"
        }
      },
      {
        "title": "POPL Tutorial/Exceptions-problem",
        "ns": 0,
        "id": 2118,
        "revision": {
          "id": 5824,
          "parentid": 5699,
          "timestamp": "2009-01-18T08:05:22Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 7580,
            "#text": "%{\n\nType safety for MinML: call-by-value, with recursive functions, in extrinsic form, with exceptions.\n\nIn this example, we will take the MinML language from earlier and extend it with constructs for raising and handling exceptions. \n\nThe static semantics will be extended with rules to handle these new expressions. The structured operational semantics from before will be extended with a new judgment that denotes when an expression raises an uncaught exception. \n\nThe preservation and progress proofs must then be updated to\naccommodate the extensions to the language. \n\n== Syntax ==\n\nTypes:\n\n}%\n\ntp : type.\t\t\t\t%name tp T.\nnat : tp.\narr : tp -> tp -> tp.\n\n%{\n\nRaw expressions, which admit ill-typed terms\n\n}%\n\nexp : type.\t\t\t\t%name exp E.\nz : exp.\ns : exp -> exp.\nifz : exp -> exp -> (exp -> exp) -> exp.\nfun : tp -> tp -> (exp -> exp -> exp) -> exp.\napp : exp -> exp -> exp.\n\n%{\n\nWe will extend MinML with two constructs. The first, (raise T), is a term of type T that will raise an exception.\n\nThe second, (handle E1 E2), is a term that executes E1. If E1\nevaluates to a value V, then (handle E1 E2) evaluates to V. If E1\nraises an exception, then the handler E2 is executed. \n\n}%\n\nraise : tp -> exp.\nhandle : exp -> exp -> exp. \n\n%{\n\n== Static semantics ==\n\nA judgement picking out the well-typed terms:\n\n}%\n\nof : exp -> tp -> type.\t\t\t%name of Dof.\n%mode of +E -T.\n\nof/z\n   : of z nat.\nof/s\n   : of (s E) nat <- of E nat.\nof/ifz\n   : of (ifz E E1 ([x] E2 x)) T\n      <- of E nat\n      <- of E1 T\n      <- ({x:exp} of x nat -> of (E2 x) T).\nof/fun\n   : of (fun T1 T2 ([f] [x] E f x)) (arr T1 T2)\n      <- ({f:exp} of f (arr T1 T2) -> {x:exp} of x T1 -> of (E f x) T2).\nof/app\n   : of (app E1 E2) T\n      <- of E1 (arr T2 T)\n      <- of E2 T2.\n\n%{\n\nThe following are the new typing rules for (raise T) and (handle E1 E2).\n\n}%\n\nof/raise\n   : of (raise T) T.\nof/handle\n   : of (handle E1 E2) T\n      <- of E1 T\n      <- of E2 T. \n\n%{\n\n== Dynamic semantics ==\n\n}%\n\nvalue : exp -> type.\t\t\t%name value Dval.\n%mode value +E.\n\nvalue/z : value z.\nvalue/s : value (s E) <- value E.\nvalue/fun : value (fun _ _ _).\n\nraises : exp -> type.\n%mode raises +E.\n\nraises/raise   \n   : raises (raise T).\nraises/app/fun\n   : raises (app E1 E2)\n      <- raises E1.\nraises/app/arg\n   : raises (app E1 E2)\n      <- value E1 \n      <- raises E2.\n\n%{\nExercise: Give two rules, raises/s and raises/ifz, that propogate raises through the (s E) and (ifz E1 E2 E3) expressions. \n}%\n\n\nstep : exp -> exp -> type.\t\t%name step Dstep.\n%mode step +E1 -E2.\n\nstep/s\n   : step (s E) (s E') <- step E E'.\nstep/ifz/arg\n   : step (ifz E E1 ([x] E2 x)) (ifz E' E1 ([x] E2 x))\n      <- step E E'.\nstep/ifz/z\n   : step (ifz z E1 ([x] E2 x)) E1.\nstep/ifz/s\n   : step (ifz (s E) E1 ([x] E2 x)) (E2 E)\n      <- value E.\nstep/app/fun\n   : step (app E1 E2) (app E1' E2)\n      <- step E1 E1'.\nstep/app/arg\n   : step (app E1 E2) (app E1 E2')\n      <- value E1 <- step E2 E2'.\nstep/app/beta-v\n   : step\n      (app (fun T1 T2 ([f] [x] E f x)) E2)\n      (E (fun T1 T2 ([f] [x] E f x)) E2)\n      <- value E2.\n\n%{\n\nThe following are new step rules for the (handle E1 E2)\nexpression. There is one rule for stepping the body, another rule for\nhandling a raised exception, and a third rule for when the body is a\nvalue. \n\n}%\n\nstep/handle/body\n   : step\n      (handle E1 E2)\n      (handle E1' E2)\n      <- step E1 E1'.\nstep/handle/raise\n   : step\n      (handle E1 E2)\n      E2\n      <- raises E1. \nstep/handle/body-v\n   : step\n      (handle E1 E2)\n      E1\n      <- value E1. \n\n%{\n\n== Preservation ==\n\nWith this encoding, we have to prove preservation explicitly, as the\ntype of <tt>step</tt> doesn't guarantee it.\n\n}%\n\npres : step E E' -> of E T -> of E' T -> type. %name pres Dpres.\n%mode pres +Dstep +Dof -Dof.\n\n- : pres\n     (step/s Dstep)\n     (of/s Dof)\n     (of/s Dof')\n     <- pres Dstep Dof Dof'.\n\n- : pres\n     (step/ifz/arg Dstep)\n     (of/ifz ([x] [dx] Dof2 x dx) Dof1 Dof)\n     (of/ifz ([x] [dx] Dof2 x dx) Dof1 Dof')\n     <- pres Dstep Dof Dof'.\n\n- : pres\n     step/ifz/z\n     (of/ifz _ Dof1 _)\n     Dof1.\n\n- : pres\n     (step/ifz/s (_ : value E))\n     (of/ifz ([x] [dx] Dof2 x dx) _ (of/s Dof))\n     (Dof2 E Dof).\n\n- : pres\n     (step/app/fun Dstep1)\n     (of/app Dof2 Dof1)\n     (of/app Dof2 Dof1')\n     <- pres Dstep1 Dof1 Dof1'.\n\n- : pres\n     (step/app/arg Dstep2 _)\n     (of/app Dof2 Dof1)\n     (of/app Dof2' Dof1)\n     <- pres Dstep2 Dof2 Dof2'.\n\n- : pres\n     (step/app/beta-v _)\n     (of/app\n\tDof2\n\t(of/fun [f] [df] [x] [dx] (Dof1 f df x dx)))\n     (Dof1\n\t_\n\t(of/fun [f] [df] [x] [dx] (Dof1 f df x dx))\n\t_\n\tDof2).\n\n%{\n\nExercise: Give proof cases for step/handle/body, step/handle/body-v, and step/handle/raise.\n\n}%\n\n%worlds () (pres Dstep Dof Dof').\n%total Dstep (pres Dstep _ _).\n\n%{\n\n== Progress ==\n\n}%\n\nval-or-raises-or-step : exp -> type.\t\t%name val-or-raises-or-step Dvrs.\nvrs/val : val-or-raises-or-step E <- value E.\nvrs/step : val-or-raises-or-step E <- step E _.\n\n%{\n\nval-or-raises-or-step must have a case for when an expression raises an exception. \n\n}%\n\nvrs/raises : val-or-raises-or-step E <- raises E. \n%{\n\n=== [[Output factoring|Factoring lemmas]] ===\n\n}%\n\nprog/s\n   : val-or-raises-or-step E -> val-or-raises-or-step (s E) -> type.\n%mode prog/s +Dvrs1 -Dvrs2.\n\n- : prog/s\n     (vrs/step Dstep)\n     (vrs/step (step/s Dstep)).\n\n- : prog/s\n     (vrs/val Dval)\n     (vrs/val (value/s Dval)).\n\n%{\n\nA new case for when the input is an unhandled exception must be provided. \n\n}%\n\n- : prog/s\n     (vrs/raises Draises)\n     (vrs/raises (raises/s Draises)).\n\n%worlds () (prog/s _ _).\n%total {} (prog/s _ _).\n\nprog/ifz\n   :  of E nat\n      -> val-or-raises-or-step E\n      -> {E1} {E2} (val-or-raises-or-step (ifz E E1 ([x] E2 x)))\n      -> type.\n%mode prog/ifz +Dof +Dvrs +E1 +E2 -Dstep.\n\n- : prog/ifz _ (vrs/step Dstep) _ _ (vrs/step (step/ifz/arg Dstep)).\n- : prog/ifz _ (vrs/val value/z) _ _ (vrs/step step/ifz/z).\n- : prog/ifz _ (vrs/val (value/s Dval)) _ _ (vrs/step (step/ifz/s Dval)).\n\n%{ A new case for when the input is an unhandled exception must be provided. }%\n\n- : prog/ifz _ (vrs/raises Draises) _ _ (vrs/raises (raises/ifz Draises)).\n%worlds () (prog/ifz _ _ _ _ _).\n%total {} (prog/ifz _ _ _ _ _).\n\nprog/app\n   : of E1 (arr T2 T)\n      -> val-or-raises-or-step E1\n      -> val-or-raises-or-step E2\n      -> val-or-raises-or-step (app E1 E2)\n      -> type.\n%mode prog/app +Dof +Dvrs1 +Dvrs2 -Dstep.\n\n- : prog/app\n     _\n     (vrs/step Dstep1)\n     _\n     (vrs/step (step/app/fun Dstep1)).\n\n- : prog/app\n     _\n     (vrs/val Dval1)\n     (vrs/step Dstep2)\n     (vrs/step (step/app/arg Dstep2 Dval1)).\n\n- : prog/app\n     _\n     (vrs/val Dval1)\n     (vrs/val Dval2)\n     (vrs/step (step/app/beta-v Dval2)).\n\n%{  \n\nExercise: Give the missing cases for when the inputs are unhandled exceptions.\n\n}%\n\n%worlds () (prog/app _ _ _ _).\n%total {} (prog/app _ _ _ _).\n\n   \n%{\n\n=== Main theorem ===\n\n}%\n\nprog : of E T -> val-or-raises-or-step E -> type. %name prog Dprog.\n%mode prog +Dof -Dvrs.\n\n- : prog of/z (vrs/val value/z).\n\n- : prog (of/s Dof) Dvrs'\n     <- prog Dof Dvrs\n     <- prog/s Dvrs Dvrs'.\n\n- : prog (of/ifz ([x] [dx] Dof2 x dx) Dof1 Dof) Dvrs'\n     <- prog Dof Dvrs\n     <- prog/ifz Dof Dvrs _ _ Dvrs'.\n\n- : prog (of/fun _) (vrs/val value/fun).\n\n- : prog (of/app Dof2 Dof1) Dvrs3\n     <- prog Dof1 Dvrs1\n     <- prog Dof2 Dvrs2\n     <- prog/app Dof1 Dvrs1 Dvrs2 Dvrs3.\n\n%{\n\nExercise: Give the missing cases for of/handle and of/raise. It may be necessary to use a factoring lemma in the solution for the case corresponding to of/handle. \n\n}%\n\n%worlds () (prog _ _).\n%total Dof (prog Dof _)."
          },
          "sha1": "m42oygp3hux3woxukjlzrfun1lcrdsu"
        }
      },
      {
        "title": "POPL Tutorial/MinML",
        "ns": 0,
        "id": 2151,
        "revision": {
          "id": 7950,
          "parentid": 5836,
          "timestamp": "2013-08-08T11:46:17Z",
          "contributor": {
            "username": "Namin",
            "id": 10184
          },
          "comment": "fix link",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 294,
            "#text": "* [[POPL Tutorial/MinML encoding| MinML Syntax and judgments---the code we just wrote]]\n\n* [http://twelf.org/w/index.php?title=POPL_Tutorial/MinML_Starter&action=raw&ctype=text/css Starter code]: start here if you don't want to type along\n* [[POPL Tutorial/MinML Answer|Solutions to exercises]]"
          },
          "sha1": "oh89t5xaghw0f59c3x5x9q6dyv5xu6d"
        }
      },
      {
        "title": "POPL Tutorial/MinML Answer",
        "ns": 0,
        "id": 2147,
        "revision": {
          "id": 5744,
          "parentid": 5743,
          "timestamp": "2009-01-17T02:54:43Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "minor": null,
          "comment": "[[POPL Tutorial/MinML]] moved to [[POPL Tutorial/MinML Answer]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 4400,
            "#text": "%{\n\n== Syntax ==\n\n}%\n\ntp : type.\t\t\t\t%name tp T.\nnum : tp.\narr : tp -> tp -> tp.\n\n%% you can world-check syntax if you want\n%worlds () (tp).\n\nexp : type.\t\t\t\t%name exp E.\nfn : tp -> (exp -> exp) -> exp.\napp : exp -> exp -> exp.\nz : exp.\ns : exp -> exp.\n\n%{\n==== Exercise: constant for ifz ====\n}%\n\nifz : exp -> exp -> (exp -> exp) -> exp.\n\n%% you can world-check syntax if you want\n%block exp_block : block {x:exp}.\n%worlds (exp_block) (exp).\n\n%{\n\n== Static semantics ==\n\n}%\n\nof : exp -> tp -> type.                %name of Dof.\n\nof/z : of z num.\n\nof/app : of (app E1 E2) T\n\t  <- of E1 (arr T' T)\n\t  <- of E2 T'.\n\nof/fn : of (fn T1 ([x] E x)) (arr T1 T2)\n\t <- ({x:exp} of x T1 -> of (E x) T2).\n\n%{ \n==== Exercise: typing rules for s and ifz ====\n}%\n\nof/s : of (s E) num\n\t<- of E num.\n\nof/ifz : of (ifz E E0 ([x] E1 x)) T\n\t  <- of E num\n\t  <- of E0 T\n\t  <- ({x:exp} of x num -> of (E1 x) T).\n\n%block of_block : some {T:tp} block {x:exp}{dx: of x T}.\n%worlds (of_block) (of _ _).\n\n%{\n\n== Dynamic semantics ==\n\n=== value judgement ===\n\n\n}%\n\nvalue : exp -> type.               %name value Dval.\n\nvalue/fn : value (fn T ([x] E x)).\n%{ \n==== Exercise: value rules for z and s ====\n}%\nvalue/z  : value z.\nvalue/s  : value (s E)\n\t    <- value E.\n\n%{\n\n=== step judgement ===\n\n}%\n\nstep : exp -> exp -> type.        %name step Dstep.\n\nstep/app/fn : step (app E1 E2) (app E1' E2)\n\t       <- step E1 E1'.\n\nstep/app/arg : step (app E1 E2) (app E1 E2')\n\t\t<- value E1\n\t\t<- step E2 E2'.\n\nstep/app/beta : step (app (fn T ([x] E x)) E2) (E E2)\n\t\t <- value E2.\n\n%{ \n==== Exercise: step rules for s and ifz ====\n}%\n\nstep/s : step (s E) (s E')\n\t  <- step E E'.\n\nstep/ifz/arg : step (ifz E E0 ([x] E1 x)) (ifz E' E0 ([x] E1 x))\n\t\t<- step E E'.\n\nstep/ifz/z   : step (ifz z E0 ([x] E1 x)) E0.\n\nstep/ifz/s   : step (ifz (s E) E0 ([x] E1 x)) (E1 E)\n\t\t<- value E.\n\n%{ \n\n== Progress theorem ==\n\n=== Sum type for the result ===\n\n}%\n\nval-or-step : exp -> type.        %name val-or-step Dvos.\n\nvos/value : val-or-step E\n\t     <- value E.\nvos/step  : val-or-step E\n\t     <- step E E'.\n\n%{\n\n=== Lemmas ===\n\n}%\n\nprog/app : of E1 (arr T' T) \n\t    -> val-or-step E1\n\t    -> val-or-step E2\n\t    -> val-or-step (app E1 E2)\n\t    -> type.\n%mode prog/app +Dof +Dvos1 +Dvos2 -Dvos.\n\n- : prog/app \n     _ \n     (vos/step (Dstep1 : step E1 E1'))\n     _\n     (vos/step (step/app/fn Dstep1)).\n\n- : prog/app\n     _\n     (vos/value (Dval1 : value E1))\n     (vos/step (Dstep2 : step E2 E2'))\n     (vos/step (step/app/arg Dstep2 Dval1)).\n\n- : prog/app\n     (of/fn _ : of (fn T ([x] E' x)) (arr T T'))\n     (vos/value (Dval1 : value (fn T ([x] E' x))))\n     (vos/value (Dval2 : value E2))\n     (vos/step (step/app/beta Dval2)).\n\n%worlds () (prog/app _ _ _ _).\n%total {} (prog/app _ _ _ _).\n\n%{\n\n==== Exercise: lemma for s ====\n\n}%\n\nprog/s : val-or-step E -> val-or-step (s E) -> type.\n%mode prog/s +Dvos1 -Dvos2.\n\n- : prog/s\n     (vos/step (Dstep : step E E'))\n     (vos/step (step/s Dstep)).\n\n- : prog/s\n     (vos/value (Dval : value E))\n     (vos/value (value/s Dval)).\n\n%worlds () (prog/s _ _).\n%total {} (prog/s _ _).\n\n%{\n\n==== Exercise: lemma for ifz ====\n\n}%\n\nprog/ifz : of E num\n \t    -> {E0:exp} \n \t       {E1:exp -> exp}\n\t       val-or-step E\n\t    -> step (ifz E E0 ([x] E1 x)) E'\n\t    -> type.\n%mode prog/ifz +Dof +E0 +E1 \n+Dvos -Dstep.\n\n%mode prog/ifz +Dof +Dvos +E1 +E2 -Dstep.\n\n- : prog/ifz _ _ _ (vos/step Dstep) (step/ifz/arg Dstep).\n- : prog/ifz _ _ _ (vos/value value/z) step/ifz/z.\n- : prog/ifz _ _ _ (vos/value (value/s Dval)) (step/ifz/s Dval).\n\n%worlds () (prog/ifz _ _ _ _ _).\n%total {} (prog/ifz _ _ _ _ _).\n\n%{\n\n=== Main theorem ===\n\n}%\n\nprog : of E T -> val-or-step E -> type.\n%mode prog +Dof -Dvos.\n\n- : prog (of/z : of z num) (vos/value (value/z : value z)).\n\n- : prog (of/fn _) (vos/value value/fn).\n\n- : prog (of/app \n\t    (D2 : of E2 T') \n\t    (D1 : of E1 (arr T' T)))\n     DvosApp\n     <- prog D1 (Dvos1 : val-or-step E1)\n     <- prog D2 (Dvos2 : val-or-step E2)\n     <- prog/app D1 Dvos1 Dvos2 DvosApp.\n\n%{ \n\n==== Exercise: cases for s and ifz ====\n\n}%\n\n- : prog (of/s (D : of E num)) DvosS\n     <- prog D (Dvos : val-or-step E)\n     <- prog/s Dvos DvosS.\n\n- : prog (of/ifz ([x] [dx : of x num] (D1 x dx : of (E1 x) T)) \n\t    (D0 : of E0 T)\n\t    (D  : of E num))\n     (vos/step DstepIfz)\n     <- prog D (Dvos : val-or-step E)\n     <- prog/ifz D E0 ([x] E1 x) Dvos DstepIfz.\n\n%worlds () (prog _ _).\n%total Dof (prog Dof _)."
          },
          "sha1": "poeppwwl1bwxest6vcj5x7u7hgr2tf8"
        }
      },
      {
        "title": "POPL Tutorial/MinML Encoding",
        "ns": 0,
        "id": 2167,
        "redirect": {
          "@title": "POPL Tutorial/MinML encoding",
          "#text": null
        },
        "revision": {
          "id": 5835,
          "timestamp": "2009-01-19T20:38:20Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "[[POPL Tutorial/MinML Encoding]] moved to [[POPL Tutorial/MinML encoding]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 42,
            "#text": "#REDIRECT [[POPL Tutorial/MinML encoding]]"
          },
          "sha1": "dtf6w6admrs1qwz070kc5sc1txj54z9"
        }
      },
      {
        "title": "POPL Tutorial/MinML Preservation Theorem",
        "ns": 0,
        "id": 2163,
        "revision": {
          "id": 5812,
          "parentid": 5806,
          "timestamp": "2009-01-18T07:09:44Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 1849,
            "#text": "%{\n\nIn this exercise, we prove the preservation theorem for the MinML langauge we worked with before.\n\nThere is one task:\n* Complete the cases of the preservation theorem\n\nThe solution is [[POPL Tutorial/MinML Preservation Theorem Answer | here]].\n\n== Syntax ==\n\nTypes:\n\n}%\n\ntp : type.\t\t\t\t%name tp T.\nnat : tp.\narr : tp -> tp -> tp.\n\n%{\n\nExpressions\n\n}%\n\nexp : type.\t\t\t\t%name exp E.\nfn : tp -> (exp -> exp) -> exp.\napp : exp -> exp -> exp.\nz : exp.\ns : exp -> exp.\nifz : exp -> exp -> (exp -> exp) -> exp.\n\n%{\n\n== Static semantics ==\n\n}%\n\nof : exp -> tp -> type.\t\t\t%name of Dof.\n%mode of +E -T.\n\nof/z : of z nat.\nof/fn : of (fn T1 ([x] E x)) (arr T1 T2)\n\t <- ({x:exp} of x T1 -> of (E x) T2).\nof/app : of (app E1 E2) T\n      <- of E1 (arr T2 T)\n      <- of E2 T2.\nof/s : of (s E) nat \n\t<- of E nat.\nof/ifz : of (ifz E E1 ([x] E2 x)) T\n\t  <- of E nat\n\t  <- of E1 T\n\t  <- ({x:exp} of x nat -> of (E2 x) T).\n\n%{\n\n== Dynamic semantics ==\n\n}%\n\nvalue : exp -> type.\t\t\t%name value Dval.\n%mode value +E.\n\nvalue/z : value z.\nvalue/s : value (s E) \n\t   <- value E.\nvalue/fn : value (fn _ _).\n\nstep : exp -> exp -> type.\t\t%name step Dstep.\n%mode step +E1 -E2.\n\nstep/app/fn : step (app E1 E2) (app E1' E2)\n\t       <- step E1 E1'.\nstep/app/arg : step (app E1 E2) (app E1 E2')\n\t\t<- value E1 <- step E2 E2'.\nstep/app/beta : step (app (fn _ ([x] E x)) E2) (E E2)\n\t\t <- value E2.\nstep/s : step (s E) (s E') \n\t  <- step E E'.\nstep/ifz/arg : step (ifz E E1 ([x] E2 x)) (ifz E' E1 ([x] E2 x))\n\t\t<- step E E'.\nstep/ifz/z : step (ifz z E1 ([x] E2 x)) E1.\nstep/ifz/s : step (ifz (s E) E1 ([x] E2 x)) (E2 E)\n\t      <- value E.\n\n%{\n\n== Preservation ==\n\n==== TASK 1: Fill in missing cases ====\n\n}%\n\npres : step E E' -> of E T -> of E' T -> type. %name pres Dpres.\n%mode pres +Dstep +Dof -Dof.\n\n% fill in here.\n\n%worlds () (pres Dstep Dof Dof').\n%total Dstep (pres Dstep _ _)."
          },
          "sha1": "5n2kg655k0ugfzu8g6pgpajj95fza3e"
        }
      },
      {
        "title": "POPL Tutorial/MinML Preservation Theorem: Solution",
        "ns": 0,
        "id": 2164,
        "revision": {
          "id": 5826,
          "parentid": 5807,
          "timestamp": "2009-01-19T02:19:03Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 2396,
            "#text": "%{This is the solution to [[POPL_Tutorial/MinML_Preservation_Theorem|this exercise]].\n\nType safety for MinML\n\n|hidden = true}%\n\n%% Syntax %%\n\ntp : type.\t\t\t\t%name tp T.\nnat : tp.\narr : tp -> tp -> tp.\n\n%% Expressions %%\n\nexp : type.\t\t\t\t%name exp E.\nfn : tp -> (exp -> exp) -> exp.\napp : exp -> exp -> exp.\nz : exp.\ns : exp -> exp.\nifz : exp -> exp -> (exp -> exp) -> exp.\n\n%% Static semantics %%\n\nof : exp -> tp -> type.\t\t\t%name of Dof.\n%mode of +E -T.\n\nof/z : of z nat.\nof/fn : of (fn T1 ([x] E x)) (arr T1 T2)\n\t <- ({x:exp} of x T1 -> of (E x) T2).\nof/app : of (app E1 E2) T\n      <- of E1 (arr T2 T)\n      <- of E2 T2.\nof/s : of (s E) nat \n\t<- of E nat.\nof/ifz : of (ifz E E1 ([x] E2 x)) T\n\t  <- of E nat\n\t  <- of E1 T\n\t  <- ({x:exp} of x nat -> of (E2 x) T).\n\n%% Dynamic semantics %%\n\nvalue : exp -> type.\t\t\t%name value Dval.\n%mode value +E.\n\nvalue/z : value z.\nvalue/s : value (s E) \n\t   <- value E.\nvalue/fn : value (fn _ _).\n\nstep : exp -> exp -> type.\t\t%name step Dstep.\n%mode step +E1 -E2.\n\nstep/app/fn : step (app E1 E2) (app E1' E2)\n\t       <- step E1 E1'.\nstep/app/arg : step (app E1 E2) (app E1 E2')\n\t\t<- value E1 <- step E2 E2'.\nstep/app/beta : step (app (fn _ ([x] E x)) E2) (E E2)\n\t\t <- value E2.\nstep/s : step (s E) (s E') \n\t  <- step E E'.\nstep/ifz/arg : step (ifz E E1 ([x] E2 x)) (ifz E' E1 ([x] E2 x))\n\t\t<- step E E'.\nstep/ifz/z : step (ifz z E1 ([x] E2 x)) E1.\nstep/ifz/s : step (ifz (s E) E1 ([x] E2 x)) (E2 E)\n\t      <- value E.\n\n%{ \n\n== Preservation ==\n\n}%\n\npres : step E E' -> of E T -> of E' T -> type. %name pres Dpres.\n%mode pres +Dstep +Dof -Dof.\n\n- : pres\n     (step/s Dstep)\n     (of/s Dof)\n     (of/s Dof')\n     <- pres Dstep Dof Dof'.\n\n- : pres\n     (step/ifz/arg Dstep)\n     (of/ifz ([x] [dx] Dof2 x dx) Dof1 Dof)\n     (of/ifz ([x] [dx] Dof2 x dx) Dof1 Dof')\n     <- pres Dstep Dof Dof'.\n\n- : pres\n     step/ifz/z\n     (of/ifz _ Dof1 _)\n     Dof1.\n\n- : pres\n     (step/ifz/s (_ : value E))\n     (of/ifz ([x] [dx] Dof2 x dx) _ (of/s Dof))\n     (Dof2 E Dof).\n\n- : pres\n     (step/app/fn Dstep1)\n     (of/app Dof2 Dof1)\n     (of/app Dof2 Dof1')\n     <- pres Dstep1 Dof1 Dof1'.\n\n- : pres\n     (step/app/arg Dstep2 _)\n     (of/app Dof2 Dof1)\n     (of/app Dof2' Dof1)\n     <- pres Dstep2 Dof2 Dof2'.\n\n- : pres\n     (step/app/beta _)\n     (of/app\n\tDof2\n\t(of/fn [x] [dx] (Dof1 x dx)))\n     (Dof1 _ Dof2).\n\n%worlds () (pres Dstep Dof Dof').\n%total Dstep (pres Dstep _ _)."
          },
          "sha1": "pj5x9s7hb1agyafrncoq2mq0h1ffgu2"
        }
      },
      {
        "title": "POPL Tutorial/MinML Preservation Theorem Answer",
        "ns": 0,
        "id": 2165,
        "redirect": {
          "@title": "POPL Tutorial/MinML Preservation Theorem: Solution",
          "#text": null
        },
        "revision": {
          "id": 5808,
          "timestamp": "2009-01-18T06:42:57Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "[[POPL Tutorial/MinML Preservation Theorem Answer]] moved to [[POPL Tutorial/MinML Preservation Theorem: Solution]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 64,
            "#text": "#REDIRECT [[POPL Tutorial/MinML Preservation Theorem: Solution]]"
          },
          "sha1": "tm4ztrx4b241cqqvrhvc3a9oqinnjmr"
        }
      },
      {
        "title": "POPL Tutorial/MinML Starter",
        "ns": 0,
        "id": 2152,
        "revision": {
          "id": 5790,
          "parentid": 5748,
          "timestamp": "2009-01-18T06:09:06Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 2862,
            "#text": "%{\n\n== Syntax ==\n\n}%\n\ntp : type.\t\t\t\t%name tp T.\nnum : tp.\narr : tp -> tp -> tp.\n\nexp : type.\t\t\t\t%name exp E.\nfn : tp -> (exp -> exp) -> exp.\napp : exp -> exp -> exp.\nz : exp.\ns : exp -> exp.\n\n%{\n==== Exercise: constant for ifz ====\n}%\n\n%% The syntax '% .' (without the space)\n%% causes Twelf to stop processing the file at this point\n%% remove once you have completed the exercise\n%.\n\n%{\n\n== Static semantics ==\n\n}%\n\nof : exp -> tp -> type.                %name of Dof.\n\nof/z : of z num.\n\nof/app : of (app E1 E2) T\n\t  <- of E1 (arr T' T)\n\t  <- of E2 T'.\n\nof/fn : of (fn T1 ([x] E x)) (arr T1 T2)\n\t <- ({x:exp} of x T1 -> of (E x) T2).\n\n%{ \n==== Exercise: typing rules for s and ifz ====\n}%\n\n\n\n\n\n\n\n\n\n\n%block of_block : some {T:tp} block {x:exp}{dx: of x T}.\n%worlds (of_block) (of _ _).\n\n%{\n\n== Dynamic semantics ==\n\n=== value judgement ===\n\n\n}%\n\nvalue : exp -> type.               %name value Dval.\n\nvalue/fn : value (fn T ([x] E x)).\n%{ \n==== Exercise: value rules for z and s ====\n}%\n\n\n\n\n\n\n\n%{\n\n=== step judgement ===\n\n}%\n\nstep : exp -> exp -> type.        %name step Dstep.\n\nstep/app/fn : step (app E1 E2) (app E1' E2)\n\t       <- step E1 E1'.\n\nstep/app/arg : step (app E1 E2) (app E1 E2')\n\t\t<- value E1\n\t\t<- step E2 E2'.\n\nstep/app/beta : step (app (fn T ([x] E x)) E2) (E E2)\n\t\t <- value E2.\n\n%{ \n==== Exercise: step rules for s and ifz ====\n}%\n\n\n\n\n\n\n%{ \n\n== Progress theorem ==\n\n=== Sum type for the result ===\n\n}%\n\nval-or-step : exp -> type.        %name val-or-step Dvos.\n\nvos/value : val-or-step E\n\t     <- value E.\nvos/step  : val-or-step E\n\t     <- step E E'.\n\n%{\n\n=== Lemmas ===\n\n}%\n\nprog/app : of E1 (arr T' T) \n\t    -> val-or-step E1\n\t    -> val-or-step E2\n\t    -> val-or-step (app E1 E2)\n\t    -> type.\n%mode prog/app +Dof +Dvos1 +Dvos2 -Dvos.\n\n- : prog/app \n     _ \n     (vos/step (Dstep1 : step E1 E1'))\n     _\n     (vos/step (step/app/fn Dstep1)).\n\n- : prog/app\n     _\n     (vos/value (Dval1 : value E1))\n     (vos/step (Dstep2 : step E2 E2'))\n     (vos/step (step/app/arg Dstep2 Dval1)).\n\n- : prog/app\n     (of/fn _ : of (fn T ([x] E' x)) (arr T T'))\n     (vos/value (Dval1 : value (fn T ([x] E' x))))\n     (vos/value (Dval2 : value E2))\n     (vos/step (step/app/beta Dval2)).\n\n%worlds () (prog/app _ _ _ _).\n%total {} (prog/app _ _ _ _).\n\n%{\n\n==== Exercise: lemma for s ====\n\n}%\n\n\n\n\n\n\n\n\n%{\n\n==== Exercise: lemma for ifz ====\n\n}%\n\n\n\n\n\n\n\n\n%{\n\n=== Main theorem ===\n\n}%\n\nprog : of E T -> val-or-step E -> type.\n%mode prog +Dof -Dvos.\n\n- : prog (of/z : of z num) (vos/value (value/z : value z)).\n\n- : prog (of/fn _) (vos/value value/fn).\n\n- : prog (of/app \n\t    (D2 : of E2 T') \n\t    (D1 : of E1 (arr T' T)))\n     DvosApp\n     <- prog D1 (Dvos1 : val-or-step E1)\n     <- prog D2 (Dvos2 : val-or-step E2)\n     <- prog/app D1 Dvos1 Dvos2 DvosApp.\n\n%{ \n\n==== Exercise: cases for s and ifz ====\n\n}%\n\n\n\n\n\n\n\n\n%worlds () (prog _ _).\n%total Dof (prog Dof _)."
          },
          "sha1": "a70uv5neci3ow7z5weoyj3gtc1zvfsl"
        }
      },
      {
        "title": "POPL Tutorial/MinML encoding",
        "ns": 0,
        "id": 2166,
        "revision": {
          "id": 5837,
          "parentid": 5834,
          "timestamp": "2009-01-19T21:24:56Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 3323,
            "#text": "%{\n\n== Syntax ==\n\n}%\n\ntp : type.\t\t\t\t%name tp T.\nnum : tp.\narr : tp -> tp -> tp.\n\n%% you can world-check syntax if you want\n%worlds () (tp).\n\nexp : type.\t\t\t\t%name exp E.\nfn : tp -> (exp -> exp) -> exp.\napp : exp -> exp -> exp.\nz : exp.\ns : exp -> exp.\n\n%{\n==== Exercise: constant for ifz ====\n}%\n\nifz : exp -> exp -> (exp -> exp) -> exp.\n\n%% you can world-check syntax if you want\n%block exp_block : block {x:exp}.\n%worlds (exp_block) (exp).\n\n%{\n\n== Static semantics ==\n\n}%\n\nof : exp -> tp -> type.                %name of Dof.\n\nof/z : of z num.\n\nof/app : of (app E1 E2) T\n\t  <- of E1 (arr T' T)\n\t  <- of E2 T'.\n\nof/fn : of (fn T1 ([x] E x)) (arr T1 T2)\n\t <- ({x:exp} of x T1 -> of (E x) T2).\n\n%{ \n==== Exercise: typing rules for s and ifz ====\n}%\n\nof/s : of (s E) num\n\t<- of E num.\n\nof/ifz : of (ifz E E0 ([x] E1 x)) T\n\t  <- of E num\n\t  <- of E0 T\n\t  <- ({x:exp} of x num -> of (E1 x) T).\n\n%block of_block : some {T:tp} block {x:exp}{dx: of x T}.\n%worlds (of_block) (of _ _).\n\n%{\n\n== Dynamic semantics ==\n\n=== value judgement ===\n\n\n}%\n\nvalue : exp -> type.               %name value Dval.\n\nvalue/fn : value (fn T ([x] E x)).\n%{ \n==== Exercise: value rules for z and s ====\n}%\nvalue/z  : value z.\nvalue/s  : value (s E)\n\t    <- value E.\n\n%{\n\n=== step judgement ===\n\n}%\n\nstep : exp -> exp -> type.        %name step Dstep.\n\nstep/app/fn : step (app E1 E2) (app E1' E2)\n\t       <- step E1 E1'.\n\nstep/app/arg : step (app E1 E2) (app E1 E2')\n\t\t<- value E1\n\t\t<- step E2 E2'.\n\nstep/app/beta : step (app (fn T ([x] E x)) E2) (E E2)\n\t\t <- value E2.\n\n%{ \n==== Exercise: step rules for s and ifz ====\n}%\n\nstep/s : step (s E) (s E')\n\t  <- step E E'.\n\nstep/ifz/arg : step (ifz E E0 ([x] E1 x)) (ifz E' E0 ([x] E1 x))\n\t\t<- step E E'.\n\nstep/ifz/z   : step (ifz z E0 ([x] E1 x)) E0.\n\nstep/ifz/s   : step (ifz (s E) E0 ([x] E1 x)) (E1 E)\n\t\t<- value E.\n\n%{ \n\n== Progress theorem ==\n\n=== Sum type for the result ===\n\n}%\n\nval-or-step : exp -> type.        %name val-or-step Dvos.\n\nvos/value : val-or-step E\n\t     <- value E.\nvos/step  : val-or-step E\n\t     <- step E E'.\n\n%{\n\n=== Lemmas ===\n\n}%\n\nprog/app : of E1 (arr T' T) \n\t    -> val-or-step E1\n\t    -> val-or-step E2\n\t    -> val-or-step (app E1 E2)\n\t    -> type.\n%mode prog/app +Dof +Dvos1 +Dvos2 -Dvos.\n\n- : prog/app \n     _ \n     (vos/step (Dstep1 : step E1 E1'))\n     _\n     (vos/step (step/app/fn Dstep1)).\n\n- : prog/app\n     _\n     (vos/value (Dval1 : value E1))\n     (vos/step (Dstep2 : step E2 E2'))\n     (vos/step (step/app/arg Dstep2 Dval1)).\n\n- : prog/app\n     (of/fn _ : of (fn T ([x] E' x)) (arr T T'))\n     (vos/value (Dval1 : value (fn T ([x] E' x))))\n     (vos/value (Dval2 : value E2))\n     (vos/step (step/app/beta Dval2)).\n\n%worlds () (prog/app _ _ _ _).\n%total {} (prog/app _ _ _ _).\n\n%{\n\n==== Exercise: lemma for s ====\n\n}%\n\n\n%{\n\n==== Exercise: lemma for ifz ====\n\n}%\n\n%{\n\n=== Main theorem ===\n\n}%\n\nprog : of E T -> val-or-step E -> type.\n%mode prog +Dof -Dvos.\n\n- : prog (of/z : of z num) (vos/value (value/z : value z)).\n\n- : prog (of/fn _) (vos/value value/fn).\n\n- : prog (of/app \n\t    (D2 : of E2 T') \n\t    (D1 : of E1 (arr T' T)))\n     DvosApp\n     <- prog D1 (Dvos1 : val-or-step E1)\n     <- prog D2 (Dvos2 : val-or-step E2)\n     <- prog/app D1 Dvos1 Dvos2 DvosApp.\n\n%{ \n\n==== Exercise: cases for s and ifz ====\n\n}%\n\n%worlds () (prog _ _).\n%total Dof (prog Dof _)."
          },
          "sha1": "5gds9pz94j4x6mzzq7e6h47xz1s3iy0"
        }
      },
      {
        "title": "POPL Tutorial/Nat",
        "ns": 0,
        "id": 2146,
        "revision": {
          "id": 5718,
          "timestamp": "2009-01-06T02:41:12Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "comment": "New page: %{  == Nats ==  }%  nat  : type. zero : nat. succ : nat -> nat.  %{  == Add ==  }%  add : nat -> nat -> nat -> type. add/z : add zero N N. add/s : add (succ M) N (succ O) \t <- add M N O.  ...",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 1432,
            "#text": "%{\n\n== Nats ==\n\n}%\n\nnat  : type.\nzero : nat.\nsucc : nat -> nat.\n\n%{\n\n== Add ==\n\n}%\n\nadd : nat -> nat -> nat -> type.\nadd/z : add zero N N.\nadd/s : add (succ M) N (succ O)\n\t <- add M N O.\n\n%mode add +M +N -O.\n%worlds () (add _ _ _).\n%total M (add M _ _).\n\n%{\n\n== Exercise: Mult ==\n\n}%\n\nmult : nat -> nat -> nat -> type.\nmult/z : mult zero N zero.\nmult/s : mult (succ M) N O'\n\t  <- mult M N O\n\t  <- add N O O'.\n\n%mode mult +M +N -O.\n%worlds () (mult _ _ _).\n%total M (mult M _ _).\n\n%{\n\n== Right-hand Identity ==\n\n}%\n\nrhzero : {M : nat} add M zero M -> type.\n%mode rhzero +M -D.\n\n- : rhzero zero add/z.\n- : rhzero (succ M) (add/s D)\n     <- rhzero M (D : add M zero M).\n     \n%worlds () (rhzero _ _).\n%total M (rhzero M _).\n\n%{\n\n== Right-hand succ ==\n\n}%\n\nrhsucc : add M N O -> add M (succ N) (succ O) -> type.\n%mode rhsucc +D1 -D2.\n\n- : rhsucc (add/z : add zero M M) (add/z : add zero (succ M) (succ M)).\n- : rhsucc (add/s (D1 : add M N O) : add (succ M) N (succ O))\n     (add/s D2)\n     <- rhsucc D1 (D2 : add M (succ N) (succ O)).\n     \n%worlds () (rhsucc _ _).\n%total M (rhsucc M _).\n\n%{\n\n== Exercise: put it all together ==\n\n}%\n\ncommute : add M N O -> add N M O -> type.\n%mode commute +D1 -D2.\n\n- : commute (add/z : add zero M M) D\n     <- rhzero M D.\n\n- : commute (add/s (D : add M N O)) D''\n     <- commute D  (D' : add N M O)\n     <- rhsucc D' (D'' : add N (succ M) (succ O)).\n\n%worlds () (commute _ _).\n%total D (commute D _)."
          },
          "sha1": "fpapofjz713rk1nf1xh1k01rls3vjvb"
        }
      },
      {
        "title": "POPL Tutorial/Nat Starter",
        "ns": 0,
        "id": 2154,
        "redirect": {
          "@title": "POPL Tutorial/Basics Starter",
          "#text": null
        },
        "revision": {
          "id": 5752,
          "timestamp": "2009-01-17T03:06:51Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "comment": "[[POPL Tutorial/Nat Starter]] moved to [[POPL Tutorial/Basics Starter]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 42,
            "#text": "#REDIRECT [[POPL Tutorial/Basics Starter]]"
          },
          "sha1": "6zli6c6cj30zkjb2zng9ga0rwhx5sl4"
        }
      },
      {
        "title": "POPL Tutorial/New language",
        "ns": 0,
        "id": 2143,
        "revision": {
          "id": 5706,
          "parentid": 5702,
          "timestamp": "2008-12-04T15:28:42Z",
          "contributor": {
            "username": "DanielKLee",
            "id": 5
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 9364,
            "#text": "%{\n\n== Arithmetic Primitives ==\n\n}%\n\nnat : type.  \nz : nat.\ns : nat -> nat.\n\nadd : nat -> nat -> nat -> type.\n%mode add +M +N -P.\n\nadd/z : add z N N.\n\nadd/s : add (s M) N (s P)\n         <- add M N P.\n\n%worlds () (add _ _ _).\n%total M (add M _ _).\n\n\nmult : nat -> nat -> nat -> type.\n%mode mult +M +N -P.\n\nmult/z : mult z N z.\n\nmult/s : mult (s M) N Q\n          <- mult M N P\n          <- add P N Q.\n\n%worlds () (mult _ _ _).\n%total M (mult M _ _).\n\n\n%{\n\n== Language Syntax ==\n\n}%\n\ntp : type.\n\nnum : tp.\narrow : tp -> tp -> tp.\nprod : tp -> tp -> tp.\n\nexp : type.\n\nnumeral : nat -> exp.\nplus : exp -> exp -> exp.\ntimes : exp -> exp -> exp.\n\nlam : tp -> (exp -> exp) -> exp.\napp : exp -> exp -> exp.\n\npair : exp -> exp -> exp.\nsplit : exp -> (exp -> exp -> exp) -> exp.\n\n\n%{\n\n== Dynamic Semantics ==\n\n}%\n\nvalue : exp -> type.\nstep : exp -> exp -> type.\n\n%%% argh, too many rules!\n\nvalue/numeral : value (numeral N).\n\nvalue/lam : value (lam T [x] E x).\n\nvalue/pair : value (pair E1 E2)\n              <- value E1\n              <- value E2.\n\n\nstep/plus/1 : step (plus E1 E2) (plus E1' E2)\n               <- step E1 E1'.\n\nstep/plus/2 : step (plus V1 E2) (plus V1 E2')\n               <- value V1\n               <- step E2 E2'.\n\nstep/plus/add : step (plus (numeral N1) (numeral N2)) (numeral N3)\n                 <- add N1 N2 N3.\n\nstep/times/1 : step (times E1 E2) (times E1' E2)\n                <- step E1 E1'.\n\nstep/times/2 : step (times V1 E2) (times V1 E2')\n                <- value V1\n                <- step E2 E2'.\n\nstep/times/mult : step (times (numeral N1) (numeral N2)) (numeral N3)\n                   <- mult N1 N2 N3.\n\nstep/app/fun : step (app E1 E2) (app E1' E2)\n                <- step E1 E1'.\n\nstep/app/arg : step (app V1 E2) (app V1 E2')\n                <- value V1\n                <- step E2 E2'.\n\nstep/app/beta : step (app (lam T ([x] E x)) V) (E V)\n                 <- value V.\n\nstep/pair/1 : step (pair E1 E2) (pair E1' E2)\n               <- step E1 E1'.\n\nstep/pair/2 : step (pair V1 E2) (pair V1 E2')\n               <- value V1\n               <- step E2 E2'.\n\nstep/split/arg : step (split E1 ([x] [y] E2 x y)) (split E1' ([x] [y] E2 x y))\n                  <- step E1 E1'.\n\nstep/split/pair : step (split (pair V1 V2) ([x] [y] E x y)) (E V1 V2)\n                   <- value V1\n                   <- value V2.\n\n%worlds () (value _).\n%worlds () (step _ _).\n\n\n%{\n\n== Static Semantics ==\n\n}%\n\nof : exp -> tp -> type.\n\nof/numeral : of (numeral N) num.\n\nof/plus : of (plus E1 E2) num\n           <- of E1 num\n           <- of E2 num.\n\nof/times : of (times E1 E2) num\n            <- of E1 num\n            <- of E2 num.\n\nof/lam : of (lam T1 [x] E x) (arrow T1 T2)\n          <- ({x} of x T1 -> of (E x) T2).\n\nof/app : of (app E1 E2) T\n          <- of E1 (arrow T2 T)\n          <- of E2 T2.\n\nof/pair : of (pair E1 E2) (prod T1 T2)\n           <- of E1 T1\n           <- of E2 T2.\n\nof/split : of (split E ([x] [y] Ebody x y)) T\n            <- of E (prod T1 T2)\n            <- ({x} of x T1 -> {y} of y T2 -> of (Ebody x y) T).\n\n%block tbind : some {T:tp} block {x:exp} {dx:of x T}.\n%worlds (tbind) (of _ _).\n\n\n\n%{\n\n== Progress ==\n\n}%\n\nnotstuck : exp -> type.\n\nnotstuck/value\t: notstuck E\n\t\t   <- value E.\n\nnotstuck/step\t: notstuck E\n\t\t   <- step E E'.\n\n\nprogress-app\t: of E1 (arrow T1 T2)\n\t\t   -> notstuck E1\n\t\t   -> notstuck E2\n\t\t   -> notstuck (app E1 E2)\n\t\t   -> type.\n%mode progress-app +Dof +Dns1 +Dns2 -Dns3.\n\n-\t: progress-app Dof (notstuck/step Dstep) Dns2\n\t   (notstuck/step (step/app/fun Dstep)).\n\n-\t: progress-app Dof (notstuck/value Dval) (notstuck/step Dstep)\n\t   (notstuck/step (step/app/arg Dstep Dval)).\n\n-\t: progress-app (of/lam Dof') (notstuck/value value/lam)\n\t   (notstuck/value Dval2)\n\t   (notstuck/step (step/app/beta Dval2)).\n\n%worlds () (progress-app _ _ _ _).\n%total {} (progress-app _ _ _ _).\n\n\n\nprogress-pair\t: notstuck E1\n\t\t   -> notstuck E2\n\t\t   -> notstuck (pair E1 E2)\n\t\t   -> type.\n%mode progress-pair +Dns1 +Dns2 -Dns3.\n\n-\t: progress-pair (notstuck/step Dstep) Dns2\n\t   (notstuck/step (step/pair/1 Dstep)).\n\n-\t: progress-pair (notstuck/value Dval1) (notstuck/step Dstep2)\n\t   (notstuck/step (step/pair/2 Dstep2 Dval1)).\n\n-\t: progress-pair (notstuck/value Dval1) (notstuck/value Dval2)\n\t   (notstuck/value (value/pair Dval2 Dval1)).\n\n%worlds () (progress-pair _ _ _).\n%total {} (progress-pair _ _ _).\n\n\n\nprogress-split\t: of E1 (prod T1 T2)\n\t\t   -> notstuck E1\n\t\t   -> {Ebody} notstuck (split E1 Ebody)\n\t\t   -> type.\n%mode progress-split +Dof1 +Dns1 +Ebody -Dns2.\n\n-\t: progress-split Dof (notstuck/step Dstep) Ebody\n\t   (notstuck/step (step/split/arg Dstep)).\n\n-\t: progress-split (of/pair Dof2 Dof1) \n\t   (notstuck/value (value/pair Dval2 Dval1)) Ebody\n\t   (notstuck/step (step/split/pair Dval2 Dval1)).\n\n%worlds () (progress-split _ _ _ _).\n%total {} (progress-split _ _ _ _). \n\n\n\ncan-add\t: {N1} {N2} add N1 N2 N3\n\t   -> type.\n%mode can-add +N1 +N2 -Dadd.\n\n-\t: can-add z N add/z.\n\n-\t: can-add (s N1) N2 (add/s Dadd)\n\t   <- can-add N1 N2 Dadd.\n\n%worlds () (can-add _ _ _).\n%total (D1) (can-add D1 _ _). \n\n\n\nprogress-plus\t: of E1 num\n\t\t   -> of E2 num\n\t\t   -> notstuck E1\n\t\t   -> notstuck E2\n\t\t   -> notstuck (plus E1 E2)\n\t\t   -> type.\n%mode progress-plus +Dof1 +Dof2 +Dns1 +Dns2 -Dns3.\n\n-\t: progress-plus Dof1 Dof2 (notstuck/step Dstep) Dns2\n\t   (notstuck/step (step/plus/1 Dstep)).\n\n-\t: progress-plus Dof1 Dof2 (notstuck/value Dval1) (notstuck/step Dstep2)\n\t   (notstuck/step (step/plus/2 Dstep2 Dval1)).\n\n-\t: progress-plus of/numeral of/numeral\n\t   (notstuck/value value/numeral) (notstuck/value value/numeral)\n\t   (notstuck/step (step/plus/add Dadd))\n\t   <- can-add N1 N2 (Dadd : add N1 N2 N3).\n\n%worlds () (progress-plus _ _ _ _ _).\n%total {} (progress-plus _ _ _ _ _).\n\n\n\ncan-mult\t: {N1} {N2} mult N1 N2 N3\n\t   -> type.\n%mode can-mult +N1 +N2 -Dmult.\n\n-\t: can-mult z N mult/z.\n\n-\t: can-mult (s N1) N2 (mult/s Dadd Dmult)\n\t   <- can-mult N1 N2 (Dmult : mult N1 N2 N3)\n\t   <- can-add N3 N2 Dadd.\n\n%worlds () (can-mult _ _ _).\n%total (D1) (can-mult D1 _ _). \n\n\n\nprogress-times\t: of E1 num\n\t\t   -> of E2 num\n\t\t   -> notstuck E1\n\t\t   -> notstuck E2\n\t\t   -> notstuck (times E1 E2)\n\t\t   -> type.\n%mode progress-times +Dof1 +Dof2 +Dns1 +Dns2 -Dns3.\n\n-\t: progress-times Dof1 Dof2 (notstuck/step Dstep) Dns2\n\t   (notstuck/step (step/times/1 Dstep)).\n\n-\t: progress-times Dof1 Dof2 (notstuck/value Dval1) (notstuck/step Dstep2)\n\t   (notstuck/step (step/times/2 Dstep2 Dval1)).\n\n-\t: progress-times of/numeral of/numeral\n\t   (notstuck/value value/numeral) (notstuck/value value/numeral)\n\t   (notstuck/step (step/times/mult Dmult))\n\t   <- can-mult N1 N2 (Dmult : mult N1 N2 N3).\n\n%worlds () (progress-times _ _ _ _ _).\n%total {} (progress-times _ _ _ _ _).\n\n\n\nprogress : of E T\n\t    -> notstuck E\n\t    -> type.\n%mode progress +Dof -Dns.\n\n-\t: progress of/numeral\n\t   (notstuck/value value/numeral). \n\n-\t: progress (of/plus Dof2 Dof1) Dns3\n\t   <- progress Dof1 Dns1\n\t   <- progress Dof2 Dns2\n\t   <- progress-plus Dof1 Dof2 Dns1 Dns2 Dns3.\n\n-\t: progress (of/times Dof2 Dof1) Dns3\n\t   <- progress Dof1 Dns1\n\t   <- progress Dof2 Dns2\n\t   <- progress-times Dof1 Dof2 Dns1 Dns2 Dns3.\n\n-\t: progress (of/lam Dof1)\n\t   (notstuck/value value/lam). \n\n-\t: progress (of/app Dof2 Dof1) Dns3\n\t   <- progress Dof1 Dns1\n\t   <- progress Dof2 Dns2\n\t   <- progress-app Dof1 Dns1 Dns2 Dns3.\n\n-\t: progress (of/pair Dof2 Dof1) Dns3\n\t   <- progress Dof1 Dns1\n\t   <- progress Dof2 Dns2\n\t   <- progress-pair Dns1 Dns2 Dns3.\n\n-\t: progress (of/split \n\t\t      (Dbody : {x} of x T1 -> {y} of y T2 -> of (Ebody x y) T)\n\t\t      Dof1) Dns2\n\t   <- progress Dof1 Dns1\n\t   <- progress-split Dof1 Dns1 Ebody Dns2.\n\n%worlds () (progress _ _).\n%total (D1) (progress D1 _).\n\n\n\n%{\n== Preservation ==\n}%\n\n\npreservation\t: of E1 T1\n\t\t   -> step E1 E2\n\t\t   -> of E2 T1\n\t\t   -> type.\n%mode preservation +Dof1 +Dstep -Dof2.\n\n-\t: preservation (of/plus Dof2 Dof1) (step/plus/1 Dstep1)\n\t   (of/plus Dof2 Dof1')\n\t   <- preservation Dof1 Dstep1 Dof1'.\n\n-\t: preservation (of/plus Dof2 Dof1) (step/plus/2 Dstep2 Dval1)\n\t   (of/plus Dof2' Dof1)\n\t   <- preservation Dof2 Dstep2 Dof2'.\n\n-\t: preservation (of/plus Dof2 Dof1) (step/plus/add Dadd) \n\t   of/numeral.\n\n-\t: preservation (of/times Dof2 Dof1) (step/times/1 Dstep1)\n\t   (of/times Dof2 Dof1')\n\t   <- preservation Dof1 Dstep1 Dof1'.\n\n-\t: preservation (of/times Dof2 Dof1) (step/times/2 Dstep2 Dval1)\n\t   (of/times Dof2' Dof1)\n\t   <- preservation Dof2 Dstep2 Dof2'.\n\n-\t: preservation (of/times Dof2 Dof1) (step/times/mult Dmult) \n\t   of/numeral.\n\n-\t: preservation (of/pair Dof2 Dof1) (step/pair/1 Dstep1)\n\t   (of/pair Dof2 Dof1')\n\t   <- preservation Dof1 Dstep1 Dof1'.\n\n-\t: preservation (of/pair Dof2 Dof1) (step/pair/2 Dstep2 Dval)\n\t   (of/pair Dof2' Dof1)\n\t   <- preservation Dof2 Dstep2 Dof2'.\n\n-\t: preservation (of/split Dbody Dof1) (step/split/arg Dstep1)\n\t   (of/split Dbody Dof1')\n\t   <- preservation Dof1 Dstep1 Dof1'.\n\n-\t: preservation (of/split Dbody (of/pair Dof2 Dof1))\n\t   (step/split/pair Dval2 Dval1)\n\t   (Dbody E1 Dof1 E2 Dof2).\n\n-\t: preservation (of/app Dof2 Dof1) (step/app/fun Dstep1)\n\t   (of/app Dof2 Dof1')\n\t   <- preservation Dof1 Dstep1 Dof1'.\n\n-\t: preservation (of/app Dof2 Dof1) (step/app/arg Dstep2 Dval)\n\t   (of/app Dof2' Dof1)\n\t   <- preservation Dof2 Dstep2 Dof2'.\n\n-\t: preservation (of/app Dof2 (of/lam Dbody)) (step/app/beta Dval1)\n\t   (Dbody E2 Dof2).\n\n%worlds () (preservation _ _ _).\n%total (D1) (preservation _ D1 _)."
          },
          "sha1": "o8xdsmsgfsbqsa9r0ar63aawte87myv"
        }
      },
      {
        "title": "POPL Tutorial/Next",
        "ns": 0,
        "id": 2158,
        "revision": {
          "id": 5827,
          "parentid": 5825,
          "timestamp": "2009-01-19T02:44:12Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 2588,
            "#text": "If you want to read more about Twelf, you can check out the [[introductions to Twelf|introductions]], [[tutorials]], and [[case studies]] on the wiki.\n\nWe strongly recommend that you work on some of the following exercises: you'll get a flavor for the experience of defining systems and proving theorems in Twelf.  If we have time at the end of the tutorial, we'll break into small groups and you can pick an interesting problem or two to work on.  If you get stuck, ask a TA!  Refer to the solutions to check your work (though Server OK from Twelf should be assurance enough!)  Feel free to ask us for help during the rest of the conference. \n\n== Beginner problems (Recommended) ==\n* [[POPL Tutorial/MinML Preservation Theorem|Preservation for MinML]] -- Prove type preservation for MinML. ([[POPL Tutorial/MinML Preservation Theorem Answer|Solution]])\n* [[POPL Tutorial/Sequent vs Natural Deduction|Sequent calculus vs. natural deduction]] -- Prove the logical equivalence of Gentzen's intuitionistic sequent calculus and intuitionistic natural deduction. ([[POPL Tutorial/Sequent vs Natural Deduction: Solution|Solution]])\n* [[POPL Tutorial/Big step, small step|Big-step evaluation vs. small-step transition semantics]] -- Prove the operational equivalence of the big-step and small-step views of operational semantics.  ([[POPL Tutorial/Big step, small step: Solution|Solution]])\n\n== Intermediate problems ==\n* [[POPL Tutorial/cps-problem|Call-by-value CPS transform, with administrative redexes]] -- Define an algorithm for converting lambda terms to continuation-passing style ([[POPL Tutorial/CPS Solutions|Solution]])\n* [[POPL Tutorial/cps-problem2|Higher-order call-by-value CPS transform, no administrative redexes]] -- Define a higher-order variant of the CPS conversion that never creates administrative redexes ([[POPL Tutorial/CPS Solution2|Solution]])\n* [[POPL Tutorial/Church Rosser (Problem)|Church-Rosser]] -- Prove Church and Rosser's seminal result via a Diamond Lemma for the untyped lambda calculus. ([[POPL Tutorial/Church Rosser|Solution]])\n* [[POPL Tutorial/Exceptions-problem|MinML with exceptions]] -- Prove type safety for an extension of MinML with exceptions defined using structural operational semantics with a \"raises\" judgement.  ([[POPL Tutorial/Exceptions|Solution]])\n* [[POPL Tutorial/Typed bracket abstraction|Lambda calculus and combinators]] -- Explore the relation between the simply-typed lambda calculus and combinatory logic using Curry's classic bracket abstraction algorithm.  ([[POPL Tutorial/Typed bracket abstraction (solution)|Solution]])"
          },
          "sha1": "12kwp44wuo2sa3rqrxp26knefc5pz00"
        }
      },
      {
        "title": "POPL Tutorial/Pattern Matching",
        "ns": 0,
        "id": 2098,
        "redirect": {
          "@title": "POPL Tutorial/Pattern matching",
          "#text": null
        },
        "revision": {
          "id": 5454,
          "timestamp": "2008-11-17T23:05:40Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "comment": "[[POPL Tutorial/Pattern Matching]] moved to [[POPL Tutorial/Pattern matching]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 44,
            "#text": "#REDIRECT [[POPL Tutorial/Pattern matching]]"
          },
          "sha1": "ki7ts812ht0zw4xwgo0oz6k3c3g0uar"
        }
      },
      {
        "title": "POPL Tutorial/Pattern matching",
        "ns": 0,
        "id": 2097,
        "revision": {
          "id": 5453,
          "parentid": 5451,
          "timestamp": "2008-11-17T23:05:40Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "minor": null,
          "comment": "[[POPL Tutorial/Pattern Matching]] moved to [[POPL Tutorial/Pattern matching]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 12453,
            "#text": "%{ \nThis is a case study on pattern matching using Twelf.\n}%\n\n\n\n% \n\nnat : type.\n\nz\t: nat.\ns\t: nat -> nat.\n\n\ntp : type.\n\no\t: tp.\narrow\t: tp -> tp -> tp.\nprod\t: tp -> tp -> tp.\nsum\t: tp -> tp -> tp.\n\n\ntplist\t: type. \n\ntplist/nil\t: tplist.\ntplist/cons\t: tp -> tplist -> tplist.\n\n\npat\t: type.\n\npat/underscore\t: pat.\npat/pair\t: pat -> pat -> pat.\npat/inl\t\t: pat -> pat.\npat/inr\t\t: pat -> pat.\npat/var\t\t: pat. \npat/as\t\t: pat -> pat -> pat.\n\n\nexp\t: type. \noexp\t: type.  % oexp N is an expression with N bound vars\nmatch\t: type.\n\nexp/unit\t: exp. \nexp/lam\t\t: match -> exp. \nexp/app\t\t: exp -> exp -> exp. \nexp/pair\t: exp -> exp -> exp.\nexp/inl\t\t: exp -> exp. \nexp/inr\t\t: exp -> exp. \nexp/handle\t: exp -> exp -> exp. \n\n\noexp/c\t: exp -> oexp.\noexp/o\t: (exp -> oexp) -> oexp. \n\n\nmatch/nil\t: match. \nmatch/cons\t: pat -> oexp -> match -> match.\n\n\n\n%{ static semantics }%\n\ntplist-append\t: tplist -> tplist -> tplist -> type. \n\ntplist-append/nil\t: tplist-append tplist/nil TL TL.\ntplist-append/cons\t: tplist-append (tplist/cons T TL) TL' \n\t\t\t   (tplist/cons T TL'')\n\t\t\t   <- tplist-append TL TL' TL''.\n\n\n\ntplist-get\t: nat -> tplist -> tp -> type. \n\ntplist-get/hit\t: tplist-get z (tplist/cons T TL) T.\ntplist-get/miss\t: tplist-get (s N) (tplist/cons T TL) T'\n\t\t   <- tplist-get N TL T'.\n\n\n\nof-pat\t: pat -> tp -> tplist -> type. \n\nof-pat/underscore\t: of-pat pat/underscore T tplist/nil. \nof-pat/pair\t\t: of-pat (pat/pair P1 P2) (prod T1 T2) TL'\n\t\t\t   <- of-pat P1 T1 TL1\n\t\t\t   <- of-pat P2 T2 TL2\n\t\t\t   <- tplist-append TL1 TL2 TL'.\nof-pat/inl\t\t: of-pat (pat/inl P) (sum T1 T2) TL\n\t\t\t   <- of-pat P T1 TL. \nof-pat/inr\t\t: of-pat (pat/inr P) (sum T1 T2) TL\n\t\t\t   <- of-pat P T2 TL. \nof-pat/var\t\t: of-pat pat/var T (tplist/cons T tplist/nil). \nof-pat/as\t\t: of-pat (pat/as P1 P2) T TL3\n\t\t\t   <- of-pat P1 T TL1\n\t\t\t   <- of-pat P2 T TL2\n\t\t\t   <- tplist-append TL1 TL2 TL3. \n\n\nof-exp\t: exp -> tp -> type. \nof-match: match -> tp -> tp -> type. \nof-oexp\t: tplist -> oexp -> tp -> type. \n\n\n\nof-oexp/c\t: of-oexp tplist/nil (oexp/c E) T\n\t\t   <- of-exp E T. \nof-oexp/o\t: of-oexp (tplist/cons T TL) (oexp/o ([x] EL x)) T'\n\t\t   <- ({x} of-exp x T\n\t\t\t -> of-oexp TL (EL x) T').\n\n\n\nof-match/nil\t: of-match match/nil T T'.\nof-match/cons\t: of-match (match/cons P OE M) T T'\n\t\t   <- of-pat P T TL\n\t\t   <- of-oexp TL OE T'\n\t\t   <- of-match M T T'.\n\n\n\nof-exp/unit\t: of-exp exp/unit o. \nof-exp/lam\t: of-exp (exp/lam M) (arrow T1 T2)\n\t\t   <- of-match M T1 T2.  \nof-exp/app\t: of-exp (exp/app E1 E2) T2\n\t\t   <- of-exp E1 (arrow T1 T2) \n\t\t   <- of-exp E2 T1.\nof-exp/pair\t: of-exp (exp/pair E1 E2) (prod T1 T2)\n\t\t   <- of-exp E1 T1\n\t\t   <- of-exp E2 T2. \nof-exp/inl\t: of-exp (exp/inl E) (sum T1 T2)\n\t\t   <- of-exp E T1.\nof-exp/inr\t: of-exp (exp/inr E) (sum T1 T2)\n\t\t   <- of-exp E T2. \nof-exp/handle\t: of-exp (exp/handle E1 E2) T\n\t\t   <- of-exp E1 T\n\t\t   <- of-exp E2 T.\n\n\n% syntax only needed for dynamic semantics of the language\n\nexplist\t: type. \n\nexplist/nil\t: explist.\nexplist/cons\t: exp -> explist -> explist.\n\n\n\n% static semantics of explists\n\nof-explist\t: explist -> tplist -> type. \n\nof-explist/nil\t: of-explist explist/nil tplist/nil.\nof-explist/cons\t: of-explist (explist/cons E EL) (tplist/cons T TL)\n\t\t   <- of-exp E T\n\t\t   <- of-explist EL TL. \n\n\n\nsubst-oexp\t: explist -> oexp -> exp -> type. \n\nsubst-oexp/c\t: subst-oexp explist/nil (oexp/c E) E. \nsubst-oexp/o\t: subst-oexp (explist/cons E EL) (oexp/o ([x] OE x)) E'\n\t\t   <- subst-oexp EL (OE E) E'.\n\n\n\nexplist-get\t: nat -> explist -> exp -> type. \n\nexplist-get/hit\t: explist-get z (explist/cons T TL) T.\nexplist-get/miss: explist-get (s N) (explist/cons T TL) T'\n\t\t   <- explist-get N TL T'.\n\n\n\nexplist-append\t: explist -> explist -> explist -> type.\n\nexplist-append/nil\t: explist-append explist/nil EL EL. \nexplist-append/cons\t: explist-append (explist/cons E EL) EL' \n\t\t\t   (explist/cons E EL'')\n\t\t\t   <- explist-append EL EL' EL''.\n\n\n\napply-pat\t: pat -> exp -> explist -> type. \n\n% only have to define failure over well-typed pattern/expression pairs\n% failures arise from inl/inr mismatches\n\nfail-pat\t: pat -> exp -> type. \n\napply-pat/underscore\t\n   : apply-pat pat/underscore E explist/nil. \napply-pat/pair\t\t\n   : apply-pat (pat/pair P1 P2) (exp/pair E1 E2) EL'\n      <- apply-pat P1 E1 EL1\n      <- apply-pat P2 E2 EL2\n      <- explist-append EL1 EL2 EL'.\napply-pat/inl\n   : apply-pat (pat/inl P) (exp/inl E) EL\n      <- apply-pat P E EL.\napply-pat/inr\n   : apply-pat (pat/inr P) (exp/inr E) EL\n      <- apply-pat P E EL. \napply-pat/var\n   : apply-pat pat/var E (explist/cons E explist/nil). \napply-pat/as\t\t\n   : apply-pat (pat/as P1 P2) E EL'\n      <- apply-pat P1 E EL1\n      <- apply-pat P2 E EL2\n      <- explist-append EL1 EL2 EL'.\n\n\nfail-pat/pair-1\t: fail-pat (pat/pair P1 P2) (exp/pair E1 E2) \n\t\t   <- fail-pat P1 E1.\nfail-pat/pair-2\t: fail-pat (pat/pair P1 P2) (exp/pair E1 E2)\n\t\t   <- apply-pat P1 E1 EL\n\t\t   <- fail-pat P2 E2. \nfail-pat/inl-t\t: fail-pat (pat/inl P) (exp/inl E)\n\t\t   <- fail-pat P E. \nfail-pat/inl-f\t: fail-pat (pat/inl P) (exp/inr E).\nfail-pat/inr-t\t: fail-pat (pat/inr P) (exp/inr E)\n\t\t   <- fail-pat P E. \nfail-pat/inr-f\t: fail-pat (pat/inr P) (exp/inl E).\nfail-pat/as-1\t: fail-pat (pat/as P1 P2) E\n\t\t   <- fail-pat P1 E.\nfail-pat/as-2\t: fail-pat (pat/as P1 P2) E\n\t\t   <- apply-pat P1 E EL\n\t\t   <- fail-pat P2 E. \n\n\n\napply-or-fail-pat\t: pat -> exp -> type. \n\napply-or-fail-pat/apply\t: apply-or-fail-pat P E \n\t\t\t\t   <- apply-pat P E EL.\napply-or-fail-pat/fail\t: apply-or-fail-pat P E\n\t\t\t\t   <- fail-pat P E. \n\n\n\napply-match\t: match -> exp -> exp -> type. \n\napply-match/cons-1\t: apply-match (match/cons P OE M) E E'\n\t\t\t   <- apply-pat P E EL\n\t\t\t   <- subst-oexp EL OE E'. \napply-match/cons-2\t: apply-match (match/cons P OE M) E E'\n\t\t\t   <- fail-pat P E\n\t\t\t   <- apply-match M E E'. \n\n\nfail-match\t: match -> exp -> type. \n\nfail-match/nil\t: fail-match match/nil E.\nfail-match/cons\t: fail-match (match/cons P OE M) E\n\t\t   <- fail-pat P E\n\t\t   <- fail-match M E.\n\n\n\napply-or-fail-match\t: match -> exp -> type. \n\napply-or-fail-match/apply\t: apply-or-fail-match M E\n\t\t\t\t   <- apply-match M E E'. \napply-or-fail-match/fail\t: apply-or-fail-match M E\n\t\t\t\t   <- fail-match M E.\n\n\n\nexception\t: type. \nexception/match\t: exception. \n\n\n\nvalue\t: exp -> type.\n\nvalue/unit\t: value exp/unit. \nvalue/lam\t: value (exp/lam M).\nvalue/pair\t: value (exp/pair E1 E2)\n\t\t   <- value E1\n\t\t   <- value E2.\nvalue/inl\t: value (exp/inl E)\n\t\t   <- value E.\nvalue/inr\t: value (exp/inr E)\n\t\t   <- value E.\n\n\n\nraises\t: exp -> exception -> type. \n\nraises/app-1\t: raises (exp/app E1 E2) X\n\t\t   <- raises E1 X.\nraises/app-2\t: raises (exp/app E1 E2) X\n\t\t   <- value E1\n\t\t   <- raises E2 X.\nraises/app-fail\t: raises (exp/app (exp/lam M) E2) exception/match\n\t\t   <- value E2\n\t\t   <- fail-match M E2.\nraises/pair-1\t: raises (exp/pair E1 E2) X\n\t\t   <- raises E1 X.\nraises/pair-2\t: raises (exp/pair E1 E2) X\n\t\t   <- value E1\n\t\t   <- raises E2 X. \nraises/inl\t: raises (exp/inl E) X\n\t\t   <- raises E X. \nraises/inr\t: raises (exp/inr E) X\n\t\t   <- raises E X.\n\n\n\nstep\t: exp -> exp -> type. \n\nstep/app-1\t\t: step (exp/app E1 E2) (exp/app E1' E2)\n\t\t\t   <- step E1 E1'.\nstep/app-2\t\t: step (exp/app E1 E2) (exp/app E1 E2')\n\t\t\t   <- value E1\n\t\t\t   <- step E2 E2'.\nstep/app-beta\t\t: step (exp/app (exp/lam M) E) E'\n\t\t\t   <- value E2\n\t\t\t   <- apply-match M E E'.\nstep/pair-1\t\t: step (exp/pair E1 E2) (exp/pair E1' E2)\n\t\t\t   <- step E1 E1'.\nstep/pair-2\t\t: step (exp/pair E1 E2) (exp/pair E1 E2')\n\t\t\t   <- value E1\n\t\t\t   <- step E2 E2'.\nstep/inl\t\t: step (exp/inl E) (exp/inl E')\n\t\t\t   <- step E E'.\nstep/inr\t\t: step (exp/inr E) (exp/inr E')\n\t\t\t   <- step E E'.\nstep/handle\t\t: step (exp/handle E1 E2) (exp/handle E1' E2)\n\t\t\t   <- step E1 E1'.\nstep/handle-beta\t: step (exp/handle E1 E2) E1\n\t\t\t   <- value E1.\nstep/handle-fail\t: step (exp/handle E1 E2) E2\n\t\t\t   <- raises E1 X.\n\n\npreservation-subst-oexp\t: of-explist EL TL\n\t\t\t   -> of-oexp TL OE T\n\t\t\t   -> subst-oexp EL OE E\n\t\t\t   -> of-exp E T\n\t\t\t   -> type.\n%mode preservation-subst-oexp +D1 +D2 +D3 -D4.\n\n-\t: preservation-subst-oexp _ (of-oexp/c D1) subst-oexp/c D1.\n\n-\t: preservation-subst-oexp (of-explist/cons D1 D) (of-oexp/o D2)\n\t   (subst-oexp/o D3) D4\n\t   <- preservation-subst-oexp D1 (D2 _ D) D3 D4.\n\n%worlds () (preservation-subst-oexp _ _ _ _).\n%total (D1) (preservation-subst-oexp _ _ D1 _).\n\n\n\npreservation-append\t: of-explist EL1 TL1\n\t\t\t   -> of-explist EL2 TL2\n\t\t\t   -> explist-append EL1 EL2 EL3\n\t\t\t   -> tplist-append TL1 TL2 TL3\n\t\t\t   -> of-explist EL3 TL3\n\t\t\t   -> type. \n%mode preservation-append +D1 +D2 +D3 +D4 -D5.\n\n-\t: preservation-append _ D explist-append/nil tplist-append/nil D.\n\n-\t: preservation-append (of-explist/cons D1 D) D2 (explist-append/cons D3)\n\t   (tplist-append/cons D4) (of-explist/cons D5 D)\n\t   <- preservation-append D1 D2 D3 D4 D5.\n\n%worlds () (preservation-append _ _ _ _ _).\n%total (D1) (preservation-append _ _ _ D1 _).\n\n\n\npreservation-get\t: of-explist EL TL\n\t\t\t   -> explist-get M EL E\n\t\t\t   -> tplist-get M TL T\n\t\t\t   -> of-exp E T\n\t\t\t   -> type.\n%mode preservation-get +D1 +D2 +D3 -D4.\n\n-\t: preservation-get (of-explist/cons _ D) explist-get/hit tplist-get/hit D.\n\n-\t: preservation-get (of-explist/cons DL _) (explist-get/miss D') \n\t   (tplist-get/miss D'') D\n\t   <- preservation-get DL D' D'' D.\n\n%worlds () (preservation-get _ _ _ _).\n%total (D1) (preservation-get _ _ D1 _).\n\n\npreservation-apply-pat\t: of-exp E T\n\t\t\t   -> of-pat P T TL\n\t\t\t   -> apply-pat P E EL\n\t\t\t   -> of-explist EL TL\n\t\t\t   -> type.\n%mode preservation-apply-pat +D1 +D2 +D3 -D4.\n\n-\t: preservation-apply-pat D1 of-pat/underscore apply-pat/underscore\n\t   of-explist/nil.\n\n-\t: preservation-apply-pat (of-exp/pair DE2 DE1) \n\t   (of-pat/pair DTA DP2 DP1)\n\t   (apply-pat/pair DEA DA2 DA1) D3\n\t   <- preservation-apply-pat DE1 DP1 DA1 D1\n\t   <- preservation-apply-pat DE2 DP2 DA2 D2\n\t   <- preservation-append D1 D2 DEA DTA D3.\n\n-\t: preservation-apply-pat DE\n\t   (of-pat/as DTA DP2 DP1)\n\t   (apply-pat/as DEA DA2 DA1) D3\n\t   <- preservation-apply-pat DE DP1 DA1 D1\n\t   <- preservation-apply-pat DE DP2 DA2 D2\n\t   <- preservation-append D1 D2 DEA DTA D3.\n\n-\t: preservation-apply-pat (of-exp/inl DE) (of-pat/inl DP)\n\t   (apply-pat/inl DA) D\n\t   <- preservation-apply-pat DE DP DA D.\n\n-\t: preservation-apply-pat (of-exp/inr DE) (of-pat/inr DP)\n\t   (apply-pat/inr DA) D\n\t   <- preservation-apply-pat DE DP DA D.\n\n-\t: preservation-apply-pat D1 of-pat/var apply-pat/var\n\t   (of-explist/cons of-explist/nil D1).\n\n\n%worlds () (preservation-apply-pat _ _ _ _).\n%total (D1) (preservation-apply-pat _ _ D1 _).\n\n\n\npreservation-apply-match\t: of-exp E T\n\t\t\t\t   -> of-match M T T'\n\t\t\t\t   -> apply-match M E E'\n\t\t\t\t   -> of-exp E' T'\n\t\t\t\t   -> type.\n%mode preservation-apply-match +D1 +D2 +D3 -D4.\n\n-\t: preservation-apply-match D1 (of-match/cons _ DOE D2)\n\t   (apply-match/cons-1 DS DA) D'\n\t   <- preservation-apply-pat D1 D2 DA D\n\t   <- preservation-subst-oexp D DOE DS D'.\n\n-\t: preservation-apply-match D1 (of-match/cons D2 _ _)\n\t   (apply-match/cons-2 DA _) D'\n\t   <- preservation-apply-match D1 D2 DA D'.\n\n%worlds () (preservation-apply-match _ _ _ _).\n%total (D1) (preservation-apply-match _ _ D1 _).\n\n\n\npreservation\t: of-exp E T\n\t\t   -> step E E'\n\t\t   -> of-exp E' T\n\t\t   -> type.\n%mode preservation +D1 +D2 -D3.\n\n-\t: preservation (of-exp/app D2 D1) (step/app-1 DS)\n\t   (of-exp/app D2 D1')\n\t   <- preservation D1 DS D1'.\n\n-\t: preservation (of-exp/app D2 D1) (step/app-2 DS V)\n\t   (of-exp/app D2' D1)\n\t   <- preservation D2 DS D2'.\n\n-\t: preservation (of-exp/app D2 (of-exp/lam D1)) (step/app-beta DA _) D\n\t   <- preservation-apply-match D2 D1 DA D.\n\n-\t: preservation (of-exp/pair D2 D1) (step/pair-1 DS)\n\t   (of-exp/pair D2 D1')\n\t   <- preservation D1 DS D1'.\n\n-\t: preservation (of-exp/pair D2 D1) (step/pair-2 DS V)\n\t   (of-exp/pair D2' D1)\n\t   <- preservation D2 DS D2'.\n\n-\t: preservation (of-exp/handle D2 D1) (step/handle DS)\n\t   (of-exp/handle D2 D1')\n\t   <- preservation D1 DS D1'.\n\n-\t: preservation (of-exp/inl D1) (step/inl DS)\n\t   (of-exp/inl D1')\n\t   <- preservation D1 DS D1'.\n\n-\t: preservation (of-exp/inr D1) (step/inr DS)\n\t   (of-exp/inr D1')\n\t   <- preservation D1 DS D1'.\n\n-\t: preservation (of-exp/handle D2 D1) (step/handle DS)\n\t   (of-exp/handle D2 D1')\n\t   <- preservation D1 DS D1'.\n\n-\t: preservation (of-exp/handle D2 D1) (step/handle-beta _) D1.\n\n-\t: preservation (of-exp/handle D2 D1) (step/handle-fail _) D2.\n\n%worlds () (preservation _ _ _).\n%total (D1) (preservation _ D1 _).\n\n%{\n--[[User:DanielKLee|DanielKLee]] 01:46, 11 October 2007 (EDT)\n\nTODO: Finish commentary.\n{{stub}}\n}%"
          },
          "sha1": "3w4kuzxacldlnxmyntxpt83k7jjua0o"
        }
      },
      {
        "title": "POPL Tutorial/Problems",
        "ns": 0,
        "id": 2096,
        "revision": {
          "id": 5708,
          "parentid": 5627,
          "timestamp": "2008-12-04T23:53:21Z",
          "contributor": {
            "username": "William Lovas",
            "id": 11
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 1673,
            "#text": "* [[POPL Tutorial/cps]] by jcreed\n* [[POPL Tutorial/cps-rp]] by dklee, based on code by jcreed\n* [[POPL Tutorial/cps-problem]] by arbob, based on code by jcreed\n** [[POPL Tutorial/CPS_Solutions]] by arbob, based on code by jcreed\n* [[POPL Tutorial/cps-problem2]] by arbob, based on code by jcreed\n** [[POPL Tutorial/CPS_Solution2]] by arbob, based on code by jcreed\n* [[POPL_Tutorial/Sequent_vs_Natural_Deduction]] by cmartens/wlovas\n** [[POPL Tutorial/Sequent vs Natural Deduction: Solution]]\n* [[POPL_Tutorial/Pattern_matching]] by dklee\n* [[POPL_Tutorial/Control machine]] by [[User:Rsimmons|Rob]]\n* [[POPL Tutorial/Church Rosser (Problem)]] by [[User:Rsimmons|Rob]], based on code by Karl\n** [[POPL Tutorial/Church Rosser]] by [[User:Rsimmons|Rob]] solution to the above\n* [[POPL_Tutorial/Properties_of_Typing_and_Reduction]] by [[User:Twilson|Todd]].\n* [[POPL_Tutorial/Cost_semantics]] by Rob and mpa\n* [[POPL_Tutorial/Combinators]] by Karl\n* [[Bracket abstraction]] by wlovas (can this be made into a problem?)\n* [[POPL Tutorial/Typed bracket abstraction]] by wlovas (types make it combinatory logic)\n* [[POPL Tutorial/Typed bracket abstraction with equivalence]] by wlovas (full beta/eta equivalence)\n* [[POPL Tutorial/Big step, small step]] by wlovas\n** [[POPL Tutorial/Big step, small step: Solution]]\n* [[POPL Tutorial/Exceptions-problem]] by dklee\n** [[POPL Tutorial/Exceptions]] by dklee, a solution to the above problem.\n* [[POPL Tutorial/Evaluation_Contexts_Intrinsic]] by drl\n\n* CPS variations (Dklee and arbob are working on this for wednesday)\n* Stack machine vs. SOS vs. evaluation (Will and Chris are working on this for Weds)\n* Authorization logic\n* ML5"
          },
          "sha1": "09rixwapg1jt4tb17kon9wd9szrwx22"
        }
      },
      {
        "title": "POPL Tutorial/Properties of Typing and Reduction",
        "ns": 0,
        "id": 2104,
        "revision": {
          "id": 5480,
          "timestamp": "2008-11-19T16:31:37Z",
          "contributor": {
            "username": "Twilson",
            "id": 15
          },
          "comment": "New page: This problem (or problems) involves proving three properties of typing and reduction for the language L{num str} from Bob Harper's book,  [http://www.cs.cmu.edu/~rwh/plbook/book.pdf Practi...",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 17106,
            "#text": "This problem (or problems) involves proving three properties of typing and reduction for the language L{num str}\nfrom Bob Harper's book,  [http://www.cs.cmu.edu/~rwh/plbook/book.pdf Practical Foundations for Programming Languages].\n\n== The System L{num str} ==\n\n<twelf>\n% Natural numbers\n\nnat : type.\n\n0 : nat.\ns : nat -> nat.\n\n\n% Addition for natural numbers\n\nplus_op : nat -> nat -> nat -> type.\n\nplus_op/0 : plus_op 0 N N.\nplus_op/s : plus_op N M L -> plus_op (s N) M (s L).\n\n\n% Multiplication for natural numbers\n\ntimes_op : nat -> nat -> nat -> type.\n\ntimes_op/0 : times_op 0 N 0.\ntimes_op/s : times_op (s N) M P\n              <- times_op N M L\n              <- plus_op L M P.\n\n\n%%%%%%%%%%%%%%%% L{num str}: Syntax %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n% Types\n\ntyp : type.\n\nnum : typ.\nstr : typ.\n\n\n% Expressions.  For simplicity, strings are just natural numbers,\n% concatenation is addition, and len is the identity.\n\nexp : type.\n\nnume  : nat -> exp.\nstre  : nat -> exp.\nplus  : exp -> exp -> exp.\ntimes : exp -> exp -> exp.\ncat   : exp -> exp -> exp.\nlen   : exp -> exp.\nlet   : exp -> (exp -> exp) -> exp.\n\n\n%%%%%%%%%%%%%%%% L{num str}: Static semantics (typing judgment) %%%%%%%%%%%%%%%\n\nof : exp -> typ -> type.\n\nof/stre  : of (stre S) str.\n\nof/nume  : of (nume N) num.\n\nof/plus  : of E1 num -> of E2 num\n            -> of (plus E1 E2) num.\n\nof/times : of E1 num -> of E2 num\n            -> of (times E1 E2) num.\n\nof/cat   : of E1 str -> of E2 str\n            -> of (cat E1 E2) str.\n\nof/len   : of E1 str\n            -> of (len E1) num.\n\nof/let   : of E1 T1 -> ({x} of x T1 -> of (E2 x) T2)\n            -> of (let E1 ([x] E2 x)) T2.\n\n\n% Assumption block for typing judgment (coming from of/let)\n\n%block of_bind : some {T:typ}\n               block {x:exp}{ofx:of x T}.\n\n\n\n%%%%%%%%%%%%%%%% L{num str}: Dynamic Semantics %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n% Values\n\nval : exp -> type.\n\nval/stre : val (stre N).\nval/nume : val (nume N).\n\n\n% Reduction\n\nred : exp -> exp -> type.\n\nred/plus/num  : plus_op N1 N2 N\n                 -> red (plus (nume N1) (nume N2)) (nume N).\n\nred/plus1     : red E1 E1'\n                 -> red (plus E1 E2) (plus E1' E2).\n\nred/plus2     : val E1 -> red E2 E2'\n                 -> red (plus E1 E2) (plus E1 E2').\n\nred/times/num : times_op N1 N2 N\n                 -> red (times (nume N1) (nume N2)) (nume N).\n\nred/times1    : red E1 E1'\n                 -> red (times E1 E2) (times E1' E2).\n\nred/times2    : val E1 -> red E2 E2'\n\t\t -> red (times E1 E2) (times E1 E2').\n\nred/cat/str   : plus_op S1 S2 S\n                 -> red (cat (stre S1) (stre S2)) (stre S).\n\nred/cat1      : red E1 E1'\n                 -> red (cat E1 E2) (cat E1' E2).\n\nred/cat2      : val E1 -> red E2 E2'\n\t\t -> red (cat E1 E2) (cat E1 E2').\n\nred/len/str   : red (len (stre S)) (nume S).\n\nred/len       : red E1 E1'\n\t\t -> red (len E1) (len E1').\n\nred/let/val   : val E1\n\t\t -> red (let E1 ([x] E2 x)) (E2 E1).\n\nred/let       : red E1 E1'\n\t\t -> red (let E1 ([x] E2 x)) (let E1' ([x] E2 x)).\n</twelf>\n\n== Problem 1: Unicity of Typing ==\n\n<twelf>\n%%%%%%%%%%%%%%%% Lemma 9.1 (Unicity of typing) %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n% If G |- E : T1 and G |- E : T2, then T1 = T2.\n\n% Equality of types\n\neqtyp : typ -> typ -> type.\n\nrefl_t : eqtyp T T.\n\n\n% Congruence for typing assumptions.  Although the proof doesn't\n% introduce any parameters or hypotheses, it is used by a theorem that\n% does, and so we need to check it in the extended worlds.\n\ncong_of : eqtyp A1 A2 -> ({x} of x A1 -> of (E x) T)\n           -> ({x} of x A2 -> of (E x) T) -> type.\n%mode cong_of +EA +OE1 -OE2.\n\n- : cong_of refl_t OE1 OE1.\n\n%worlds (of_bind) (cong_of _ _ _).\n%total OE1 (cong_of _ OE1 _).\n\n\n% Statement and proof of Lemma.  Notice that the worlds in this proof\n% are an extension (technically, they subsume) the worlds in the\n% congruence lemma above.\n\nlemma9-1 : of E T1 -> of E T2 -> eqtyp T1 T2 -> type.\n%mode lemma9-1 +OjE1 +OjE2 -Ej.\n\n- : lemma9-1 of/stre of/stre refl_t.\n\n- : lemma9-1 of/nume of/nume refl_t.\n\n- : lemma9-1 (of/plus OjE11 OjE12) (of/plus OjE21 OjE22) refl_t.\n\n- : lemma9-1 (of/times OjE11 OjE12) (of/times OjE21 OjE22) refl_t.\n\n- : lemma9-1 (of/cat OjE11 OjE12) (of/cat OjE21 OjE22) refl_t.\n\n- : lemma9-1 (of/len OjE1) (of/len OjE2) refl_t.\n\n- : lemma9-1 (of/let OjE11 ([x][ofx1] OjE12 x ofx1))\n     (of/let OjE21 ([x][ofx2] OjE22 x ofx2)) Q\n      <- lemma9-1 OjE11 OjE21 E1\n      <- cong_of E1 OjE12 OjE12'\n      <- {x}{ofx2} lemma9-1 ofx2 ofx2 refl_t\n         -> lemma9-1 (OjE12' x ofx2) (OjE22 x ofx2) Q.\n\n%block lemma_block\n   : some {T:typ}\n      block {x:exp}{ofx:of x T}{u:lemma9-1 ofx ofx refl_t}.\n\n%worlds (lemma_block) (lemma9-1 _ _ _).\n%total OjT2 (lemma9-1 _ OjT2 _).\n</twelf>\n\n== Problem 2: Determinacy of Reduction ==\n\n<twelf>\n%%%%%%%%%%%%%%%% Lemma 10.1 (Determinacy of Reduction) %%%%%%%%%%%%%%%%%%%%%%%\n%\n% If E |-> E' and E |-> E'', then E' = E''.\n\n% Equality and congruence for nats\n\neqnat  : nat -> nat -> type.\n\nrefl_n : eqnat N N.\n\ncong_s : eqnat N M -> eqnat (s N) (s M) -> type.\n%mode cong_s +E -ES.\n\n- : cong_s refl_n refl_n.\n\n%worlds () (cong_s _ _).\n%total {} (cong_s _ _).\n\n\n% Equality for expressions\n\neqexp : exp -> exp -> type.\n\nrefl_e : eqexp E E.\n\n\n% Congruences for expressions\n\ncong_nume   : eqnat N1 N2 -> eqexp (nume N1) (nume N2) -> type.\n%mode cong_nume +E -E'.\n\n- : cong_nume   refl_n refl_e.\n\n%worlds () (cong_nume _ _).\n%total E (cong_nume E _).\n\n\ncong_stre   : eqnat S1 S2 -> eqexp (stre S1) (stre S2) -> type.\n%mode cong_stre +E -E'.\n\n- : cong_stre   refl_n refl_e.\n\n%worlds () (cong_stre _ _).\n%total E (cong_stre E _).\n\n\ncong_plus1  : eqexp E1 E2 -> eqexp (plus E1 F) (plus E2 F) -> type.\n%mode +{E1:exp} +{E2:exp} +{F:exp} +{E:eqexp E1 E2}\n   -{E':eqexp (plus E1 F) (plus E2 F)} (cong_plus1 E E').\n\n- : cong_plus1  refl_e refl_e.\n\n%worlds () (cong_plus1 _ _).\n%total E (cong_plus1 E _).\n\n\ncong_plus2  : eqexp F1 F2 -> eqexp (plus E F1) (plus E F2) -> type.\n%mode +{F1:exp} +{F2:exp} +{E:exp} +{E1:eqexp F1 F2}\n   -{E':eqexp (plus E F1) (plus E F2)} (cong_plus2 E1 E').\n\n- : cong_plus2  refl_e refl_e.\n\n%worlds () (cong_plus2 _ _).\n%total E (cong_plus2 E _).\n\n\ncong_times1 : eqexp E1 E2 -> eqexp (times E1 F) (times E2 F) -> type.\n%mode +{E1:exp} +{E2:exp} +{F:exp} +{E:eqexp E1 E2}\n   -{E':eqexp (times E1 F) (times E2 F)} (cong_times1 E E').\n\n- : cong_times1 refl_e refl_e.\n\n%worlds () (cong_times1 _ _).\n%total E (cong_times1 E _).\n\n\ncong_times2 : eqexp F1 F2 -> eqexp (times E F1) (times E F2) -> type.\n%mode +{F1:exp} +{F2:exp} +{E:exp} +{E2:eqexp F1 F2}\n   -{E':eqexp (times E F1) (times E F2)} (cong_times2 E2 E').\n\n- : cong_times2 refl_e refl_e.\n\n%worlds () (cong_times2 _ _).\n%total E (cong_times2 E _).\n\n\ncong_cat1   : eqexp E1 E2 -> eqexp (cat E1 F) (cat E2 F) -> type.\n%mode +{E1:exp} +{E2:exp} +{F:exp} +{E:eqexp E1 E2}\n   -{E':eqexp (cat E1 F) (cat E2 F)} (cong_cat1 E E').\n\n- : cong_cat1   refl_e refl_e.\n\n%worlds () (cong_cat1 _ _).\n%total E (cong_cat1 E _).\n\n\ncong_cat2   : eqexp F1 F2 -> eqexp (cat E F1) (cat E F2) -> type.\n%mode +{F1:exp} +{F2:exp} +{E:exp} +{E3:eqexp F1 F2}\n   -{E':eqexp (cat E F1) (cat E F2)} (cong_cat2 E3 E').\n\n- : cong_cat2   refl_e refl_e.\n\n%worlds () (cong_cat2 _ _).\n%total E (cong_cat2 E _).\n\n\ncong_len    : eqexp E1 E2 -> eqexp (len E1) (len E2) -> type.\n%mode cong_len +E -E'.\n\n- : cong_len    refl_e refl_e.\n\n%worlds () (cong_len _ _).\n%total E (cong_len E _).\n\n\ncong_let    : eqexp E1 E2 -> eqexp (let E1 F) (let E2 F) -> type.\n%mode +{E1:exp} +{E2:exp} +{F:exp -> exp} +{E:eqexp E1 E2}\n   -{E':eqexp (let E1 ([x:exp] F x)) (let E2 ([x:exp] F x))} (cong_let E E').\n\n- : cong_let    refl_e refl_e.\n\n%worlds () (cong_let _ _).\n%total E (cong_let E _).\n\n\n% Uniqueness of plus\n\nplus! : plus_op N M L1 -> plus_op N M L2 -> eqnat L1 L2 -> type.\n%mode plus! +Pj1 +Pj2 -EL.\n\n- : plus! plus_op/0 plus_op/0 refl_n.\n\n- : plus! (plus_op/s Pj1) (plus_op/s Pj2) ES\n     <- plus! Pj1 Pj2 EL\n     <- cong_s EL ES.\n\n%worlds () (plus! _ _ _).\n%total Pj1 (plus! Pj1 _ _).\n\n\n% Congruence of plus\n\nplus_cong : eqnat N1 N2 -> plus_op N1 M L1 -> plus_op N2 M L2\n             -> eqnat L1 L2 -> type.\n%mode plus_cong +EN +Pj1 +Pj2 -EL.\n\n- : plus_cong refl_n plus_op/0 plus_op/0 refl_n.\n\n- : plus_cong refl_n (plus_op/s Pj1) (plus_op/s Pj2) ES\n     <- plus_cong refl_n Pj1 Pj2 EL\n     <- cong_s EL ES.\n\n%worlds () (plus_cong _ _ _ _).\n%total PjL (plus_cong _ PjL _ _).\n\n\n% Uniqueness of times\n\ntimes! : times_op N M L1 -> times_op N M L2 -> eqnat L1 L2 -> type.\n%mode times! +Tj1 +Tj2 -EL.\n\n- : times! times_op/0 times_op/0 refl_n.\n\n- : times! (times_op/s Pj1 Tj1) (times_op/s Pj2 Tj2) ES\n     <- times! Tj1 Tj2 EL\n     <- plus_cong EL Pj1 Pj2 ES.\n\n%worlds () (times! _ _ _).\n%total Tj1 (times! Tj1 _ _).\n\n\n\n% Proof of Lemma 10.1\n\nlemma10-1 : red E E1 -> red E E2 -> eqexp E1 E2 -> type.\n%mode lemma10-1 +RjE1 +RjE2 -EE.\n\n- : lemma10-1 (red/plus/num PjN1) (red/plus/num PjN2) EE'\n     <- plus! PjN1 PjN2 EL\n     <- cong_nume EL EE'.\n\n- : lemma10-1 (red/plus1 RjE1) (red/plus1 RjE2) EE'\n     <- lemma10-1 RjE1 RjE2 EE\n     <- cong_plus1 EE EE'.\n\n- : lemma10-1 (red/plus2 _ RjF1) (red/plus2 _ RjF2) EE'\n     <- lemma10-1 RjF1 RjF2 EF\n     <- cong_plus2 EF EE'.\n\n- : lemma10-1 (red/times/num TjN1) (red/times/num TjN2) EE'\n     <- times! TjN1 TjN2 EE\n     <- cong_nume EE EE'.\n\n- : lemma10-1 (red/times1 RjE1) (red/times1 RjE2) EE'\n     <- lemma10-1 RjE1 RjE2 EE\n     <- cong_times1 EE EE'.\n\n- : lemma10-1 (red/times2 _ RjF1) (red/times2 _ RjF2) EE'\n     <- lemma10-1 RjF1 RjF2 EF\n     <- cong_times2 EF EE'.\n\n- : lemma10-1 (red/cat/str PjN1) (red/cat/str PjN2) EE'\n     <- plus! PjN1 PjN2 EE\n     <- cong_stre EE EE'.\n\n- : lemma10-1 (red/cat1 RjE1) (red/cat1 RjE2) EE'\n     <- lemma10-1 RjE1 RjE2 EE\n     <- cong_cat1 EE EE'.\n\n- : lemma10-1 (red/cat2 _ RjF1) (red/cat2 _ RjF2) EE'\n     <- lemma10-1 RjF1 RjF2 EF\n     <- cong_cat2 EF EE'.\n\n- : lemma10-1 (red/len/str:red (len (stre S)) (nume S)) red/len/str EE'\n     <- cong_nume refl_n EE'.\n\n- : lemma10-1 (red/len RjE1) (red/len RjE2) EE'\n     <- lemma10-1 RjE1 RjE2 EE\n     <- cong_len EE EE'.\n\n- : lemma10-1 (red/let/val VjE11) (red/let/val VjE12) refl_e.\n\n- : lemma10-1 (red/let RjE1) (red/let RjE2) EE'\n     <- lemma10-1 RjE1 RjE2 EE\n     <- cong_let EE EE'.\n\n\n%worlds () (lemma10-1 _ _ _).\n%total RjE (lemma10-1 RjE _ _).\n</twelf>\n\n== Problem 3: Contextual Semantics ==\n\nIn this problem, we define the contextual semantics for L{num str} and proof that it is equivalent to (defines the same relation as) the given dynamic semantics (reduction).\n\n<twelf>\n\n%%%%%%%%%%%%%%%% L{num str}: Contextual Semantics %%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n% Instructions:  E0 ~> E0'\n\ninstr : exp -> exp -> type.\n\ninstr/plus  : plus_op N1 N2 N\n               -> instr (plus (nume N1) (nume N2)) (nume N).\n\ninstr/times : times_op N1 N2 N\n               -> instr (times (nume N1) (nume N2)) (nume N).\n\ninstr/cat   : plus_op S1 S2 S\n               -> instr (cat (stre S1) (stre S2)) (stre S).\n\ninstr/len   : instr (len (stre S)) (nume S).\n\ninstr/let   : val E1\n               -> instr (let E1 ([x] E2 x)) (E2 E1).\n\n\n% Expression contexts, represented as \"expressions with holes\", i.e.,\n% functions on expressions.\n\nectxt : (exp -> exp) -> type.\n\nectxt/hole   : ectxt ([x] x).\n\nectxt/plus1  : ectxt ([x] C1 x)\n                -> ectxt ([x] plus (C1 x) E2).\n\nectxt/plus2  : val E1 -> ectxt ([x] C2 x)\n                -> ectxt ([x] plus E1 (C2 x)).\n\nectxt/times1 : ectxt ([x] C1 x)\n                -> ectxt ([x] times (C1 x) E2).\n\nectxt/times2 : val E1 -> ectxt ([x] C2 x)\n                -> ectxt ([x] times  E1 (C2 x)).\n\nectxt/cat1   : ectxt ([x] C1 x)\n                -> ectxt ([x] cat (C1 x) E2).\n\nectxt/cat2   : val E1 -> ectxt ([x] C2 x)\n                -> ectxt ([x] cat E1 (C2 x)).\n\nectxt/len    : ectxt ([x] C x)\n                -> ectxt ([x] len (C x)).\n\nectxt/let    : ectxt ([x] C1 x)\n                -> ectxt ([x] let (C1 x) ([y] E2 y)).\n\n\n% Filling the hole of an expression context with an expression\n\nfill : ectxt ([x] C x) -> exp -> exp -> type.\n\nfill/hole   : fill ectxt/hole E E.\n\nfill/plus1  : fill ECC1 E C1@E\n               -> fill (ectxt/plus1 ECC1:ectxt ([x] plus (C1 x) E2)) E\n                  (plus C1@E E2).\n\nfill/plus2  : {VjE1:val E1} fill ECC2 E C2@E\n               -> fill (ectxt/plus2 VjE1 ECC2) E (plus E1 C2@E).\n\nfill/times1 : fill ECC1 E C1@E\n               -> fill (ectxt/times1 ECC1:ectxt ([x] times (C1 x) E2)) E\n                 (times C1@E E2).\n\nfill/times2 : {VjE1:val E1} fill ECC2 E C2@E\n               -> fill (ectxt/times2 VjE1 ECC2) E (times E1 C2@E).\n\nfill/cat1   : fill ECC1 E C1@E\n               -> fill (ectxt/cat1 ECC1:ectxt ([x] cat (C1 x) E2)) E\n                  (cat C1@E E2).\n\nfill/cat2   : {VjE1:val E1} fill ECC2 E C2@E\n               -> fill (ectxt/cat2 VjE1 ECC2) E (cat E1 C2@E).\n\nfill/len    : fill ECC1 E C1@E\n               -> fill (ectxt/len ECC1) E (len C1@E).\n\nfill/let    : fill ECC1 E C1@E\n               -> fill (ectxt/let ECC1:ectxt ([x] let (C1 x) [y] E2 y)) E\n                  (let C1@E ([y] E2 y)).\n\n\n% Contextual reduction rule\n\ncred : exp -> exp -> type.\n\ncred/step : fill EC E0 C@E0 -> instr E0 E0' -> fill EC E0' C@E0'\n             -> cred C@E0 C@E0'.\n\n\n\n%%%%%%%%%%%%%%%% Theorem 10.2.1 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n% If E |-> E', then E |->c E'.\n\nthm10-2-1 : red E E' -> cred E E' -> type.\n%mode thm10-2-1 +RjE -CjE.\n\n- : thm10-2-1 (red/plus/num PjN)\n     (cred/step fill/hole (instr/plus PjN) fill/hole).\n\n- : thm10-2-1 (red/plus1 RjE1)\n     (cred/step (fill/plus1 FjC1@E0) I (fill/plus1 FjC1@E0'))\n     <- thm10-2-1 RjE1 (cred/step FjC1@E0 I FjC1@E0').\n\n- : thm10-2-1 (red/plus2 VjE1 RjE2)\n     (cred/step (fill/plus2 VjE1 FjC2@E0) I (fill/plus2 VjE1 FjC2@E0'))\n     <- thm10-2-1 RjE2 (cred/step FjC2@E0 I FjC2@E0').\n\n- : thm10-2-1 (red/times/num TjN)\n     (cred/step fill/hole (instr/times TjN) fill/hole).\n\n- : thm10-2-1 (red/times1 RjE1)\n     (cred/step (fill/times1 FjC1@E0) I (fill/times1 FjC1@E0'))\n     <- thm10-2-1 RjE1 (cred/step FjC1@E0 I FjC1@E0').\n\n- : thm10-2-1 (red/times2 VjE1 RjE2)\n     (cred/step (fill/times2 VjE1 FjC2@E0) I (fill/times2 VjE1 FjC2@E0'))\n     <- thm10-2-1 RjE2 (cred/step FjC2@E0 I FjC2@E0').\n\n- : thm10-2-1 (red/cat/str PjN)\n     (cred/step fill/hole (instr/cat PjN) fill/hole).\n\n- : thm10-2-1 (red/cat1 RjE1)\n     (cred/step (fill/cat1 FjC1@E0) I (fill/cat1 FjC1@E0'))\n     <- thm10-2-1 RjE1 (cred/step FjC1@E0 I FjC1@E0').\n\n- : thm10-2-1 (red/cat2 VjE1 RjE2)\n     (cred/step (fill/cat2 VjE1 FjC2@E0) I (fill/cat2 VjE1 FjC2@E0'))\n     <- thm10-2-1 RjE2 (cred/step FjC2@E0 I FjC2@E0').\n\n- : thm10-2-1 red/len/str\n     (cred/step fill/hole instr/len fill/hole).\n\n- : thm10-2-1 (red/len RjE1)\n     (cred/step (fill/len FjC1@E0) I (fill/len FjC1@E0'))\n     <- thm10-2-1 RjE1 (cred/step FjC1@E0 I FjC1@E0').\n\n- : thm10-2-1 (red/let/val VjE1)\n     (cred/step fill/hole (instr/let VjE1) fill/hole).\n\n- : thm10-2-1 (red/let RjE1)\n     (cred/step (fill/let FjC1@E0) I (fill/let FjC1@E0'))\n     <- thm10-2-1 RjE1 (cred/step FjC1@E0 I FjC1@E0').\n\n%worlds () (thm10-2-1 _ _).\n%total RjE (thm10-2-1 RjE _).\n\n\n\n%%%%%%%%%%%%%%%% Theorem 10.2.2 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n% If E |->c E', then E |-> E'.\n\nthm10-2-2 : cred E E' -> red E E' -> type.\n%mode thm10-2-2 +CjE -RjE.\n\n\n% Lemma.  If C{E0} = E, E0 ~> E0', and C{E0'} = E', then E |-> E'.\n\nlem10-2-2 : fill EC E0 E -> instr E0 E0' -> fill EC E0' E'\n             -> red E E' -> type.\n%mode lem10-2-2 +FjE +I +FjE' -RjE.\n\n- : lem10-2-2 fill/hole (instr/plus PjN) fill/hole (red/plus/num PjN).\n\n- : lem10-2-2 fill/hole (instr/times TjN) fill/hole (red/times/num TjN).\n\n- : lem10-2-2 fill/hole (instr/cat PjN) fill/hole (red/cat/str PjN).\n\n- : lem10-2-2 fill/hole instr/len fill/hole red/len/str.\n\n- : lem10-2-2 fill/hole (instr/let VjE1) fill/hole (red/let/val VjE1).\n\n- : lem10-2-2 (fill/plus1 FjC1@E0) I (fill/plus1 FjC1@E0') (red/plus1 RjE)\n     <- lem10-2-2 FjC1@E0 I FjC1@E0' RjE.\n\n- : lem10-2-2 (fill/plus2 VjE1 FjC2@E0) I (fill/plus2 VjE1 FjC2@E0')\n     (red/plus2 VjE1 RjE)\n     <- lem10-2-2 FjC2@E0 I FjC2@E0' RjE.\n\n- : lem10-2-2 (fill/times1 FjC1@E0) I (fill/times1 FjC1@E0') (red/times1 RjE)\n     <- lem10-2-2 FjC1@E0 I FjC1@E0' RjE.\n\n- : lem10-2-2 (fill/times2 VjE1 FjC2@E0) I (fill/times2 VjE1 FjC2@E0')\n     (red/times2 VjE1 RjE)\n     <- lem10-2-2 FjC2@E0 I FjC2@E0' RjE.\n\n- : lem10-2-2 (fill/cat1 FjC1@E0) I (fill/cat1 FjC1@E0') (red/cat1 RjE)\n     <- lem10-2-2 FjC1@E0 I FjC1@E0' RjE.\n\n- : lem10-2-2 (fill/cat2 VjE1 FjC2@E0) I (fill/cat2 VjE1 FjC2@E0')\n     (red/cat2 VjE1 RjE)\n     <- lem10-2-2 FjC2@E0 I FjC2@E0' RjE.\n\n- : lem10-2-2 (fill/len FjC1@E0) I (fill/len FjC1@E0') (red/len RjE)\n     <- lem10-2-2 FjC1@E0 I FjC1@E0' RjE.\n\n- : lem10-2-2 (fill/let FjC2@E0) I (fill/let FjC2@E0')\n     (red/let RjE)\n     <- lem10-2-2 FjC2@E0 I FjC2@E0' RjE.\n\n%worlds () (lem10-2-2 _ _ _ _).\n%total FjE (lem10-2-2 FjE _ _ _).\n\n\n% Proof of main theorem\n\n- : thm10-2-2 (cred/step FjC@E0 I FjC@E0') RjE\n     <- lem10-2-2 FjC@E0 I FjC@E0' RjE.\n\n%worlds () (thm10-2-2 _ _).\n%total {} (thm10-2-2 _ _).\n</twelf>\n\n== Twelf Output ==\n\nThe <twelflink check=\"true\">output</twelflink> for the above."
          },
          "sha1": "ok3yw8l7g0dja6nt7iw7zofkz96pdti"
        }
      },
      {
        "title": "POPL Tutorial/Saturday",
        "ns": 0,
        "id": 2130,
        "revision": {
          "id": 5680,
          "parentid": 5679,
          "timestamp": "2008-11-22T22:23:36Z",
          "contributor": {
            "username": "William Lovas",
            "id": 11
          },
          "comment": "/* Notes from Saturday */",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 2991,
            "#text": "== Notes from Saturday ==\n\nPlease fill out our <big>'''''[https://spreadsheets.google.com/viewform?key=p0-89EvFXQhUXF827jjk_Dg feedback form]'''''</big>.\n\nIf you have questions, you can email a TA at <tt>twelfelf@gmail.com</tt>.\n\nCheck out [[POPL Tutorial/Session 5|Session 5]]'s material: do some practice problems, email us feedback.\n\n== Mechanizing Metatheory with LF and Twelf ==\n\nDo you want to learn how to use [[Main page|Twelf]] to specify, implement, and prove\nproperties about programming languages?  \n\nCome to the Twelf tutorial on '''January 19, 2009''', co-located with POPL 2009, in\n'''Savannah, Georgia'''.\n\nLearn to:\n* Represent [[deductive systems|languages and logics]] in [[LF]]\n* Prove [[metatheorem]]s with [[Main page|Twelf]]\nunder the helpful guidance of Twelf experts.  \n\nThe tutorial will be a highly interactive introduction to LF and Twelf\naimed at programming languages researchers. No prior experience with LF\nand Twelf is presumed.  Participants will leave the workshop with\nexperience in reading and writing LF representations of programming\nlanguages, and experience reading, writing, and debugging Twelf proofs.\n\nRegister at the [http://www.regmaster.com/conf/popl2009.html POPL 2009 registration site]!  \nThe early registration deadline is '''December 19'''.\n                                                                                                                                                            \nThe tutorial is organized and presented by the CMU Principles of\nProgramming group.\n\n== Schedule ==\n\n* Session 1 (11AM-noon): [http://www.cs.cmu.edu/~drl/tmp/twelflectures.pdf Overview of LF and Twelf]\n* Session 2 (12:15-1:15PM): [[POPL_Tutorial/Session 2|Working with Twelf]]\n* Session 3 (1:30PM-2:30PM): [http://www.cs.cmu.edu/~drl/tmp/twelflectures.pdf Adequacy]\n* Pizza break\n* Session 4 (3:00PM-4:30PM): [[POPL_Tutorial/Session 4|Type safety for MinML]]\n* Session 5 (4:45PM-6:15PM): [[POPL_Tutorial/Session 5|Work on exercies]]\n\n== Get Twelf before the tutorial! ==\n\nThe tutorial will be interactive, with participants writing Twelf code, so you should come with Twelf installed on your laptop.\n\nPre-built binaries of Twelf are available for most operating systems through the [http://twelf.plparty.org/builds Twelf Night(ly)].\n* [http://twelf.plparty.org/builds/twelf-linux.tar.gz Linux (tgz)]\n* [http://twelf.plparty.org/builds/twelf.exe Windows (exe)]\n* [http://twelf.plparty.org/builds/twelf-osx-intel.dmg Mac OS 10.4 or 10.5 (Intel only) (dmg)]\n\nOtherwise:\n* you can build Twelf from the [http://twelf.plparty.org/builds/twelf-src.tar.gz source tarball].  You will need [http://www.mlton.org MLton] or [http://www.smlnj.org sml/nj]. \n* you can make yourself an account on the wiki, and do the exercises on your User:<login> page (linked at the top after you log in).\n\nThen see [[Twelf with Emacs]] for the basics of interacting with Twelf.  (You can also use [[Twelf without Emacs]], by interacting with the Twelf server directly.)"
          },
          "sha1": "q1n3eacbcutw559inj8eu8kbr6ed4gs"
        }
      },
      {
        "title": "POPL Tutorial/Sequent vs Natural Deduction",
        "ns": 0,
        "id": 2095,
        "revision": {
          "id": 5811,
          "parentid": 5809,
          "timestamp": "2009-01-18T07:09:11Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 6285,
            "#text": "%{ \n\nIn this exercise, we will present rules for natural deduction and for a sequent calculus presentation of intuitionistic logic, and give an two incomplete proofs. The first establishes that derivability in natural deduction implies derivability in the sequent calculus, the second establishes the converse.\n\nThere are two tasks:\n* Complete the three cases of the natural deduction -> sequent calculus proof relating to conjunction.\n* Complete the three cases of the sequent calculus -> natural deduction proof relating to implication and cut.\n\nThe solution is [[POPL Tutorial/Sequent vs Natural Deduction: Solution | here]].\n\n== Syntax for Propositions ==\n\n}%\n\nprop : type.  %name prop A.\n\ntop : prop.\nand : prop -> prop -> prop.\nimp : prop -> prop -> prop.\n\n%{\n\n== Natural Deduction Inference Rules ==\n\nNatural deduction deals with a single judgment, <math>\\texttt{true}~A</math>.\n\n}%\n\ntrue : prop -> type.\n\n%{\n\nSix rules describe a natural deduction system for the language considered here.\n\n}%\n\ntopI  : true top.\n\nandI  : true (and A B)\n             <- true B\n             <- true A.\n\nandE1 : true A\n         <- true (and A B).\n\nandE2 : true B\n         <- true (and A B).\n\nimpI  : true (imp A B)\n         <- (true A -> true B).\n\nimpE  : true B\n         <- true (imp A B)\n         <- true A.\n\n%{\n\n== Sequent Calculus ==\n\nWith the same grammar of propositions, we can define a sequent\ncalculus with different judgments for the left and the right of\nthe sequent (<math>\\texttt{hyp}~A</math> for the left and <math>\\texttt{conc}~A</math> for the right).\n\n}%\n\nhyp : prop -> type.\n\nconc : prop -> type.\n\n%{\n\nThis particular sequent calculus includes the cut rule. We can show\nseparately that it is possible to eliminate all uses of cut by proving\nthe [[admissibility of cut]].\n\n}%\n\ninit : conc A\n        <- hyp A.\n\ntopR : conc top.\n\nandL : (hyp (and A B) -> conc C)\n        <- (hyp A -> hyp B -> conc C).\n\nandR : conc (and A B)\n        <- conc B\n        <- conc A.\n\nimpL : (hyp (imp A B) -> conc C)\n        <- conc A\n        <- (hyp B -> conc C).\n\nimpR : conc (imp A B)\n        <- (hyp A -> conc B).\n\ncut  : conc B\n        <- conc A\n        <- (hyp A -> conc B).\n\n%{ \n\nThe natural deduction system exists in a world with arbitrary assumptions <math>\\texttt{hyp}~A</math>.\n\n}%\n\n%block bhyp : some {A : prop} block {H : hyp A}.\n\n%{\n\n== Translation: Natural Deduction to Sequent Calculus ==\n\nThe following (incomplete) proof establishes that whenever a proposition is true in the natural deduction system, it is derivable as a conclusion in the sequent calculus.\n\nThe cases for top and implication are filled in for you; all that remains is\nthe cases for conjunction.\n\nThe -impI case provides and example of using a theorem case. You will need\nsomething similar in the translation for the other direction.\n\n==== TASK 1: Fill in the three missing cases for conjunction ====\n\n}%\n\nnd-to-seq : true A \n             -> conc A\n             -> type.\n%mode nd-to-seq +X1 -X2.\n\n-top : nd-to-seq topI topR.\n\n% fill in here.\n-andI : nd-to-seq \n         (andI (DtrueA : true A) (DtrueB : true B)) %% true (and A B)\n         XXX. \n\n% fill in here.\n-andE1 : nd-to-seq\n          (andE1 (DtrueAB : true (and A B))) %% true A\n          XXX.\n\n% fill in here.\n-andE2 : nd-to-seq\n          (andE2 (DtrueAB : true (and A B))) %% true B\n          XXX.\n\n-impI : nd-to-seq \n         (impI ([dA : true A] Dimp dA : true B)) %% true (imp A B)\n         (impR [hA : hyp A] (DconcB hA))\n      <- ({dA : true A}\n             {hA : hyp A}\n             {dtrans : nd-to-seq dA (init hA)}\n             nd-to-seq (Dimp dA) (DconcB hA : conc B)).\n\n-impE : nd-to-seq \n         (impE (DtrueA : true A) (DtrueAB : true (imp A B))) %% true B\n         (cut (impL ([hB : hyp B] init hB) DconcA) DconcAB)\n      <- nd-to-seq DtrueA (DconcA : conc A)\n      <- nd-to-seq DtrueAB (DconcAB : conc (imp A B)).\n\n\n\n%block truetohyp : some {A : prop} block \n            {DA : true A} {HA : hyp A} {Dtrans : nd-to-seq DA (init HA)}.\n\n%worlds (truetohyp) (nd-to-seq _ _).\n%trustme %total D (nd-to-seq D _).\n\n\n%{\n\n== Translation: Sequent Calculus to Natural Deduction ==\n\n\nThe following (incomplete) proof establishes that whenever a proposition is derivable as a conclusion in the sequent calculus, it is true in the natural deduction system.\n\n==== TASK 2: Complete the theorem with cases for implication and cut ====\n\n}%\n\nhyp-to-true : hyp A -> true A -> type.\n%mode hyp-to-true +X1 -X2.\n\n%block hyptotrue : some {A : prop}\n           block {HA : hyp A} {DA : true A} {Dtrans : hyp-to-true HA DA}.\n%worlds (hyptotrue) (hyp-to-true _ _).\n%total {} (hyp-to-true _ _).\n\n\nseq-to-nd : conc A -> true A -> type.\n%mode seq-to-nd +X1 -X2.\n\n-init   : seq-to-nd (init (DhypA : hyp A)) DtrueA\n           <- hyp-to-true DhypA (DtrueA : true A).\n\n-top    : seq-to-nd (topR : conc top) topI.\n\n-andR   : seq-to-nd \n              (andR\n                  (DconcA : conc A)\n                  (DconcB : conc B) : conc (and A B))\n              (andI\n                  DtrueA\n                  DtrueB)\n           <- seq-to-nd DconcA (DtrueA : true A)\n           <- seq-to-nd DconcB (DtrueB : true B).\n\n-andL   : seq-to-nd \n              (andL \n                  ([hA : hyp A] [hB : hyp B] DconcC hA hB : conc C)\n                  (Hab : hyp (and A B))\n                : conc C)\n              (DtrueC (andE1 DtrueAB) (andE2 DtrueAB))\n           <- ({hA} {dA : true A} {dtransA : hyp-to-true hA dA}\n                  {hB} {dB : true B} {dtransB : hyp-to-true hB dB}\n                      seq-to-nd (DconcC hA hB)\n                      (DtrueC dA dB : true C))\n           <- hyp-to-true Hab (DtrueAB : true (and A B)).\n\n%% fill in here\n-impR   : seq-to-nd\n              (impR\n                  ([hA] DconcB hA : conc B) : conc (imp A B))\n              XXX.\n\n%% fill in here\n-impL   : seq-to-nd\n              (impL\n                  ([hB : hyp B] DconcC hB : conc C)\n                  (DconcA : conc A)\n                  (Hab : hyp (imp A B)))\n              XXX.\n\n%% fill in here\n-cut    : seq-to-nd\n              (cut\n                  ([hA : hyp A] DconcB hA : conc B)\n                  (DconcA : conc A))\n              XXX.\n\n%worlds (hyptotrue) (seq-to-nd _ _).\n%total D (seq-to-nd D _).\n\n%{\n[[POPL Tutorial/Sequent vs Natural Deduction: Solution | Solution]]\n}%"
          },
          "sha1": "pdfi4bha5x8eyx4ua8g09nkrdp994zy"
        }
      },
      {
        "title": "POPL Tutorial/Sequent vs Natural Deduction: Solution",
        "ns": 0,
        "id": 2117,
        "revision": {
          "id": 5805,
          "parentid": 5803,
          "timestamp": "2009-01-18T06:40:31Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 5168,
            "#text": "%{This is the solution to [[POPL Tutorial/Sequent vs Natural Deduction|this exercise]].\n|hidden = true}%\n\n%% Syntax for Propositions %%\n\nprop : type.  %name prop A.\n\ntop : prop.\nand : prop -> prop -> prop.\nimp : prop -> prop -> prop.\n\n\n%% Natural Deduction Inference Rules %%\n\ntrue : prop -> type.\n\ntopI  : true top.\n\nandI  : true (and A B)\n             <- true B\n             <- true A.\n\nandE1 : true A\n         <- true (and A B).\n\nandE2 : true B\n         <- true (and A B).\n\nimpI  : true (imp A B)\n         <- (true A -> true B).\n\nimpE  : true B\n         <- true (imp A B)\n         <- true A.\n\n\n%% Sequent Calculus %%\n\nhyp : prop -> type.\n\nconc : prop -> type.\n\ninit : conc A\n        <- hyp A.\n\ntopR : conc top.\n\nandL : (hyp (and A B) -> conc C)\n        <- (hyp A -> hyp B -> conc C).\n\nandR : conc (and A B)\n        <- conc B\n        <- conc A.\n\nimpL : (hyp (imp A B) -> conc C)\n        <- conc A\n        <- (hyp B -> conc C).\n\nimpR : conc (imp A B)\n        <- (hyp A -> conc B).\n\ncut  : conc B\n        <- conc A\n        <- (hyp A -> conc B).\n\n\n%%  blocks  %%\n\n%block bhyp : some {A : prop} block {H : hyp A}.\n\n%{\n\n== Translation: Natural Deduction to Sequent Calculus ==\n\n}%\n\nnd-to-seq : true A -> conc A -> type.\n%mode nd-to-seq +X1 -X2.\n\n-top      : nd-to-seq topI topR.\n\n-andI     : nd-to-seq (andI (DtrueA : true A) (DtrueB : true B)) %% true (and A B)\n                (andR DconcA DconcB)\n             <- nd-to-seq DtrueA (DconcA : conc A)\n             <- nd-to-seq DtrueB (DconcB : conc B).\n\n-andE1    : nd-to-seq (andE1 (DtrueAB : true (and A B))) %% true A\n                (cut (andL ([dA : hyp A] [_] (init dA))) DconcAB)\n             <- nd-to-seq DtrueAB (DconcAB : conc (and A B)).\n\n-andE2    : nd-to-seq (andE2 (DtrueAB : true (and A B))) %% true B\n                (cut (andL ([_] [dB : hyp B] (init dB))) DconcAB)\n             <- nd-to-seq DtrueAB (DconcAB : conc (and A B)).\n\n-impI     : nd-to-seq (impI ([dA : true A] Dimp dA : true B)) %% true (imp A B)\n                (impR [hA : hyp A] (DconcB hA))\n             <- ({dA : true A}\n                    {hA : hyp A}\n                    {dtrans : nd-to-seq dA (init hA)}\n                    nd-to-seq (Dimp dA) (DconcB hA : conc B)).\n\n-impE     : nd-to-seq (impE (DtrueA : true A) (DtrueAB : true (imp A B))) %% true B\n                (cut (impL ([hB : hyp B] init hB) DconcA) DconcAB)\n             <- nd-to-seq DtrueA (DconcA : conc A)\n             <- nd-to-seq DtrueAB (DconcAB : conc (imp A B)).\n\n%block truetohyp : some {A : prop} block \n            {DA : true A} {HA : hyp A} {Dtrans : nd-to-seq DA (init HA)}.\n\n%worlds (truetohyp) (nd-to-seq _ _).\n%total D (nd-to-seq D _).\n\n\n%{\n\n== Translation: Sequent Calculus to Natural Deduction ==\n\n}%\n\nhyp-to-true : hyp A -> true A -> type.\n%mode hyp-to-true +X1 -X2.\n\n%block hyptotrue : some {A : prop}\n           block {HA : hyp A} {DA : true A} {Dtrans : hyp-to-true HA DA}.\n%worlds (hyptotrue) (hyp-to-true _ _).\n%total {} (hyp-to-true _ _).\n\n\nseq-to-nd : conc A -> true A -> type.\n%mode seq-to-nd +X1 -X2.\n\n-init   : seq-to-nd (init (DhypA : hyp A)) DtrueA\n           <- hyp-to-true DhypA (DtrueA : true A).\n\n-top    : seq-to-nd (topR : conc top) topI.\n\n-andR   : seq-to-nd \n              (andR\n                  (DconcA : conc A)\n                  (DconcB : conc B) : conc (and A B))\n              (andI\n                  DtrueA\n                  DtrueB)\n           <- seq-to-nd DconcA (DtrueA : true A)\n           <- seq-to-nd DconcB (DtrueB : true B).\n\n-andL   : seq-to-nd \n              (andL \n                  ([hA : hyp A] [hB : hyp B] DconcC hA hB : conc C)\n                  (Hab : hyp (and A B))\n                : conc C)\n              (DtrueC (andE1 DtrueAB) (andE2 DtrueAB))\n           <- ({hA} {dA : true A} {dtransA : hyp-to-true hA dA}\n                  {hB} {dB : true B} {dtransB : hyp-to-true hB dB}\n                      seq-to-nd (DconcC hA hB)\n                      (DtrueC dA dB : true C))\n           <- hyp-to-true Hab (DtrueAB : true (and A B)).\n\n-impR   : seq-to-nd\n              (impR\n                  ([hA] DconcB hA : conc B) : conc (imp A B))\n              (impI ([dA] DtrueB dA))\n           <- ({hA} {dA : true A} {dtrans : hyp-to-true hA dA}\n                  seq-to-nd (DconcB hA)\n                  (DtrueB dA : true B)).\n\n-impL   : seq-to-nd\n              (impL\n                  ([hB : hyp B] DconcC hB : conc C)\n                  (DconcA : conc A)\n                  (Hab : hyp (imp A B)))\n              (DtrueC (impE DtrueA DtrueAB))\n           <- ({hB} {dB : true B} {dtrans : hyp-to-true hB dB}\n                  seq-to-nd (DconcC hB)\n                  (DtrueC dB : true C))\n           <- seq-to-nd DconcA (DtrueA : true A)\n           <- hyp-to-true Hab (DtrueAB : true (imp A B)).\n\n-cut    : seq-to-nd\n              (cut\n                  ([hA : hyp A] DconcB hA : conc B)\n                  (DconcA : conc A))\n              (DtrueB DtrueA)\n           <- ({hA} {dA : true A} {dtrans : hyp-to-true hA dA}\n                  seq-to-nd (DconcB hA)\n                  (DtrueB dA : true B))\n           <- seq-to-nd DconcA\n              (DtrueA : true A).\n\n%worlds (hyptotrue) (seq-to-nd _ _).\n%total D (seq-to-nd D _)."
          },
          "sha1": "p5uuzxh8c6jsphdemcqcxi0e5aki1q9"
        }
      },
      {
        "title": "POPL Tutorial/Session2",
        "ns": 0,
        "id": 2134,
        "redirect": {
          "@title": "POPL Tutorial/Session 2 Answer",
          "#text": null
        },
        "revision": {
          "id": 5664,
          "timestamp": "2008-11-22T05:56:06Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "comment": "[[POPL Tutorial/Session2]] moved to [[POPL Tutorial/Session 2 Answer]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 44,
            "#text": "#REDIRECT [[POPL Tutorial/Session 2 Answer]]"
          },
          "sha1": "4xfhc2a4t4qgl9zhp4yrxwow1r2q2dj"
        }
      },
      {
        "title": "POPL Tutorial/Session 2",
        "ns": 0,
        "id": 2133,
        "revision": {
          "id": 5662,
          "parentid": 5661,
          "timestamp": "2008-11-22T05:55:44Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 124,
            "#text": "# Start from the [[POPL Tutorial/Session 2 Starter|(starter code)]]\n# [[POPL Tutorial/Session 2 Answer|Notes and solutions]]"
          },
          "sha1": "mzpvjt65h1pjenwa8m8ucqi1k6ac5u4"
        }
      },
      {
        "title": "POPL Tutorial/Session 2 Answer",
        "ns": 0,
        "id": 2119,
        "revision": {
          "id": 5663,
          "parentid": 5643,
          "timestamp": "2008-11-22T05:56:06Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "minor": null,
          "comment": "[[POPL Tutorial/Session2]] moved to [[POPL Tutorial/Session 2 Answer]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 15779,
            "#text": "%{\n\n== Arithmetic primitives ==\n\n}%\n\nnat : type.  \nz : nat.\ns : nat -> nat.\n\nadd : nat -> nat -> nat -> type.\n%mode add +M +N -P.\n\nadd/z : add z N N.\nadd/s : add (s M) N (s P) <- add M N P.\n\n%worlds () (add _ _ _).\n%total M (add M _ _).\n\n%{\n\n== Multiplication ==\n\n(Interactively) First, let's write multiplication: \n\nAnswer:\n\n}%\n\nmult : nat -> nat -> nat -> type.\n\nmult/z : mult z N z.\nmult/s : mult (s M) N Q\n\t  <- mult M N P\n\t  <- add P N Q.\n\n%{\n\nNow let's check that multiplication is total.\n\nFirst, we specify the mode: which arguments are inputs, and which\narguments are outputs?\n\nAnswer:\n\n}%\n\n%mode mult +M +N -P.\n\n%{\n\n+ means input (univeral); - means output (existential).  \n\nNext the world:\n\n}%\n\n%worlds () (mult _ _ _).\n\n%{\n\nThis means we consider terms of type mult in the empty LF context only.\n\nFinally, we ask Twelf to check that it is total by induction over the\nfirst argument:\n\n}%\n\n%total M (mult M _ _).\n\n%{\n\nWhat does this really mean? \"For any two LF terms M and N in the empty\ncontext, there exists a term P and a deriation of <tt>mult M N P</tt> in\nthe empty context.\"\n\n==How Twelf checks assertions==\n\nTwelf proves a totality assertion for a type family such as\n<tt>mult</tt> by checking several properties.  These properties, taken\ntogether, constitute a proof by induction on canonical forms that the\ntype family defines a total relation.\n\n===Mode=== \n\nTwelf checks that each constant inhabiting the type family is\n''well-moded''.  Roughly, this means that the inputs to the conclusion\nof a constant determine the inputs of the first premise, and that these\ntogether with the outputs of the first premise determine the inputs of\nthe second premise, and so on, until the outputs of all the premises\ndetermine the outputs of the conclusion.\n\n<twelf name=\"base\" hidden=\"true\">\n%% so we don't get freezing errors\nnat : type.  \nz : nat.\ns : nat -> nat.\n\nadd : nat -> nat -> nat -> type.\n%mode add +M +N -P.\n\nadd/z : add z N N.\nadd/s : add (s M) N (s P) <- add M N P.\n\n%worlds () (add _ _ _).\n%total M (add M _ _).\n</twelf>\n\n<twelf name=\"m\" hidden=\"true\">\nmult : nat -> nat -> nat -> type.\n%mode mult +M +N -P.\n\nmult/z : mult z N z.\nmult/s : mult (s M) N Q\n\t  <- mult M N P\n\t  <- add P N Q.\n</twelf>\n\nFor example, the constant\n<twelf name=\"examplesucc\" ignore=\"true\">\nmult/s : mult (s M) N Q\n\t  <- mult M N P\n\t  <- add P N Q.\n</twelf>\n\nhas mode <tt>+M +N -P</tt> because the input <tt>M</tt> and <tt>N</tt>\nin the conclusion determine the inputs of the premise, and the\n<tt>P</tt> output by the premise determines the first input to the second\npremise (add), and the output of that determines the conclusion.  \nOn the other hand, a constant\n\n<twelf include=\"m\" name=\"badmode\" check=\"decl\">\nmult-bad-mode : mult M N P.\n</twelf>\nis not well-moded---the output <tt>P</tt> is not determined by the\ninputs.  Similarly, \n<twelf include=\"m\" name=\"badmode2\" check=\"decl\">\nmult-badmode2 : mult N1 N2 N3 \n\t\t <- mult N4 N2 N3.  \n</twelf> \nis not well-moded---first input to the premise is not determined\nby the inputs of the conclusion.\n\nSubgoal order matters:\n\n<twelf include=\"m\" name=\"subgoal\" check=\"decl\">\nmult/s : mult (s M) N Q\n\t  <- add P N Q\n\t  <- mult M N P.\n</twelf>\n\n===Worlds===\n\nTwelf checks that each constant inhabiting the type family obeys the\nworlds declaration.  Because we are only proving theorems about closed\nterms right now, we will not run across any problems with world\nchecks.  \n\n===Termination===\n\nTwelf checks that each constant inhabiting the type family obeys the\ninduction order specified in the <tt>%total</tt> declaration.  In each\ninductive premise of a constant, the specified induction position must\nbe a strict subterm of the corresponding argument in the conclusion.\nFor example, the constant\n\n<twelf name=\"termination\" ignore=\"true\">\nmult/s : mult (s M) N Q\n\t  <- mult M N P\n\t  <- add P N Q.\n</twelf>\nobeys the induction order <tt>M</tt> specified in the above totality\nassertion because the term <tt>M</tt> is a strict subterm of the term\n<tt>(s M)</tt>.\n\nOn the other hand, Twelf would not accept the totality of <tt>mult</tt>\nif <tt>N</tt> were used as the induction order&mdash;the same term\n<tt>N</tt> in the conclusion of this constant appears in the premise:\n\n<twelf include=\"m\" name=\"badtotal\" check=\"decl\">\n%total N (mult _ N _).\n</twelf>\n\nIn addition to the subterm ordering on a single argument, Twelf supports\n[[mutual induction]] and [[lexicographic induction]].\n\n===Output coverage===\n\nIn the definition of a type family, you may pattern-match the outputs of\na premise.  For example, we might write\n<twelf include=\"m\" name=\"badoutput\" check=\"decl\">\nmult-bad-output : mult (s N1) N2 (s (s N3))\n                   <- mult N1 N2 (s N3).\n%worlds () (mult _ _ _).\n%total N1 (mult N1 N2 N3).\n</twelf>\n\nHere we have insisted that the output of the premise has the form <tt>s\nN3</tt> for some <tt>N3</tt>.  Twelf correctly reports an output\ncoverage error because this condition can fail..\n\nPattern-matching the output of a premise is like an [[inversion]] step\nin a proof: you're insisting that the premise derivation must conclude a\nparticular fact that is more specific than the judgement form itself.\nFor Twelf to accept a relation as total, Twelf must notice that all of\nthese inversions are permissible.  Twelf permits such inversions when it\nis readily apparent that they are justified, and those inversions that\nTwelf does not accept can be proved explicitly.\n\nIn this example, we got an output coverage error because we constrained\nthe output of the premise by insisting it be formed by a particular\nconstant.  The other way to get output coverage errors is to insist that\nthe output of a premise be a variable that occurs elsewhere in the type.\nFor example:\n\n<twelf include=\"m\" name=\"badoutputfreeness\" check=\"decl\">\nmult-bad-output-freeness : mult (s N1) N2 (s N2)\n                            <- mult N1 N2 N2.\n%worlds () (mult _ _ _).\n%total N1 (mult N1 N2 N3).\n</twelf>\n\nHere, we insisted that the output of the premise be the number\n<tt>N2</tt> that we put in.  Twelf is very conservative in checking\n[[output freeness]]: a type family will not be judged total if you\nconstrain the outputs of any premise at all in this manner.\n\n===Input coverage===\n\nMode, worlds, termination, and output coverage ensure that each constant\nreally does cover the part of the relation indicated by its conclusion.\nFor example, if <tt>mult</tt> passes these four checks, we know that\n<tt>mult/z</tt> and <tt>mult/s</tt> cover <tt>(z, N, _)</tt> and <tt>(s N1,\nN2, _)</tt>, respectively.  What else is necessary to know that\n<tt>mult</tt> defines a total relation?  We need to know that all the\nconstants inhabiting <tt>mult</tt>, taken together, cover all of the\ninputs.  Input coverage checks exactly this.\n\nFor example, if we forgot <tt>mult/z</tt>, input coverage for\n<tt>mult</tt> would fail.  For example:\n\n<twelf include=\"base\" name=\"inputcov\" check=\"decl\">\nmult' : nat -> nat -> nat -> type.\n%mode mult' +N1 +N2 -X3.\n\nmult'/s : mult' (s M) N Q\n\t  <- mult' M N P\n\t  <- add P N Q.\n\n%worlds () (mult' _ _ _).\n%total M (mult' M _ _).\n</twelf>\n\nHere's an analogy that might be helpful: You can think of each constant\nof a type as being a clause in an ML pattern matching declaration.  Then\ninput coverage is like the exhaustiveness checker for pattern matching.\n\nTwelf checks input coverage by [[splitting]] the input types to\ncase-analyze the various constants that could have been used to inhabit\nthem.  For <tt>plus</tt>, Twelf splits the first <tt>nat</tt> argument\n<tt>N1</tt>, and then checks that the cases <tt>plus z N2 N2</tt> and\n<tt>plus (s N1) N2 N3</tt> are covered.  Fortunately, these are exactly\nthe cases we wrote down.  If we had case-analyzed further in the\ndefinition of the judgement (e.g., if the definition of <tt>plus</tt>\ncase-analyzed the second argument as well), Twelf would continue\nsplitting the input space.  Because Twelf separates termination checking\nand coverage checking, the constants defining a type family do not need\nto follow any particular primitive recursion schema-the constants may\npattern-match the inputs in a general manner.\n\n==When Twelf checks what==\n\nTo a first approximation, you can think of the <tt>%mode</tt> and <tt>%worlds</tt> declarations as specifying a totality assertion and the <tt>%total</tt> declaration as checking it.  This isn't exactly how Twelf works, though:\n\n# When a <tt>%mode</tt> declaration is entered, Twelf checks that all previous constants inhabiting the specified type family are well-moded; further, it then mode-checks any subsequent constants inhabiting that family.  \n# When a <tt>%worlds</tt> declaration is entered, Twelf world-checks the type family; further, it then reports an error if any new constants contributing to the family at all are added.\n# When a <tt>%total</tt> declaration is entered, Twelf checks termination, then input coverage, then output coverage.  When checking output coverage, Twelf checks for unjustified constant pattern-matching in a first pass and then output freeness problems in a second pass.\n\nThis separation allows you to, for example, check that each constant in a family is well-moded (i.e., takes specified inputs to specified outputs) without checking that the entire type family is total.  You can also use the declarations [[%terminates]] and [[%covers]] to check termination and input coverage independently.\n\nIf any constant in a type family fails mode, worlds, or output coverage, then mode, worlds, or totality checking fails for the whole type family.  One could imagine that Twelf instead would just disregard the offending constant: it is possible that the type family as a whole satisfies a totality assertion without that constant, and, in a mathematical sense, adding additional constants never invalidates the fact a totality assertion is true of a family.    The reason Twelf does not work this way is that <tt>%total</tt> actually has a more specific meaning, as we discuss in the next section.\n\n}%\n\n%{\n\n== Expressions from before ==\n\n}%\n\nval : type.\nnum : nat -> val.\n\nexp : type.\nret : val -> exp.\nplus  : exp -> exp -> exp.\nlet : exp -> (val -> exp) -> exp.\n\neval : exp -> val -> type.\n%mode eval +E1 -E2.\n\neval/val : eval (ret V) V.\n\neval/plus : eval (plus E1 E2) (num N)\n\t     <- eval E1 (num N1)\n\t     <- eval E2 (num N2)\n\t     <- add N1 N2 N.\n\neval/let : eval (let E1 ([x] E2 x)) A\n\t    <- eval E1 V\n\t    <- eval (E2 V) A.\n\n%worlds () (eval _ _).\n%total E (eval E _).\n\n%{\n\n== Expressions with times ==\n\nWe'll add syntax for 'times' and an evaluation rule\n\n}%\n\nval : type.\nnum : nat -> val.\n\nexp : type.\nret : val -> exp.\nplus  : exp -> exp -> exp.\nlet : exp -> (val -> exp) -> exp.\n%% NEW\ntimes : exp -> exp -> exp.\n\neval : exp -> val -> type.\n%mode eval +E1 -E2.\n\neval/val : eval (ret V) V.\n\neval/plus : eval (plus E1 E2) (num N)\n\t     <- eval E1 (num N1)\n\t     <- eval E2 (num N2)\n\t     <- add N1 N2 N.\n\neval/let : eval (let E1 ([x] E2 x)) A\n\t    <- eval E1 V\n\t    <- eval (E2 V) A.\n\n%% NEW\neval/times : eval (times E1 E2) (num N)\n\t     <- eval E1 (num N1)\n\t     <- eval E2 (num N2)\n\t     <- mult N1 N2 N.\n\n%worlds () (eval _ _).\n%total E (eval E _).\n\n\n%{\n\n== Expressions with pairs ==\n\n}%\n\nval : type.\nnum  : nat -> val.\n%% NEW\npair : val -> val -> val.\n\nexp : type.\nret : val -> exp.\nplus  : exp -> exp -> exp.\nlet : exp -> (val -> exp) -> exp.\ntimes : exp -> exp -> exp.\n%% NEW\nfst : exp -> exp.\nsnd : exp -> exp.\n\neval : exp -> val -> type.\n%mode eval +E1 -E2.\n\neval/val : eval (ret V) V.\n\neval/plus : eval (plus E1 E2) (num N)\n\t     <- eval E1 (num N1)  \n\t     <- eval E2 (num N2)\n\t     <- add N1 N2 N.\n\neval/let : eval (let E1 ([x] E2 x)) A\n\t    <- eval E1 V\n\t    <- eval (E2 V) A.\n\neval/times : eval (times E1 E2) (num N)\n\t     <- eval E1 (num N1)\n\t     <- eval E2 (num N2)\n\t     <- mult N1 N2 N.\n\n%% NEW\neval/fst : eval (fst E) V1\n\t    <- eval E (pair V1 V2).\n\n%% NEW\neval/snd : eval (snd E) V2\n\t    <- eval E (pair V1 V2).\n\n%worlds () (eval _ _).\n\n\n%{\n\n<twelf name=\"evalnottotal\" check=\"decl\">\n%total E (eval E _).\n</twelf>\n\nWe get an output coverage error for <tt>eval-plus</tt>.\n\nWhy? Not every expression evaluates to a <tt>num</tt>, e.g. <tt>(plus (ret (pair 6 7)) 8)</tt>.  \n\n== Typing 1 ==\n\nWe'll introduce a typing judgement.  \n\n}%\n\ntp : type.\nnatural : tp.\nprod : tp -> tp -> tp.\n\n%% relates a value to a type.\nof-val : val -> tp -> type.\n\nof-val/num  : of-val (num N) natural.  \nof-val/pair : of-val (pair V1 V2) (prod T1 T2)\n\t   <- of-val V1 T1\n\t   <- of-val V2 T2.\n\n%% synthesis \n%mode of-val +E -T.\n%worlds () (of-val _ _).\n\nof : exp -> tp -> type.\n%mode of +E -T.\n\nof/ret : of (ret V) T\n\t  <- of-val V T.\nof/plus : of (plus E1 E2) natural\n\t   <- of E1 natural\n\t   <- of E2 natural.\nof/times : of (times E1 E2) natural\n\t   <- of E1 natural\n\t   <- of E2 natural.\nof/fst : of (fst E) T1\n\t  <- of E (prod T1 T2). \nof/snd : of (snd E) T2\n\t  <- of E (prod T1 T2). \nof/let : of (let E1 ([x] E2 x)) T\n \t  <- of E1 T1\n  \t  <- ({x : val} of (E2 x) T).\n\n%{\n\n<twelf check=\"decl\" name=\"badworlds\">\n%worlds () (of _ _).\n</twelf>\n\nWe promised we'd stay in the empty LF context, but we don't.\n\n== Typing 2a ==\n\n}%\n\n%% relates a value to a type.\nof-val : val -> tp -> type.\n\nof-val/num  : of-val (num N) natural.  \nof-val/pair : of-val (pair V1 V2) (prod T1 T2)\n\t   <- of-val V1 T1\n\t   <- of-val V2 T2.\n\n%% synthesis \n%mode of-val +E -T.\n\n%worlds () (of-val _ _).\n\nof : exp -> tp -> type.\n\nof/ret : of (ret V) T\n\t  <- of-val V T.\nof/plus : of (plus E1 E2) natural\n\t   <- of E1 natural\n\t   <- of E2 natural.\nof/times : of (times E1 E2) natural\n\t   <- of E1 natural\n\t   <- of E2 natural.\nof/fst : of (fst E) T1\n\t  <- of E (prod T1 T2). \nof/snd : of (snd E) T2\n\t  <- of E (prod T1 T2). \nof/let : of (let E1 ([x] E2 x)) T\n \t  <- of E1 T1\n  \t  <- ({x : val} of (E2 x) T).\n\n%mode of +E -T.\n%block valb : block {x : val}.\n\n%{\n\n<twelf name=\"worldsubserror\" check=\"decl\">\n%worlds (valb) (of _ _).\n</twelf>\n\n== Typing 2 ==\n\n}%\n\n%% relates a value to a type.\nof-val : val -> tp -> type.\n\nof-val/num  : of-val (num N) natural.  \nof-val/pair : of-val (pair V1 V2) (prod T1 T2)\n\t   <- of-val V1 T1\n\t   <- of-val V2 T2.\n\n%% synthesis \n%mode of-val +E -T.\n\n%block valb : block {x : val}.\n%worlds (valb) (of-val _ _).\n\nof : exp -> tp -> type.\n\nof/ret : of (ret V) T\n\t  <- of-val V T.\nof/plus : of (plus E1 E2) natural\n\t   <- of E1 natural\n\t   <- of E2 natural.\nof/times : of (times E1 E2) natural\n\t   <- of E1 natural\n\t   <- of E2 natural.\nof/fst : of (fst E) T1\n\t  <- of E (prod T1 T2). \nof/snd : of (snd E) T2\n\t  <- of E (prod T1 T2). \nof/let : of (let E1 ([x] E2 x)) T\n \t  <- of E1 T1\n  \t  <- ({x : val} of (E2 x) T).\n\n%mode of +E -T.\n%worlds (valb) (of _ _).\n\n%{\n\n== Typing 3 ==\n\n<twelf check=\"decl\" name=\"trytotypelet\">\nexample : of (let (ret (num z)) ([y] (ret y))) natural \n \t   = of/let ([x] (of/ret (XXX x))) (of/ret of-val/num).\n</twelf>\n\nWe need a derivation of  <tt>of-val x natural</tt>!\n\n}%\n\nof-val : val -> tp -> type.\n\nof-val/num  : of-val (num N) natural.  \nof-val/pair : of-val (pair V1 V2) (prod T1 T2)\n\t   <- of-val V1 T1\n\t   <- of-val V2 T2.\n\n%mode of-val +E -T.\n%block valb : some {T : tp} block {x : val} {dx : of-val x T}.\n%worlds (valb) (of-val _ _).\n\nof : exp -> tp -> type.\n\nof/ret : of (ret V) T\n\t  <- of-val V T.\nof/plus : of (plus E1 E2) natural\n\t   <- of E1 natural\n\t   <- of E2 natural.\nof/times : of (times E1 E2) natural\n\t   <- of E1 natural\n\t   <- of E2 natural.\nof/fst : of (fst E) T1\n\t  <- of E (prod T1 T2). \nof/snd : of (snd E) T2\n\t  <- of E (prod T1 T2). \nof/let : of (let E1 ([x] E2 x)) T\n\t  <- of E1 T1\n \t  <- ({x : val} of-val x T1 -> of (E2 x) T).\n\n%mode of +E -T.\n%worlds (valb) (of _ _).\n\n%% now we can finish it:\nexample : of (let (ret (num z)) ([y] (ret y))) natural \n\t   = of/let ([x] [dx : of-val x natural] (of/ret dx)) (of/ret of-val/num)."
          },
          "sha1": "iol3hlymxubrjkppsiqt6thdpldhq02"
        }
      },
      {
        "title": "POPL Tutorial/Session 2 Script",
        "ns": 0,
        "id": 2129,
        "revision": {
          "id": 5652,
          "timestamp": "2008-11-22T05:35:02Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "comment": "New page: %{  == Arithmetic primitives ==  }%  nat : type.   z : nat. s : nat -> nat.  add : nat -> nat -> nat -> type. %mode add +M +N -P.  add/z : add z N N. add/s : add (s M) N (s P) <- add M N P...",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 3363,
            "#text": "%{\n\n== Arithmetic primitives ==\n\n}%\n\nnat : type.  \nz : nat.\ns : nat -> nat.\n\nadd : nat -> nat -> nat -> type.\n%mode add +M +N -P.\n\nadd/z : add z N N.\nadd/s : add (s M) N (s P) <- add M N P.\n\n%worlds () (add _ _ _).\n%total M (add M _ _).\n\n%{\n\n== Multiplication ==\n\n}%\n\nmult : nat -> nat -> nat -> type.\n\nmult/z : mult z N z.\nmult/s : mult (s M) N Q\n\t  <- mult M N P\n\t  <- add P N Q.\n\n%mode mult +M +N -P.\n%worlds () (mult _ _ _).\n%total M (mult M _ _).\n\n%% Mode failures:\nmult-bad-mode : mult M N P.\nmult-badmode2 : mult N1 N2 N3 \n\t\t <- mult N4 N2 N3.  \nmult/s : mult (s M) N Q\n\t  <- add P N Q\n\t  <- mult M N P.\n\n%% Termination failure\n%total N (mult _ N _).\n\n%% Output cov:\nmult-bad-output : mult (s N1) N2 (s (s N3))\n                   <- mult N1 N2 (s N3).\nmult-bad-output-freeness : mult (s N1) N2 (s N2)\n                            <- mult N1 N2 N2.\n\n%% Input coverage:\nmult' : nat -> nat -> nat -> type.\n%mode mult' +N1 +N2 -X3.\n\nmult'/s : mult' (s M) N Q\n\t  <- mult' M N P\n\t  <- add P N Q.\n\n%worlds () (mult' _ _ _).\n%total M (mult'' M _ _).\n\n%{\n\n== Expressions with times, pairs ==\n\n# Add syntax for times; eval is still total\n# Add syntax for pairs; eval is no longer total\n\n}%\n\nval : type.\nnum  : nat -> val.\n%% NEW\npair : val -> val -> val.\n\nexp : type.\nret : val -> exp.\nplus  : exp -> exp -> exp.\nlet : exp -> (val -> exp) -> exp.\n%% NEW\ntimes : exp -> exp -> exp.\nfst : exp -> exp.\nsnd : exp -> exp.\n\neval : exp -> val -> type.\n%mode eval +E1 -E2.\n\neval/val : eval (ret V) V.\n\neval/plus : eval (plus E1 E2) (num N)\n\t     <- eval E1 (num N1)  %% OUTPUT COV ERROR HERE\n\t     <- eval E2 (num N2)\n\t     <- add N1 N2 N.\n\neval/let : eval (let E1 ([x] E2 x)) A\n\t    <- eval E1 V\n\t    <- eval (E2 V) A.\n\n%% NEW\neval/times : eval (times E1 E2) (num N)\n\t     <- eval E1 (num N1)\n\t     <- eval E2 (num N2)\n\t     <- mult N1 N2 N.\n\neval/fst : eval (fst E) V1\n\t    <- eval E (pair V1 V2).\n\neval/snd : eval (snd E) V2\n\t    <- eval E (pair V1 V2).\n\n%worlds () (eval _ _).\n%% %total E (eval E _).\n\n%{\n\n== Typing judgement ==\n\n# Write the rules, don't add typing assumption in of/let, get a world error\n# Define block, get a world subsumption error for of-val\n# Put of-val in the right world; now of world-checks\n# Try example; get stuck\n# Add typing assumption, change of/let, finish example\n\nFinished product:\n\n}%\n\ntp : type.\nnatural : tp.\nprod : tp -> tp -> tp.\n\n%% relates a value to a type.\nof/val : val -> tp -> type.\n\nof/num : of/val (num N) natural.  \nof/pair : of/val (pair V1 V2) (prod T1 T2)\n\t   <- of/val V1 T1\n\t   <- of/val V2 T2.\n\n%% synthesis \n%mode of/val +E -T.\n%block ofb : some {T : tp} block {x : val} {dx : of/val x T}.\n%worlds (ofb) (of/val _ _).\n\nof : exp -> tp -> type.\n\nof/ret : of (ret V) T\n\t  <- of/val V T.\nof/plus : of (plus E1 E2) natural\n\t   <- of E1 natural\n\t   <- of E2 natural.\nof/times : of (times E1 E2) natural\n\t   <- of E1 natural\n\t   <- of E2 natural.\nof/fst : of (fst E) T1\n\t  <- of E (prod T1 T2). \nof/snd : of (snd E) T2\n\t  <- of E (prod T1 T2). \nof/let : of (let E1 ([x] E2 x)) T\n\t  <- of E1 T1\n \t  <- ({x : val} of/val x T1 -> of (E2 x) T).\n\n%mode of +E -T.\n%worlds (ofb) (of _ _).\n\n\n% example : of (let (ret (num z)) ([y] (ret y))) natural \n% \t   = of/let ([x] (of/ret (XXX x))) (of/ret of/num).\nexample : of (let (ret (num z)) ([y] (ret y))) natural \n\t   = of/let ([x] [dx : of/val x natural] (of/ret dx)) (of/ret of/num)."
          },
          "sha1": "o685bizb1uwbk1qwpahh16l3mccvyyj"
        }
      },
      {
        "title": "POPL Tutorial/Session 2 Starter",
        "ns": 0,
        "id": 2128,
        "revision": {
          "id": 5651,
          "parentid": 5650,
          "timestamp": "2008-11-22T03:45:17Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 734,
            "#text": "%{\n\n== Starter code for Session 2 ==\n\n== Arithmetic primitives ==\n\n}%\n\nnat : type.  \nz : nat.\ns : nat -> nat.\n\nadd : nat -> nat -> nat -> type.\n%mode add +M +N -P.\n\nadd/z : add z N N.\nadd/s : add (s M) N (s P) <- add M N P.\n\n%worlds () (add _ _ _).\n%total M (add M _ _).\n\n%{\n\n== Expressions ==\n\n}%\n\nval : type.\nnum : nat -> val.\n\nexp : type.\nret : val -> exp.\nplus  : exp -> exp -> exp.\nlet : exp -> (val -> exp) -> exp.\n\neval : exp -> val -> type.\n%mode eval +E1 -E2.\n\neval/val : eval (ret V) V.\n\neval/plus : eval (plus E1 E2) (num N)\n\t     <- eval E1 (num N1)\n\t     <- eval E2 (num N2)\n\t     <- add N1 N2 N.\n\neval/let : eval (let E1 ([x] E2 x)) A\n\t    <- eval E1 V\n\t    <- eval (E2 V) A.\n\n%worlds () (eval _ _).\n%total E (eval E _)."
          },
          "sha1": "k1fpnrooansr9z3twxiah2eanxzan4j"
        }
      },
      {
        "title": "POPL Tutorial/Session 4",
        "ns": 0,
        "id": 2131,
        "revision": {
          "id": 5660,
          "parentid": 5659,
          "timestamp": "2008-11-22T05:53:07Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 361,
            "#text": "== Type preservation for MinML ==\n\nIn this session, we will prove type preservation for MinML.\n\n# We recommend that you type in what we type, so your fingers get used to Twelf. But if you want to save your self some typing, start from the [[POPL_Tutorial/Session 4 Starter|(starter code)]]\n# Answers to the exercises: [[POPL Tutorial/Session 4 Answer|(answer)]]"
          },
          "sha1": "czrhdlqjzo17ejiymjpgsb5c8f21gw9"
        }
      },
      {
        "title": "POPL Tutorial/Session 4 Answer",
        "ns": 0,
        "id": 2127,
        "revision": {
          "id": 5655,
          "parentid": 5649,
          "timestamp": "2008-11-22T05:44:36Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "minor": null,
          "comment": "[[POPL Tutorial/Session 4]] moved to [[POPL Tutorial/Session 4 Answer]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 3585,
            "#text": "%{\n\n== Session 4: Type Preservation Answer ==\n\n=== Syntax ===\n\n}%\n\ntp : type.  %name tp T.\n\nnat\t: tp.\narr\t: tp -> tp -> tp.\n\n\nexp : type.  %name exp E.\n\nz\t: exp.\nfun\t: tp -> tp -> (exp -> exp -> exp) -> exp.\napp\t: exp -> exp -> exp.\n\n%{ \nTASK 1:\n}%\n\ns\t: exp -> exp.\nifz\t: exp -> exp -> (exp -> exp) -> exp.\n\n%{\n\n===  Static Semantics ===\n\n}%\n\nof : exp -> tp -> type.  %name of Dof.\n\nof/z\t\t: of z nat.\n\nof/fun\t\t: of (fun T1 T2 ([f] [x] E f x)) (arr T1 T2)\n\t\t   <- ({f} of f (arr T1 T2)\n\t\t\t -> {x} of x T1\n\t\t\t -> of (E f x) T2).\n\nof/app\t\t: of (app E1 E2) T'\n\t\t   <- of E1 (arr T T')\n\t\t   <- of E2 T.\n\n%{ \nTASK 2:\n}%\nof/s\t\t: of (s E) nat\n\t\t   <- of E nat.\n\nof/ifz\t\t: of (ifz E E1 ([x] E2 x)) T\n\t\t   <- of E nat\n\t\t   <- of E1 T\n\t\t   <- ({x} of x nat -> of (E2 x) T).\n\n\n\n%{  \n\n=== Dynamic Semantics ===\n\n}%\n\nvalue : exp -> type.  %name value Dval.\n\nvalue/z\t\t: value z.\n\nvalue/s\t\t: value (s E)\n\t\t   <- value E.\n\nvalue/fun\t: value (fun _ _ _).\n\n\nstep : exp -> exp -> type.  %name step Dstep.\n\nstep/app/fun\t: step (app E1 E2) (app E1' E2)\n\t\t   <- step E1 E1'.\n\nstep/app/arg\t: step (app E1 E2) (app E1 E2')\n\t\t   <- value E1\n\t\t   <- step E2 E2'.\n\nstep/app/beta-v\t: step (app (fun T1 T2 ([f] [x] E1 f x)) E2) (E1 (fun T1 T2 ([f] [x] E1 f x)) E2)\n\t\t   <- value E2.\n\n%{ \nTASK 3:\n}%\nstep/s\t\t: step (s E) (s E')\n\t\t   <- step E E'.\n\nstep/ifz/arg\t: step (ifz E E1 ([x] E2 x)) (ifz E' E1 ([x] E2 x))\n\t\t   <- step E E'.\n\nstep/ifz/z\t: step (ifz z E1 ([x] E2 x)) E1.\n\nstep/ifz/s\t: step (ifz (s E) E1 ([x] E2 x)) (E2 E)\n\t\t   <- value E.\n\n\n\n%{ \n\n=== Preservation ===\n\n}%\n\n\npreservation : of E T\n\t\t-> step E E' \n%%\n\t\t-> of E' T\n\t\t-> type.\n%mode preservation +Dof +Dstep -Dof'.\n\n-\t: preservation\n\t   (of/app\n\t      (DofE2 : of E2 T)\n\t      (DofE1 : of E1 (arr T T')))\n\t   (step/app/fun\n\t      (Dstep : step E1 E1')\n\t      : step (app E1 E2) (app E1' E2))\n\t   %%\n\t   (of/app DofE2 DofE1')\n\t   <- preservation DofE1 Dstep (DofE1' : of E1' (arr T T')).\n\n-\t: preservation\n\t   (of/app\n\t      (DofE2 : of E2 T)\n\t      (DofE1 : of E1 (arr T T')))\n\t   (step/app/arg\n\t      (Dstep : step E2 E2')\n\t      _\n\t      : step (app E1 E2) (app E1 E2'))\n\t   %%\n\t   (of/app DofE2' DofE1)\n\t   <- preservation DofE2 Dstep (DofE2' : of E2' T).\n\n-\t: preservation\n\t   (of/app\n\t      (DofE2 : of E2 T1)\n\t      (of/fun\n\t\t (DofE1 : {f} of f (arr T1 T2) -> {x} of x T1 -> of (E1 f x) T2)\n\t\t : of (fun T1 T2 ([f] [x] E1 f x)) (arr T1 T2)))\n\t   (step/app/beta-v _\n\t      : step (app (fun T1 T2 ([f] [x] E1 f x)) E2) (E1 (fun T1 T2 ([f] [x] E1 f x)) E2))\n\t   %%\n\t   (DofE1 (fun T1 T2 ([f] [x] E1 f x)) (of/fun DofE1) E2 DofE2).\n\n\n%{ \nTASK 4:\n}%\n\n-\t: preservation \n\t   (of/s\n\t      (Dof : of E nat))\n\t   (step/s \n\t      (Dstep : step E E')\n\t      : step (s E) (s E'))\n\t   %%\n\t   (of/s Dof')\n\t   <- preservation Dof Dstep (Dof' : of E' nat).\n\n-\t: preservation\n\t   (of/ifz\n\t      (DofE2 : {x} of x nat -> of (E2 x) T)\n\t      (DofE1 : of E1 T)\n\t      (DofE : of E nat))\n\t   (step/ifz/arg\n\t      (Dstep : step E E')\n\t      : step (ifz E E1 ([x] E2 x)) (ifz E' E1 ([x] E2 x)))\n\t   %%\n\t   (of/ifz DofE2 DofE1 DofE')\n\t   <- preservation DofE Dstep (DofE' : of E' nat).\n\n-\t: preservation\n\t   (of/ifz\n\t      (DofE2 : {x} of x nat -> of (E2 x) T)\n\t      (DofE1 : of E1 T)\n\t      of/z)\n\t   (step/ifz/z\n\t      : step (ifz z E1 ([x] E2 x)) E1)\n\t   %%\n\t   DofE1.\n\n-\t: preservation\n\t   (of/ifz\n\t      (DofE2 : {x} of x nat -> of (E2 x) T)\n\t      (DofE1 : of E1 T)\n\t      (of/s\n\t\t (DofE : of E nat)))\n\t   (step/ifz/s _\n\t      : step (ifz (s E) E1 ([x] E2 x)) (E2 E))\n\t   %%\n\t   (DofE2 E DofE).\n\n%worlds () (preservation _ _ _).\n%total D (preservation _ D _)."
          },
          "sha1": "6pv6hp1zmb858r9dcfmv3a7d8zehlut"
        }
      },
      {
        "title": "POPL Tutorial/Session 4 Live",
        "ns": 0,
        "id": 2136,
        "revision": {
          "id": 5676,
          "parentid": 5675,
          "timestamp": "2008-11-22T22:03:32Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 4075,
            "#text": "%{\n\n'''''Please fill [https://spreadsheets.google.com/viewform?key=p0-89EvFXQhUXF827jjk_Dg feedback form]'''''\n\n\n== Syntax ==\n\n}%\n\n%% Types:\n\ntp : type.  %name tp T.\nnat : tp.\narr : tp -> tp -> tp.\n\n%% Terms:\n\nexp : type.  %name exp E.\n\n%% variables represented by LF variables\n\nz : exp.\n\nfun : tp -> tp -> (exp -> exp -> exp) -> exp.\napp : exp -> exp -> exp.\n\n%% TASK 1 Answer:\n\ns : exp -> exp.\nifz : exp -> exp -> (exp -> exp) -> exp.\n%% not: ifz : exp -> exp -> exp -> exp.\n\n%{\n\n== Typing ==\n\n}%\n\n%% Note: not total!  Not all terms are well-typed\n%% Don't need mode, worlds right now.\nof : exp -> tp -> type.\n\n%% represent variables as LF variables\n\nof/z : of z nat.\n\nof/app : of (app E1 E2) T'\n\t  <- of E1 (arr T T')\n\t  <- of E2 T.\n\n%% really: \n%% of E2 T -> of E1 (arr T T') -> of/app : of (app E1 E2) T'\n\n%% not eta-long:\n%% of/fun' : of (fun T1 T2 E) _.\n\n%% eta-long:\nof/fun : of (fun T1 T2 ([f] [x] E f x)) (arr T1 T2)\n\t  <- ({f : exp} of f (arr T1 T2) \n\t\t-> {x : exp} of x T1 \n\t\t-> of (E f x) T2).\n\n% of/fun : of (fun T1 T2 ([f] [x] E f x)) (arr T1 T2)\n% \t  %% make assumptions in a different order\n% \t  <- ({f : exp} {x : exp}\n% \t\t-> of f (arr T1 T2) -> of x T1 \n% \t\t-> of (E f x) T2).\n\n%% Task: give typing rules for\n%% s, ifz\n\n%{\n e : nat\n---------\ns e : nat\n\ne : nat\ne0 : T\nx exp , x : nat |- e1 : T\n--------------------------\nifz(e,e0,x.e1) : T\n}%\n\nof/s : of (s E) nat\n\t<- of E nat.\n\nof/ifz : of (ifz E E0 ([x] Es x)) T\n\t  <- of E nat\n\t  <- of E0 T\n\t  <- ({x : exp} of x nat\n\t\t-> of (Es x) T).\n\n%{\n\n== Operational semantics ==\n\n}%\n\n%% Which expressions are values?\n%% Use a predicate\n\nvalue : exp -> type.\n%mode value +E.\n\nvalue/z : value z.\nvalue/s : value (s E)\n\t   <- value E.\n%% value/fun : value (fun T1 T2 ([f] [x] E f x)).\nvalue/fun : value (fun _ _ _).\n\n%% Small-step evaluation\n\nstep : exp -> exp -> type.\n%mode step +E -E'.\n\nstep/app/fun : step (app E1 E2) (app E1' E2)\n\t\t<- step E1 E1'.\n\nstep/app/arg : step (app E1 E2) (app E1 E2')\n\t\t<- value E1\n\t\t<- step E2 E2'.\n\nstep/app/beta : step \n\t\t (app \n\t\t    (fun T1 T2 ([f] [x] E1 f x))\n\t\t    E2)\n\t      %% substitution = LF function application\n\t\t (E1 (fun T1 T2 ([f] [x] E1 f x)) E2)\n\t\t <- value E2.\n\n\n%% Task 3:\n%% (s E) takes a step if E takes a step\n\nstep/s : step (s E) (s E')\n\t  <- step E E'.\n\n\n%% when E takes a step then\n%% ifz E _ _ takes a step\n\nstep/ifz/arg : step \n\t\t(ifz E E0 ([x] Es x))\n\t\t(ifz E' E0 ([x] Es x))\n\t\t<- step E E'.\n\n%% (ifz z E0 Es) steps to E0\n\nstep/ifz/z : step\n\t      (ifz z E0 ([x] Es x))\n\t      E0.\n\n%% (ifz (s E) _ x.Es) steps to [E/x]Es\n%% when E is a value\n\nstep/ifz/s : step \n\t      (ifz (s E) E0 ([x] Es x))\n\t      (Es E) %% substitution\n\t      <- value E.\n\n%{\n\n== Proof of type preservation ==\n\nIf   e : T\nand  step e e'\nthen e' : T.\n\n(eval relates expressions to answers)\n\nType preservation relates derivations of judgements\nto other derivations\n\nRelate: e : T  and  step e e'  to  e' : T\n\nKey idea: define total relations\n\n}%\n\n%% Type family:\n\npres : of E T \n\t-> step E E'\n\t-> of E' T\n\t-> type.\n%mode pres +Dof +Dstep -Dof'.\n\n%% gives cases\n\n- : pres \n     ((of/app \n\t (DofE2 : of E2 T2)\n\t (DofE1 : of E1 (arr T2 T1)))\n\t: of (app E1 E2) T1)\n     (step/app/fun \n\t(Dstep : step E1 E1') \n\t: step (app E1 E2) (app E1' E2))\n     (of/app DofE2 DofE1')\n     <- pres DofE1 Dstep (DofE1' : of E1' (arr T2 T1)).\n\n- : pres\n     ((of/app \n\t (DofE2 : of E2 T2)\n\t (DofE1 : of E1 (arr T2 T1)))\n\t: of (app E1 E2) T1)\n     (step/app/arg \n\t(Dstep : step E2 E2')\n\t(Dval : value E1)\n\t: step (app E1 E2) (app E1 E2'))\n     (of/app DofE2' DofE1)\n     <- pres DofE2 Dstep (DofE2' : of E2' T2).\n\n- : pres \n     ((of/app \n\t (DofE2 : of E2 T2)\n\t ((of/fun \n\t     (DofE1 : {f} of f (arr T2 T1)\n\t\t       -> {x} of x T2\n\t\t       -> of (E1 f x) T1))  \n\t    : of (fun T2 T1 ([f] [x] E1 f x)) (arr T2 T1)))\n\t: of (app (fun T2 T1 ([f] [x] E1 f x)) E2) T1)\n     (step/app/beta\n\t(Dval : value E2)\n\t: step (app (fun T2 T1 ([f] [x] E1 f x)) E2)\n\t   (E1 (fun T2 T1 ([f] [x] E1 f x)) E2))\n     (DofE1 (fun T2 T1 ([f] [x] E1 f x)) (of/fun DofE1) E2 DofE2).\n\n%worlds () (pres _ _ _).\n%total D (pres _ D _)."
          },
          "sha1": "mlrnk1ftkzid2ta7vhpdtq00k0qyz5q"
        }
      },
      {
        "title": "POPL Tutorial/Session 4 Starter",
        "ns": 0,
        "id": 2132,
        "revision": {
          "id": 5658,
          "timestamp": "2008-11-22T05:50:59Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "comment": "New page: %{  == Session 4: Type Preservation Starter ==  === Syntax ===  }%  tp : type.  %name tp T.  nat\t: tp. arr\t: tp -> tp -> tp.   exp : type.  %name exp E.  z\t: exp. fun\t: tp -> tp -> (exp ->...",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 2377,
            "#text": "%{\n\n== Session 4: Type Preservation Starter ==\n\n=== Syntax ===\n\n}%\n\ntp : type.  %name tp T.\n\nnat\t: tp.\narr\t: tp -> tp -> tp.\n\n\nexp : type.  %name exp E.\n\nz\t: exp.\nfun\t: tp -> tp -> (exp -> exp -> exp) -> exp.\napp\t: exp -> exp -> exp.\n\n%{ \nTASK 1:\n\nAdd constants for successor and ifz:\n\n}%\n\n%{\n\n===  Static Semantics ===\n\n}%\n\nof : exp -> tp -> type.  %name of Dof.\n\nof/z\t\t: of z nat.\n\nof/fun\t\t: of (fun T1 T2 ([f] [x] E f x)) (arr T1 T2)\n\t\t   <- ({f} of f (arr T1 T2)\n\t\t\t -> {x} of x T1\n\t\t\t -> of (E f x) T2).\n\nof/app\t\t: of (app E1 E2) T'\n\t\t   <- of E1 (arr T T')\n\t\t   <- of E2 T.\n\n%{ \nTASK 2:\n\nAdd two new typing rules for successor and ifz\n\n}%\n\n\n%{  \n\n=== Dynamic Semantics ===\n\n}%\n\nvalue : exp -> type.  %name value Dval.\n\nvalue/z\t\t: value z.\n\n%{\nTask 3a: Add a value rule for successor\n}%\n\nvalue/fun\t: value (fun _ _ _).\n\n\nstep : exp -> exp -> type.  %name step Dstep.\n\nstep/app/fun\t: step (app E1 E2) (app E1' E2)\n\t\t   <- step E1 E1'.\n\nstep/app/arg\t: step (app E1 E2) (app E1 E2')\n\t\t   <- value E1\n\t\t   <- step E2 E2'.\n\nstep/app/beta-v\t: step (app (fun T1 T2 ([f] [x] E1 f x)) E2) (E1 (fun T1 T2 ([f] [x] E1 f x)) E2)\n\t\t   <- value E2.\n\n%{ \nTASK 3:\n\nAdd four more operational semantics rules for successor and ifz.\n\n}%\n\n%{ \n\n=== Preservation ===\n\n}%\n\n\npreservation : of E T\n\t\t-> step E E' \n%%\n\t\t-> of E' T\n\t\t-> type.\n%mode preservation +Dof +Dstep -Dof'.\n\n-\t: preservation\n\t   (of/app\n\t      (DofE2 : of E2 T)\n\t      (DofE1 : of E1 (arr T T')))\n\t   (step/app/fun\n\t      (Dstep : step E1 E1')\n\t      : step (app E1 E2) (app E1' E2))\n\t   %%\n\t   (of/app DofE2 DofE1')\n\t   <- preservation DofE1 Dstep (DofE1' : of E1' (arr T T')).\n\n-\t: preservation\n\t   (of/app\n\t      (DofE2 : of E2 T)\n\t      (DofE1 : of E1 (arr T T')))\n\t   (step/app/arg\n\t      (Dstep : step E2 E2')\n\t      _\n\t      : step (app E1 E2) (app E1 E2'))\n\t   %%\n\t   (of/app DofE2' DofE1)\n\t   <- preservation DofE2 Dstep (DofE2' : of E2' T).\n\n-\t: preservation\n\t   (of/app\n\t      (DofE2 : of E2 T1)\n\t      (of/fun\n\t\t (DofE1 : {f} of f (arr T1 T2) -> {x} of x T1 -> of (E1 f x) T2)\n\t\t : of (fun T1 T2 ([f] [x] E1 f x)) (arr T1 T2)))\n\t   (step/app/beta-v _\n\t      : step (app (fun T1 T2 ([f] [x] E1 f x)) E2) (E1 (fun T1 T2 ([f] [x] E1 f x)) E2))\n\t   %%\n\t   (DofE1 (fun T1 T2 ([f] [x] E1 f x)) (of/fun DofE1) E2 DofE2).\n\n\n%{ \nTASK 4: Finish the proof!\n}%\n\n%worlds () (preservation _ _ _).\n%total D (preservation _ D _)."
          },
          "sha1": "2spzqq59kb5z9966q2gqme7wfe0583n"
        }
      },
      {
        "title": "POPL Tutorial/Session 5",
        "ns": 0,
        "id": 2126,
        "revision": {
          "id": 5678,
          "parentid": 5677,
          "timestamp": "2008-11-22T22:04:17Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 2230,
            "#text": "In this session, you'll get a flavor for the experience of defining systems and proving theorems in Twelf.  Break into small groups and pick an interesting problem or two to work on.  If you get stuck, ask a TA!  Refer to the solutions to check your work (though Server OK from Twelf should be assurance enough!)\n\n<big>'''''Please fill [https://spreadsheets.google.com/viewform?key=p0-89EvFXQhUXF827jjk_Dg feedback form]'''''</big>\n\n== Beginner problems (Recommended) ==\n* [[POPL Tutorial/Sequent vs Natural Deduction|Sequent calculus vs. natural deduction]] -- Prove the logical equivalence of Gentzen's intuitionistic sequent calculus and intuitionistic natural deduction. ([[POPL Tutorial/Sequent vs Natural Deduction: Solution|Solution]])\n* [[POPL Tutorial/Big step, small step|Big-step evaluation vs. small-step transition semantics]] -- Prove the operational equivalence of the big-step and small-step views of operational semantics.  ([[POPL Tutorial/Big step, small step: Solution|Solution]])\n\n== Intermediate problems ==\n* [[POPL Tutorial/cps-problem|Call-by-value CPS transform, with administrative redexes]] -- Define an algorithm for converting lambda terms to continuation-passing style ([[POPL Tutorial/CPS Solutions|Solution]])\n* [[POPL Tutorial/cps-problem2|Higher-order call-by-value CPS transform, no administrative redexes]] -- Define a higher-order variant of the CPS conversion that never creates administrative redexes ([[POPL Tutorial/CPS Solution2|Solution]])\n* [[POPL Tutorial/Typed bracket abstraction|Lambda calculus and combinators]] -- Explore the relation between the simply-typed lambda calculus and combinatory logic using Curry's classic bracket abstraction algorithm.  ([[POPL Tutorial/Typed bracket abstraction (solution)|Solution]])\n* [[POPL Tutorial/Church Rosser (Problem)|Church-Rosser]] -- Prove Church and Rosser's seminal result via a Diamond Lemma for the untyped lambda calculus. ([[POPL Tutorial/Church Rosser|Solution]])\n\n== Advanced problems ==\n* [[POPL Tutorial/Exceptions-problem|MinML with exceptions]] -- Prove type safety for an extension of MinML with exceptions defined using structural operational semantics with a \"raises\" judgement.  ([[POPL Tutorial/Exceptions|Solution]])"
          },
          "sha1": "nign00xdzrgqk6mucsqoj39xsxzhv73"
        }
      },
      {
        "title": "POPL Tutorial/Thursday",
        "ns": 0,
        "id": 2148,
        "revision": {
          "id": 5738,
          "parentid": 5724,
          "timestamp": "2009-01-13T20:23:05Z",
          "contributor": {
            "username": "William Lovas",
            "id": 11
          },
          "comment": "/* Schedule (all slides) */",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 2709,
            "#text": "== Mechanizing Metatheory with LF and Twelf ==\n\nDo you want to learn how to use [[Main page|Twelf]] to specify, implement, and prove\nproperties about programming languages?  \n\nCome to the Twelf tutorial on '''January 19, 2009''', co-located with POPL 2009, in\n'''Savannah, Georgia'''.\n\nLearn to:\n* Represent [[deductive systems|languages and logics]] in [[LF]]\n* Prove [[metatheorem]]s with [[Main page|Twelf]]\nunder the helpful guidance of Twelf experts.  \n\nThe tutorial will be a highly interactive introduction to LF and Twelf\naimed at programming languages researchers. No prior experience with LF\nand Twelf is presumed.  Participants will leave the workshop with\nexperience in reading and writing LF representations of programming\nlanguages, and experience reading, writing, and debugging Twelf proofs.\n\nRegister at the [http://www.regmaster.com/conf/popl2009.html POPL 2009 registration site]!  \nThe early registration deadline is '''December 19'''.\n                                                                                                                                                            \nThe tutorial is organized and presented by the CMU Principles of\nProgramming group.\n\n== Schedule ([http://www.cs.cmu.edu/~drl/tmp/lectures.pdf all slides]) ==\n\n* Overview ([[POPL_Tutorial/Nat|Answers]])\n** Session A1: Representation\n** Session A2: Totality ([[POPL_Tutorial/Session_2_Answer|notes]])\n** Session A3: Metatheory\n\n* Languages ([[POPL_Tutorial/MinML|Answers]])\n** Session B1: Representation and adequacy\n** Session B2: Metatheory\n\n* Advanced examples\n** Session C1: [[POPL_Tutorial/Combinators session|Combinators]]\n** Session C2: [[POPL_Tutorial/Session 5|Work on exercies]]\n\n== Get Twelf before the tutorial! ==\n\nThe tutorial will be interactive, with participants writing Twelf code, so you should come with Twelf installed on your laptop.\n\nPre-built binaries of Twelf are available for most operating systems through the [http://twelf.plparty.org/builds Twelf Night(ly)].\n* [http://twelf.plparty.org/builds/twelf-linux.tar.gz Linux (tgz)]\n* [http://twelf.plparty.org/builds/twelf.exe Windows (exe)]\n* [http://twelf.plparty.org/builds/twelf-osx-intel.dmg Mac OS 10.4 or 10.5 (Intel only) (dmg)]\n\nOtherwise:\n* you can build Twelf from the [http://twelf.plparty.org/builds/twelf-src.tar.gz source tarball].  You will need [http://www.mlton.org MLton] or [http://www.smlnj.org sml/nj]. \n* you can make yourself an account on the wiki, and do the exercises on your User:<login> page (linked at the top after you log in).\n\nThen see [[Twelf with Emacs]] for the basics of interacting with Twelf.  (You can also use [[Twelf without Emacs]], by interacting with the Twelf server directly.)"
          },
          "sha1": "0qp4wlw9yyaevyggv59xuw7ck01mugq"
        }
      },
      {
        "title": "POPL Tutorial/Typed bracket abstraction",
        "ns": 0,
        "id": 2111,
        "revision": {
          "id": 5671,
          "parentid": 5670,
          "timestamp": "2008-11-22T16:52:37Z",
          "contributor": {
            "username": "William Lovas",
            "id": 11
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 7744,
            "#text": "%{\n\nThis is a case study translating the simply lambda calculus into S, K, and I\ncombinatory logic.  The correctness of the translation is proven in the\nfollowing sense: if a term steps to a reduct, its translation multi-steps to\nits reduct's translation.\n\n[[User:William Lovas|William Lovas]]\n\n}%\n\n\n%{\n\n== Syntax and static semantics ==\n\n}%\n\n%{\n\nFirst we define the syntax of the two languages.  <tt>term A</tt> is the\ntype of simply-typed lambda-calculus terms of type A; <tt>cterm A</tt> is\nthe type of simply-typed combinator terms of type A.  Combinators are of\ninterest primarily because they have no binding structure; despite this\napparent limitation, we can translate any lambda-calculus term to an\noperationally and logically related combinator term.\n\nNote that since we're using an\n[[intrinsic and extrinsic encodings|intrinsic encoding]], these syntax\ndefinitions double as definitions of the languages' static semantics.\n\n}%\n\ntp : type.\n\ni : tp.\n=> : tp -> tp -> tp.    %infix right 10 =>.\n\n\nterm : tp -> type.      %name term M x.\n\napp : term (A => B) -> term A -> term B.\nlam : (term A -> term B) -> term (A => B).\n\n\ncterm : tp -> type.     %name cterm N y.\n\ns : cterm ((A => B => C) => (A => B) => A => C).\nk : cterm (A => B => A).\ni : cterm (A => A).\n\ncapp : cterm (A => B) -> cterm A -> cterm B.\n\n%{ \n\nWe can use Twelf's [[Abbrev_declaration|abbreviation mechanism]] and\n[[Fixity declaration|fixity declarations]] to obtain some cute syntax.\n\n}%\n\n%abbrev @ = app.\n%infix left 10 @.\n\n%abbrev @@ = capp.\n%infix left 10 @@.\n\n%{\n\n== Dynamic semantics ==\n\n}%\n\n%{\n\nThen we define reduction relations on both languages.  <tt>step</tt> is the\nsingle-step reduction relation on lambda terms; <tt>cstep</tt> is the\nsingle-step reduction relation on combinator terms.  For lambda-calculus\nterms, we do not reduce under binders.\n\n}%\n\nstep : term A -> term A -> type.\n\ns-beta : step (app (lam [x] M1 x) M2) (M1 M2).\n\ns-1 : step (app M1 M2) (app M1' M2)\n       <- step M1 M1'.\n\ns-2 : step (app M1 M2) (app M1 M2')\n       <- step M2 M2'.\n\n\ncstep : cterm A -> cterm A -> type.\n\ncs-i : cstep (capp i X) X.\ncs-k : cstep (capp (capp k X) Y) X.\ncs-s : cstep (capp (capp (capp s X) Y) Z) (capp (capp X Z) (capp Y Z)).\n\ncs-1 : cstep (capp X Y) (capp X' Y)\n        <- cstep X X'.\n\ncs-2 : cstep (capp X Y) (capp X Y')\n        <- cstep Y Y'.\n\n%{\n\nWe also define multi-step reduction on combinator terms.\n\nOur simulation will relate single-step derivations in the lambda-calculus\nto multi-step derivations on the translated terms.\n\n}%\n\ncstep* : cterm A -> cterm A -> type.\n\ncs-cons : cstep* N N''\n           <- cstep N N'\n           <- cstep* N' N''.\n\ncs-nil  : cstep* N N.\n\n\n%{\n\nWe can pre-emptively prove some compatibility lemmas about multi-step\nreduction.\n\n}%\n\ncs-1* : cstep* N1 N1' -> cstep* (capp N1 N2) (capp N1' N2) -> type.\n%mode +{A:tp} +{B:tp} +{N1:cterm (A => B)} +{N1':cterm (A => B)} +{N2:cterm A}\n      +{CS1:cstep* N1 N1'} -{CS2:cstep* (capp N1 N2) (capp N1' N2)}\n      (cs-1* CS1 CS2).\n\n- : cs-1* cs-nil cs-nil.\n- : cs-1* (cs-cons CS C) (cs-cons CS' (cs-1 C))\n     <- cs-1* CS CS'.\n\n%worlds () (cs-1* _ _).\n%total {CS} (cs-1* CS _).\n\ncs-2* : cstep* N2 N2' -> cstep* (capp N1 N2) (capp N1 N2') -> type.\n%mode +{A:tp} +{B:tp} +{N1:cterm (A => B)} +{N2:cterm A} +{N2':cterm A}\n      +{CS1:cstep* N2 N2'} -{CS2:cstep* (capp N1 N2) (capp N1 N2')}\n      (cs-2* CS1 CS2).\n\n- : cs-2* cs-nil cs-nil.\n- : cs-2* (cs-cons CS C) (cs-cons CS' (cs-2 C))\n     <- cs-2* CS CS'.\n\n%worlds () (cs-2* _ _).\n%total {CS} (cs-2* CS _).\n\ncs-trans : cstep* N1 N2 -> cstep* N2 N3 -> cstep* N1 N3 -> type.\n%mode cs-trans +Cs1 +Cs2 -Cs3.\n\n- : cs-trans cs-nil Cs2 Cs2.\n- : cs-trans (cs-cons Cs1 C) Cs2 (cs-cons Cs12 C)\n     <- cs-trans Cs1 Cs2 Cs12.\n\n%worlds () (cs-trans _ _ _).\n%total {Cs} (cs-trans Cs _ _).\n\n%{\n\n== Translation ==\n\n}%\n\n%{\n\nWe can now define a compositional translation from lambda terms to combinator\nterms in the standard way.  The translation appeals to a function called\n''bracket abstraction'' which simulates binding in the combinator calculus.\n\nBracket abstraction is usually written <math>[x] N</math> where <math>N</math>\nis a combinator term, and <math>x</math> is a variable potentially free in\n<math>N</math>.  (Be careful not to confuse these brackets with Twelf's syntax\nfor lambda abstraction.)  It is defined inductively over the term\n<math>N</math>:\n\n<blockquote>\n<math>[x]</math> <math>x = I</math><br>\n<math>[x]</math> <math>N = K</math> <math>N</math>\n    (where <math>x</math> not free in <math>N</math>)<br>\n<math>[x]</math> <math>N_1</math> <math>N_2 =\n    S</math> <math>([x]</math> <math>N_1)</math>\n             <math>([x]</math> <math>N_2)</math><br>\n</blockquote>\n\nUsing it, we can define a translation on lambda-terms, <math>M^*</math>, where\n<math>M</math> is a lambda-term, as follows:\n\n<blockquote>\n<math>x^* = x</math><br>\n<math>(M_1</math> <math>M_2)^*</math> =\n    <math>M_1^*</math> <math>M_2^*</math><br>\n<math>(\\lambda x.</math> <math>M)^* = [x]</math> <math>M^*</math>\n</blockquote>\n\nNote that in the definition of bracket abstraction, we need not consider a\ncase for lambda-abstraction since bracket abstraction works over combinator\nterms, in which lambda-abstraction has already been eliminated.\n\nThe main translation is represented in LF by a judgement (an LF type family)\n<tt>trans M N</tt>.  Bracket abstraction is represented by a judgement\nrelating LF-level abstractions in the combinator language to closed combinator\nterms, <tt>bracket ([x] N x) N</tt>.  This definition is essentially an\ninstance of [[higher-order abstract syntax]].\n\n}%\n\ntrans : term A -> cterm A -> type.\nbracket : (cterm A -> cterm B) -> cterm (A => B) -> type.\n\n\nt-app : trans (app M1 M2) (capp N1 N2)\n         <- trans M1 N1\n         <- trans M2 N2.\n\n%{\n\nThe translation on lambda-abstractions has to work under an extended context\nwith a lambda-term variable, a combinator-term variable, and an assumption\nthat the one translates to the other.  See the <tt>%worlds</tt> declaration\nbelow.\n\n}%\n\n%%%\n%%% TODO: complete the translation case for lambda-abstraction\n%%%\nt-lam : trans (lam [x] M x) XXX-FILL_IN-XXX.\n\n\nb-i : bracket ([x] x) i.\n\nb-k : bracket ([x] Y) (capp k Y).\n\n%%%\n%%% TODO: complete the application case for bracket abstraction\n%%%\nb-s : bracket XXX-FILL_IN-XXX YYY-FILL_IN-YYY.\n\n\n%block tbind : some {A:tp} block {x:term A} {y:cterm A} {dtrans:trans x y}.\n%worlds (tbind) (bracket _ _).\n%worlds (tbind) (trans _ _).\n\n%{\n\n== Correctness of the translation ==\n\n}%\n\n%{\n\nFirst, we prove the correctness of bracket abstraction itself:\nthe application of a bracket abstraction reduces to a substitution.\n\n}%\n\nsubst : bracket ([x] N x) N' -> {N0} cstep* (capp N' N0) (N N0) -> type.\n%mode subst +B +N0 -CS.\n\n- : subst b-i N0 (cs-cons cs-nil cs-i).\n\n- : subst b-k N0 (cs-cons cs-nil cs-k).\n\n%%%\n%%% TODO: complete the case for b-s\n%%\n- : subst (b-s (B2 : bracket ([x] N2 x) N2')\n               (B1 : bracket ([x] N1 x) N1'))\n          N0\n          XXX-FILL_IN-XXX.\n\n%worlds () (subst _ _ _).\n%total {B} (subst B _ _).\n\n%{\n\nThen, we can prove simulation, the correctness of translation, by a\nstraightforward induction on single-step derivations in the lambda-calculus,\nusing the correctness of bracket abstraction as a lemma in the case of a\nbeta-reduction.\n\n}%\n\nsimulate : step M M' -> trans M N -> trans M' N' -> cstep* N N' -> type.\n%mode simulate +S +T -T' -CS.\n\n%{\n\nNB: in the <tt>s-beta</tt> case on paper, you have to prove two\ncompositionality lemmas.  In Twelf, using higher-order abstract\nsyntax, we get them for free.\n\n}%\n\n%%%\n%%% TODO: prove simulation; there are three cases.\n%%%\n\n%worlds () (simulate _ _ _ _).\n%total D (simulate D _ _ _).\n\n%{\n\n[[POPL Tutorial/Typed bracket abstraction (solution)]]\n\n}%"
          },
          "sha1": "jsbkhezu3c7ol4tjihsjar54zttdhx0"
        }
      },
      {
        "title": "POPL Tutorial/Typed bracket abstraction (solution)",
        "ns": 0,
        "id": 2123,
        "revision": {
          "id": 5668,
          "parentid": 5667,
          "timestamp": "2008-11-22T16:39:56Z",
          "contributor": {
            "username": "William Lovas",
            "id": 11
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 8313,
            "#text": "%{\n\nThis is a case study translating the simply lambda calculus into S, K, and I\ncombinatory logic.  The correctness of the translation is proven in the\nfollowing sense: if a term steps to a reduct, its translation multi-steps to\nits reduct's translation.\n\n[[User:William Lovas|William Lovas]]\n\n}%\n\n\n%{\n\n== Syntax and static semantics ==\n\n}%\n\n%{\n\nFirst we define the syntax of the two languages.  <tt>term A</tt> is the\ntype of simply-typed lambda-calculus terms of type A; <tt>cterm A</tt> is\nthe type of simply-typed combinator terms of type A.  Combinators are of\ninterest primarily because they have no binding structure; despite this\napparent limitation, we can translate any lambda-calculus term to an\noperationally and logically related combinator term.\n\nNote that since we're using an\n[[intrinsic and extrinsic encodings|intrinsic encoding]], these syntax\ndefinitions double as definitions of the languages' static semantics.\n\n}%\n\ntp : type.\n\ni : tp.\n=> : tp -> tp -> tp.    %infix right 10 =>.\n\n\nterm : tp -> type.      %name term M x.\n\napp : term (A => B) -> term A -> term B.\nlam : (term A -> term B) -> term (A => B).\n\n\ncterm : tp -> type.     %name cterm N y.\n\ns : cterm ((A => B => C) => (A => B) => A => C).\nk : cterm (A => B => A).\ni : cterm (A => A).\n\ncapp : cterm (A => B) -> cterm A -> cterm B.\n\n%{ \n\nWe can use Twelf's [[Abbrev_declaration|abbreviation mechanism]] and\n[[Fixity declaration|fixity declarations]] to obtain some cute syntax.\n\n}%\n\n%abbrev @ = app.\n%infix left 10 @.\n\n%abbrev @@ = capp.\n%infix left 10 @@.\n\n%{\n\n== Dynamic semantics ==\n\n}%\n\n%{\n\nThen we define reduction relations on both languages.  <tt>step</tt> is the\nsingle-step reduction relation on lambda terms; <tt>cstep</tt> is the\nsingle-step reduction relation on combinator terms.  For lambda-calculus\nterms, we do not reduce under binders.\n\n}%\n\nstep : term A -> term A -> type.\n\ns-beta : step (app (lam [x] M1 x) M2) (M1 M2).\n\ns-1 : step (app M1 M2) (app M1' M2)\n       <- step M1 M1'.\n\ns-2 : step (app M1 M2) (app M1 M2')\n       <- step M2 M2'.\n\n\ncstep : cterm A -> cterm A -> type.\n\ncs-i : cstep (capp i X) X.\ncs-k : cstep (capp (capp k X) Y) X.\ncs-s : cstep (capp (capp (capp s X) Y) Z) (capp (capp X Z) (capp Y Z)).\n\ncs-1 : cstep (capp X Y) (capp X' Y)\n        <- cstep X X'.\n\ncs-2 : cstep (capp X Y) (capp X Y')\n        <- cstep Y Y'.\n\n%{\n\nWe also define multi-step reduction on combinator terms.\n\nOur simulation will relate single-step derivations in the lambda-calculus\nto multi-step derivations on the translated terms.\n\n}%\n\ncstep* : cterm A -> cterm A -> type.\n\ncs-cons : cstep* N N''\n           <- cstep N N'\n           <- cstep* N' N''.\n\ncs-nil  : cstep* N N.\n\n\n%{\n\nWe can pre-emptively prove some compatibility lemmas about multi-step\nreduction.\n\n}%\n\ncs-1* : cstep* N1 N1' -> cstep* (capp N1 N2) (capp N1' N2) -> type.\n%mode +{A:tp} +{B:tp} +{N1:cterm (A => B)} +{N1':cterm (A => B)} +{N2:cterm A}\n      +{CS1:cstep* N1 N1'} -{CS2:cstep* (capp N1 N2) (capp N1' N2)}\n      (cs-1* CS1 CS2).\n\n- : cs-1* cs-nil cs-nil.\n- : cs-1* (cs-cons CS C) (cs-cons CS' (cs-1 C))\n     <- cs-1* CS CS'.\n\n%worlds () (cs-1* _ _).\n%total {CS} (cs-1* CS _).\n\ncs-2* : cstep* N2 N2' -> cstep* (capp N1 N2) (capp N1 N2') -> type.\n%mode +{A:tp} +{B:tp} +{N1:cterm (A => B)} +{N2:cterm A} +{N2':cterm A}\n      +{CS1:cstep* N2 N2'} -{CS2:cstep* (capp N1 N2) (capp N1 N2')}\n      (cs-2* CS1 CS2).\n\n- : cs-2* cs-nil cs-nil.\n- : cs-2* (cs-cons CS C) (cs-cons CS' (cs-2 C))\n     <- cs-2* CS CS'.\n\n%worlds () (cs-2* _ _).\n%total {CS} (cs-2* CS _).\n\ncs-trans : cstep* N1 N2 -> cstep* N2 N3 -> cstep* N1 N3 -> type.\n%mode cs-trans +Cs1 +Cs2 -Cs3.\n\n- : cs-trans cs-nil Cs2 Cs2.\n- : cs-trans (cs-cons Cs1 C) Cs2 (cs-cons Cs12 C)\n     <- cs-trans Cs1 Cs2 Cs12.\n\n%worlds () (cs-trans _ _ _).\n%total {Cs} (cs-trans Cs _ _).\n\n%{\n\n== Translation ==\n\n}%\n\n%{\n\nWe can now define a compositional translation from lambda terms to combinator\nterms in the standard way.  The translation appeals to a function called\n''bracket abstraction'' which simulates binding in the combinator calculus.\n\nBracket abstraction is usually written <math>[x] N</math> where <math>N</math>\nis a combinator term, and <math>x</math> is a variable potentially free in\n<math>N</math>.  (Be careful not to confuse these brackets with Twelf's syntax\nfor lambda abstraction.)  It is defined inductively over the term\n<math>N</math>:\n\n<blockquote>\n<math>[x]</math> <math>x = I</math><br>\n<math>[x]</math> <math>N = K</math> <math>N</math>\n    (where <math>x</math> not free in <math>N</math>)<br>\n<math>[x]</math> <math>N_1</math> <math>N_2 =\n    S</math> <math>([x]</math> <math>N_1)</math>\n             <math>([x]</math> <math>N_2)</math><br>\n</blockquote>\n\nUsing it, we can define a translation on lambda-terms, <math>M^*</math>, where\n<math>M</math> is a lambda-term, as follows:\n\n<blockquote>\n<math>x^* = x</math><br>\n<math>(M_1</math> <math>M_2)^*</math> =\n    <math>M_1^*</math> <math>M_2^*</math><br>\n<math>(\\lambda x.</math> <math>M)^* = [x]</math> <math>M^*</math>\n</blockquote>\n\nNote that in the definition of bracket abstraction, we need not consider a\ncase for lambda-abstraction since bracket abstraction works over combinator\nterms, in which lambda-abstraction has already been eliminated.\n\nThe main translation is represented in LF by a judgement (an LF type family)\n<tt>trans M N</tt>.  Bracket abstraction is represented by a judgement\nrelating LF-level abstractions in the combinator language to closed combinator\nterms, <tt>bracket ([x] N x) N</tt>.  This definition is essentially an\ninstance of [[higher-order abstract syntax]].\n\n}%\n\ntrans : term A -> cterm A -> type.\nbracket : (cterm A -> cterm B) -> cterm (A => B) -> type.\n\n\nt-app : trans (app M1 M2) (capp N1 N2)\n         <- trans M1 N1\n         <- trans M2 N2.\n\n%{\n\nThe translation on lambda-abstractions has to work under an extended context\nwith a lambda-term variable, a combinator-term variable, and an assumption\nthat the one translates to the other.  See the <tt>%worlds</tt> declaration\nbelow.\n\n}%\nt-lam : trans (lam [x] M x) N'\n         <- ({x:term A} {y:cterm A} trans x y -> trans (M x) (N y))\n         <- bracket ([y] N y) N'.\n\n\nb-i : bracket ([x] x) i.\n\nb-k : bracket ([x] Y) (capp k Y).\n\nb-s : bracket ([x] capp (N1 x) (N2 x)) (capp (capp s N1') N2')\n       <- bracket ([x] N1 x) N1'\n       <- bracket ([x] N2 x) N2'.\n\n\n%block tbind : some {A:tp} block {x:term A} {y:cterm A} {dtrans:trans x y}.\n%worlds (tbind) (bracket _ _).\n%worlds (tbind) (trans _ _).\n\n%{\n\n== Correctness of the translation ==\n\n}%\n\n%{\n\nFirst, we prove the correctness of bracket abstraction itself:\nthe application of a bracket abstraction reduces to a substitution.\n\n}%\n\nsubst : bracket ([x] N x) N' -> {N0} cstep* (capp N' N0) (N N0) -> type.\n%mode subst +B +N0 -CS.\n\n- : subst b-i N0 (cs-cons cs-nil cs-i).\n\n- : subst b-k N0 (cs-cons cs-nil cs-k).\n\n% developing incrementally, it's useful to write down the type of each output\n- : subst (b-s (B2 : bracket ([x] N2 x) N2')\n               (B1 : bracket ([x] N1 x) N1'))\n          N0\n          (cs-cons CS12' cs-s)\n     <- subst B1 N0 (CS1 : cstep* (N1' @@ N0) (N1 N0))\n     <- subst B2 N0 (CS2 : cstep* (N2' @@ N0) (N2 N0))\n     <- cs-1* CS1 (CS1' : cstep* ((N1' @@ N0) @@ (N2' @@ N0)) (N1 N0 @@ (N2' @@ N0)))\n     <- cs-2* CS2 (CS2' : cstep* (N1 N0 @@ (N2' @@ N0)) (N1 N0 @@ N2 N0))\n     <- cs-trans CS1' CS2' CS12'.\n\n%worlds () (subst _ _ _).\n%total {B} (subst B _ _).\n\n%{\n\nThen, we can prove simulation, the correctness of translation, by a\nstraightforward induction on single-step derivations in the lambda-calculus,\nusing the correctness of bracket abstraction as a lemma in the case of a\nbeta-reduction.\n\n}%\n\nsimulate : step M M' -> trans M N -> trans M' N' -> cstep* N N' -> type.\n%mode simulate +S +T -T' -CS.\n\n%{\n\nNB: in this step, on paper, you have to prove two compositionality lemmas.\nin Twelf, using higher-order abstract syntax, we get them for free -- see\n(T1 _ _ T2) output.\n\n}%\n- : simulate s-beta (t-app T2 (t-lam B1 T1)) (T1 _ _ T2) CS\n     <- subst B1 N2 CS.\n\n- : simulate (s-1 S1) (t-app T2 T1) (t-app T2 T1') CSapp\n     <- simulate S1 T1 T1' CS1\n     <- cs-1* CS1 CSapp.\n\n- : simulate (s-2 S2) (t-app T2 T1) (t-app T2' T1) CSapp\n     <- simulate S2 T2 T2' CS2\n     <- cs-2* CS2 CSapp.\n\n%worlds () (simulate _ _ _ _).\n%total D (simulate D _ _ _)."
          },
          "sha1": "i77rbac7z01agtsmynz3lczvgc85g2s"
        }
      },
      {
        "title": "POPL Tutorial/Typed bracket abstraction with equivalence",
        "ns": 0,
        "id": 2144,
        "revision": {
          "id": 5707,
          "timestamp": "2008-12-04T23:53:17Z",
          "contributor": {
            "username": "William Lovas",
            "id": 11
          },
          "comment": "first cut at a bracket abstraction example using full beta/eta equality",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 16027,
            "#text": "%{\n\nThis is a case study translating the simply lambda calculus into S, K, and I\ncombinatory logic.  The correctness of the translation is proven in the\nfollowing sense: if a two terms are beta-eta equal, then their translations\nare beta-eta equal.\n\n[[User:William Lovas|William Lovas]]\n\n}%\n\n\n%{\n\n== Syntax and static semantics ==\n\n}%\n\n%{\n\nFirst we define the syntax of the two languages.  <tt>term A</tt> is the\ntype of simply-typed lambda-calculus terms of type A; <tt>comb A</tt> is\nthe type of simply-typed combinator terms of type A.  Combinators are of\ninterest primarily because they have no binding structure; despite this\napparent limitation, we can translate any lambda-calculus term to an\noperationally and logically related combinator term.\n\nNote that since we're using an\n[[intrinsic and extrinsic encodings|intrinsic encoding]], these syntax\ndefinitions double as definitions of the languages' static semantics.\n\n}%\n\ntp : type.              %name tp A a.\n\no : tp.\n=> : tp -> tp -> tp.    %infix right 10 =>.\n\n\nterm : tp -> type.      %name term M x.\n\n%% tm : type.              %name tm M x.\n%% %abbrev term : tp -> type = [x] tm.\n\napp : term (A => B) -> term A -> term B.\nlam : (term A -> term B) -> term (A => B).\n\n\ncomb : tp -> type.     %name comb N y.\n\n%% cm : type.              %name cm N y.\n%% %abbrev comb : tp -> type = [x] cm.\n\ns : comb ((A => B => C) => (A => B) => A => C).\nk : comb (A => B => A).\ni : comb (A => A).\n\ncapp : comb (A => B) -> comb A -> comb B.\n\n%{ \n\nWe can use Twelf's [[Abbrev_declaration|abbreviation mechanism]] and\n[[Fixity declaration|fixity declarations]] to obtain some cute syntax.\n\n}%\n\n%abbrev @ = app.\n%infix left 10 @.\n\n%abbrev @@ = capp.\n%infix left 10 @@.\n\n%{\n\n== Equational theory ==\n\n}%\n\n%{\n\nThen we define equality relations on both languages.  <tt>teq</tt> is\ndefinitional equality for lambda terms; <tt>ceq</tt> is definitional\nequality for combinator terms.  In both cases, the equality relation\namounts to beta-eta equivalence.  (We use extensionality instead of a\nrule based on eta-expansion.)\n\n}%\n\n% definitional equality on terms (better name?)\nteq : term A -> term A -> type.\n%mode teq *M1 *M2.  % spurious mode declaration necessary?  see unique-block..\n\n% beta\neq/beta : teq (app (lam [x] M1 x) M2) (M1 M2).\n\n% eta\neq/eta : teq M1 M2\n          <- ({x} teq (app M1 x) (app M2 x)).\n\n% XXX interesting note: beta + ext ⊦ lam.  lam + beta + eta ⊦ ext.\n% others?  cut out some cases?\n\n% compatibilities\neq/lam : teq (lam [x] M x) (lam [x] M' x)\n          <- ({x} teq (M x) (M' x)).\n\neq/app : teq (app M1 M2) (app M1' M2')\n          <- teq M1 M1'\n          <- teq M2 M2'.\n\n% equivalence\neq/refl : teq M M.\n\neq/symm : teq M M'\n           <- teq M' M.\n\neq/trans : teq M M''\n            <- teq M' M''\n            <- teq M M'.\n\n%block teq-block : some {A:tp} block {x:term A}.\n%worlds (teq-block) (teq _ _).\n\n% definitional equality on combs\nceq : comb A -> comb A -> type.\n\n% betas\nceq/i : ceq (capp i N) N.\nceq/k : ceq (capp (capp k N1) N2) N1.\nceq/s : ceq (capp (capp (capp s N1) N2) N3) (capp (capp N1 N3) (capp N2 N3)).\n\n% eta\nceq/eta : ceq N1 N2\n           <- ({y} ceq (capp N1 y) (capp N2 y)).\n\n% compatibility\nceq/app : ceq (capp N1 N2) (capp N1' N2')\n           <- ceq N1 N1'\n           <- ceq N2 N2'.\n\n% equivalence\nceq/refl : ceq N N.\n\nceq/symm : ceq N N'\n            <- ceq N' N.\n\nceq/trans : ceq N N''\n             <- ceq N' N''\n             <- ceq N N'.\n\n%abbrev ; : ceq N N' -> ceq N' N'' -> ceq N N'' = [d1] [d2] ceq/trans d1 d2.\n%infix right 5 ;.\n\n%block ceq-block : some {A:tp} block {y:comb A}.\n%worlds (ceq-block) (ceq _ _).\n\n%{\n\n== Translation ==\n\n}%\n\n%{\n\nWe can now define a compositional translation from lambda terms to combinator\nterms in the standard way.  The translation appeals to a function called\n''bracket abstraction'' which simulates binding in the combinator calculus.\n\nBracket abstraction is usually written <math>[x] N</math> where <math>N</math>\nis a combinator term, and <math>x</math> is a variable potentially free in\n<math>N</math>.  (Be careful not to confuse these brackets with Twelf's syntax\nfor lambda abstraction.)  It is defined inductively over the term\n<math>N</math>:\n\n<blockquote>\n<math>[x]</math> <math>x = I</math><br>\n<math>[x]</math> <math>N = K</math> <math>N</math>\n    (where <math>x</math> not free in <math>N</math>)<br>\n<math>[x]</math> <math>N_1</math> <math>N_2 =\n    S</math> <math>([x]</math> <math>N_1)</math>\n             <math>([x]</math> <math>N_2)</math><br>\n</blockquote>\n\nUsing it, we can define a translation on lambda-terms, <math>M^*</math>, where\n<math>M</math> is a lambda-term, as follows:\n\n<blockquote>\n<math>x^* = x</math><br>\n<math>(M_1</math> <math>M_2)^*</math> =\n    <math>M_1^*</math> <math>M_2^*</math><br>\n<math>(\\lambda x.</math> <math>M)^* = [x]</math> <math>M^*</math>\n</blockquote>\n\nNote that in the definition of bracket abstraction, we need not consider a\ncase for lambda-abstraction since bracket abstraction works over combinator\nterms, in which lambda-abstraction has already been eliminated.\n\nThe main translation is represented in LF by a judgement (an LF type family)\n<tt>translate M N</tt>.  Bracket abstraction is represented by a judgement\nrelating LF-level abstractions in the combinator language to closed combinator\nterms, <tt>bracket ([x] N x) N</tt>.  This definition is essentially an\ninstance of [[higher-order abstract syntax]].\n\n}%\n\ntranslate : term A -> comb A -> type.\n%mode translate +M -N.\n%name translate Dtrans dtrans.\n\nbracket : (comb A -> comb B) -> comb (A => B) -> type.\n%mode bracket +N -N*.\n%name bracket Dbrack dbrack.\n\n\nt/app : translate (app M1 M2) (capp N1 N2)\n         <- translate M1 N1\n         <- translate M2 N2.\n\n%{\n\nThe translation on lambda-abstractions has to work under an extended context\nwith a lambda-term variable, a combinator-term variable, and an assumption\nthat the one translates to the other.  See the <tt>%worlds</tt> declaration\nbelow.\n\n}%\nt/lam : translate (lam [x] M x) N*\n         <- ({x:term A} {y:comb A} translate x y -> translate (M x) (N y))\n         <- bracket ([y] N y) N*.\n\n\nb/i : bracket ([x] x) i.\n\nb/k : bracket ([x] Y) (capp k Y).\n\nb/s : bracket ([x] capp (N1 x) (N2 x)) (capp (capp s N1') N2')\n       <- bracket ([x] N1 x) N1'\n       <- bracket ([x] N2 x) N2'.\n\n\n%block trans-block : some {A:tp}\n                     block {x:term A} {y:comb A} {dtrans:translate x y}.\n\n%worlds (trans-block) (bracket _ _).\n%worlds (trans-block) (translate _ _).\n\n%{\n\nBoth relations are effective (though we cannot use this fact in proofs).\n\n}%\n\n%total N (bracket N _).\n%total M (translate M _).\n\n%{\n\nInstead, we need effectiveness lemmas.  XXX explain this better...\n\n}%\n\ncan-bracket : {N : comb A -> comb B} bracket N N* -> type.\n%mode can-bracket +N -Dbrack.\n\ncan-translate : {M : term A} translate M N -> type.\n%mode can-translate +M -Dtrans.\n\n- : can-bracket ([x] x) b/i.\n- : can-bracket ([x] N) b/k.\n- : can-bracket ([x] capp (N1 x) (N2 x)) (b/s Dbrack2 Dbrack1)\n     <- can-bracket ([x] N1 x) Dbrack1\n     <- can-bracket ([x] N2 x) Dbrack2.\n\n- : can-translate (app M1 M2) (t/app Dtrans2 Dtrans1)\n     <- can-translate M1 (Dtrans1 : translate M1 N1)\n     <- can-translate M2 (Dtrans2 : translate M2 N2).\n\n- : can-translate (lam [x] M x) (t/lam Dbrack Dtrans)\n     <- ({x} {y} {dtrans: translate x y} {thm: can-translate x dtrans}\n            can-translate (M x) (Dtrans x y dtrans : translate (M x) (N y)))\n     <- can-bracket ([y] N y) (Dbrack : bracket ([y] N y) N*).\n\n%block can-block\n            : some {A:tp}\n              block {x:term A} {y:comb A}\n                    {dtrans: translate x y}\n                    {thm: can-translate x dtrans}.\n\n%worlds (can-block) (can-bracket _ _).\n%total N (can-bracket N _).\n\n%worlds (can-block) (can-translate _ _).\n%total M (can-translate M _).\n\n\n%{\n\n== Correctness of the translation ==\n\n}%\n\n%{\n\nFirst, we prove the correctness of bracket abstraction itself:\nthe application of a bracket abstraction reduces to a substitution.\n\n}%\n\nsubst : bracket ([x] N x) N* -> {N0} ceq (capp N* N0) (N N0) -> type.\n%mode subst +B +X -CS.\n\n- : subst (b/i : bracket ([x] x) i)\n          N0\n          (ceq/i : ceq (i @@ N0) N0).\n\n- : subst (b/k : bracket ([x] Y) (k @@ Y))\n          N0\n          (ceq/k : ceq (k @@ Y @@ N0) Y).\n\n% developing incrementally, it's useful to write down the type of each output\n- : subst (b/s (B2 : bracket ([x] N2 x) N2')\n               (B1 : bracket ([x] N1 x) N1')\n            : bracket ([x] N1 x @@ N2 x) (s @@ N1' @@ N2'))\n          N0\n          (ceq/trans\n              (ceq/s\n                : ceq (s @@ N1' @@ N2' @@ N0) ((N1' @@ N0) @@ (N2' @@ N0)))\n              (ceq/app Dceq2 Dceq1\n                : ceq ((N1' @@ N0) @@ (N2' @@ N0)) (N1 N0 @@ N2 N0)))\n     <- subst B1 N0 (Dceq1 : ceq (N1' @@ N0) (N1 N0))\n     <- subst B2 N0 (Dceq2 : ceq (N2' @@ N0) (N2 N0)).\n\n%worlds (ceq-block) (subst _ _ _).\n%total {B} (subst B _ _).\n\n\n%{\n\nNext, we need to know that the translation of a term is unique up to\nequivalence.\n\n}%\n\ntranslate-unique : translate M N -> translate M N' -> ceq N N' -> type.\n%mode translate-unique +Dt1 +Dt2 -Deq.\n\n- : translate-unique\n        (t/app (Dtrans2 : translate M2 N2)\n               (Dtrans1 : translate M1 N1)\n          : translate (M1 @ M2) (N1 @@ N2))\n        (t/app (Dtrans2' : translate M2 N2')\n               (Dtrans1' : translate M1 N1')\n          : translate (M1 @ M2) (N1' @@ N2'))\n        (ceq/app Dceq2 Dceq1)\n     <- translate-unique Dtrans1 Dtrans1' (Dceq1 : ceq N1 N1')\n     <- translate-unique Dtrans2 Dtrans2' (Dceq2 : ceq N2 N2').\n\n- : translate-unique\n        (t/lam (Dbrack : bracket ([y] N y) N*)\n               ([x] [y] [dt] Dtrans x y dt : translate (M x) (N y))\n          : translate (lam [x] M x) N*)\n        (t/lam (Dbrack' : bracket ([y] N' y) N'*)\n               ([x] [y] [dt] Dtrans' x y dt : translate (M x) (N' y))\n          : translate (lam [x] M x) N'*)\n        (ceq/eta ([y] (Dceq y : ceq (N* @@ y) (N y)) ;\n                      (Dceqtrans y : ceq (N y) (N' y)) ;\n                      (ceq/symm (Dceq' y) : ceq (N' y) (N'* @@ y))\n                   : ceq (N* @@ y) (N'* @@ y))\n          : ceq N* N'*)\n     <- ({x} {y} {dtrans: translate x y}\n         {thm-unique: translate-unique dtrans dtrans ceq/refl}\n            translate-unique (Dtrans x y dtrans) (Dtrans' x y dtrans)\n            (Dceqtrans y : ceq (N y) (N' y)))\n     <- ({z} subst Dbrack z (Dceq z : ceq (N* @@ z) (N z)))\n     <- ({z} subst Dbrack' z (Dceq' z : ceq (N'* @@ z) (N' z))).\n\n%block unique-block\n            : some {A:tp}\n              block {x:term A} {y:comb A}\n                    {dtrans: translate x y}\n                    {thm: translate-unique dtrans dtrans ceq/refl}.\n\n%worlds (unique-block) (translate-unique _ _ _).\n%total D (translate-unique D _ _).\n\n\n%{\n\nThen, we can prove simulation, the correctness of translation, by a\nstraightforward induction on equality derivations in the lambda-calculus,\nusing the correctness of bracket abstraction as a lemma in the case of a\nbeta-reduction.\n\n}%\n\nsimulate' : translate M N -> translate M' N' -> teq M M' -> ceq N N' -> type.\n%mode simulate' +Dt +Dt' +Deq -Dceq.\n\n%abbrev simulate\n            : teq M M' -> translate M N -> translate M' N' -> ceq N N' -> type\n            = [deq] [dt] [dt'] [ceq] simulate' dt dt' deq ceq.\n%%mode simulate +Deq +Dt +Dt' -Dceq.\n\n- : simulate (eq/beta\n               : teq (app (lam [x] M1 x) M2) (M1 M2))\n             (t/app (Dtrans2 : translate M2 N2)\n                    (t/lam\n                        (Dbrack : bracket ([y] N1 y) N1*)\n                        % XXX mysteriously necessary type annotations\n                        ([x:term A2] [y:comb A2] [dtrans:translate x y]\n                            Dtrans1 x y dtrans\n                          : translate (M1 x) (N1 y)))\n               : translate (app (lam [x] M1 x) M2) (capp N1* N2))\n             (Dtrans3\n               : translate (M1 M2) N3)\n             (Dceq ; Dceq3\n               : ceq (capp N1* N2) N3)\n     <- subst Dbrack N2 (Dceq : ceq (capp N1* N2) (N1 N2))\n     <- translate-unique (Dtrans1 M2 N2 Dtrans2) Dtrans3\n                         (Dceq3 : ceq (N1 N2) N3).\n\n- : simulate (eq/eta ([x] Deq x : teq (app M1 x) (app M2 x))\n               : teq M1 M2)\n             (Dtrans1 : translate M1 N1)\n             (Dtrans2 : translate M2 N2)\n             (ceq/eta ([y] Dceq y) : ceq N1 N2)\n     <- ({x} {y} {dtrans: translate x y}\n         {thm-can: can-translate x dtrans}\n         {thm-unique: translate-unique dtrans dtrans ceq/refl}\n         {thm-simulate: simulate eq/refl dtrans dtrans ceq/refl}\n            simulate (Deq x : teq (app M1 x) (app M2 x))\n                     (t/app dtrans Dtrans1 : translate (app M1 x) (capp N1 y))\n                     (t/app dtrans Dtrans2 : translate (app M2 x) (capp N2 y))\n                     (Dceq y : ceq (capp N1 y) (capp N2 y))).\n\n- : simulate (eq/lam ([x] Deq x : teq (M x) (M' x))\n               : teq (lam [x] M x) (lam [x] M' x))\n             (t/lam (Dbrack : bracket ([y] N y) N*)\n                    ([x] [y] [dtrans: translate x y] Dtrans x y dtrans\n                      : translate (M x) (N y))\n               : translate (lam [x] M x) N*)\n             (t/lam (Dbrack' : bracket ([y] N' y) N*')\n                    ([x] [y] [dtrans: translate x y] Dtrans' x y dtrans\n                      : translate (M' x) (N' y))\n               : translate (lam [x] M' x) N*')\n             (ceq/eta ([y] (Dceq* y : ceq (N* @@ y) (N y)) ;\n                           (Dceq y : ceq (N y) (N' y)) ;\n                           (ceq/symm (Dceq*' y) : ceq (N' y) (N*' @@ y)))\n               : ceq N* N*')\n     <- ({x} {y} {dtrans: translate x y}\n         {thm-can: can-translate x dtrans}\n         {thm-unique: translate-unique dtrans dtrans ceq/refl}\n         {thm-simulate: simulate eq/refl dtrans dtrans ceq/refl}\n            simulate (Deq x : teq (M x) (M' x))\n                     (Dtrans x y dtrans : translate (M x) (N y))\n                     (Dtrans' x y dtrans : translate (M' x) (N' y))\n                     (Dceq y : ceq (N y) (N' y)))\n     <- ({y} subst Dbrack y (Dceq* y : ceq (N* @@ y) (N y)))\n     <- ({y} subst Dbrack' y (Dceq*' y : ceq (N*' @@ y) (N' y))).\n\n- : simulate (eq/app (Deq2 : teq M2 M2')\n                     (Deq1 : teq M1 M1')\n               : teq (M1 @ M2) (M1' @ M2'))\n             (t/app (Dtrans2 : translate M2 N2)\n                    (Dtrans1 : translate M1 N1)\n               : translate (M1 @ M2) (N1 @@ N2))\n             (t/app (Dtrans2' : translate M2' N2')\n                    (Dtrans1' : translate M1' N1')\n               : translate (M1' @ M2') (N1' @@ N2'))\n             (ceq/app Dceq2 Dceq1\n               : ceq (N1 @@ N2) (N1' @@ N2'))\n     <- simulate Deq1 Dtrans1 Dtrans1' (Dceq1 : ceq N1 N1')\n     <- simulate Deq2 Dtrans2 Dtrans2' (Dceq2 : ceq N2 N2').\n\n- : simulate (eq/refl : teq M M)\n             (Dtrans : translate M N)\n             (Dtrans' : translate M N')\n             Dceq\n     <- translate-unique Dtrans Dtrans' (Dceq : ceq N N').\n\n- : simulate (eq/symm (Deq : teq M' M) : teq M M')\n             (Dtrans : translate M N)\n             (Dtrans' : translate M' N')\n             (ceq/symm Dceq : ceq N N')\n     <- simulate Deq Dtrans' Dtrans (Dceq : ceq N' N).\n\n- : simulate (eq/trans (Deq1 : teq M M') (Deq2 : teq M' M'') : teq M M'')\n             (Dtrans : translate M N)\n             (Dtrans'' : translate M'' N'')\n             (ceq/trans Dceq1 Dceq2 : ceq N N'')\n     <- can-translate M' (Dtrans' : translate M' N')\n     <- simulate Deq1 Dtrans Dtrans' (Dceq1 : ceq N N')\n     <- simulate Deq2 Dtrans' Dtrans'' (Dceq2 : ceq N' N'').\n\n%block simulate-block\n            : some {A:tp}\n              block {x:term A} {y:comb A}\n                    {dtrans: translate x y}\n                    {thm-can: can-translate x dtrans}\n                    {thm-unique: translate-unique dtrans dtrans ceq/refl}\n                    {thm-simulate: simulate' dtrans dtrans eq/refl ceq/refl}.\n\n%worlds (simulate-block) (simulate' _ _ _ _).\n%total D (simulate' _ _ D _)."
          },
          "sha1": "i6uk0yka8b3vcqcvbec7evwxvtdclzt"
        }
      },
      {
        "title": "POPL Tutorial/cps",
        "ns": 0,
        "id": 2094,
        "revision": {
          "id": 5468,
          "parentid": 5448,
          "timestamp": "2008-11-18T00:08:47Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 1150,
            "#text": "%{\n\n== CPS Conversion ==\n\n}%\n\ntp : type.\no : tp.\n=> : tp -> tp -> tp. %infix right 3 =>.\n\ne : tp -> type.\nv : tp -> type.\napp : e (A => B) -> e A -> e B.\nlam : (v A -> e B) -> v (A => B).\ninj : v A -> e A.\n%block sourceb : some {A : tp} block {x : v A}.\n%worlds (sourceb) (e _) (v _).\n\nce : type.\ncv : tp -> type.\ncapp : cv (A => B) -> cv A -> (cv B -> ce) -> ce.\nclam : (cv A -> (cv B -> ce) -> ce) -> cv (A => B).\n%block targetb1 : some {A : tp} block {x : cv A}.\n%block targetb2 : some {A : tp} block {y : cv A -> ce}.\n%worlds (targetb1 | targetb2) (ce) (cv _).\n\ncps : v A -> cv A -> type.\n%mode cps +X1 -X2.\n\ncpse : e A -> ((cv A -> ce) -> ce) -> type.\n%mode cpse +X1 -X2.\n\ncps/lam : cps (lam E) (clam E')\n\t   <- ({x:v A}{x':cv A} cps x x' -> cpse (E x) (E' x')).\ncpse/app : cpse (app E1 E2)\n\t    ([c : (cv A -> ce)] E1' ([w1] E2' ([w2]\n                                        capp w1 w2 c)))\n\t    <- cpse E1 E1'\n\t    <- cpse E2 E2'.\ncpse/inj : cpse (inj E) ([c : (cv A -> ce)] c E')\n\t    <- cps E E'.\n\n%block cpsb : some {A : tp} block {x : v A} {x' : cv A} {d : cps x x'}.\n%worlds (cpsb) (cps _ _) (cpse _ _).\n%total (E V) (cps E _) (cpse V _)."
          },
          "sha1": "ibl39yzbmgrqug6o2rchwtajm8d4qfz"
        }
      },
      {
        "title": "POPL Tutorial/cps-ctp",
        "ns": 0,
        "id": 2103,
        "revision": {
          "id": 5478,
          "timestamp": "2008-11-18T22:43:19Z",
          "contributor": {
            "ip": "72.95.199.32"
          },
          "comment": "Modification of Jason's cps code that indexes with target types",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 1830,
            "#text": "== CPS conversion with target types ==\n\n\n<twelf>\n%% Source types\n\ntp : type.\no : tp.\n=> : tp -> tp -> tp.           %infix right 3 =>.\n\n%% Destination types\nctp : type.\nco : ctp.\ncnot : ctp -> ctp.\ncand : ctp -> ctp -> ctp.      %infix right 3 cand.\n\n%% Source expressions and values annotated by the translation of their types.\ne : ctp -> type.\nv : ctp -> type.\napp : e (cnot (A cand (cnot B))) -> e A -> e B.\nlam : (v A -> e B) -> v (cnot (A cand (cnot B))).\ninj : v A -> e A.\n%block sourceb : some {A : ctp} block {x : v A}.\n%worlds (sourceb) (e _) (v _).\n\n%% Destination expression and values annotated by their types.\nce : type.\ncv : ctp -> type.\n% This is the only kind of conjunction we need but it seems pretty odd.\ncapp : cv A -> cv (cnot B) -> (cv (cnot (cnot (A cand (cnot B))))).\nclam : (cv A -> cv (cnot B) -> ce) -> cv (cnot (A cand (cnot B))).\ncnoti : (cv A -> ce) -> cv (cnot A).\nthrow : cv A -> cv (cnot A) -> ce.\n%block targetb : some {A : ctp} block {x : cv A}.\n%worlds (targetb) (ce) (cv _).\n\ncps : v A -> cv A -> type.\n%mode cps +X1 -X2.\n\ncpse : e A -> (cv (cnot A) -> ce) -> type.\n%mode cpse +X1 -X2.\n\ncps/lam : cps (lam (E:v A -> e B)) (clam (E':cv A -> cv (cnot B) -> ce))\n              <- ({x:v A}{x':cv A} cps x x' -> cpse (E x) (E' x')).\ncpse/app : cpse (app (E1:e (cnot (B cand (cnot A)))) (E2:e B))\n                ([c:cv (cnot A)] E2' (cnoti ([arg:cv B]\n                                               E1' (capp arg c))))\n                <- cpse E1 (E1':(cv (cnot (cnot (B cand (cnot A))))) -> ce)\n                <- cpse E2 (E2':(cv (cnot B)) -> ce).\ncpse/inj : cpse (inj (V:v A)) ([c:cv (cnot A)] throw V' c)\n                <- cps V (V':cv A).\n\n%block cpsb : some {A : ctp} block {x : v A} {x' : cv A} {d : cps x x'}.\n%worlds (cpsb) (cps _ _) (cpse _ _).\n%total (E V) (cps E _) (cpse V _).\n</twelf>"
          },
          "sha1": "l1gaambu6jlbe56n43d7zeur3vj3vlh"
        }
      },
      {
        "title": "POPL Tutorial/cps-problem",
        "ns": 0,
        "id": 2112,
        "revision": {
          "id": 5598,
          "parentid": 5596,
          "timestamp": "2008-11-21T21:00:51Z",
          "contributor": {
            "username": "Adahmad",
            "id": 43
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 3127,
            "#text": "%{\n\n== Problem 1: CPS Conversion with Administrative Redices ==\n\nIn this problem we define a translation from the following simply-typed\nλ-calculus to a language in continuation passing style (CPS).\n\n}%\n\ntp : type.\no  : tp.\n=> : tp -> tp -> tp.           %infix right 3 =>.\n\nexp   : tp -> type.\nvalue : tp -> type.\napp   : exp (A => B) -> exp A -> exp B.\nlam   : (value A -> exp B) -> value (A => B).\nret   : value A -> exp A.\n%block sourceb : some {A : tp} block {x : value A}.\n%worlds (sourceb) (exp _) (value _).\n\n%{\n\nThe terms are divided into expressions and values as in the previous exercise, but there is also an injection of values into expressions.  We define the language so that an expression or value of type A will have the type exp A or value A, respectively.  We will initially define a translation into the following CPS language.\n\n}%\n\ncontra : type.\ncvalue : tp -> type.\nccont  : tp -> type.\ncapp   : cvalue (A => B) -> cvalue A -> ccont B -> contra.\nclam   : (cvalue A -> ccont B -> contra) -> cvalue (A => B).\ncconti : (cvalue A -> contra) -> ccont A.\ncthrow : ccont A -> cvalue A -> contra.\n%block targetb1 : some {A : tp} block {x : cvalue A}.\n%block targetb2 : some {A : tp} block {x : ccont A}.\n%worlds (targetb1 | targetb2) (contra) (cvalue _) (ccont _).\n%{\n\nHere we have divided the terms into values, continuations, and contradictions.  Values have a similar interpretation as in the source language.  The continuations represent the remainder of the computation given a value.  From a logical perspective, a continuation of type A may be viewed as a proof of not A. Notice that the introduction and elimination rules for continuations are inverses.  Intuitively, a contradiction is a computation.\n\nA value of type A => B can be interpreted as proofs of (not (A and (not B))).  Consequently, the function in the target language is defined by deriving a contradiction from A value of type A and a continuation of type B, and the application in the target language is the inverse of the function introduction taking a value of type A => B and giving back a proof that a value of type A and a continuation of type B yield a contradiction.\n\nIt remains to define a translation from the source to the target language:\n\n}%\ncps : value A -> cvalue A -> type.\n%mode cps +X1 -X2.\n\ncpse : exp A -> (ccont A -> contra) -> type.\n%mode cpse +X1 -X2.\n\n%{\n\nWe translate values in the source language to values in the target language of the same type.  We translate expressions in the source language to computations in the target language which depend on a continuation of the given type.  For this problem, fill in the three cases of the translation and check that it is total.  The translation defined on the bottom of page 147 in [http://homepages.inf.ed.ac.uk/gdp/publications/cbn_cbv_lambda.pdf Plotkin's Call-by-name, Call-by-value and the λ-Calculus] may be helpful.  Note that the translation of functions given there is the composition of the translations of ret and lam in our setting.\n\nWhen you complete this problem you can learn another technique in the second part: [[POPL Tutorial/cps-problem2]]\n\n}%"
          },
          "sha1": "817q74ejt6nbq5iclekiefkb9ysrp52"
        }
      },
      {
        "title": "POPL Tutorial/cps-problem2",
        "ns": 0,
        "id": 2120,
        "revision": {
          "id": 5605,
          "parentid": 5576,
          "timestamp": "2008-11-21T21:15:23Z",
          "contributor": {
            "username": "Adahmad",
            "id": 43
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 1719,
            "#text": "%{\n== Problem 2: Elimination of Administrative Redices ==\n\nRather than introducing the administrative redices of explicitly introducing and eliminating continuations (see [[POPL Tutorial/cps-problem]]), we can simply use the function from values to computations itself wherever we previously used a continuation.  Therefore, the new definition of the CPS language is obtained by replacing all instances of ccont A with (cvalue A -> contra).\n| hidden=\"true\"}%\ntp : type.\no : tp.\n=> : tp -> tp -> tp.           %infix right 3 =>.\n\nexp   : tp -> type.\nvalue : tp -> type.\napp   : exp (A => B) -> exp A -> exp B.\nlam   : (value A -> exp B) -> value (A => B).\nret   : value A -> exp A.\n%block sourceb : some {A : tp} block {x : value A}.\n%worlds (sourceb) (exp _) (value _).\n%{}%\ncontra : type.\ncvalue : tp -> type.\ncapp   : cvalue (A => B) -> cvalue A -> (cvalue B -> contra) -> contra.\nclam   : (cvalue A -> (cvalue B -> contra) -> contra) -> cvalue (A => B).\n%block targetb1 : some {A : tp} block {x : cvalue A}.\n%block targetb2 : some {A : tp} block {y : cvalue A -> contra}.\n%worlds (targetb1 | targetb2) (contra) (cvalue _).\n%{\nNotice that we no longer need terms for continuations as they are implicitly represented by the functions from values to contradictions.\n\nFor this problem, write the translation to this version of the CPS language:\n}%\ncps : value A -> cvalue A -> type.\n%mode cps +X1 -X2.\n\ncpse : exp A -> ((cvalue A -> contra) -> contra) -> type.\n%mode cpse +X1 -X2.\n%{\nThe code for this problem should be similar to the code from the previous problem except that the introduction of continuations with cfalsei and their elimination with throw is replaced by Twelf function introduction and application.\n}%"
          },
          "sha1": "9pk2952snlomvkvrte2ty2hdkgdt4tt"
        }
      },
      {
        "title": "POPL Tutorial/cps-rp",
        "ns": 0,
        "id": 2101,
        "revision": {
          "id": 5472,
          "parentid": 5471,
          "timestamp": "2008-11-18T01:00:45Z",
          "contributor": {
            "username": "DanielKLee",
            "id": 5
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 3140,
            "#text": "%{}%\n\ntp : type.\no : tp.\n=> : tp -> tp -> tp. %infix right 3 =>.\n\ne : tp -> type.\nv : tp -> type.\napp : e (A => B) -> e A -> e B.\nlam : (v A -> e B) -> v (A => B).\ninj : v A -> e A.\n%block sourceb : some {A : tp} block {x : v A}.\n%worlds (sourceb) (e _) (v _).\n\n\n\n\nctp\t: type.\n\nco\t: ctp.\ncarr\t: ctp -> ctp -> ctp. \n\n\nce : type.\ncv : ctp -> type.\ncapp : cv (carr A B) -> cv A -> (cv B -> ce) -> ce.\nclam : (cv A -> (cv B -> ce) -> ce) -> cv (carr A B).\n%block targetb1 : some {A : ctp} block {x : cv A}.\n%block targetb2 : some {A : ctp} block {y : cv A -> ce}.\n%worlds (targetb1 | targetb2) (ce) (cv _).\n\n\n\ntrans-tp\t: tp -> ctp -> type.\n\ntrans-tp/o\t: trans-tp o co.\ntrans-tp/arr\t: trans-tp (T1 => T2) (carr P1 P2)\n\t\t   <- trans-tp T1 P1\n\t\t   <- trans-tp T2 P2. \n\ncan-trans-tp\t: {A:tp}\n\t\t   trans-tp A A'\n\t\t   -> type.\n%mode can-trans-tp +D1 -D2.\n\n-\t: can-trans-tp _ trans-tp/o.\n\n-\t: can-trans-tp (A => B) (trans-tp/arr D2 D1)\n\t   <- can-trans-tp A D1\n\t   <- can-trans-tp B D2.\n\n%worlds () (can-trans-tp _ _).\n%total (D1) (can-trans-tp D1 _).\n\n\n\nctp-eq\t: ctp -> ctp -> type.\n\nctp-eq/i\t: ctp-eq A' A'.\n\n\nctp-eq-resp\t: {C : ctp -> ctp -> ctp}\n\t\t   ctp-eq A1 A1'\n\t\t   -> ctp-eq A2 A2'\n\t\t   -> ctp-eq (C A1 A2) (C A1' A2')\n\t\t   -> type.\n%mode ctp-eq-resp +D1 +D2 +D3 -D4.\n\n-\t: ctp-eq-resp C (ctp-eq/i : ctp-eq A A)\n\t   (ctp-eq/i : ctp-eq B B)\n\t   (ctp-eq/i : ctp-eq (C A B) (C A B)).\n\n%worlds () (ctp-eq-resp _ _ _ _).\n%total {} (ctp-eq-resp _ _ _ _). \n\n\ntrans-tp-unique\t: trans-tp A A'\n\t\t   -> trans-tp A A''\n\t\t   -> ctp-eq A' A''\n\t\t   -> type. \n%mode trans-tp-unique +D1 +D2 -D3.\n\n-\t: trans-tp-unique trans-tp/o trans-tp/o ctp-eq/i.\n\n-\t: trans-tp-unique (trans-tp/arr D2 D1) (trans-tp/arr D2' D1')  DQ3\n\t   <- trans-tp-unique D1 D1' DQ1\n\t   <- trans-tp-unique D2 D2' DQ2\n\t   <- ctp-eq-resp carr DQ1 DQ2 DQ3.\n\n%worlds () (trans-tp-unique _ _ _).\n%total (D1) (trans-tp-unique D1 _ _). \n\n\n\nceo-resp-ctp-eq\t: ctp-eq A A'\n\t\t   -> ((cv A -> ce) -> ce)\n\t\t   -> ((cv A' -> ce) -> ce)\n\t\t   -> type. \n%mode ceo-resp-ctp-eq +D1 +D2 -D3.\n\n-\t: ceo-resp-ctp-eq _ D1 D1.\n\n%worlds (targetb1 | targetb2) (ceo-resp-ctp-eq _ _ _).\n%total {} (ceo-resp-ctp-eq  _ _ _). \n\n\n\ncps : v A -> trans-tp A A' -> cv A' -> type.\n%mode cps +X1 -X2 -X3.\n\ncpse : e A -> trans-tp A A' -> ((cv A' -> ce) -> ce) -> type.\n%mode cpse +X1 -X2 -X3.\n\ncpse+ : e A -> trans-tp A A' -> ((cv A' -> ce) -> ce) -> type.\n%mode cpse+ +X1 +X2 -X3.\n\ncps/lam : cps (lam E) (trans-tp/arr D2 D1) (clam E')\n\t   <- can-trans-tp _ D1\n\t   <- ({x:v A}{x':cv A'} cps x D1 x' -> cpse (E x) D2 (E' x')).\ncpse/app : cpse (app E1 E2) D2\n\t    ([c : (cv A' -> ce)] E1' ([w1] E2' ([w2]\n                                        capp w1 w2 c)))\n\t    <- cpse E1 (trans-tp/arr D2 D1) E1'\n\t    <- cpse+ E2 D1 E2'.\ncpse/inj : cpse (inj E) D1 ([c : (cv A -> ce)] c E')\n\t    <- cps E D1 E'.\n\ncpse+/i\t: cpse+ E D1 E''\n\t   <- cpse E D1' E'\n\t   <- trans-tp-unique D1' D1 DQ\n\t   <- ceo-resp-ctp-eq DQ E' E''.\n\n%block cpsb : some {A : tp}{A' : ctp}{D1: trans-tp A A'} block {x : v A} {x' : cv A'} {d : cps x D1 x'}.\n%worlds (cpsb) (cps _ _ _) (cpse _ _ _) (cpse+ _ _ _).\n%total (E V E') (cps E _ _) (cpse V _ _) (cpse+ E' _ _)."
          },
          "sha1": "i1xqdvh7vs99gxmwaid0e0smzxfb0kk"
        }
      },
      {
        "title": "POPL Tutorial/cps-truefalse",
        "ns": 0,
        "id": 2108,
        "revision": {
          "id": 5505,
          "parentid": 5502,
          "timestamp": "2008-11-20T00:17:40Z",
          "contributor": {
            "ip": "128.237.229.15"
          },
          "comment": "/* CPS Conversion */",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 1688,
            "#text": "== CPS Conversion ==\n\n\n<twelf>\ntp : type.\no  : tp.\n=> : tp -> tp -> tp.           %infix right 3 =>.\n\nexp   : tp -> type.\nvalue : tp -> type.\napp   : exp (A => B) -> exp A -> exp B.\nlam   : (value A -> exp B) -> value (A => B).\nret   : value A -> exp A.\n%block sourceb : some {A : tp} block {x : value A}.\n%worlds (sourceb) (exp _) (value _).\n\ncontra  : type.\ncvalue  : tp -> type.\nccont   : tp -> type.\ncapp    : cvalue (A => B) -> cvalue A -> ccont B -> contra.\nclam    : (cvalue A -> ccont B -> contra) -> cvalue (A => B).\ncfalsei : (cvalue A -> contra) -> ccont A.\ncthrow : ccont A -> cvalue A -> contra.\n%block targetb1 : some {A : tp} block {x : cvalue A}.\n%block targetb2 : some {A : tp} block {x : ccont A}.\n%worlds (targetb1 | targetb2) (contra) (cvalue _) (ccont _).\n\ncps : value A -> cvalue A -> type.\n%mode cps +X1 -X2.\n\ncpse : exp A -> (ccont A -> contra) -> type.\n%mode cpse +X1 -X2.\n\ncps/lam : cps (lam (E:value A -> exp B))\n              (clam (E':cvalue A -> ccont B -> contra))\n           <- ({x:value A}{x':cvalue A} cps x x' -> cpse (E x) (E' x')).\ncpse/app : cpse (app (E1:exp (B => A)) (E2:exp B))\n                ([c:ccont A] E1' (cfalsei ([f:cvalue (B => A)]\n                                             E2' (cfalsei([x:cvalue B]\n                                                            capp f x c)))))\n            <- cpse E1 (E1':ccont (B => A) -> contra)\n            <- cpse E2 (E2':ccont B -> contra).\ncpse/ret : cpse (ret (V:value A)) ([c:ccont A] cthrow c V')\n            <- cps V (V':cvalue A).\n\n%block cpsb : some {A : tp} block {x : value A} {x' : cvalue A} {d : cps x x'}.\n%worlds (cpsb) (cps _ _) (cpse _ _).\n%total (E V) (cps E _) (cpse V _).</twelf>"
          },
          "sha1": "gyey1u6hz4injbr7i23t1nbvhd8sosl"
        }
      },
      {
        "title": "Pattern Matching (Case Study)",
        "ns": 0,
        "id": 2014,
        "redirect": {
          "@title": "Pattern matching",
          "#text": null
        },
        "revision": {
          "id": 4935,
          "timestamp": "2007-10-11T14:03:25Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "[[Pattern Matching (Case Study)]] moved to [[Pattern matching]]: Lcase, and we don't need to say it's a case study unless there's a name conflict",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 30,
            "#text": "#REDIRECT [[Pattern matching]]"
          },
          "sha1": "jpqslcdv3rg2wt550nvjbqj4aeub9zo"
        }
      },
      {
        "title": "Pattern matching",
        "ns": 0,
        "id": 2013,
        "revision": {
          "id": 4934,
          "parentid": 4933,
          "timestamp": "2007-10-11T14:03:25Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "minor": null,
          "comment": "[[Pattern Matching (Case Study)]] moved to [[Pattern matching]]: Lcase, and we don't need to say it's a case study unless there's a name conflict",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 25889,
            "#text": "%{ \nThis is a case study on pattern matching using Twelf.\n}%\n\n\nnat\t: type.\n\nz\t: nat.\ns\t: nat -> nat. \n\n\n% \n\nmap\t: nat -> type. \n\nmap/z\t: map z.\nmap/s\t: nat -> map N -> map (s N).\n\n\ntp : type.\n\no\t: tp.\narrow\t: tp -> tp -> tp.\nprod\t: tp -> tp -> tp.\nsum\t: tp -> tp -> tp.\n\n\ntplist\t: (nat -> nat) -> type. \n\ntplist/z\t: tplist ([n] n).\ntplist/s\t: tp -> tplist N -> tplist ([n] s (N n)). \n\n%{ A <tt>pat N</tt> is a pattern that binds (N z) variables. }%\n\npat\t: (nat -> nat) -> type.\n\npat/underscore\t: pat ([n] n).\npat/pair\t: pat N1 -> pat N2 -> pat ([n] N1 (N2 n)). \npat/inl\t\t: pat N -> pat N.\npat/inr\t\t: pat N -> pat N.\npat/var\t\t: pat s. \npat/as\t\t: pat N1 -> pat N2 -> pat ([n] N1 (N2 n)).\npat/or\t\t: pat N -> map (N z) -> pat N -> pat N.\n\n\nexp\t: type. \noexp\t: nat -> type.  % oexp N is an expression with N bound vars\nmatch\t: type.\n\nexp/unit\t: exp. \nexp/lam\t\t: match -> exp. \nexp/app\t\t: exp -> exp -> exp. \nexp/pair\t: exp -> exp -> exp.\nexp/inl\t\t: exp -> exp. \nexp/inr\t\t: exp -> exp. \nexp/handle\t: exp -> exp -> exp. \n\n\noexp/z\t: exp -> oexp z.\noexp/s\t: (exp -> oexp N) -> oexp (s N). \n\n\nmatch/nil\t: match. \nmatch/cons\t: pat N -> oexp (N z)-> match -> match.\n\n\n\n%{ static semantics }%\n\ntplist-append\t: tplist N1 -> tplist N2 -> tplist ([n] N1 (N2 n)) -> type. \n\ntplist-append/z\t: tplist-append tplist/z TL TL.\ntplist-append/s\t: tplist-append (tplist/s T TL) TL' (tplist/s T TL'')\n\t\t   <- tplist-append TL TL' TL''.\n\n\n\ntplist-get\t: nat -> tplist N -> tp -> type. \n\ntplist-get/hit\t: tplist-get z (tplist/s T TL) T.\ntplist-get/miss\t: tplist-get (s N) (tplist/s T TL) T'\n\t\t   <- tplist-get N TL T'.\n\n\ntplist-map\t: tplist N -> map (N' z) -> tplist N' -> type. \n\ntplist-map/z\t: tplist-map TL map/z tplist/z.\ntplist-map/s\t: tplist-map TL (map/s N M) (tplist/s T TL')\n\t\t   <- tplist-get N TL T\n\t\t   <- tplist-map TL M TL'.\n\n\nof-pat\t: pat N -> tp -> tplist N -> type. \n\nof-pat/underscore\t: of-pat pat/underscore T tplist/z. \nof-pat/pair\t\t: of-pat (pat/pair P1 P2) (prod T1 T2) TL'\n\t\t\t   <- of-pat P1 T1 TL1\n\t\t\t   <- of-pat P2 T2 TL2\n\t\t\t   <- tplist-append TL1 TL2 TL'.\nof-pat/inl\t\t: of-pat (pat/inl P) (sum T1 T2) TL\n\t\t\t   <- of-pat P T1 TL. \nof-pat/inr\t\t: of-pat (pat/inr P) (sum T1 T2) TL\n\t\t\t   <- of-pat P T2 TL. \nof-pat/var\t\t: of-pat pat/var T (tplist/s T tplist/z). \nof-pat/as\t\t: of-pat (pat/as P1 P2) T TL3\n\t\t\t   <- of-pat P1 T TL1\n\t\t\t   <- of-pat P2 T TL2\n\t\t\t   <- tplist-append TL1 TL2 TL3. \nof-pat/or\t\t: of-pat (pat/or P1 NM P2) T TL\n\t\t\t   <- of-pat P1 T (TL : tplist N)\n\t\t\t   <- of-pat P2 T (TL' : tplist N)\n\t\t\t   <- tplist-map TL' NM TL.  % or patterns are limited\n\n\nof-exp\t: exp -> tp -> type. \nof-match: match -> tp -> tp -> type. \nof-oexp\t: tplist N -> oexp (N z) -> tp -> type. \n\n\n\nof-oexp/z\t: of-oexp tplist/z (oexp/z E) T\n\t\t   <- of-exp E T. \nof-oexp/s\t: of-oexp (tplist/s T TL) (oexp/s ([x] EL x)) T'\n\t\t   <- ({x} of-exp x T\n\t\t\t -> of-oexp TL (EL x) T').\n\n\n\nof-match/nil\t: of-match match/nil T T'.\nof-match/cons\t: of-match (match/cons P OE M) T T'\n\t\t   <- of-pat P T TL\n\t\t   <- of-oexp TL OE T'\n\t\t   <- of-match M T T'.\n\n\n\nof-exp/unit\t: of-exp exp/unit o. \nof-exp/lam\t: of-exp (exp/lam M) (arrow T1 T2)\n\t\t   <- of-match M T1 T2.  \nof-exp/app\t: of-exp (exp/app E1 E2) T2\n\t\t   <- of-exp E1 (arrow T1 T2) \n\t\t   <- of-exp E2 T1.\nof-exp/pair\t: of-exp (exp/pair E1 E2) (prod T1 T2)\n\t\t   <- of-exp E1 T1\n\t\t   <- of-exp E2 T2. \nof-exp/inl\t: of-exp (exp/inl E) (sum T1 T2)\n\t\t   <- of-exp E T1.\nof-exp/inr\t: of-exp (exp/inr E) (sum T1 T2)\n\t\t   <- of-exp E T2. \nof-exp/handle\t: of-exp (exp/handle E1 E2) T\n\t\t   <- of-exp E1 T\n\t\t   <- of-exp E2 T.\n\n\n% syntax only needed for dynamic semantics of the language\n\nexplist\t: (nat -> nat) -> type. \n\nexplist/z\t: explist ([n]n).\nexplist/s\t: exp -> explist N -> explist ([n] s (N n)).\n\n\n\n% static semantics of explists\n\nof-explist\t: explist N -> tplist N -> type. \n\nof-explist/z\t: of-explist explist/z tplist/z.\nof-explist/s\t: of-explist (explist/s E EL) (tplist/s T TL)\n\t\t   <- of-exp E T\n\t\t   <- of-explist EL TL. \n\n\n\nsubst-oexp\t: explist N -> oexp (N z) -> exp -> type. \n\nsubst-oexp/z\t: subst-oexp explist/z (oexp/z E) E. \nsubst-oexp/s\t: subst-oexp (explist/s E EL) (oexp/s ([x] OE x)) E'\n\t\t   <- subst-oexp EL (OE E) E'.\n\n\n\nexplist-get\t: nat -> explist N -> exp -> type. \n\nexplist-get/hit\t: explist-get z (explist/s T TL) T.\nexplist-get/miss\t: explist-get (s N) (explist/s T TL) T'\n\t\t   <- explist-get N TL T'.\n\n\nexplist-map\t: explist N -> map (N' z) -> explist N' -> type. \n\nexplist-map/z\t: explist-map TL map/z explist/z.\nexplist-map/s\t: explist-map TL (map/s N M) (explist/s T TL')\n\t\t   <- explist-get N TL T\n\t\t   <- explist-map TL M TL'.\n\n\nexplist-append\t: explist N1 -> explist N2 -> explist ([n] N1 (N2 n)) -> type.\n\nexplist-append/z\t: explist-append explist/z EL EL. \nexplist-append/s\t: explist-append (explist/s E EL) EL' (explist/s E EL'')\n\t\t\t   <- explist-append EL EL' EL''.\n\n\n\napply-pat\t: pat N -> exp -> explist N -> type. \n\n% only have to define failure over well-typed pattern/expression pairs\n% failures arise from inl/inr mismatches\n\nfail-pat\t: pat N -> exp -> type. \n\napply-pat/underscore\t\n   : apply-pat pat/underscore E explist/z. \napply-pat/pair\t\t\n   : apply-pat (pat/pair P1 P2) (exp/pair E1 E2) EL'\n      <- apply-pat P1 E1 EL1\n      <- apply-pat P2 E2 EL2\n      <- explist-append EL1 EL2 EL'.\napply-pat/inl\n   : apply-pat (pat/inl P) (exp/inl E) EL\n      <- apply-pat P E EL.\napply-pat/inr\n   : apply-pat (pat/inr P) (exp/inr E) EL\n      <- apply-pat P E EL. \napply-pat/var\n   : apply-pat pat/var E (explist/s E explist/z). \napply-pat/as\t\t\n   : apply-pat (pat/as P1 P2) E EL'\n      <- apply-pat P1 E EL1\n      <- apply-pat P2 E EL2\n      <- explist-append EL1 EL2 EL'.\napply-pat/or-1\n   : apply-pat (pat/or P1 M P2) E EL\n      <- apply-pat P1 E EL.\napply-pat/or-2\n   : apply-pat (pat/or P1 M P2) E EL'\n      <- fail-pat P1 E\n      <- apply-pat P2 E EL\n      <- explist-map EL M EL'. \n\n\nfail-pat/pair-1\t: fail-pat (pat/pair P1 P2) (exp/pair E1 E2) \n\t\t   <- fail-pat P1 E1.\nfail-pat/pair-2\t: fail-pat (pat/pair P1 P2) (exp/pair E1 E2)\n\t\t   <- apply-pat P1 E1 EL\n\t\t   <- fail-pat P2 E2. \nfail-pat/inl-t\t: fail-pat (pat/inl P) (exp/inl E)\n\t\t   <- fail-pat P E. \nfail-pat/inl-f\t: fail-pat (pat/inl P) (exp/inr E).\nfail-pat/inr-t\t: fail-pat (pat/inr P) (exp/inr E)\n\t\t   <- fail-pat P E. \nfail-pat/inr-f\t: fail-pat (pat/inr P) (exp/inl E).\nfail-pat/as-1\t: fail-pat (pat/as P1 P2) E\n\t\t   <- fail-pat P1 E.\nfail-pat/as-2\t: fail-pat (pat/as P1 P2) E\n\t\t   <- apply-pat P1 E EL\n\t\t   <- fail-pat P2 E. \nfail-pat/or\t: fail-pat (pat/or P1 M P2) E\n\t\t   <- fail-pat P1 E\n\t\t   <- fail-pat P2 E. \n\n\n\napply-or-fail-pat\t: pat N -> exp -> type. \n\napply-or-fail-pat/apply\t: apply-or-fail-pat P E \n\t\t\t\t   <- apply-pat P E EL.\napply-or-fail-pat/fail\t: apply-or-fail-pat P E\n\t\t\t\t   <- fail-pat P E. \n\n\n\napply-match\t: match -> exp -> exp -> type. \n\napply-match/cons-1\t: apply-match (match/cons P OE M) E E'\n\t\t\t   <- apply-pat P E EL\n\t\t\t   <- subst-oexp EL OE E'. \napply-match/cons-2\t: apply-match (match/cons P OE M) E E'\n\t\t\t   <- fail-pat P E\n\t\t\t   <- apply-match M E E'. \n\n\nfail-match\t: match -> exp -> type. \n\nfail-match/nil\t: fail-match match/nil E.\nfail-match/cons\t: fail-match (match/cons P OE M) E\n\t\t   <- fail-pat P E\n\t\t   <- fail-match M E.\n\n\napply-or-fail-match\t: match -> exp -> type. \n\napply-or-fail-match/apply\t: apply-or-fail-match M E\n\t\t\t\t   <- apply-match M E E'. \napply-or-fail-match/fail\t: apply-or-fail-match M E\n\t\t\t\t   <- fail-match M E.\n\n\n\nexception\t: type. \nexception/match\t: exception. \n\n\n\nvalue\t: exp -> type.\n\nvalue/unit\t: value exp/unit. \nvalue/lam\t: value (exp/lam M).\nvalue/pair\t: value (exp/pair E1 E2)\n\t\t   <- value E1\n\t\t   <- value E2.\nvalue/inl\t: value (exp/inl E)\n\t\t   <- value E.\nvalue/inr\t: value (exp/inr E)\n\t\t   <- value E.\n\n\n\nraises\t: exp -> exception -> type. \n\nraises/app-1\t: raises (exp/app E1 E2) X\n\t\t   <- raises E1 X.\nraises/app-2\t: raises (exp/app E1 E2) X\n\t\t   <- value E1\n\t\t   <- raises E2 X.\nraises/app-fail\t: raises (exp/app (exp/lam M) E2) exception/match\n\t\t   <- value E2\n\t\t   <- fail-match M E2.\nraises/pair-1\t: raises (exp/pair E1 E2) X\n\t\t   <- raises E1 X.\nraises/pair-2\t: raises (exp/pair E1 E2) X\n\t\t   <- value E1\n\t\t   <- raises E2 X. \nraises/inl\t: raises (exp/inl E) X\n\t\t   <- raises E X. \nraises/inr\t: raises (exp/inr E) X\n\t\t   <- raises E X.\n\n\n\nstep\t: exp -> exp -> type. \n\nstep/app-1\t\t: step (exp/app E1 E2) (exp/app E1' E2)\n\t\t\t   <- step E1 E1'.\nstep/app-2\t\t: step (exp/app E1 E2) (exp/app E1 E2')\n\t\t\t   <- value E1\n\t\t\t   <- step E2 E2'.\nstep/app-beta\t\t: step (exp/app (exp/lam M) E) E'\n\t\t\t   <- value E2\n\t\t\t   <- apply-match M E E'.\nstep/pair-1\t\t: step (exp/pair E1 E2) (exp/pair E1' E2)\n\t\t\t   <- step E1 E1'.\nstep/pair-2\t\t: step (exp/pair E1 E2) (exp/pair E1 E2')\n\t\t\t   <- value E1\n\t\t\t   <- step E2 E2'.\nstep/inl\t\t: step (exp/inl E) (exp/inl E')\n\t\t\t   <- step E E'.\nstep/inr\t\t: step (exp/inr E) (exp/inr E')\n\t\t\t   <- step E E'.\nstep/handle\t\t: step (exp/handle E1 E2) (exp/handle E1' E2)\n\t\t\t   <- step E1 E1'.\nstep/handle-beta\t: step (exp/handle E1 E2) E1\n\t\t\t   <- value E1.\nstep/handle-fail\t: step (exp/handle E1 E2) E2\n\t\t\t   <- raises E1 X.\n\n\n\nnotstuck\t: exp -> type. \n\nnotstuck/value\t: notstuck E\n\t\t   <- value E.\nnotstuck/raises\t: notstuck E\n\t\t   <- raises E X.\nnotstuck/step\t: notstuck E\n\t\t   <- step E E'.\n\n\n\ncan-explist-append\t: {EL1 : explist N1}\n\t\t\t   {EL2 : explist N2}\n\t\t\t   explist-append EL1 EL2 EL3\n\t\t\t   -> type. \n%mode can-explist-append +D1 +D2 -D3.\n\n-\t: can-explist-append _ _ explist-append/z.\n\n-\t: can-explist-append (explist/s E EL) EL' (explist-append/s D1)\n\t   <- can-explist-append EL EL' D1. \n\n%worlds () (can-explist-append _ _ _).\n%total (D1) (can-explist-append D1 _ _). \n\n\n\ncan-explist-get\t: {EL : explist N'}\n\t\t   tplist-get N (TL : tplist N') T\n\t\t   -> explist-get N EL E\n\t\t   -> type.\n%mode can-explist-get +D1 +D2 -D3.\n\n-\t: can-explist-get _ tplist-get/hit \n\t   explist-get/hit.\n\n-\t: can-explist-get _ (tplist-get/miss D2) \n\t   (explist-get/miss D')\n\t   <- can-explist-get _ D2 D'.\n\n%worlds () (can-explist-get _ _ _).\n%total (D2) (can-explist-get _ D2 _). \n\n\ncan-explist-map\t: {EL : explist N'}\n\t\t\t   tplist-map (TL : tplist N')\n\t\t\t   (M : map (N z)) (TL' : tplist N)\n\t\t\t   -> explist-map EL M (EL' : explist N)\n\t\t\t   -> type.\n%mode can-explist-map +D1 +D2 -D3.\n\n-\t: can-explist-map  _ tplist-map/z explist-map/z.\n\n-\t: can-explist-map D1 (tplist-map/s D2 D) (explist-map/s D3 D')\n\t   <- can-explist-get D1 D D'\n\t   <- can-explist-map D1 D2 D3.\n\n%worlds () (can-explist-map _ _ _).\n%total (D1) (can-explist-map _ D1 _). \n\n\n\nprogress-pat-pair\t: apply-or-fail-pat P1 E1\n\t\t\t   -> apply-or-fail-pat P2 E2\n\t\t\t   -> apply-or-fail-pat \n\t\t\t      (pat/pair P1 P2) (exp/pair E1 E2)\n\t\t\t   -> type.\n%mode progress-pat-pair +D1 +D2 -D3.\n\n-\t: progress-pat-pair (apply-or-fail-pat/fail DF) _\n\t   (apply-or-fail-pat/fail (fail-pat/pair-1 DF)).\n\n-\t: progress-pat-pair (apply-or-fail-pat/apply DA)\n\t   (apply-or-fail-pat/fail DF)\n\t   (apply-or-fail-pat/fail (fail-pat/pair-2 DF DA)).\n\n-\t: progress-pat-pair (apply-or-fail-pat/apply DA)\n\t   (apply-or-fail-pat/apply DA')\n\t   (apply-or-fail-pat/apply (apply-pat/pair  Dap DA' DA))\n\t   <- can-explist-append _ _ Dap.\n\n%worlds () (progress-pat-pair _ _ _). \n%total {} (progress-pat-pair _ _ _). \n\n\n\nprogress-pat-as\t: apply-or-fail-pat P1 E\n\t\t\t   -> apply-or-fail-pat P2 E\n\t\t\t   -> apply-or-fail-pat \n\t\t\t      (pat/as P1 P2) E\n\t\t\t   -> type.\n%mode progress-pat-as +D1 +D2 -D3.\n\n-\t: progress-pat-as (apply-or-fail-pat/fail DF) _\n\t   (apply-or-fail-pat/fail (fail-pat/as-1 DF)).\n\n-\t: progress-pat-as (apply-or-fail-pat/apply DA)\n\t   (apply-or-fail-pat/fail DF)\n\t   (apply-or-fail-pat/fail (fail-pat/as-2 DF DA)).\n\n-\t: progress-pat-as (apply-or-fail-pat/apply DA)\n\t   (apply-or-fail-pat/apply DA')\n\t   (apply-or-fail-pat/apply (apply-pat/as  Dap DA' DA))\n\t   <- can-explist-append _ _ Dap.\n\n%worlds () (progress-pat-as _ _ _). \n%total {} (progress-pat-as _ _ _). \n\n\n\nprogress-pat-inl\t: apply-or-fail-pat P1 E1\n\t\t\t   -> apply-or-fail-pat \n\t\t\t      (pat/inl P1) (exp/inl E1)\n\t\t\t   -> type.\n%mode progress-pat-inl +D1 -D2.\n\n-\t: progress-pat-inl (apply-or-fail-pat/fail DF)\n\t   (apply-or-fail-pat/fail (fail-pat/inl-t DF)).\n\n-\t: progress-pat-inl (apply-or-fail-pat/apply DA)\n\t   (apply-or-fail-pat/apply (apply-pat/inl DA)).\n\n%worlds () (progress-pat-inl _ _). \n%total {} (progress-pat-inl _ _). \n\n\n\nprogress-pat-inr\t: apply-or-fail-pat P1 E1\n\t\t\t   -> apply-or-fail-pat \n\t\t\t      (pat/inr P1) (exp/inr E1)\n\t\t\t   -> type.\n%mode progress-pat-inr +D1 -D2.\n\n-\t: progress-pat-inr (apply-or-fail-pat/fail DF)\n\t   (apply-or-fail-pat/fail (fail-pat/inr-t DF)).\n\n-\t: progress-pat-inr (apply-or-fail-pat/apply DA)\n\t   (apply-or-fail-pat/apply (apply-pat/inr DA)).\n\n%worlds () (progress-pat-inr _ _). \n%total {} (progress-pat-inr _ _). \n\n\n\nprogress-pat-or\t: tplist-map (TL  : tplist N) M (TL' : tplist N)\n\t\t   -> apply-or-fail-pat (P1 : pat N) E\n\t\t   -> apply-or-fail-pat P2 E\n\t\t   -> apply-or-fail-pat \n\t\t      (pat/or P1 M P2) E\n\t\t   -> type.\n%mode progress-pat-or +D1 +D2 +D3 -D4.\n\n-\t: progress-pat-or _\n\t   (apply-or-fail-pat/fail DF1)\n\t   (apply-or-fail-pat/fail DF2)\n\t   (apply-or-fail-pat/fail (fail-pat/or DF2 DF1)).\n\n-\t: progress-pat-or _\n\t   (apply-or-fail-pat/apply DA1)\n\t   _\n\t   (apply-or-fail-pat/apply (apply-pat/or-1 DA1)).\n\n-\t: progress-pat-or DM\n\t   (apply-or-fail-pat/fail DF1)\n\t   (apply-or-fail-pat/apply DA2)\n\t   (apply-or-fail-pat/apply (apply-pat/or-2 DMap DA2 DF1))\n\t   <- can-explist-map _ DM DMap.\n\n%worlds () (progress-pat-or _ _ _ _).\n%total {} (progress-pat-or _ _ _ _).\n\n\n\nprogress-pat\t: value E\n\t\t   -> of-exp E T\n\t\t   -> of-pat P T TL\n\t\t   -> apply-or-fail-pat P E\n\t\t   -> type. \n%mode progress-pat +D1 +D2 +D3 -D4.\n\n-\t: progress-pat _ D1 of-pat/underscore \n\t   (apply-or-fail-pat/apply apply-pat/underscore).\n\n-\t: progress-pat _ D1 of-pat/var\n\t   (apply-or-fail-pat/apply apply-pat/var).\n\n-\t: progress-pat (value/pair DV2 DV1) \n\t   (of-exp/pair D2 D1) (of-pat/pair _ D2' D1') DAF3\n\t   <- progress-pat DV1 D1 D1' DAF1\n\t   <- progress-pat DV2 D2 D2' DAF2\n\t   <- progress-pat-pair DAF1 DAF2 DAF3.\n\n-\t: progress-pat DV\n\t   D1 (of-pat/as _ D2' D1') DAF3\n\t   <- progress-pat DV D1 D1' DAF1\n\t   <- progress-pat DV D1 D2' DAF2\n\t   <- progress-pat-as DAF1 DAF2 DAF3.\n\n-\t: progress-pat (value/inl DV1) \n\t   (of-exp/inl D1) (of-pat/inl D1') DAF2\n\t   <- progress-pat DV1 D1 D1' DAF1\n\t   <- progress-pat-inl DAF1 DAF2.\n\n-\t: progress-pat (value/inr DV1) \n\t   (of-exp/inr D1) (of-pat/inr D1') DAF2\n\t   <- progress-pat DV1 D1 D1' DAF1\n\t   <- progress-pat-inr DAF1 DAF2.\n\n-\t: progress-pat (value/inr DV1) \n\t   (of-exp/inr D1) (of-pat/inl D1')\n\t   (apply-or-fail-pat/fail fail-pat/inl-f).\n\n-\t: progress-pat (value/inl DV1) \n\t   (of-exp/inl D1) (of-pat/inr D1')\n\t   (apply-or-fail-pat/fail fail-pat/inr-f).\n\n-\t: progress-pat DV D1\n\t   (of-pat/or DM D2' D1')\n\t   DAF3\n\t   <- progress-pat DV D1 D1' \n\t      (DAF1 : apply-or-fail-pat X4 X1)\n\t   <- progress-pat DV D1 D2' \n\t      (DAF2 : apply-or-fail-pat X6 X1)\n\t   <- progress-pat-or DM DAF1 DAF2 DAF3.\n\n%worlds () (progress-pat _ _ _ _).\n%total (D1) (progress-pat _ _ D1 _). \n\n\n\ncan-subst-oexp\t: {EL : explist N}\n\t\t   {OE : oexp (N z)}\n\t\t   subst-oexp EL OE E\n\t\t   -> type. \n%mode can-subst-oexp +D1 +D2 -D3.\n\n-\t: can-subst-oexp _ _ subst-oexp/z.\n\n-\t: can-subst-oexp (explist/s E EL) _ (subst-oexp/s D1)\n\t   <- can-subst-oexp EL _ D1. \n\n%worlds () (can-subst-oexp _ _ _).\n%total (D1) (can-subst-oexp D1 _ _).\n\n\n\nprogress-match-cons\t: {OE}\n\t\t\t   apply-or-fail-pat P E\n\t\t\t   -> apply-or-fail-match M E\n\t\t\t   -> apply-or-fail-match (match/cons P OE M) E\n\t\t\t   -> type.\n%mode progress-match-cons +D1 +D2 +D3 -D4.\n\n-\t: progress-match-cons _\n\t   (apply-or-fail-pat/fail DF)\n\t   (apply-or-fail-match/fail DF')\n\t   (apply-or-fail-match/fail (fail-match/cons DF' DF)).\n\n-\t: progress-match-cons _\n\t   (apply-or-fail-pat/fail DF)\n\t   (apply-or-fail-match/apply DA)\n\t   (apply-or-fail-match/apply (apply-match/cons-2 DA DF)).\n\n\n-\t: progress-match-cons _\n\t   (apply-or-fail-pat/apply DA) _\n\t   (apply-or-fail-match/apply (apply-match/cons-1 DS DA))\n\t   <- can-subst-oexp _ _ DS.\n\n%worlds () (progress-match-cons _ _ _ _).\n%total {} (progress-match-cons _ _ _ _).\n\n\n\nprogress-match\t: value E\n\t\t   -> of-exp E T\n\t\t   -> of-match M T T'\n\t\t   -> apply-or-fail-match M E\n\t\t   -> type.\n%mode progress-match +D1 +D2 +D3 -D4.\n\n-\t: progress-match _ _ of-match/nil \n\t   (apply-or-fail-match/fail fail-match/nil).\n\n-\t: progress-match DV DE (of-match/cons D2 _ D1) DAF3\n\t   <- progress-pat DV DE D1 DAF1\n\t   <- progress-match DV DE D2 DAF2\n\t   <- progress-match-cons _ DAF1 DAF2 DAF3.\n\n%worlds () (progress-match _ _ _ _).\n%total (D1) (progress-match _ _ D1 _).\n\n\n\nprogress-app-beta\t: value E\n\t\t\t   -> apply-or-fail-match M E\n\t\t\t   -> notstuck (exp/app (exp/lam M) E)\n\t\t\t   -> type.\n%mode progress-app-beta +D1 +D2 -D3.\n\n-\t: progress-app-beta DV (apply-or-fail-match/fail DF)\n\t   (notstuck/raises (raises/app-fail DF DV)).\n\n-\t: progress-app-beta DV (apply-or-fail-match/apply DA)\n\t   (notstuck/step (step/app-beta DA DV)).\n\n%worlds () (progress-app-beta _ _ _).\n%total {} (progress-app-beta _ _ _).\n\n\n\nprogress-app\t: of-exp E1 (arrow T1 T2)\n\t\t   -> of-exp E2 T1\n\t\t   -> notstuck E1\n\t\t   -> notstuck E2\n\t\t   -> notstuck (exp/app E1 E2)\n\t\t   -> type. \n%mode progress-app +D1 +D2 +D3 +D4 -D5.\n\n-\t: progress-app _ _ (notstuck/step DS) _\n\t   (notstuck/step (step/app-1 DS)).\n\n-\t: progress-app _ _ (notstuck/value V) (notstuck/step DS)\n\t   (notstuck/step (step/app-2 DS V)).\n\n-\t: progress-app _ _ (notstuck/raises DS) _\n\t   (notstuck/raises (raises/app-1 DS)).\n\n-\t: progress-app _ _  (notstuck/value V) (notstuck/raises DS)\n\t   (notstuck/raises (raises/app-2 DS V)).\n\n-\t: progress-app (of-exp/lam DM) D2 (notstuck/value value/lam)\n\t   (notstuck/value DV) NS\n\t   <- progress-match DV D2 DM DAF\n\t   <- progress-app-beta DV DAF NS.\n\n%worlds () (progress-app _ _ _ _ _).\n%total {} (progress-app _ _ _ _ _).\n\n\n\nprogress-pair\t: notstuck E1\n\t\t   -> notstuck E2\n\t\t   -> notstuck (exp/pair E1 E2)\n\t\t   -> type. \n%mode progress-pair +D1 +D2 -D3.\n\n-\t: progress-pair (notstuck/step DS) _\n\t   (notstuck/step (step/pair-1 DS)).\n\n-\t: progress-pair (notstuck/value V) (notstuck/step DS)\n\t   (notstuck/step (step/pair-2 DS V)).\n\n-\t: progress-pair (notstuck/raises DS) _\n\t   (notstuck/raises (raises/pair-1 DS)).\n\n-\t: progress-pair  (notstuck/value V) (notstuck/raises DS)\n\t   (notstuck/raises (raises/pair-2 DS V)).\n\n-\t: progress-pair (notstuck/value DV1)\n\t   (notstuck/value DV2) (notstuck/value (value/pair DV2 DV1)).\n\n%worlds () (progress-pair _ _ _).\n%total {} (progress-pair _ _ _).\n\n\n\nprogress-inl\t: notstuck E1\n\t\t   -> notstuck (exp/inl E1)\n\t\t   -> type. \n%mode progress-inl +D1 -D2.\n\n-\t: progress-inl (notstuck/step DS)\n\t   (notstuck/step (step/inl DS)).\n\n-\t: progress-inl (notstuck/raises DS)\n\t   (notstuck/raises (raises/inl DS)).\n\n-\t: progress-inl (notstuck/value DV1)\n\t   (notstuck/value (value/inl DV1)).\n\n%worlds () (progress-inl _ _).\n%total {} (progress-inl _ _).\n\n\n\nprogress-inr\t: notstuck E1\n\t\t   -> notstuck (exp/inr E1)\n\t\t   -> type. \n%mode progress-inr +D1 -D2.\n\n-\t: progress-inr (notstuck/step DS)\n\t   (notstuck/step (step/inr DS)).\n\n-\t: progress-inr (notstuck/raises DS)\n\t   (notstuck/raises (raises/inr DS)).\n\n-\t: progress-inr (notstuck/value DV1)\n\t   (notstuck/value (value/inr DV1)).\n\n%worlds () (progress-inr _ _).\n%total {} (progress-inr _ _).\n\n\n\nprogress-handle\t: {E2}notstuck E1\n\t\t   -> notstuck (exp/handle E1 E2)\n\t\t   -> type. \n%mode progress-handle +E +D1 -D2.\n\n-\t: progress-handle _ (notstuck/step DS)\n\t   (notstuck/step (step/handle DS)).\n\n-\t: progress-handle _ (notstuck/raises DR)\n\t   (notstuck/step (step/handle-fail DR)).\n\n-\t: progress-handle _ (notstuck/value DV1)\n\t   (notstuck/step (step/handle-beta DV1)).\n\n%worlds () (progress-handle _ _ _).\n%total {} (progress-handle _ _ _).\n\n\n\nprogress\t: of-exp E T\n\t\t   -> notstuck E\n\t\t   -> type.\n%mode progress +D1 -D2.\n\n-\t: progress of-exp/unit (notstuck/value value/unit).\n\n-\t: progress (of-exp/lam _) (notstuck/value value/lam).\n\n-\t: progress (of-exp/app D2 D1) NS3\n\t   <- progress D1 NS1\n\t   <- progress D2 NS2\n\t   <- progress-app D1 D2 NS1 NS2 NS3.\n\n-\t: progress (of-exp/pair D2 D1) NS3\n\t   <- progress D1 NS1\n\t   <- progress D2 NS2\n\t   <- progress-pair NS1 NS2 NS3.\n\n-\t: progress (of-exp/inl D1) NS2\n\t   <- progress D1 NS1\n\t   <- progress-inl NS1 NS2.\n\n-\t: progress (of-exp/inr D1) NS2\n\t   <- progress D1 NS1\n\t   <- progress-inr NS1 NS2.\n\n-\t: progress (of-exp/handle D2 D1) NS2\n\t   <- progress D1 NS1\n\t   <- progress-handle _ NS1 NS2.\n\n%worlds () (progress _ _).\n%total (D1) (progress D1 _).\n\n\n\npreservation-subst-oexp\t: of-explist EL TL\n\t\t\t   -> of-oexp TL OE T\n\t\t\t   -> subst-oexp EL OE E\n\t\t\t   -> of-exp E T\n\t\t\t   -> type.\n%mode preservation-subst-oexp +D1 +D2 +D3 -D4.\n\n-\t: preservation-subst-oexp _ (of-oexp/z D1) subst-oexp/z D1.\n\n-\t: preservation-subst-oexp (of-explist/s D1 D) (of-oexp/s D2)\n\t   (subst-oexp/s D3) D4\n\t   <- preservation-subst-oexp D1 (D2 _ D) D3 D4.\n\n%worlds () (preservation-subst-oexp _ _ _ _).\n%total (D1) (preservation-subst-oexp _ _ D1 _).\n\n\n\npreservation-append\t: of-explist EL1 TL1\n\t\t\t   -> of-explist EL2 TL2\n\t\t\t   -> explist-append EL1 EL2 EL3\n\t\t\t   -> tplist-append TL1 TL2 TL3\n\t\t\t   -> of-explist EL3 TL3\n\t\t\t   -> type. \n%mode preservation-append +D1 +D2 +D3 +D4 -D5.\n\n-\t: preservation-append _ D explist-append/z tplist-append/z D.\n\n-\t: preservation-append (of-explist/s D1 D) D2 (explist-append/s D3)\n\t   (tplist-append/s D4) (of-explist/s D5 D)\n\t   <- preservation-append D1 D2 D3 D4 D5.\n\n%worlds () (preservation-append _ _ _ _ _).\n%total (D1) (preservation-append _ _ _ D1 _).\n\n\n\npreservation-get\t: of-explist EL TL\n\t\t\t   -> explist-get M EL E\n\t\t\t   -> tplist-get M TL T\n\t\t\t   -> of-exp E T\n\t\t\t   -> type.\n%mode preservation-get +D1 +D2 +D3 -D4.\n\n-\t: preservation-get (of-explist/s _ D) explist-get/hit tplist-get/hit D.\n\n-\t: preservation-get (of-explist/s DL _) (explist-get/miss D') \n\t   (tplist-get/miss D'') D\n\t   <- preservation-get DL D' D'' D.\n\n%worlds () (preservation-get _ _ _ _).\n%total (D1) (preservation-get _ _ D1 _).\n\n\n\npreservation-map\t: of-explist EL TL\n\t\t\t   -> explist-map EL M EL'\n\t\t\t   -> tplist-map TL M TL'\n\t\t\t   -> of-explist EL' TL'\n\t\t\t   -> type.\n%mode preservation-map +D1 +D2 +D3 -D4.\n\n-\t: preservation-map DL explist-map/z tplist-map/z \n\t   of-explist/z.\n\n-\t: preservation-map DL (explist-map/s DEM DEG) \n\t   (tplist-map/s DTM DTG)\n\t   (of-explist/s DL' D1')\n\t   <- preservation-get DL DEG DTG D1'\n\t   <- preservation-map DL DEM DTM DL'.\n\n%worlds () (preservation-map _ _ _ _).\n%total (D1) (preservation-map _ _ D1 _).\n\n\n\npreservation-apply-pat\t: of-exp E T\n\t\t\t   -> of-pat P T TL\n\t\t\t   -> apply-pat P E EL\n\t\t\t   -> of-explist EL TL\n\t\t\t   -> type.\n%mode preservation-apply-pat +D1 +D2 +D3 -D4.\n\n-\t: preservation-apply-pat D1 of-pat/underscore apply-pat/underscore\n\t   of-explist/z.\n\n-\t: preservation-apply-pat (of-exp/pair DE2 DE1) \n\t   (of-pat/pair DTA DP2 DP1)\n\t   (apply-pat/pair DEA DA2 DA1) D3\n\t   <- preservation-apply-pat DE1 DP1 DA1 D1\n\t   <- preservation-apply-pat DE2 DP2 DA2 D2\n\t   <- preservation-append D1 D2 DEA DTA D3.\n\n-\t: preservation-apply-pat DE\n\t   (of-pat/as DTA DP2 DP1)\n\t   (apply-pat/as DEA DA2 DA1) D3\n\t   <- preservation-apply-pat DE DP1 DA1 D1\n\t   <- preservation-apply-pat DE DP2 DA2 D2\n\t   <- preservation-append D1 D2 DEA DTA D3.\n\n-\t: preservation-apply-pat (of-exp/inl DE) (of-pat/inl DP)\n\t   (apply-pat/inl DA) D\n\t   <- preservation-apply-pat DE DP DA D.\n\n-\t: preservation-apply-pat (of-exp/inr DE) (of-pat/inr DP)\n\t   (apply-pat/inr DA) D\n\t   <- preservation-apply-pat DE DP DA D.\n\n-\t: preservation-apply-pat D1 of-pat/var apply-pat/var\n\t   (of-explist/s of-explist/z D1).\n\n-\t: preservation-apply-pat DE (of-pat/or _ _ DP)\n\t   (apply-pat/or-1 DA) D\n\t   <- preservation-apply-pat DE DP DA D.\n\n-\t: preservation-apply-pat DE (of-pat/or DTM DP _)\n\t   (apply-pat/or-2 DEM DA _) D'\n\t   <- preservation-apply-pat DE DP DA D\n\t   <- preservation-map D DEM DTM D'.\n\n%worlds () (preservation-apply-pat _ _ _ _).\n%total (D1) (preservation-apply-pat _ _ D1 _).\n\n\n\npreservation-apply-match\t: of-exp E T\n\t\t\t\t   -> of-match M T T'\n\t\t\t\t   -> apply-match M E E'\n\t\t\t\t   -> of-exp E' T'\n\t\t\t\t   -> type.\n%mode preservation-apply-match +D1 +D2 +D3 -D4.\n\n-\t: preservation-apply-match D1 (of-match/cons _ DOE D2)\n\t   (apply-match/cons-1 DS DA) D'\n\t   <- preservation-apply-pat D1 D2 DA D\n\t   <- preservation-subst-oexp D DOE DS D'.\n\n-\t: preservation-apply-match D1 (of-match/cons D2 _ _)\n\t   (apply-match/cons-2 DA _) D'\n\t   <- preservation-apply-match D1 D2 DA D'.\n\n%worlds () (preservation-apply-match _ _ _ _).\n%total (D1) (preservation-apply-match _ _ D1 _).\n\n\n\npreservation\t: of-exp E T\n\t\t   -> step E E'\n\t\t   -> of-exp E' T\n\t\t   -> type.\n%mode preservation +D1 +D2 -D3.\n\n-\t: preservation (of-exp/app D2 D1) (step/app-1 DS)\n\t   (of-exp/app D2 D1')\n\t   <- preservation D1 DS D1'.\n\n-\t: preservation (of-exp/app D2 D1) (step/app-2 DS V)\n\t   (of-exp/app D2' D1)\n\t   <- preservation D2 DS D2'.\n\n-\t: preservation (of-exp/app D2 (of-exp/lam D1)) (step/app-beta DA _) D\n\t   <- preservation-apply-match D2 D1 DA D.\n\n-\t: preservation (of-exp/pair D2 D1) (step/pair-1 DS)\n\t   (of-exp/pair D2 D1')\n\t   <- preservation D1 DS D1'.\n\n-\t: preservation (of-exp/pair D2 D1) (step/pair-2 DS V)\n\t   (of-exp/pair D2' D1)\n\t   <- preservation D2 DS D2'.\n\n-\t: preservation (of-exp/handle D2 D1) (step/handle DS)\n\t   (of-exp/handle D2 D1')\n\t   <- preservation D1 DS D1'.\n\n-\t: preservation (of-exp/inl D1) (step/inl DS)\n\t   (of-exp/inl D1')\n\t   <- preservation D1 DS D1'.\n\n-\t: preservation (of-exp/inr D1) (step/inr DS)\n\t   (of-exp/inr D1')\n\t   <- preservation D1 DS D1'.\n\n-\t: preservation (of-exp/handle D2 D1) (step/handle DS)\n\t   (of-exp/handle D2 D1')\n\t   <- preservation D1 DS D1'.\n\n-\t: preservation (of-exp/handle D2 D1) (step/handle-beta _) D1.\n\n-\t: preservation (of-exp/handle D2 D1) (step/handle-fail _) D2.\n\n%worlds () (preservation _ _ _).\n%total (D1) (preservation _ D1 _).\n%{\n--[[User:DanielKLee|DanielKLee]] 01:46, 11 October 2007 (EDT)\n\nTODO: Finish commentary.\n{{stub}}\n}%"
          },
          "sha1": "3m18mw7wdqh5zy3dcprm0rkfs7m1ybl"
        }
      },
      {
        "title": "Polarized PCF",
        "ns": 0,
        "id": 2113,
        "revision": {
          "id": 5534,
          "parentid": 5533,
          "timestamp": "2008-11-20T20:21:26Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "minor": null,
          "comment": "[[Polarized PCF Better]] moved to [[Polarized PCF]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 10347,
            "#text": "%{ \n\nPolarized PCF with a stack machine semantics \n\n# Interalizes the composition/leftist substitution principles (left-commutative cuts), so there are no meta-ops in evaluation other than LF substitution\n# force+ binds a positive value variable, rather than requiring an immediate left inversion\n# Proves completeness of focusing, so you can see what direct-style terms mean\n# Does purely negative stream using (non-canonical) negative continuation variables; completeness of focusing does some sort of CPS conversion\n\n}%\n\n%{ == Syntax == }%\n\npos : type.\nneg : type.\n\ndown : neg -> pos.\nnat  : pos.\n\nup  : pos -> neg.\narr : pos -> neg -> neg.\nstream : neg -> neg.\n\nval+  : pos -> type.\ncont+ : pos -> pos -> type.\nval-  : neg -> type.\ncont- : neg -> pos -> type.\nexp   : pos -> type.\n\n%% positive values\nzero   : val+ nat.\nsucc   : val+ nat -> val+ nat.\ndelay- : val- A- -> val+ (down A-).\n\n%% positive conts\nifz      : exp A+ -> (val+ nat -> exp A+) -> cont+ nat A+.\nforce-   : (val- A- -> exp C+) -> cont+ (down A-) C+.\n%% internalize composition\ncomp+    : cont+ A+ B+ -> (val+ B+ -> exp C+) -> cont+ A+ C+.\n\n%% negative values\nlam    : (val+ A+ -> val- B-) -> val- (arr A+ B-).\ndelay+ : exp A+ -> val- (up A+).\nfix    : (val- A- -> val- A-) -> val- A-.\ncons   : ({C+} cont- A- C+ -> exp C+) \n\t  -> ({C+} cont- (stream A-) C+ -> exp C+)\n\t  -> val- (stream A-).\n\n%% negative conts\napp    : val+ A+ -> cont- B- C+ -> cont- (arr A+ B-) C+.\nforce+ : (val+ A+ -> exp C+) -> cont- (up A+) C+.\n%% internalize composition\ncomp-  : cont- A- B+ -> (val+ B+ -> exp C+) -> cont- A- C+.\nhead   : cont- A- C+ -> cont- (stream A-) C+ .\ntail   : cont- (stream A-) A+ -> cont- (stream A-) A+.\n\n%% expressions\nret : val+ A+ -> exp A+.\n%% internalize arbitrary cuts.\n%% these two are canonical when the value is a variable,\n%% but if we'ere only running closed terms, then that\n%% distinction is moot.  \ncut+ : val+ A+ -> cont+ A+ C+ -> exp C+. \ncut- : val- A- -> cont- A- C+ -> exp C+.\n%% internalize composition\nlet  : exp A+ -> (val+ A+ -> exp C+) -> exp C+.\n\n%% these terms are not eta-long, because we use the same\n%% val judgements on the left as on the right\n%block posb : some {A+ : pos} block {x : val+ A+}. \n%block negb : some {A- : neg} block {x : val- A-}.\n%block negcb : some {A- : neg} block {A+ : pos} {k : cont- A- A+}.\n%worlds (posb | negb | negcb) (val+ _) (cont+ _ _) (val- _) (cont- _ _) (exp _).\n\n%% FIXME: weirldly asymetric: we need both pos and neg assumptions,\n%% but not both kinds of conclusion??\n\n%{ \n\n=== Step === \n\nNote that all rules are axioms.\n\n}%\n\nstep : exp A+ -> exp A+ -> type.\n%mode step +X1 -X2.\n\nstep/ifz-0 : step (cut+ zero (ifz E0 E1)) E0. \nstep/ifz-1 : step (cut+ (succ V) (ifz E0 E1)) (E1 V). \nstep/force- : step (cut+ (delay- V-) (force- E)) (E V-).\nstep/fix    : step (cut- (fix E) K-) (cut- (E (fix E)) K-).\nstep/app    : step (cut- (lam V-) (app V+ K-)) (cut- (V- V+) K-).\nstep/force+ : step (cut- (delay+ E1) (force+ E)) (let E1 E).\nstep/head   : step (cut- (cons E1 E2) (head K-)) (E1 _ K-).\nstep/tail   : step (cut- (cons E1 E2) (tail K-)) (E2 _ K-).\n%% left commutative cuts:\nstep/letret  : step (let (ret V+) E2) (E2 V+).\nstep/letcut+ : step (let (cut+ V+ K+) E2) (cut+ V+ (comp+ K+ E2)).\nstep/letcut- : step (let (cut- V- K-) E2) (cut- V- (comp- K- E2)).\nstep/letlet  : step (let (let E1 E2) E3) (let E1 ([x] (let (E2 x) E3))).\nstep/cconv-ifz    : step (cut+ V+ (comp+ (ifz E0 E1) E))\n\t\t     (cut+ V+ (ifz (let E0 E) ([y] let (E1 y) E))). \nstep/cconv-force- : step (cut+ V+ (comp+ (force- E1) E))\n\t\t     (cut+ V+ (force- [y] (let (E1 y) E))).\nstep/cconv-comp+  : step (cut+ V+ (comp+ (comp+ E1 E2) E))\n\t\t     (cut+ V+ (comp+ E1 ([y] (let (E2 y) E)))).\nstep/cconv-app    : step (cut- V- (comp- (app V+ K-) E))\n\t\t     (cut- V- (app V+ (comp- K- E))).\nstep/cconv-force+ : step (cut- V- (comp- (force+ E1) E))\n\t\t     (cut- V- (force+ ([y] (let (E1 y) E)))).\nstep/cconv-comp- : step (cut- V- (comp- (comp- K- E1) E2))\n\t  \t     (cut- V- (comp- K- ([y] (let (E1 y) E2)))).\nstep/cconv-head  : step (cut- V- (comp- (head K-) E))\n\t\t    (cut- V- (head (comp- K- E))).\nstep/cconv-tail  : step (cut- V- (comp- (tail K-) E))\n\t\t    (cut- V- (tail (comp- K- E))).\n\n%worlds () (step _ _).\n\n%{\n\n== Progress ==\n\n}%\n\nok : exp A+ -> type.\nok/final : ok (ret V+).\nok/step  : ok E\n\t    <- step E E'.\n\nprogress : {E : exp A+} ok E -> type.\n%mode progress +E -O.\n\n- : progress _ ok/final.\n- : progress _ (ok/step step/ifz-0).\n- : progress _ (ok/step step/ifz-1).\n- : progress _ (ok/step step/force-).\n- : progress _ (ok/step step/fix).\n- : progress _ (ok/step step/app).\n- : progress _ (ok/step (step/force+)).\n- : progress _ (ok/step step/head).\n- : progress _ (ok/step step/tail).\n- : progress _ (ok/step step/letret).\n- : progress _ (ok/step step/letcut+).\n- : progress _ (ok/step step/letcut-).\n- : progress _ (ok/step step/letlet).\n- : progress _ (ok/step step/cconv-ifz).\n- : progress _ (ok/step step/cconv-force-).\n- : progress _ (ok/step step/cconv-comp+).\n- : progress _ (ok/step step/cconv-app).\n- : progress _ (ok/step step/cconv-force+).\n- : progress _ (ok/step step/cconv-head).\n- : progress _ (ok/step step/cconv-tail).\n- : progress _ (ok/step step/cconv-comp-).\n\n%worlds () (progress _ _).\n%total {} (progress _ _).\n\n\n%{ == EL == }%\n\n%{ === Syntax === }%\n\netp : type.\t\t\t\t%name etp T.\nenat : etp.\nearr : etp -> etp -> etp.\nestream : etp -> etp.\n\neexp : etp -> type.\t\t\t%name eexp E.  %postfix 1 eexp.\nez : enat eexp.\nes : enat eexp -> enat eexp.\neifz : enat eexp -> T eexp -> (enat eexp -> T eexp) -> T eexp.\nefun : {T1:etp} {T2:etp} ((earr T1 T2) eexp -> T1 eexp -> T2 eexp) -> (earr T1 T2) eexp.\neapp : (earr T1 T2) eexp -> T1 eexp -> T2 eexp.\necons : T eexp -> (estream T) eexp -> (estream T) eexp.\nestreamfix : ((estream T) eexp -> (estream T) eexp) -> (estream T) eexp.\nehead : (estream T) eexp -> T eexp.\netail : (estream T) eexp -> (estream T) eexp.\n\n%{ === Completeness of focusing === }%\n\npoltp : etp -> pos -> type.\n%mode poltp +X1 -X2.\n\npoltp/nat : poltp enat nat.\npoltp/arr : poltp (earr T1 T2) (down (arr A1 (up A2)))\n\t     <- poltp T1 A1\n\t     <- poltp T2 A2.\npoltp/stream : poltp (estream T) (down (stream (up A)))\n\t\t<- poltp T A.\n\n%worlds () (poltp _ _).\n%total T (poltp T _).\n%unique poltp +T -1A.\n\ncan-poltp : {T} poltp T A -> type.\n%mode can-poltp +X1 -X3.\n%worlds () (can-poltp _ _).\n% not really a trustme: Twelf proved this totality above!\n%trustme %total {} (can-poltp _ _).\n\nid : pos -> pos -> type.\nrefl : id A A.\n\nunique-poltp : poltp T A' -> poltp T A -> id A A' -> type.\n%mode unique-poltp +X1 +X2 -X3.\n%worlds () (unique-poltp _ _ _).\n% not really a trustme: Twelf proved this totality above!\n%trustme %total {} (unique-poltp _ _ _).\n\nretype : exp A -> id A A' -> exp A' -> type.\n%mode retype +X1 +X2 -X3.\n- : retype D refl D.\n%worlds (posb | negb) (retype _ _ _).\n%total {} (retype _ _ _).\n\ncomplete : poltp T A -> T eexp -> exp A -> type.\n%mode complete +X1 +X2 -X3.\n\ncomplete/z : complete poltp/nat ez (ret zero).\ncomplete/s : complete poltp/nat (es E) (let E' ([x] (ret (succ x))))\n\t      <- complete poltp/nat E E'.\ncomplete/ifz : complete (Dpol : poltp T A) (eifz E E0 E1)\n\t\t(let E' ([x] cut+ x (ifz E0' E1')))\n\t\t<- complete poltp/nat E E'\n\t\t<- complete Dpol E0 E0'\n\t\t<- ({x : enat eexp} \n\t\t      {x' : val+ nat}\n\t\t      {d : {A1' : pos} {D' : poltp enat A1'}\n\t\t\t    {Did : id nat A1'} {E : exp A1'}\n \t\t\t  complete D' x E\n\t\t\t    <- unique-poltp D' poltp/nat Did\n\t\t\t    <- retype (ret x') Did E}\n\t\t      complete Dpol (E1 x) (E1' x')).\n\ncomplete/fun : complete (poltp/arr (Dp2 : poltp T2 A2) (Dp1 : poltp T1 A1))\n\t\t(efun T1 T2 E) \n\t\t(ret (delay- (fix ([f'] (lam [x'] (delay+ (E' (delay- f') x')))))))\n\t\t<- {f : (earr T1 T2) eexp} {f' : val+ (down (arr A1 (up A2)))} \n\t\t   {d : {A1' : pos} {D' : poltp (earr T1 T2) A1'} \n\t\t\t {Did : id (down (arr A1 (up A2))) A1'} {E : exp A1'}\n \t\t\t  complete D' f E\n\t\t\t  <- unique-poltp D' (poltp/arr Dp2 Dp1) Did\n\t\t\t  <- retype (ret f') Did E}\n\t\t   {x : T1 eexp} {x' : val+ A1} \n\t\t   {d : {A1' : pos} {D' : poltp T1 A1'} \n\t\t\t {Did : id A1 A1'} {E : exp A1'}\n \t\t\t  complete D' x E\n\t\t\t <- unique-poltp D' Dp1 Did\n\t\t\t <- retype (ret x') Did E}\n\t\t   complete Dp2 (E f x) (E' f' x').\ncomplete/app : complete (D : poltp T A) (eapp (E1 : (earr T2 T) eexp) E2) \n\t\t(let E1'\n\t\t   ([f] \n\t\t      let E2'\n\t\t      ([x]\n\t\t\t (cut+ f \n\t\t\t      (force- [y] \n\t\t\t\t (cut- y (app x (force+ [z] (ret z)))))))))\n\t\t<- can-poltp T2 (Dp2 : poltp T2 A2)\n\t\t<- complete (poltp/arr D Dp2) E1 E1'\n\t\t<- complete Dp2 E2 E2'.\n\n%% cons is lazy in both components\ncomplete/cons : complete (poltp/stream Dp) (econs E1 E2) \n\t\t (ret (delay- (cons \n\t\t\t\t ([C+] [k] (let E1' [y] (cut- (delay+ (ret y)) k)))\n\t\t\t\t ([C+] [k] (let E2' [y] \n\t\t\t\t\t      (cut+ y (force- [w] \n\t\t\t\t\t\t\t (cut- w k))))))))\n\t\t <- complete Dp E1 E1'\n\t\t <- complete (poltp/stream Dp) E2 E2'.\ncomplete/head : complete D (ehead E) \n\t\t (let E' \n\t\t    ([x] \n\t\t       (cut+ x (force- [y] \n\t\t\t\t  (cut- y (head \n\t\t\t\t\t     %% this is like an identity cont.\n\t\t\t\t\t     (force+ ([z] ret z))))))))\n\t\t <- complete (poltp/stream D) E E'.\ncomplete/tail : complete (poltp/stream D) (etail E) \n\t\t (let E' \n\t\t    ([x] \n\t\t       (cut+ x (force- [y] \n\t\t\t\t  (ret (delay- \n\t\t\t\t\t  (cons \n\t\t\t\t\t     ([C] [hobs] \n\t\t\t\t\t\t(cut- y (tail (head hobs))))\n\t\t\t\t\t     ([C] [tobs]\n\t\t\t\t\t\t(cut- y (tail (tail tobs))))\n\t\t\t\t\t     )))))))\n\t\t <- complete (poltp/stream D) E E'.\ncomplete/streamfix : complete (poltp/stream D) (estreamfix E1) \n\t\t      (ret (delay- (fix [f] (cons \n\t\t\t\t\t       ([C] [hobs] \n\t\t\t\t\t\t  let (E1' (delay- f)) [r]\n\t\t\t\t\t\t  (cut+ r (force- [r'] \n\t\t\t\t\t\t\t     (cut- r' (head hobs)))))\n\t\t\t\t\t       ([C] [tobs] \n\t\t\t\t\t\t  let (E1' (delay- f)) [r]\n\t\t\t\t\t\t  (cut+ r (force- [r'] \n\t\t\t\t\t\t\t     (cut- r' (tail tobs)))))\n\t\t\t\t\t       ))))\n\t\t      <- {x : _ eexp} {x' : val+ _} \n\t\t\t {d : {A1' : pos} {D' : poltp _ A1'} \n\t\t\t       {Did : id _ A1'} {E : exp A1'}\n\t\t\t       complete D' x E\n\t\t\t       <- unique-poltp D' (poltp/stream D) Did\n\t\t\t       <- retype (ret x') Did E}\n\t\t\t complete (poltp/stream D) (E1 x) (E1' x').\n\n%block completeb : some {T1:etp} {A1:pos} {D : poltp T1 A1} \n\t\t    block \n\t\t    {x : T1 eexp} {x' : val+ A1} \n \t\t    {d : {A1' : pos} {D' : poltp T1 A1'}\n\t\t\t  {Did : id A1 A1'} {E : exp A1'}\n \t\t\t  complete D' x E\n\t\t\t  <- unique-poltp D' D Did\n\t\t\t  <- retype (ret x') Did E}.\n\n%worlds (completeb) (complete _ E _).\n%total (E) (complete _ E _)."
          },
          "sha1": "0qc646ndd81xaw71jfndanj10vc2g5o"
        }
      },
      {
        "title": "Polarized PCF Better",
        "ns": 0,
        "id": 2115,
        "redirect": {
          "@title": "Polarized PCF",
          "#text": null
        },
        "revision": {
          "id": 5535,
          "timestamp": "2008-11-20T20:21:26Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "comment": "[[Polarized PCF Better]] moved to [[Polarized PCF]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 27,
            "#text": "#REDIRECT [[Polarized PCF]]"
          },
          "sha1": "g6fmr35n2pp0ttdyj4yqxwuzopsjwkw"
        }
      },
      {
        "title": "Programming language theory with Twelf",
        "ns": 0,
        "id": 2049,
        "revision": {
          "id": 5412,
          "parentid": 5192,
          "timestamp": "2008-11-01T01:36:18Z",
          "contributor": {
            "username": "Twilson",
            "id": 15
          },
          "comment": "Reorganization, putting the two books PFPL and TAPL front and center",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 4597,
            "#text": "== Preface ==\n\nThe study of programming languages generally proceeds in two parallel directions.  In one direction,\nstudents are introduced to several specific programming languages representing different\n''programming paradigms'' (functional, object-oriented, logic programming, scripting, etc.) and are\nshown many examples of how these languages are used.  They learn about the strengths and weaknesses\nof the languages and about techniques that can be used to program effectively with them.  In the\nother direction, students are introduced to ''programming language theory'', a body of knowledge\nthat attempts to organize and analyze the wide variety of programming languages and programming\nlanguage features.  Such knowledge can be used to explain why certain languages ''adhere'' better\nthan others, or why certain kinds of run-time errors in a particular language are impossible, and it\ncan serve as a reliable guide to designing new programming languages.\n\nAlthough several approaches to programming language theory exist, the most effective is the approach\nthat represents both the abstract syntax and the static and dynamic semantics of a programming\nlanguage using inductively-defined hypothetical judgments given by sets of rules&mdash;essentially\ntreating the language as a formal system.  Coupled with a systematic classification of program\nfragments using types, even when types are not explicitly part of the language under consideration,\na powerfully uniform treatment of programming language theory emerges.  This approach is\ndeveloped in the two textbooks\n\n* PFPL: [http://www.cs.cmu.edu/~rwh/plbook/book.pdf Practical Foundations for Programming Languages] (PDF), by Robert Harper (draft, 2008), and\n* TAPL: [http://www.cis.upenn.edu/~bcpierce/tapl/ Types and Programming Languages], by Benjamin Pierce (MIT Press, 2002).\n\nDespite the success of this approach to programming language theory, one of its disadvantages,\nespecially for students seeing it for the first time, is that it can be quite abstract.  This is\nwhere Twelf comes in.  The rules for the hypothetical judgments associated with a particular\nprogramming language, and much of the resulting metatheory (i.e., the theorems about these\nrepresentations and their relations), are very naturally represented using Twelf.  Further, the\ncorrectness of the proofs can often be checked by Twelf, with feedback given when the proof is\nincomplete or incorrect.  This gives students concrete artifacts they can manipulate, interact and\nexperiment with, and test ideas on.\n\nThe aim of these notes is to act as a kind of \"laboratory handbook\" for the above two books,\nintroducing students of programming language theory to the Twelf system so that they can use it as a\nsupplement to their study, as well as, eventually, a tool for programming language research.  Our\ngoal here is not to ''teach'' programming language theory&mdash;that is done very well already by\nthe two books above&mdash;but to ''illustrate'' it and make it more concrete.  To that end, after a\ntutorial introduction to Twelf, we will give complete and carefully explained formalizations of the\nvarious systems, examples, proofs, and exercises in each of the above two books, pausing frequently\nto discuss the techniques used in the formalizations and the obstacles faced producing them.  In the\ncase of TAPL, we will be making use of some notes of Benjamin Pierce for his course at Penn,\n[http://www.seas.upenn.edu/~cis500/cis500-f07/schedule.html CIS 500], which uses the\n[http://coq.inria.fr Coq system] where we have used Twelf.\n\n== Table of Contents ==\n\nPart 1:  [[Introduction to Twelf]]\n# [[First-order encodings]]\n# [[Signatures as logic programs]]\n# [[Signature checking]]: modes, termination, coverage, totality\n# [[Higher-order encodings]]\n# [[Common patterns and pitfalls]]\n\nPart 2:  [[Logical Foundations of Programming Languages]]\n# [[LFPL:Chapter  1|Chapter  1]]: Inductive Definitions\n# [[LFPL:Chapter  4|Chapter  4]]: Transition Systems\n# [[LFPL:Chapter  5|Chapter  5]]: Basic Syntactic Objects\n# [[LFPL:Chapter  6|Chapter  6]]: Binding and Scope\n# [[LFPL:Chapter  7|Chapter  7]]: Concrete Syntax\n# [[LFPL:Chapter  8|Chapter  8]]: Abstract Syntax\n# [[LFPL:Chapter  9|Chapter  9]]: Static Semantics\n# [[LFPL:Chapter 10|Chapter 10]]: Dynamic Semantics\n# [[LFPL:Chapter 11|Chapter 11]]: Type Safety\n# [[LFPL:Chapter 12|Chapter 12]]: Evaluation Semantics\n# [[LFPL:Chapter 14|Chapter 14]]: Functions\n# [[LFPL:Chapter 15|Chapter 15]]: Gödel's System T\n# [[LFPL:Chapter 16|Chapter 16]]: Plotkin's PCF\n\nPart 3: [[Types and Programming Languages]]"
          },
          "sha1": "kmo18qaenkchsm3t1xtiu63qo3d4gvk"
        }
      },
      {
        "title": "Progress",
        "ns": 0,
        "id": 1650,
        "redirect": {
          "@title": "Canonical forms lemma",
          "#text": null
        },
        "revision": {
          "id": 2317,
          "timestamp": "2006-09-30T22:39:30Z",
          "contributor": {
            "ip": "71.206.199.131"
          },
          "comment": "Redirecting to [[Canonical forms lemma]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 35,
            "#text": "#REDIRECT [[Canonical forms lemma]]"
          },
          "sha1": "8no8mbjxhymtk9a3s35asmmglfp1v3z"
        }
      },
      {
        "title": "Proofs by reductio ad absurdum",
        "ns": 0,
        "id": 1403,
        "redirect": {
          "@title": "Reasoning from false",
          "#text": null
        },
        "revision": {
          "id": 1622,
          "parentid": 1453,
          "timestamp": "2006-09-06T20:28:49Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "minor": null,
          "comment": "[[Proofs by reducto ad absurdum]] moved to [[Proofs by reductio ad absurdum]]: spelling error",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 34,
            "#text": "#REDIRECT [[Reasoning from false]]"
          },
          "sha1": "0w24kisntse04nga26zz6cv6vu7pf27"
        }
      },
      {
        "title": "Proving metatheorems with Twelf",
        "ns": 0,
        "id": 1760,
        "revision": {
          "id": 290197,
          "parentid": 4957,
          "timestamp": "2021-03-23T12:55:36Z",
          "contributor": {
            "username": "Kartik",
            "id": 305433
          },
          "comment": "/* Is this introduction for you? */",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 3734,
            "#text": "==Is this introduction for you?==\n\nThe life story of a typical [[deductive system]] goes something like this: One day, a programming language designer has an idea for a new programming language.  She writes down the language's [[abstract syntax]].  Then, she gives the syntax meaning by defining some [[judgement]]s for it, such as a type system or an operational semantics.  Next, she investigates the language's properties by proving some theorems.  Maybe she fiddles with the language some to make the desired theorems true; maybe the idea doesn't work at all and she goes on to something else.  Maybe she implements the language to try out some examples.  Eventually, if the idea works out, she writes up a paper about the language.  If it's a good idea, then she, or maybe someone who read the paper, will someday want to extend the language, or incorporate the idea into another language.\n\nTwelf is a tool that assists people designing deductive systems: One day, a programming language designer has an idea.  Then, she formalizes the syntax and judgements of the language in the [[LF]] logical framework.  She uses Twelf to check her proofs of the theorems.  She uses Twelf to run the language definition itself to try out some examples.  Her paper includes a Twelf appendix, which makes her and her readers much more confident that the theorems in the paper are actually true.  When someone goes to extend the language, he has a formal, machine-checkable artifact that he can study or perhaps even reuse directly.\n\nThis introduction assumes that the first version of this story is somewhat familiar to you (if not, you should read a textbook such as [http://www.cis.upenn.edu/~bcpierce/tapl/ TAPL] or  [https://www.cs.cmu.edu/~rwh/pfpl/ PFPL]).  Here, you will learn the fundamentals of the Twelf version of the story.  This guide unveils Twelf in several layers.  The first layer uses a ''very'' simple deductive system ([[natural numbers]] with addition) to introduce the Twelf methodology.  The second layer tells the same story for a programming language with variable binding (the [[simply-typed lambda calculus]]), which is where Twelf really shines.  The third layer presents some more-interesting proofs and introduces one additional feature of Twelf, the ability to do proofs about open terms.\n\n==Table of contents==\n\n#First-order representations: The natural numbers \n## [[Proving metatheorems: Representing the syntax of the natural numbers|Representing syntax]] \n## [[Proving metatheorems: Simply typed LF|Simply typed LF]]\n## [[Proving metatheorems: Representing the judgements of the natural numbers|Representing judgements]] \n## [[Proving metatheorems: Full LF|Full LF]]\n## [[Proving metatheorems: Proving totality assertions about the natural numbers|Proving totality assertions]]\n## [[Proving metatheorems: Proving metatheorems about the natural numbers|Proving metatheorems]] \n## [[Proving metatheorems: Summary: the natural numbers|Summary]] ([[Proving metatheorems: Natural numbers: Answers to exercises|Answers to exercises]])\n#Higher-order representations: The STLC\n## [[Proving metatheorems: Representing the syntax of the STLC|Representing syntax]]\n## [[Proving metatheorems: Representing the judgements of the STLC|Representing judgements]]\n## [[Proving metatheorems: Proving metatheorems about the STLC|Proving metatheorems]]\n## [[Proving metatheorems: Proving totality assertions in non-empty contexts|Proving totality assertions in non-empty contexts]]\n## [[Proving metatheorems: Proving metatheorems in non-empty contexts|Proving metatheorems in non-empty contexts]]\n## [[Proving metatheorems: Summary: the STLC|Summary]] ([[Proving metatheorems: STLC: Answers to exercises|Answers to exercises]])"
          },
          "sha1": "3ke1xmul9anme61oh42rcp0z9dvbjwk"
        }
      },
      {
        "title": "Quick introduction",
        "ns": 0,
        "id": 1753,
        "redirect": {
          "@title": "General description of Twelf",
          "#text": null
        },
        "revision": {
          "id": 3254,
          "parentid": 3070,
          "timestamp": "2006-11-01T04:38:27Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "compress",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 42,
            "#text": "#REDIRECT [[General description of Twelf]]"
          },
          "sha1": "ov5pakkbtrpuvcm48w7n0plzn7qoopb"
        }
      },
      {
        "title": "Real-world binding structures",
        "ns": 0,
        "id": 2025,
        "redirect": {
          "@title": "Ad hoc binding structures",
          "#text": null
        },
        "revision": {
          "id": 4993,
          "timestamp": "2007-10-18T18:11:21Z",
          "contributor": {
            "username": "DanielKLee",
            "id": 5
          },
          "comment": "[[Real-world binding structures]] moved to [[Ad hoc binding structures]]: Ask Karl",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 39,
            "#text": "#REDIRECT [[Ad hoc binding structures]]"
          },
          "sha1": "6293c7a77en9xc086z1pw3u951hrdca"
        }
      },
      {
        "title": "Real World Binding Structures",
        "ns": 0,
        "id": 2022,
        "redirect": {
          "@title": "Ad hoc binding structures",
          "#text": null
        },
        "revision": {
          "id": 5000,
          "parentid": 4983,
          "timestamp": "2007-10-20T01:25:14Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "comment": "double redirect",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 39,
            "#text": "#REDIRECT [[Ad hoc binding structures]]"
          },
          "sha1": "6293c7a77en9xc086z1pw3u951hrdca"
        }
      },
      {
        "title": "Reasoning from equality",
        "ns": 0,
        "id": 1651,
        "redirect": {
          "@title": "Equality",
          "#text": null
        },
        "revision": {
          "id": 2319,
          "timestamp": "2006-09-30T22:45:43Z",
          "contributor": {
            "ip": "71.206.199.131"
          },
          "comment": "Redirecting to [[Equality]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 22,
            "#text": "#REDIRECT [[Equality]]"
          },
          "sha1": "1evo9trxxsh7ggeo11ch1cqy7ro4l3c"
        }
      },
      {
        "title": "Reasoning from false",
        "ns": 0,
        "id": 1401,
        "revision": {
          "id": 5406,
          "parentid": 4250,
          "timestamp": "2008-10-29T22:27:11Z",
          "contributor": {
            "username": "Pronesto",
            "id": 40
          },
          "comment": "/* Proving contradictions */",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 4208,
            "#text": "Twelf's coverage checker often rules out contradictory cases for you (see, for example, the [[Uniqueness lemmas|proof of determinacy for the simply typed λ-calculus]]).  However, you will sometimes need to reason from contradictory assumptions yourself. You can do this by declaring an ''uninhabited type'', proving that certain assumptions are contradictory, and then writing lemmas that conclude anything from a term of the uninhabited type. \n\n== The uninhabited type ==\n\n<twelf>uninhabited : type. \n%freeze uninhabited. \n</twelf>\n\nFreezing the intentionally uninhabited type (which is also sometimes called <tt>void</tt>, <tt>false</tt>, or <tt>absurd</tt>) is not strictly necessary, but it clarifies the programmer's intent—Twelf will signal an error if any later part of the signature introduces a term of this type.\n\n== Proving contradictions ==\n\nWe use some simple judgements on natural numbers to illustrate proving contradictions.\n\n<twelf>\nnat   : type. \nnat/z : nat.\nnat/s : nat -> nat.\n\nnat-less   : nat -> nat -> type.\nnat-less/z : nat-less nat/z (nat/s N).\nnat-less/s : nat-less (nat/s N1) (nat/s N2)\n              <- nat-less N1 N2.\n\nnat-plus   : nat -> nat -> nat -> type.\nnat-plus/z : nat-plus nat/z N N.\nnat-plus/s : nat-plus (nat/s N1) N2 (nat/s N3)\n              <- nat-plus N1 N2 N3.\n</twelf>\n\n=== Contradiction by coverage checking ===\n\nFirst, we prove that no number is less than zero:\n<twelf check=\"true\">\nnat-less-z-uninhabited : nat-less N nat/z \n                          -> uninhabited\n                          -> type.\n%mode nat-less-z-uninhabited +D1 -D2.\n%worlds () (nat-less-z-uninhabited _ _).\n%total {} (nat-less-z-uninhabited _ _).\n</twelf>\nThe coverage checker accepts this proof without any cases because there are no rules for deriving <tt>nat-less _ nat/z</tt>.  This is the simplest way to create a contradiction.  \n\n=== Inductive contradictions ===\n\nSome contradictions require an inductive argument.  For example, we can prove that if <tt>N1 < N2</tt> then there is no <tt>N3</tt> such that <tt>N2 + N3 = N1</tt>.\n<twelf check=\"true\">\nnat-less-plus-uninhabited : nat-less N1 N2\n                             -> nat-plus N2 N3 N1\n                             -> uninhabited\n                             -> type.\n%mode nat-less-plus-uninhabited +D1 +D2 -D3.\n\n- : nat-less-plus-uninhabited (nat-less/s NL) (nat-plus/s NP) DU\n     <- nat-less-plus-uninhabited NL NP DU.\n\n%worlds () (nat-less-plus-uninhabited _ _ _).\n%total (D1) (nat-less-plus-uninhabited D1 _ _).\n</twelf>\n\nIn this theorem, the coverage checker rules out all cases but the one where the first input is of the form\n<code>\nnat-less N1 N2\n------------------------------nat-less/s\nnat-less (nat/s N1) (nat/s N2)\n</code>\nand the second input is of the form\n<code>\nnat-plus N2 N3 N1\n----------------------------------nat-plus/s\nnat-plus (nat/s N2) N3 (nat/s N1)\n</code>\nTo show that this remaining case is contradictory. we apply the inductive hypothesis on the subderivations to derive <tt>uninhabited</tt>, and then return the resulting derivation of <tt>uninhabited</tt> to meet our proof obligations.\n\nWith this theorem, the coverage checker rules out all the base cases, so we are able to return a term of type <tt>uninhabited</tt> in the one remaining case by writing a loop.\n\n== Reasoning from contradiction ==\n\nOnce you have a contradiction, it is easy to write a lemma that reasons from it.  For example, from <tt>uninhabited</tt> we can conclude that any two numbers are <tt>nat-less</tt>:\n\n<twelf check=\"true\">\nuninhabited-nat-less : {N1:nat}{N2:nat}\n                         uninhabited\n                        -> nat-less N1 N2\n                        -> type.\n%mode uninhabited-nat-less +D1 +D2 +D3 -D4.\n%worlds () (uninhabited-nat-less _ _ _ _).\n%total {} (uninhabited-nat-less _ _ _ _).\n</twelf>\n\nThis proof requires no cases because any case would involve a canonical form of type <tt>uninhabited</tt>.\n\nThis lemma could be used in a proof that requires coming up with a derivation of some <tt>less-than</tt> fact in contradictory circumstances.  \n\nFor an example where reasoning from contradiction is necessary, see the tutorial on [[hereditary substitution for the STLC]].\n\n{{tutorial}}"
          },
          "sha1": "6ghesohp6nb1q01wlz7xjlbuce8sqji"
        }
      },
      {
        "title": "Reformulating languages to use hypothetical judgements",
        "ns": 0,
        "id": 2034,
        "revision": {
          "id": 5116,
          "parentid": 5114,
          "timestamp": "2008-03-11T15:20:21Z",
          "contributor": {
            "username": "Rpollack",
            "id": 28
          },
          "comment": "/* Reformulation 2: Change the definition */",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 12744,
            "#text": "It's easy to represent [[hypothetical judgement]]s in LF, exploiting [[higher-order judgements|higher-order]] representation techniques.  This tutorial presents some object-language judgements which are '''not''' typically phrased as hypothetical judgements, but can easily be reformulated as such, making the correspondence with their LF representation quite clear.  \nIn particular, we discuss parallel reduction and complete development for the lambda-calculus; thanks to [[User:rpollack]] for suggesting this example.\n\nBefore reading this tutorial, you should learn about hypothetical judgements and their representation in LF: [[Proving metatheorems: Representing the judgements of the STLC]] shows how object-language hypothetical judgements can be represented using LF binding. [[Proving metatheorems: Proving totality assertions in non-empty contexts]] shows an additional example, and discusses proving totality assertions about higher-order judgements. [[Proving metatheorems: Proving metatheorems in non-empty contexts]] shows how to use totality assertions to prove metatheorems about higher-order judgements. \n\n== Syntax is a hypothetical judgement ==\n\nFirst, we need to define the syntax of the untyped lambda-calculus:\n\n<code>\nM ::= x | lam x.M | app M1 M2\n</code>\n\nA traditional story about this definition is that variables <tt>x</tt> are some piece of first-order data such as strings or de Bruijn indices, <tt>lam x.M</tt> is a binder (which means it can be <math>\\alpha</math>-converted and can be substituted for) and so on.\n\nHowever, suppose we were given a single untyped datatype of tree-structured data with binding as a primitive notion, where such trees consist of variables <tt>x</tt>, binders <tt>x.t</tt>, and applications of constants such as <tt>lam</tt> and <tt>app</tt>.  Then we can save ourselves the trouble of recapitulating the construction of binding for each object language by simply carving out those trees that represent the language in question.    We can do so with a hypothetical judgement of the form <tt>x1 trm ... xn trm |- M trm</tt>, where the subjects of the judgement <tt>trm</tt> are untyped binding trees.  This judgement is defined as follows:\n\n<code>\nx trm in G\n----------\nG |- x trm\n\nG |- M1 trm  G |- M2 trm\n-------------------------\nG |- (app M1 M2) trm\n\n\nG , x trm |- M trm\n------------------\nG |- lam (x.M) trm\n</code>\n\nA variable is a term if it was assumed to be a term; at a binder, we extend the context by assuming a new term.  The important point about this style of definition is that variables are inherently  ''scoped'' and given meaning only by assumption: <tt>x</tt> is only meaningful if we are in a context where we have some assumptions about it.  Consequently, <tt>x1 trm ... xn trm |- M trm</tt> captures exactly the terms with free variables <tt>x1</tt>...<tt>xn</tt>.  \n\nWhen you're working with an inherently scoped type of binding trees, you can't give an unconditional definition of what it means to be a term with rules like  \n\n<code>\n-----\nx trm\n\nM trm\n-------------\nlam (x.M) trm\n</code>\n\nwhere the first rule means \"all those trees that happen to be variables are terms\": it would break the abstraction of variables-as-scoped-data to state a rule about all those trees that happen to be variables.    \n\nThe moral of the story is that syntax with binding can be thought of as a hypothetical judgement.\nThe LF encoding of this syntax can be thought of as an [[intrinsic encoding]] of the above judgement <tt>x1 trm ... xn trm |- M trm</tt>. LF provides typed binding trees, so we can define terms by specifying typed operators, rather than a predicate over untyped trees:  \n\n<twelf>\ntrm : type.\nlam : (trm -> trm) -> trm.\napp : trm -> trm -> trm.\n</twelf>\n\nThen the judgement <tt>x1 trm ... xn trm |- M trm</tt> becomes the LF judgement \n<tt>x1 : trm ... xn : trm |- M : trm</tt> where <tt>x</tt> and <tt>M</tt> are LF variables and terms.\n\n== Parallel reduction ==   \n\nParallel reduction is traditionally defined as follows.  For conciseness, we write <tt>\\x.M</tt> for <tt>lam x.M</tt> and <tt>M1 M2</tt> for <tt>app M1 M2</tt>\n\n<pre>\n------- var\nx => x\n \nM => M'  N => N'\n-------------------- beta\n(\\x.M) N => M'[N'/x]\n\nM => M'  N => N'\n---------------- app\n(M N) => (M' N')\n\n   M => N\n------------- lam\n\\x.M => \\x.N\n</pre>\n\nHowever, if we want to treat variables as scoped data, we must be explicit about scoping:\n\n<pre>\nG ::= . | G , x trm\n\nx trm in G\n----------- var\nG |- x => x\n \nG, x trm |- M => M'  G |- N => N'\n--------------------------------- beta\nG |- (\\x.M) N => M'[N'/x]\n\nG |- M => M'  G |- N => N'\n-------------------------- app\nG |- (M N) => (M' N')\n\nG, x trm |- M => N\n------------------- lam\nG |- \\x.M => \\x.N\n</pre>\n\nNow at least the judgement only talks about well-scoped data. However, the <tt>var</tt> rule is somewhat problematic.  In the abstract, it says \"derive <tt>G |- J'</tt> if <tt>J</tt> is in <tt>G</tt>\", where <tt>J</tt> and <tt>J'</tt> are ''different judgements''.  This isn't one of the structural principles of a [[hypothetical judgement]], and allowing this strange sort of access to the context could invalidate the substitution principle (if I substitute for <tt>J</tt>, I can no longer derive <tt>J'</tt>!).  So what are we to do?\n\n=== Reformulation 1: Hypothetical reductions ===   \n\nWhile a rule that says \"derive <tt>G |- J'</tt> if <tt>J</tt> is in <tt>G</tt>\" is suspicious, a rule that says \n\"derive <tt>G |- '''J'''</tt> if <tt>J</tt> is in <tt>G</tt>\" is just the usual hypothesis/identity axiom that we expect from all hypothetical judgements.  So, one solution is to change the notion of context we consider so that <tt>var</tt> is just an instance of hypothesis.  In particular, whenever we assume a variable <tt>x trm</tt>, we also ''assume'' a derivation <tt>x => x</tt>:\n\n<pre>\nG ::= . | G , x trm,x => x\n\nx => x in G\n----------- var\nG |- x => x\n \nG, x trm, x => x |- M => M'  G |- N => N'\n----------------------------------------- beta\nG |- (\\x.M) N => M'[N'/x]\n\nG |- M => M'  G |- N => N'\n-------------------------- app\nG |- (M N) => (M' N')\n\nG, x trm, x => x |- M => N\n--------------------------- lam\nG |- \\x.M => \\x.N\n</pre>\n\nNow the <tt>var</tt> rule is unobjectionable.  In the premies of the rules <tt>beta</tt> and <tt>lam</tt>, which deal with binding forms, the context is extended with the assumption that <tt>x => x</tt> for the bound variable <tt>x</tt>.  The derivations of this version are isomorphic to the first definition of <tt>G |- M => N</tt>, but the <tt>var</tt> rule here has a more generally acceptable form. \n\nThe LF representation of this formulation is quite direct:\n\n<twelf>\n=> : trm -> trm -> type.  %infix none 10 =>.\n\n=>/beta : (app (lam M) N) => M' N'\n          <- ({x:trm} x => x -> M x => M' x) \n          <- N => N'.\n=>/app  : (app M N) => (app M' N')\n          <- N => N'\n          <- M => M'.\n=>/lam  : lam M => lam M'\n          <- ({x:trm} x => x -> M x => M' x).\n\n%block =>b : block {x : trm} {=>/x : x => x}.\n%worlds (=>b) (=> _ _).\n</twelf>\n\nDerivations using <tt>var</tt> are represented by LF variables representing the reduction assumptions in <tt>G</tt>.  The Twelf <tt>%worlds</tt> declaration documents the form of <tt>G</tt> in our informal definition.\n\n==== Substitution ====\n\nThis reformulation elucidates a substitution principle for parallel reduction, as an instance of the general substitution principle for hypothetical judgements: \n\n: If <tt>G, x trm, x => x |- M => N</tt> and <tt>G |- M' trm</tt> and <tt>G |- M' => M'</tt> then <tt>[M'/x]M => [M'/x]N</tt>\n\nIn the LF representation, this substitution principle comes \"for free\" from the general substitution principle for LF terms.\n\n=== Reformulation 2: Change the definition ===\n\nAnother option is to change the definition of the judgement so that it doesn't have a variable-specific rule.  In this case, we can generalize the variable rule to a general reflexivity rule:\n\n<pre>\nG ::= . | G , x trm\n\n----------- refl\nG |- M => M\n \nG, x trm |- M => M'  G |- N => N'\n--------------------------------- beta\nG |- (\\x.M) N => M'[N'/x]\n\nG |- M => M'  G |- N => N'\n-------------------------- app\nG |- (M N) => (M' N')\n\nG, x trm |- M => N\n------------------- lam\nG |- \\x.M => \\x.N\n</pre>\n\nIn this case, this reformulation changes the structure of derivations (these are '''not''' isomorphic to what we started with) but does not change the relation defined by them, as reflexivity was admissible above.  This reformulation clearly would not be an option if reflexivity were not admissible, as in the example of complete development (below).\n\nThe LF representation looks like this:\n\n<twelf>\n=> : trm -> trm -> type.  %infix none 10 =>.\n\n=>/refl : M => M.\n=>/beta : (app (lam M) N) => M' N'\n          <- ({x:trm} M x => M' x)\n          <- N => N'.\n=>/app  : (app M N) => (app M' N')\n          <- N => N'\n          <- M => M'.\n=>/lam  : lam M => lam M'\n          <- ({x:trm} M x => M' x).\n\n%block trmb : block {x : trm}.\n%worlds (trmb) (=> _ _).\n</twelf>\n\n=== Reformulation 3 : tagged variables ===\n\n(coming soon!)\n\n== Complete development == \nParallel reduction is non-deterministic: any left-hand term that can be reduced by the <tt>beta</tt> rule can also be reduced by the <tt>app</tt> rule.  Complete development is a restriction of parallel reduction where <tt>beta</tt> takes precedence over <tt>app</tt>.  In each step of complete development, all of the beta-redices in the left-hand term are reduced.\n\nInformally, we add a side condition to the <tt>app</tt> rule:\n<pre>\nG |- M ==> M'  G |- N ==> N'  (M is not a lambda)\n------------------------------------------------ app\nG |- (M N) ==> (M' N')\n</pre>\n\nHow can we state this side condition more precisely?  We need a judgement <tt>notlam M</tt> which holds whenever <tt>M</tt> is not <tt>\\x.M'</tt>.  It's easy to define this as a hypothetical judgement if we choose our contexts correctly:\n\n<pre>\nG ::= . | G , x trm, notlam x\n\nnotlam x in G\n-------------\nG |- notlam x\n\n-----------------------\nG |- notlam (app M1 M2)\n</pre>\n\nThat is, with each variable, we make the additional assumption that it is not a lambda.\n\nThen complete development is easy to define:\n<pre>\nG ::= . | G , x trm, notlam x, x ==> x\n\nx ==> x in G\n------------ var\nG |- x ==> x\n \nG, x trm, notlam x, x => x |- M ==> M'  G |- N ==> N'\n----------------------------------------------------- beta\nG |- (\\x.M) N ==> M'[N'/x]\n\nG |- M ==> M'  G |- N ==> N'  G |- notlam M\n-------------------------------------------- app\nG |- (M N) ==> (M' N')\n\nG, x trm, notlam x, x => x |- M ==> N\n------------------------------------- lam\nG |- \\x.M ==> \\x.N\n</pre>\n\nThe LF representation is direct:\n\n<twelf>\nnotlam : trm -> type.\nnotlam/app : notlam (app _ _).\n\n%block nlb : block {x : trm} {nlx : notlam x}.\n%worlds (nlb) (notlam _).\n</twelf>\n\nWhenever we add a <tt>trm</tt> assumption to the LF context, we assume that it is not a lambda.  The Twelf <tt>%worlds</tt> declaration documents this fact, and causes Twelf to complain if we ever violate this convention.  \n\nThen complete development is a simple twist on parallel reduction:\n<twelf check=\"true\">\n==> : trm -> trm -> type.  %infix none 10 ==>.\n\n==>/beta : (app (lam M) N) ==> M' N'\n          <- ({x:trm} notlam x -> x ==> x -> M x ==> M' x)\n          <- N ==> N'.\n==>/app  : (app M N) ==> (app M' N')\n          <- N ==> N'\n          <- M ==> M'\n\t  <- notlam M.\n==>/lam  : lam M ==> lam M'\n          <- ({x:trm} notlam x -> x ==> x -> M x ==> M' x).\n\n%block ==>b : block {x : trm} {nlx : notlam x} {==>/x : x ==> x}.\n%worlds (==>b) (==> _ _).\n</twelf>\n\nEvery time we extend the context, we add an assumption <tt>notlam x</tt> for that variable.  We also add a reflexivity assumption for each variable because the informal definition of complete development still has a reflexivity rule for variables (even though the relation is not reflexive in general).  \n\n==== Substitution ====\n\nAs above, this formulation gives a \"free\" substitution principle for complete development: if we have a complete development derivation <tt>G , x trm, notlam x, x ==> x |- M ==> N</tt> \nand <tt>G |- M' trm</tt> and <tt>G |- notlam M'</tt> and <tt> G |- M' ==> M'</tt>\nthen  <tt>G |- M[M'/x] ==> N[M'/x]</tt>.  The form of the context ensures that we need a derivation of <tt>notlam M'</tt> to make this substitution: it's not obvious that you can substitute lambdas for variables while preserving complete development, since you'd have to replace instances of <tt>app</tt> with something else.    \n\n== See also ==\n\n* [[Hypothetical judgement]]s\n* [[Higher-order judgement]]s\n* The case study on [[Church-Rosser via complete development]] for some proofs about the judgements defined here, illustrating the use of [[regular world]]s.\n\n{{tutorial}}"
          },
          "sha1": "dx4b0t31m30zha7zr438gavevpk8k5w"
        }
      },
      {
        "title": "Regular world",
        "ns": 0,
        "id": 1975,
        "redirect": {
          "@title": "%worlds",
          "#text": null
        },
        "revision": {
          "id": 4548,
          "parentid": 4545,
          "timestamp": "2007-03-21T02:25:50Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "comment": "Redirecting to [[%worlds]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 21,
            "#text": "#REDIRECT [[%worlds]]"
          },
          "sha1": "0jtdy7wnk96spj887p00qwvmaysabch"
        }
      },
      {
        "title": "Regular worlds",
        "ns": 0,
        "id": 1976,
        "redirect": {
          "@title": "%worlds",
          "#text": null
        },
        "revision": {
          "id": 4547,
          "timestamp": "2007-03-21T02:25:30Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "comment": "Redirecting to [[%worlds]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 21,
            "#text": "#REDIRECT [[%worlds]]"
          },
          "sha1": "0jtdy7wnk96spj887p00qwvmaysabch"
        }
      },
      {
        "title": "Relation",
        "ns": 0,
        "id": 1488,
        "revision": {
          "id": 4555,
          "parentid": 3114,
          "timestamp": "2007-03-21T03:00:24Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 332,
            "#text": "It is common to refer to a an LF [[type family]] as a '''relation''', because a type family defines a relation on its indices where indices are related iff their instance of the type family is inhabited. A htype family is also commonly referred to as a [[judgment]].\n\n== See also ==\n\n* [[Judgment]]\n* [[Judgments as types]]\n{{stub}}"
          },
          "sha1": "kc2xdvwtff3deogizsgt6m7uwpsf94c"
        }
      },
      {
        "title": "Release history",
        "ns": 0,
        "id": 1407,
        "revision": {
          "id": 6241,
          "parentid": 6237,
          "timestamp": "2011-03-25T13:07:46Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "/* Twelf 1.7.1 (Mar 19, 2011) */",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 3925,
            "#text": "This page contains links to all numbered releases of the Twelf software. Releases before 1.7.0 can be found at http://www.cs.cmu.edu/~twelf/dist/, and releases from 1.7.0 onwards can be found at http://twelf.plparty.org/releases. Other ways of getting (possibly more recent) versions of Twelf can be found on the [[Download]] page.\n\n== Twelf 1.7.1 (Mar 19, 2011) == \n* Adds support for <tt>[[%block]]</tt> definitions (as opposed to block declarations).\n\n== Twelf 1.7.0 (Mar 2, 2011) ==\n* Includes many important features like [[%trustme]] and [[%reduces]] that are in standard use and documented on the wiki.\n* Fixes long-standing bug in coverage checking (not known to cause unsoundness)\n* Clarified the release status of Twelf, which is released under the [http://www.opensource.org/licenses/bsd-license.php simplified BSD license].\n\n== Twelf 1.5R1 (Mar 1, 2005) ==\n*[http://www.cs.cmu.edu/~twelf/dist/twelf-1-5R1.tar.gz twelf-1-5R1.tar.gz] (source distribution only)\n*Significantly improved tabling over Twelf 1.5\n*The documentation is not yet updated\n*Re-packaged on March 8 in a form suitable for SML/NJ 110.0.07, SML/NJ 110.53, Poly/ML 4.1.3 and MLton 20040227\n\n== 1.4 alpha  ==\n*[http://www.cs.cmu.edu/~twelf/dist/twelf-1-4.tar.gz twelf-1-4.tar.gz] source distribution (1.4 MB)\n*[http://www.cs.cmu.edu/~twelf/dist/twelf-1-4-0.i386.rpm twelf-1-4-0.i386.rpm] binary distribution for Red Hat Linux 7.1 (2.9 MB), built with MLton (README-1-4-rpm)\n*[http://www.cs.cmu.edu/~twelf/dist/twelf-1-4.exe twelf-1-4.exe] binary for Windows (5.1 MB)\n*[http://www.cs.cmu.edu/~twelf/dist/README-1-4 README-1-4]\n*[http://www.cs.cmu.edu/~twelf/guide-1-4/twelf_1.html#SEC2 New Features] (release notes)\n*[http://www.cs.cmu.edu/~twelf/guide-1-4/index.html Twelf User's Guide, Version 1.4]\nSource distribution can be compiled with SML/NJ, Poly/ML and MLton under Linux, Windows, and MacOS X. This is first version of Twelf whose source is fully compatible with the SML'97 Definition. Twelf 1.4 has several new features including world checking, coverage checking, totality checking, tracing type reconstruction, and use of definitions during proof search (see New Features).\n\n== Working Version 1.3R4  ==\n*[http://www.cs.cmu.edu/~twelf/dist/twelf-1-3R4.tar.gz twelf-1-3R4.tar.gz] (1.4 MB) for Linux/Unix/Solaris, including User's Guide and example suites. Requires SML'97 (preferably SML of NJ, version 110 or higher). See the [http://www.cs.cmu.edu/~twelf/dist/README-1-3R4 README-1-3R4] file for further information.\n\n== 1.3 alpha  ==\n*[http://www.cs.cmu.edu/~twelf/dist/twelf-1-3.tar.gz twelf-1-3.tar.gz] (1.1 MB) for Linux/Unix/Solaris, including User's Guide and example suites. Requires SML'97 (preferably SML of NJ, version 110 or higher). See the [http://www.cs.cmu.edu/~twelf/dist/README-1-3 README-1-3] file for further information. \n*[http://www.cs.cmu.edu/~twelf/dist/twelf-1-3-0.i386.rpm twelf-1-3-0.i386.rpm] (1.4 MB) a binary distribution for x86/Linux.\n*[http://www.cs.cmu.edu/~twelf/dist/twelf-1-3.exe twelf-1-3.exe] (5.7 MB) for Windows 9x/ME/NT/2000. This includes binaries, sources, User's Guide, and examples suites. See the [http://www.cs.cmu.edu/~twelf/dist/README-1-3 README-1-3] file for further information.\n\n== 1.2 alpha ==\n*[http://www.cs.cmu.edu/~twelf/dist/twelf-1-2.tar.gz twelf-1-2.tar.gz] (717KB, [http://www.cs.cmu.edu/~twelf/dist/README-1-2 README-1-2]), includes User's Guide and example suites. Requires SML'97 (preferably SML of NJ, version 110 or higher). It has been tested under Linux, SunOS, Sun/Solaris and Windows 95/98/NT.\n*[http://www.cs.cmu.edu/~twelf/dist/twelf-1-2-1.i386.rpm twelf-1-2-1.i386.rpm] (959KB), a precompiled rpm file for RedHat Linux, includes User's Guide and example suites but no source code.\n*[http://www.cs.cmu.edu/~twelf/dist/twelf-1-2.exe twelf-1-2.exe] (1,868KB), a precompiled version for Windows 95/98/NT, includes User's Guide and example suites but no source code."
          },
          "sha1": "7uvg2dgx7eh4kjynckg5eci55edga7r"
        }
      },
      {
        "title": "Research projects using Twelf",
        "ns": 0,
        "id": 1414,
        "revision": {
          "id": 9605,
          "parentid": 9604,
          "timestamp": "2019-03-29T19:42:58Z",
          "contributor": {
            "username": "Hibou57",
            "id": 15420
          },
          "comment": "Removed spam links (french is my native tong, believe me, these sites had nothing to do with logic or Twelf)",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 2727,
            "#text": "Please add your research using Twelf to the links below.  We hope this collection of links will encourage collaboration among Twelf users and record how Twelf is being used in practice.  \n\nThe links on this page are grouped into two rough categories: larger projects (e.g., a multi-year endeavor) and smaller projects (e.g., some Twelf code that accompanies a research paper).  The line between these two is fuzzy, so add your work wherever you think it fits best. __NOTOC__\n\n== Research using Twelf ==\n\n==== Larger projects ====\n\n* [http://www.cs.princeton.edu/sip/projects/pcc/ Proof Carrying Code] - scaling up the idea of Proof Carrying Code to real programming languages, using a logic encoded in Twelf's dependent type system.\n* [http://www.cs.cmu.edu/~self/ The SeLF Project] - encodings of security policies and proofs of security properties for the [http://www.ece.cmu.edu/~grey/ Grey project].\n* [http://www.cs.cmu.edu/~dklee/tslf/ Mechanizing the Metatheory of Standard ML] - a formalization of Standard ML and verification of its metatheory in Twelf. \n* [http://tom7.org/proposal/ Modal Types for Mobile Code] - [[User:Tom7|Tom]]'s Ph.D. thesis project\n* [https://trac.omdoc.org/LATIN LATIN] - a project aimed at the creation of a large library of logics and logic translations supported by a web-scalable infrastructure\n\n==== Smaller projects ====\n\n* [http://www.cs.cmu.edu/~drl/pubs/lh05dmlproofs-tr/lh05dmlproofs-tr.pdf Dependent Types for ML] - A paper by [[User:drl|Dan Licata]] and [[User:rwh|Bob Harper]] about enriching an ML-like type system with a form of dependent types.  Much of the metatheory of the language is mechanized in Twelf.  \n* [http://www.cs.cornell.edu/people/fluet/twelf/index.html Substructural Languages] - Twelf code from some of Matthew Fluet's papers on substructural languages.\n* [http://www.cs.cmu.edu/~jdonham/aml-proof/ Self-Adjusting Computation] - [[User:JakeD|Jake Donham's]] formalization of a consistency proof of non-deterministic semantics.\n* [http://www.cs.cmu.edu/~joshuad/papers/intcomp/ Elaborating Intersection and Union Types] — [[User:Joshua|Joshua Dunfield]]'s proofs about an elaboration semantics.\n\n== Related projects ==\n\n* [[poplmark:The POPLmark Challenge|The POPLmark Challenge]] - A project aimed at increasing the overall use of theorem provers like Twelf in programming language design. A solution to the full challege using Twelf submitted by a team at CMU [http://fling-l.seas.upenn.edu/~plclub/cgi-bin/poplmark/index.php?title=Submission_from_Carnegie_Mellon].\n* [http://delphin.poswolsky.com/ Delphin] - An integration of concepts from Twelf and functional programming languages.\n* [http://www.cs.cmu.edu/~fp/elf.html Elf] - The predecessor to Twelf."
          },
          "sha1": "ovv1ia4avktc2h5uz2uwjuj8cb2mhzl"
        }
      },
      {
        "title": "Respects lemma",
        "ns": 0,
        "id": 1675,
        "revision": {
          "id": 6193,
          "parentid": 6192,
          "timestamp": "2010-11-30T18:12:35Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "minor": null,
          "comment": "Reverted edits by [[Special:Contributions/Doriangrand|Doriangrand]] ([[User talk:Doriangrand|talk]]) to last revision by [[User:Drl|Drl]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 7053,
            "#text": "''You should read the tutorial on [[equality|representing equality of LF terms as a type family]] before reading this one.''\n\nAt a high level, a '''respects lemma''' shows that a type family or term constructor \"respects\" some relations on its arguments.  Specifically, we use the term ''respects lemma'' to refer to:\n# a lemma proving that the indices to a type family \"respect\" some relations on those indices, in the sense that inhabitation of the type family is preserved by replacing related indices.  \n# a '''compatibility lemma''' for a term constructor <tt>f</tt>, which states that if some relations hold for some arguments, then a relation holds for <tt>f</tt> applied to those arguments.\n\nOften, the relations in question are [[equality|equality of LF terms]].  \n\n== Example: Proving that a type family respects equality ==\n\nIt is often necessary to prove a respects lemma showing that a type family respects equality of its indices.  \nFor example, we can define the standard equality relation <tt>bin-eq</tt> for binary numbers, the standard <tt>and</tt> relation on binary numbers, and then prove a ''respects lemma'' that <tt>and</tt> respects equality:\n\n<twelf>\nbin : type. \n\ne : bin. \n1 : bin -> bin. \n0 : bin -> bin.\n\nbin-eq : bin -> bin -> type.\nbin-eq/ : bin-eq N N.\n\n% note: not defined unless the numbers are the same length\nand : bin -> bin -> bin -> type.\n%mode and +N1 +N2 -N3.\n\nand/e : and e e e.\nand/00 : and (0 M) (0 N) (0 P) <- and M N P.\nand/01 : and (0 M) (1 N) (0 P) <- and M N P.\nand/10 : and (1 M) (0 N) (0 P) <- and M N P.\nand/11 : and (1 M) (1 N) (1 P) <- and M N P.\n\n%{\nThe respects lemma: the and relation respects equality\n}%\n\nand-resp : bin-eq M M' -> bin-eq N N' -> bin-eq O O' -> and M N O -> and M' N' O' -> type.\n%mode and-resp +EQM +EQN +EQO +A -A'.\n\n- : and-resp bin-eq/ bin-eq/ bin-eq/ A A.\n\n%worlds () (and-resp _ _ _ _ _).\n%total {} (and-resp _ _ _ _ _).\n</twelf>\n\nThe theorem <tt>and-resp</tt> states that if M and M' are equal, and N and N' are equal, and O and O' are equal, and M & N = O, then M' & N' = O'. The proof is trivial: since the only way to conclude <tt>bin-eq</tt> is using <tt>bin-eq/</tt> where both binary numbers must be identical, the same derivation of <tt>and</tt> that we got as input works for the output.\n\nIf <tt>bin-eq</tt> were some other equivalence relation (''e.g.'', ignoring leading zeros), the respects lemma would require a more sophisticated proof (e.g., an inductive argument over the derivation of the equality).\n\nAlthough we proved that <tt>and</tt> respects equality in all three arguments, we can easily use this lemma even when we only have an equality derivation for one pair of arguments, as long as the other two pairs of arguments are already syntactically equal. For example, we can prove:\n\n<twelf>\nand-first-resp : bin-eq M M' -> and M N O -> and M' N O -> type.\n%mode and-first-resp +EQ +A -A'.\n\n- : and-first-resp EQ A A' <- and-resp EQ bin-eq/ bin-eq/ A A'.\n%worlds () (and-first-resp _ _ _).\n%total D (and-first-resp D _ _).\n</twelf>\n\n(This theorem is trivial and could have been proven directly, but it illustrates the point.) When we invoke the <tt>and-resp</tt> lemma as a subgoal, we pass along the equality derivation for the first two arguments, and pass along the constant <tt>bin-eq/</tt> for the others, which are known to be identical. Therefore, it suffices to define the more general respects lemmas and then invoke them in specialized ways, if necessary.\n\n{{needs|an example where a respects lemma is needed}}\n\n== Example: proving compatibility lemmas ==\n\nAnother kind of respects lemma is a '''compatibility lemma''', which states that a relation is respected by the application of term constructors. (This is also called a '''congruence lemma''' when the relation in question is an equivalence relation.) For example, we can prove compatibility lemmas about the constructors <tt>1</tt> and <tt>0</tt>:\n\n<twelf>\n1-compat : bin-eq M M' -> bin-eq (1 M) (1 M') -> type.\n%mode 1-compat +EQ -EQ'.\n- : 1-compat bin-eq/ bin-eq/.\n\n0-compat : bin-eq M M' -> bin-eq (0 M) (0 M') -> type.\n%mode 0-compat +EQ -EQ'.\n- : 0-compat bin-eq/ bin-eq/.\n\n%worlds () (1-compat _ _) (0-compat _ _).\n%total (D E) (1-compat D _) (0-compat E _).\n</twelf>\n\nWe might use these compatibility lemmas in proving some theorems about binary numbers. For instance, we might want to prove that <tt>not</tt> is its own inverse:\n\n<twelf>\nnot : bin -> bin -> type.\n%mode not +B -B'.\nnot/e : not e e.\nnot/1 : not (1 B) (0 B') <- not B B'.\nnot/0 : not (0 B) (1 B') <- not B B'.\n\nnotnot : not A B -> not B C -> bin-eq A C -> type.\n%mode notnot +N +N' -EQ.\n\nnotnot/e : notnot not/e not/e bin-eq/.\nnotnot/1 : notnot (not/1 N1) (not/0 N2) EQ'\n        <- notnot N1 N2 (EQ : bin-eq A' C')\n        <- 1-compat EQ (EQ' : bin-eq (1 A') (1 C')).\nnotnot/0 : notnot (not/0 N1) (not/1 N2) EQ'\n        <- notnot N1 N2 (EQ : bin-eq A' C')\n        <- 0-compat EQ (EQ' : bin-eq (0 A') (0 C')).\n\n%worlds () (notnot _ _ _).\n%total D (notnot D _ _).\n</twelf>\n\nIn the inductive cases of <tt>notnot</tt>, we have a derivation <tt>EQ</tt> that two smaller numbers are equal, and need to use this derivation to prove that if we apply the <tt>1</tt> constructor (for each) to each of the terms, they are still equal.\n\n=== Generalized compatibility lemmas ===\n\nCompatibility lemmas can be generalized somewhat so that we needn't prove so many. Instead of defining the <tt>0-compat</tt> and <tt>1-compat</tt> cases separately, we can abstract over the constructor as an LF function:\n\n<twelf>\nf-compat : {EQ  : bin-eq M M'}\n           {F   : bin -> bin} \n           {EQ' : bin-eq (F M) (F M')}\n           type.\n%mode f-compat +EQ +F -EQ'.\n- : f-compat bin-eq/ _ bin-eq/.\n%worlds () (f-compat _ _ _).\n%total D (f-compat D _ _).\n</twelf>\n\nHere, we instead prove that if <tt>M</tt> and <tt>M'</tt> are equal, then <tt>F M</tt> and <tt>F M'</tt> are equal for any <tt>F</tt>. Now we can prove the <tt>notnot</tt> theorem again using only this generalized compatibility lemma:\n\n<twelf>\nnotnot : not A B -> not B C -> bin-eq A C -> type.\n%mode notnot +N +N' -EQ.\n\nnotnot/e : notnot not/e not/e bin-eq/.\nnotnot/1 : notnot (not/1 N1) (not/0 N2) EQ'\n        <- notnot N1 N2 EQ\n        <- f-compat EQ 1 EQ'.\nnotnot/0 : notnot (not/0 N1) (not/1 N2) EQ'\n        <- notnot N1 N2 EQ\n        <- f-compat EQ 0 EQ'.\n\n%worlds () (notnot _ _ _).\n%total D (notnot D _ _).\n</twelf>\n\nHere we pass in the constructors <tt>1 : bin -> bin</tt> and <tt>0 : bin -> bin</tt> as <tt>F</tt>. The functions could arbitrary complex, like <tt>[b] 0 (1 (1 b))</tt>.\n\nThis generalization technique usually only works when equality is defined as Twelf identity, because of the arbitrariness of the function passed in. When it can be used, it can substantially reduce the number of compatibility lemmas that one needs to state.\n\n{{needs|a description of some more advanced/tasteless generalization tricks}}\n\n<twelflink>All code from this tutorial</twelflink>. <twelflink check=\"true\">Twelf's output from this tutorial</twelflink>.\n\n{{tutorial}}"
          },
          "sha1": "ihv7iu6r5f86ji89n9m52zee3qg1fax"
        }
      },
      {
        "title": "Respects lemmas",
        "ns": 0,
        "id": 1879,
        "redirect": {
          "@title": "Respects lemma",
          "#text": null
        },
        "revision": {
          "id": 3856,
          "parentid": 3855,
          "timestamp": "2007-03-09T04:31:59Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "oops",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 28,
            "#text": "#REDIRECT [[Respects lemma]]"
          },
          "sha1": "mv4t94do770qopwnz5smkbbw3qpa5js"
        }
      },
      {
        "title": "Revision history",
        "ns": 0,
        "id": 1476,
        "redirect": {
          "@title": "Release history",
          "#text": null
        },
        "revision": {
          "id": 1814,
          "timestamp": "2006-09-23T02:04:14Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 29,
            "#text": "#REDIRECT [[Release history]]"
          },
          "sha1": "cno8tkmgalsjej1ukttajpinibw1h9i"
        }
      },
      {
        "title": "Sets and supersets",
        "ns": 0,
        "id": 1427,
        "revision": {
          "id": 2734,
          "parentid": 1944,
          "timestamp": "2006-10-13T07:52:52Z",
          "contributor": {
            "username": "Varming",
            "id": 10
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 4818,
            "#text": "{{needs|this is really about multisets encoded as lists . s/set/multiset/g. BTW didn't I author the part to do with reflexivity? [[User:Varming|Varming]] 03:52, 13 October 2006 (EDT)}}\n{{needs|editing for context and tone}}\n\nThis is a simplification of your concept further to take away the need for subtyping. I think this is essentially as simple as you can get, and from here you can do one of two things:\n\n* Make the entries in the sets not strictly equal, but subject to a subtype relation (this is what you did, essentially)\n* Make the sets ordered\n\nOnce you've done both of these things, which seem like they are relatively orthogonal to each other, *then* we've got the environments that Appel is looking for. I think what would be interesting is to see the progression of all of them, so what I'm probably going to do next (unless you want to crack at it) is to redo this file will well-ordered sets. \n\n<twelf>%% Map subtyping - concept progression\n%% 1) Notion of sets and supersets of natural numbers\n\n%% Daniel K. Lee and Robert J. Simmons\n%% Carnegie Mellon University. August 2006.\n\n% Natural numbers \n\nnat : type.\n\nz: nat.\ns: nat -> nat.\n\n% Sets of natural numbers\n\nset : type.\n\nset/nil : set.\nset/cons : nat -> set -> set.\n\n% The containment judgment\n%\n% Succeeds if a natural number is one of the items in the set\n\nin-set : nat -> set -> type.\n\nin-set/hit : in-set N (set/cons N SET).\nin-set/miss : in-set N (set/cons N' SET)\n\t       <- in-set N SET.\n\n%{ \nThe superset relation\n\nThis definition is \"extensional\" in that S1 is a superset of S2 if for\nevery natural number n in S2, that natural number also exists in S1. \n\nThis relation says nothing about the frequency of these entries, so\n(1,2,1) is a superset of (2,2,2) (a strict superset, though we do not define the\nnotion of \"strict\")\n}%\n\nsuperset : set -> set -> type.\n\nsuperset/nil : superset SET set/nil.\nsuperset/cons : superset SET1 (set/cons N SET2)\n\t\t <- in-set N SET1\n\t\t <- superset SET1 SET2.\n\n% BEGIN META-THEOREMS\n\n%{\nWeakening\n\nWeakening is the crucial lemma for the reflexivity - it states that if SET1 is\na superset of SET2, you can add something to SET1 and the result is still a \nsuperset of SET2.\n\nThe second case goes as follows (using A >= B as shorthand for superset A B). \nIn the case that we have:\n\n IN:(in-set N' SET1)   SUP:(SET1 >= SET2)\n---------------------------------------- superset/cons\n      SET1 >= (set/cons N' SET2)\n\nwe can get from induction that, for some arbitrary N, \nSUP':((set/cons N SET1) >= SET2)\n\nWe can then build a derivation of the result that we want like so:\n\n     IN:(in-set N' SET1)\n----------------------------- in-set/miss\n in-set N' (set/cons N SET1)              SUP':((set/cons N SET1) >= SET2)\n------------------------------------------------------------------ superset/cons\n      (set/cons N SET1) >= (set/cons N' SET2)\n}%\n\nsuperset-wkn : {N} superset SET1 SET2\n\t\t-> superset (set/cons N SET1) SET2 -> type.\n%mode superset-wkn +D1 +D2 -D3.\n\n- : superset-wkn _ superset/nil superset/nil.\n- : superset-wkn N (superset/cons SUP IN) \n                   (superset/cons SUP'  (in-set/miss IN))\n     <- superset-wkn N SUP SUP'.\n\n%worlds () (superset-wkn _ _ _). %total T (superset-wkn _ T _).\n\n% Reflexivity of the superset relation\n\nsuperset-refl : {SET} superset SET SET -> type.\n%mode superset-refl +D1 -D2.\n\n- : superset-refl set/nil superset/nil.\n- : superset-refl (set/cons N SET) (superset/cons SUP' in-set/hit)\n     <- superset-refl SET (SUP: superset SET SET)\n     <- superset-wkn N SUP (SUP': superset (set/cons N SET) SET).\n\n%worlds () (superset-refl _ _).\n%total T (superset-refl T _).\n\n%{\nThe \"Entry-in-superset\" lemma\n\nJust as weakening was the crucial lemma for reflexivity, this is the crucial\nlemma for the transitivity lemma. It's statmement is simple - if N is in SET2,\nand SET1 is a supertype of SET2, then N is in SET1. \n\nThe proof is pretty straightforward induction - if the derivation of \"in-set\" \nis the hit, you're done, if it's not, keep looking.\n}%\n\nin-superset : in-set N SET2\n\t       -> superset SET1 SET2\n\t       -> in-set N SET1 -> type.\n%mode in-superset +D1 +D2 -D3.\n\n- : in-superset in-set/hit (superset/cons SUP IN) IN.\n- : in-superset (in-set/miss IN) (superset/cons SUP _) IN'\n     <- in-superset IN SUP IN'.\n\n%worlds () (in-superset _ _ _). %total T (in-superset T _ _).\n\n% Transitivity of the superset relation\n\nsuperset-trans : superset SET1 SET2\n\t\t  -> superset SET2 SET3\n\t\t  -> superset SET1 SET3 -> type.\n%mode superset-trans +D1 +D2 -D3.\n\n- : superset-trans _ superset/nil superset/nil.\n- : superset-trans SUP1 (superset/cons SUP2 IN) (superset/cons SUP3 IN')\n     <- superset-trans SUP1 SUP2 SUP3\n     <- in-superset IN SUP1 IN'.\n\n%worlds () (superset-trans _ _ _). %total T (superset-trans _ T _).</twelf>\n\n[[Category:Twelf code]]\n{{stub tutorial}}"
          },
          "sha1": "l351a4au75jmimlcs7xkcxpqs3cei6w"
        }
      },
      {
        "title": "Shallow equality",
        "ns": 0,
        "id": 1516,
        "redirect": {
          "@title": "Equality",
          "#text": null
        },
        "revision": {
          "id": 2017,
          "timestamp": "2006-09-28T00:52:04Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "create redirect",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 22,
            "#text": "#REDIRECT [[Equality]]"
          },
          "sha1": "1evo9trxxsh7ggeo11ch1cqy7ro4l3c"
        }
      },
      {
        "title": "Signature",
        "ns": 0,
        "id": 1645,
        "redirect": {
          "@title": "Twelf signature",
          "#text": null
        },
        "revision": {
          "id": 2298,
          "timestamp": "2006-09-30T18:15:42Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "Redirecting to [[Twelf signature]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 29,
            "#text": "#REDIRECT [[Twelf signature]]"
          },
          "sha1": "68mj74j56n1gge9m6112xlpulup1l2b"
        }
      },
      {
        "title": "Signature checking",
        "ns": 0,
        "id": 2090,
        "revision": {
          "id": 5416,
          "timestamp": "2008-11-01T03:09:25Z",
          "contributor": {
            "username": "Twilson",
            "id": 15
          },
          "comment": "New page: {{needswork|To be completed}} If all Twelf had were the features we've introduced so far, it would still be a useful tool: we can represent a large variety of complex types and do searches...",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 1766,
            "#text": "{{needswork|To be completed}}\nIf all Twelf had were the features we've introduced so far, it would still be a useful tool: we can represent a large variety of complex types and do searches and logic programming over them.  But where Twelf really shines is in its signature checks.  Having created a Twelf signature&mdash;which, as we've seen, we can interpret as a labeled logic program&mdash;we can then ask Twelf to check certain properties of that signature.  In particular, as we will see shortly, we can designate the arguments of a type family as inputs and outputs, and then ask\n* whether this designation is consistent with the reading of the signature as a logic program, that is, whether the outputs of the constructor will be ground (involve no logic variables) if the inputs are all ground (a '''mode''' check),\n* whether the constructor will produce at most one combination of outputs for any given combination of ground inputs (a '''uniqueness''' check),\n* whether the logic program will always terminate if it is given ground inputs (a '''termination''' check), or\n* whether the constructor will always produce at least one combination of ground outputs for any possible combination of ground inputs (a '''totality''' check).\nThe totality check subsumes termination, but it has a couple of additional elements: '''input coverage''' and '''output coverage'''.  Input coverage involves checking whether there are enough clauses for the constructor to match any possible combination of inputs; we then say that all possible inputs are ''covered''.  Output coverage involves checking that certain assumptions made about the form of outputs from \"subroutine\" calls are justified.  Let's now take a look at these checks in more detail and see some examples."
          },
          "sha1": "shfr60ufes0eb5cex226up0j2we0rqs"
        }
      },
      {
        "title": "Signatures as logic programs",
        "ns": 0,
        "id": 2089,
        "revision": {
          "id": 5415,
          "parentid": 5414,
          "timestamp": "2008-11-01T03:04:41Z",
          "contributor": {
            "username": "Twilson",
            "id": 15
          },
          "minor": null,
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 13899,
            "#text": "Recall from the previous section the signature for representing the days of the week, the \"next day\" function, and the \"day after tomorrow\" function:\n<twelf>\n% Days of the week\nday : type.\n\nsunday    : day.\nmonday    : day.\ntuesday   : day.\nwednesday : day.\nthursday  : day.\nfriday    : day.\nsaturday  : day.\n\n\n% Next day function\nnext_day : day -> day -> type.\n\nnext_day_sun : next_day sunday monday.\nnext_day_mon : next_day monday tuesday.\nnext_day_tue : next_day tuesday wednesday.\nnext_day_wed : next_day wednesday thursday.\nnext_day_thu : next_day thursday friday.\nnext_day_fri : next_day friday saturday.\nnext_day_sat : next_day saturday sunday.\n\n\n% Day after tomorrow function\ndat : day -> day -> type.\n\ndat_def : next_day D1 D2 -> next_day D2 D3 -> dat D1 D3.\n</twelf>\nReaders familiar with logic programming may have noticed a strong similarity between this signature and how the relations \"next day\" and \"day after tomorrow\" might be defined in Prolog.  This is no coincidence.  Indeed, consider the following Prolog definitions for these two relations:\n<pre>\n% Prolog definitions of next_day and dat\nnext_day(sunday, monday).\nnext_day(monday, tuesday).\nnext_day(tuesday, wednesday).\nnext_day(wednesday, thursday).\nnext_day(thursday, friday).\nnext_day(friday, saturday).\nnext_day(saturday, sunday).\n\ndat(D1, D3) :- next_day(D1, D2), next_day(D2, D3).\n</pre>\nNo types are involved here; the logical constants are introduced when they are needed, rather than declared in advance; and <tt>D1</tt>, <tt>D2</tt>, and <tt>D3</tt> are logic variables.  The Twelf declarations for these relations have essentially the same form, except that they are curried and associate an identifier with each clause (<tt>next_day_sun</tt>, <tt>next_day_mon</tt>, etc., and <tt>dat_def</tt>), making a Twelf signature a kind of \"labeled\" logic program.  It may thus be said that, in the analogy between Prolog and Twelf, Prolog is concerned only with which instances of relations are \"true\", whereas Twelf is concerned with ''how'' they are true&mdash;i.e., what constitutes evidence for them.  Each successful Prolog search for a satisfying substitution to a goal query corresponds to a Twelf term of the type associated with the instantiated goal.  Prolog searches can only succeed or fail, but Twelf terms are concrete certificates of successful searches that can be further manipulated.\n\nAnother way of making this point is to say that every logic program has both a ''declarative'' reading, in which we are asserting some facts about certain relations, and an ''operational'' reading, which specifies how the clause \"database\" is searched when a query is given.  Twelf signatures have similar readings: on the one hand, we can view a Twelf signature as specifying certain families of types and elements, representing data structures and relations with evidence; on the other, we can view a Twelf signature as a labeled logic program that specifies how to search for terms of a given type.\n\nThe Twelf server, besides being able to check Twelf source files for type-correctness, also has a logic-programming engine that can be used in three different ways:\n* It can be run stand-alone or as an inferior process as part of the Emacs interface and be used interactively, as a top-level loop, like most Prolog interpreters.  In this mode, you type in queries&mdash;which are just types, possibly with free variables (upper-case identifiers or, as we might call them, \"logic variables\")&mdash;and the Twelf server ''solves'' them, i.e., looks for elements of the given type.  If it finds any elements, it will print out a satisfying substitution for the free variables and give you the option of looking for more solutions.\n* As part of a Twelf source file, you can use a <tt>%query</tt> directive to search, in \"batch mode\", for a given number of solutions to a query, printing out satisfying substitutions if they exist.\n* Also as part of a Twelf source file, you can use a <tt>%solve</tt> directive to search for an element of a given type and define an identifier to be the first such element found.  You can also, with an accompanying <tt>%define</tt> directive, define identifiers to be the elements that get substituted for particular logic variables in the satisfying solution.\nSee the Twelf [[User's Guide]] for more information on interacting with the Twelf server using the top-level loop.  Here we will give some examples of using <tt>%query</tt>, <tt>%solve</tt>, and <tt>%define</tt>.  \n\n=== The <tt>%query</tt> directive ===\n\nThe format of a <tt>%query</tt> declaration is <tt>%query</tt>&nbsp;''solns''&nbsp;''tries''&nbsp;''type'', where ''solns'' is the expected number of solutions, ''tries'' is a limit to the number of solutions that will be listed (or \"<tt>*</tt>\" if there is no limit), and ''type'' is the type, possibly containing logic variables, of which Twelf will search for elements.  Of course, it only makes sense to speak of elements of real types, without free variables&mdash;we call them ''ground'' types&mdash;but the point is that, searching for elements of the given type using the declarations in the signature will cause these logic variables to be instantiated to particular terms, and it is discovering these substitutions that are the main purpose of the <tt>%query</tt> declaration.  Here are some examples:\n<twelf discard=\"true\" check=\"decl\">\n%query 1 1 dat sunday tuesday.   % Check that \"dat sunday tuesday\" has exactly one solution\n%query 1 1 dat monday X.         % Check that \"dat monday X\" has exactly one solution, and report the value of X\n%query 1 1 dat X monday.         % Same for the inverse relation\n%query 7 7 dat X Y.              % Check that \"dat X Y\" has exactly seven solutions\n%query 1 * dat X X.              % Look for at least one solution to \"dat X X\", FAILS!\n</twelf>\n\n=== The <tt>%solve</tt> and <tt>%define</tt> directives ===\n\nThe format of a <tt>%solve</tt> declaration is <tt>%solve</tt>&nbsp;''ident''&nbsp;<tt>:</tt>&nbsp;''type''.  This directive will search for a solution to the query (i.e., an element of the type) ''type'', and define ''ident'' to be this element.  Any logic variables in ''type'' will be instantiated, and you can seen them in the type when Twelf echoes the definition in its output, but they are not reported separately, as they are with the <tt>%query</tt> directive.  If you want to capture these instantiations of free variables as definitions, you can prefix the <tt>%solve</tt> directive with one or more <tt>%define</tt> directives, the format of which is <tt>%define</tt>&nbsp;''ident''&nbsp;<tt>=</tt>&nbsp;''var''&nbsp;<tt>:</tt>&nbsp;''type'', where ''ident'' is the identifier to be defined, ''var'' is the free variable in the subsequent <tt>%solve</tt> declaration whose instantiation you want to capture, and ''type'' is the type of that variable.  Please note that the <tt>%define</tt> directives do not end in a period (\"<tt>.</tt>\") but are the beginning part of a single <tt>%solve</tt> directive.  Here are some examples, the first of which repeats the definition of <tt>dat_sunday</tt> above, except that Twelf figures out the element (or \"evidence\") itself:\n<twelf discard=\"true\" check=\"decl\">\n%solve dat_sunday : dat sunday tuesday.\n\n%solve dat_monday : dat monday X.\n\n%define d = X : day\n%solve dat_tuesday : dat tuesday X.\n\n%define first_day = X : day\n%define second_day = Y : day\n%solve dat_first_second : dat X Y.\n</twelf>\nIn the first <tt>%solve</tt>, the identifier <tt>dat_sunday</tt> gets bound to <tt>dat_def&nbsp;next_day_sun&nbsp;next_day_mon</tt>.  In the second, <tt>X</tt> gets instantiated to <tt>wednesday</tt> (which we can see in the type <tt>dat&nbsp;monday&nbsp;wednesday</tt>) and <tt>dat_monday</tt> gets bound to <tt>dat_def&nbsp;next_day_mon&nbsp;next_day_tue</tt>.  In the next query, <tt>d</tt> gets bound to <tt>thursday</tt>, since this is what <tt>X</tt> gets instantiated to in the <tt>%solve</tt>, and <tt>dat_tuesday</tt> gets bound to <tt>dat_def&nbsp;next_day_tue&nbsp;next_day_wed</tt>.  Finally, in the last query, <tt>X</tt> and <tt>Y</tt> get instantiated to <tt>saturday</tt> and <tt>monday</tt> respectively, and <tt>first_day</tt> and <tt>second_day</tt> get bound to these, while <tt>dat_first_second</tt> gets bound to <tt>dat_def&nbsp;next_day_sat&nbsp;next_day_sun</tt>.\n\n=== Operational Semantics ===\n\nLet's look more closely at what Twelf does to solve a query, for this will clarify the operational meaning of a Twelf signature (see Section 5.5 of the [[User's Guide]] for more information).  First, some terminology.  A ''goal'' is a type, possibly involving free variables, for which we are interested in finding an element.  There are three kinds of goal:\n* an ''atomic'' goal, which is a fully-applied type family, i.e., a type constructor with a declaration like <tt>a&nbsp;:&nbsp;B1&nbsp;->&nbsp;...&nbsp;->&nbsp;Bm&nbsp;->&nbsp;type</tt> applied to <tt>m</tt> terms, such as <tt>a&nbsp;M1&nbsp;...&nbsp;Mm</tt>, resulting in a type;\n* a ''hypothetical'' goal, which is a type of the form <tt>A -> B</tt>, with <tt>A</tt> and <tt>B</tt> types; and\n* a ''parametric'' goal, which is a type of the form <tt>{x:A} B</tt>, where <tt>x</tt> occurs in <tt>B</tt> (if it does not, then <tt>{x:A}&nbsp;B</tt> is just <tt>A&nbsp;->&nbsp;B</tt>, and it is treated as a hypothetical goal).\nThe type families used in such goals are called ''predicates''. A value declaration in a signature that is available during search is called a ''clause''.  A clause will always have the form\n c : An -> ... -> A1 -> a M1 ... Mm.    % or, equivalently, c : a M1 ... Mm <- A1 <- ... <- An.\nwhere the atomic type <tt>a M1 ... Mm</tt> is the ''head'' of the clause and the atomic, hypothetical, or parametric types <tt>A1</tt> through <tt>An</tt> are the ''subgoals''.  Note, as mentioned in the comment, that Twelf allows us to write the arrows in these types in either orientation, with <tt>-></tt> associating to the right and <tt>&lt;-</tt> associating to the left.  The latter is especially useful from a logic-programming perspective, because it puts the head of the clause at the front and the subgoals linearly afterward, as is the case in Prolog (read the first back-arrow as <tt>:-</tt>, and read the rest of the back-arrows as commas).\n\nHow does Twelf go about solving a goal?  That is, given a type, possibly involving free variables, how does Twelf find a substitution instance for these variables and an element of the resulting type?  Here is a simplified description of the algorithm.  Throughout the search process, Twelf maintains several pieces of information:\n* a ''current substitution'' and ''element trace'', which are, respectively, a partial instantiation of the free variables in the query and a partial term of the resulting type;\n* a list of ''subgoals'', whose joint solution entails a solution to the original query; and\n* the ''context'', a list of both ''local assumptions'', which are goals that are temporarily assumed during the search, and ''local parameters'', which are new constants that are introduced during the search.\nTwelf also maintains a list of equational ''constraints'' that arise during unification and a stack of backtrack points that it will use to find alternate solutions, but we will not go into detail about these here.  Initially, the current substitution, element trace, and context are all empty, and the list of subgoals consists of a single element, namely the query itself.  The first element of the list of subgoals is the ''current subgoal''.  The search process consists of repeating the following steps:\n# if the list of subgoals is emtpy, then the current substitution and element trace are complete and provide a solution to the query;\n# otherwise, consider the current subgoal:\n#* if it is a hypothetical subgoal, of the form <tt>A -> B</tt>, then add <tt>A</tt> to the context as a local assumption and take <tt>B</tt> as the new current subgoal;\n#* if it is a parametric subgoal, of the form <tt>{x:A} B</tt>, then choose a new constant, say <tt>c</tt>, add <tt>c:A</tt> to the context as a local parameter, and take as the new current subgoal the result of replacing every instance of <tt>x</tt> in <tt>B</tt> with <tt>c</tt>;\n#* if it is an atomic subgoal, of the form <tt>a&nbsp;M1&nbsp;...&nbsp;Mm</tt>, then perform ''backchaining'':  look for a clause with a head that unifies with the subgoal; the resulting substitution is then \"composed\" with the current substitution, the element trace is updated using the constructor for the clause, and the current subgoal is replaced by the list of subgoals of the clause, in order from \"inside out\" (for example, in the clause for <tt>c</tt> displayed above, the order of subgoals is <tt>A1</tt>, ..., <tt>An</tt>, i.e., the order they appear when the clause is written with back-arrows, Prolog-style).  Clauses in the local assumptions are tried first, starting with the most recent assumption and proceeding to the earlier assumptions, and then the clauses from the signature are tried, in the order they appear in the input file.  As a result,\n#*# If a unifying clause is found, it is pushed onto the stack of backtrack points, so that if backtracking later reaches this point, a later unifying clause can be sought.\n#*# If no more clauses can be found to match the current subgoal, then backtrack: pop the stack of backtrack points and resume the previous search for a clause from that point;\n#*# If the stack of backtracking points is empty, then fail.\nNote, again, that this method is very similar to the method Prolog uses to solve a query.  The main difference is that each clause that gets used in a search results in its constructor becoming part of the partial term that is being constructed, so that when the search succeeds, we not only have an instantiation of the free variables in the query but also a term of the given type."
          },
          "sha1": "dyx9013yghblglgcjtc89ybdx4vfhad"
        }
      },
      {
        "title": "Simplifying dynamic clauses",
        "ns": 0,
        "id": 1769,
        "revision": {
          "id": 4822,
          "parentid": 4817,
          "timestamp": "2007-09-26T17:24:02Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "rv vandal",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 6100,
            "#text": "=== Summary ===\n\nWhen writing proofs about relations that introduce hypotheses, it is sometimes necessary to introduce dynamic clauses for the proof along with the hypothetical variable, to encode informal reasoning \"at the variable case\". In some cases, this reasoning is somewhat complicated, and can be streamlined by a judicious choice of lemma, so that the dynamic clause, while still present, is of a much simpler form, and the complicated reasoning is pushed to the top-level, where it can be more easily encoded.\n\n=== Example ===\n\nSuppose that we have lists of items, some of which may be colored red.\n\n<twelf name=\"basics\">\nelt : type.\ncherry : elt.\nstrawberry : elt.\nblueberry : elt.\n\nlist : type.\nnil : list.\ncons : elt -> list -> list.\n\nis-red : elt -> type.\nis-red/cherry : is-red cherry.\nis-red/strawberry : is-red strawberry.\n</twelf>\n\nA property that a list may satisfy is that all of its elements are red, which is encoded as follows:\n<twelf name=\"basics\" include=\"basics\">\nall-red : list -> type.\nall-red/nil : all-red nil.\nall-red/cons : all-red (cons H L) \n\t\t<- all-red L \n\t\t<- is-red H.\n</twelf>\n\nWe now define a nondeterministic function that take in a list, and outputs a list derived from the input by some combination of permutation, duplication, and dropping of its elements.\n\n<twelf name=\"basics\" include=\"basics\">\nmix : list -> list -> type.\nseed : elt -> type.\n\nmix/sow : (seed E -> mix L L') -> mix (cons E L) L'.\nmix/reap : mix nil L -> seed E -> mix nil (cons E L).\nmix/nil : mix nil nil.\n</twelf>\n\nThe behavior of <tt>mix</tt> is as follows: it decomposes the input list, turning every element <tt>E</tt> in it into a hypothesis of type <tt>seed E</tt>. Once the input list is empty, it builds up a new list by consing on some number of elements to the empty list, but each element must have come from some <tt>seed E</tt>. Since there is no restriction on how many times a hypothesis is used, the resulting list may have many (or one, or no) copies of each element in the original list, and in any order. However, since the function <tt>mix</tt> cannot introduce elements <I>ex nihilo</I>, we can state and prove some properties of it. For instance, when applied to an all-red list, it must yield an all-red list.\n\n<twelf name=\"basics\" include=\"basics\">\nmix-pres : mix L L'\n\t -> all-red L\n\t -> all-red L'\n\t -> type.\n%mode mix-pres +MIX +AR -AR'.\n</twelf>\n\n==== First proof ====\n\nIt can be proved in the following way:\n<twelf name=\"proof1\" include=\"basics\">\n- : mix-pres \n\t     (mix/sow ([s] MIX s)) \n \t     (all-red/cons RH AR)\n\t     AR'\n     <- ({sd:seed E} \n\t   {dynclause: {L: list} {Mix : mix nil L} {Ared:all-red nil} {Ared':all-red L}\n\t\t     mix-pres (mix/reap Mix sd) Ared (all-red/cons RH Ared')\n\t\t     <- mix-pres Mix Ared Ared'}\n\t   mix-pres (MIX sd) AR AR').\n\n- : mix-pres \n     mix/nil\n     all-red/nil\n     all-red/nil.\n</twelf>\n\nIn this proof of the theorem, the block of variables introduced includes a <I>dynamic clause</I> for the relation <tt>mix-pres</tt> that covers the variable case. It expresses the reasoning, \"if the last rule used to derive <tt>mix</tt> was <tt>mix-pres</tt> applied to the seed <tt>sd</tt> just introduced, then appeal to the induction hypothesis on the smaller derivation of <tt>mix</tt>\". Without this dynamic clause, coverage would fail, and the theorem would not go through.\n\n<twelf include=\"proof1\">\n%block b : some {E:elt} {RH:is-red E} block {sd:seed E}\n\t   {dynclause: {L: list} {Mix : mix nil L} {Ared:all-red nil} {Ared':all-red L}\n\t\t     mix-pres (mix/reap Mix sd) Ared (all-red/cons RH Ared')\n\t\t     <- mix-pres Mix Ared Ared'}.\n%worlds (b) (mix-pres _ _ _).\n%total X (mix-pres X _ _).\n</twelf>\n\nWriting dynamic clauses like this can be annoying, because Twelf's type reconstruction cannot be used to elide implicit &Pi;s. If we left a variable such as <tt>Mix</tt> implicitly quantified inside the dynamic clause, it would be quantified at the very outside, which would be incorrect. Moreover, some older versions of Twelf cannot check dynamic clauses that themselves have subgoals, as is the case here.\n\n==== Second proof ====\n\nWe can instead prove the same theorem in a different way, which has the advantage of working in older verisons of Twelf, and allowing more leverage of type reconstruction in any event, simplifying the presentation.\nThe technique is to introduce another lemma that makes explicit the invariant represented by the worlds declaration for the main theorem. In this case, we know that for every <tt>seed E</tt> in the context, there is a derivation <tt>RH</tt> of type <tt>is-red E</tt>.\n\n<twelf name=\"proof2\" include=\"basics\">\nhas-rh : seed E -> is-red E -> type.\n%mode has-rh +A -C.\n\n</twelf>\n\nThe proof of this theorem conists of one dynamic clause, which has no subgoals, and no &Pi;-quantification:\n\n<twelf name=\"proof2\" include=\"proof2\">\n%block b : some {E:elt} {RH:is-red E} block {sd:seed E}\n\t   {clause: has-rh sd RH}.\n\n%worlds (b) (has-rh _ _).\n%total X (has-rh X _).\n</twelf>\n\nHaving done that, the proof of the main theorem is simply\n<twelf name=\"proof2\" include=\"proof2\">\n- : mix-pres (mix/reap Mix SEED) Ared (all-red/cons RH Ared')\n     <- has-rh SEED RH\n     <- mix-pres Mix Ared Ared'.\n\n- : mix-pres\n\t     (mix/sow ([s] MIX s)) \n \t     (all-red/cons RH AR)\n\t     AR'\n     <- ({sd:seed E} \n\t   {dynclause: has-rh sd RH}\n\t   mix-pres(MIX sd) AR AR').\n\n- : mix-pres\n     mix/nil\n     all-red/nil\n     all-red/nil.\n\n%worlds (b) (mix-pres _ _ _).\n%total X (mix-pres X _ _).\n</twelf>\n\nNote how there is now an \"explicit variable case\", which covers any possible derivation <tt>SEED</tt> of <tt>seed E</tt>, and appeals to the above lemma <tt>has-rh</tt> in order to get the derivation of <tt>is-red H</tt>. The second case, which introduces a parametric <tt>sd : seed E</tt>, needs only supply the comparatively simple dynamic clause <tt>{dynclause: has-rh sd RH}</tt> to ensure the proof of <tt>has-rh</tt> goes through.\n\n<twelflink include=\"proof1\">Twelf code of first proof</twelflink><BR/>\n<twelflink include=\"proof2\">Twelf code of second proof</twelflink>\n\n{{tutorial}}"
          },
          "sha1": "jj7e4ntwmpbm04fdnbu0oiw0f15ylh1"
        }
      },
      {
        "title": "Simply-typed lambda calculus",
        "ns": 0,
        "id": 1819,
        "revision": {
          "id": 6071,
          "parentid": 4649,
          "timestamp": "2010-04-21T16:23:47Z",
          "contributor": {
            "ip": "134.157.168.46"
          },
          "comment": "fixed typo in of-lam",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 6669,
            "#text": "The '''simply-typed lambda calculus''' is a common example of a simple typed programming language. This article discusses its encoding in Twelf. \n\nIf you're trying to learn Twelf from this example, you may wish to read the discussion starting in {{proving|title=Representing the syntax of the STLC}}.  That introductory guide discusses this representation of the STLC and why it works in more detail.  This page summarizes the judgements of the STLC and the corresponding LF code for reference, but does not explain them in detail.\n\n== What is illustrated by this example? ==\n\nThere are simpler examples of LF representations (see, e.g., the [[natural numbers]]). However, the STLC is a good first example of a representation that uses [[higher-order abstract syntax]] and [[higher-order judgment]]s.  These two representation techniques drastically simplify the process of representing and proving theorems about \nmany programming languages and logics.  The idea is that the binding structure of LF is used to represent the binding structure of the object language.  At the level of syntax, this gives [[alpha-equivalence]] and capture-avoiding substitution \"for free\" from the representation.  At the level of judgements, this gives the properties of a [[hypothetical judgement]], such as weakening and substitution, for free.\n\nThis encoding of the STLC is adapted from ''Mechanizing Metatheory in a Logical Framework''<ref name=\"hl07mechanizing\">{{bibtex:hl07mechanizing}}</ref>.  Section 3 of that paper exhaustively discusses the [[adequacy]] of this encoding.\n\n== Encoding of syntax == \n\nThe types of the simply typed lambda calculus are simply the unit type and the arrow or function type.\n\n<math>\\texttt{}\\tau ::= \\texttt{unit} \\,|\\, \\tau_1 \\rightarrow \\tau_2</math>\n\n<twelf>\ntp : type.\narrow : tp -> tp -> tp.\nunit : tp.\n</twelf>\n\nThe terms are the variable <math>x</math>, the empty pair (which has type <tt>unit</tt>), lambda abstraction (with a type annotation), and application.\n\n<math>\\texttt{}e ::= x \\,|\\, \\langle\\rangle \\,|\\, \\lambda x :\\tau . e \\,|\\, e_1 e_2</math>\n<twelf>\ntm : type.\nempty : tm.\napp : tm -> tm -> tm.\nlam : tp -> (tm -> tm) -> tm.\n</twelf>\n\n== Encoding of judgments ==\n\n=== Static semantics ===\n\nThe typing rules for the simply typed lambda calculus use a typing context <math>\\texttt{}\\gamma</math> to record the type annotations that have been encountered at lambda-bindings. \n\n<math>{ \\; \\over \\gamma \\vdash \\langle\\rangle : \\texttt{unit}}\\,\\mbox{of-empty}</math>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \n<math>{ \\; \\over \\gamma, x : \\tau, \\gamma' \\vdash x : \\tau}\\,\\mbox{of-var}</math>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \n<math>{ \\gamma , x : \\tau_2 \\vdash e : \\tau \\over \\gamma \\vdash \\lambda x.e:(\\tau_2 \\rightarrow \\tau)}\\,\\mbox{of-lam}</math>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \n<math>{ \\gamma \\vdash e_1 : (\\tau_2 \\rightarrow \\tau) \\qquad \\gamma \\vdash e_2 : \\tau_2 \\over \\gamma \\vdash e_1 e_2 : \\tau}\\,\\mbox{of-app}</math>\n\nThis judgement is represented by the following LF signature:\n\n<twelf>\nof : tm -> tp -> type.\nof-empty : of empty unit.\nof-lam : of (lam T2 ([x] E x)) (arrow T2 T)\n          <- ({x: tm} of x T2 -> of (E x) T).\nof-app : of (app E1 E2) T\n          <- of E1 (arrow T2 T)\n          <- of E2 T2.\n</twelf>\n\nAssumptions <math>\\texttt{}x:\\tau</math> in the typing context <math>\\texttt{}\\gamma</math> are represented as a pair of objects <tt>x:tm</tt> and <tt>d:of&nbsp;x&nbsp;T</tt> in the LF context <math>\\texttt{}\\Gamma</math> (<tt>T</tt> is the LF representation of the type <math>\\texttt{}\\tau</math>). This can be seen in the encoding of the judgment <tt>of_lam</tt>. There is no need to write out the equivalent of the of-var rule, becuase the necessary judgment is directly assumed by the <tt>of-lam</tt> rule. This method avoids the need for a [[substitution lemma]], and the article on that subject discusses the matter further.\n\n=== Dynamic semantics ===\n\nWe define the dynamic semantics of the STLC by a call-by-value, left-to-right structural operational semantics on closed terms.  \n\nThe judgement <math>e \\; \\mathsf{value}</math> identifies the values:\n\n<math>{ \\; \\over \\mathsf{empty} \\; \\mathsf{value}} \\, \\mbox{value-empty}</math>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n<math>{ \\; \\over \\lambda x:\\tau.e \\; \\mathsf{value}} \\, \\mbox{value-empty}</math>\n\nNext, we define the operational semantics with a judgement <math>e \\mapsto e'</math>:\n\n<math>{e_1 \\mapsto e_1' \\over e_1 \\, e_2 \\mapsto e_1' \\, e_2} \\, \\mbox{step-app-1}</math>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n<math>{e_1 \\; \\mathsf{value} \\;\\;\\; e_2 \\mapsto e_2' \\over e_1 \\, e_2 \\mapsto e_1 \\, e_2'} \\, \\mbox{step-app-2}</math>\n\n<math>{e_2 \\; \\mathsf{value} \\over (\\lambda x:\\tau.e) \\, e_2 \\mapsto \\{e_2/x\\} e } \\mbox{step-app-beta}</math>\n\nThese judgments are represented by the following Twelf signature:\n\n<twelf>\nvalue : tm -> type.\nvalue-empty : value empty.\nvalue-lam : value (lam T ([x] E x)).\n\nstep : tm -> tm -> type.\nstep-app-1 : step (app E1 E2) (app E1' E2)\n              <- step E1 E1'.\nstep-app-2 : step (app E1 E2) (app E1 E2') \n              <- value E1\n              <- step E2 E2'.\nstep-app-beta : step (app (lam T2 ([x] E x)) E2) (E E2)\n                 <- value E2.\n</twelf>\n\nYou can <twelflink>see or download the full Twelf source</twelflink>, which is almost exactly that of Figure 7 and Figure 13 of ''Mechanizing Metatheory'' <ref name=\"hl07mechanizing\" />.  You can also <twelflink check=\"true\">see Twelf's output</twelflink>, which is closer to the LF code in Figure 7 and Figure 10 of that paper, because it makes the [[implicit parameter|implicit parameters]] explicit. Note that in Twelf's concrete syntax, curly brackets (<tt>{}</tt>) are used for pi-bindings instead of the <math>\\Pi</math> symbol.\n\n== Metatheorems ==\n\nSeveral metatheorems about this formulation of the simply typed lambda-calculus are proved on this wiki.  See, for example:\n* [[Proving metatheorems:Proving metatheorems about the STLC|Proving metatheorems about the STLC]] for a proof of type preservation\n* [[Output factoring]] for a proof of progress\n* [[Uniqueness lemma]]s for a proof of determinacy of the operational semantics\n* [[Proving metatheorems:Proving totality assertions in non-empty contexts|Proving totality assertions in non-empty contexts]] for a height judgement\n* [[Proving metatheorems:Proving metatheorems in non-empty contexts|Proving metatheorems in non-empty contexts]] for a proof that the height of a term can only be increased by substitution.\n\n== References ==\n\n<references/>"
          },
          "sha1": "7e9hkys9m904zxlauevl7qgcsykovub"
        }
      },
      {
        "title": "Software",
        "ns": 0,
        "id": 1667,
        "redirect": {
          "@title": "Download",
          "#text": null
        },
        "revision": {
          "id": 2403,
          "timestamp": "2006-10-06T16:26:09Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "[[Software]] moved to [[Download]]: Every other site in the world calls this page \"Download,\" we might as well.",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 22,
            "#text": "#REDIRECT [[Download]]"
          },
          "sha1": "ihiqqko676zphmtvlxefwtc3jqebbwz"
        }
      },
      {
        "title": "Strengthening",
        "ns": 0,
        "id": 1748,
        "revision": {
          "id": 4150,
          "parentid": 4145,
          "timestamp": "2007-03-15T20:36:40Z",
          "contributor": {
            "username": "JakeD",
            "id": 8
          },
          "comment": "/* Evaluation and preservation */",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 10056,
            "#text": "'''Strengthening''' lemmas prove that something which holds under assumptions also holds without them.\n\nWhen proving type families total using [[%total]], strengthening lemmas are sometimes necessary because Twelf estimates dependencies conservatively using the [[subordination]] relation.  Specifically, for Twelf's [[output coverage]] check to succeed, the output variables of higher-order premises must mention all assumptions of subordinate types.  If an assumption's type is subordinate to an output variable's type, but additional reasoning shows that the assumption cannot occur in the output variable in a particular case, you must prove a strengthening lemma expressing this reasoning.  \n\nIn this tutorial, we'll show a proof where the need for strengthening arises. We'll define a language with locations, stores which map locations to terms in the language, and a notion of well-formedness with respect to a store (no dangling references and no loops). Then we'll define evaluation for the language, and prove that well-formed terms evaluate to well-formed terms; we will need strengthening for this proof.\n\n== A little language with locations ==\n\nLocations and terms:\n\n<twelf name=\"prelude\">\nloc\t: type. %name loc _L.\n\nloc/z\t: loc.\nloc/s\t: loc -> loc.\n\ntm\t: type. %name tm _T.\n\ntm/loc\t: loc -> tm.\ntm/lam\t: (tm -> tm) -> tm.\ntm/app\t: tm -> tm -> tm.\n</twelf>\n\nThis is a silly little language; it has locations but no way to use them.\n\n(The <tt>[[%name]]</tt> declarations give a prefix which Twelf uses to name unnamed variables for display; we prefix the names with <tt>_</tt> so that it's clear which variables Twelf named, and also because Twelf will rename your variables if they collide with the naming prefix, which can be very confusing.)\n\nStores and store lookup:\n\n<twelf include=\"prelude\">\nst\t: type. %name st _S.\n\nst/nil\t: st.\nst/cons\t: loc -> tm -> st -> st.\n\nst-lookup\t: st -> loc -> tm -> type. %name st-lookup _Dlook.\n\nst-lookup/1\t: st-lookup (st/cons L T _) L T.\nst-lookup/2\t: st-lookup (st/cons L T S) L' T'\n\t\t   <- st-lookup S L' T'.\n</twelf>\n\nStores are just lists of location/term pairs. The lookup relation might look a little strange, since both <tt>st-lookup/1</tt> and <tt>st-lookup/2</tt> apply if <tt>L = L'</tt>, but for our purpose it is OK and this avoids having to define disequality of locations.\n\nWell-formedness of terms with respect to a store:\n\n<twelf include=\"prelude\">\ntm-wf\t: tm -> st -> type. %name tm-wf _Dwf.\n\ntm-var\t: tm -> type.\n\ntm-wf/var\t: tm-wf V S\n\t\t   <- tm-var V.\n\ntm-wf/loc\t: tm-wf (tm/loc L) S\n\t\t   <- st-lookup S L T\n\t\t   <- tm-wf T S.\n\ntm-wf/lam\t: tm-wf (tm/lam ([x:tm] T x)) S\n\t\t   <- ({v:tm}{d:tm-var v}\n\t\t\t tm-wf (T v) S).\n\ntm-wf/app\t: tm-wf (tm/app T1 T2) S\n\t\t   <- tm-wf T1 S\n\t\t   <- tm-wf T2 S.\n</twelf>\n\nA term is well-formed with respect to a store if its locations are all defined in the store, and if the terms bound to its locations are all well-formed with respect to the store.\n\nHow to define well-formedness of the open term that appears in the <tt>lam</tt> case? We assume some term, and mark it is a variable using <tt>tm-var</tt>, then check the well-formedness of the lambda body applied to this new term. Then we give a case saying that any term marked as a variable is well-formed.\n\nAn alternative would be to directly assume <tt>tm-wf v S</tt>. This example was extracted from the [[AML proof]], where we need to prove that if we have a store <tt>S'</tt> which extends <tt>S</tt>, and a term <tt>T</tt> is well-formed in <tt>S</tt>, then <tt>T</tt> is also well-formed in <tt>S'</tt>. That proof is difficult if we assume <tt>tm-wf v S</tt>, because we know nothing about <tt>v</tt> in <tt>S'</tt>. With the <tt>tm-var</tt> approach we can just apply the <tt>tm-wf/var</tt> rule to get <tt>tm-wf v S'</tt>.\n\nHowever, as we will see, this approach forces us to prove a substitution lemma, which requires the strengthening lemma.\n\n=== Evaluation and preservation ===\n\nNow, some evaluation semantics, and the preservation theorem:\n\n<twelf name=\"thm\" include=\"lemma3\" check=\"true\">\neval : tm -> tm -> type. %name eval _Deval.\n\neval/loc\t: eval (tm/loc L) (tm/loc L).\neval/lam\t: eval (tm/lam ([x:tm] T x)) (tm/lam ([x:tm] T x)).\neval/app\t: eval (tm/app T1 T2) T'\n\t\t   <- eval T1 (tm/lam ([x:tm] T1' x))\n\t\t   <- eval (T1' T2) T'.\n\neval-pres-wf\t: eval T T' -> tm-wf T S -> tm-wf T' S -> type.\n%mode eval-pres-wf +X1 +X2 -X3.\n\n-/loc\t: eval-pres-wf eval/loc D D.\n-/lam\t: eval-pres-wf eval/lam D D.\n-/app\t: eval-pres-wf (eval/app Deval2 Deval1) (tm-wf/app Dwf2 Dwf1) Dwf''\n\t   <- eval-pres-wf Deval1 Dwf1 (tm-wf/lam Dwf1')\n\t   <- tm-wf-subst Dwf1' Dwf2 Dwf'\n\t   <- eval-pres-wf Deval2 Dwf' Dwf''.\n\n%worlds () (eval-pres-wf _ _ _).\n%total D (eval-pres-wf D _ _).\n</twelf>\n\nEvaluation is just beta-reduction; we do nothing with locations.\n\nThe preservation theorem is straightforward, but we need to appeal to a substitution lemma. Let's see why: we have <tt>Dwf1' : {v:tm}{d:tm-var v} tm-wf (T1 v) S</tt> and <tt>Dwf2 : tm-wf T2 S</tt>; we need <tt>Dwf' : tm-wf (T1 T2) S</tt>. Now, had we defined <tt>tm-wf/lam</tt> to assume <tt>d:tm-wf v S</tt> instead of <tt>d:tm-var v</tt>, then we could just write <tt>(Dwf1' T2 Dwf2)</tt> in place of <tt>Dwf'</tt>. But, as previously noted, that gets us into a different kind of trouble. So we prove an explicit substitution lemma:\n\n<twelf name=\"block\" include=\"prelude\">\n%block tm-bind : block {v:tm}{d:tm-var v}.\n</twelf>\n\n<twelf name=\"lemma3\" include=\"lemma2\">\ntm-wf-subst\t:\n  ({v:tm}{d:tm-var v}\n     tm-wf (T1 v) S) ->\n  tm-wf T2 S ->\n%%\n  tm-wf (T1 T2) S ->\n  type.\n%mode tm-wf-subst +X1 +X2 -X3.\n\n-/app\t: tm-wf-subst ([v][d] tm-wf/app (Dwf2 v d) (Dwf1 v d)) Dwf (tm-wf/app Dwf2' Dwf1')\n\t   <- tm-wf-subst Dwf1 Dwf Dwf1'\n\t   <- tm-wf-subst Dwf2 Dwf Dwf2'.\n\n-/lam\t: tm-wf-subst ([v][d] tm-wf/lam (Dwf1 v d)) Dwf2 (tm-wf/lam Dwf1')\n\t   <- ({v':tm}{d':tm-var v'}\n\t\t tm-wf-subst ([v][d] Dwf1 v d v' d') Dwf2 (Dwf1' v' d')).\n\n-/loc\t: tm-wf-subst ([v][d] tm-wf/loc (Dwf1 v d) (Dlook v)) Dwf2 (tm-wf/loc Dwf1' Dlook')\n\t   <- st-lookup-strengthen Dlook Dlook' Deq\n\t   <- tm-wf-strengthen Dwf1 Deq Dwf1'.\n\n-/var\t: tm-wf-subst ([v][d] tm-wf/var d) Dwf Dwf.\n\n-/bind\t: tm-wf-subst ([v][d] Dwf) _ Dwf.\n\n%worlds (tm-bind) (tm-wf-subst _ _ _).\n%total D (tm-wf-subst D _ _).\n</twelf>\n\nThis lemma gives us exactly what we needed above.\n\nThe <tt>lam</tt> case is complicated only by the fact that we need to go under a binder; here <tt>v</tt> is the variable we're substituting for and <tt>v'</tt> is the bound variable. Since we call the lemma recursively under assumptions, we need to prove it in worlds where those assumptions are present.\n\nIn the <tt>var</tt> case we have found the variable we're substituting for. The <tt>bind</tt> case handles assumptions; there is no way to explicitly refer to them, but they are closed, so we can catch them with this case for closed terms.\n\nThe <tt>loc</tt> case is why we're here: Twelf determines that <tt>Dlook</tt> can depend on <tt>v</tt> and <tt>Dwf1</tt> on <tt>v</tt> and <tt>d</tt>, even though they can't. So we need two strengthening lemmas to get the terms we need.\n\nWhy can't <tt>Dlook</tt> and <tt>Dwf1</tt> depend on <tt>v</tt> and <tt>d</tt>? We are about to give proofs, but here is the intuition: The store <tt>S</tt> has no dependencies in the declaration of the lemma, and <tt>st-lookup</tt> just walks over the store, so <tt>Dlook</tt> has no dependencies; neither does the looked-up term. Now <tt>tm-wf</tt> just walks over the term looking up locations in the store, so it also has no dependencies.\n\n=== Strengthening lemmas ===\n\nHere is the first:\n\n<twelf name=\"lemma1\" include=\"block\">\ntm-eq\t: tm -> tm -> type.\ntm-eq_\t: tm-eq T T.\n\nst-lookup-strengthen :\n  ({v:tm} st-lookup S L (T v)) ->\n%%\n  st-lookup S L T' ->\n  ({v:tm} tm-eq (T v) T') ->\n  type.\n%mode st-lookup-strengthen +X1 -X2 -X3.\n\n-/1\t: st-lookup-strengthen ([v] st-lookup/1) st-lookup/1 ([v] tm-eq_).\n-/2\t: st-lookup-strengthen ([v] st-lookup/2 (Dlook v)) (st-lookup/2 Dlook') Deq\n\t   <- st-lookup-strengthen Dlook Dlook' Deq.\n\n%worlds (tm-bind) (st-lookup-strengthen _ _ _).\n%total D (st-lookup-strengthen D _ _).\n</twelf>\n\nIt would be nice if we could just get rid of the <tt>v</tt> assumption on the <tt>st-lookup</tt> derivation, but we have in addition that the returned term <tt>T</tt> can depend on <tt>v</tt>, so we must invent a new non-dependent <tt>T'</tt> and return an equality. Otherwise, this is a straightforward induction that demonstrates that we never use the assumption.\n\nThe second strengthening lemma is a little different:\n\n<twelf name=\"lemma2\" include=\"lemma1\">\ntm-wf-strengthen :\n  ({v:tm}{d:tm-var v} tm-wf (T v) S) ->\n  ({v:tm} tm-eq (T v) T') ->\n%%\n  tm-wf T' S ->\n  type.\n%mode tm-wf-strengthen +X1 +X2 -X3.\n\n-/app\t: tm-wf-strengthen ([v][d] tm-wf/app (Dwf2 v d) (Dwf1 v d)) ([v] tm-eq_) (tm-wf/app Dwf2' Dwf1')\n\t   <- tm-wf-strengthen Dwf2 ([v] tm-eq_) Dwf2'\n\t   <- tm-wf-strengthen Dwf1 ([v] tm-eq_) Dwf1'.\n\n-/lam\t: tm-wf-strengthen ([v][d] tm-wf/lam (Dwf v d)) ([v:tm] tm-eq_) (tm-wf/lam Dwf')\n\t   <- ({v':tm}{d':tm-var v'}\n\t\t tm-wf-strengthen ([v][d] Dwf v d v' d') ([v] tm-eq_) (Dwf' v' d')).\n\n-/loc\t: tm-wf-strengthen ([v][d] tm-wf/loc (Dwf v d) (Dlook v)) ([v] tm-eq_) (tm-wf/loc Dwf' Dlook')\n\t   <- st-lookup-strengthen Dlook Dlook' Deq\n\t   <- tm-wf-strengthen Dwf Deq Dwf'.\n\n-/bind\t: tm-wf-strengthen ([v][d] Dwf) _ Dwf.\n\n%worlds (tm-bind) (tm-wf-strengthen _ _ _).\n%total D (tm-wf-strengthen D _ _).\n</twelf>\n\nHere it is a priori possible that something of type <tt>tm-wf (T v) S</tt> could depend on <tt>v</tt> and <tt>d</tt> (e.g. it could be <tt>(tm-wf/var d)</tt>), but in conjunction with the equality it cannot. In the <tt>loc</tt> case we're doing essentially the same thing that we do in the substitution lemma, and must appeal to <tt>st-lookup-strengthen</tt> and <tt>tm-wf-strengthen</tt> (but we're not inducting over the well-formed term here). The coverage checker is able to rule out the <tt>var</tt> case since <tt>T</tt> does not depend on <tt>v</tt>.\n\n\n{{tutorial}}"
          },
          "sha1": "cxyzx6q0w50d9fnk9m10adxscnbsn8h"
        }
      },
      {
        "title": "Structural metric",
        "ns": 0,
        "id": 2006,
        "redirect": {
          "@title": "Structural metrics",
          "#text": null
        },
        "revision": {
          "id": 4871,
          "timestamp": "2007-10-03T15:54:17Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "Redirecting to [[Structural metrics]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 32,
            "#text": "#REDIRECT [[Structural metrics]]"
          },
          "sha1": "eevskztve10qnquc3khd5x3g131qu9t"
        }
      },
      {
        "title": "Structural metrics",
        "ns": 0,
        "id": 1712,
        "revision": {
          "id": 6201,
          "parentid": 6169,
          "timestamp": "2010-12-24T04:33:16Z",
          "contributor": {
            "ip": "70.10.11.138"
          },
          "comment": "confusing typo",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 9603,
            "#text": "Twelf is able to prove metatheorems using induction over a sub-term ordering on a particular input. However, there are some theorems you would like to prove where you want to induct on an object that is not necessarily a subterm of your induction position, but in some sense this object is \"smaller\". What you can do is define a metric describing the size of the input that you would like to induct on, and use a termination argument that uses the metric in the induction position. The first choice for a metric that comes to mind is the [[natural numbers]]; see the tutorial on [[numeric termination metrics]] for an example. Using the natural numbers as a metric has the advantage that you can [[Using nat-less with %reduces|use nat-less with %reduces]] in order to do strong induction. \n\nHowever, the natural numbers are not the only thing you can use as a metric. Oftentimes it is more convenient to use a metric that captures the structure of your derivations, instead of defining a numerical \"size\" or \"height\" with the natural numbers. Structural termination metrics correspond more closely to the original derivation, and they save you from having to prove [[%reduces]] lemmas for the auxiliary operations used to define a numerical metric.  Structural metrics for most [[type families]] are tree-like structures (but the structural metric for type families that look like lists is the natural numbers).  Typing derivations for lambda calculi are an obvious example of a type family whose structural metric resembles a tree.\n\nIn the following example, we will define a type family for colors and for trees with colors at the leaves. We will then mutually recursively define two recoloring operations over the colored trees. In order to show the [[effectiveness lemma]] for these recoloring operations, we will need to use a structural metric describing the shape of the colored trees as part of our induction. This technique is particularly important when proving properties about an operation that may change a derivation, but preserves \"shape\". \n\nWe will first define some colors and trees over colors.\n\n<twelf export=\"trees\">\ncolor : type.\n\ncolor/red   : color.\ncolor/blue  : color.\ncolor/white : color.\n\n\n\ncolortree : type.\n\ncolortree/node : colortree -> colortree -> colortree.\ncolortree/leaf : color -> colortree.\n</twelf>\n\nWe will also define two operations to recolor colors. We will use these operations to define two operations to recolor trees. Notice how they are defined mutually recursively. This mutual recursion in the definition is what will ultimately force us to require a metric. \n\n<twelf import=\"trees\">\nrecolor1 : color -> color -> type.\n\nrecolor1/rb : recolor1 color/red color/blue.\nrecolor1/bw : recolor1 color/blue color/white.\nrecolor1/wr : recolor1 color/white color/red.\n\n\n\nrecolor2 : color -> color -> type.\n\nrecolor2/rr : recolor2 color/red color/red.\nrecolor2/br : recolor2 color/blue color/red.\nrecolor2/wb : recolor2 color/white color/blue.\n\n\n\nrecolortree1 : colortree -> colortree -> type.\nrecolortree2 : colortree -> colortree -> type.\n\nrecolortree1/node : recolortree2 TA TA' \n                     -> recolortree1 TA' TA''\n                     -> recolortree1 (colortree/node TA TB) (colortree/node TA'' TB).\n\nrecolortree1/leaf : recolor1 C1 C2 -> recolortree1 (colortree/leaf C1) (colortree/leaf C2).\n\n\n\nrecolortree2/node : recolortree1 TB TB' \n                     -> recolortree2 TB' TB''\n                     -> recolortree2 (colortree/node TA TB) (colortree/node TA TB'').\n\nrecolortree2/leaf : recolor2 C1 C2 -> recolortree2 (colortree/leaf C1) (colortree/leaf C2).\n</twelf>\n\nAt a high level, we can see that the recoloring operations to not change the height or \"shape\" of the trees, just the coloring. So this operation should be total. We can easily show an [[effectiveness lemma]] for each of the recoloring operations for colors.\n\n<twelf import=\"trees\">\ncan-recolor1 : {C} recolor1 C C' -> type.\n%mode can-recolor1 +D -D1.\n\n- : can-recolor1 color/red recolor1/rb.\n\n- : can-recolor1 color/blue recolor1/bw.\n\n- : can-recolor1 color/white recolor1/wr.\n\n%worlds () (can-recolor1 _ _).\n%total {} (can-recolor1 _ _).\n\n\n\ncan-recolor2 : {C} recolor2 C C' -> type.\n%mode can-recolor2 +D -D1.\n\n- : can-recolor2 color/red recolor2/rr.\n\n- : can-recolor2 color/blue recolor2/br.\n\n- : can-recolor2 color/white recolor2/wb.\n\n%worlds () (can-recolor2 _ _).\n%total {} (can-recolor2 _ _).\n</twelf>\n\nCan we prove an effectiveness lemma about the recoloring operations for trees? We will pre-emptively avoid an early pitfull and try to prove both lemmas simultaneously (which is necessary because one must call the other).\n\n<twelf import=\"trees\">\ncan-recolortree1 : {T} {T'} recolortree1 T T' -> type.\n%mode can-recolortree1 +T -T' -D1.\n\ncan-recolortree2 : {T} {T'} recolortree2 T T' -> type.\n%mode can-recolortree2 +T -T' -D1.\n\n- : can-recolortree1 (colortree/node T1 T2) (colortree/node T1'' T2) (recolortree1/node D1 D2)\n     <- can-recolortree2 T1 T1' D1\n     <- can-recolortree1 T1' T1'' D2.\n\n% we can't even get the above case to pass termination checking\n\n%worlds () (can-recolortree1 _ _ _) (can-recolortree2 _ _ _).\n% %total (T) (can-recolortree1 T _ _) (can-recolortree2 T _ _).\n</twelf>\n\nWhat went wrong when in the above case? The first inductive call to <tt>can-recolortree2</tt> was valid. But in the second inductive call to <tt>can-recolortree2</tt> we had the ''output'' of the first inductive call in the induction position of the second call. This is not valid, because the tree that was outputted was not a sub-term of the input tree. So we will need a metric. It is possible to use a natural number representing the height or size of the tree as a metric, but for this particular proof such a metric would be a bit cumbersome, because we would need to know things about arithmetic to make the induction go through. Instead, we will exploit the fact that the \"shape\" of the tree is unchanged by the operations and use a tree metric describing the shape of the tree.\n\n<twelf import=\"trees\">\ntree : type.\n\ntree/node : tree -> tree -> tree.\ntree/leaf : tree.\n</twelf>\n\nThe type <tt>tree</tt> we've defined above describes trees with no interesting information at the nodes or leaves. They are only \"shapes\". We can relate <tt>colortrees</tt> to <tt>trees</tt> by shape. We can also prove an [[effectiveness lemma]] showing this operation is always possible.\n\n<twelf import=\"trees\">\ncolortree-shape : colortree -> tree -> type.\n\ncolortree-shape/node : colortree-shape T1 T1'\n                        -> colortree-shape T2 T2'\n                        -> colortree-shape (colortree/node T1 T2) (tree/node T1' T2').\n\ncolortree-shape/leaf : colortree-shape (colortree/leaf _) tree/leaf.\n\n\n\ncan-colortree-shape : {C} {T} colortree-shape C T -> type.\n%mode can-colortree-shape +C -T -D1.\n\n- : can-colortree-shape (colortree/node C1 C2) (tree/node T1 T2)\n     (colortree-shape/node D1 D2)\n     <- can-colortree-shape C1 T1 D1\n     <- can-colortree-shape C2 T2 D2.\n\n- : can-colortree-shape (colortree/leaf _) tree/leaf colortree-shape/leaf.\n\n%worlds () (can-colortree-shape _ _ _).\n%total (C) (can-colortree-shape C _ _).\n</twelf>\n\nWe will now use <tt>colortree</tt> to strengthen our induction hypothesis for the effectiveness of recoloring trees. We will use them to state that not only is it always possible to recolor a tree, but the resulting tree is always the same shape. We will induct over the structure of the <tt>tree</tt>.\n\n<twelf import=\"trees\">\ncan-recolortree1* : {T:tree} colortree-shape CT T\n                    -> colortree-shape CT' T\n                    -> recolortree1 CT CT' -> type.\n%mode can-recolortree1* +T +D1 -D2 -D3.\n\ncan-recolortree2* : {T:tree} colortree-shape CT T\n                    -> colortree-shape CT' T\n                    -> recolortree2 CT CT' -> type.\n%mode can-recolortree2* +T +D1 -D2 -D3.\n\n- : can-recolortree1* (tree/node T1 T2) (colortree-shape/node DCS1 DCS2)\n     (colortree-shape/node DCS1'' DCS2) (recolortree1/node DR1 DR2)\n     <- can-recolortree2* T1 DCS1 DCS1' DR1\n     <- can-recolortree1* T1 DCS1' DCS1'' DR2.\n\n- : can-recolortree1* tree/leaf colortree-shape/leaf \n     colortree-shape/leaf (recolortree1/leaf DR)\n     <- can-recolor1 _ DR.\n\n\n\n- : can-recolortree2* (tree/node T1 T2) (colortree-shape/node DCS1 DCS2)\n     (colortree-shape/node DCS1 DCS2'') (recolortree2/node DR1 DR2)\n     <- can-recolortree1* T2 DCS2 DCS2' DR1\n     <- can-recolortree2* T2 DCS2' DCS2'' DR2.\n\n- : can-recolortree2* tree/leaf colortree-shape/leaf \n     colortree-shape/leaf (recolortree2/leaf DR)\n     <- can-recolor2 _ DR.\n\n%worlds () (can-recolortree1* _ _ _ _) (can-recolortree2* _ _ _ _).\n%total (T1 T2) (can-recolortree1* T1 _ _ _) (can-recolortree2* T2 _ _ _).\n</twelf>\n\nNow we have proven effectiveness lemmas for the recoloring tree operations conditional on the fact that we can compute the size metric. Since we proved this is possible, we can write nicer versions of the lemmas that do not mention the metric. \n\n<twelf import=\"trees\" check=\"true\">\ncan-recolortree1 : {T} {T'} recolortree1 T T' -> type.\n%mode can-recolortree1 +T -T' -D1.\n\n- : can-recolortree1 CT _ DR\n     <- can-colortree-shape CT T DCS\n     <- can-recolortree1* T DCS _ DR.\n\n%worlds () (can-recolortree1 _ _ _).\n%total {} (can-recolortree1 _ _ _).\n\n\n\ncan-recolortree2 : {T} {T'} recolortree2 T T' -> type.\n%mode can-recolortree2 +T -T' -D1.\n\n- : can-recolortree2 CT _ DR\n     <- can-colortree-shape CT T DCS\n     <- can-recolortree2* T DCS _ DR.\n\n%worlds () (can-recolortree2 _ _ _).\n%total {} (can-recolortree2 _ _ _).\n</twelf>\n\n{{tutorial}}"
          },
          "sha1": "cgvm5t7c6apyqb68hkn3iqtgnw9ir4m"
        }
      },
      {
        "title": "Structural termination metrics",
        "ns": 0,
        "id": 1903,
        "redirect": {
          "@title": "Structural metrics",
          "#text": null
        },
        "revision": {
          "id": 4149,
          "timestamp": "2007-03-15T19:44:54Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "comment": "Redirecting to [[Structural metrics]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 32,
            "#text": "#REDIRECT [[Structural metrics]]"
          },
          "sha1": "eevskztve10qnquc3khd5x3g131qu9t"
        }
      },
      {
        "title": "Style guide",
        "ns": 0,
        "id": 1445,
        "redirect": {
          "@title": "Twelf style guide",
          "#text": null
        },
        "revision": {
          "id": 1593,
          "timestamp": "2006-09-06T14:23:55Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "[[Style guide]] moved to [[Twelf style guide]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 31,
            "#text": "#REDIRECT [[Twelf style guide]]"
          },
          "sha1": "k6sm6g7fzveo5by8zzpfy2mlae0e9v4"
        }
      },
      {
        "title": "Subordination",
        "ns": 0,
        "id": 1946,
        "revision": {
          "id": 7071,
          "parentid": 6039,
          "timestamp": "2013-05-19T09:13:23Z",
          "contributor": {
            "username": "Plmday",
            "id": 4356
          },
          "comment": "Removed a redundant definite article",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 1770,
            "#text": "A '''subordination relation''' determines when terms of one LF type may appear in terms of another.  Subordination is used in Twelf to determine how the inhabitants of a type change when considered in different LF contexts.\n\nTwelf infers a subordination relation from a signature.  For example, consider the following signature for the [[simply-typed lambda calculus]]:\n<twelf>\ntp : type.\nunit : tp.\narrow : tp -> tp -> tp.\n\ntm : type.\nempty : tm.\nlam : tp -> (tm -> tm) -> tm.\napp : tm -> tm -> tm.\n</twelf>\n\n{{needs|syntax consistent with Print.subord}}\n\nTwelf infers the following subordination relation:\n<pre>\ntm <| tm\ntp <| tp\ntp <| tm\n</pre>\nThis subordination relation says that <tt>tm</tt> is subordinate to <tt>tm</tt>, and <tt>tp</tt> is subordinate to <tt>tp</tt> and <tt>tm</tt>.  That is, terms can appear in terms, types can appear in types, and types can appear in terms, but terms cannot appear in types.  This makes sense for the language that we have given.  \n\nHowever, if we add dependent types to this object language, Twelf extends the subordination relation with\n<pre>\ntm <| tp\n</pre>\nbecause now terms may appear in types.\n\n{{needs|a formal account of subordination}}\n\nSubordination has several uses, including:\n* It enables modular [[adequacy]] proofs.\n* It enables a Twelf [[metatheorem]] that is proved for one set of LF contexts to be reused in other sets of contexts.  This is called [[world subsumption]].\nThe reason is that subordination gives rise to a general condition under which the terms of a type remain invariant when the type is considered in different LF contexts.  Roughly, the terms of a type are invariant when the context is changed by adding or deleting declarations that are '''not''' subordination to that type.  \n\n{{stub}}"
          },
          "sha1": "90zb8ptyi9intw78zknh25excd8058c"
        }
      },
      {
        "title": "Substitution",
        "ns": 0,
        "id": 1505,
        "redirect": {
          "@title": "Substitution lemma",
          "#text": null
        },
        "revision": {
          "id": 1965,
          "timestamp": "2006-09-26T19:58:00Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "comment": "redir to lemma page",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 32,
            "#text": "#REDIRECT [[substitution lemma]]"
          },
          "sha1": "tg5t4zb0w92dfz7eyhkfdfohoxrzyak"
        }
      },
      {
        "title": "Substitution Lemma",
        "ns": 0,
        "id": 1499,
        "redirect": {
          "@title": "Substitution lemma",
          "#text": null
        },
        "revision": {
          "id": 1908,
          "timestamp": "2006-09-25T04:01:08Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "[[Substitution Lemma]] moved to [[Substitution lemma]]: pages should be downcase",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 32,
            "#text": "#REDIRECT [[Substitution lemma]]"
          },
          "sha1": "0e4qg5o74bbfzyjy7u9sq8xlnhb0pjg"
        }
      },
      {
        "title": "Substitution lemma",
        "ns": 0,
        "id": 1493,
        "revision": {
          "id": 8116,
          "parentid": 8108,
          "timestamp": "2016-02-10T15:40:12Z",
          "contributor": {
            "username": "Boyland",
            "id": 17
          },
          "comment": "Undo SPAM revision 8108 by [[Special:Contributions/122.102.45.251|122.102.45.251]] ([[User talk:122.102.45.251|talk]])",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 11973,
            "#text": "Type-preserving '''substitution''' is the property of a hypothetical judgment that if Γ, x : A {{vdash}} M(x) : B and Γ {{vdash}} N : A, then Γ, {{vdash}} M(N) : B. In other words, if we have a well-typed term M(x) that depends on a hypothesis x of type A, and we have a well-typed term N : A, then we can substitute N for the variable x within M to produce a well-typed term that does not depend on x.\n\nDepending on how the type system of an object language is encoded, there are a number of different techniques for proving a '''substitution lemma''' for the language.\n== Substitution via application in LF ==\n\nWhen an object language is encoded using [[higher-order judgements|higher-order representations of hypothetical judgements]], substitution comes for free: object-language variables and typing assumptions are represented by LF lambdas, so substitution follows from LF application.\n\nConsider the following encoding of a simply typed λ-calculus:\n\n<twelf import=\"application\">\n%% Syntax\n\ntp : type.\n\ntp/unit  : tp.\ntp/arrow : tp -> tp -> tp.\n\nexp : type.\n\nexp/unit : exp.\nexp/lam  : tp -> (exp -> exp) -> exp.\nexp/app  : exp -> exp -> exp.\n\n%% Typing judgement\n\nof : exp -> tp -> type.\n\nof/unit : of exp/unit tp/unit.\n\nof/lam  : of (exp/lam T E) (tp/arrow T T')\n           <- ({x:exp} of x T\n                -> of (E x) T').\n\nof/app  : of (exp/app E1 E2) T'\n           <- of E2 T\n           <- of E1 (tp/arrow T T').\n</twelf>\n\nWe can give a direct proof of substitution:\n\n<twelf import=\"application\"  check=true>\nsubst   : of E1 T\n           -> ({x:exp}{dx:of x T} of (E2 x) T')\n           -> of (E2 E1) T'\n           -> type.\n%mode subst +D1 +D2 -D3.\n\n- : subst D1 D2 (D2 E1 D1).\n\n%block of-block : some {T:tp} block {x:exp}{dx:of x T}.\n%worlds (of-block) (subst _ _ _).\n%total {} (subst _ _ _).\n</twelf>\n\nThe typing derivation for the substitution is created by applying the LF function <tt>D2</tt>, which represents the hypothetical typing derivation, to the LF term <tt>D1</tt>, which represents the typing derivation for the substituted term.  \n\nAlthough we proved substitution as a metatheorem <tt>subst</tt> here, in practice it is unnecessary to state substitution as a lemma. The substitution can be performed via application whenever it is necessary.\n\n== Substitution lemmas with a \"var\" rule ==\n<!-- This section heading is referred to by name in following articles:\n\nExchange lemma\n\nIf you change the heading, be sure to change the reference on those pages -->\n\nIn the above language, there was no explicit typing rule in the system for typing variables. Instead, typing derivations for variables were put directly into the LF context. However, for some languages it is necessary to use separate judgments for assumptions about variables and for typing derivations. This is common for languages with references and stores which require a lemma that shows it is admissible to weaken typing derivations with respect to the store. \n\nIn the following example, the <tt>assm</tt> judgment is used in conjunction with the <tt>oftp/var</tt> rule to give <tt>of</tt> typing derivations for variables. A derivation of <tt>{x:exp} assm x T -> of (E2 x) T'</tt> and a derivation of <tt>of E1 T</tt> ''cannot'' be used to show <tt>of (E2 E1) T'</tt> via application in LF. This is because a hypothetical judgment expecting an <tt>assm</tt> derivation cannot be applied to an <tt>of</tt> derivation. That is, the LF representation does not directly tell us that substitution holds, as the assumption is of a different type.\n\nHowever, in this case, the desired substitution principle can be proved via an induction over the structure of the hypothetical judgment. The key to making the following proof work is the fact that [[exchange]] is admissible for this language via its encoding in LF. In general, exchange is admissible whenever assumptions about variables cannot depend on assumptions earlier in the context.\n\nHere is an encoding that uses a different judgement for assumptions:\n<twelf import=\"var\">\n%% Syntax\n\ntp : type.\n\ntp/unit  : tp.\ntp/arrow : tp -> tp -> tp.\n\nexp : type.\n\nexp/unit : exp.\nexp/lam  : tp -> (exp -> exp) -> exp.\nexp/app  : exp -> exp -> exp.\n\n%% Typing judgements\n\nassm : exp -> tp -> type.\nof : exp -> tp -> type.\n\nof/var  : of E T\n           <- assm E T.\n\nof/unit : of exp/unit tp/unit.\n\nof/lam  : of (exp/lam T E) (tp/arrow T T')\n           <- ({x:exp} assm x T\n                -> of (E x) T').\n\nof/app  : of (exp/app E1 E2) T'\n           <- of E2 T\n           <- of E1 (tp/arrow T T').\n</twelf>\n\nNow, we prove the substitution theorem:\n\n<twelf import=\"var\">\nsubst   : of E1 T\n           -> ({x:exp}{dx:assm x T} of (E2 x) T')\n           -> of (E2 E1) T'\n           -> type.\n%mode subst +D1 +D2 -D3.\n\n% case for substituting out the assumption\n\n- : subst D1 ([x][dx] of/var dx) D1.\n\n% catch-all case for of/unit or instances of of/var for a different assumption\n\n- : subst D1 ([x][dx] D2) D2.\n</twelf>\n\nThe following case is the key for the proof of this metatheorem. It works because the language admits the property of exchange.\n\nIn the following case, D2 has the type\n<twelf discard=\"true\">\n{x:exp}{dx:of x T}{y:exp}{dy:of y T'} of (E' x y) T''\n</twelf>\nThe principle of exchange can be applied to produce a derivation of\n<twelf discard=\"true\">\n{y:exp}{dy:of y T'}{x:exp}{dx:of x T} of (E' x y) T''\n</twelf>\nOn the inductive call to subst, the assumptions \n<twelf discard=\"true\">{y:exp}{dy:of y T'}\n</twelf> \nare pushed into the LF context, so that a derivation of type\n\n<twelf discard=\"true\">\n{x:exp}{dx:of x T} of (E' x y) T''\n</twelf>\n\ncan be given as the second argument to the inductive call.\n\n<twelf import=\"var\" check=true>\n- : subst D1 ([x][dx] of/lam ([y][dy] D2 x dx y dy)) (of/lam D2')\n     <- ({y}{dy} subst D1 ([x][dx] D2 x dx y dy) (D2' y dy)).\n\n- : subst D1 ([x][dx] of/app (D2 x dx) (D3 x dx)) (of/app D2' D3')\n     <- subst D1 D2 D2'\n     <- subst D1 D3 D3'.\n\n%block assm-block : some {T:tp} block {x:exp}{dx:assm x T}.\n%worlds (assm-block) (subst _ _ _).\n%total (D1) (subst _ D1 _).\n</twelf>\n\n== Substitution lemmas with dependent types [Advanced topic] ==\n\nThe preceding technique for showing substitution lemmas works fine for systems without dependent types. However, it would not work for a system with dependent types, because its typing assumptions could not admit exchange, in general. A recent discovery is that a similarly general technique is available for languages with dependent types and a var rule, despite the apparent absence of an exchange property. Of course, if the system has the same judgment for assumptions and typing derivations, then substitution can be performed via application in LF.\n\nThe following example studies a very simple singleton calculus with the dependent Π type for functions. The presence of dependent types means typing assumptions about expressions can depend on expression variables introduced in earlier assumptions. \n\n[[Explicit contexts]] could be used to do substition in this case, but this technique is much simpler in practice.\n\n<twelf import=\"depvar\">tp : type.\nexp : type.\n\ntp/sing  : exp -> tp.\ntp/unit  : tp.\ntp/pi    : tp -> (exp -> tp) -> tp.\n\n\n\nexp/unit : exp.\nexp/lam  : tp -> (exp -> exp) -> exp.\nexp/app  : exp -> exp -> exp.\n\n\n\nassm : exp -> tp -> type.\n\n\n\nof : exp -> tp -> type.\n\nof/var  : of E T\n           <- assm E T.\n\nof/unit : of exp/unit tp/unit.\n\nof/lam  : of (exp/lam T E) (tp/pi T T')\n           <- ({x:exp} assm x T\n                -> of (E x) (T' x)).\n\nof/app  : of (exp/app E1 E2) (T' E2)\n           <- of E2 T\n           <- of E1 (tp/pi T T').\n\nof/sing : of E (tp/sing E)\n           <- of E tp/unit.\n\n\n\n%block assm-block : some {T:tp} block {x:exp}{dx:assm x T}.\n</twelf>\n\nThe following metatheorem is actually true, but the naive attempt at proving it will fail.\n\n<twelf import=\"depvar\">\nsubst-wontwork   : of E1 T\n                    -> ({x:exp}{dx:assm x T} of (E2 x) (T' x))\n                    -> of (E2 E1) (T' E1)\n                    -> type.\n%mode subst-wontwork +D1 +D2 -D3.\n\n% case for substituting out the assumption\n\n- : subst-wontwork D1 ([x][dx] of/var dx) D1.\n\n% catch-all case for of/unit or instances of of/var for a different assumption\n\n- : subst-wontwork D1 ([x][dx] D2) D2.\n\n- : subst-wontwork D1 ([x][dx] of/app (D2 x dx) (D3 x dx)) (of/app D2' D3')\n     <- subst-wontwork D1 D2 D2'\n     <- subst-wontwork D1 D3 D3'.\n\n- : subst-wontwork D1 ([x][dx] of/sing (D2 x dx)) (of/sing D2')\n     <- subst-wontwork D1 D2 D2'.\n</twelf>\n\nThe proof fails because this case is not general enough to cover all lambdas. Specifically, this case only applies if the type assigned to the variable y does not depend on the variable x.\n\n<twelf import=\"depvar\" check=decl discard=true>\n- : subst-wontwork D1 ([x][dx] of/lam ([y][dy:assm y T'] D2 x dx y dy)) (of/lam D2')\n     <- ({y}{dy} subst-wontwork D1 ([x][dx] D2 x dx y dy) (D2' y dy)).\n\n%worlds (assm-block) (subst-wontwork _ _ _).\n%total (D1) (subst-wontwork _ D1 _).\n</twelf>\n\nIn the blocker case for the above proof attempt, the problem was that\nnew assumptions could depend on the x. However, E1 is going to be\nsubstituted in for x anyway. If it is substituted in first, then these\ndependencies disappear. What remains is to show that we can swap in a\nderivation for of E1 T into a derivation of (assm E1 T -> of (E2 E1) (T' E1)).\n\nIn the statement of the following metatheorem, (E2 E1) and (T' E1) \nare generalized by the schematic variables E3 and T'', respectively.\n\n<twelf import=\"depvar\">\nsubst* : of E1 T\n          -> (assm E1 T -> of E3 T'')\n          -> of E3 T''\n          -> type.\n%mode subst* +D1 +D2 -D3.\n\n% case for substituting out the assumption\n\n- : subst* D1 ([dx] of/var dx) D1.\n\n% catch-all case for of/unit or instances of of/var for a different assumption\n\n- : subst* D1 ([dx] D2) D2.\n\n- : subst* D1 ([dx] of/app (D2 dx) (D3 dx)) (of/app D2' D3')\n     <- subst* D1 D2 D2'\n     <- subst* D1 D3 D3'.\n\n- : subst* D1 ([dx] of/sing (D2 dx)) (of/sing D2')\n     <- subst* D1 D2 D2'.\n\n- : subst* D1 ([dx] of/lam ([y][dy] D2 dx y dy)) (of/lam D2')\n     <- ({y}{dy} subst* D1 ([dx] D2 dx y dy) (D2' y dy)).\n\n%worlds (assm-block) (subst* _ _ _).\n%total (D1) (subst* _ D1 _).\n</twelf>\n\nHaving proved the preceding lemma, the general substitution principle can be proven by first substituting E1 in for x, and then applying subst* to eliminate the dependency on assm E1 T.\n\n<twelf import=\"depvar\" check=\"true\">\nsubst : of E1 T\n         -> ({x:exp}{dx:assm x T} of (E2 x) (T' x))\n         -> of (E2 E1) (T' E1)\n         -> type.\n%mode subst +D1 +D2 -D3.\n\n- : subst (D1 : of E1 T) (D2 : {x} {dx:assm x T} of (E2 x) (T' x)) D2'\n     <- subst* D1 (D2 E1) D2'.\n\n%worlds (assm-block) (subst _ _ _).\n%total {} (subst _ _ _).</twelf>\n\n=== Remarks about adequacy ===\n\nThe reader may have concerns as to whether this proof technique affects [[adequacy]] for the object language. Although the second input to the <tt>subst*</tt> is not an adequate encoding of a typing derivation that makes a proper extension to the LF context (because it is missing an <tt>{x:exp}</tt> argument), the result is a valid typing derivation in the object logic. <tt>subst*</tt> is a correct lemma about LF terms of a particular form. Doing a proof of <tt>subst</tt> using <tt>subst*</tt> does not \"break\" the object language in any way, because 1) the deviations from adequate encodings occured only in intermediate stages of the proof and 2) the proof produces results that are adequate encodings of the object language.\n\n=== Comparison to the POPLMark 1a narrowing proof ===\n\nThis technique is similar to how the narrowing lemma was proven for POPLMark challenge 1a. However, because we are proving a substitution lemma instead of narrowing the type of a variable, we have an actual term to substitute in for the variable. Because the variable can be substituted away and does not have to be put into the LF context, this proof does not need to deal with any special worlds.\n \n\n{{tutorial}}"
          },
          "sha1": "3zb7b3xdjrhwb5eg5vwhujz4w5k6m56"
        }
      },
      {
        "title": "Sudoku",
        "ns": 0,
        "id": 2005,
        "revision": {
          "id": 4868,
          "timestamp": "2007-10-02T22:12:51Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "comment": "just pasted code, finish later",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 5768,
            "#text": "[[Image:sudokuexample.svg|thumb|right|300px|Example Sudoku puzzle]]\nIn the '''Sudoku''' puzzle, a 9x9 board must be filled with the numbers <math>1 \\ldots 9</math> such that no row, column, or box contains the same digit twice.\n\n{{needs|to be completed}}\n\n<twelf>\n% Sudoku solver, brute force\n\ncell : type.\n1 : cell.\n2 : cell.\n3 : cell.\n4 : cell.\n5 : cell.\n6 : cell.\n7 : cell.\n8 : cell.\n9 : cell.\n\nnat : type.\nz : nat.\ns : nat -> nat. %prefix 5 s.\nnine = s s s  s s s  s s s z.\n\ncells : nat -> type.\n//  : cell -> cells N -> cells (s N).\n%infix right 5 //.\nnil : cells z.\n\ncellss : nat -> type.\n///  : cells nine -> cellss N -> cellss (s N).\n%infix right 4 ///.\nnill : cellss z.\n\nremove : cells (s N) -> cell -> cells N -> type.\n%mode remove +L +C -L'.\n\nrem-hit  : remove (X // C) X C.\n% okay that we can also skip this one\nrem-miss : remove (X // C) Y (X // C')\n        <- remove C Y C'.\n\n%worlds () (remove _ _ _).\n%terminates D (remove D _ _).\n\nnodups : cells X -> cells Y -> type.\n%mode nodups +OK +L.\n\nnd-nil  : nodups _ nil.\nnd-hit  : nodups OK (X // C)\n       <- remove OK X OK'\n       <- nodups OK' C.\n\n%worlds () (nodups _ _).\n%terminates D (nodups _ D).\n\n% valid if there are no duplicates\nallcells = 1 // 2 // 3 //\n           4 // 5 // 6 //\n           7 // 8 // 9 // nil.\n\nunitok : cells nine -> type.\n\nuo : unitok C\n  <- nodups allcells C.\n\n% the nine rows\n%abbrev board = cellss nine.\n\n% extract three boxes from three rows\nboxes : cells nine -> cells nine -> cells nine ->\n        cells nine -> cells nine -> cells nine -> type.\n%mode boxes +A +B +C -A' -B' -C'.\n\nb : boxes\n      (A1 // B1 // C1  //  D1 // E1 // F1  //  G1 // H1 // I1  //  nil)\n      (A2 // B2 // C2  //  D2 // E2 // F2  //  G2 // H2 // I2  //  nil)\n      (A3 // B3 // C3  //  D3 // E3 // F3  //  G3 // H3 // I3  //  nil)\n%\n      (A1 // B1 // C1 //\n       A2 // B2 // C2 //\n       A3 // B3 // C3 // nil)\n%\n      (D1 // E1 // F1 //\n       D2 // E2 // F2 //\n       D3 // E3 // F3 // nil)\n%\n      (G1 // H1 // I1 //\n       G2 // H2 // I2 //\n       G3 // H3 // I3 // nil).\n\n%worlds () (boxes _ _ _  _ _ _).\n%total {} (boxes _ _ _  _ _ _).\n\n% transpose a whole board\ntranspose : board -> board -> type.\n%mode transpose +B -B'.\n\ntr : transpose ((A1 // B1 // C1 // D1 // E1 // F1 // G1 // H1 // I1 // nil) ///\n                (A2 // B2 // C2 // D2 // E2 // F2 // G2 // H2 // I2 // nil) ///\n                (A3 // B3 // C3 // D3 // E3 // F3 // G3 // H3 // I3 // nil) ///\n                (A4 // B4 // C4 // D4 // E4 // F4 // G4 // H4 // I4 // nil) ///\n                (A5 // B5 // C5 // D5 // E5 // F5 // G5 // H5 // I5 // nil) ///\n                (A6 // B6 // C6 // D6 // E6 // F6 // G6 // H6 // I6 // nil) ///\n                (A7 // B7 // C7 // D7 // E7 // F7 // G7 // H7 // I7 // nil) ///\n                (A8 // B8 // C8 // D8 // E8 // F8 // G8 // H8 // I8 // nil) ///\n                (A9 // B9 // C9 // D9 // E9 // F9 // G9 // H9 // I9 // nil) /// nill)\n%\n               ((A1 // A2 // A3 // A4 // A5 // A6 // A7 // A8 // A9 // nil) ///\n                (B1 // B2 // B3 // B4 // B5 // B6 // B7 // B8 // B9 // nil) ///\n                (C1 // C2 // C3 // C4 // C5 // C6 // C7 // C8 // C9 // nil) ///\n                (D1 // D2 // D3 // D4 // D5 // D6 // D7 // D8 // D9 // nil) ///\n                (E1 // E2 // E3 // E4 // E5 // E6 // E7 // E8 // E9 // nil) ///\n                (F1 // F2 // F3 // F4 // F5 // F6 // F7 // F8 // F9 // nil) ///\n                (G1 // G2 // G3 // G4 // G5 // G6 // G7 // G8 // G9 // nil) ///\n                (H1 // H2 // H3 // H4 // H5 // H6 // H7 // H8 // H9 // nil) ///\n                (I1 // I2 // I3 // I4 // I5 // I6 // I7 // I8 // I9 // nil) /// nill).\n%worlds () (transpose _ _).\n%total {} (transpose C _).\n\nboardok : board -> type.\n\nbo : boardok\n     (A /// B /// C /// D /// E /// F /// G /// H /// I /// nill)\n% rows\n  <- unitok A <- unitok B <- unitok C\n  <- unitok D <- unitok E <- unitok F\n  <- unitok G <- unitok H <- unitok I\n% boxes\n  <- boxes A B C  Ab Bb Cb\n  <- unitok Ab <- unitok Bb <- unitok Cb\n  <- boxes D E F  Db Eb Fb\n  <- unitok Da <- unitok Ea <- unitok Fa\n  <- boxes G H I  Gb Hb Ib\n  <- unitok Gb <- unitok Hb <- unitok Ib\n% cols\n  <- transpose (A  /// B  /// C  /// D  /// E  /// F  /// G  /// H  /// I  /// nill)\n               (At /// Bt /// Ct /// Dt /// Et /// Ft /// Gt /// Ht /// It /// nill)\n  <- unitok At <- unitok Bt <- unitok Ct\n  <- unitok Dt <- unitok Et <- unitok Ft\n  <- unitok Gt <- unitok Ht <- unitok It.\n\n%solve _ : boardok\n(\n(8 // 2 // 6  //  7 // 1 // 4  //  9 // 5 // 3  // nil) ///\n(3 // 4 // 5  //  8 // 6 // 9  //  2 // 1 // 7  // nil) ///\n(9 // 7 // 1  //  2 // 5 // 3  //  4 // 8 // 6  // nil) ///\n\n(1 // 6 // 3  //  9 // 2 // 5  //  7 // 4 // 8  // nil) ///\n(5 // 9 // 4  //  6 // 7 // 8  //  1 // 3 // 2  // nil) ///\n(2 // 8 // 7  //  3 // 4 // 1  //  5 // 6 // 9  // nil) ///\n\n(7 // 5 // 9  //  4 // 3 // 6  //  8 // 2 // 1  // nil) ///\n(4 // 3 // 2  //  1 // 8 // 7  //  6 // 9 // 5  // nil) ///\n(6 // 1 // 8  //  5 // 9 // 2  //  3 // 7 // 4  // nil) /// nill).\n\n%solve _ : boardok\n(\n(8 // 2 // 6  //  7 // 1 // 4  //  9 // 5 // 3 // nil) ///\n(3 // 4 // 5  //  8 // 6 // 9  //  2 // 1 // 7  // nil) ///\n(9 // 7 // 1  //  2 // 5 // 3  //  4 // 8 // 6  // nil) ///\n\n(1 // 6 // 3  //  _ // 2 // 5  //  7 // 4 // 8  // nil) ///\n(5 // 9 // 4  //  _ // 7 // 8  //  1 // 3 // 2  // nil) ///\n(2 // 8 // 7  //  _ // _ // 1  //  5 // 6 // 9  // nil) ///\n\n(7 // 5 // 9  //  4 // 3 // 6  //  8 // 2 // 1  // nil) ///\n(4 // 3 // 2  //  1 // 8 // 7  //  6 // 9 // 5  // nil) ///\n(6 // 1 // 8  //  5 // 9 // 2  //  3 // 7 // 4  // nil) /// nill).\n</twelf>\n\n<twelflink>All code from this tutorial</twelflink>. <twelflink check=\"true\">Twelf's output from this tutorial</twelflink>.\n\n\n{{case study}}[[Category:Twelf code]]"
          },
          "sha1": "204rx8yhw3lr6gisqd0bwagp33y78ia"
        }
      },
      {
        "title": "Summer school 2008",
        "ns": 0,
        "id": 2052,
        "revision": {
          "id": 5371,
          "parentid": 5370,
          "timestamp": "2008-07-30T16:07:29Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 3307,
            "#text": "__NOTOC__\nThis page contains course materials for the Twelf course at [http://www.cs.uoregon.edu/research/summerschool/summer08/ the University of Oregon Summer School on Logic and Theorem Proving in Programming Languages, July 2008].  In this course, you will learn to represent [[deductive system]]s in [[LF]] and prove [[metatheorem]]s about them with [[About The Twelf Project|Twelf]].\n\n== New: Feedback Form ==\n\nPlease fill out our [http://gs4080.sp.cs.cmu.edu/servlets/summerschool2008/feedback.ss feedback form]!\n\n== Get Twelf ==\n\nPre-built binaries of Twelf are available for most operating systems through the [http://twelf.plparty.org/builds Twelf Night(ly)].\n* [http://twelf.plparty.org/builds/twelf-linux.tar.gz Linux (tgz)]\n* [http://twelf.plparty.org/builds/twelf.exe Windows (exe)]\n* [http://twelf.plparty.org/builds/twelf-osx-intel.dmg Mac OS 10.4 or 10.5 (Intel only) (dmg)]\n\nOtherwise:\n* you can build Twelf from the [http://twelf.plparty.org/builds/twelf-src.tar.gz source tarball].  You will need [http://www.mlton.org MLton] or [http://www.smlnj.org sml/nj]. \n* you can make yourself an account on the wiki, and do the exercises on your User:<login> page (linked at the top after you log in).\n\nThen see [[Twelf with Emacs]] for the basics of interacting with Twelf.  (You can also use [[Twelf without Emacs]], by interacting with the Twelf server directly.)\n\n== Lectures and Labs [http://www.cs.cmu.edu/~rwh/talks/UO_Summer08.pdf (slides)] ==\n\n=== Class 1: Overview ===\n* [[Summer school 2008:Arithmetic expressions|Arithmetic expressions]]\n* [[Summer school 2008:Arithmetic expressions with let-binding|Arithmetic expressions with let-binding]]\n** Variation: [[Summer school 2008:Arithmetic expressions with call-by-value let-binding|Call-by-value let-binding syntax]]\n** Variation: [[Summer school 2008:Arithmetic expressions with let-binding (hypothetical evaluation)|Defining evaluation with a hypothetical judgement]]\n* [[Summer school 2008:Typed arithmetic expressions|Typed arithmetic expressions]]\n** Variation: [[Summer school 2008:Typed arithmetic expressions (extrinsic encoding)|Typed arithmetic expressions (extrinsic encoding)]]\n\n* [[Summer school 2008:Exercises 1|Exercises 1]]\n\n=== Class 2: Representation ===\n* [http://www.cs.cmu.edu/~drl/pubs/hl07mechanizing/hl07mechanizing.pdf Mechanizing Metatheory in a Logical Framework] discusses this material in detail.\n* [[Summer school 2008:Exercises 2|Exercises 2]]\n\n=== Class 3: Mechanizing Metatheory ===\n\n* [[Summer school 2008:Type safety for MinML (intrinsic encoding)|Type safety for MinML (intrinsic encoding)]]\n* [[Summer school 2008:Type safety for MinML (extrinsic encoding)|Type safety for MinML (extrinsic encoding)]]\n\n* [[Summer school 2008:Exercises 3|Exercises 3]]\n\n== Additional reading ==\n\n* PFPL: We will use [http://www.cs.cmu.edu/~rwh/plbook/book.pdf Practical Foundations for Programming Languages] as a reference for basic PL concepts.\n* MMLF: [http://www.cs.cmu.edu/~drl/pubs/hl07mechanizing/hl07mechanizing.pdf Mechanizing Metatheory in a Logical Framework] discusses LF, representation, and mechanized metatheory in technical detail.\n* [[Proving metatheorems with Twelf]] is a self-contained intro tutorial on this wiki.\n* After you get spun up, there are lots of [[tutorials]] and [[case studies]]."
          },
          "sha1": "qlepu10fe88ajg5uopiq24p0sbnyr6e"
        }
      },
      {
        "title": "Summer school 2008:Alternate typed arithmetic expressions with sums",
        "ns": 0,
        "id": 2078,
        "revision": {
          "id": 5361,
          "parentid": 5357,
          "timestamp": "2008-07-24T17:22:23Z",
          "contributor": {
            "username": "William Lovas",
            "id": 11
          },
          "comment": "pointer to the new alternate solution",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 3004,
            "#text": "%{\n\n{{Summer school 2008\n  |prev=Typed arithmetic expressions\n  |prevname=Typed arithmetic expressions\n  |nonext=\n}}\n\nArithmetic expressions with pairs and sums.  (There are two alternate solutions, [[Summer_school_2008:Typed_arithmetic_expressions_with_sums_2|one by William]] (involving output factoring) and [[Summer_school_2008:Typed_arithmetic_expressions_with_sums|one by Dan]] (involving output factoring and identity types).)\n\nNumbers and strings are unchanged.\n\n|hidden=\"true\"}%\n\nnat : type.             %name nat M.\nz : nat.\ns : nat -> nat.\n\nadd : nat -> nat -> nat -> type.\n%mode add +M +N -P.\n\nadd/z : add z N N.\nadd/s : add (s M) N (s P) <- add M N P.\n\n%worlds () (add _ _ _).\n%total M (add M _ _).\n\nchar : type.\t\t\t\t%name char X.\na : char.\nb : char.\n\nstr : type.\t\t\t\t%name str S.\nemp : str.\ncons : char -> str -> str.\n\ncat : str -> str -> str -> type.\n%mode cat +S1 +S2 -S3.\n\ncat/e : cat emp S S.\ncat/c : cat (cons X S1) S2 (cons X S3) <- cat S1 S2 S3.\n\n%worlds () (cat _ _ _).\n%total S (cat S _ _).\n\n%{\n\n== Typed expressions ==\n\nAdd a type for disjoint sums:\n\n}%\n\ntp : type.\t\t\t\t%name tp T.\nnumber : tp.\nstring : tp.\nprod   : tp -> tp -> tp.\nsum    : tp -> tp -> tp.\n\n%{\n\nAdd injections as values, and case as an expression. Note that you can only case on a value.  This makes evaluation slightly easier; \nfor versions with expression-case as a primitive; see the above alternate solutions.\n\n}%\n\nval : tp -> type.\t\t\t%name val V.  %postfix 1 val.\nnum : nat -> number val.\nlit : str -> string val.\npair : T val -> U val -> (prod T U) val.\ninl : T val -> (sum T U) val.\ninr : U val -> (sum T U) val.\n\nexp : tp -> type.\t\t\t%name exp E.  %postfix 1 exp.\nret : T val -> T exp.\nplus : number exp -> number exp -> number exp.\nappend : string exp -> string exp -> string exp.\nlet : T exp -> (T val -> U exp) -> U exp.\nfst : (prod T U) exp -> T exp.\nsnd : (prod T U) exp -> U exp.\ncase : (sum T U) val -> (T val -> V exp) -> (U val -> V exp) -> V exp.\n\n%{\n\nNote that if we want to case on an expression, we can let-bind it:\n\n}%\n\necase : (sum T U) exp -> (T val -> V exp) -> (U val -> V exp) -> V exp \n            = [esum] [e1] [e2] (let esum ([x] case x e1 e2)).\n\n%{\n\nAdd eval cases for case.\n\n}%\n\neval : T exp -> T val -> type.\n%mode eval +E1 -E2.\n\neval/val\n   : eval (ret V) V.\n\neval/plus\n   : eval (plus E1 E2) (num N)\n      <- eval E1 (num N1)\n      <- eval E2 (num N2)\n      <- add N1 N2 N.\n\neval/append\n   : eval (append E1 E2) (lit S)\n      <- eval E1 (lit S1)\n      <- eval E2 (lit S2)\n      <- cat S1 S2 S.\n\neval/let\n   : eval (let E1 ([x] E2 x)) A\n      <- eval E1 V\n      <- eval (E2 V) A.\n\neval/fst\n   : eval (fst E) A\n      <- eval E (pair A _).\n\neval/snd\n   : eval (snd E) B\n      <- eval E (pair _ B).\n\neval/case1\n  : eval (case (inl A) ([x] E1 x) _) A1\n      <- eval (E1 A) A1.\n\neval/case2\n  : eval (case (inr A) _ ([x] E2 x)) A2\n      <- eval (E2 A) A2.\n\n%worlds () (eval _ _).\n%total E (eval E _).\n\n%{\n\n{{Summer school 2008\n  |prev=Exercises 1\n  |prevname=Exercises 1\n  |nonext=\n}}\n\n}%"
          },
          "sha1": "i7h31ab6lltogtmfy4garul2gueqbx5"
        }
      },
      {
        "title": "Summer school 2008:Arithmetic expressions",
        "ns": 0,
        "id": 2056,
        "revision": {
          "id": 5279,
          "parentid": 5272,
          "timestamp": "2008-07-20T01:26:43Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 3447,
            "#text": "%{\n\n{{Summer school 2008\n   |noprevious = \n   |next = Arithmetic expressions with let-binding\n   |nextname = Arithmetic expressions with let-binding\n}}\n\n== Rudimentary arithmetic ==\n\nIn on-paper notation, the syntax of the natural numbers is given as follows:\n\n<math>n ::= \\mathsf{z} \\, | \\, \\mathsf{s}(n)</math>\n\nThat is, <math>\\mathsf{z}</math> is a natural number, and if <math>n</math> is a natural number, then <math>\\mathsf{s}(n)</math> is as well.\n\nWe represent natural numbers as an LF type <tt>nat</tt> with two constants generating LF terms of that type:\n\n}%\n\nnat : type.             %name nat M.\nz : nat.\ns : nat -> nat.\n\n%{\n\nThe constant <tt>z</tt> constructs a <tt>nat</tt>; the constant <tt>s</tt> constructs a <tt>nat</tt> from a <tt>nat</tt>.\n\n=== Addition ===\n\nNext, we define addition as a judgement relating two natural numbers to their sum:\n\n<table style=\"margin-left:auto;margin-right:auto\" cellpadding=\"24\">\n<tr><td>\n<math>{\\qquad} \\over {\\mathsf{add}(\\mathsf{z},n,n)}\n</math>\n</td><td>\n<math>\n{\\mathsf{add}(m,n,p)} \\over\n{\\mathsf{add}(\\mathsf{s}(m), n, \\mathsf{s}(p))}\n</math>\n</td></tr>\n</table>\n\nThis judgement is represented in LF as follows:\n\n}%\n\nadd : nat -> nat -> nat -> type.\n%mode add +M +N -P.\n\nadd/z : add z N N.\nadd/s : add (s M) N (s P) \n         <- add M N P.\n\n%{\n\nThe first line says that the type family <tt>add</tt> relates three natural numbers.  The second line says that the first two (the addends) determine the third (the sum).  The constants <tt>add/z</tt> and <tt>add/s</tt> correspond to the inference rules above.\n\n==== Totality ====\n\nTwelf verifies that addition is a total function on closed terms of type nat:\n\n}%\n\n%worlds () (add _ _ _).\n%total M (add M _ _).\n\n%{ \nThe declarations should be read as follows:\n* [[%mode]]: The two addends are inputs; the sum is an output.\n* [[%worlds]]: <tt>add</tt> is defined on closed LF terms\n* [[%total]]: For all <tt>M</tt> and <tt>N</tt>, there exists a <tt>P</tt> such that <tt>add M N P</tt> is derivable.\n\nThis proves a [[totality assertion]] for <tt>add</tt>.\n}%\n\n%{\n\n== Simple arithmetic expressions ==\n\n}%\n\nexp : type.             %name exp E.\nnum : nat -> exp.\nplus : exp -> exp -> exp.\n\n%{\n=== Evaluation ===\n\nFirst, we define a syntactic category of answers, which in this case is\njust natural numbers:\n\n}%\n\nans : type.\t\t\t\t%name ans A.\nanum : nat -> ans.\n\n%{ \nNext, we define the evaluation judgement relating an expression to an answer.\n}%\n\neval : exp -> ans -> type.\t\t%name eval Deval.\n%mode eval +E1 -E2.\n\neval/num\n   : eval (num N) (anum N).\n\neval/plus\n   : eval (plus E1 E2) (anum N)\n      <- eval E1 (anum N1)\n      <- eval E2 (anum N2)\n      <- add N1 N2 N.\n\n%worlds () (eval _ _).\n%total E (eval E _).\n\n%{\nTwelf verifies that evaluation is total: \n* the mode declaration says that the expression is an input, and the answer is an output.\n* the worlds declaration says that we're only considering closed expressions\n* the total declaration asks Twelf to verify that <tt>eval</tt> defines a total relation from closed expressions to closed answers.  \n}%\n\n%{ \n=== Solving for derivations ===\n\nWe can use logic programming to [[%solve|solve]] for derivations.  \n\n}%\n\ntwo : nat = (s (s z)).\n%solve _ : add two two N.\n\ntwo_exp : exp = num two.\n%solve _ : eval (plus two_exp two_exp) E.\n\n%{\n\n\n{{Summer school 2008\n   |noprevious = \n   |next = Arithmetic expressions with let-binding\n   |nextname = Arithmetic expressions with let-binding\n}}\n\n}%"
          },
          "sha1": "g3ccwlhngl9ubdcrame6psise6cl39p"
        }
      },
      {
        "title": "Summer school 2008:Arithmetic expressions with call-by-value let-binding",
        "ns": 0,
        "id": 2061,
        "revision": {
          "id": 5239,
          "parentid": 5238,
          "timestamp": "2008-07-19T02:37:43Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "minor": null,
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 2768,
            "#text": "%{\n\n{{Summer school 2008\n   |prev=Arithmetic expressions with let-binding\n   |prevname=Arithmetic expressions with let-binding\n   |next=Arithmetic expressions with let-binding (hypothetical evaluation)\n   |nextname=Defining evaluation with a hypothetical judgement}}\n\nWe define a simple expression language with let-bindings, making explicit the\ninvariant that variables stand for values into the syntax.  This allows\nTwelf to prove termination of evaluation.  \n\nNatural numbers and addition are defined as before.\n\n|hidden=\"true\"}%\n\nnat : type.             %name nat M.\nz : nat.\ns : nat -> nat.\n\nadd : nat -> nat -> nat -> type.\n%mode add +M +N -P.\n\nadd/z : add z N N.\nadd/s : add (s M) N (s P) <- add M N P.\n\n%worlds () (add _ _ _).\n%total M (add M _ _).\n\n%{\n\n== Call-by-value arithmetic expressions ==\n\nFirst, we define a type of <tt>open values</tt>, which are either a\nnumeral or a variable.  Numerals are represented by a constant\n<tt>num</tt>; variables are represented by LF variables.  \n\n}%\n\nval : type.\t\t%name val V.\nnum : nat -> val.\n\n%{\nNext, we define expressions, with a constant <tt>ret</tt> including\nvalues into expressions.\n}%\n\nexp : type.             %name exp E.\nret : val -> exp.\nplus : exp -> exp -> exp.\nlet : exp -> (val -> exp) -> exp.\n\n%{\n\nNote that the <tt>let</tt>-bound variable stands for a value.  \n\n== Evaluation, using substitution ==\n\nAs before, the type of answers includes only numerals.  The code for\nevaluation is exactly the same as [[Summer school 2008:Arithmetic expressions with let-binding|before]].  \n\n}%\n\nans : type.\t\t\t\t%name ans A.\nanum : nat -> ans.\n\neval : exp -> ans -> type.\n%mode eval +E1 -E2.\n\neval/val\n   : eval (ret (num N)) (anum N).\n\neval/plus\n   : eval (plus E1 E2) (anum N)\n      <- eval E1 (anum N1)\n      <- eval E2 (anum N2)\n      <- add N1 N2 N.\n\neval/let\n   : eval (let E1 ([x] E2 x)) A\n      <- eval E1 (anum N)\n      <- eval (E2 (num N)) A.\n\n%{\n\nBut now, Twelf can prove evaluation total:\n\n}%\n\n%worlds () (eval _ _).\n%total E (eval E _).\n\n%{\n\nWhy does this work?  When termination-checking <tt>eval/let</tt>, Twelf\nobserves that no expressions can appear in variables (this observation\nis based on [[subordination]]), so it's possible to view all\nsubstitution instances of <tt>E2</tt> as having the same size as\n<tt>E2</tt>.  This justifies the recursive call.  If Twelf didn't build\nin this reasoning, one could justify it explcitly by using a [[numeric termination metric]] where the size of any value = the size of a\nvariable = 1.\n\n\n\n{{Summer school 2008\n   |prev=Arithmetic expressions with let-binding\n   |prevname=Arithmetic expressions with let-binding\n   |next=Arithmetic expressions with let-binding (hypothetical evaluation)\n   |nextname=Defining evaluation with a hypothetical judgement}}\n\n}%"
          },
          "sha1": "g3dipb4e04vi69ckb6h3eo58c1v9kvz"
        }
      },
      {
        "title": "Summer school 2008:Arithmetic expressions with let-binding",
        "ns": 0,
        "id": 2059,
        "revision": {
          "id": 5280,
          "parentid": 5274,
          "timestamp": "2008-07-20T01:27:20Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 3669,
            "#text": "%{\n\n{{Summer school 2008\n  |prev=Arithmetic expressions\n  |prevname=Arithmetic expressions\n  |next=Arithmetic expressions with call-by-value let-binding\n  |nextname=Arithmetic expressions with call-by-value let-binding\n}}\n\nNext, we add let-binding to our expression language.  Natural numbers\nand addition are the same as before.\n\n|hidden=\"true\"}%\n\nnat : type.             %name nat M.\nz : nat.\ns : nat -> nat.\n\nadd : nat -> nat -> nat -> type.\n%mode add +M +N -P.\n\nadd/z : add z N N.\nadd/s : add (s M) N (s P) <- add M N P.\n\n%% addition is a total function on closed terms of type nat\n\n%worlds () (add _ _ _).\n%total M (add M _ _).\n\n%{\n\n== Arithmetic expressions with let-binding ==\n\n=== Syntax ===\n\nFirst, the syntax:\n\n}%\n\nexp : type.\t\t\t\t%name exp E.\nnum : nat -> exp.\nplus : exp -> exp -> exp.\nlet : exp -> (exp -> exp) -> exp.\n\n%{  \n\nLet-binding is represented using [[higher-order abstract syntax]]:\n<math>\\mathsf{let} \\, x \\, = e_1 \\, \\mathsf{in} \\, e_2</math> is\nrepresented by <tt>let e_1 ([x] e_2)</tt>; an LF variable is used to\nrepresent the bound-variable.  So the body of the <tt>let</tt> has LF\ntype <tt>(exp -> exp)</tt>.\n\n}%\n\n%{\n\n=== Evaluation, using substitution ===\n\n}%\n\nans : type.\t\t\t\t%name ans A.\nanum : nat -> ans.\n\neval : exp -> ans -> type.\n%mode eval +E1 -E2.\n\neval/num\n   : eval (num N) (anum N).\n\neval/plus\n   : eval (plus E1 E2) (anum N)\n      <- eval E1 (anum N1)\n      <- eval E2 (anum N2)\n      <- add N1 N2 N.\n\neval/let\n   : eval (let E1 ([x] E2 x)) A\n      <- eval E1 (anum N)\n      <- eval (E2 (num N)) A.\n\n%{ \nThat is, to evaluate a <tt>let</tt>, we \n* evaluate the let-bound term <tt>E1</tt> to an answer <tt>anum N</tt>\n* substitute its value into the body.  Substitution is represented by the LF application of <tt>E2</tt> to <tt>(num N)</tt>.\n* evaluate the result\n\nTwelf cannot prove this total without some help, because it's not\nobvious that the substitution instance <tt>(E2 (num N))</tt> is smaller\nthan the input expression.\n\n}%\n\n%worlds () (eval _ _).\n\n%{\n\n<twelf ignore=\"true\" check=\"decl\">\n%total E (eval E _).\n</twelf>\n\nHowever, evaluation does terminate.  There are two different ways to see\nthis: \n\n# Observe that we only substitute ''values'' for variables. Consequently, it is possible to give a size metric on terms where all the substitution instances of <tt>E2</tt> are the same size as <tt>E2</tt>, by taking the size of a variable = the size of a value = one.  We can formalize this reasoning in Twelf in two ways:\n## We can prove termination ourselves as a [[metatheorem]].  We'll learn about this in class 3.\n## We can make the invariant that variables stand for values explicit in the syntax of the language, in which case Twelf can prove termination itself.  See [[Summer school 2008:Arithmetic expressions with call-by-value let-binding|Variation: Call-by-value let-binding syntax]]\n# Rather than recursively evaluating the substitution instance, we can give an environment semantics where the values of variables are tracked off to the side.  To evaluate a <tt>let</tt>, we recursively evaluate body (so evaluation is structurally inductive on the expression) in an extended environment.  See [[Summer school 2008:Arithmetic expressions with let-binding (hypothetical evaluation)|Variation: Defining evaluation with a hypothetical judgement]]\n\nAt this point, you should explore one or both of these variations, and then proceed to see how we represent typed arithmetic expressions.\n\n\n{{Summer school 2008\n  |prev=Arithmetic expressions\n  |prevname=Arithmetic expressions\n  |next=Arithmetic expressions with call-by-value let-binding\n  |nextname=Arithmetic expressions with call-by-value let-binding\n}}\n\n}%"
          },
          "sha1": "bv2hbrrphhb3yo3593fipsrhxmutyzh"
        }
      },
      {
        "title": "Summer school 2008:Arithmetic expressions with let-binding (hypothetical evaluation)",
        "ns": 0,
        "id": 2063,
        "revision": {
          "id": 5285,
          "parentid": 5283,
          "timestamp": "2008-07-20T01:48:43Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 3533,
            "#text": "%{\n\n{{Summer school 2008\n   |prev=Arithmetic expressions with call-by-value let-binding\n   |prevname=Call-by-value let-binding syntax\n   |next=Typed arithmetic expressions\n   |nextname=Typed arithmetic expressions}}\n\nNumbers and addition are as before.\n\n|hidden=\"true\"}%\n\nnat : type.             %name nat M.\nz : nat.\ns : nat -> nat.\n\nadd : nat -> nat -> nat -> type.\n%mode add +M +N -P.\n\nadd/z : add z N N.\nadd/s : add (s M) N (s P) <- add M N P.\n\n%% addition is a total function on closed terms of type nat\n\n%worlds () (add _ _ _).\n%total M (add M _ _).\n\n%{\n\n== Evaluation using a hypothetical judgement ==\n\nWe use the call-by-value syntax for expressions here.\n\nValues, expressions, answers, and the first two cases of evaluation are as before:\n\n}%\n\nval : type.\t\t\t\t%name val V.\nnum : nat -> val.\n\nexp : type.\t\t\t\t%name exp E.\nret : val -> exp.\nplus : exp -> exp -> exp.\nlet : exp -> (val -> exp) -> exp.\n\n%%% evaluation, using hypothetical judgements\n\nans : type.\t\t\t\t%name ans A.\nanum : nat -> ans.\n\neval : exp -> ans -> type.\n%mode eval +E1 -E2.\n\neval/val\n   : eval (ret (num N)) (anum N).\n\neval/plus\n   : eval (plus E1 E2) (anum N)\n      <- eval E1 (anum N1)\n      <- eval E2 (anum N2)\n      <- add N1 N2 N.\n\neval/let\n   : eval (let E1 ([x] E2 x)) A2\n      <- eval E1 A1\n      <- ({x:val} eval (ret x) A1 -> eval (E2 x) A2).\n\n%{\n\n<tt>eval/let</tt> deserves some explanation: the second recursive call says that we evaluate <tt>(E2 x)</tt> in an extended LF context.  In particular, we extend the context with <tt>x:val</tt>, a variable ranging over values, and a derivation of <tt>eval (ret x) A1</tt>.  In the scope of these assumptions, the expression <tt>ret x</tt> therefore evaluates to <tt>A1</tt>.  In the terminology of [http://www.cs.cmu.edu/~rwh/plbook/book.pdf Practical Foundations for Programming Languages], <tt>eval</tt> is a [[hypothetical judgement|hypothetical]] (because we add <tt>eval</tt> assumptions to the context) and general (because we add variables to the context) judgement. The context of <tt>eval</tt> is represented by the LF context, a technique called [[higher-order judgements]].  \n\n=== Totality in non-empty worlds ===\n\nBecause evaluation recurs in an extend context, we must prove it total not just for the empty context, as we have done above, but for a [[world]] of a particular form.  \n\nIf we tried to prove it total in the empty context, Twelf would complain:\n\n<twelf check=\"decl\">\n%worlds () (eval _ _).\n</twelf> \n\nThis error means \"you said <tt>eval</tt> stays in the empty context, but it doesn't!\".\n\nIn what contexts in <tt>eval</tt> total?  Not in every context: if we ever assumed a variable <tt>x:val</tt> without also assuming <tt>eval (ret x) A</tt> for some <tt>A</tt>, then <tt>ret x</tt> would be an expression without a value.  So we want to describe the invariant that the context looks like\n\n<tt>x1:val, d1:eval (ret x) A1, ...... , xn:val, dn:eval (ret x) An</tt>\n\nfor some <tt>A1, ... , An</tt>.  \n\nWe do this by \n# defining a block <tt>eval_block</tt> describing that pattern\n# stating <tt>eval</tt> for a world containing contexts made up of <tt>eval_block</tt>s\n}%\n\n%block eval_block : some {A:ans} block {x:val} {_:eval (ret x) A}.\n%worlds (eval_block) (eval _ _).\n\n%{\n\nNow Twelf can verify the totality of <tt>eval</tt>:\n\n}%\n\n%total E (eval E _).\n\n%{\n\n{{Summer school 2008\n   |prev=Arithmetic expressions with call-by-value let-binding\n   |prevname=Call-by-value let-binding syntax\n   |next=Typed arithmetic expressions\n   |nextname=Typed arithmetic expressions}}\n}%"
          },
          "sha1": "syuzpbcip9gbv5o56g41mv9xjclz9sj"
        }
      },
      {
        "title": "Summer school 2008:Arithmetic expressions with pairs (value)",
        "ns": 0,
        "id": 2069,
        "redirect": {
          "@title": "Summer school 2008:Typed arithmetic expressions (value)",
          "#text": null
        },
        "revision": {
          "id": 5264,
          "timestamp": "2008-07-19T23:37:35Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "comment": "[[Summer school 2008:Arithmetic expressions with pairs (value)]] moved to [[Summer school 2008:Typed arithmetic expressions (value)]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 69,
            "#text": "#REDIRECT [[Summer school 2008:Typed arithmetic expressions (value)]]"
          },
          "sha1": "bqlm84e0z581pek47par0809kkbn2wd"
        }
      },
      {
        "title": "Summer school 2008:Encoding of System F",
        "ns": 0,
        "id": 2071,
        "revision": {
          "id": 5294,
          "parentid": 5293,
          "timestamp": "2008-07-20T02:10:44Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 1254,
            "#text": "%{\n\n{{Summer school 2008\n   |prev=Exercises 2\n   |prevname=Exercises 2\n   |nonext= \n}}\n\n== Syntax ==\n\nTypes:\n\n}%\n\ntp : type.  \n\narrow : tp -> tp -> tp.\nforall : (tp -> tp) -> tp.\n\n%{\n\nTerms: \n\n}%\n\ntm : type. \n\nfn : tp -> (tm -> tm) -> tm.\napp : tm -> tm -> tm.\n\ntfn : (tp -> tm) -> tm.\ntapp : tm -> tp -> tm.\n\n%{\n\n== Static semantics ==\n\n}%\n\nof : tm -> tp -> type.\n\nof-fn : of (fn T2 ([x:tm] (E x))) (arrow T2 T)\n\t   <- ({x : tm} {dx : of x T2} of (E x) T).\nof-app : of (app E1 E2) T\n\t    <- of E1 (arrow T2 T)\n\t    <- of E2 T2.\nof-tfn : of (tfn ([u:tp] (E u))) (forall ([u:tp] T u))\n\t    <- ({u : tp} of (E u) (T u)).\nof-tapp : of (tapp E T2) (T T2)\n\t      <- of E (forall ([u] T u)).\n\n%{\n\n== Dynamic semantics ==\n\n}%\n\nvalue    : tm -> type.\nvalue-fn : value (fn A E).\nvalue-tfn : value (tfn E).\n\n\nstep : tm -> tm -> type.\n\nstep-app-1 : step (app E1 E2) (app E1' E2)\n\t\t<- step E1 E1'.\nstep-app-2 : step (app V1 E2) (app V1 E2')\n\t\t<- value V1\n\t\t<- step E2 E2'.\nstep-app-beta : step (app (fn T2 ([x:tm] (E x))) E2) (E E2)\n\t\t   <- value E2.\nstep-tapp-1 : step (tapp E1 T) (tapp E1' T)\n\t\t <- step E1 E1'.\nstep-tapp-beta : step (tapp (tfn ([u:tp] E u)) T2) (E T2).\n\n%{\n\n\n{{Summer school 2008\n   |prev=Exercises 2\n   |prevname=Exercises 2\n   |nonext= \n}}\n\n\n}%"
          },
          "sha1": "5wln6i1fzu2e9vua621ivhm8o6ee8i1"
        }
      },
      {
        "title": "Summer school 2008:Exercises 1",
        "ns": 0,
        "id": 2067,
        "revision": {
          "id": 6008,
          "parentid": 6007,
          "timestamp": "2009-05-14T20:16:35Z",
          "contributor": {
            "username": "Sunshine",
            "id": 50
          },
          "comment": "/* Add pairs (solution) */",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 1556,
            "#text": "{{Summer school 2008\n   |noprevious = \n   |nonext = }}\n\n== Add pairs [[Summer school 2008:Typed arithmetic expressions with pairs|(solution)]] ==\n\nExtend the [[Summer school 2008:Typed arithmetic expressions (value)|Typed arithmetic expressions (value)]] language with binary pairs (see [http://www.cs.cmu.edu/~rwh/plbook/book.pdf PFPL Chapter 16] if you need a refresher on the syntax and typing rules for pairs).  \n\nThis will be easiest if you start from [[Summer school 2008:Typed arithmetic expressions (value)|Typed arithmetic expressions (value)]].  Use the \"Code: here\" link in the top-left corner to download the code.\n\nYou will need to add:\n\n# a type <tt>prod T U</tt>\n# expression constructors for pairing <tt>(pair E1 E2)</tt>, and first and second projection <tt>(fst E)</tt> and <tt>(snd E)</tt>.\n# new cases for evaluation\n\nGet Twelf to verify the totality of your extended evaluation judgement.\n\nIf you're feeling ambitious, add disjoint sums ([http://www.cs.cmu.edu/~rwh/plbook/book.pdf PFPL Chapter 17]) as well! [[Summer school 2008:Alternate typed arithmetic expressions with sums|(solution)]]\n\n== Getting familiar with Twelf ==\n\nRead the discussion of Twelf's totality checker on  [[Proving_metatheorems:Proving_totality_assertions_about_the_natural_numbers|this page]] so that you understand Twelf's error messages better.\n\n== Call-by-name ==\n\nDo a call-by-name version of evaluation for [[Summer school 2008:Arithmetic expressions with let-binding|Arithmetic expressions with let-binding]].  How would you prove evaluation terminates?"
          },
          "sha1": "f019kugds4tlcfeh2y9tyhmcnwc8oqt"
        }
      },
      {
        "title": "Summer school 2008:Exercises 2",
        "ns": 0,
        "id": 2070,
        "revision": {
          "id": 5359,
          "parentid": 5311,
          "timestamp": "2008-07-24T07:07:38Z",
          "contributor": {
            "ip": "169.237.10.63"
          },
          "comment": "/* System F (solution) */ give location in paper for adequacy proof of STLC",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 977,
            "#text": "{{Summer school 2008\n  |noprevious=\n  |nonext=\n}}\n\n== System F [[Summer school 2008:Encoding of System F|(solution)]]==\n\n# Give an LF encoding of System F (the polymorphic lambda-calculus). Use [http://www.cs.cmu.edu/~rwh/plbook/book.pdf PFPL Chapter 25 as the on-paper definition].  \n# Prove adequacy.  You may want to follow the adequacy proof in [http://www.cs.cmu.edu/~drl/pubs/hl07mechanizing/hl07mechanizing.pdf MMLF], section 3.2, page 21.\n\n== System F, Intrinsic Encoding ==\n\n# Use an [[intrinsic encoding]] to represent only the well-typed System F terms.\n# What can you say about adequacy for this encoding? \n\n== Hereditary substitution ==\n\nHereditary substitution is used in the definition of LF to compute the canonical result of substituting one canonical term into another.  Read and understand the rules for hereditary substitution in [http://www.cs.cmu.edu/~drl/pubs/hl07mechanizing/hl07mechanizing.pdf MMLF].\n\n\n{{Summer school 2008\n  |noprevious=\n  |nonext=\n}}"
          },
          "sha1": "3urg1d8xwo1o0fpsqpcxeuv5pq0987f"
        }
      },
      {
        "title": "Summer school 2008:Exercises 3",
        "ns": 0,
        "id": 2073,
        "revision": {
          "id": 5327,
          "parentid": 5326,
          "timestamp": "2008-07-22T02:20:16Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 1941,
            "#text": "== Polymorphic MinML [[Summer school 2008:Type safety for polymorphic MinML (intrinsic encoding)|(solution)]]==\n\nAdd explicit polymorphism to MinML and prove type safety:\n\n# Add a type <math>\\forall \\alpha.\\tau</math>\n# Add terms <math>\\Lambda \\alpha.e</math> and <math>e [\\tau]</math>, with the appropriate typing rules and dynamic semantics\n# Extend the type safety proof to cover the new cases.\n\nYou can start from either encoding:\n* [[Summer school 2008:Type safety for MinML (intrinsic encoding)|The intrinsic encoding]] will be easier, because it takes full advantage of dependent types.\n* [[Summer school 2008:Type safety for MinML (extrinsic encoding)|The extrinsic encoding]] is closer to what people usually write on paper.\n\n== Monadic Effects [[Summer school 2008:Type safety for MinML with monadic effects|(solution)]]==\n\nAdd monadically encapsulated effects (i.e., an <tt>IO</tt> monad) to MinML, following [http://www.cs.cmu.edu/~rwh/plbook/book.pdf PFPL Chapter 39].  \n\nIf you're feeling ambitious, add the following specific effects [[Summer school 2008:Type safety for MinML with monadic effects (putngetn)|(solution)]]:\n* <tt>getn ; x.m</tt> reads a natural number from an input buffer (i.e., stdin).  <tt>x</tt> stands for the number in <tt>m</tt>.\n* <tt>putn(e) ; m</tt> writes a natural number, the value of <tt>e</tt> to an output buffer (i.e., stdout).  \n\nThese primitives are simpler than full mutable references because their dynamic semantics can be given as a labeled transition system with labels <tt>read n</tt> and <tt>write n</tt>---you do not need a store as part of the judgement form. \n\n== Determinacy of Evaluation == \n\nProve that the dynamic semantics of MinML are deterministic (every expression steps to at most one other expression).  Hint: you will need to use [[equality]] to state the theorem.  See the discussion of [[uniqueness lemma]]s for a proof of determinacy for the simply-typed λ-calculus."
          },
          "sha1": "ebmcepvrpe1p7s5dlpnkrtmg1qhyxv4"
        }
      },
      {
        "title": "Summer school 2008:Type safety for MinML (extrinsic encoding)",
        "ns": 0,
        "id": 2072,
        "revision": {
          "id": 5337,
          "parentid": 5305,
          "timestamp": "2008-07-22T17:24:46Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 6081,
            "#text": "%{\n\n{{Summer school 2008\n  |prev=Type safety for MinML (intrinsic encoding)\n  |prevname=Type safety for MinML (intrinsic encoding)\n  |next=Exercises 3\n  |nextname=Exercises 3\n}}\n\nType safety for MinML: call-by-value, with recursive functions, in extrinsic form\n\n== Syntax ==\n\nTypes:\n\n}%\n\ntp : type.\t\t\t\t%name tp T.\nnat : tp.\narr : tp -> tp -> tp.\n\n%{\n\nRaw expressions, which admit ill-typed terms\n\n}%\n\nexp : type.\t\t\t\t%name exp E.\nz : exp.\ns : exp -> exp.\nifz : exp -> exp -> (exp -> exp) -> exp.\nfun : tp -> tp -> (exp -> exp -> exp) -> exp.\napp : exp -> exp -> exp.\n\n%{\n\n== Static semantics ==\n\nA judgement picking out the well-typed terms:\n\n}%\n\nof : exp -> tp -> type.\t\t\t%name of Dof.\n%mode of +E -T.\n\nof/z\n   : of z nat.\nof/s\n   : of (s E) nat <- of E nat.\nof/ifz\n   : of (ifz E E1 ([x] E2 x)) T\n      <- of E nat\n      <- of E1 T\n      <- ({x:exp} of x nat -> of (E2 x) T).\nof/fun\n   : of (fun T1 T2 ([f] [x] E f x)) (arr T1 T2)\n      <- ({f:exp} of f (arr T1 T2) -> {x:exp} of x T1 -> of (E f x) T2).\nof/app\n   : of (app E1 E2) T\n      <- of E1 (arr T2 T)\n      <- of E2 T2.\n\n%{\n\n== Dynamic semantics ==\n\n}%\n\nvalue : exp -> type.\t\t\t%name value Dval.\n%mode value +E.\n\nvalue/z : value z.\nvalue/s : value (s E) <- value E.\nvalue/fun : value (fun _ _ _).\n\nstep : exp -> exp -> type.\t\t%name step Dstep.\n%mode step +E1 -E2.\n\nstep/s\n   : step (s E) (s E') <- step E E'.\nstep/ifz/arg\n   : step (ifz E E1 ([x] E2 x)) (ifz E' E1 ([x] E2 x))\n      <- step E E'.\nstep/ifz/z\n   : step (ifz z E1 ([x] E2 x)) E1.\nstep/ifz/s\n   : step (ifz (s E) E1 ([x] E2 x)) (E2 E)\n      <- value E.\nstep/app/fun\n   : step (app E1 E2) (app E1' E2)\n      <- step E1 E1'.\nstep/app/arg\n   : step (app E1 E2) (app E1 E2')\n      <- value E1 <- step E2 E2'.\nstep/app/beta-v\n   : step\n      (app (fun T1 T2 ([f] [x] E f x)) E2)\n      (E (fun T1 T2 ([f] [x] E f x)) E2)\n      <- value E2.\n\n%{\n\n== Preservation ==\n\nWith this encoding, we have to prove preservation explicitly, as the\ntype of <tt>step</tt> doesn't guarantee it.\n\n}%\n\npres : step E E' -> of E T -> of E' T -> type. %name pres Dpres.\n%mode pres +Dstep +Dof -Dof.\n\n- : pres\n     (step/s Dstep)\n     (of/s Dof)\n     (of/s Dof')\n     <- pres Dstep Dof Dof'.\n\n- : pres\n     (step/ifz/arg Dstep)\n     (of/ifz ([x] [dx] Dof2 x dx) Dof1 Dof)\n     (of/ifz ([x] [dx] Dof2 x dx) Dof1 Dof')\n     <- pres Dstep Dof Dof'.\n\n- : pres\n     step/ifz/z\n     (of/ifz _ Dof1 _)\n     Dof1.\n\n- : pres\n     (step/ifz/s (_ : value E))\n     (of/ifz ([x] [dx] Dof2 x dx) _ (of/s Dof))\n     (Dof2 E Dof).\n\n- : pres\n     (step/app/fun Dstep1)\n     (of/app Dof2 Dof1)\n     (of/app Dof2 Dof1')\n     <- pres Dstep1 Dof1 Dof1'.\n\n- : pres\n     (step/app/arg Dstep2 _)\n     (of/app Dof2 Dof1)\n     (of/app Dof2' Dof1)\n     <- pres Dstep2 Dof2 Dof2'.\n\n- : pres\n     (step/app/beta-v _)\n     (of/app\n\tDof2\n\t(of/fun [f] [df] [x] [dx] (Dof1 f df x dx)))\n     (Dof1\n\t_\n\t(of/fun [f] [df] [x] [dx] (Dof1 f df x dx))\n\t_\n\tDof2).\n\n%worlds () (pres Dstep Dof Dof').\n%total Dstep (pres Dstep _ _).\n\n%{\n\n== Progress ==\n\n}%\n\nval-or-step : exp -> type.\t\t%name val-or-step Dvos.\nvos/val : val-or-step E <- value E.\nvos/step : val-or-step E <- step E _.\n\n%{\n\n=== [[Output factoring|Factoring lemmas]] ===\n\n}%\n\nprog/s\n   : val-or-step E -> val-or-step (s E) -> type.\n%mode prog/s +Dvos1 -Dvos2.\n\n- : prog/s\n     (vos/step Dstep)\n     (vos/step (step/s Dstep)).\n\n- : prog/s\n     (vos/val Dval)\n     (vos/val (value/s Dval)).\n\n%worlds () (prog/s _ _).\n%total {} (prog/s _ _).\n\nprog/ifz\n   :  of E nat\n      -> val-or-step E\n      -> {E1} {E2} (step (ifz E E1 ([x] E2 x)) E')\n      -> type.\n%mode prog/ifz +Dof +Dvos +E1 +E2 -Dstep.\n\n- : prog/ifz _ (vos/step Dstep) _ _ (step/ifz/arg Dstep).\n- : prog/ifz _ (vos/val value/z) _ _ step/ifz/z.\n- : prog/ifz _ (vos/val (value/s Dval)) _ _ (step/ifz/s Dval).\n\n%worlds () (prog/ifz _ _ _ _ _).\n%total {} (prog/ifz _ _ _ _ _).\n\nprog/app\n   : of E1 (arr T2 T)\n      -> val-or-step E1\n      -> val-or-step E2\n      -> step (app E1 E2) E'\n      -> type.\n%mode prog/app +Dof +Dvos1 +Dvos2 -Dstep.\n\n- : prog/app\n     _\n     (vos/step Dstep1)\n     _\n     (step/app/fun Dstep1).\n\n- : prog/app\n     _\n     (vos/val Dval1)\n     (vos/step Dstep2)\n     (step/app/arg Dstep2 Dval1).\n\n- : prog/app\n     _\n     (vos/val Dval1)\n     (vos/val Dval2)\n     (step/app/beta-v Dval2).\n\n%worlds () (prog/app _ _ _ _).\n%total {} (prog/app _ _ _ _).\n\n%{\n\n=== Main theorem ===\n\n}%\n\nprog : of E T -> val-or-step E -> type. %name prog Dprog.\n%mode prog +Dof -Dvos.\n\n- : prog of/z (vos/val value/z).\n\n- : prog (of/s Dof) Dvos'\n     <- prog Dof Dvos\n     <- prog/s Dvos Dvos'.\n\n- : prog (of/ifz ([x] [dx] Dof2 x dx) Dof1 Dof) (vos/step Dstep)\n     <- prog Dof Dvos\n     <- prog/ifz Dof Dvos _ _ Dstep.\n\n- : prog (of/fun _) (vos/val value/fun).\n\n- : prog (of/app Dof2 Dof1) (vos/step Dstep)\n     <- prog Dof1 Dvos1\n     <- prog Dof2 Dvos2\n     <- prog/app Dof1 Dvos1 Dvos2 Dstep.\n\n%worlds () (prog _ _).\n%total Dof (prog Dof _).\n\n%{\n\nAnd thus we have proved type safety for minml!\n\n== Examples ==\n\n}%\n\n%abbrev plus : exp = \n  fun nat (arr nat nat) \n   ([plus] [x] ifz x \n                  (fun nat nat ([_] [y] y))\n                  ([predx] (fun nat nat ([_] [y] s (app (app plus predx) y))))).\n%solve D : of plus T.\n\n%abbrev mult : exp = \n  fun nat (arr nat nat) \n   ([mult] [x] (fun nat nat\n\t\t  [_] [y]\n\t\t  ifz y \n\t\t      z\n\t\t  ([predy] app (app plus x) (app (app mult x) predy)))).\n%solve Dmult : of mult T.\n\n%abbrev fact : exp = \n  fun nat nat ([fact] [x] \n    ifz x \n       (s z) \n       ([predx] (app (app mult x) (app fact predx)))).  \n\n%{\n|check=\"decl\"}%\n%solve Dfact : of fact T.\n\n%{ }%\n\nstepv : exp -> exp -> type.\nstepv/v : stepv E E\n\t   <- value E.\nstepv/s : stepv E E''\n\t   <- step E E'\n\t   <- stepv E' E''.\n\n%solve D : stepv (app (app plus (s (s z))) (s (s z))) E.\n%solve D : stepv (app (app mult (s (s (s z)))) (s (s z))) E.\n\n%{\n|check=\"decl\"}%\n%solve D : stepv (app fact (s (s (s z)))) E.\n%{ }%\n\n%{\n\n{{Summer school 2008\n  |prev=Type safety for MinML (intrinsic encoding)\n  |prevname=Type safety for MinML (intrinsic encoding)\n  |next=Exercises 3\n  |nextname=Exercises 3\n}}\n\n}%"
          },
          "sha1": "2h1lc1yqwv9pd1ku09k5bi7kt8vglqq"
        }
      },
      {
        "title": "Summer school 2008:Type safety for MinML (intrinsic encoding)",
        "ns": 0,
        "id": 2054,
        "revision": {
          "id": 5304,
          "parentid": 5303,
          "timestamp": "2008-07-20T02:39:01Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 3565,
            "#text": "%{\n\n{{Summer school 2008\n  |noprevious=\n  |next=Type safety for MinML (extrinsic encoding)\n  |nextname=Type safety for MinML (extrinsic encoding)\n}}\n\nType safety for MinML: call-by-value, with recursive functions, in intrinsic form\n\n}%\n\n%{\n\n== Syntax / static semantics ==\n\nTypes:\n\n}%\n\ntp : type.\t\t\t\t%name tp T.\nnat : tp.\narr : tp -> tp -> tp.\n\n%{\n\nTyped expressions (i.e., typing derivations):\n\n}%\n\nexp : tp -> type.\t\t\t%name exp E.  %postfix 1 exp.\nz : nat exp.\ns : nat exp -> nat exp.\nifz : nat exp -> T exp -> (nat exp -> T exp) -> T exp.\nfun : {T1:tp} {T2:tp} ((arr T1 T2) exp -> T1 exp -> T2 exp) -> (arr T1 T2) exp.\napp : (arr T1 T2) exp -> T1 exp -> T2 exp.\n\n%{\n\n== Dynamic semantics / preservation ==\n\nValues:\n\n}%\n\nvalue : T exp -> type.\t\t\t%name value Dval.\n%mode value +E.\n\nvalue/z : value z.\nvalue/s : value (s E) <- value E.\nvalue/fun : value (fun _ _ _).\n\n%{\n\nTransition relation:\n\n}%\n\nstep : T exp -> T exp -> type.\t\t%name step Dstep.\n%mode step +E1 -E2.\n\nstep/s\n   : step (s E) (s E') <- step E E'.\nstep/ifz/arg\n   : step (ifz E E1 ([x] E2 x)) (ifz E' E1 ([x] E2 x))\n      <- step E E'.\nstep/ifz/z\n   : step (ifz z E1 ([x] E2 x)) E1.\nstep/ifz/s\n   : step (ifz (s E) E1 ([x] E2 x)) (E2 E)\n      <- value E.\nstep/app/fun\n   : step (app E1 E2) (app E1' E2)\n      <- step E1 E1'.\nstep/app/arg\n   : step (app E1 E2) (app E1 E2')\n      <- value E1 <- step E2 E2'.\nstep/app/beta-v\n   : step\n      (app (fun T1 T2 ([f] [x] E f x)) E2)\n      (E (fun T1 T2 ([f] [x] E f x)) E2)\n      <- value E2.\n\n%{\n\n== Progress ==\n\nThe sum type we return:\n\n}%\n\nval-or-step : T exp -> type.\t\t%name val-or-step Dvos.\nvos/val : val-or-step E <- value E.\nvos/step : val-or-step E <- step E _.\n\n%{ \n\n=== [[Output factoring|Factoring]] lemmas ===\n\n}%\n\nprog/s\n   : val-or-step E -> val-or-step (s E) -> type.\n%mode prog/s +Dvos1 -Dvos2.\n\n- : prog/s\n     (vos/step Dstep)\n     (vos/step (step/s Dstep)).\n- : prog/s\n     (vos/val Dval)\n     (vos/val (value/s Dval)).\n\n%worlds () (prog/s _ _).\n%total {} (prog/s _ _).\n\nprog/ifz\n   : val-or-step (E : nat exp)\n      -> {E1} {E2} (step (ifz E E1 ([x] E2 x)) E')\n      -> type.\n%mode prog/ifz +E +E1 +E2 -Dstep.\n\n- : prog/ifz (vos/step Dstep) _ _ (step/ifz/arg Dstep).\n- : prog/ifz (vos/val value/z) _ _ step/ifz/z.\n- : prog/ifz (vos/val (value/s Dval)) _ _ (step/ifz/s Dval).\n\n%worlds () (prog/ifz _ _ _ _).\n%total {} (prog/ifz _ _ _ _).\n\nprog/app\n   : val-or-step (E1 : (arr T2 T) exp)\n      -> val-or-step (E2 : T2 exp)\n      -> step (app E1 E2) E'\n      -> type.\n%mode prog/app +Dvos1 +Dvos2 -Dstep.\n\n- : prog/app\n     (vos/step Dstep1)\n     _\n     (step/app/fun Dstep1).\n\n- : prog/app\n     (vos/val Dval1)\n     (vos/step Dstep2)\n     (step/app/arg Dstep2 Dval1).\n\n- : prog/app\n     (vos/val Dval1)\n     (vos/val Dval2)\n     (step/app/beta-v Dval2).\n\n%worlds () (prog/app _ _ _).\n%total {} (prog/app _ _ _).\n\n%{\n\n=== Main theorem ===\n\n}%\n\nprog : {E : T exp} val-or-step E -> type. %name prog Dprog.\n%mode prog +E -Dvos.\n\n- : prog z (vos/val value/z).\n\n- : prog (s E) Dvos'\n     <- prog E Dvos\n     <- prog/s Dvos Dvos'.\n\n- : prog (ifz E E1 ([x] E2 x)) (vos/step Dstep)\n     <- prog E Dvos\n     <- prog/ifz Dvos _ _ Dstep.\n\n- : prog (fun _ _ _) (vos/val value/fun).\n\n- : prog (app E1 E2) (vos/step Dstep)\n     <- prog E1 Dvos1\n     <- prog E2 Dvos2\n     <- prog/app Dvos1 Dvos2 Dstep.\n\n%worlds () (prog _ _).\n%total Dof (prog Dof _).\n\n%{\nAnd thus we have proved type safety for MinML!\n\n\n{{Summer school 2008\n  |noprevious=\n  |next=Type safety for MinML (extrinsic encoding)\n  |nextname=Type safety for MinML (extrinsic encoding)\n}}\n\n}%"
          },
          "sha1": "p9ch948m6gl79lhfabia0pt7fflx274"
        }
      },
      {
        "title": "Summer school 2008:Type safety for MinML with monadic effects",
        "ns": 0,
        "id": 2074,
        "revision": {
          "id": 5328,
          "timestamp": "2008-07-22T02:22:16Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "comment": "New page: %{  {{Summer school 2008   |prev=Exercises 3   |prevname=Exercies 3   |nonext= }}  Type safety for MinML with monadic effects  }%  %{  == Syntax / static semantics ==  Types:  }%  tp : typ...",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 7118,
            "#text": "%{\n\n{{Summer school 2008\n  |prev=Exercises 3\n  |prevname=Exercies 3\n  |nonext=\n}}\n\nType safety for MinML with monadic effects\n\n}%\n\n%{\n\n== Syntax / static semantics ==\n\nTypes:\n\n}%\n\ntp : type.\t\t\t\t%name tp T.\nnat : tp.\narr : tp -> tp -> tp.\ncircle : tp -> tp.  %% called 'comp' in PFPL;\n                    %% the lax modality is often rendered as a circle \n\n%{\n\nNext, we define typed expressions (i.e., typing derivations).  There are\ntwo syntactic classes: pure expressions, and possibly-effectful\ncommands.\n\n}%\n\nexp  : tp -> type.\t\t\t%name exp E.  %postfix 1 exp.\ncommand : tp -> type.\t\t\t%name command M.  %postfix 1 command.\n\nz : nat exp.\ns : nat exp -> nat exp.\nifz : nat exp -> T exp -> (nat exp -> T exp) -> T exp.\nfun : {T1:tp} {T2:tp} ((arr T1 T2) exp -> T1 exp -> T2 exp) -> (arr T1 T2) exp.\napp : (arr T1 T2) exp -> T1 exp -> T2 exp.\ncomp : T command -> (circle T) exp.\n\nreturn : T exp -> T command.\nlet    : (circle T) exp -> (T exp -> U command) -> U command.\n\n%{\n\n== Dynamic semantics / preservation ==\n\n=== Values and final states ===\n\n}%\n\nvalue : T exp -> type.\t\t\t%name value Dval.\n%mode value +E.\n\nvalue/z : value z.\nvalue/s : value (s E) <- value E.\nvalue/fun : value (fun _ _ _).\nvalue/comp : value (comp _).\n\nfinal : T command -> type.                 %name final Dfin.\n%mode final +M.\n\nfinal/ret : final (return E)\n\t     <- value E.\n\n%{\n\n=== Transition relation for expressions ===\n\n}%\n\nstep : T exp -> T exp -> type.\t\t%name step Dstep.\n%mode step +E1 -E2.\n\nstep/s\n   : step (s E) (s E') <- step E E'.\nstep/ifz/arg\n   : step (ifz E E1 ([x] E2 x)) (ifz E' E1 ([x] E2 x))\n      <- step E E'.\nstep/ifz/z\n   : step (ifz z E1 ([x] E2 x)) E1.\nstep/ifz/s\n   : step (ifz (s E) E1 ([x] E2 x)) (E2 E)\n      <- value E.\nstep/app/fun\n   : step (app E1 E2) (app E1' E2)\n      <- step E1 E1'.\nstep/app/arg\n   : step (app E1 E2) (app E1 E2')\n      <- value E1 <- step E2 E2'.\nstep/app/beta-v\n   : step\n      (app (fun T1 T2 ([f] [x] E f x)) E2)\n      (E (fun T1 T2 ([f] [x] E f x)) E2)\n      <- value E2.\n\n%{\n\n=== Transition relation for commands === \n\n}%\n\nmstep : T command -> T command -> type.\t\t%name mstep Dstep.\n%mode mstep +E1 -E2.\n\nmstep/ret : mstep (return E) (return E')\n\t     <- step E E'.\nmstep/let-e : mstep (let E ([x] M x)) (let E' ([x] M x))\n\t       <- step E E'.\nmstep/let-m : mstep (let (comp M1) ([x] M2 x)) (let (comp M1') ([x] M2 x))\n\t       <- mstep M1 M1'.\nmstep/let-beta : mstep (let (comp (return E)) ([x] M x)) (M E)\n\t\t  <- final (return E).\n\n%{\n\n== Progress ==\n\nThe progress theorem for expressions does not require a corresponding\ntheorem for commands, because commands are suspended inside expressions\n(<tt>comp M</tt> is always a value).  We prove progress for expressions\nfirst, and for commands below.\n\n=== Return sums ===\n\n}%\n\nval-or-step : T exp -> type.\t\t%name val-or-step Dvos.\nvos/val : val-or-step E <- value E.\nvos/step : val-or-step E <- step E _.\n\nfin-or-mstep : T command -> type.       %name fin-or-mstep Dfos.\nfos/fin : fin-or-mstep M <- final M.\nfos/step : fin-or-mstep M <- mstep M _ .\n\n%{ \n\n=== [[Output factoring|Factoring]] lemmas ===\n\n}%\n\nprog/s\n   : val-or-step E -> val-or-step (s E) -> type.\n%mode prog/s +Dvos1 -Dvos2.\n\n- : prog/s\n     (vos/step Dstep)\n     (vos/step (step/s Dstep)).\n- : prog/s\n     (vos/val Dval)\n     (vos/val (value/s Dval)).\n\n%worlds () (prog/s _ _).\n%total {} (prog/s _ _).\n\nprog/ifz\n   : val-or-step (E : nat exp)\n      -> {E1} {E2} (step (ifz E E1 ([x] E2 x)) E')\n      -> type.\n%mode prog/ifz +E +E1 +E2 -Dstep.\n\n- : prog/ifz (vos/step Dstep) _ _ (step/ifz/arg Dstep).\n- : prog/ifz (vos/val value/z) _ _ step/ifz/z.\n- : prog/ifz (vos/val (value/s Dval)) _ _ (step/ifz/s Dval).\n\n%worlds () (prog/ifz _ _ _ _).\n%total {} (prog/ifz _ _ _ _).\n\nprog/app\n   : val-or-step (E1 : (arr T2 T) exp)\n      -> val-or-step (E2 : T2 exp)\n      -> step (app E1 E2) E'\n      -> type.\n%mode prog/app +Dvos1 +Dvos2 -Dstep.\n\n- : prog/app\n     (vos/step Dstep1)\n     _\n     (step/app/fun Dstep1).\n\n- : prog/app\n     (vos/val Dval1)\n     (vos/step Dstep2)\n     (step/app/arg Dstep2 Dval1).\n\n- : prog/app\n     (vos/val Dval1)\n     (vos/val Dval2)\n     (step/app/beta-v Dval2).\n\n%worlds () (prog/app _ _ _).\n%total {} (prog/app _ _ _).\n\n%{\n\n=== Progress for expressions ===\n\n}%\n\nprog : {E : T exp} val-or-step E -> type. %name prog Dprog.\n%mode prog +E -Dvos.\n\n- : prog z (vos/val value/z).\n\n- : prog (s E) Dvos'\n     <- prog E Dvos\n     <- prog/s Dvos Dvos'.\n\n- : prog (ifz E E1 ([x] E2 x)) (vos/step Dstep)\n     <- prog E Dvos\n     <- prog/ifz Dvos _ _ Dstep.\n\n- : prog (fun _ _ _) (vos/val value/fun).\n\n- : prog (app E1 E2) (vos/step Dstep)\n     <- prog E1 Dvos1\n     <- prog E2 Dvos2\n     <- prog/app Dvos1 Dvos2 Dstep.\n\n- : prog (comp M) (vos/val value/comp).\n\n%worlds () (prog _ _).\n%total Dof (prog Dof _).\n\n%{\n\n=== Factoring lemmas for commands ===\n\n}%\n\nmprog/ret : val-or-step E -> fin-or-mstep (return E) -> type.\n%mode mprog/ret +X1 -X2.\n\n- : mprog/ret (vos/val Dval) (fos/fin (final/ret Dval)).\n- : mprog/ret (vos/step Dstep) (fos/step (mstep/ret Dstep)).\n\n%worlds () (mprog/ret _ _).\n%total {} (mprog/ret _ _).\n\nmprog/let-comp : fin-or-mstep (M1 : T command) -> {M2 : (T exp -> U command) } mstep (let (comp M1) M2) M' -> type.\n%mode mprog/let-comp +X1 +X2 -X3.\n\n- : mprog/let-comp \n     (fos/fin ((final/ret Dval) : final (return E))) \n     M2 \n     ((mstep/let-beta (final/ret Dval)) : mstep (let (comp (return E)) M2) (M2 E)).\n\n- : mprog/let-comp \n     (fos/step \n\t(Dmstep : mstep M1 M1')\n\t)\n     M2\n     ((mstep/let-m Dmstep) : mstep (let (comp M1) M2) (let (comp M1') M2)).\n\n%worlds () (mprog/let-comp _ _ _).\n%total {} (mprog/let-comp _ _ _).\n\n%{\n\n=== Progress for commands ===\n\nThe factoring lemma for <tt>let</tt> is is mutually recursive with the\nmain theorem---when the <tt>let</tt>-bound expression is <tt>comp\nM</tt>, we need to recursively appeal to progress on <tt>M</tt>. \n\n}%\n\nmprog/let : {E : (circle T) exp} val-or-step E -> {M : (T exp -> U command) } mstep (let E M) M' -> type.\n%mode mprog/let +X1 +X2 +X3 -X4.\n\nmprog : {M : T command} fin-or-mstep M -> type.\n%mode mprog +M -Dfos.\n\n%% mprog/let\n\n- : mprog/let (comp M) (vos/val value/comp) _ Dmstep\n     <- mprog M Dfos\n     <- mprog/let-comp Dfos _ Dmstep.\n\n- : mprog/let _ (vos/step Dstep) _ (mstep/let-e Dstep).\n\n%% mprog\n\n- : mprog (return E) Dfos\n     <- prog E Dvos\n     <- mprog/ret Dvos Dfos.  \n\n- : mprog \n     (let (E : (circle T) exp)\n\t(M : (T exp -> U command)))\n     (fos/step Dmstep)\n     <- prog E (Dvos : val-or-step E)\n     <- mprog/let E Dvos M (Dmstep : mstep (let E M) M').\n\n%worlds () (mprog _ _) (mprog/let _ _ _ _).\n%total (M E) (mprog M _) (mprog/let E _ _ _).\n\n%{\nBecause <tt>mprog</tt> and <tt>mprog/let</tt> are mutually recursive, we:\n# Declare and give modes for both type families before declaring their constants.\n# Declare their worlds simulataneously, by putting two call-patterns in the world declaration.\n# Prove them total simultaneously, with the mutual termination order <tt>(M E)</tt>.\n\nAnd thus we have proved type safety for MinML with monadic effects!\n\n{{Summer school 2008\n  |prev=Exercises 3\n  |prevname=Exercies 3\n  |nonext=\n}}\n\n}%"
          },
          "sha1": "eoohceugp08h1aokbb8wc72mt74u5pj"
        }
      },
      {
        "title": "Summer school 2008:Type safety for MinML with monadic effects (putngetn)",
        "ns": 0,
        "id": 2075,
        "revision": {
          "id": 5330,
          "parentid": 5329,
          "timestamp": "2008-07-22T02:25:42Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 7369,
            "#text": "%{\n\n{{Summer school 2008\n  |prev=Exercises 3\n  |prevname=Exercies 3\n  |nonext=\n}}\n\nType safety for MinML with monadic effects, with putn and getn primitives.\n\n}%\n\n%{\n\n== Syntax / static semantics ==\n\nTypes:\n\n}%\n\ntp : type.\t\t\t\t%name tp T.\nnat : tp.\narr : tp -> tp -> tp.\ncircle : tp -> tp.\n\n%{\n\nTyped expressions (i.e., typing derivations):\n\n}%\n\nexp  : tp -> type.\t\t\t%name exp E.  %postfix 1 exp.\ncommand : tp -> type.\t\t\t%name command M.  %postfix 1 command.\n\nz : nat exp.\ns : nat exp -> nat exp.\nifz : nat exp -> T exp -> (nat exp -> T exp) -> T exp.\nfun : {T1:tp} {T2:tp} ((arr T1 T2) exp -> T1 exp -> T2 exp) -> (arr T1 T2) exp.\napp : (arr T1 T2) exp -> T1 exp -> T2 exp.\ncomp : T command -> (circle T) exp.\n\nreturn : T exp -> T command.\nlet    : (circle T) exp -> (T exp -> U command) -> U command.\ngetn   : (nat exp -> U command) -> U command.\nputn   : nat exp -> U command -> U command.\n\n%{\n\n== Dynamic semantics / preservation ==\n\n=== Values and final states ===\n\n}%\n\nvalue : T exp -> type.\t\t\t%name value Dval.\n%mode value +E.\n\nvalue/z : value z.\nvalue/s : value (s E) <- value E.\nvalue/fun : value (fun _ _ _).\nvalue/comp : value (comp _).\n\nfinal : T command -> type.                 %name final Dfin.\n%mode final +M.\n\nfinal/ret : final (return E)\n\t     <- value E.\n\n%{\n\n=== Transition relation for expressions ===\n\n}%\n\nstep : T exp -> T exp -> type.\t\t%name step Dstep.\n%mode step +E1 -E2.\n\nstep/s\n   : step (s E) (s E') <- step E E'.\nstep/ifz/arg\n   : step (ifz E E1 ([x] E2 x)) (ifz E' E1 ([x] E2 x))\n      <- step E E'.\nstep/ifz/z\n   : step (ifz z E1 ([x] E2 x)) E1.\nstep/ifz/s\n   : step (ifz (s E) E1 ([x] E2 x)) (E2 E)\n      <- value E.\nstep/app/fun\n   : step (app E1 E2) (app E1' E2)\n      <- step E1 E1'.\nstep/app/arg\n   : step (app E1 E2) (app E1 E2')\n      <- value E1 <- step E2 E2'.\nstep/app/beta-v\n   : step\n      (app (fun T1 T2 ([f] [x] E f x)) E2)\n      (E (fun T1 T2 ([f] [x] E f x)) E2)\n      <- value E2.\n\n%{\n\n=== Labelled transition relation for commands === \n\n}%\n\nlabel : type.  %name label L.\nlabel/read  : (value (N : nat exp)) -> label.\nlabel/write : (value (N : nat exp)) -> label.\nlabel/sil   : label. %% silent transition\n\nmstep : T command -> T command -> label -> type.\t\t%name mstep Dstep.\n%mode mstep +E1 *E2 *L.\n\nmstep/ret : mstep (return E) (return E') label/sil\n\t     <- step E E'.\nmstep/let-e : mstep (let E ([x] M x)) (let E' ([x] M x)) label/sil\n\t       <- step E E'.\nmstep/let-m : mstep (let (comp M1) ([x] M2 x)) (let (comp M1') ([x] M2 x)) L\n\t       <- mstep M1 M1' L.\nmstep/let-beta : mstep (let (comp (return E)) ([x] M x)) (M E) label/sil\n\t\t  <- final (return E).\nmstep/getn : mstep (getn ([x] M x)) (M E) (label/read (Dval : value E)).\nmstep/putn : mstep (putn E M) (putn E' M) label/sil\n\t      <- step E E'.\nmstep/putn-put : mstep (putn E M) M (label/write (Dval : value E)).\n\n%{\n\n== Progress ==\n\n=== Return sums ===\n\n}%\n\nval-or-step : T exp -> type.\t\t%name val-or-step Dvos.\nvos/val : val-or-step E <- value E.\nvos/step : val-or-step E <- step E _.\n\nfin-or-mstep : T command -> type.       %name fin-or-mstep Dfos.\nfos/fin : fin-or-mstep M <- final M.\nfos/step : fin-or-mstep M <- mstep M _ _.\n\n%{ \n\n=== [[Output factoring|Factoring]] lemmas ===\n\n}%\n\nprog/s\n   : val-or-step E -> val-or-step (s E) -> type.\n%mode prog/s +Dvos1 -Dvos2.\n\n- : prog/s\n     (vos/step Dstep)\n     (vos/step (step/s Dstep)).\n- : prog/s\n     (vos/val Dval)\n     (vos/val (value/s Dval)).\n\n%worlds () (prog/s _ _).\n%total {} (prog/s _ _).\n\nprog/ifz\n   : val-or-step (E : nat exp)\n      -> {E1} {E2} (step (ifz E E1 ([x] E2 x)) E')\n      -> type.\n%mode prog/ifz +E +E1 +E2 -Dstep.\n\n- : prog/ifz (vos/step Dstep) _ _ (step/ifz/arg Dstep).\n- : prog/ifz (vos/val value/z) _ _ step/ifz/z.\n- : prog/ifz (vos/val (value/s Dval)) _ _ (step/ifz/s Dval).\n\n%worlds () (prog/ifz _ _ _ _).\n%total {} (prog/ifz _ _ _ _).\n\nprog/app\n   : val-or-step (E1 : (arr T2 T) exp)\n      -> val-or-step (E2 : T2 exp)\n      -> step (app E1 E2) E'\n      -> type.\n%mode prog/app +Dvos1 +Dvos2 -Dstep.\n\n- : prog/app\n     (vos/step Dstep1)\n     _\n     (step/app/fun Dstep1).\n\n- : prog/app\n     (vos/val Dval1)\n     (vos/step Dstep2)\n     (step/app/arg Dstep2 Dval1).\n\n- : prog/app\n     (vos/val Dval1)\n     (vos/val Dval2)\n     (step/app/beta-v Dval2).\n\n%worlds () (prog/app _ _ _).\n%total {} (prog/app _ _ _).\n\n%{\n\n=== Progress for expressions ===\n\n}%\n\nprog : {E : T exp} val-or-step E -> type. %name prog Dprog.\n%mode prog +E -Dvos.\n\n- : prog z (vos/val value/z).\n\n- : prog (s E) Dvos'\n     <- prog E Dvos\n     <- prog/s Dvos Dvos'.\n\n- : prog (ifz E E1 ([x] E2 x)) (vos/step Dstep)\n     <- prog E Dvos\n     <- prog/ifz Dvos _ _ Dstep.\n\n- : prog (fun _ _ _) (vos/val value/fun).\n\n- : prog (app E1 E2) (vos/step Dstep)\n     <- prog E1 Dvos1\n     <- prog E2 Dvos2\n     <- prog/app Dvos1 Dvos2 Dstep.\n\n- : prog (comp M) (vos/val value/comp).\n\n%worlds () (prog _ _).\n%total Dof (prog Dof _).\n\n%{\n\n=== Factoring lemmas for commands ===\n\n}%\n\nmprog/ret : val-or-step E -> fin-or-mstep (return E) -> type.\n%mode mprog/ret +X1 -X2.\n\n- : mprog/ret (vos/val Dval) (fos/fin (final/ret Dval)).\n- : mprog/ret (vos/step Dstep) (fos/step (mstep/ret Dstep)).\n\n%worlds () (mprog/ret _ _).\n%total {} (mprog/ret _ _).\n\nmprog/let-comp : fin-or-mstep (M1 : T command) -> {M2 : (T exp -> U command) } mstep (let (comp M1) M2) M' L -> type.\n%mode mprog/let-comp +X1 +X2 -X3.\n\n- : mprog/let-comp \n     (fos/fin ((final/ret Dval) : final (return E))) \n     M2 \n     ((mstep/let-beta (final/ret Dval)) : mstep (let (comp (return E)) M2) (M2 E) label/sil).\n\n- : mprog/let-comp \n     (fos/step \n\t(Dmstep : mstep M1 M1' L)\n\t)\n     M2\n     ((mstep/let-m Dmstep) : mstep (let (comp M1) M2) (let (comp M1') M2) L).\n\n%worlds () (mprog/let-comp _ _ _).\n%total {} (mprog/let-comp _ _ _).\n\nmprog/putn : val-or-step E -> {M} mstep (putn E M) M' L -> type.\n%mode mprog/putn +X1 +X3 -X2.\n\n- : mprog/putn (vos/val Dval) M (mstep/putn-put : mstep (putn E M) M (label/write Dval)).\n- : mprog/putn (vos/step Dstep) _ (mstep/putn Dstep).\n\n%worlds () (mprog/putn _ _ _).\n%total {} (mprog/putn _ _ _).\n\n%{\n\n=== Progress for commands ===\n\nOne of the factoring lemmas is mutually recursive with the main theorem:\n\n}%\n\nmprog/let : {E : (circle T) exp} val-or-step E -> {M : (T exp -> U command) } mstep (let E M) M' L -> type.\n%mode mprog/let +X1 +X2 +X3 -X4.\n\nmprog : {M : T command} fin-or-mstep M -> type.\n%mode mprog +M -Dfos.\n\n%% mprog/let\n\n- : mprog/let (comp M) (vos/val value/comp) _ Dmstep\n     <- mprog M Dfos\n     <- mprog/let-comp Dfos _ Dmstep.\n\n- : mprog/let _ (vos/step Dstep) _ (mstep/let-e Dstep).\n\n%% mprog\n\n- : mprog (return E) Dfos\n     <- prog E Dvos\n     <- mprog/ret Dvos Dfos.  \n\n- : mprog \n     (let (E : (circle T) exp)\n\t(M : (T exp -> U command)))\n     (fos/step Dmstep)\n     <- prog E (Dvos : val-or-step E)\n     <- mprog/let E Dvos M (Dmstep : mstep (let E M) M' L).\n\n%%FIXME: weird that we have to pick a number here...\n%%       maybe this isn't the right theorem\n- : mprog (getn M) (fos/step (mstep/getn : mstep (getn M) (M z) (label/read (value/z)))).\n\n- : mprog (putn E M) (fos/step Dmstep)\n     <- prog E Dvos\n     <- mprog/putn Dvos M Dmstep.\n\n%worlds () (mprog _ _) (mprog/let _ _ _ _).\n%total (M E) (mprog M _) (mprog/let E _ _ _).\n\n\n%{\nAnd thus we have proved type safety for MinML with monadic effects!\n\n{{Summer school 2008\n  |prev=Exercises 3\n  |prevname=Exercies 3\n  |nonext=\n}}\n\n}%"
          },
          "sha1": "d9smdo2pwl8ij9qpfry1h0i7rdiyjmf"
        }
      },
      {
        "title": "Summer school 2008:Type safety for polymorphic MinML (intrinsic encoding)",
        "ns": 0,
        "id": 2055,
        "revision": {
          "id": 5196,
          "timestamp": "2008-07-17T23:20:29Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "comment": "New page: %{ MinML: call-by-value, with recursive functions, using an intrinsic encoding }%   %{ == Types == }%  tp : type.\t\t\t\t%name tp T. nat : tp. arr : tp -> tp -> tp. all : (tp -> tp) -> tp.  %{...",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 3987,
            "#text": "%{\nMinML: call-by-value, with recursive functions, using an intrinsic encoding\n}% \n\n%{\n== Types ==\n}%\n\ntp : type.\t\t\t\t%name tp T.\nnat : tp.\narr : tp -> tp -> tp.\nall : (tp -> tp) -> tp.\n\n%{ \n== Syntax / static semantics ==\n}%\n\nexp : tp -> type.\t\t\t%name exp E.\n\nz : exp nat.\ns : exp nat -> exp nat.\nifz : exp nat -> exp T -> (exp nat -> exp T) -> exp T.\nfun : {T1} {T2} (exp (arr T1 T2) -> exp T1 -> exp T2) -> exp (arr T1 T2).\napp : exp (arr T2 T) -> exp T2 -> exp T.\ntfun : ({a : tp} exp (T a)) -> exp (all [a] T a).\ntapp : exp (all [a] T a) -> {T2 : tp} exp (T T2). \n\n%{\n== Dynamic Semantics / Preservation ==\n}%\n\nvalue : exp T -> type.\t\t\t%name value Dval.\n%mode value +E.\n\nvalue/z : value z.\nvalue/s : value (s E) <- value E.\nvalue/fun : value (fun _ _ _).\nvalue/tfun : value (tfun _).\n\nstep : exp T -> exp T -> type.\t\t%name step Dstep.\n%mode step +E1 -E2.\n\nstep/s\n   : step (s E) (s E') <- step E E'.\nstep/ifz/arg\n   : step (ifz E E1 ([x] E2 x)) (ifz E' E1 ([x] E2 x))\n      <- step E E'.\nstep/ifz/z\n   : step (ifz z E1 ([x] E2 x)) E1.\nstep/ifz/s\n   : step (ifz (s E) E1 ([x] E2 x)) (E2 E)\n      <- value E.\nstep/app/fun\n   : step (app E1 E2) (app E1' E2)\n      <- step E1 E1'.\nstep/app/arg\n   : step (app E1 E2) (app E1 E2')\n      <- value E1 <- step E2 E2'.\nstep/app/beta-v\n   : step\n      (app (fun T1 T2 ([f] [x] E f x)) E2)\n      (E (fun T1 T2 ([f] [x] E f x)) E2)\n      <- value E2.\nstep/tapp/tfun\n   : step (tapp E T) (tapp E' T)\n      <- step E E'.\nstep/tapp/beta\n   : step (tapp (tfun ([a] E a)) T) (E T).\n\n%{\n== Progress ==\n}%\n\nval-or-step : exp T -> type.\t\t%name val-or-step Dvos.\nvos/val : val-or-step E <- value E.\nvos/step : val-or-step E <- step E _.\n\n%{\n=== Factoring lemmas ===\n\nThese are necessary for case-analyzing the results of recursive calls.\n\n}%\n\nprog/s\n   : val-or-step E -> val-or-step (s E) -> type.\n%mode prog/s +Dvos1 -Dvos2.\n\n- : prog/s\n     (vos/step Dstep)\n     (vos/step (step/s Dstep)).\n\n- : prog/s\n     (vos/val Dval)\n     (vos/val (value/s Dval)).\n\n%worlds () (prog/s _ _).\n%total {} (prog/s _ _).\n\nprog/ifz : val-or-step (E : exp nat)\n\t    -> {E1} {E2}\n\t       step (ifz E E1 ([x] E2 x)) E'\n\t    -> type.\n%mode prog/ifz +E +E1 +E2 -Dstep.\n\n- : prog/ifz (vos/step Dstep) _ _ (step/ifz/arg Dstep).\n\n- : prog/ifz (vos/val value/z) _ _ step/ifz/z.\n\n- : prog/ifz (vos/val (value/s Dval)) _ _ (step/ifz/s Dval).\n\n%worlds () (prog/ifz _ _ _ _).\n%total {} (prog/ifz _ _ _ _).\n\nprog/app : val-or-step (E1 : exp (arr T2 T))\n\t    -> val-or-step E2\n\t    -> step (app E1 E2) E'\n\t    -> type.\n%mode prog/app +Dvos1 +Dvos2 -Dstep.\n\n- : prog/app\n     (vos/step Dstep1)\n     _\n     (step/app/fun Dstep1).\n\n- : prog/app\n     (vos/val Dval1)\n     (vos/step Dstep2)\n     (step/app/arg Dstep2 Dval1).\n\n- : prog/app\n     (vos/val Dval1)\n     (vos/val Dval2)\n     (step/app/beta-v Dval2).\n\n%worlds () (prog/app _ _ _).\n%total {} (prog/app _ _ _).\n\nprog/tapp : val-or-step (E : exp (all [a] T a))\n\t    -> {T'} \n\t       {E'}  %% otherwise, the type of E' can't mention T'\n\t       step (tapp E T') E'   \n\t    -> type.\n%mode prog/tapp +E +T' -E' -Dstep.\n\n- : prog/tapp\n     (vos/step Dstep1)\n     _ _\n     (step/tapp/tfun Dstep1).\n\n- : prog/tapp\n     (vos/val Dval)\n     _ _\n     step/tapp/beta.\n\n%worlds () (prog/tapp _ _ _ _).\n%total {} (prog/tapp _ _ _ _).\n\n%{ \n== Main theorem ==\n}%\n\nprog : {E : exp T} val-or-step E -> type. \n%mode prog +Dof -Dvos.\n\n- : prog z (vos/val value/z).\n\n- : prog (s E') Dvos'\n     <- prog E' Dvos\n     <- prog/s Dvos Dvos'.\n\n- : prog (ifz E E0 ([x] E1 x)) (vos/step Dstep)\n     <- prog E Dvos\n     <- prog/ifz Dvos _ _ Dstep.\n\n- : prog (fun _ _ _) (vos/val value/fun).\n\n- : prog (app E1 E2) (vos/step Dstep)\n     <- prog E1 Dvos1\n     <- prog E2 Dvos2\n     <- prog/app Dvos1 Dvos2 Dstep.\n\n- : prog (tfun _) (vos/val value/tfun).\n\n- : prog (tapp E T) (vos/step Dstep)\n     <- prog E Dvos\n     <- prog/tapp Dvos _ _ Dstep.\n\n%worlds () (prog _ _).\n%total Dof (prog Dof _).\n\n%{\nAnd thus we have proved type safety for MinML with polymorphism!\n}%"
          },
          "sha1": "5t34a6kjdpxzx75tlmodla8cf7uh4wy"
        }
      },
      {
        "title": "Summer school 2008:Typed arithmetic expressions",
        "ns": 0,
        "id": 2064,
        "revision": {
          "id": 5284,
          "parentid": 5262,
          "timestamp": "2008-07-20T01:47:17Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 3294,
            "#text": "%{\n\n{{Summer school 2008\n  |prev=Arithmetic expressions with let-binding (hypothetical evaluation)\n  |prevname=Arithmetic expressions with let-binding (hypothetical evaluation)\n  |next=Typed arithmetic expressions (extrinsic encoding)\n  |nextname=Typed arithmetic expressions (extrinsic encoding)\n}}\n\nNext, we add another base type besides numbers.\n\n== Numbers and addition ==\n\nNatural numbers and addition are the same as before:\n\n}%\n\nnat : type.             %name nat M.\nz : nat.\ns : nat -> nat.\n\nadd : nat -> nat -> nat -> type.\n%mode add +M +N -P.\n\nadd/z : add z N N.\nadd/s : add (s M) N (s P) <- add M N P.\n\n%worlds () (add _ _ _).\n%total M (add M _ _).\n\n%{\n\n== Strings and append ==\n\nStrings and append are analogous\n\n}%\n\nchar : type.\t\t\t\t%name char X.\na : char.\nb : char.\n\nstr : type.\t\t\t\t%name str S.\nemp : str.\ncons : char -> str -> str.\n\ncat : str -> str -> str -> type.\n%mode cat +S1 +S2 -S3.\n\ncat/e : cat emp S S.\ncat/c : cat (cons X S1) S2 (cons X S3) <- cat S1 S2 S3.\n\n%worlds () (cat _ _ _).\n%total S (cat S _ _).\n\n%{\n\n== Typed expressions ==\n\nThere are two types:\n\n}%\n\ntp : type.\t\t\t\t%name tp T.\nnumber : tp.\nstring : tp.\n\n%{\n\nWe use an [[intrinsic encoding]], where only well-typed terms are\nrepresented.  Another way of looking at this is that we skip raw syntax\nand work directly with typing derivations. This works well for\nsimply-typed languages, where the raw syntax for well-typed terms is\nisomorphic to its typing derivations.\n\n}%\n\nval : tp -> type.\t\t\t%name val V.  %postfix 1 val.\nnum : nat -> number val.\nlit : str -> string val.\n\nexp : tp -> type.\t\t\t%name exp E.  %postfix 1 exp.\nret : T val -> T exp.\nplus : number exp -> number exp -> number exp.\nappend : string exp -> string exp -> string exp.\nlet : T exp -> (T val -> U exp) -> U exp.\n\n%{\n\nAnswers are typed as well:\n\n}%\n\nans : tp -> type.\t\t\t%name ans A.  %postfix 1 ans.\nanum : nat -> number ans.\nastr : str -> string ans.\n\n%{ \n\nEvaluation relates an expression to an answer of the same type,\nguaranteeing type preservation.  \n\nBecause of Twelf's implicit argument mechanism, the cases for numbers\nand let-binding are unchanged.\n\n}%\n\neval : T exp -> T ans -> type.\n%mode eval +E1 -E2.\n\neval/val/num\n   : eval (ret (num N)) (anum N).\n\neval/val/str\n   : eval (ret (lit S)) (astr S).\n\neval/plus\n   : eval (plus E1 E2) (anum N)\n      <- eval E1 (anum N1)\n      <- eval E2 (anum N2)\n      <- add N1 N2 N.\n\neval/append\n   : eval (append E1 E2) (astr S)\n      <- eval E1 (astr S1)\n      <- eval E2 (astr S2)\n      <- cat S1 S2 S.\n\neval/let/num\n   : eval (let E1 ([x] E2 x)) A\n      <- eval E1 (anum N)\n      <- eval (E2 (num N)) A.\n\neval/let/str\n   : eval (let E1 ([x] E2 x)) A\n      <- eval E1 (astr S)\n      <- eval (E2 (lit S)) A.\n\n%worlds () (eval _ _).\n%total E (eval E _).\n\n%{\n\nNote: in this example <tt>ans</tt> is isomorphic to <tt>val</tt>, so we can simplify things slightly by not making the distinction.  (See [[Summer school 2008:Typed arithmetic expressions (value)|Typed arithmetic expressions (value)]]).\n\n{{Summer school 2008\n  |prev=Arithmetic expressions with let-binding (hypothetical evaluation)\n  |prevname=Arithmetic expressions with let-binding (hypothetical evaluation)\n  |next=Typed arithmetic expressions (extrinsic encoding)\n  |nextname=Typed arithmetic expressions (extrinsic encoding)\n}}\n\n}%"
          },
          "sha1": "2i6rt1473c4ho4u72ym0twhes5psk2l"
        }
      },
      {
        "title": "Summer school 2008:Typed arithmetic expressions (extrinsic encoding)",
        "ns": 0,
        "id": 2065,
        "revision": {
          "id": 5269,
          "parentid": 5245,
          "timestamp": "2008-07-19T23:44:18Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 2917,
            "#text": "%{\n\n{{Summer school 2008\n   |prev=Typed arithmetic expressions\n   |prevname=Typed arithmetic expressions\n   |next=Exercises 1\n   |nextname=Exercises 1\n   }}\n\nHere we take a more traditional approach to representing syntax, by\nfirst giving a definition of raw syntax, with a separate judgement\ndefining the well-typed expressions.  This is called an [[extrinsic encoding]].\n\nNumbers and strings are as before.\n\n|hidden=\"true\"}%\n\nnat : type.             %name nat M.\nz : nat.\ns : nat -> nat.\n\nadd : nat -> nat -> nat -> type.\n%mode add +M +N -P.\n\nadd/z : add z N N.\nadd/s : add (s M) N (s P) <- add M N P.\n\n%% addition is a total function on closed terms of type nat\n\n%worlds () (add _ _ _).\n%total M (add M _ _).\n\nchar : type.\t\t\t\t%name char X.\na : char.\nb : char.\n\nstr : type.\t\t\t\t%name str S.\nemp : str.\ncons : char -> str -> str.\n\ncat : str -> str -> str -> type.\n%mode cat +S1 +S2 -S3.\n\ncat/e : cat emp S S.\ncat/c : cat (cons X S1) S2 (cons X S3) <- cat S1 S2 S3.\n\n%worlds () (cat _ _ _).\n%total S (cat S _ _).\n\n%{\n\n== Raw syntax ==\n\n}%\n\ntp : type.\t\t\t\t%name tp T.\nnumber : tp.\nstring : tp.\n\nval : type.\t\t\t\t%name val V.\nnum : nat -> val.\nlit : str -> val.\n\nexp : type.\t\t\t\t%name exp E.\nret : val -> exp.\nplus : exp -> exp -> exp.\nappend : exp -> exp -> exp.\nlet : exp -> (val -> exp) -> exp.\n\n%{\n\n== Typing judgement on raw syntax ==\n\n}%\n\nofv : val -> tp -> type.\t\t%name ofv Dofv.\n%mode ofv +V -T.\n\n- : ofv (num _) number.\n- : ofv (lit _) string.\n\nof : exp -> tp -> type.\t\t\t%name of Dof.\n%mode of +E -T.\n\n- : of (ret V) T <- ofv V T.\n- : of (plus E1 E2) number <- of E1 number <- of E2 number.\n- : of (append E1 E2) string <- of E1 string <- of E2 string.\n- : of (let E1 ([x] E2 x)) T' <- of E1 T <- ({x:val} ofv x T -> of (E2 x) T').\n\n%{\n\n== Evaluation ==\n\n=== Answers ===\n\n}%\n\nans : type.\t\t\t\t%name ans A.\nanum : nat -> ans.\nastr : str -> ans.\n\nofa : ans -> tp -> type.\t\t%name ofa Dofa.\n%mode ofa +A -T.\n\n- : ofa (anum _) number.\n- : ofa (astr _) string.\n\n%{\n\n=== Evaluation judgement on raw syntax ===\n\n}%\n\neval : exp -> ans -> type.\n%mode eval +E1 -E2.\n\neval/val/num\n   : eval (ret (num N)) (anum N).\n\neval/val/lit\n   : eval (ret (lit S)) (astr S).\n\neval/plus\n   : eval (plus E1 E2) (anum N)\n      <- eval E1 (anum N1)\n      <- eval E2 (anum N2)\n      <- add N1 N2 N.\n\neval/append\n   : eval (append E1 E2) (astr S)\n      <- eval E1 (astr S1)\n      <- eval E2 (astr S2)\n      <- cat S1 S2 S.\n\neval/let\n   : eval (let E1 ([x] E2 x)) A\n      <- eval E1 (anum N)\n      <- eval (E2 (num N)) A.\n\n%{\n\nEvaluation is not total because of run-time type errors!  (e.g., try\nappending two numbers).  \n\n}%\n\n%worlds () (eval _ _).\n\n%{\n\nTwelf gives this error, refering to the first recursive call of <tt>eval/plus</tt>.\n\n<twelf check=\"decl\">\n%total E (eval E _).\n</twelf>\n\n{{Summer school 2008\n   |prev=Typed arithmetic expressions\n   |prevname=Typed arithmetic expressions\n   |next=Exercises 1\n   |nextname=Exercises 1\n   }}\n\n}%"
          },
          "sha1": "7nqip3qtsw5s67667qqp21kvp9xvbcs"
        }
      },
      {
        "title": "Summer school 2008:Typed arithmetic expressions (value)",
        "ns": 0,
        "id": 2068,
        "revision": {
          "id": 5265,
          "parentid": 5263,
          "timestamp": "2008-07-19T23:38:21Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 1725,
            "#text": "%{\n\n{{Summer school 2008\n  |prev=Typed arithmetic expressions\n  |prevname=Typed arithmetic expressions\n  |nonext=\n}}\n\nArithmetic expressions, where the answer type is values. \n\n}%\n\nnat : type.             %name nat M.\nz : nat.\ns : nat -> nat.\n\nadd : nat -> nat -> nat -> type.\n%mode add +M +N -P.\n\nadd/z : add z N N.\nadd/s : add (s M) N (s P) <- add M N P.\n\n%worlds () (add _ _ _).\n%total M (add M _ _).\n\nchar : type.\t\t\t\t%name char X.\na : char.\nb : char.\n\nstr : type.\t\t\t\t%name str S.\nemp : str.\ncons : char -> str -> str.\n\ncat : str -> str -> str -> type.\n%mode cat +S1 +S2 -S3.\n\ncat/e : cat emp S S.\ncat/c : cat (cons X S1) S2 (cons X S3) <- cat S1 S2 S3.\n\n%worlds () (cat _ _ _).\n%total S (cat S _ _).\n\n%{\n\n== Typed expressions ==\n\n}%\n\ntp : type.\t\t\t\t%name tp T.\nnumber : tp.\nstring : tp.\n\nval : tp -> type.\t\t\t%name val V.  %postfix 1 val.\nnum : nat -> number val.\nlit : str -> string val.\n\nexp : tp -> type.\t\t\t%name exp E.  %postfix 1 exp.\nret : T val -> T exp.\nplus : number exp -> number exp -> number exp.\nappend : string exp -> string exp -> string exp.\nlet : T exp -> (T val -> U exp) -> U exp.\n\n%{\n\nFor simplicity, take answers to be values. \n\n}%\n\neval : T exp -> T val -> type.\n%mode eval +E1 -E2.\n\neval/val\n   : eval (ret V) V.\n\neval/plus\n   : eval (plus E1 E2) (num N)\n      <- eval E1 (num N1)\n      <- eval E2 (num N2)\n      <- add N1 N2 N.\n\neval/append\n   : eval (append E1 E2) (lit S)\n      <- eval E1 (lit S1)\n      <- eval E2 (lit S2)\n      <- cat S1 S2 S.\n\neval/let\n   : eval (let E1 ([x] E2 x)) A\n      <- eval E1 V\n      <- eval (E2 V) A.\n\n%worlds () (eval _ _).\n%total E (eval E _).\n\n%{\n\n{{Summer school 2008\n  |prev=Typed arithmetic expressions\n  |prevname=Typed arithmetic expressions\n  |nonext=\n}}\n\n}%"
          },
          "sha1": "1ppk0eif62af80p4db4q2wwybaaz7gq"
        }
      },
      {
        "title": "Summer school 2008:Typed arithmetic expressions with pairs",
        "ns": 0,
        "id": 2053,
        "revision": {
          "id": 5261,
          "parentid": 5258,
          "timestamp": "2008-07-19T23:36:09Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 2040,
            "#text": "%{\n\n{{Summer school 2008\n  |prev=Exercises 1\n  |prevname=Exercises 1\n  |nonext=\n}}\n\nArithmetic expressions with pairs.\n\nNumbers and strings are unchanged.\n\n|hidden=\"true\"}%\n\nnat : type.             %name nat M.\nz : nat.\ns : nat -> nat.\n\nadd : nat -> nat -> nat -> type.\n%mode add +M +N -P.\n\nadd/z : add z N N.\nadd/s : add (s M) N (s P) <- add M N P.\n\n%worlds () (add _ _ _).\n%total M (add M _ _).\n\nchar : type.\t\t\t\t%name char X.\na : char.\nb : char.\n\nstr : type.\t\t\t\t%name str S.\nemp : str.\ncons : char -> str -> str.\n\ncat : str -> str -> str -> type.\n%mode cat +S1 +S2 -S3.\n\ncat/e : cat emp S S.\ncat/c : cat (cons X S1) S2 (cons X S3) <- cat S1 S2 S3.\n\n%worlds () (cat _ _ _).\n%total S (cat S _ _).\n\n%{\n\n== Typed expressions ==\n\nAdd a type for products:\n\n}%\n\ntp : type.\t\t\t\t%name tp T.\nnumber : tp.\nstring : tp.\nprod   : tp -> tp -> tp.\n\n%{\n\nAdd pairs as a value, projections as expressions:\n\n}%\n\nval : tp -> type.\t\t\t%name val V.  %postfix 1 val.\nnum : nat -> number val.\nlit : str -> string val.\npair : T val -> U val -> (prod T U) val.\n\nexp : tp -> type.\t\t\t%name exp E.  %postfix 1 exp.\nret : T val -> T exp.\nplus : number exp -> number exp -> number exp.\nappend : string exp -> string exp -> string exp.\nlet : T exp -> (T val -> U exp) -> U exp.\nfst : (prod T U) exp -> T exp.\nsnd : (prod T U) exp -> U exp.\n\n%{\n\nFor simplicity, take answers to be values. \n\nAnd we add cases to eval:\n\n}%\n\neval : T exp -> T val -> type.\n%mode eval +E1 -E2.\n\neval/val\n   : eval (ret V) V.\n\neval/plus\n   : eval (plus E1 E2) (num N)\n      <- eval E1 (num N1)\n      <- eval E2 (num N2)\n      <- add N1 N2 N.\n\neval/append\n   : eval (append E1 E2) (lit S)\n      <- eval E1 (lit S1)\n      <- eval E2 (lit S2)\n      <- cat S1 S2 S.\n\neval/let\n   : eval (let E1 ([x] E2 x)) A\n      <- eval E1 V\n      <- eval (E2 V) A.\n\neval/fst\n   : eval (fst E) A\n      <- eval E (pair A _).\n\neval/snd\n   : eval (snd E) B\n      <- eval E (pair _ B).\n\n%worlds () (eval _ _).\n%total E (eval E _).\n\n%{\n\n{{Summer school 2008\n  |prev=Exercises 1\n  |prevname=Exercises 1\n  |nonext=\n}}\n\n}%"
          },
          "sha1": "fwb5krvx434bffl3h6emnd6vbwm1plk"
        }
      },
      {
        "title": "Summer school 2008:Typed arithmetic expressions with sums",
        "ns": 0,
        "id": 2077,
        "revision": {
          "id": 5362,
          "parentid": 5349,
          "timestamp": "2008-07-24T17:25:26Z",
          "contributor": {
            "username": "William Lovas",
            "id": 11
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 6532,
            "#text": "%{\n\n{{Summer school 2008\n  |prev=Typed arithmetic expressions\n  |prevname=Typed arithmetic expressions\n  |nonext=\n}}\n\nArithmetic expressions with pairs and sums, where the answer type is values.\n\nFor an alternate version of sums that doesn't involve output factoring, see [[Summer school 2008:Alternate typed arithmetic expressions with sums|Chris's solution]].  For a version that uses output factoring but avoids identity types, see [[Summer school 2008:Typed arithmetic expressions with sums 2|William's solution]].\n\n}%\n\nnat : type.             %name nat M.\nz : nat.\ns : nat -> nat.\n\nadd : nat -> nat -> nat -> type.\n%mode add +M +N -P.\n\nadd/z : add z N N.\nadd/s : add (s M) N (s P) <- add M N P.\n\n%worlds () (add _ _ _).\n%total M (add M _ _).\n\nchar : type.\t\t\t\t%name char X.\na : char.\nb : char.\n\nstr : type.\t\t\t\t%name str S.\nemp : str.\ncons : char -> str -> str.\n\ncat : str -> str -> str -> type.\n%mode cat +S1 +S2 -S3.\n\ncat/e : cat emp S S.\ncat/c : cat (cons X S1) S2 (cons X S3) <- cat S1 S2 S3.\n\n%worlds () (cat _ _ _).\n%total S (cat S _ _).\n\n%{\n\n== Typed expressions ==\n\n}%\n\ntp : type.\t\t\t\t%name tp T.\nnumber : tp.\nstring : tp.\nprod   : tp -> tp -> tp.\nsum    : tp -> tp -> tp.\n\nval : tp -> type.\t\t\t%name val V.  %postfix 1 val.\nnum : nat -> number val.\nlit : str -> string val.\npair : U val -> T val -> (prod U T) val.\ninl  : (U val) -> (sum U T) val.\ninr  : (T val) -> (sum U T) val.\n\nexp : tp -> type.\t\t\t%name exp E.  %postfix 1 exp.\nret : T val -> T exp.\nplus : number exp -> number exp -> number exp.\nappend : string exp -> string exp -> string exp.\nlet : T exp -> (T val -> U exp) -> U exp.\nfst : (prod U T) exp -> U exp.  %% (fst e)\nsnd : (prod U T) exp -> T exp.  %% (snd e)\ncase : (sum T U) exp -> (T val -> V exp) -> (U val -> V exp) -> V exp.\n\n%{\n\n== Evaluation ==\n\nFor simplicity, take answers to be values. \n\n}%\n\neval : T exp -> T val -> type.\n%mode eval +E1 -E2.\n\n%% eval\n\neval/val\n   : eval (ret V) V.\n\neval/plus\n   : eval (plus E1 E2) (num N)\n      <- eval E1 (num N1)\n      <- eval E2 (num N2)\n      <- add N1 N2 N.\n\neval/append\n   : eval (append E1 E2) (lit S)\n      <- eval E1 (lit S1)\n      <- eval E2 (lit S2)\n      <- cat S1 S2 S.\n\neval/let\n   : eval (let E1 ([x] E2 x)) A\n      <- eval E1 V\n      <- eval (E2 V) A.\n\neval/fst \n   : eval (fst E) A1\n      <- eval E (pair A1 A2).\n\neval/snd \n   : eval (snd (E : (prod T1 T2) exp)) A2\n      <- eval E (pair A1 A2).\n\neval/case/inl\n   : eval (case E E1 E2) A'\n      <- eval E (inl A1)\n      <- eval (E1 A1) A'.\n\neval/case/inr\n   : eval (case E E1 E2) A'\n      <- eval E (inr A2)\n      <- eval (E2 A2) A'.\n\n%worlds () (eval _ _).\n\n%{\n\nWe can write the obvious rules for evaluation, but Twelf can't prove\nthis definition total.  The reason is that the [[output coverage]]\nchecker looks at each constant in isolation, not at the whole set of\nconstants.  In this case, it flags an error on the case\n<tt>eval/case/inl</tt>:\n\n<twelf check=\"decl\">\n%total E (eval E _).\n</twelf>\n\nbecause it doesn't notice that the next constant,\n<tt>eval/case/inr</tt>, covers the other possible output of evaluating\n<tt>E</tt>.  We can fix this using a technique called [[output factoring]].\n\n== Output factored evaluation ==\n\n}%\n\nid : A exp -> A exp -> type.\nrefl : id E E.\n\neval'-case : {E' : V exp} {E : (sum T U) exp} {E1} {E2} \n\t      id E' (case E E1 E2) \n\t      -> (sum T U) val \n\t      -> V val\n\t      -> type.\n%mode eval'-case +X-2 +X-1 +X0 +X1 +X2 +X3 -X4.\n\neval' : T exp -> T val -> type.\n%mode eval' +E1 -E2.\n\n%% eval'-case\n\neval'-case/inl : eval'-case _ E E1 E2 refl (inl A1) A\n\t\t <- eval' (E1 A1) A.\n\neval'-case/inr : eval'-case _ E E1 E2 refl (inr A2) A\n\t\t <- eval' (E2 A2) A.\n\n%% eval'\n\neval'/val\n   : eval' (ret V) V.\n\neval'/plus\n   : eval' (plus E1 E2) (num N)\n      <- eval' E1 (num N1)\n      <- eval' E2 (num N2)\n      <- add N1 N2 N.\n\neval'/append\n   : eval' (append E1 E2) (lit S)\n      <- eval' E1 (lit S1)\n      <- eval' E2 (lit S2)\n      <- cat S1 S2 S.\n\neval'/let\n   : eval' (let E1 ([x] E2 x)) A\n      <- eval' E1 V\n      <- eval' (E2 V) A.\n\neval'/fst \n   : eval' (fst E) A1\n      <- eval' E (pair A1 A2).\n\neval'/snd \n   : eval' (snd (E : (prod T1 T2) exp)) A2\n      <- eval' E (pair A1 A2).\n\neval'/case \n   : eval' (case E E1 E2) A'\n      <- eval' E A\n      <- eval'-case (case E E1 E2) E E1 E2 refl A A'.\n\n%worlds () (eval' _ _) (eval'-case _ _ _ _ _ _ _).\n%total (E E') (eval'-case E' _ _ _ _ _ _) (eval' E _).\n\n%{ \n\nThe constant <tt>eval'/case</tt> uses [[output factoring]]: the\nsubsidiary case-analysis of the result of <tt>eval' E A</tt> is broken\nout into a separate lemma, <tt>eval'-case</tt>.  This solves the above\nproblem, because while output coverage cannot be split across multiple\nconstants, input coverage certainly can.  However, because\n<tt>eval'-case</tt> recursively calls <tt>eval'</tt>, the two relations\nmust be proved total using [[mutual induction]].  This is why we \n# write both type families and modes before writing any constants\n# declare their worlds and modes at once\n# use the mutual termination metric <tt>(E E')</tt>\n\nHowever, there is an additional subtlety that we need to address.  You\nmight think <tt>eval'-case</tt> could be defined as follows:\n\n<twelf ignore=\"true\">\neval'-case : {E : (sum T U) exp} {E1 : T val -> V exp} {E2 : U val -> V exp} \n\t      (sum T U) val \n\t      -> A val\n\t      -> type.\n%mode eval'-case +X0 +X1 +X2 +X3 -X4.\n\neval'-case/inl : eval'-case E E1 E2 (inl A1) A\n\t\t <- eval' (E1 A1) A.\n\neval'-case/inr : eval'-case E E1 E2 (inr A2) A\n\t\t <- eval' (E2 A2) A.\n</twelf>\n\nThe problem is that Twelf can't justify the recursive calls to\n<tt>eval'</tt> on <tt>E1</tt> and <tt>E2</tt>.  In fact, why does this\nrecursion pattern work at all?  The reason is that we don't call\n<tt>eval'-case</tt> on just any <tt>E1</tt> and <tt>E2</tt>, but on\nsubexpressions of the <tt>E</tt> that <tt>eval'</tt> was originally\ncalled with.  Thus, when we call back to <tt>eval'</tt> from\n<tt>eval'-case</tt>, it's on a smaller expression.\n\nWe make this invariant evident to Twelf as follows:\n# when <tt>eval'</tt> calls <tt>eval'-case</tt>, we pass in the original expression <tt>(case E E1 E2)</tt> that <tt>eval'</tt> was called with\n# this argument is used as termination metric for <tt>eval-case'</tt>\n# we constrain this position to be a case-analysis using an [[equality|identity type]], so that we don't have extraneous cases to consider.  \n\nThis explains the somewhat-convoluted code above.  \n\n{{Summer school 2008\n  |prev=Typed arithmetic expressions\n  |prevname=Typed arithmetic expressions\n  |nonext=\n}}\n\n}%"
          },
          "sha1": "b4omrtbvcbdysdx46ysdu0bqb2x6anc"
        }
      },
      {
        "title": "Summer school 2008:Typed arithmetic expressions with sums 2",
        "ns": 0,
        "id": 2081,
        "revision": {
          "id": 5360,
          "timestamp": "2008-07-24T17:19:41Z",
          "contributor": {
            "username": "William Lovas",
            "id": 11
          },
          "comment": "alternate solution that avoids identity types",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 3444,
            "#text": "%{\n\n{{Summer school 2008\n  |prev=Typed arithmetic expressions\n  |prevname=Typed arithmetic expressions\n  |nonext=\n}}\n\nArithmetic expressions with pairs and sums.  (This solution involves [[output factoring]], but no [[Equality|identity types]].  Dan posted a [[Summer_school_2008:Typed_arithmetic_expressions_with_sums|solution involving identity types]], and Chris posted a [[Summer_school_2008:Alternate_typed_arithmetic_expressions_with_sums|solution that avoids output factoring]].)\n\nNumbers and strings are unchanged.\n\n|hidden=\"true\"}%\n\nnat : type.             %name nat M.\nz : nat.\ns : nat -> nat.\n\nadd : nat -> nat -> nat -> type.\n%mode add +M +N -P.\n\nadd/z : add z N N.\nadd/s : add (s M) N (s P) <- add M N P.\n\n%worlds () (add _ _ _).\n%total M (add M _ _).\n\nchar : type.\t\t\t\t%name char X.\na : char.\nb : char.\n\nstr : type.\t\t\t\t%name str S.\nemp : str.\ncons : char -> str -> str.\n\ncat : str -> str -> str -> type.\n%mode cat +S1 +S2 -S3.\n\ncat/e : cat emp S S.\ncat/c : cat (cons X S1) S2 (cons X S3) <- cat S1 S2 S3.\n\n%worlds () (cat _ _ _).\n%total S (cat S _ _).\n\n%{\n\n== Typed expressions ==\n\nAdd a type for disjoint sums:\n\n}%\n\ntp : type.\t\t\t\t%name tp T.\nnumber : tp.\nstring : tp.\nprod   : tp -> tp -> tp.\nsum    : tp -> tp -> tp.\n\n%{\n\nAdd injections as values, and case as an expression.\n\n}%\n\nval : tp -> type.\t\t\t%name val V.  %postfix 1 val.\nnum : nat -> number val.\nlit : str -> string val.\npair : T val -> U val -> (prod T U) val.\ninl : T val -> (sum T U) val.\ninr : U val -> (sum T U) val.\n\nexp : tp -> type.\t\t\t%name exp E.  %postfix 1 exp.\nret : T val -> T exp.\nplus : number exp -> number exp -> number exp.\nappend : string exp -> string exp -> string exp.\nlet : T exp -> (T val -> U exp) -> U exp.\nfst : (prod T U) exp -> T exp.\nsnd : (prod T U) exp -> U exp.\n\n%{\nFor technical reasons, we bundle the branches of the case into a separate term with type <tt>cases</tt>; this makes the termination order more evident to Twelf.  An element of \"cases T U V\" is the branches for a \"sum T U\" whose result has tp \"V\".\n}%\ncases : tp -> tp -> tp -> type.\ncases/i : (T val -> V exp) -> (U val -> V exp) -> cases T U V.\ncase : (sum T U) exp -> cases T U V -> V exp.\n\n%{\n\nAdd eval cases for case.\n\n}%\n\neval : T exp -> T val -> type.\n%mode eval +E1 -E2.\n\neval/val\n   : eval (ret V) V.\n\neval/plus\n   : eval (plus E1 E2) (num N)\n      <- eval E1 (num N1)\n      <- eval E2 (num N2)\n      <- add N1 N2 N.\n\neval/append\n   : eval (append E1 E2) (lit S)\n      <- eval E1 (lit S1)\n      <- eval E2 (lit S2)\n      <- cat S1 S2 S.\n\neval/let\n   : eval (let E1 ([x] E2 x)) A\n      <- eval E1 V\n      <- eval (E2 V) A.\n\neval/fst\n   : eval (fst E) A\n      <- eval E (pair A _).\n\neval/snd\n   : eval (snd E) B\n      <- eval E (pair _ B).\n\n%{\nFor \"case\" evaluation, we need an auxiliary relation \"evalcase\" to branch on inl vs. inr ([[output factoring]]).\n}%\nevalcase : (sum T U) val -> cases T U S -> S val -> type.\n%mode evalcase +V +Cases -A.\n\neval/case\n  : eval (case E Cases) A\n      <- eval E V\n      <- evalcase V Cases A.\n\nevalcase/inl\n   : evalcase (inl V1) (cases/i ([x] F1 x) ([y] F2 y)) A\n      <- eval (F1 V1) A.\n\nevalcase/inr\n   : evalcase (inr V2) (cases/i ([x] F1 x) ([y] F2 y)) A\n      <- eval (F2 V2) A.\n\n%{\nThen we use [[mutual induction]] to show evaluation total.\n}%\n%worlds () (eval _ _) (evalcase _ _ _).\n%total (E Cases) (eval E _) (evalcase _ Cases _).\n\n%{\n\n{{Summer school 2008\n  |prev=Exercises 1\n  |prevname=Exercises 1\n  |nonext=\n}}\n\n}%"
          },
          "sha1": "gxhark1evkgemg9d52v594i49kyi996"
        }
      },
      {
        "title": "Summer school 2008: Exercise: Typed arithmetic expressions with pairs",
        "ns": 0,
        "id": 2066,
        "redirect": {
          "@title": "Summer school 2008:Typed arithmetic expressions with pairs",
          "#text": null
        },
        "revision": {
          "id": 5248,
          "timestamp": "2008-07-19T22:42:37Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "comment": "[[Summer school 2008: Exercise: Typed arithmetic expressions with pairs]] moved to [[Summer school 2008:Typed arithmetic expressions with pairs]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 72,
            "#text": "#REDIRECT [[Summer school 2008:Typed arithmetic expressions with pairs]]"
          },
          "sha1": "8gqb5vlzht8fdjov1jdehqdjzqelid2"
        }
      },
      {
        "title": "Syntax (Object logic)",
        "ns": 0,
        "id": 1482,
        "revision": {
          "id": 4540,
          "parentid": 2012,
          "timestamp": "2007-03-21T02:15:59Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 595,
            "#text": "The syntax of an [[object logic]] is commonly encoded as an [[LF]] [[type family]] of [[kind]] <tt>type</tt>.\n\nFor example, if the language of our object logic is the [[natural numbers]], its syntax would be declared in the following way.\n\n<twelf>% declare a type family of kind \"type\" for natural numbers.\nnat : type.\n\n% inhabit the nat with the appropriate constructors.\n\nnat/z : nat.\nnat/s : nat -> nat.</twelf>\n\n== See also ==\n\n* Read the [[introductions to Twelf]] to learn how to represent syntax in LF.\n* [[Judgment]]\n* [[Judgments as types]]\n* [[Higher-order abstract syntax]]\n\n\n{{stub}}"
          },
          "sha1": "hfox23ouze9guuxo74na3s8uxki2bnb"
        }
      },
      {
        "title": "TAT/church.elf",
        "ns": 0,
        "id": 2231,
        "revision": {
          "id": 6168,
          "timestamp": "2010-10-17T18:13:15Z",
          "contributor": {
            "username": "Cmartens",
            "id": 35
          },
          "comment": "Created page with \"%{ Part 2: Polymorphic Lambda Calculus }%  tp : type. arrow : tp -> tp -> tp.  forall : (tp -> tp) -> tp.  %block tvar : block {a:tp}.  tm : tp -> type. lam : (tm T -> tm S) -> t...\"",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 1179,
            "#text": "%{ Part 2: Polymorphic Lambda Calculus }%\n\ntp : type.\narrow : tp -> tp -> tp. \nforall : (tp -> tp) -> tp. \n%block tvar : block {a:tp}.\n\ntm : tp -> type.\nlam : (tm T -> tm S) -> tm (arrow T S). \napp : tm (arrow T S) -> tm T -> tm S.\ntlam : ({a:tp} tm (T a)) -> tm (forall ([a] T a)).\ntapp : tm (forall [a] T a) -> {S:tp} tm (T S). \n\n%% Iterators %%\n\n%% iter N F E is \"apply F to E N times\"\niter : nat -> {T:tp} tm (arrow T T) -> tm T -> tm T -> type.\n\niter/z : iter z T F E E.\niter/s : iter (s N) T F E (app F E') \n          <- iter N T F E E'. \n\n%% Church Encoding %%\n\nencode : nat -> tm (forall [a] (arrow (arrow a a) (arrow a a))) -> type.\n%mode encode +N -E. \n\nencode/z : encode z (tlam [a] lam [f] lam [x] x). \n\nencode/s : encode (s N)  \n               (tlam [a] lam [f:tm (arrow a a)] lam [x:tm a]\n                  app (app (tapp E a) f) x)\n            <- encode N E.\n\n%worlds () (encode _ _). \n%total N (encode N _). \n\nequiv : tm T -> tm T -> type.\nlam-beta : equiv (app (lam [x] M x) N) (M N). \n\nsound : iter N T F E E' -> encode N EN\n         -> equiv E' (app (app (tapp EN T) F) E)  -> type.\n%mode sound +X1 +X2 -X3.\n\n%worlds () (sound _ _ _). \n%total {} (sound _ _ _)."
          },
          "sha1": "49u3swp3chsc5rgcgox17wj3bqt56o8"
        }
      },
      {
        "title": "TAT/plus.elf",
        "ns": 0,
        "id": 2230,
        "revision": {
          "id": 6167,
          "timestamp": "2010-10-17T18:12:32Z",
          "contributor": {
            "username": "Cmartens",
            "id": 35
          },
          "comment": "Created page with \"%{ Part 1 }%  nat : type. z : nat. s : nat -> nat.  plus : nat -> nat -> nat -> type. %mode plus +N1 +N2 -N3. p/z : plus z N N. p/s : plus (s N) M (s P)        <- plus N M P. %wo...\"",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 1073,
            "#text": "%{ Part 1 }%\n\nnat : type.\nz : nat.\ns : nat -> nat.\n\nplus : nat -> nat -> nat -> type.\n%mode plus +N1 +N2 -N3.\np/z : plus z N N.\np/s : plus (s N) M (s P)\n       <- plus N M P.\n%worlds () (plus _ _ _). \n%total N (plus N _ _). \n\nplus/z : {N:nat} plus N z N -> type.\n%mode plus/z +N -X. \n\n-z : plus/z z p/z.\n-s : plus/z (s N) (p/s Dplus)\n      <- plus/z N (Dplus : plus N z N). \n\n%worlds () (plus/z _ _). \n%total N (plus/z N _). \n\nplus/s : plus N M P -> plus N (s M) (s P) -> type.\n%mode plus/s +X1 -X2.\n\n-z : plus/s p/z p/z.\n\n-s : plus/s\n         (p/s (Dplus : plus N M P)) \n         (p/s Dplus')\n      <- plus/s Dplus (Dplus' : plus N (s M) (s P)).\n\n%worlds () (plus/s _ _). \n%total D (plus/s D _). \n\nplus/commutes : plus N M P -> plus M N P -> type.\n%mode plus/commutes +X1 -X2.\n\n-z  : plus/commutes p/z D\n       <- plus/z _ D.\n\n-s  : plus/commutes (p/s (Dplus : plus N M P)) Dplus''\n       <- plus/commutes Dplus\n          (Dplus' : plus M N P)\n       <- plus/s Dplus'\n          (Dplus'' : plus M (s N) (s P)).\n\n%worlds () (plus/commutes _ _).\n%total D (plus/commutes D _)."
          },
          "sha1": "grao5b24s5wcjwr0gbem8gvw95pglul"
        }
      },
      {
        "title": "Tabled logic programming",
        "ns": 0,
        "id": 1868,
        "revision": {
          "id": 6118,
          "parentid": 4921,
          "timestamp": "2010-09-02T12:29:36Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 3715,
            "#text": "%{ \nThe operational semantics of Twelf are similar to those of Prolog, \na style known as ''backward chaining'' or ''goal-directed'' proof \nsearch. '''Tabled logic programming''', which uses Twelf's \n<tt>[[%tabled]]</tt> and <tt>[[%querytabled]]</tt> directives to \nallow Twelf to prove theorems that might be time-consuming or \nimpossible to prove otherwise. The tabled logic programming \ncapabilities are a \npart of Twelf's capabilities as a logical framework, but not as a \nmetalogical framework; in other worlds, tabled logic programming \ncannot be used to prove [[metatheorems]].\n\n[[Image:Searchgraph-found.svg|thumb|right|325px|The graph used in this example, and the path that the tabled logic query finds to get from node a to node g.]] \n\nThe simplest examples of the power of tabled logic programming in \npractice involve judgments that involve transitive and/or symmetric \nclosures, such as searching for a path in a graph or formalizing a \nlanguage with subtyping. Using standard backward-chaining proof search, \nit is almost impossible to write terminating programs that search for \npaths, and using backward-chaining search for subtyping typically \nrequires a separate definition of \"algorithmic subtyping\" that must \nbe shown to be sound and complete with respect to the clearer, simpler \ndefinition of subtyping that uses transitivity.\n\nThis article will use as its example a path-finding algorithm \non an undirected graphs. \n\n}%\n\n%{ == Defining the graph == }%\n\n%{ === Nodes === }%\n\nnode : type.\n\na : node.\nb : node.\nc : node.\nd : node.\ne : node.\nf : node.\ng : node.\nh : node.\n\n%{ === Edges === }%\n\n%{ While we will consider edges in our graph to be undirected, \nwe will only define the edge in one, arbitrary, direction. }%\n\nedge : node -> node -> type.\n\nab : edge a b.\nac : edge a c. \nbc : edge b c.\nbd : edge b d.\ncd : edge c d.\nce : edge c e.\nde : edge d e.\ndf : edge d f.\nfg : edge f g.\n\n%{ === Paths in the graph === }%\n\n%{\nThis is normally where we would get into trouble; in standard \nlogic programming, it is difficult if not impossible to avoid \nnon-terminating behavior when writing a judgment defining a \ntransitive-symmetric closure like <tt>path</tt>. However, by \nadding the directive <tt>[[%tabled]] path</tt>, we will be able \nto use <tt>[[%querytabled]]</tt> directives to cause each instance \nof <tt>path A B</tt> to be derived at most once during the course \nof a search: the result is a query that terminates rapidly, \ninstead of not at all.\n}%\n\npath : node -> node -> type.\n%tabled path.\n\npath/link : edge A B -> path A B.\npath/refl : path A B -> path B A.\npath/trans : path A B -> path B C -> path A C.\n\n%{ == Searching the graph == }%\n\n%{ \nIt is crucial that we use <tt>[[%querytabled]]</tt> rather than \n<tt>[[%query]]</tt> in our queries if we wish for them to terminate. \nEven though we ask Twelf for as many solutions as it can find, the \ntabled proof search ensures that we can only find one proof of any \ngiven path, and the path that is found is by not necessarily the shortest.\nWhile the path that is found is shown on the graph above, the edge <tt>ab</tt>\nactually appears three times here - if we use parenthesis to show the order in which\ntabled search connected paths, the path that is found is\n<tt>a</tt> - ((<tt>b</tt> - ((<tt>a</tt> - <tt>b</tt> - <tt>d</tt>) - <tt>f</tt>)) \n- <tt>g</tt>).\n|check=decl discard=true}%\n\n%querytabled * * D : path a g.\n\n%{\nWe can also run a terminating search for a path that does not exist, \nsuch as one from <tt>a</tt> to <tt>h</tt>.\n|check=decl discard=true}%\n\n%querytabled * * D : path a h.\n\n%.\n\n== See also ==\n\n* <tt>[[%tabled]]</tt>\n* <tt>[[%querytabled]]</tt>\n* {{guide|chapter=5|section=31|title=Tabled Logic Programming}}"
          },
          "sha1": "s7wb2pf1f7ptx5chlh9iagyh7cz8c2i"
        }
      },
      {
        "title": "Tactical theorem proving",
        "ns": 0,
        "id": 1915,
        "revision": {
          "id": 5977,
          "parentid": 4291,
          "timestamp": "2009-04-18T23:12:28Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 5526,
            "#text": "%{ \nLogics can be defined in Twelf in such a way that it may not be possible\nto do proof search by the fixed search strategy of Twelf's \n[[logic programming]] engine. In these cases, tactical theorem provers can \nbe written that may still be able to prove many theorems. This article\ndefines two approaches to writing these tactical theorem provers.\n}%\n\n%{ == Logic definition == }%\n\n%{ \nWhen we introduce numbers with addition on this wiki (see for example\n[[natural numbers]]), we usually define a judgmental definition of addition\nand then prove that it has the properties we desire. This will be a rather\ndifferent presentation, more in line with the [[Zermelo Frankel]] case study.\nThis is a signature for an object language (a logic) that has addition\nas a primitive operation.\n\nWe define a type for numbers <tt>num</tt>, and then make addition a\nprimitive operation. We also define propositions; the only proposition we \ndefine here is equality of two numbers.\n}%\n\nnum : type. %name num N.\n+ : num -> num -> num. %infix left 10 +.\n0 : num.\n1 : num.\n\nprop : type.\n== : num -> num -> prop. %infix none 5 ==.\n\n%{\nWe can create a valid proposition that may be obviously untrue; for instance,\n<tt>(0 == 1)</tt> is a valid object of type <tt>prop</tt>. Therefore,\nwe create <tt>pf</tt>, which is a particular little logic which\nwill allow us to prove a large number of theorems about addition based\non a small number of axioms. Eight axioms are defined below:\n}%\n\npf : prop -> type.\n\nrefl : pf (N == N).\nsymm : pf (N1 == N2) -> pf (N2 == N1).\ntrans : pf (N1 == N2) -> pf (N2 == N3) -> pf (N1 == N3).\n\nplus_assoc : pf (N1 + N2 + N3 == N1 + (N2 + N3)).\nplus_comm : pf (N1 + N2 == N2 + N1).\nplus_zero : pf (N1 + 0 == N1).\nplus_cong : pf (N1 == N1') -> pf (N2 == N2') -> pf (N1 + N2 == N1' + N2').\nplus_elim1 : pf (N1 + N2 == N1 + N2') -> pf (N2 == N2').\n\n%freeze pf.\n\n%{\nWe [[freeze]] the type family <tt>pf</tt> to prevent any more \naxioms from being defined,\nbut we can still define (many!) more theorems using the axioms (for instance,\nthe complement to <tt>plus_elim1</tt>.\n}% \n\nplus_elim2 : pf (N1 + N2 == N1' + N2) -> pf (N1 == N1') = \n  [p1 : pf (N1 + N2 == N1' + N2)] \n  plus_elim1 (trans (trans plus_comm p1) plus_comm).\n\n%{ == Tactical theorem proving == }%\n\n%{ === Motivation: \"flattening\" a numeric formula === }%\n%{ \nSay we want to define a predicate <tt>mklist</tt> that takes some numeric \nformula <tt>num</tt> and applies associativity exhaustively to \"flatten\" \nthe formula into a list, for instance transforming <tt>(a + (b + c) + d)</tt>\ninto <tt>(a + b + c + d)</tt> - addition was defined to be left-associative,\nso this is the same as <tt>(((a + b) + c) + d)</tt>.\n\nThe <tt>list</tt> type family below will do this when run as a logic program.\n}%\n\nlist : num -> num -> type.\n%mode list +A -B.\n\nlist-swap : list (A + (B + C)) D\n\t     <- list (A + B + C) D.\nlist-step : list (A + C) (B + C)\n\t     <- list A B.\nlist-stop : list A A.\n\n%{ === Returning a proof of equality === }%\n\n%{\nThe operation of <tt>list</tt> may seem a bit mysterious - how\ndo we know that the straightened out formula is equal to the old one? By using\nTwelf's [[dependent types]], we can define a new type family <tt>mklist</tt>\nwhich operates in the same way but returns a proof that the two numeric\nformulas are equal. We do '''not''' prove that the second \nformula is flattened, just that it is equal to the first formula.\n}%\n\nmklist : {A}{B} pf (A == B) -> type.\n%mode mklist +A -B -Pf.\n\nmklist-swap : mklist (A + (B + C)) D (trans (symm plus_assoc) Pf)\n\t\t<- mklist (A + B + C) D (Pf: pf (A + B + C == D)).\nmklist-step : mklist (A + C) (B + C) (plus_cong Pf refl)\n\t\t<- mklist A B (Pf: pf (A == B)).\nmklist-stop : mklist A A refl.\n\n%{ === Using the tactical theorem prover === }%\n\n%{ \nWe can then use <tt>[[Define declaration|%define]]</tt> and \n<tt>[[%solve]]</tt> to create\na proof that (a + (b + c) + d == a + b + c + d). In order for <tt>mklist</tt>\nto terminate, it must be given a [[ground]] term, so we introduce a four \natomic terms <tt>a</tt> through <tt>d</tt>. The proof <tt>Pf</tt>\nmust be explicitly allowed to rely on those terms, which is why\n<tt>(Pf a b c d)</tt> is written instead of just <tt>Pf</tt>.\n|check=decl}%\n\n%define p1 = Pf\n%solve _ : {a}{b}{c}{d} mklist (a + (b + c) + d) _ (Pf a b c d).\n\n\n%{ == Tactics with <tt>%clause</tt> == }%\n\n%{ Another way to achieve the same goal is to ''define'' <tt>(list A B)</tt>\nas <tt>(pf (A == B))</tt>, which we do for <tt>list'</tt> below. }%\n\nlist' : num -> num -> type = [a][b] pf (a == b).\n%mode list +A -B.\n\n%{ Then, we have to ''justify'' each clause of the logic in the same way\nas we justified <tt>plus_elim2</tt> above. We have to write the \n<tt>[[%clause]]</tt> because, if we do not, then Twelf will not use the\ndefinitions in logic programming search. }%\n\n%clause\nlist'-swap : list' (A + (B + C)) D\n\t     <- list' (A + B + C) D \n  = [Pf: pf (A + B + C == D)] (trans (symm plus_assoc) Pf).\n\n%clause\nlist'-step : list' (A + C) (B + C)\n\t     <- list' A B\n  = [Pf: pf (A == B)] (plus_cong Pf refl).\n\n%clause\nlist'-stop : list' A A = refl.\n\n%{ Now we do not need to use <tt>%define</tt>; <tt>p2</tt> proves the \nsame thing as <tt>p1</tt> above. |check=decl}%\n\n%solve p2 : {a}{b}{c}{d} list' (a + (b + c) + d) _.\n\n%{ This is not the recommended style for a number of reasons (metatheoretic parts of Twelf like [[totality assertions]] won't work with <tt>%clause</tt>), but a few large examples such as the [[big algebraic solver]] have been written in this style. }%"
          },
          "sha1": "1sbwj8m167lalnngo4dod28eu3dnz3h"
        }
      },
      {
        "title": "Termination analysis",
        "ns": 0,
        "id": 1978,
        "redirect": {
          "@title": "%terminates",
          "#text": null
        },
        "revision": {
          "id": 4575,
          "timestamp": "2007-03-21T05:22:28Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "Redirecting to [[%terminates]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 25,
            "#text": "#REDIRECT [[%terminates]]"
          },
          "sha1": "mjttg0bn95k0len7emz29fg06jf3jcv"
        }
      },
      {
        "title": "Termination checking",
        "ns": 0,
        "id": 2182,
        "redirect": {
          "@title": "%terminates",
          "#text": null
        },
        "revision": {
          "id": 5881,
          "timestamp": "2009-02-21T21:48:37Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "Redirecting to [[%terminates]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 24,
            "#text": "#REDIRECT[[%terminates]]"
          },
          "sha1": "kck8gitf7icvu2h1h5n6wplwkou5g1v"
        }
      },
      {
        "title": "Tethered Modal Logic",
        "ns": 0,
        "id": 2187,
        "redirect": {
          "@title": "Tethered modal logic",
          "#text": null
        },
        "revision": {
          "id": 5912,
          "timestamp": "2009-02-24T21:55:53Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "[[Tethered Modal Logic]] moved to [[Tethered modal logic]]: Downcase",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 34,
            "#text": "#REDIRECT [[Tethered modal logic]]"
          },
          "sha1": "nfkq1mkfnc47uis3udlszvlzz399ucl"
        }
      },
      {
        "title": "Tethered modal logic",
        "ns": 0,
        "id": 2186,
        "revision": {
          "id": 6053,
          "parentid": 5911,
          "timestamp": "2010-02-26T01:08:38Z",
          "contributor": {
            "username": "Jcreed",
            "id": 9
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 9074,
            "#text": "%{ Alex Simpson's thesis shows how to encode a variety of constructive\nmodal logics by making box and diamond into universal and existential\nquantifiers over accessible Kripke worlds and orthogonally allowing\naxiomatization of the accessibility relation.\n\nHere we encode and prove cut admissibility for a sequent calculus for\na similar spectrum of logics. The difference is that uses of\nleft rules are constrained  (`tethered') to only fire when the label on the \nconclusion is the same as the label on the hypothesis.\n\nThe conjecture was that Pfenning-Davies judgmental modal logic is\nexactly tethered modal logic where accessibility relation is\naxiomatized by reflexivity and transitivity. However, this is refuted by considering <math>\\Diamond\\Diamond A \\Rightarrow \\Diamond A</math>, which is provable in Pfenning-Davies and (apparently?) not in the current system. The exact status of this logic relative to other constructive modal logics is still being determined.\n\nThe standard litmus-test entailment that fails in this logic (and succeeds in Simpsons')\nis\n\n<math>\\Diamond A \\Rightarrow \\square B \\vdash \\square (A \\Rightarrow B)</math>\n\n(Author: Jason Reed, based on Pfenning's encoding of intuitionistic\nlogic with cut admissibility)\n}%\n\nw : type.  % worlds\n%name w P.\n\n<= : w -> w -> type. % accessibility relation\n%infix none 3 <=.\nrefl : P <= P.\ntrans : P <= Q -> Q <= R -> P <= R.\nsym : P <= Q -> Q <= P.\n\no : type.  % formulas\n%name o A.\n\nand    : o -> o -> o.  %infix right 11 and.\nimp    : o -> o -> o.  %infix right 10 imp.\nor     : o -> o -> o.  %infix right 11 or.\ntrue   : o.\nfalse  : o.\nbox : o -> o.\ndia : o -> o.\n\n% Sequent Calculus\n\nhyp  : o -> w -> type.  % Hypotheses (left)\nghyp  : o -> w -> type.  % Global-after-P Hypotheses (left)\nconc : o -> w -> type.  % Conclusion (right)\n\n%name hyp H.\n%name conc D.\n\naxiom : (hyp A P -> conc A P).\n\nandr  : conc A P\n\t -> conc B P\n\t -> conc (A and B) P.\n\nandl1 : (hyp A P -> conc C P)\n\t -> (hyp (A and B) P -> conc C P).\n\nandl2 : (hyp B P -> conc C P)\n\t -> (hyp (A and B) P -> conc C P).\n\nimpr  : (hyp A P -> conc B P)\n\t -> conc (A imp B) P.\n\nimpl  : conc A P\n\t -> (hyp B P -> conc C P)\n\t -> (hyp (A imp B) P -> conc C P).\n\norr1  : conc A P\n\t -> conc (A or B) P.\n\norr2  : conc B P\n\t -> conc (A or B) P.\n\norl   : (hyp A P -> conc C P)\n\t -> (hyp B P -> conc C P)\n\t -> (hyp (A or B) P -> conc C P).\n\ntruer : conc (true) P.\n\nfalsel : (hyp (false) P -> conc C P).\n\nboxr : ({a:w} P <= a -> conc A a)\n\t   -> conc (box A) P. \n\nboxl : (ghyp A P -> conc C P)\n\t   -> (hyp (box A) P -> conc C P). \n\n% Can copy to any world after P regardless of conc\ncopy : (hyp A Q -> conc C R)\n\t-> P <= Q\n\t-> (ghyp A P -> conc C R).\n\ndiar : conc A Q\n\t-> P <= Q\n\t-> conc (dia A) P.\n\ndial : ({a:w} P <= a -> hyp A a -> conc C P)\n\t-> (hyp (dia A) P -> conc C P).\n\n\n%%% Termination Metric\n\nlittle : type.\nbig : type.\nlittle/ : little.\nbig/ : little -> big.\n\n%%% Cut admissibility\n\nca : {M:little} {A:o} conc A P -> (hyp A P -> conc C Q) -> conc C Q -> type.\n\ncag : {M:big} {A:o} ({a:w} Q <= a -> conc A a) -> (ghyp A Q -> conc C R) -> conc C R -> type.\n\n%% Axioms\n\nca_axiom_d : ca M A (axiom H) E (E H).\n\nca_axiom_e : ca M A D axiom D.\n\n%% Principal Cases\n\nca_and1 : ca M (A1 and A2) (andr D1 D2)\n\t   ([h] andl1 (E1 h) h) F\n\t   <- ({h1}\n\t\t ca M (A1 and A2) (andr D1 D2)\n\t\t ([h] E1 h h1) (E1' h1))\n\t   <- ca M A1 D1 E1' F.\n\nca_and2 : ca M (A1 and A2) (andr D1 D2)\n\t   ([h] andl2 (E2 h) h) F\n\t   <- ({h2}\n\t\t ca M (A1 and A2) (andr D1 D2)\n\t\t ([h] E2 h h2) (E2' h2))\n\t   <- ca M A2 D2 E2' F.\n\nca_imp  : ca M (A1 imp A2) (impr D2)\n\t   ([h] impl (E1 h) (E2 h) h) F\n\t   <- ca M (A1 imp A2) (impr D2) E1 E1'\n\t   <- ({h2}\n\t\t ca M (A1 imp A2) (impr D2)\n\t\t ([h] E2 h h2) (E2' h2))\n\t   <- ca M A1 E1' D2 D2'\n\t   <- ca M A2 D2' E2' F.\n\nca_or1  : ca M (A1 or A2) (orr1 D1)\n\t   ([h] orl (E1 h) (E2 h) h) F\n\t   <- ({h1}\n\t\t ca M (A1 or A2) (orr1 D1)\n\t\t ([h] E1 h h1) (E1' h1))\n\t   <- ca M A1 D1 E1' F.\nca_or2  : ca M (A1 or A2) (orr2 D2)\n\t   ([h] orl (E1 h) (E2 h) h) F\n\t   <- ({h2}\n\t\t ca M (A1 or A2) (orr2 D2)\n\t\t ([h] E2 h h2) (E2' h2))\n\t   <- ca M A2 D2 E2' F.\n\nca_box : ca M (box A) (boxr D1) ([h] boxl (E1 h) h) F\n\t  <- ({h2} ca M (box A) (boxr D1) ([h] E1 h h2) (F' h2))\n\t  <- cag (big/ little/) A D1 F' F.\n\nca_dia : ca M (dia A) (diar D1 ACC) ([h] dial (E1 h) h) F\n   <- ({a:w} {acc} {h2:hyp A a} ca M (dia A) (diar D1 ACC) ([h] E1 h a acc h2) (F' a acc h2))\n   <- ca M A D1 ([h2] F' _ ACC h2) F.\n\n%% D-Commutative Conversions\n\ncad_andl1  : ca M A (andl1 D1 H) E (andl1 D1' H)\n\t      <- {h1} ca M A (D1 h1) E (D1' h1).\n\ncad_andl2  : ca M A (andl2 D2 H) E (andl2 D2' H)\n\t      <- {h2} ca M A (D2 h2) E (D2' h2).\n\ncad_impl   : ca M A (impl D1 D2 H) E (impl D1 D2' H)\n\t      <- ({h2} ca M A (D2 h2) E (D2' h2)).\n\ncad_orl    : ca M A (orl D1 D2 H) E (orl D1' D2' H)\n\t      <- ({h1} ca M A (D1 h1) E (D1' h1))\n\t      <- ({h2} ca M A (D2 h2) E (D2' h2)).\n\ncad_falsel  : ca M A (falsel H) E (falsel H).\n\ncad_boxl : ca M A (boxl D1 H) E (boxl D1' H)\n\t       <- ({h} ca M A (D1 h) E (D1' h)).\n\ncad_dial : ca M A (dial D1 H) E (dial D1' H)\n\t       <- ({a:w} {acc} {h:hyp B1 a}\n\t\t     ca M A (D1 a acc h) E (D1' a acc h)).\ncad_copy : ca M A (copy D ACC H) E (copy D' ACC H)\n\t    <- ({h} ca M A (D h) E (D' h)).\n\n%% E-Commutative Conversions\n\ncae_axiom : ca M A D ([h] axiom H1) (axiom H1).\n\ncae_andr : ca M A D ([h] andr (E1 h) (E2 h)) (andr E1' E2')\n\t    <- ca M A D E1 E1'\n\t    <- ca M A D E2 E2'.\n\ncae_andl1: ca M A D ([h] andl1 (E1 h) H) (andl1 E1' H)\n\t    <- ({h1} ca M A D ([h] E1 h h1) (E1' h1)).\n\ncae_andl2: ca M A D ([h] andl2 (E2 h) H) (andl2 E2' H)\n\t    <- ({h2} ca M A D ([h] E2 h h2) (E2' h2)).\n\ncae_impr : ca M A D ([h] impr (E2 h)) (impr E2')\n\t    <- ({h1} ca M A D ([h] E2 h h1) (E2' h1)).\n\ncae_impl : ca M A D ([h] impl (E1 h) (E2 h) H) (impl E1' E2' H)\n\t    <- ca M A D E1 E1'\n\t    <- ({h2} ca M A D ([h] E2 h h2) (E2' h2)).\n\ncae_orr1 : ca M A D ([h] orr1 (E1 h)) (orr1 E1')\n\t    <- ca M A D E1 E1'.\n\ncae_orr2 : ca M A D ([h] orr2 (E2 h)) (orr2 E2')\n\t    <- ca M A D E2 E2'.\n\ncae_orl  : ca M A D ([h] orl (E1 h) (E2 h) H) (orl E1' E2' H)\n\t    <- ({h1} ca M A D ([h] E1 h h1) (E1' h1))\n\t    <- ({h2} ca M A D ([h] E2 h h2) (E2' h2)).\n\ncae_truer: ca M A D ([h] truer) (truer).\n\ncae_falsel : ca M A D ([h] falsel H) (falsel H).\n\ncae_boxr : ca M A D ([h] boxr (E1 h)) (boxr E1')\n\t       <- ({a:w} {acc} ca M A D ([h] E1 h a acc) (E1' a acc)).\n\n\ncae_boxl: ca M A D ([h] boxl (E1 h) H) (boxl E1' H)\n\t      <- ({gh1} ca M A D ([h] E1 h gh1) (E1' gh1)).\n\ncae_diar : ca M A D ([h] diar (E1 h) ACC) (diar E1' ACC)\n\t       <- ca M A D E1 E1'.\n\ncae_dial : ca M A D ([h] dial (E1 h) H) (dial E1' H)\n\t       <- ({a:w} {acc} {h1:hyp B1 a}\n\t\t     ca M A D ([h] E1 h a acc h1) (E1' a acc h1)).\n\ncae_copy : ca M A D ([h] copy (E h) ACC H) (copy E' ACC H)\n\t    <- ({h2} ca M A D ([h] E h h2) (E' h2)).\n\n%% E-Commutative Conversions for ca (global)\n\ncage_axiom : cag M A D ([h] axiom H1) (axiom H1).\n\ncage_andr : cag M A D ([h] andr (E1 h) (E2 h)) (andr E1' E2')\n\t    <- cag M A D E1 E1'\n\t    <- cag M A D E2 E2'.\n\ncage_andl1: cag M A D ([h] andl1 (E1 h) H) (andl1 E1' H)\n\t    <- ({h1} cag M A D ([h] E1 h h1) (E1' h1)).\n\ncage_andl2: cag M A D ([h] andl2 (E2 h) H) (andl2 E2' H)\n\t    <- ({h2} cag M A D ([h] E2 h h2) (E2' h2)).\n\ncage_impr : cag M A D ([h] impr (E2 h)) (impr E2')\n\t    <- ({h1} cag M A D ([h] E2 h h1) (E2' h1)).\n\ncage_impl : cag M A D ([h] impl (E1 h) (E2 h) H) (impl E1' E2' H)\n\t    <- cag M A D E1 E1'\n\t    <- ({h2} cag M A D ([h] E2 h h2) (E2' h2)).\n\ncage_orr1 : cag M A D ([h] orr1 (E1 h)) (orr1 E1')\n\t    <- cag M A D E1 E1'.\n\ncage_orr2 : cag M A D ([h] orr2 (E2 h)) (orr2 E2')\n\t    <- cag M A D E2 E2'.\n\ncage_orl  : cag M A D ([h] orl (E1 h) (E2 h) H) (orl E1' E2' H)\n\t    <- ({h1} cag M A D ([h] E1 h h1) (E1' h1))\n\t    <- ({h2} cag M A D ([h] E2 h h2) (E2' h2)).\n\ncage_truer: cag M A D ([h] truer) (truer).\n\ncage_falsel : cag M A D ([h] falsel H) (falsel H).\n\ncage_boxr : cag M A D ([h] boxr (E1 h)) (boxr E1')\n\t     <- ({a:w} {acc} cag M A D ([h] E1 h a acc) (E1' a acc)).\n\n\ncage_boxl: cag M A D ([h] boxl (E1 h) H) (boxl E1' H)\n\t      <- ({gh1} cag M A D ([h] E1 h gh1) (E1' gh1)).\n\ncage_diar : cag M A D ([h] diar (E1 h) ACC) (diar E1' ACC)\n\t       <- cag M A D E1 E1'.\n\ncage_dial : cag M A D ([h] dial (E1 h) H) (dial E1' H)\n\t       <- ({a:w} {acc} {h1:hyp B1 a}\n\t\t     cag M A D ([h] E1 h a acc h1) (E1' a acc h1)).\n\n\ncage_copy : cag M A D ([h] copy (E h) ACC H) (copy E' ACC H)\n\t    <- ({h2} cag M A D ([h] E h h2) (E' h2)).\n\n% Single principal case for ca (global)\n\ncag_copy : cag (big/ M) A D ([h] copy (E h) ACC h) F\n\t    <- ({h2} cag (big/ M) A D ([h] E h h2) (E' h2))\n\t    <- ca M A (D _ ACC) E' F.\n\n%block bacc : some {Q:w} {P:w} block {d:P <= Q}.\t    \n%block bhyp : some {A:o} {P:w} block {h:hyp A P}.\n%block bghyp : some {A:o} {P:w} block {h:ghyp A P}.\n%block bw : block {a:w}.\n%block bo : block {p:o}.\n%worlds (bhyp | bghyp | bw | bo | bacc) (ca M A D E F) (cag M A D E F).\n\n%mode (ca +M +A +D +E -F)\n      (cag +M +A +D +E -F).\n\n%total {(A' A) (M' M) [(D' D) (E' E)]} \n       (cag M' A' D' E' _) \n       (ca M A D E _)."
          },
          "sha1": "94e9kmdlpvnkk87hamtfx7dv687qqgv"
        }
      },
      {
        "title": "The Best Fake cigarette Sold in the market",
        "ns": 0,
        "id": 2379,
        "revision": {
          "id": 6436,
          "parentid": 6435,
          "timestamp": "2011-10-15T06:08:51Z",
          "contributor": {
            "username": "Mackferral",
            "id": 242
          },
          "minor": null,
          "comment": "moved [[User:Mackferral]] to [[The Best Fake cigarette Sold in the market]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 2522,
            "#text": "== The Best Fake cigarette Sold in the market ==\n\nFake cigarettes or electronic cigarettes are obtaining popularity each day due to its benefits. As things are not a whole lot harmful to improve your health almost all allows you overcome your smoking habit. Fake cigarettes behaves like traditional cigarettes it can be much totally different from them. Fake cigarette use liquid flavored nicotine since its fuel. Fake cigarettes exhale vapors in place of smoke. Here aren' passive smoking effects. There is not any ash, smoke, no bad order in breath and in cloths, no passive smoking effects, no necessity of lighter etc. These benefits are making fake cigarette much popular in the middle smokers. These cigarettes will also be cost-effective when compared to the earlier cigarettes.\nThe marketplace is filled with different electronic or fake cigarettes just like Green smoke, V2 cigs, Blu cigs, White cloud, The safe cig, Vapor cigs etc. Each of these fake cigarette brands attempt to become the best already in the market. Various fake cigarette reviews demonstrates that [http://www.deltascan.org/white-cloud-electronic-cigarette-reviews.html white cloud] fake cigarettes are one of the best cigarettes out there. All companies offer various flavors and accessories. A number commonly provided flavors are Tobacco or Classic Tobacco, Menthol, Coffee, Cherry, Strawberry, Chocolate, Vanilla etc. in accordance with fake cigarette reviews white cloud fake cigarettes is among the most best fake cigarette seen in the marketplace. They have various accessories as well as types of chargers which includes an A\\C wall charger, a USB charger or possibly a car charger.\n[http://www.deltascan.org/fake-cigarettes-reviews.html fake cigarette] is not only just much harmful for health just about all helps you control your smoking habit. Various fake cigarette reviews points too it is possible to overcome your smoking habit, what you need to do is that you should slow up the standard of nicotine from it time by time. If you do time you are going to found that this may not harming your body much and also you had controlled your smoking addiction. Or else you can continue your smoking without harming your body much. Different electronic cigarettes reviews signifies that white cloud electronic cigarette offers one of many best back-up and support who has got the best electronic cigarette already in the market besides other smokers take it as being a alternative device of smoking instead of those regular cigarettes."
          },
          "sha1": "3x1rwx0uo48xh9ejex1f4v8jmvirax2"
        }
      },
      {
        "title": "The two Twelfs",
        "ns": 0,
        "id": 1988,
        "redirect": {
          "@title": "Modes of use",
          "#text": null
        },
        "revision": {
          "id": 4692,
          "timestamp": "2007-04-09T20:57:02Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "[[The two Twelfs]] moved to [[Modes of use]]: better name",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 26,
            "#text": "#REDIRECT [[Modes of use]]"
          },
          "sha1": "148nl04m0hzcnb4uvaimu916wvdv6fa"
        }
      },
      {
        "title": "Theorem prover",
        "ns": 0,
        "id": 1827,
        "revision": {
          "id": 4745,
          "parentid": 4313,
          "timestamp": "2007-05-15T00:49:17Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "make warning more severe",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 4000,
            "#text": "The '''Twelf theorem prover''' is a way of specifying and automatically verifying [[metatheorems]] that have the form of {{forall}}{{exists}}-statements. It uses the Twelf declarations <tt>[[%theorem]]</tt>, <tt>[[%prove]]</tt>, <tt>[[%establish]]</tt>, and <tt>[[%assert]]</tt>. The last of these is an [[unsafe mode|unsafe]] operation similar to <tt>[[%trustme]]</tt>.\n\nThe current theorem prover is buggy, sometimes does not terminate, and does not output a total logic program that can be used to witness the {{forall}}{{exists}}-statement as described in {{guide|title=Proof realizations|section=62|chapter=10}}. Because of this, it cannot interact with the technique of verifying metatheorems by writing [[totality assertions]], and its use is not recommended.\n\n== Example - commutativity of addition ==\n\n=== Object language ===\n\nWe start with the standard presentation of the [[natural numbers]] with addition. \n\n<twelf>\nnat : type.\ns : nat -> nat.\nz : nat.\n\nplus : nat -> nat -> nat -> type.\np-z : plus z N N.\np-s : plus (s N1) N2 (s N3) <- plus N1 N2 N3.\n</twelf>\n\n=== Establishing {{forall}}{{exists}}-metatheorems with totality assertions ===\n\nA simple [[metatheorem]] about this object language is the {{forall}}{{exists}}-statement that for all natural numbers <math>\\texttt{}N</math>, there exists a derivation of <math>\\texttt{plus}(N,0,N)</math>. This translates into LF as a {{forall}}{{exists}}-statement that for all objects <tt>N</tt> with type <tt>nat</tt>, there exists an object <tt>D</tt> of type <tt>plus N z N</tt>. \n\nThe \"usual\" way of proving this kind of metatheorem in Twelf is to define a type family which represents a relation, translate the cases of the inductive proof into LF objects in that type family, and use a <tt>[[%mode]]</tt> directive and <tt>[[%worlds]]</tt> directive to specify a [[totality assertion]] that corresponds to the {{forall}}{{exists}}-statement. The totality assertion for type family <tt>plus-z-thm</tt> below establishes the {{forall}}{{exists}}-statement that is stated above.\n\n<twelf discard=\"true\" check=\"true\">\nplus-z-thm : {N: nat} plus N z N -> type.\n\n- : plus-z-thm z p-z.\n- : plus-z-thm (s N) (p-s D)\n     <- plus-z-thm N D.\n\n%mode plus-z-thm +N -D.\n%worlds () (plus-z-thm _ _).\n%total T (plus-z-thm T _).\n</twelf>\n\n=== Establishing {{forall}}{{exists}}-metatheorems with the theorem prover ===\n\nThe equivalent of the type family definition for <tt>plus-z-thm</tt> and the <tt>%mode</tt> declaration from the above code can be stated with a <tt>[[%theorem]]</tt>.\n\n<twelf>\n%theorem plus-z : forall {N: nat} \n                  exists {D: plus N z N} \n                  true.\n</twelf>\n\n(Side note: some versions of Twelf allow the <tt>%theorem</tt> declaration above to be used in lieu of the type family definition and <tt>%mode</tt> declaration; [[User:Boyland|John Boyland]] utilizes this in his tutorial and code examples, but it is not a supported feature and may break in future versions of Twelf!)\n\nGiven the <tt>%theorem</tt> declaration, we can ask Twelf to try to establish the metatheorem it states by using a <tt>[[%prove]]</tt> declaration.\n\n<twelf check=decl>\n%prove 5 N (plus-z N D).\n</twelf>\n\nWe can also include the equivalent of [[implicit parameters]] in our metatheorem statements, but unlike the standard method where we define a new type family, all our implicit parameters must be listed after the <tt>forall*</tt> keyword. We can then prove two more metatheorems (the second is the commutativity of addition).\n\n<twelf>\n%theorem plus-s : forall* {N1: nat}{N2: nat}{N3: nat}\n                  forall {D1: plus N1 N2 N3} \n                  exists {D2: plus N1 (s N2) (s N3)} \n                  true.\n%prove 5 D1 (plus-s D1 D2).\n\n%theorem plus-comm : forall* {N1: nat}{N2: nat}{N3: nat}\n                 forall {D1: plus N1 N2 N3} \n                 exists {D2: plus N2 N1 N3} \n                 true.\n%prove 5 D1 (plus-comm D1 D2).\n</twelf>\n\n== See also ==\n\n* {{guide|title=Theorem Prover|chapter=10|section=57}}"
          },
          "sha1": "6sfrgktj43wz4pct9gbjfgty285lae5"
        }
      },
      {
        "title": "Totality assertion",
        "ns": 0,
        "id": 1821,
        "revision": {
          "id": 6119,
          "parentid": 5170,
          "timestamp": "2010-09-02T12:30:24Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 3982,
            "#text": "A '''totality assertion''' is one type of [[metatheorem]] about [[LF]] [[type family|type families]].  A totality assertion for a type family <tt>a</tt> is specified by designating some arguments of the type family as inputs and the remaining arguments as outputs, and by specifying a set of LF contexts.  Then the totality assertion for the type family is the following proposition:\n\n: For all contexts Γ, for all inputs <tt>M</tt> in Γ, there exist outputs <tt>N</tt> in Γ such that the type <tt>a M N</tt> is inhabited in Γ.\n\nIn Twelf, totality assertions are specified using [[%mode]] and [[%worlds]] declarations and verified using [[%total]] declarations.  Totality assertions are useful for verifying properties of object-language [[judgment]]s.  Additionally, Twelf's ability to verify totality assertions is used to prove general [[metatheorem]]s.  \n\n== Example totality assertions == \n\nConsider the following LF signature, which defined addition on natural numbers:\n\n<twelf>\nnat : type.\nz   : nat.\ns   : nat -> nat.\n\nplus   : nat -> nat -> nat -> type.\nplus-z : plus z N2 N2.\nplus-s : plus (s N1) N2 (s N3)\n\t  <- plus N1 N2 N3.\n</twelf>\n\nA type family such as <tt>plus</tt> defines a relation among its indices, where indices are related iff their instance of the family is inhabited by an LF term.  For example, <tt>plus</tt> defines a relation between three terms of type <tt>nat</tt>.  The terms (<tt>s (s z)</tt>, <tt>s z</tt>, <tt>s (s (s z))</tt>) are related by this relation (because 2 + 1 = 3), but the terms (<tt>z</tt>, <tt>s z</tt>, <tt>s (s (s z))</tt>) are not.\n\nTotality assertions are one class of statements about LF type families. A totality assertion for a type family is specified by designating some index positions as inputs and others positions as outputs.  We call this specification the [[%mode|mode]] of the totality assertion.  Given a mode specification, the totality assertion asserts that for all inputs, there exist outputs that stand in the relation. Using <tt>plus</tt> as an example, if we designate the first two positions as inputs and the third position as an output, this specifies the following totality assertion:\n\n: For all <tt>N1:nat</tt> and <tt>N2:nat</tt>, there exist <tt>N3:nat</tt> and <tt>D:plus N1 N2 N3</tt>.\n\nThat is, the sum of any two natural numbers exists.  Designating instead the first position as output and second and third positions as inputs defines the following totality assertion:\n\n: For all <tt>N2:nat</tt> and <tt>N3:nat</tt>, there exist <tt>N1:nat</tt> and <tt>D:plus N1 N2 N3</tt>.\n\nOf course, this totality assertion is false, as <tt>N3 - N2</tt> might not be a natural number.\n\nA totality assertion for an LF type family corresponds with the standard notion of totality for the relation defined by the family.  Proving a relation total is different from showing that the relation defines a function, as the outputs of a total relation are not necessarily unique&mdash;the relation may relate particular inputs to more than one collection of outputs.\n\nWe may prove a totality assertion by induction on [[canonical forms]].  For example, we can prove the first above totality assertion by induction on <tt>N1:nat</tt>.  \n\nThe above examples consider only terms that are well-typed without mentioning LF variables. In general, it is useful to state totality assertions about all terms that are well-typed in any LF context in a particular [[world]], which is a set of LF contexts.  Thus, a totality assertion is specified by both a mode declaration and a [[%worlds|world declaration]].  \n\nThe page on [[%worlds]] presents an example totality assertion in non-empty contexts.\n\n== See also ==\n* This page's description of totality assertions was extracted from {{proving|title=Proving totality assertions about the natural numbers}}.  Read that introduction to learn how to prove totality assertions using Twelf, and how to use totality assertions to mechanize proofs of more general [[metatheorem]]s."
          },
          "sha1": "e3b2owj95tpjqne3b5dv1v5mb7vyqcy"
        }
      },
      {
        "title": "Totality assertions",
        "ns": 0,
        "id": 1822,
        "redirect": {
          "@title": "Totality assertion",
          "#text": null
        },
        "revision": {
          "id": 3413,
          "timestamp": "2006-12-28T06:43:13Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "[[Totality assertions]] moved to [[Totality assertion]]: I guess we try not to plural things here.",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 32,
            "#text": "#REDIRECT [[Totality assertion]]"
          },
          "sha1": "jc4bl7ia1uai9n1wr951nzdkrarusvb"
        }
      },
      {
        "title": "Try Twelf now",
        "ns": 0,
        "id": 1709,
        "redirect": {
          "@title": "Twelf Live",
          "#text": null
        },
        "revision": {
          "id": 2776,
          "timestamp": "2006-10-13T21:33:47Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "[[Try Twelf now]] moved to [[Twelf Live]]: Separate page with a name. Horray for AJALF!",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 24,
            "#text": "#REDIRECT [[Twelf Live]]"
          },
          "sha1": "65oxu796zqeg82mvc4825qwxuntk6d9"
        }
      },
      {
        "title": "Tutorial",
        "ns": 0,
        "id": 1638,
        "redirect": {
          "@title": "Tutorials",
          "#text": null
        },
        "revision": {
          "id": 2270,
          "timestamp": "2006-09-30T05:58:40Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "[[Tutorial]] moved to [[Tutorials]]: Should have put it here in the first place",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 23,
            "#text": "#REDIRECT [[Tutorials]]"
          },
          "sha1": "0gix2xri4j3grz0gx8k3mmlakxagwjj"
        }
      },
      {
        "title": "Tutorials",
        "ns": 0,
        "id": 1421,
        "revision": {
          "id": 6559,
          "parentid": 6557,
          "timestamp": "2012-11-12T21:30:17Z",
          "contributor": {
            "ip": "90.184.11.212"
          },
          "comment": "/* Removed spam. */",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 3552,
            "#text": ":''If you are not already familiar with Twelf, you should read the [[introductions to Twelf]] before reading the tutorials on this page.  See the [[documentation]] page for other resources.''\n\nTypes of tutorials:\n* '''[[#Proof techniques|Proof techniques]]:''' learn helpful and common Twelf devices.\n* '''[[#Troubleshooting|Troubleshooting]]:''' learn how to diagnose and fix Twelf errors. \n\nFeel free to write new tutorials and add them to this page.__NOTOC__\n\nThese tutorials are also gathered in the [[:Category:tutorials|tutorial category]].  \n\n== Proof techniques ==\n\n<!-- DRL says: header 2 has too much visual weight here -->\n\n==== Beginner ====\n\n* [[Reformulating languages to use hypothetical judgements]] - how to present judgements in a way that's easy to encode in LF.\n* [[Holes in metatheorems]] - how to assume lemmas while developing proofs.\n* [[Equality]] - how to represent equality of LF terms as a type family.\n* [[Respects lemma]]s - how to prove that other families and constants respect equality and other relations.\n* [[Uniqueness lemma]]s - how to prove that the inputs to a relation determine an output uniquely.\n* [[Effectiveness lemma]]s - how to prove [[totality assertion]]s explicitly.\n* [[Output factoring]] - how to reason from a disjunction.  Illustrates proving the progress theorem for a programming language.                            \n* [[Reasoning from false]] - how to do proofs by contradiction.\n* [[Catch-all case]]s - how to avoid putting a theorem case in the LF context.\n* [[Mutual induction]] - how to prove mutually inductive theorems\n* [[Converting between implicit and explicit parameters]] - how to convert between implicit and explicit quantification of the parameters of a type family.\n\n==== Advanced ====\n\n* [[Strengthening]] - how to convince Twelf that a term does not depend on some assumptions.\n* Explicit termination metrics - how to use a termination metric other than the subderivation ordering.\n** [[Numeric termination metrics]] - how to use numbers to induct on the size of some argument.\n** [[Structural termination metrics]] - how to use fancier termination metrics that capture the structure of an argument directly.\n* [[Simplifying dynamic clauses]] - how to streamline certain proofs about relations that introduce hypotheses. \n* [[Canonical forms lemma]] for a progress theorem - how to get this lemma for free when you can, and how to prove it explicitly using [[equality]] when you can't.\n* Structural properties of a [[hypothetical judgement]] - how to get structural properties for free when you can, and how to prove them explicitly when you can't.\n** [[Weakening]]\n** [[Exchange]] \n** [[Substitution]]\n* [[Evaluation contexts]] - how to represent evaluation contexts as LF functions\n* [[User-defined constraint domain]]s - how to make encodings more [[Intrinsic and extrinsic encodings|intrinsic]] by replacing predicates with indexing, and how to use Church-encodings to create special index types that are similar to constraint domains in that they admit non-trivial equations on their elements.\nFor larger examples of Twelf in action, see see the [[case studies]].\n\n== Troubleshooting ==\n\n* [[Error messages]] - brief explanations of (and remedies for) common Twelf error messages.\n* [[Output freeness|Understanding output freeness]] - understanding a subtle part of output coverage checking.\n* [[Debugging coverage errors]] - techniques for finding coverage errors.\n* [[Constraint domains and coverage checking]] - in general, you can't use them in the same [[signature]]."
          },
          "sha1": "sx4vzfsakhe5ltag5crt7cy6qhi40yn"
        }
      },
      {
        "title": "Twelf-list",
        "ns": 0,
        "id": 1648,
        "redirect": {
          "@title": "Mailing lists",
          "#text": null
        },
        "revision": {
          "id": 2318,
          "parentid": 2307,
          "timestamp": "2006-09-30T22:44:41Z",
          "contributor": {
            "ip": "71.206.199.131"
          },
          "comment": "Redirecting to [[Mailing lists]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 27,
            "#text": "#REDIRECT [[Mailing lists]]"
          },
          "sha1": "d4bw2y12z3b5n2f5k02k8ic3i1wrsjx"
        }
      },
      {
        "title": "TwelfTag",
        "ns": 0,
        "id": 1843,
        "revision": {
          "id": 3847,
          "parentid": 3766,
          "timestamp": "2007-03-03T05:39:59Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "minor": null,
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 2323,
            "#text": "%{ The '''TwelfTag''' system is a way of adding Twelf code directly into the Twelf Project Wiki. This page gives an introduction to TwelfTag for readers. The page [[Project:TwelfTag]] has information about TwelfTag for editors, and the [[Twelf Live]] system provides a more interactive way of using Twelf with on this website. }%\n\n%{ == Syntax highlighting == }%\n\n%{ The most basic function of TwelfTag is to highlight Twelf code much the same way that [[Twelf with Emacs|Emacs]] does. Names are red, and metavariables (free variables) are in blue.  \n}%\n\nelem : type.\n\nlist : type.\nnil : list.\ncons : elem -> list -> list.\n\nlist-reverse : list -> list -> list -> type.\nlr/nil : list-reverse nil L L.\nlr/cons : list-reverse (cons E L1) L2 L3\n           <- list-reverse L1 (cons E L2) L3.\n\n%{ == Showing Twelf's response == }%\n\n%{ When Twelf checks a piece of code, it produces some output that represents Twelf's reconstruction of that code and a message (<tt>%% OK %%</tt> or <tt>%% ABORT %%</tt>) that signals whether it was successful. Sometimes it is helpful to show Twelf's response in an article, and TwelfTag can do this too, showing Twelf's response in green. |check=decl}%\n\n%solve test : {e1}{e2}{e3}{e4} list-reverse (cons e1 (cons e3 (cons e2 (cons e4 nil)))) nil _.\n\n%. == Linking to Twelf code and Twelf output ==\n\nTwelfTag has the ability to link, inside a page, to the code that has been shown highlighted on that page, and also to link to the response Twelf gives when checking that code.\n*<twelflink>This link</twelflink> shows you the twelf code (the code that is shown with syntax ) for this page.\n*<twelflink check=true>This link</twelflink> shows you Twelf's response from reading the code on this page.\n\n== \"Literate Twelf\" ==\n\nFor some pages, including this one, the page itself is written in valid Twelf that is then automatically transformed into an article. Pages written in this way look exactly like other pages, but they have a note at the top of the article that reports on Twelf's status after reading the file - <tt>%% OK %%</tt> means everything checked out, and <tt>%% ABORT %%</tt> means that there was a problem - and links to both the code and Twelf's response. More information on writing articles with this feature can be found at the page on [[Project:Literate Twelf|Literate Twelf]]."
          },
          "sha1": "8wokqsxaax0axe04n2sme4iajq4o2yx"
        }
      },
      {
        "title": "Twelf Elf Rotation Charter",
        "ns": 0,
        "id": 1719,
        "revision": {
          "id": 2854,
          "parentid": 2852,
          "timestamp": "2006-10-14T22:23:33Z",
          "contributor": {
            "username": "DanielKLee",
            "id": 5
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 2244,
            "#text": "This is the charter for those who volunteer into the rotation of people making sure that Twelf related questions are answered in a timely fashion.\n\n* At any given time, there will be one person on the rotation designated as \"possessed\" by Twelf Elf.\n* After a tenure two weeks (this figure may change), the next person in the rotation will become \"possessed\" by Twelf Elf. \n* The \"possessed\" is responsible for monitoring the Twelf Elf e-mail account and [[Ask Twelf Elf]] wiki article for questions.\n* The primary duty of the \"possessed\" is the ensure questions sent to the Twelf Elf are responded to in a timely fashion.\n* \"Timely fashion\" is currently set at 48 hours. This may change in the future.\n* The \"possessed\" should answer to any questions it is within his ability to do so.\n* The \"possessed\" should arrange for someone on the rotation to fill in for him for periods he knows he will be unable to fulfill his duties (e.g. very sick, stuck on a cruise ship, at a conference, etc).\n* If the \"possessed\" is unable to answer a question, he should attempt to refer the question to someone on the rotation who is able to do so. The question should get a \"That one is tricky, but someone '''will''' get back to you in a few days!\" response. If no such person exists, the question should get a \"Sorry, we don't know!\" response.\n* If a question has been referred to someone on the rotation, that person should attempt to send an adequate response within a week. If the initial question was by e-mail, responses should either be sent from the Twelf Elf e-mail address or CCed to it for recording purposes.\n* Questions/answers that are interesting and not covered by the wiki should become wiki articles. \n* Valid questions/answers should not be deleted from the e-mail account. Feel free to nuke spam.\n* Anyone on the rotation is free to monitor the e-mail address. \n* Someone on the rotation but not currently \"possessed\" may volunteer to take over a question.\n\n== Current rotation ==\n\nCurrently, we are tracking the rotation with google calendar. [http://www.google.com/calendar/render?cid=twelfelf%40gmail.com Subscribe]. \n\n*10/13/06 &ndash; 10/28/06 : [[User:DanielKLee|DanielKLee]]\n*10/29/06 &ndash; 11/11/06 : [[User:Rsimmons|Rsimmons]]"
          },
          "sha1": "0ieacsvwccih9o6gs7grysp1jadfg74"
        }
      },
      {
        "title": "Twelf Live",
        "ns": 0,
        "id": 1691,
        "revision": {
          "id": 5540,
          "parentid": 5395,
          "timestamp": "2008-11-20T21:59:54Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "minor": null,
          "comment": "I think it works more generally now",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 1526,
            "#text": "You can '''try Twelf now''' from the wiki without installing any software! The same [[The Twelf Project:TwelfTag|TwelfTag]] system that allows code on the wiki to be automatically checked powers an online, interactive Twelf interface. \n\nhttp://twelf.plparty.org/live/\n\nFeel free to develop bits of Twelf code in this manner. If you plan on doing serious development with Twelf, you will probably want to eventually [[download]] Twelf so you can develop your Twelf code in a more private and configurable environment.\n\n== Using Twelf Live ==\n\n=== Regular view ===\n\nThe interface for Twelf Live is fairly simple; text is entered into the \"Input\" window just as it would be entered into Emacs when using [[Twelf with Emacs]].  Hitting the \"check\" button causes the \"Output\" window to display the output of Twelf from reading the file - the screenshot below shows Twelf Live immediately after the \"check\" button is clicked.\n\n[[Image:TWELFLIVE-2.png]]\n\n=== Incremental view ===\n\nIt can be difficult, when there is a great deal of output, to see just the part that you are interested in. In this situation it is useful to use the incremental view, which is opened by clicking \"open incremental view.\" In incremental view, Twelf will not display anything while checking the first input window (assuming there are no errors), but will display output normally while checking the second input window. This can be seen below, where Twelf only outputs the result of checking the <tt>[[%query]]</tt> declaration.\n\n[[Image:TWELFLIVE-3.png]]"
          },
          "sha1": "j0ryadaiufrwnxy7fo00762w02p4hhr"
        }
      },
      {
        "title": "Twelf glossary",
        "ns": 0,
        "id": 1498,
        "redirect": {
          "@title": "Glossary",
          "#text": null
        },
        "revision": {
          "id": 1904,
          "timestamp": "2006-09-25T03:57:38Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 22,
            "#text": "#REDIRECT [[Glossary]]"
          },
          "sha1": "qy901llvsbudox5oho8s6f41t7ptbxe"
        }
      },
      {
        "title": "Twelf naming conventions",
        "ns": 0,
        "id": 1647,
        "redirect": {
          "@title": "Naming conventions",
          "#text": null
        },
        "revision": {
          "id": 2306,
          "timestamp": "2006-09-30T19:51:53Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "needed pages cleanup",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 32,
            "#text": "#REDIRECT [[Naming conventions]]"
          },
          "sha1": "5bvfctp8h4imz3ajus2g3mpjpfnidon"
        }
      },
      {
        "title": "Twelf signature",
        "ns": 0,
        "id": 1644,
        "revision": {
          "id": 4508,
          "parentid": 2299,
          "timestamp": "2007-03-20T23:59:14Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 391,
            "#text": "A '''Twelf signature''' is the thing you are writing when you are writing Twelf code - when you create a [[configuration file]], all the Twelf code in all the files you are working with makes up a Twelf signature. \n\n{{needs|a simple description of how the term arises from the LF theory}}\n\n== See also ==\n* See the [[introductions to Twelf]] to learn how to write Twelf signatures.\n\n{{stub}}"
          },
          "sha1": "g36r6vofkhslauavd1b7r87hpjchv8g"
        }
      },
      {
        "title": "Twelf style guide",
        "ns": 0,
        "id": 1442,
        "revision": {
          "id": 6052,
          "parentid": 3622,
          "timestamp": "2010-02-24T22:42:11Z",
          "contributor": {
            "ip": "132.206.54.94"
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 12303,
            "#text": "''This page is a style guide for Twelf code. For a style guide for contributions to the Twelf Project Wiki, see [[Project:Style guide]]''\n\nThe style you use to write Twelf code should be consistent so that it is readable by others now and by you in the future. However, the general objectives of <i>consistency and readability of code</i> is more important than anything that is or possibly could be said on this page. Therefore, this page should be seen as attempt to collect a set of good practices from experience that can be used as recommendations for new users. \n\nThe first two sections are about whitespace & comments, which are extremely important aspects of readability. The final section is on conventions used for writing identifiers, which is less important as long as consistency is maintained within a project. The article on [[naming conventions]] also considers ways of standardizing identifier names.\n\n== Whitespace ==\n\nProper use of whitespace, line breaks, and spacing is very important for promoting the readability of Twelf code.\n\n=== Object language syntax === \n\nThe declarations for the constants corresponding to a type for syntax of an object language should be grouped together. There should be an empty line between the declaration of the type and its constants. There should be a line break, but no empty lines, between each declaration.\n\n<twelf>\ncolor : type.\n\ncolor/red   : color.\ncolor/black : color.\n</twelf>\n\n=== Judgments ===\n\nThe declarations for the constants corresponding to the inference rules for a particular judgment should be grouped together. There should be an empty line between the declaration of the judgment and its inference rules, as well as one empty line between the declaration of two inference rules. If a [[%mode]] declaration is used, it should be on the line immediately following the declaration of the judgment.\n\n<twelf>\ncolor-neq : color -> color -> type.\n\ncolor-neq/red-black : color-neq color/red color/black.\n\ncolor-neq/black-red : color-neq color/black color/red.\n\n\n\ncolor-swap : color -> color -> type.\n%mode color-swap +C1 -C2.\n\ncolor-swap/red : color-swap color/red color/black.\n\ncolor-swap/black : color-swap color/black color/red.\n</twelf>\n\n=== Metatheorems === \n\nThe definitions for cases to a metatheorem should be grouped together. The <tt>%mode</tt> declaration should be on the line following the declaration of the type family for the metatheorem, with no line breaks in between. There should be an empty line following the mode declaration. There should be one empty line between each case. There should be an empty line preceding the <tt>%worlds</tt> declaration. The <tt>%total</tt> declaration should be on the following line.\n\n<twelf>\ncan-color-neq : {C:color} color-neq C C' -> type.\n%mode color-neq +D1 -D2.\n\n- : can-color-neq color/red color-neq/red-black.\n\n- : can-color-neq color/black color-neq/black-red.\n\n%worlds () (color-neq _ _).\n%total {} (color-neq _ _).\n</twelf>\n\n=== Additional guidelines ===\n\n* There should be at least 3 empty lines between any \"groups\", where a group is something on the scale of declarations for a type family or proof of a metatheorem. 4 or more empty lines should between super-groups of related groups, such as the proofs for a set of related lemmas.\n\n* The colons following the names of the constants for a group should all line up.\n\n* Directives such as <tt>[[%mode]]</tt>, <tt>[[%reduces]]</tt>, <tt>[[%terminates]]</tt>, <tt>[[%worlds]]</tt>, <tt>[[%total]]</tt> should be at the start of a new line. The one exception to this rule is the fixity directives such as <tt>[[%infix]]</tt> - it is often clearest to put the fixity declaration for a constructor on the same line as the declaration of that constructor.\n\n== Comments ==\n\nComments are at least as important a consideration when writing Twelf code intended to be readable by others, especially when the other readers are not themselves Twelf users.  The [http://www.cis.upenn.edu/~plclub/wiki-static/cmu-twelf/1a.elf CMU POPLMark solution] contains a good representation of how comments can be used to aid comprehension of a proof.\n\n=== Guidelines ===\n\n* Each file should begin with single-line comments establishing a title and authorship. If several more lines about the purpose of the file are needed, those should go into a multi-line comment immediately underneath the title/author information.\n\n* Single line comments should annotate most \"groups\" and \"super-groups\" explaining, briefly, their purpose. They should be associated with a relatively strong visual indicator that is consistent across the file, such as one of the following. Be conscious of the interaction of your comment style with the [[Twelf with Emacs|Twelf Emacs mode]] syntax highlighting – some comment styles which use percent signs at the end and the beginning of a line cause the syntax highlighting to behave unpredictably.\n<twelf>\n%%%%% Syntax %%%%%\n% ===== Type system ===== \n%%----- Theorems about termination behavior -----\n% ******* The result is s(s(s nat-39)) ******* \n%%%%% Metatheorems about nat\n%%%%{ Type preservation }%%%%\n</twelf>\n\n* Comments are most useful as multi-line comments at the beginning of \"groups\" and \"super-groups\" as defined in the previous section. Listing the important metatheorems at the beginning of a long group of metatheorems is also helpful.\n\n* Multi-line comments should be as free of visual cruft (borders, horizontal lines) as possible. The <tt>%{   }%</tt> construct should be used for most multi-line comments.\n\n== Identifiers ==\n\nDue to the current absence of a module system for Twelf, careful identifier choice is crucial to managing the namespace of a large project. Because small projects can often grow into something quite large, we suggest thinking about a system of conventions such as the one described here from the outset. \n\nThe names of constants and [[type families]] should ''always'' begin with a lower case letter. Type families should only contain lower-case letters, numbers, and dashes (\"-\") which are used to separate words in an identifier, as in <tt>this-is-my-neat-proof</tt>. The other options using underscores (as in <tt>this_is_my_neat_proof</tt>), an option that is often used but which is currently generally avoided. Using <tt>camelCase</tt> is generally to be avoided: it is easier to distinguish an [[implicit parameter]] from a constant if only implicit parameters use capital letters.\n\n[[Implicit parameter|Implicit parameters]] must be capitalized; when using [[explicit parameter|explicit parameters]]it is sometimes clearer to capitalize them, but it is often more clear and less error-prone to make explicit parameters lower case.\n\nTwelf code can generally be sorted into one of three categories: '''[[object logic syntax]]''', '''[[judgments]]''' about the object logic syntax and other judgments, and '''[[metatheorem]]s''' about the object logic. Each of the three categories has distinct style conventions.\n\nIn this section, conventions will only be given as to how to structure identifiers with separators such as \"-\" and \"/\" to make then more readable and organized. There is a separate guide for [[naming conventions]] which suggests what words should go between such separators.\n\nThe [[natural numbers]] will be used as a running example.\n\n=== Object language syntax ===\n\n<twelf>nat : type. \nlist-nat : type.</twelf>\n\nType families are typically inhabited by constants that correspond to different pieces of syntax or inference rules. We use a slash (\"/\") between the name of the type family and the identifier for the individual rule. \n\n<twelf>nat/z : nat.\nnat/s : nat -> nat.\n\nlist-nat/nil : list-nat.\nlist-nat/cons : nat -> list-nat -> list-nat.</twelf>\n\n(Whether a list of natural numbers should be called <tt>list-nat</tt> or <tt>nat-list</tt> is a matter left to the [[naming conventions]] article.)\n\n====Abbreviations====\n\nThe disadvantage of this representation is that identifier names can get relatively long. \n\nThere are two solutions for this. One is that, if you are defining a language or logic, and not a library to be used in another project, you may want to consider a small number of pieces of syntax your \"leaf cases\" and simply leave off the part before the forward slash.\nBe careful if you are doing so; this will seem like a great idea until you realize that you need both an element of type and an element of syntax called <tt>cont</tt> or <tt>pair</tt> or <tt>tuple</tt>.\n\nThe other solution is to use an ''abbreviation'' or a ''notational definition''. \n<twelf>\n% Example of abbreviation\n\n%abbrev z = nat/z.\n%abbrev s = nat/s.\n\n% Example of notational definition\n\nz = nat/z.\ns = nat/s.\n</twelf> \nAbbreviations are probably better for large projects, because even if the abbreviated identifier gets redefined,  it appears in the unshadowed extended form in the Twelf buffer. Notational definitions are probably preferable for small projects - or projects which are being debugged - for the same reason: shorter, more informative identifiers will appear in the Twelf buffer.\n\n=== Judgments ===\n\nThe naming conventions for judgments and their inference rules are similar to the ones for object syntax. The part after the forward slash, if it is associated with a piece of relevant syntax (i.e. <tt>/cons</tt> or <tt>/s</tt>) should use the same modifier.\n\n<twelf>plus-nat : nat -> nat -> nat -> type.\n%mode plus-nat +N1 +N2 -N3.\n\nplus-nat/z : plus-nat z N N.\n\nplus-nat/s : plus-nat (s N1) N2 (s N3)\n               <- plus-nat N1 N2 N3.</twelf>\n\n=== Metatheorems ===\n\n==== Identifier names ====\n\nEach metatheorem is given a name in Twelf. There are two ways in which someone might consider naming their metatheorems. If you are defining a metatheorem that defines an admissible rule, it may be reasonable to use the convention used for showing inference rules:\n\n<twelf>\nplus-nat/z-alt : {N} plus-nat N z N -> type.\n%mode plus-nat/z-alt +N -D.\n</twelf>\n\nIn most other cases, however, it is more reasonable to simply name the lemma using words and hyphens:\n\n<twelf>\nplus-comm : plus-nat N1 N2 N3 -> plus-nat N2 N1 N3 -> type.\n%mode plus-comm +D1 -D2.\n</twelf>\n\n==== Case names ====\n\nThe cases in a metatheoretic proof almost never need to be referred to, so it is common to name the labels for every individual case <tt>-</tt>. This may, however, make it more difficult to correlate error messages with specific rules, and so should be done with care.\n<twelf>\nplus-nat/z-alt : {N} plus-nat N z N -> type.\n%mode plus-nat/z-alt +N -D.\n\n- : plus-nat/z-alt z plus-nat/z.\n\n- : plus-nat/z-alt (s N) (plus-nat/s D) \n      <- plus-nat/z-alt N D.\n\n%worlds () (plus-nat/z-alt _ _).\n%total T (plus-nat/z-alt T _).\n</twelf>\n\nIf it is preferable to give each case of a metatheorem a name, for debugging or clarity reasons, the convention is to put a <tt>-</tt> before an identifier for the case. For example, we could re-write the preceding theorem in the following way.\n\n<twelf>\nplus-nat/z-alt : {N} plus-nat N z N -> type.\n%mode plus-nat/z-alt +N -D.\n\n-z : plus-nat/z-alt z plus-nat/z.\n\n-s : plus-nat/z-alt (s N) (plus-nat/s D) \n      <- plus-nat/z-alt N D.\n\n%worlds () (plus-nat/z-alt _ _).\n%total T (plus-nat/z-alt T _).\n</twelf>\n\n== Example signature ==\n\n<twelf>\n%% Demonstration of good Twelf style\n%% The Twelf Wiki authors, Febtober 19045\n\n%{\n\nIf we needed to say a bit more about what we were doing\nhere than just the line or two that fits at the top of the\npage, then this would be about the right place to try\nand put that in.\n\n}%\n\n\n\n%%%%%{ Syntax }%%%%%\n\nexp : type.\n\nexp/unit : exp.\n\n\n\n%%%%%{ Types }%%%%%\n\ntp : type.\n\ntp/unit : tp.\n\n\n\n\n%%%%%{ Judgments }%%%%%\n\ntyped : exp -> tp -> type.\n%mode typed +E -T.\n\ntyped/unit : typed exp/unit tp/unit.\n\n\n\nisvalue : exp -> type.\n%mode isvalue +E.\n\nisvalue/unit : isvalue exp/unit.\n\n\n\n\n%%%%%{ Metatheorems }%%%%%\n\n%{\n\nWe're only proving one, rather silly, methatheorem in this style example,\nnamely that if an expression is a value then it has a type. Of course,\nwe're relying on the fact that everything in our toy language is a value\nand has a type.\n\n}%\n\nisvalue-implies-typed : isvalue E -> typed E T -> type.\n%mode isvalue-implies-typed +D1 -D2.\n\n- : isvalue-implies-typed isvalue/unit typed/unit.\n\n%worlds () (isvalue-implies-typed _ _).\n%total T (isvalue-implies-typed T _).\n</twelf>"
          },
          "sha1": "ptkuocpjsnfvnlqt281juvmaloetxxp"
        }
      },
      {
        "title": "Twelf with Emacs",
        "ns": 0,
        "id": 1800,
        "revision": {
          "id": 7993,
          "parentid": 6005,
          "timestamp": "2014-09-22T01:54:32Z",
          "contributor": {
            "username": "Blaisorblade",
            "id": 13589
          },
          "comment": "/* Using the Twelf emacs mode */ Warning on clearing declarations",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 6280,
            "#text": "The preferred way to interact with Twelf is through its emacs mode, which is included in the Twelf distribution. The [[Download]] page has basic information for setting up Emacs mode with Twelf.\n\n==Prerequisites==\n\nThese instructions assume you've already [[Download|downloaded Twelf]], and that either \n* You used the Windows/OSX installer\n* You downloaded a pre-compiled tarball\n* You downloaded a source tarball and have already built Twelf\n\nThese instructions should easily translate to using Subversion to get Twelf, however.\n\n==Installing the Twelf emacs mode==\n\nAdd the following to your Emacs configuration file, which should be the file .emacs in your home directory. \n\n<code>(setq twelf-root \"/somewhere/twelf/\")\n(load (concat twelf-root \"emacs/twelf-init.el\"))</code>\n\nFor instance, if the directory where you unpacked the tarball is <tt>/usr/local/twelf</tt>, then you'll want those two lines to be:\n\n<code>(setq twelf-root \"/usr/local/twelf/\")\n(load (concat twelf-root \"emacs/twelf-init.el\"))</code>\n\nIf your Twelf directory is <tt>/home/foo/stuff/logic/twelf</tt>, then you'll want those lines to be:\n\n<code>(setq twelf-root \"/home/foo/stuff/logic/twelf/\")\n(load (concat twelf-root \"emacs/twelf-init.el\"))</code>\n\nIf you used the default Windows installer, you'll want those to lines to be \n\n<code>(setq twelf-root \"C:\\\\Program Files\\\\Twelf\\\\\")\n(load (concat twelf-root \"emacs\\\\twelf-init.el\"))</code>\n\nExit Emacs and restart it.\n\n== How Twelf programs are divided up into files ==\n\n# Twelf programs should be stored in files with the <tt>.elf</tt> extension.  \n# All of the <tt>.elf</tt> files in a project are collected in a ''configuration file'', typically called <tt>sources.cfg</tt>.  A configuration file lists (paths to) individual <tt>.elf</tt> files in dependency order.  You can load a configuration file, which loads each <tt>.elf</tt> file in sequence.\n\n=== Creating a .cfg file ===\n\nStart Emacs in some directory (for the purposes of this description, we'll assume it's <tt>~/tmp/twelf</tt>. Create the '''configuration file''' <tt>sources.cfg</tt> with the following text in it:\n\n<code>sometwelf.elf</code>\n\nSave the file (by using CTRL-x CTRL-s in Emacs).\n\n=== Creating a .elf file ===\n\nThen create a file <tt>sometwelf.elf</tt> (by using CTRL-x CTRL-f in Emacs) and enter the following text:\n\n<twelf>\nnat : type.\nz : nat.\ns : nat -> nat.\nss : nat -> nat = [n] s (s n).\n\nplus : nat -> nat -> nat -> type.\nplus/z : plus z N N.\nplus/s : plus N M P -> plus (s N) M (s P).\n</twelf>\n\nSave the file (by using CTRL-x CTRL-s in Emacs).\n\n== Using the Twelf emacs mode ==\n\nYou use Twelf by asking it to process declarations. Twelf responds by either printing <tt>Server OK</tt> at the bottom of the screen if your declarations were processed successfully, or by popping up the twelf-server buffer if there was an error (ABORT).\n\nThe emacs mode allows you to process declarations at a variety of granularities:\n* A whole configuration file (CTRL-c CTRL-c loads a cfg file)\n* A whole .elf file (CTRL-c CTRL-s loads the .elf file open in the current emacs window)\n* A single declaration (thing ending in a period) (CTRL-c CTRL-d loads declaration the cursor is on in the in the current .elf file)\n\nFor example, a typical use case is to load your entire project with CTRL-c CTRL-c when you start working, and then to process new Twelf code declaration-by-declaration as you write it, using CTRL-c CTRL-d.  Sometimes you will go back and make edits in lots of different places in a file, in which case it's helpful to reload just the current file with CTRL-c CTRL-s. \n\nOnly reloading the configuration clears the state of Twelf. Even reloading will not clear previous declarations from the file (though it will typically shadow them). This might give unexpected results if you remove a declaration and expect it to have disappeared.\n\n=== Loading the configuration file: CTRL-c CTRL-c ===\n\nAssuming you still have <tt>sometwelf.elf</tt> open in emacs, hit CTRL-c CTRL-c. If <tt>sometwelf.elf</tt> has unsaved changes, you will be asked:\n\n<code>File not in current configuration. Save? (yes or no)</code>\n\nType yes.\n\nYou will then be asked:\n\n<code>Visit config file: (default sources.cfg) ~/tmp/twelf/</code>\n\nThis is asking for the location of the sources.cfg file you saved when following the instructions above; the default option is the correct one. Just hit ENTER.\n\nYou will then be asked:\n\n<code>Twelf server: (default twelf-server) /something/bin/</code>\nThis is asking which Twelf binary you want to run; the default should already be correct, just hit ENTER.\n\nThis will process your configuration file, which in turn says to process <tt>sometwelf.elf</tt>.\n\n=== Checking an individual declaration: CTRL-c CTRL-d ===\n\nNow you can type new declarations into the emacs buffer and use CTRL-c CTRL-d to load them.\n\n=== Checking an individual file: CTRL-c CTRL-s ===\n\nOr you can reload the file in the current window with CTRL-c CTRL-s.  You must previously have loaded a configuration file.\n\n== Syntax highlighting ==\n\nTwelf does not automatically refresh its syntax highlighting as you type.  You can manually refresh the highlighting as follows:\n\n# <tt>CTRL-c l</tt> fontifies the currently visible emacs buffer.  E.g. in <tt>sometwelf.elf</tt>m the constants (<tt>nat</tt>, <tt>plus/z</tt>, etc.) should turn red, the bound variable <tt>n</tt> should turn green, and the logic-programming variables <tt>N</tt>, <tt>M</tt>, and <tt>P</tt> should turn blue.\n# <tt>CTRL-c CTRL-l</tt> fontifies the current declaration only.  This is useful if you have really big files.\n\nFor more info on the emacs mode, see {{guide|chapter=13|section=74|title=Emacs Interface}}.\n\n==Hacks==\n\nIf you use multiple frames with Emacs, <tt>twelf-mode</tt> annoyingly pops up the Twelf server buffer in the current frame, even if it is already shown in another frame. To avoid this, set <tt>display-buffer-reuse-frames</tt> to <tt>t</tt>. Now, you will still have the problem that although the buffer is shown, it does not scroll to the bottom; to fix this you need to edit <tt>twelf.el</tt> and change <code>(get-buffer-window twelf-server-buffer)</code> to <code>(get-buffer-window twelf-server-buffer t)</code>.\n\n== See also ==\n* {{guide|chapter=13|section=74|title=Emacs Interface}}"
          },
          "sha1": "em0lcn7ibvsox333x9q5snqyq78bk2q"
        }
      },
      {
        "title": "Twelf without Emacs",
        "ns": 0,
        "id": 2076,
        "revision": {
          "id": 5342,
          "parentid": 5341,
          "timestamp": "2008-07-22T21:24:42Z",
          "contributor": {
            "username": "William Lovas",
            "id": 11
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 1680,
            "#text": "First, you should read up on [[Twelf with Emacs]], to understand [[Twelf with Emacs#How Twelf programs are divided up into files|how Twelf programs are divided up into files]] and how one interacts with those files.  Then, instead of using emacs, you can run the <tt>twelf-server</tt> command directly from your shell and interact with your files using the following commands.  (You may find it convenient to run <tt>twelf-server</tt> under some readline wrapper program like <tt>rlwrap</tt> or <tt>ledit</tt> to get command-line editing and history.)\n\n=== Loading the configuration file ===\n\nTo read your current config from <tt>sources.cfg</tt>, type <code>make</code>  To read some other config <tt>other.cfg</tt>, type <code>make other.cfg</code>\n\n=== Checking an individual declaration ===\n\nTo check an individual declaration, type <code>readDecl</code>  Then, on a new line, type a Twelf declaration, terminated with a period.\n\n=== Checking an individual file ===\n\nTo load an individual file <tt>sometwelf.elf</tt>, type <code>loadFile sometwelf.elf</code>\n\n=== Logic programming proof search ===\n\nTo animate your specifications by doing logic programming queries, type <code>top</code>  You will be presented with a a prompt, <code>?-</code> at which you can type queries with existential metavariables, like <code>?- plus (s z) (s (s z)) N.</code>  Assuming you've loaded the signature from the [[Natural numbers]] article), the Twelf server responds with the following: <code>Solving...\nN = s (s (s z)).\nMore?</code>\nYou can exit the logic programming top-level by pressing Ctrl-C.\n\n=== Quitting ===\n\nTo quit from the Twelf server, type <code>quit</code> or press Ctrl-D."
          },
          "sha1": "nwkrofpb58uwl12o2cp1rjmk2lvnor3"
        }
      },
      {
        "title": "Type families",
        "ns": 0,
        "id": 1511,
        "redirect": {
          "@title": "Type family",
          "#text": null
        },
        "revision": {
          "id": 1993,
          "timestamp": "2006-09-27T21:52:39Z",
          "contributor": {
            "username": "DanielKLee",
            "id": 5
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 25,
            "#text": "#REDIRECT [[Type family]]"
          },
          "sha1": "19b06yw7o09ucbvnblmpaityoecdg6l"
        }
      },
      {
        "title": "Type family",
        "ns": 0,
        "id": 1481,
        "revision": {
          "id": 4552,
          "parentid": 1866,
          "timestamp": "2007-03-21T02:55:11Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 816,
            "#text": "We use the word '''type family''' to refer to the syntactic class of [[LF]] that classifies terms and is classified by kinds.  The type families include the types of LF, which are dependent function types and type family constants  that are fully applied to arguments.  The type families also include partially applied type family constants.  We refer to the arguments of a type family constant as the '''subjects''' or '''indices''' of the family.    \n\nThe LF methodology specifies how [[judgment|object-language judgements are represented as LF type families]].\n\n== See also ==\n* Read the [[introductions to Twelf]] to learn how to represent object-language entities as LF type families.\n* [[LF]]\n* [[Canonical form]]s\n* [[Judgment]]\n* [[Higher-order judgment]]\n* [[Syntax (Object logic)]]\n* [[Relation]]\n\n{{stub}}"
          },
          "sha1": "6ydqenyys36gghgn7cgvbdrbl5j8v2m"
        }
      },
      {
        "title": "Typed combinators soundness and completeness",
        "ns": 0,
        "id": 2145,
        "revision": {
          "id": 5715,
          "parentid": 5709,
          "timestamp": "2008-12-19T20:11:54Z",
          "contributor": {
            "username": "William Lovas",
            "id": 11
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 34269,
            "#text": "%{\n\nThis is a case study translating the simply-typed lambda calculus into the SKI\ncombinator calculus.  The correctness of the translation is proven in the\nfollowing sense: if a two terms are beta-eta equal, then their translations\nare beta-eta equal, and vice versa.\n\n[[User:William Lovas|William Lovas]]\n\n}%\n\n\n%{\n\n== Syntax and static semantics ==\n\n}%\n\n%{\n\nFirst we define the syntax of the two languages.  <tt>term A</tt> is the\ntype of simply-typed lambda-calculus terms of type A; <tt>comb A</tt> is\nthe type of simply-typed combinator terms of type A.  Combinators are of\ninterest primarily because they have no binding structure; despite this\napparent limitation, we can translate any lambda-calculus term to an\noperationally and logically related combinator term.\n\nNote that since we're using an\n[[intrinsic and extrinsic encodings|intrinsic encoding]], these syntax\ndefinitions double as definitions of the languages' static semantics.\n\nBy working over intrinsically typed terms, we can regard our theorems as\ntheorems comparing a natural deduction presentation of propositional logic\nwith a Hilbert-style axiomatic presentation, but none of the theorems depend\non types, and would hold equally well of untyped terms.\n\n}%\n\ntp : type.              %name tp A a.\n\no : tp.\n=> : tp -> tp -> tp.    %infix right 10 =>.\n\n\nterm : tp -> type.      %name term M x.\n\n%%% uncomment for untyped version:\n%% tm : type.              %name tm M x.\n%% %abbrev term : tp -> type = [x] tm.\n\napp : term (A => B) -> term A -> term B.\nlam : (term A -> term B) -> term (A => B).\n\n\ncomb : tp -> type.     %name comb N y.\n\n%%% uncomment for untyped version:\n%% cm : type.              %name cm N y.\n%% %abbrev comb : tp -> type = [x] cm.\n\ns : comb ((A => B => C) => (A => B) => A => C).\nk : comb (A => B => A).\ni : comb (A => A).\n\ncapp : comb (A => B) -> comb A -> comb B.\n\n%{ \n\nWe can use Twelf's [[Abbrev_declaration|abbreviation mechanism]] and\n[[Fixity declaration|fixity declarations]] to specify convenient infix\nsyntax for application.\n\n}%\n\n%abbrev @ = app.\n%infix left 10 @.\n\n%abbrev @@ = capp.\n%infix left 10 @@.\n\n\n%{\n\n== Equational theory ==\n\n}%\n\n%{\n\nThen we define equality relations on both languages.  <tt>teq</tt> is\ndefinitional equality for lambda terms; <tt>ceq</tt> is definitional\nequality for combinator terms.  In both cases, the equality relation\namounts to beta-eta equivalence.  (We use extensionality instead of a\nrule based on eta-expansion.)\n\n}%\n\n% definitional equality on terms\nteq : term A -> term A -> type.\n\n% beta\neq/beta : teq (app (lam [x] M1 x) M2) (M1 M2).\n\n% eta\neq/ext : teq M1 M2\n          <- ({x} teq (app M1 x) (app M2 x)).\n\n% compatibilities\neq/lam : teq (lam [x] M x) (lam [x] M' x)\n          <- ({x} teq (M x) (M' x)).\n\neq/app : teq (app M1 M2) (app M1' M2')\n          <- teq M1 M1'\n          <- teq M2 M2'.\n\n% equivalence\neq/refl : teq M M.\n\neq/symm : teq M M'\n           <- teq M' M.\n\neq/trans : teq M M''\n            <- teq M' M''\n            <- teq M M'.\n\n%{\n\nInfix syntax for transitivity is convenient when building derivations.\n\n}%\n\n%abbrev ; : teq N N' -> teq N' N'' -> teq N N'' = [d1] [d2] eq/trans d1 d2.\n%infix right 5 ;.\n\n%block term-block : some {A:tp} block {x:term A}.\n%worlds (term-block) (teq _ _).\n\n%{ }%\n\n% definitional equality on combs\nceq : comb A -> comb A -> type.\n\n% betas\nceq/i : ceq (capp i N) N.\nceq/k : ceq (capp (capp k N1) N2) N1.\nceq/s : ceq (capp (capp (capp s N1) N2) N3) (capp (capp N1 N3) (capp N2 N3)).\n\n% eta\nceq/ext : ceq N1 N2\n           <- ({y} ceq (capp N1 y) (capp N2 y)).\n\n% compatibility\nceq/app : ceq (capp N1 N2) (capp N1' N2')\n           <- ceq N1 N1'\n           <- ceq N2 N2'.\n\n% equivalence\nceq/refl : ceq N N.\n\nceq/symm : ceq N N'\n            <- ceq N' N.\n\nceq/trans : ceq N N''\n             <- ceq N' N''\n             <- ceq N N'.\n\n%abbrev ;; : ceq N N' -> ceq N' N'' -> ceq N N'' = [d1] [d2] ceq/trans d1 d2.\n%infix right 5 ;;.\n\n%block comb-block : some {A:tp} block {y:comb A}.\n%worlds (comb-block) (ceq _ _).\n\n%{\n\n== Translation ==\n\n}%\n\n%{\n\nWe can now define a compositional translation from lambda terms to combinator\nterms in the standard way.  The translation appeals to a function called\n''bracket abstraction'' which simulates binding in the combinator calculus.\n\nBracket abstraction is usually written <math>[x] N</math> where <math>N</math>\nis a combinator term, and <math>x</math> is a variable potentially free in\n<math>N</math>.  (Be careful not to confuse these brackets with Twelf's syntax\nfor lambda abstraction.)  It is defined inductively over the term\n<math>N</math>:\n\n<blockquote>\n<math>[x]</math> <math>x = I</math><br>\n<math>[x]</math> <math>N = K</math> <math>N</math>\n    (where <math>x</math> not free in <math>N</math>)<br>\n<math>[x]</math> <math>N_1</math> <math>N_2 =\n    S</math> <math>([x]</math> <math>N_1)</math>\n             <math>([x]</math> <math>N_2)</math><br>\n</blockquote>\n\nUsing it, we can define a translation on lambda-terms, <math>M^*</math>, where\n<math>M</math> is a lambda-term, as follows:\n\n<blockquote>\n<math>x^* = x</math><br>\n<math>(M_1</math> <math>M_2)^*</math> =\n    <math>M_1^*</math> <math>M_2^*</math><br>\n<math>(\\lambda x.</math> <math>M)^* = [x]</math> <math>M^*</math>\n</blockquote>\n\nNote that in the definition of bracket abstraction, we need not consider a\ncase for lambda-abstraction since bracket abstraction works over combinator\nterms, in which lambda-abstraction has already been eliminated.\n\nThe main translation is represented in LF by a judgement (an LF type family)\n<tt>translate M N</tt>.  Bracket abstraction is represented by a judgement\nrelating LF-level abstractions in the combinator language to closed combinator\nterms, <tt>bracket ([x] N x) N</tt>.  This definition is essentially an\ninstance of [[higher-order abstract syntax]].\n\n}%\n\ntranslate : term A -> comb A -> type.\n%mode translate +M -N.\n%name translate Dtrans dtrans.\n\nbracket : (comb A -> comb B) -> comb (A => B) -> type.\n%mode bracket +N -N*.\n%name bracket Dbrack dbrack.\n\n\nt/app : translate (app M1 M2) (capp N1 N2)\n         <- translate M1 N1\n         <- translate M2 N2.\n\n%{\n\nThe translation on lambda-abstractions has to work under an extended context\nwith a lambda-term variable, a combinator-term variable, and an assumption\nthat the one translates to the other.  See the <tt>%worlds</tt> declaration\nbelow.  (The block <tt>trans-block</tt> will form the basis of later blocks.)\n\n}%\nt/lam : translate (lam [x] M x) N*\n         <- ({x:term A} {y:comb A} translate x y -> translate (M x) (N y))\n         <- bracket ([y] N y) N*.\n\n\nb/i : bracket ([y] y) i.\n\nb/k : bracket ([y] N) (capp k N).\n\nb/s : bracket ([y] capp (N1 y) (N2 y)) (capp (capp s N1*) N2*)\n       <- bracket ([y] N1 y) N1*\n       <- bracket ([y] N2 y) N2*.\n\n\n%block trans-block\n            : some {A:tp}\n              block {x:term A} {y:comb A} {dtrans: translate x y}.\n\n%worlds (trans-block) (bracket _ _).\n%worlds (trans-block) (translate _ _).\n\n%{\n\nBoth relations are effective, though we cannot use this fact in proofs.\n\n}%\n\n%total N (bracket N _).\n%total M (translate M _).\n\n%{\n\nInstead, we need explicitly prove effectiveness lemmas.\n\n}%\n\ncan-bracket : {N : comb A -> comb B} bracket N N* -> type.\n%mode can-bracket +N -Dbrack.\n\ncan-translate : {M : term A} translate M N -> type.\n%mode can-translate +M -Dtrans.\n\n- : can-bracket ([x] x) b/i.\n- : can-bracket ([x] N) b/k.\n- : can-bracket ([x] capp (N1 x) (N2 x)) (b/s Dbrack2 Dbrack1)\n     <- can-bracket ([x] N1 x) Dbrack1\n     <- can-bracket ([x] N2 x) Dbrack2.\n\n- : can-translate (app M1 M2) (t/app Dtrans2 Dtrans1)\n     <- can-translate M1 (Dtrans1 : translate M1 N1)\n     <- can-translate M2 (Dtrans2 : translate M2 N2).\n\n- : can-translate (lam [x] M x) (t/lam Dbrack Dtrans)\n     <- ({x} {y} {dtrans: translate x y} {thm: can-translate x dtrans}\n            can-translate (M x) (Dtrans x y dtrans : translate (M x) (N y)))\n     <- can-bracket ([y] N y) (Dbrack : bracket ([y] N y) N*).\n\n%block can-block\n            : some {A:tp}\n              block {x:term A} {y:comb A} {dtrans: translate x y}\n                    {thm: can-translate x dtrans}.\n\n%worlds (can-block) (can-bracket _ _).\n%total N (can-bracket N _).\n\n%worlds (can-block) (can-translate _ _).\n%total M (can-translate M _).\n\n\n%{\n\n== Correctness of the translation ==\n\n}%\n\n%{\n\nFirst, we prove the correctness of bracket abstraction itself: the\napplication of a bracket abstraction is equivalent to a substitution.\n\n}%\n\nsubst : bracket ([x] N x) N* -> {N0} ceq (capp N* N0) (N N0) -> type.\n%mode subst +B +X -CS.\n\n- : subst (b/i : bracket ([x] x) i)\n          N0\n          (ceq/i : ceq (i @@ N0) N0).\n\n- : subst (b/k : bracket ([x] Y) (k @@ Y))\n          N0\n          (ceq/k : ceq (k @@ Y @@ N0) Y).\n\n% developing incrementally, it's useful to write down the type of each output\n- : subst (b/s (B2 : bracket ([x] N2 x) N2')\n               (B1 : bracket ([x] N1 x) N1')\n            : bracket ([x] N1 x @@ N2 x) (s @@ N1' @@ N2'))\n          N0\n          (ceq/trans\n              (ceq/s\n                : ceq (s @@ N1' @@ N2' @@ N0) ((N1' @@ N0) @@ (N2' @@ N0)))\n              (ceq/app Dceq2 Dceq1\n                : ceq ((N1' @@ N0) @@ (N2' @@ N0)) (N1 N0 @@ N2 N0)))\n     <- subst B1 N0 (Dceq1 : ceq (N1' @@ N0) (N1 N0))\n     <- subst B2 N0 (Dceq2 : ceq (N2' @@ N0) (N2 N0)).\n\n%worlds (comb-block) (subst _ _ _).\n%total {B} (subst B _ _).\n\n\n%{\n\nNext, we need to know that the translation of a term is unique up to\nequivalence.\n\n}%\n\ntranslate-unique : translate M N -> translate M N' -> ceq N N' -> type.\n%mode translate-unique +Dt1 +Dt2 -Deq.\n\n- : translate-unique\n        (t/app (Dtrans2 : translate M2 N2)\n               (Dtrans1 : translate M1 N1)\n          : translate (M1 @ M2) (N1 @@ N2))\n        (t/app (Dtrans2' : translate M2 N2')\n               (Dtrans1' : translate M1 N1')\n          : translate (M1 @ M2) (N1' @@ N2'))\n        (ceq/app Dceq2 Dceq1)\n     <- translate-unique Dtrans1 Dtrans1' (Dceq1 : ceq N1 N1')\n     <- translate-unique Dtrans2 Dtrans2' (Dceq2 : ceq N2 N2').\n\n- : translate-unique\n        (t/lam (Dbrack : bracket ([y] N y) N*)\n               ([x] [y] [dtrans] Dtrans x y dtrans : translate (M x) (N y))\n          : translate (lam [x] M x) N*)\n        (t/lam (Dbrack' : bracket ([y] N' y) N'*)\n               ([x] [y] [dtrans] Dtrans' x y dtrans : translate (M x) (N' y))\n          : translate (lam [x] M x) N'*)\n        (ceq/ext ([y] (Dceq y : ceq (N* @@ y) (N y)) ;;\n                      (Dceqtrans y : ceq (N y) (N' y)) ;;\n                      (ceq/symm (Dceq' y) : ceq (N' y) (N'* @@ y))\n                   : ceq (N* @@ y) (N'* @@ y))\n          : ceq N* N'*)\n     <- ({x} {y} {dtrans: translate x y}\n         {thm-unique: translate-unique dtrans dtrans ceq/refl}\n            translate-unique (Dtrans x y dtrans) (Dtrans' x y dtrans)\n            (Dceqtrans y : ceq (N y) (N' y)))\n     <- ({z} subst Dbrack z (Dceq z : ceq (N* @@ z) (N z)))\n     <- ({z} subst Dbrack' z (Dceq' z : ceq (N'* @@ z) (N' z))).\n\n%block unique-block\n            : some {A:tp}\n              block {x:term A} {y:comb A} {dtrans: translate x y}\n                    {thm: translate-unique dtrans dtrans ceq/refl}.\n\n%worlds (unique-block) (translate-unique _ _ _).\n%total D (translate-unique D _ _).\n\n\n%{\n\nThen, we can prove simulation, the correctness of translation, by a\nstraightforward induction on equality derivations in the lambda-calculus,\nusing the correctness of bracket abstraction as a lemma in the case of a\nbeta-reduction.\n\n}%\n\nsimulate : translate M N -> translate M' N' -> teq M M' -> ceq N N' -> type.\n%mode simulate +Dt +Dt' +Deq -Dceq.\n\n- : simulate (t/app (Dtrans2 : translate M2 N2)\n                    (t/lam\n                        (Dbrack : bracket ([y] N1 y) N1*)\n                        % XXX mysteriously necessary type annotations\n                        ([x:term A2] [y:comb A2] [dtrans:translate x y]\n                            Dtrans1 x y dtrans\n                          : translate (M1 x) (N1 y)))\n               : translate (app (lam [x] M1 x) M2) (capp N1* N2))\n             (Dtrans3\n               : translate (M1 M2) N3)\n             (eq/beta\n               : teq (app (lam [x] M1 x) M2) (M1 M2))\n             (Dceq ;; Dceq3\n               : ceq (capp N1* N2) N3)\n     <- subst Dbrack N2 (Dceq : ceq (capp N1* N2) (N1 N2))\n     <- translate-unique (Dtrans1 M2 N2 Dtrans2) Dtrans3\n                         (Dceq3 : ceq (N1 N2) N3).\n\n- : simulate (Dtrans1 : translate M1 N1)\n             (Dtrans2 : translate M2 N2)\n             (eq/ext ([x] Deq x : teq (app M1 x) (app M2 x))\n               : teq M1 M2)\n             (ceq/ext ([y] Dceq y) : ceq N1 N2)\n     <- ({x} {y} {dtrans: translate x y}\n         {thm-can: can-translate x dtrans}\n         {thm-unique: translate-unique dtrans dtrans ceq/refl}\n            simulate (t/app dtrans Dtrans1 : translate (app M1 x) (capp N1 y))\n                     (t/app dtrans Dtrans2 : translate (app M2 x) (capp N2 y))\n                     (Deq x : teq (app M1 x) (app M2 x))\n                     (Dceq y : ceq (capp N1 y) (capp N2 y))).\n\n- : simulate (t/lam (Dbrack : bracket ([y] N y) N*)\n                    ([x] [y] [dtrans: translate x y] Dtrans x y dtrans\n                      : translate (M x) (N y))\n               : translate (lam [x] M x) N*)\n             (t/lam (Dbrack' : bracket ([y] N' y) N*')\n                    ([x] [y] [dtrans: translate x y] Dtrans' x y dtrans\n                      : translate (M' x) (N' y))\n               : translate (lam [x] M' x) N*')\n             (eq/lam ([x] Deq x : teq (M x) (M' x))\n               : teq (lam [x] M x) (lam [x] M' x))\n             (ceq/ext ([y] (Dceq* y : ceq (N* @@ y) (N y)) ;;\n                           (Dceq y : ceq (N y) (N' y)) ;;\n                           (ceq/symm (Dceq*' y) : ceq (N' y) (N*' @@ y)))\n               : ceq N* N*')\n     <- ({x} {y} {dtrans: translate x y}\n         {thm-can: can-translate x dtrans}\n         {thm-unique: translate-unique dtrans dtrans ceq/refl}\n            simulate (Dtrans x y dtrans : translate (M x) (N y))\n                     (Dtrans' x y dtrans : translate (M' x) (N' y))\n                     (Deq x : teq (M x) (M' x))\n                     (Dceq y : ceq (N y) (N' y)))\n     <- ({y} subst Dbrack y (Dceq* y : ceq (N* @@ y) (N y)))\n     <- ({y} subst Dbrack' y (Dceq*' y : ceq (N*' @@ y) (N' y))).\n\n- : simulate (t/app (Dtrans2 : translate M2 N2)\n                    (Dtrans1 : translate M1 N1)\n               : translate (M1 @ M2) (N1 @@ N2))\n             (t/app (Dtrans2' : translate M2' N2')\n                    (Dtrans1' : translate M1' N1')\n               : translate (M1' @ M2') (N1' @@ N2'))\n             (eq/app (Deq2 : teq M2 M2')\n                     (Deq1 : teq M1 M1')\n               : teq (M1 @ M2) (M1' @ M2'))\n             (ceq/app Dceq2 Dceq1\n               : ceq (N1 @@ N2) (N1' @@ N2'))\n     <- simulate Dtrans1 Dtrans1' Deq1 (Dceq1 : ceq N1 N1')\n     <- simulate Dtrans2 Dtrans2' Deq2 (Dceq2 : ceq N2 N2').\n\n- : simulate (Dtrans : translate M N)\n             (Dtrans' : translate M N')\n             (eq/refl : teq M M)\n             Dceq\n     <- translate-unique Dtrans Dtrans' (Dceq : ceq N N').\n\n- : simulate (Dtrans : translate M N)\n             (Dtrans' : translate M' N')\n             (eq/symm (Deq : teq M' M) : teq M M')\n             (ceq/symm Dceq : ceq N N')\n     <- simulate Dtrans' Dtrans Deq (Dceq : ceq N' N).\n\n- : simulate (Dtrans : translate M N)\n             (Dtrans'' : translate M'' N'')\n             (eq/trans (Deq1 : teq M M') (Deq2 : teq M' M'') : teq M M'')\n             (ceq/trans Dceq1 Dceq2 : ceq N N'')\n     <- can-translate M' (Dtrans' : translate M' N')\n     <- simulate Dtrans Dtrans' Deq1 (Dceq1 : ceq N N')\n     <- simulate Dtrans' Dtrans'' Deq2 (Dceq2 : ceq N' N'').\n\n%block simulate-block\n            : some {A:tp}\n              block {x:term A} {y:comb A} {dtrans: translate x y}\n                    {thm-can: can-translate x dtrans}\n                    {thm-unique: translate-unique dtrans dtrans ceq/refl}.\n\n%worlds (simulate-block) (simulate _ _ _ _).\n%total D (simulate _ _ D _).\n\n%{\n\n== Backward translation ==\n\nTo show completeness we exhibit a backward translation---called\n\"reification\"---taking combinators to lambda terms, and show that\nfor every translation, there is a reification to a term equivalent\nto the original input term.\n\nReification just replaces combinators with their definitions as\nlambda terms.\n\n}%\n\nreify : comb A -> term A -> type.       %name reify Dreify dreify.\n%mode reify +N -M.\n\nr/s : reify s (lam [x] lam [y] lam [z] x @ z @ (y @ z)).\nr/k : reify k (lam [x] lam [y] x).\nr/i : reify i (lam [x] x).\n\nr/capp : reify (N1 @@ N2) (M1 @ M2)\n          <- reify N1 M1\n          <- reify N2 M2.\n\n%{\n\nWe consider reification in any world with free variables as long as there's\na combinator variable for each lambda-term variable and an appropriate\ncorrespondence between them.\n\n}%\n\n%block reify-block\n            : some {A:tp}\n              block {x:term A} {y:comb A} {dreify: reify y x}.\n\n%worlds (reify-block) (reify _ _).\n\n%{\n\nTwelf can verify that reification is total and that the result is unique\nup to identity,\n\n}%\n\n%total N (reify N _).\n%unique reify +N -M.\n\n%{\n\nbut in order to use these facts in other metatheorems, we must prove them\nourselves.\n\nThe theorem <tt>can-reify</tt> shows the effectiveness of reification by\nconstructing a <tt>reify</tt> derivation for any given combinator <tt>N</tt>.\n\n}%\n\ncan-reify : {N : comb A} reify N M -> type.\n%mode can-reify +N -Dreify.\n\n- : can-reify s r/s.\n- : can-reify k r/k.\n- : can-reify i r/i.\n- : can-reify (capp N1 N2) (r/capp Dreify2 Dreify1)\n     <- can-reify N1 Dreify1\n     <- can-reify N2 Dreify2.\n\n%{\n\nNote the use of a ''theorem case'' in the block for <tt>can-reify</tt>:\nsince we prove reification with respect to an open world, we have to include\nproofs for the free variable cases.\n\n}%\n\n%block can-reify-block\n            : some {A:tp}\n              block {x:term A} {y:comb A} {dreify: reify y x}\n                    {thm: can-reify y dreify}.\n\n%worlds (can-reify-block) (can-reify _ _).\n%total N (can-reify N _).\n\n%{\n\nThe theorem <tt>reify-unique</tt> shows the uniqueness of reification.\nFor convenience, we demonstrate only that reifications are unique up to\nterm equivalence.\n\n}%\n\nreify-unique : reify N M -> reify N M' -> teq M M' -> type.\n%mode reify-unique +Dreify1 +Dreify2 -Deq.\n\n- : reify-unique r/i r/i eq/refl.\n- : reify-unique r/k r/k eq/refl.\n- : reify-unique r/s r/s eq/refl.\n- : reify-unique (r/capp Dreify2 Dreify1)\n                 (r/capp Dreify2' Dreify1')\n                 (eq/app Deq2 Deq1)\n     <- reify-unique Dreify1 Dreify1' Deq1\n     <- reify-unique Dreify2 Dreify2' Deq2.\n\n%block reify-unique-block\n            : some {A:tp}\n              block {x:term A} {y:comb A} {dreify: reify y x}\n                    {thm: reify-unique dreify dreify eq/refl}.\n\n%worlds (reify-unique-block) (reify-unique _ _ _).\n%total D (reify-unique D _ _).\n\n\n%{\n\nThe reification of a closed combinator term is a closed lambda-term, but\nwe require the following strengthening lemma to show that this is the case.\n\n}%\n\nstrengthen-reify : ({x} {y} reify y x -> reify N (M! x))\n                    %%\n                    -> reify N M\n                    -> ({x} teq M (M! x))\n                    -> type.\n%mode strengthen-reify +Dreify! -Dreify -Deq.\n\n- : strengthen-reify ([x] [y] [dreify: reify y x] r/s) r/s ([x] eq/refl).\n- : strengthen-reify ([x] [y] [dreify: reify y x] r/k) r/k ([x] eq/refl).\n- : strengthen-reify ([x] [y] [dreify: reify y x] r/i) r/i ([x] eq/refl).\n\n- : strengthen-reify ([x] [y] [dreify: reify y x]\n                         r/capp (Dreify2! x y dreify : reify N2 (M2! x))\n                                (Dreify1! x y dreify : reify N1 (M1! x))\n                       : reify (N1 @@ N2) ((M1! x) @ (M2! x)))\n                     (r/capp Dreify2 Dreify1)\n                     ([x] eq/app (Deq2 x) (Deq1 x))\n     <- strengthen-reify ([x] [y] [dreify] Dreify1! x y dreify)\n                         (Dreify1 : reify N1 M1)\n                         ([x] Deq1 x : teq M1 (M1! x))\n     <- strengthen-reify ([x] [y] [dreify] Dreify2! x y dreify)\n                         (Dreify2 : reify N2 M2)\n                         ([x] Deq2 x : teq M2 (M2! x)).\n\n%block strengthen-reify-block\n            : some {A:tp}\n              block {x:term A} {y:comb A} {dreify: reify y x}\n                    {thm: {B:tp} strengthen-reify\n                                   ([x1:term B] [y1:comb B] [dreify1] dreify)\n                                   dreify\n                                   ([x1] eq/refl)}.\n\n%worlds (strengthen-reify-block) (strengthen-reify _ _ _).\n%total D (strengthen-reify D _ _).\n\n\n%{\n\n== Correctness of the backward translation ==\n\nOur main technique for showing completeness is to show that every translation\nof <tt>M</tt> has a reification to an equivalent <tt>M'</tt>.  First, we show\nthe following lemma, which says that bracket abstractions reify to lambda\nabstractions.\n\n}%\n\nbracket-reify : bracket ([y] N y) N*\n                 -> ({x} {y} reify y x -> reify (N y) (M x))\n                 %%\n                 -> reify N* M*\n                 -> teq M* (lam [x] M x)\n                 -> type.\n%mode bracket-reify +Dbrack +Dreify -Dreify* -Deq*.\n\n- : bracket-reify (b/i : bracket ([y] y) i)\n                  ([x] [y] [dreify: reify y x] dreify)\n                  (r/i : reify i (lam [x] x))\n                  (eq/refl : teq (lam [x] x) (lam [x] x)).\n\n%{\n\nIn the case where bracket abstraction returns an application of the K\ncombinator to a closed term, we require our strengthening lemma to show\nthat the result of reification is also closed.\n\n}%\n\n- : bracket-reify (b/k : bracket ([y] N) (k @@ N))\n                  ([x] [y] [dreify: reify y x]\n                      Dreify! x y dreify : reify N (M! x))\n                  (r/capp Dreify r/k\n                    : reify (k @@ N) ((lam [x] lam [y] x) @ M))\n                  (eq/beta ; eq/lam ([x] Deq x)\n                    : teq ((lam [x] lam [y] x) @ M) (lam [y] M! y))\n     <- strengthen-reify\n            ([x] [y] [dreify: reify y x] Dreify! x y dreify)\n            (Dreify : reify N M)\n            ([x] Deq x : teq M (M! x)).\n\n%{\n\nThe case for reifying an application of the S combinator is tedious, but\nstraightforward.\n\n}%\n\n- : bracket-reify (b/s (Dbrack2 : bracket ([y] N2 y) N2*)\n                       (Dbrack1 : bracket ([y] N1 y) N1*)\n                    : bracket ([y] (N1 y) @@ (N2 y)) (s @@ N1* @@ N2*))\n                  ([x] [y] [dreify: reify y x]\n                      r/capp (Dreify2 x y dreify : reify (N2 y) (M2 x))\n                             (Dreify1 x y dreify : reify (N1 y) (M1 x))\n                       : reify ((N1 y) @@ (N2 y)) ((M1 x) @ (M2 x)))\n                  (r/capp (Dreify2* : reify N2* M2*)\n                    (r/capp (Dreify1* : reify N1* M1*)\n                            (r/s))\n                    : reify (s @@ N1* @@ N2*)\n                            ( (lam [x] lam [y] lam [z] x @ z @ (y @ z))\n                              @ M1* @ M2*) )\n                  (% reduce first redex\n                   eq/app\n                      (eq/refl : teq M2* M2*)\n                      eq/beta\n                    ;\n                   % reduce second redex\n                   eq/beta\n                    ;\n                   % descend under lambda\n                   eq/lam ([x] eq/app\n                                (eq/app (eq/refl : teq x x) Deq2* ; eq/beta\n                                  : teq (M2* @ x) (M2 x))\n                                (eq/app (eq/refl : teq x x) Deq1* ; eq/beta\n                                  : teq (M1* @ x) (M1 x)))\n                    : teq ( (lam[x] lam[y] lam[z] x @ z @ (y @ z)) @ M1* @ M2* )\n                          (lam [z] (M1 z) @ (M2 z)))\n     <- bracket-reify Dbrack1 ([x] [y] [dreify: reify y x] Dreify1 x y dreify)\n            (Dreify1* : reify N1* M1*)\n            (Deq1* : teq M1* (lam [z] M1 z))\n     <- bracket-reify Dbrack2 ([x] [y] [dreify: reify y x] Dreify2 x y dreify)\n            (Dreify2* : reify N2* M2*)\n            (Deq2* : teq M2* (lam [z] M2 z)).\n\n%worlds (strengthen-reify-block) (bracket-reify _ _ _ _).\n%total D (bracket-reify D _ _ _).\n\n%{\n\nNow we can prove that every translation reifies to an equivalent term,\nappealing to the above bracket abstraction lemma in the <tt>lam</tt> case.\n\n}%\n\ntranslate-reify : translate M N -> reify N M' -> teq M M' -> type.\n%mode translate-reify +Dt -Dr -Deq.\n\n- : translate-reify\n        (t/app (Dtrans2 : translate M2 N2)\n               (Dtrans1 : translate M1 N1)\n          : translate (M1 @ M2) (N1 @@ N2))\n        (r/capp (Dreify2 : reify N2 M2')\n                (Dreify1 : reify N1 M1')\n          : reify (N1 @@ N2) (M1' @ M2'))\n        (eq/app Deq2 Deq1\n          : teq (M1 @ M2) (M1' @ M2'))\n     <- translate-reify Dtrans1 Dreify1 (Deq1 : teq M1 M1')\n     <- translate-reify Dtrans2 Dreify2 (Deq2 : teq M2 M2').\n\n- : translate-reify\n        (t/lam (Dbrack : bracket ([y] N y) N*)\n               ([x] [y] [dtrans: translate x y]\n                   Dtrans x y dtrans : translate (M x) (N y))\n          : translate (lam [x] M x) N*)\n        (Dreify* : reify N* M*)\n        (eq/lam ([x] Deq x) ; eq/symm Deq*\n          : teq (lam [x] M x) M*)\n     <- ({x} {y} {dtrans: translate x y} {dreify: reify y x}\n         {thm-closed: {B} strengthen-reify\n                            ([x1:term B] [y1:comb B] [dreify1] dreify)\n                            dreify\n                            ([x1] eq/refl)}\n         {thm-translate: translate-reify dtrans dreify eq/refl}\n            translate-reify\n            (Dtrans x y dtrans)\n            (Dreify x y dreify : reify (N y) (M0 x))\n            (Deq x : teq (M x) (M0 x)))\n     <- bracket-reify\n            Dbrack\n            ([x] [y] [dreify] Dreify x y dreify)\n            (Dreify* : reify N* M*)\n            (Deq* : teq M* (lam [x] M0 x)).\n\n%block translate-reify-block\n            : some {A:tp}\n              block {x:term A} {y:comb A}\n                    {dtrans: translate x y} {dreify: reify y x}\n                    {thm-closed: {B:tp}\n                                 strengthen-reify\n                                   ([x1:term B] [y1:comb B] [dreify1] dreify)\n                                   dreify\n                                   ([x1] eq/refl)}\n                    {thm-translate: translate-reify dtrans dreify eq/refl}.\n\n%worlds (translate-reify-block) (translate-reify _ _ _).\n%total D (translate-reify D _ _).\n\n\n%{\n\nNext, we prove a theorem similar to our earlier <tt>simulate</tt> theorem,\nbut for reification: given two reification derivations from equivalent inputs,\ntheir outputs are equivalent.\n\n}%\n\nreify-simulate : reify N M -> reify N' M' -> ceq N N' -> teq M M' -> type.\n%mode reify-simulate +Dreify +Dreify' +Dceq -Deq.\n\n- : reify-simulate (r/capp (Dreify : reify N M) r/i\n                     : reify (i @@ N) ((lam [x] x) @ M))\n                   (Dreify' : reify N M')\n                   (ceq/i : ceq (i @@ N) N)\n                   (eq/beta ; Deq : teq ((lam [x] x) @ M) M')\n     <- reify-unique Dreify Dreify' (Deq : teq M M').\n\n- : reify-simulate (r/capp (Dreify2 : reify N2 M2)\n                      (r/capp (Dreify1 : reify N1 M1)\n                               r/k)\n                     : reify (k @@ N1 @@ N2) ((lam [x] lam [y] x) @ M1 @ M2))\n                   (Dreify' : reify N1 M')\n                   (ceq/k : ceq (k @@ N1 @@ N2) N1)\n                   (eq/app eq/refl eq/beta ; eq/beta ; Deq\n                     : teq ((lam [x] lam [y] x) @ M1 @ M2) M')\n     <- reify-unique Dreify1 Dreify' (Deq : teq M1 M').\n\n- : reify-simulate (r/capp (Dreify3 : reify N3 M3)\n                      (r/capp (Dreify2 : reify N2 M2)\n                      (r/capp (Dreify1 : reify N1 M1)\n                      r/s))\n                     : reify (s @@ N1 @@ N2 @@ N3)\n                             ( (lam [x] lam [y] lam [z] x @ z @ (y @ z))\n                               @ M1 @ M2 @ M3 ))\n                   (r/capp\n                       (r/capp (Dreify3' : reify N3 M3')\n                               (Dreify2' : reify N2 M2'))\n                       (r/capp (Dreify3'' : reify N3 M3'')\n                               (Dreify1' : reify N1 M1'))\n                     : reify (N1 @@ N3 @@ (N2 @@ N3)) (M1' @ M3'' @ (M2' @ M3')))\n                   (ceq/s : ceq (s @@ N1 @@ N2 @@ N3) (N1 @@ N3 @@ (N2 @@ N3)))\n                   (eq/app eq/refl (eq/app eq/refl eq/beta) ;\n                    eq/app eq/refl eq/beta ;\n                    eq/beta ;\n                    eq/app (eq/app Deq3 Deq2)\n                           (eq/app Deq3' Deq1)\n                     : teq ( (lam [x] lam [y] lam [z] x @ z @ (y @ z))\n                             @ M1 @ M2 @ M3 )\n                           (M1' @ M3'' @ (M2' @ M3')))\n     <- reify-unique Dreify1 Dreify1' (Deq1 : teq M1 M1')\n     <- reify-unique Dreify2 Dreify2' (Deq2 : teq M2 M2')\n     <- reify-unique Dreify3 Dreify3' (Deq3 : teq M3 M3')\n     <- reify-unique Dreify3 Dreify3'' (Deq3' : teq M3 M3'').\n\n- : reify-simulate (Dreify1 : reify N1 M1)\n                   (Dreify2 : reify N2 M2)\n                   (ceq/ext ([y] Dceq y : ceq (N1 @@ y) (N2 @@ y))\n                     : ceq N1 N2)\n                   (eq/ext ([x] Deq x : teq (M1 @ x) (M2 @ x))\n                     : teq M1 M2)\n     <- ({x} {y} {dreify: reify y x}\n         {thm-can: can-reify y dreify}\n         {thm-unique: reify-unique dreify dreify eq/refl}\n            reify-simulate\n                (r/capp dreify Dreify1 : reify (N1 @@ y) (M1 @ x))\n                (r/capp dreify Dreify2 : reify (N2 @@ y) (M2 @ x))\n                (Dceq y)\n                (Deq x : teq (M1 @ x) (M2 @ x))).\n\n- : reify-simulate (r/capp (Dreify2 : reify N2 M2)\n                           (Dreify1 : reify N1 M1)\n                     : reify (N1 @@ N2) (M1 @ M2))\n                   (r/capp (Dreify2' : reify N2' M2')\n                           (Dreify1' : reify N1' M1')\n                     : reify (N1' @@ N2') (M1' @ M2'))\n                   (ceq/app (Dceq2 : ceq N2 N2')\n                            (Dceq1 : ceq N1 N1')\n                     : ceq (N1 @@ N2) (N1' @@ N2'))\n                   (eq/app Deq2 Deq1\n                     : teq (M1 @ M2) (M1' @ M2'))\n     <- reify-simulate Dreify1 Dreify1' Dceq1 (Deq1 : teq M1 M1')\n     <- reify-simulate Dreify2 Dreify2' Dceq2 (Deq2 : teq M2 M2').\n\n- : reify-simulate (Dreify : reify N M)\n                   (Dreify' : reify N M')\n                   (ceq/refl : ceq N N)\n                   (Deq : teq M M')\n     <- reify-unique Dreify Dreify' (Deq : teq M M').\n\n- : reify-simulate (Dreify : reify N M)\n                   (Dreify' : reify N' M')\n                   (ceq/symm (Dceq : ceq N' N) : ceq N N')\n                   (eq/symm Deq : teq M M')\n     <- reify-simulate Dreify' Dreify Dceq (Deq : teq M' M).\n\n- : reify-simulate (Dreify : reify N M)\n                   (Dreify'' : reify N'' M'')\n                   (ceq/trans (Dceq1 : ceq N N') (Dceq2 : ceq N' N'')\n                     : ceq N N'')\n                   (eq/trans Deq1 Deq2\n                     : teq M M'')\n     <- can-reify N' (Dreify' : reify N' M')\n     <- reify-simulate Dreify Dreify' Dceq1 (Deq1 : teq M M')\n     <- reify-simulate Dreify' Dreify'' Dceq2 (Deq2 : teq M' M'').\n\n%block reify-simulate-block\n            : some {A:tp}\n              block {x:term A} {y:comb A} {dreify: reify y x}\n                    {thm-can: can-reify y dreify}\n                    {thm-unique: reify-unique dreify dreify eq/refl}.\n\n%worlds (reify-simulate-block) (reify-simulate _ _ _ _).\n%total D (reify-simulate _ _ D _).\n\n%{\n\nFinally, we can now prove the translation complete: every combinator\nequivalence hit by the translation comes from a lambda-calculus equivalence.\n\nGiven two translations, we get reifications for both.  By the above simulation\ntheorem, we show that the reifications must be equal.  Then the desired result\nfollows by transitivity.\n\n}%\n\ncomplete : translate M N -> translate M' N' -> ceq N N' -> teq M M' -> type.\n%mode complete +Dtrans +Dtrans' +Dceq -Deq.\n\n- : complete (Dtrans : translate M N)\n             (Dtrans' : translate M' N')\n             (Dceq : ceq N N')\n             (Deq ; Deq0 ; eq/symm Deq' : teq M M')\n     <- translate-reify Dtrans (Dreify : reify N M0) (Deq : teq M M0)\n     <- translate-reify Dtrans' (Dreify' : reify N' M0') (Deq' : teq M' M0')\n     <- reify-simulate Dreify Dreify' Dceq (Deq0 : teq M0 M0').\n\n%{\n\nWe can also make a copy of <tt>simulate</tt> called <tt>sound</tt>, in order\nto be able check it in the same world as <tt>complete</tt>.\n\n}%\n\nsound : translate M N -> translate M' N' -> teq M M' -> ceq N N' -> type.\n%mode sound +Dtrans +Dtrans' +Deq -Dceq.\n\n- : sound (Dtrans : translate M N)\n          (Dtrans' : translate M' N')\n          (Deq : teq M M')\n          Dceq\n     <- simulate Dtrans Dtrans' Deq (Dceq : ceq N N').\n\n%{\n\nWe can make a master-block in which each of soundness and completeness hold.\nTerms under translation can have any free variables x, as long as they are\nmatched by free combinator variables y such that x translates to y and y\nreifies to x.  The other variables in the block are theorem cases relating to\nthese new translation and reification assumptions.\n\nNote that for world subsumption to work correctly, it was necessary to always\nstate x and y in the same order, even in the reification theorems.\n\n}%\n\n%block master-block\n            : some {A:tp}\n              block {x:term A} {y:comb A}\n                    {dtrans: translate x y}\n                      {thm-can-tr: can-translate x dtrans}\n                      {thm-tr-unique: translate-unique dtrans dtrans ceq/refl}\n                    {dreify: reify y x}\n                      {thm-can-re: can-reify y dreify}\n                      {thm-re-unique: reify-unique dreify dreify eq/refl}\n                      {thm-re-closed: {B:tp}\n                                 strengthen-reify\n                                   ([x1:term B] [y1:comb B] [dreify1] dreify)\n                                   dreify\n                                   ([x1] eq/refl)}\n                      {thm-tr-re: translate-reify dtrans dreify eq/refl}.\n\n%worlds (master-block) (complete _ _ _ _).\n%total {} (complete _ _ _ _).\n\n%worlds (master-block) (sound _ _ _ _).\n%total {} (sound _ _ _ _)."
          },
          "sha1": "2ptzybpivjzqctww8d7uk6p98ov53py"
        }
      },
      {
        "title": "Unary numbers",
        "ns": 0,
        "id": 1820,
        "redirect": {
          "@title": "Natural numbers",
          "#text": null
        },
        "revision": {
          "id": 3407,
          "parentid": 3406,
          "timestamp": "2006-12-28T04:35:00Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "minor": null,
          "comment": "oops",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 29,
            "#text": "#REDIRECT [[Natural numbers]]"
          },
          "sha1": "891nkk3135gx2pv61m8xpbeuzuilqeh"
        }
      },
      {
        "title": "Unification",
        "ns": 0,
        "id": 1972,
        "revision": {
          "id": 4514,
          "timestamp": "2007-03-21T00:30:33Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "comment": "New page: '''Unification''' is an algorithm for comparing terms with holes (called '''unification variables''') for equality, discovering substitutions for the unification variables which make those...",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 907,
            "#text": "'''Unification''' is an algorithm for comparing terms with holes (called '''unification variables''') for equality, discovering substitutions for the unification variables which make those terms equal.  Unification of LF terms is used in a variety of ways in Twelf:\n# During type and term reconstruction, unification is used to infer omitted type and term information.\n# In the [[logic programming]] operational semantics of LF, unification is used to find solutions to unification variables in queries.\n\nUnification for LF terms requires higher-order unification, which is undecidable.  However, many instances of unification that arise in Twelf fall into the '''pattern fragment''', which is decidable.  Those that are not in the pattern fragment are postponed as '''constraints'''; unresolved constraints are reported to the user.\n\n{{needs|examples of \"unresolved constrants\" error messages.}}\n\n\n{{stub}}"
          },
          "sha1": "9zyou2p9uhwmia2z0n4ibm0pm1krkx5"
        }
      },
      {
        "title": "Uniqueness lemma",
        "ns": 0,
        "id": 1478,
        "revision": {
          "id": 6120,
          "parentid": 5955,
          "timestamp": "2010-09-02T12:33:27Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 10718,
            "#text": "Many judgements of an object language have the property that, given some subjects of the judgement, the other subjects are determined uniquely.  For example: The [[Proving metatheorems:Representing the judgements of the natural numbers|addition judgement]] on natural numbers has the property that the two addends determine the sum uniquely.  A typing judgement for a programming language may have the property that a term has at most one type.  The operational semantics of a programming language may have the property that a term steps to at most one other term.  We refer to a metatheorem that establishes such a property a '''uniqueness lemma'''.  \n\nThe goal of this article is to teach you how to prove uniqueness lemmas in Twelf.  The only subtlety is that the statement of a uniqueness lemma requires an auxiliary definition of a judgement defining equality at the relevant types.  \n\nIn this article, we refer to the \"given\" subjects of the judgement as ''inputs'' and those subjects that are determined uniquely by the givens as ''outputs''.  However, these inputs and outputs do not need to correspond with the <tt>[[%mode]]</tt> of the judgement: it is meaningful to prove a uniqueness lemma for a judgement that has no mode specified in Twelf.  Note that a judgement may satisfy a uniqueness lemma but not define a function: uniqueness says that the outputs are uniquely determined if they exist at all.  To know that a judgement defines a function, it is necessary to prove a corresponding [[effectiveness lemma]] establishing that some instance of the judgement holds for each input.  \n\nSometimes a uniqueness lemma can be proven trivially by leveraging a <tt>[[%unique]]</tt> declaration. \n\n== Example: Flipping bits ==\n\nThe following is a simple example of a uniqueness lemma. First we define bits and a simple relation <tt>bit-flip</tt> that negates a bit.\n\n<twelf>\nbit : type.\n\nbit/0 : bit.\nbit/1 : bit.\n\nbit-flip : bit -> bit -> type.\n\nbit-flip/01 : bit-flip bit/0 bit/1.\nbit-flip/10 : bit-flip bit/1 bit/0.\n</twelf>\n\nWe would like to prove that the second argument of <tt>bit-flip</tt> is determined uniquely by the first.  How do we state this theorem?  We assume two derivations of <tt>bit-flip</tt> for the same input that seem to have distinct outputs and we prove that the outputs are the same:  \n\n: If <tt>D : bit-flip B1 B2</tt> and <tt>D' : bit-flip B1 B2'</tt> then <tt>B2 = B2'</tt>.\n\nThe only subtlety in proving this theorem in Twelf is that we need a judgement representing the equality used in the conclusion.  If the output of the judgement is in fact unique (rather than unique modulo some equivalence relation), then the best judgement to use is the [[identity]] relation at the appropriate type:\n\n<twelf>\nid-bit : bit -> bit -> type.\nid-bit/refl : id-bit B B.\n</twelf>\n\nIdentity internalizes syntactic equality of canonical forms as a judgement: <tt>id B B'</tt> is inhabited only when <tt>B</tt> an <tt>B'</tt> are the same LF term.  \n\nThus, we can prove the theorem by exhibiting the following total relation:\n<twelf check=\"true\" export=\"alt\">\nbit-flip-unique : bit-flip B1 B2\n               -> bit-flip B1 B2'\n               -> id-bit B2 B2'\n               -> type.\n%mode bit-flip-unique +D1 +D2 -D3.\n\n- : bit-flip-unique bit-flip/01 bit-flip/01 id-bit/refl.\n\n- : bit-flip-unique bit-flip/10 bit-flip/10 id-bit/refl.\n\n%worlds () (bit-flip-unique _ _ _).\n%total {} (bit-flip-unique _ _ _).\n</twelf>\n\n=== Alternate formulation ===\n\nUniqueness can also be expressed in a less-direct but sometimes more-convenient way that is nonetheless logically equivalent to the previous theorem.\nIn this theorem statement, we assume derivations whose ''inputs'' are related by an identity relation, and show that the outputs are identical as well.  This theorem statement applies when we have evidence that the inputs are identical but the two derivations of the judgement in question have different types.  The proof is no more complicated than the previous formulation, because when we derive the precondition <tt>id-bit B1 B1'</tt> using <tt>id-bit/refl</tt> (the only rule we could use to derive that fact), <tt>B1</tt> and <tt>B1'</tt> are forced to be identical objects, just as they were in the previous proof. \n\n<twelf check=\"true\" discard=\"true\">\nbit-flip-unique-alt : id-bit B1 B1'\n                       -> bit-flip B1 B2\n                       -> bit-flip B1' B2'\n                       -> id-bit B2 B2'\n                       -> type.\n%mode bit-flip-unique-alt +D0 +D1 +D2 -D3.\n\n- : bit-flip-unique-alt id-bit/refl bit-flip/01 bit-flip/01 id-bit/refl.\n\n- : bit-flip-unique-alt id-bit/refl bit-flip/10 bit-flip/10 id-bit/refl.\n\n%worlds () (bit-flip-unique-alt _ _ _ _).\n%total {} (bit-flip-unique-alt _ _ _ _).\n</twelf><twelf hidden=\"true\" import=\"alt\">\nbit-flip-resp : id-bit B1 B1'\n                 -> id-bit B2 B2'\n                 -> bit-flip B1 B2\n                 -> bit-flip B1' B2'\n                 -> type.\n%mode bit-flip-resp +D0 +D1 +D2 -D3.\n\n- : bit-flip-resp id-bit/refl id-bit/refl D D.\n\n%worlds () (bit-flip-resp _ _ _ _).\n%total {} (bit-flip-resp _ _ _ _).\n\nbit-flip-unique-alt : id-bit B1 B1' \n                       -> bit-flip B1 B2\n                       -> bit-flip B1' B2'\n                       -> id-bit B2 B2'\n                       -> type.\n%mode bit-flip-unique-alt +D0 +D1 +D2 -D3.\n\n- : bit-flip-unique-alt ID1 (BF: bit-flip B1 B2) (BF': bit-flip B1' B2') ID2\n     <- bit-flip-resp ID1 id-bit/refl BF (BF'': bit-flip B1' B2)\n     <- bit-flip-unique BF'' BF' (ID2: id-bit B2 B2').\n\n%worlds () (bit-flip-unique-alt _ _ _ _).\n%total {} (bit-flip-unique-alt _ _ _ _).\n</twelf>\nHowever, this alternate formulation is equivalent to the above uniqueness lemma.  It is easy to see that this lemma implies the above, as we can always call this lemma with <tt>id-bit/refl</tt>.  To prove the other direction, we can compose the above uniqueness lemma with a [[respects lemma]] showing that <tt>bit-flip</tt> respects equality.  <twelflink import=alt>Here is an example</twelflink> of proving <tt>bit-flip-unique-alt</tt> using a uniqueness lemma and a respects lemma (<twelflink import=alt check=true>here is Twelf's output</twelflink>).  Because the [[respects lemma]] will often be necessary for other reasons, it is usually preferable to prove it and the above uniqueness lemma, rather than the composed version presented here.\n\n== Bigger example: determinism of evaluation ==\n\nAs a slightly more-involved example of a uniqueness lemma, we can prove that the operational semantics of the simply typed λ-calculus are deterministic:\n\n: If <math>e \\mapsto e'</math> and <math>e \\mapsto e''</math> then <math>\\mathsf{}e' = e''</math>.\n\nHere, equality of terms means syntactic identity modulo α-equivalence\n\nThis proof reuses the formulation of the STLC from [[Proving metatheorems:Representing the syntax of the STLC|Proving metatheorems with Twelf]]; see that article for a description of the language and its operational semantics.  We recap the signature for the STLC here:\n<twelf>\n%% Syntax\ntp    : type.\n\nunit  : tp.\narrow : tp -> tp -> tp.\n\ntm    : type.\nempty : tm.\nlam   : tp -> (tm -> tm) -> tm.\napp   : tm -> tm -> tm.\n\n%% Dynamic Semantics\n\nvalue       : tm -> type.\nvalue_empty : value empty.\nvalue_lam   : value (lam T2 ([x] E x)).\n             \nstep          : tm -> tm -> type.\nstep_app_1    : step (app E1 E2) (app E1' E2)\n                 <- step E1 E1'.\nstep_app_2    : step (app E1 E2) (app E1 E2')\n                 <- step E2 E2'\n                 <- value E1.\n\nstep_app_beta : step (app (lam T2 ([x] E x)) E2) (E E2)\n                 <- value E2.\n</twelf>\n\nTo state the uniqueness lemma, we define an identity type for <tt>tm</tt>:\n\n<twelf>\nid : tm -> tm -> type.\nrefl : id E E.\n</twelf>\n\nThe judgement <tt>id</tt> represent object-language α-equivalence: α-equivalent STLC terms are represented by α-equivalent LF terms, and <tt>id E E'</tt> is inhabited exactly when <tt>E</tt> and <tt>E'</tt> are α-equivalent in LF.  \n\nThe proof of determinism requires a congruence lemma, which states that applications are equal if their subterms are:\n<twelf>\nid_app_cong : id E1 E1' \n               -> id E2 E2' \n               -> id (app E1 E2) (app E1' E2') \n               -> type.\n%mode id_app_cong +X1 +X2 -X3.\n\n- : id_app_cong refl refl refl.\n\n%worlds () (id_app_cong _ _ _).\n%total {} (id_app_cong _ _ _).\n</twelf>\n\nNext, we present a complete proof of determinism:\n<twelf check=\"true\">\ndet : step E E' -> step E E'' -> id E' E'' -> type.\n%mode det +X1 +X2 -X3.\n\ndet-1 : det (step_app_1 DstepE1') (step_app_1 DstepE1'') DidApp\n         <- det DstepE1' DstepE1'' DidE1\n         <- id_app_cong DidE1 refl DidApp.\n\ndet-2 : det (step_app_2 _ DstepE2') (step_app_2 _ DstepE2'') DidApp\n         <- det DstepE2' DstepE2'' DidE2\n         <- id_app_cong refl DidE2 DidApp.\n\ndet-b : det (step_app_beta _) (step_app_beta _) refl.\n\n%worlds () (det _ _ _).\n%total D (det D _ _).\n</twelf>\n\nObserve that the [[totality assertion]] for this type family implies the informal statement above.  \n\nThe proof consists of three cases, and in each case the two <tt>step</tt> derivations conclude with the same final rule.  The cases <tt>det-1</tt> and <tt>det-2</tt> appeal to the inductive hypothesis on the subderivations and then use the congruence lemma for identity.  The case <tt>det-b</tt> concludes equality by reflexivity because the left-hand term of <tt>step-app-beta</tt> uniquely determines the form of the right-hand term.\n\nTwelf successfully proves the totality of <tt>det</tt>, even though the relation elides the \"off-diagonal\" cases where the two <tt>step</tt> derivations do not concludes with the same final rule.  This is because the off-diagonal cases are all vacuously true---and moreover, Twelf's coverage checker\nrules out these contradictory cases automatically.  For example, if one derivation concluded with <tt>step-app-1</tt> and the other with <tt>step-app-2</tt>, then there would be subderivations concluding both <tt>value E1</tt> and <tt>step E1 E1'</tt>.  These two types can never be simultaneously inhabited: <tt>step</tt> is only inhabited when <tt>E1</tt> is an application, and there is no rule inhabiting <tt>value</tt> for an application.  Similarly, if one derivation concluded with <tt>step-app-1</tt> and the other with <tt>step-app-beta</tt>, subderivations would give a <tt>step</tt> derivation whose left-hand side is a <tt>lam</tt>, which cannot exist.  The other off-diagonal cases can be contradicted in a similar manner.  Twelf's coverage checker rules out cases like these where the inputs to a metatheorem result in an uninhabited instance of some type family.  See also: [[Reasoning from false]]\n\n{{tutorial}}"
          },
          "sha1": "8tzlvvn62w5whydq1rkbgjw1pnif3vc"
        }
      },
      {
        "title": "Uniqueness lemmas",
        "ns": 0,
        "id": 1642,
        "redirect": {
          "@title": "Uniqueness lemma",
          "#text": null
        },
        "revision": {
          "id": 2295,
          "timestamp": "2006-09-30T18:11:54Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "redir plural",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 30,
            "#text": "#REDIRECT [[Uniqueness lemma]]"
          },
          "sha1": "ge6czqe2g2wqqz4o68sk0ie3yspju7t"
        }
      },
      {
        "title": "Universal quantification",
        "ns": 0,
        "id": 1697,
        "redirect": {
          "@title": "Implicit and explicit parameters",
          "#text": null
        },
        "revision": {
          "id": 2686,
          "timestamp": "2006-10-12T05:20:39Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "Redirecting to [[Implicit and explicit parameters]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 46,
            "#text": "#REDIRECT [[Implicit and explicit parameters]]"
          },
          "sha1": "29fzo91l1eqb19n37srxe3ofqodcffg"
        }
      },
      {
        "title": "Universally quantified",
        "ns": 0,
        "id": 1835,
        "redirect": {
          "@title": "Implicit and explicit parameters",
          "#text": null
        },
        "revision": {
          "id": 3492,
          "timestamp": "2006-12-30T01:57:19Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "comment": "mimicking [[universal quantification]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 46,
            "#text": "#REDIRECT [[Implicit and explicit parameters]]"
          },
          "sha1": "29fzo91l1eqb19n37srxe3ofqodcffg"
        }
      },
      {
        "title": "Unsafe mode",
        "ns": 0,
        "id": 1828,
        "revision": {
          "id": 3448,
          "parentid": 3447,
          "timestamp": "2006-12-29T08:29:55Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 1023,
            "#text": "In order for Twelf to be useful as a theorem verifier, Twelf should not accept untrue or unproven assumptions. However, it is  sometimes helpful for the Twelf user to be able to state, and use, unproven assumptions, especially during proof development. Directives like <tt>[[%trustme]]</tt> and <tt>[[%assert]]</tt> allow the Twelf user to do just this. \n\nWhen Twelf is set to not accept any untrue or unproven assumptions, it is in '''safe mode''' (this is the default setting). In order to use directives like <tt>[[%trustme]]</tt>, Twelf must be set to '''unsafe mode.'''\n\n== Setting Twelf in unsafe mode ==\n\n* In [[Twelf with Emacs]], select the '''Twelf''' menu, then select the '''Options''' submenu, then select the '''unsafe''' menu option.\n* If using the Twelf server directly from the command line, the command <code>set unsafe true</code> will put Twelf in unsafe mode.\n* In ML Twelf, the SML command <code>Twelf.unsafe := true;</code> will put Twelf in unsafe mode. \n\n== See also ==\n\n* [[Holes in metatheorems]]"
          },
          "sha1": "ckpp7nn3mfpxokkounb1nh1m895sw4m"
        }
      },
      {
        "title": "User's Guide",
        "ns": 0,
        "id": 1463,
        "revision": {
          "id": 4534,
          "parentid": 1851,
          "timestamp": "2007-03-21T02:04:01Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "/* Undocumented features */ just link to cat rather than maintain a list in this unusual place for such a list",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 642,
            "#text": "The current version of the Twelf '''User's Guide''' is for Twelf version 1.4. [http://www.cs.cmu.edu/~twelf/guide-1-4/]\n\nIt is available in\n* [http://www.cs.cmu.edu/~twelf/guide-1-4/twelf_toc.html HTML]\n* [http://www.cs.cmu.edu/~twelf/guide-1-4/twelf.ps Postscript]\n* [http://www.cs.cmu.edu/~twelf/guide-1-4/twelf.ps.gz Gzipped Postscript]\n* [http://www.cs.cmu.edu/~twelf/guide-1-4/twelf.pdf PDF]\n\n== Undocumented features ==\n\nThe documentation has not yet been updated for the 1.5 release of Twelf. The [[:category:undocumented features|category for undocumented features]] collects articles on the wiki describing these features.\n\n\n{{stub}}"
          },
          "sha1": "pzdlapw7eot7cfygmhxy5n2pssj5bnq"
        }
      },
      {
        "title": "User-defined constraint domain",
        "ns": 0,
        "id": 1998,
        "revision": {
          "id": 6115,
          "parentid": 6114,
          "timestamp": "2010-09-02T11:29:57Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 45671,
            "#text": "This tutorial describes a technique for defining a limited form of '''constraint domain''' in Twelf, that is, a type with non-trivial equations among its terms.  Unlike Twelf's built-in (but [[Constraint_domains_and_coverage_checking|currently problematic]]) constraint domains of rationals, integers, and strings, these constraint domains are already part of the LF type theory and thus interact nicely with each other and with the rest of the theory.  And, as we shall see, they can be used for many of the same purposes, not to mention a whole host of new ones, including a limited form of type refinement.\n\nAlthough this tutorial has (user-defined) constraint domains as its main theme, it touches on a lot of other topics and techniques, and so has some value as a general tutorial on Twelf.\n\n== Motivation ==\n\nWe begin with some motivation (and review), which you can skip if you are interested in getting right to the examples that follow.\n\nLF is a representational framework:  given a particular formal system, we construct LF signatures that determine sets of terms (and types and kinds) that can stand as representatives of the constituents of the formal system.  We do this in such a way that the syntactic and proof-theoretic structures of the formal system, for example the binding structure of terms or the inductive construction of proofs, are mirrored in the type-theoretic structure of LF.  The measure of success for such a representation is what we call [[adequacy]].\n\nEquality of terms (and types and kinds) clearly plays a key role here, since adequacy depends on what terms are considered equal.  Twelf's built-in notion of equality, which is much coarser than plain syntactic identity, is the combination of [[beta-equivalence|beta]]- and [[eta-equivalence]].  The former, along with the notion of [[higher-order abstract syntax]], is what allows us to represent object-level substitution using meta-level function application.  And the latter implies a kind of extensionality or behavioral equivalence that gets rid of some annoying duplication in our representations that would otherwise make adequacy much more difficult to achieve.  Beta-eta equivalence has the very nice property that its equivalence classes have unique [[canonical form]]s, which are inductively defined; it is these canonical forms that are used to represent object-level entities.  Equality also plays a fundamental role in the [[Logic programming|operational semantics]] of Twelf, since one of its main components, unification, is all about finding substitutions that make a set of terms equal up to beta-eta equivalence, which is a crucial but quite non-trivial endeavor.\n\nHowever, despite the importance of equality, it remains an ''internal'' notion: there are no built-in \"equality types\" that we can use to reason about equality explicitly, for example to prove uniqueness of constructed objects or functionality of relations.  Instead, we must [[equality|define]] equality for each type where it is needed, and prove [[respects_lemma | respects]] and [[uniqueness_lemma | uniqueness]] lemmas in order to make use of it.  This approach has the advantage, though, that the same or closely-related techniques will work when the equality we define is ''not'' the built-in equality but one that carries more information.\n\nAnother crucial aspect of LF from a representational standpoint is that its terms are generated ''freely'' from its signature.  That is, no terms are present that are not built from the constructors in the signature and the variables in the context, and no identifications between terms are made, except those that follow from beta-eta equivalence.  Without this, it would be difficult to represent aspects of our formal systems that are defined (freely) by induction.  On the other hand, this freeness can also be an impediment, as when what we really want is a kind of ''algebra'':  a set endowed with certain operations that satisfy (non-trivial) equations.  Think, for example, of the type <tt>bool</tt>, which is freely generated by its two constants, <tt>true</tt> and <tt>false</tt>, but which has operations <tt>and</tt>, <tt>or</tt>, <tt>not</tt>, <tt>implies</tt>, etc., that satisfy the equations of Boolean Algebra.\n\nWe are therefore led to wonder whether we can represent such \"algebras\" as LF types.\n\n== Example 1: Even and Odd ==\n\nWe borrow our first example from the tutorial on [[Output factoring]]:\n\n<twelf discard=\"true\">\n\nnat : type.\nz : nat.\ns : nat -> nat.\n\nodd : nat -> type.\neven : nat -> type.\n\nz-e : even z.\ns-o : odd (s X) <- even X.\ns-e : even (s X) <- odd X.\n\n</twelf>\n\nHere, <tt>even</tt> and <tt>odd</tt> are ''predicates'' on <tt>nat</tt> and are defined in terms of their relation to <tt>s</tt>.  The [[output factoring|output factoring tutorial]] shows you how to prove that, under this definition, every natural number is either even or odd; the statement of the theorem requires a disjoint-union type, and the proof requires a lemma to take care of an output coverage problem.\n\n=== An approach using indexing ===\n\nSince the subsets of even and odd natural numbers are disjoint, you might think of another approach to representing these subsets, namely, by introducing a new type of ''natural number sorts'', and indexing <tt>nat</tt> by the sort:\n\n<twelf discard=\"true\">\nnat_sort : type.\neven : nat_sort.\nodd : nat_sort.\n\nnat : nat_sort -> type.\nz : nat even.\ns : nat even -> nat odd.    % Doesn't work:\ns : nat odd -> nat even.    % redefinition of s\n</twelf>\n\nWe'd like for <tt>s</tt> to have both of the declared types at the same time, but that is not possible in LF (though some proposed extensions of LF to include ''refinement types'' do allow something like this).  Alternatively, we might try to write something like\n\n<twelf discard=\"true\">\ns : nat X -> nat (f X).\n</twelf>\n\nfor some term <tt>f</tt> of type <tt>nat_sort -> nat_sort</tt> with the property that <tt>f even</tt> = <tt>odd</tt> and <tt>f odd</tt> = <tt>even</tt>, but again this is not possible in LF, since terms are freely generated and functional terms are parametric in their arguments (i.e., there are no destructors or case-splitting on arguments).  This approach seems to be stuck.  Or is it?\n\n=== A constraint domain of natural-number sorts ===\n\nThe idea is to use a higher-order \"Church-encoding\" for our two-element type and to use abbreviations to \"hide\" the implementation of this type:\n\n<twelf import=\"start\" export=\"ex1\">\n\nt : type.\n\n%abbrev nat_sort : type = t -> t -> t.\n%abbrev even : nat_sort = [even:t] [odd:t] even.\n%abbrev odd  : nat_sort = [even:t] [odd:t] odd.\n\n%abbrev add1-mod2 : nat_sort -> nat_sort = [s:nat_sort] [even:t] [odd:t] s odd even.\n\nnat : nat_sort -> type.\nz : nat even.\ns : nat X -> nat (add1-mod2 X).\n\n</twelf>\n\nWhy does this work?  As long as the type <tt>t</tt> does not become [[subordination|subordinate]] to any other type, the only canonical terms of type <tt>nat_sort</tt> are <tt>even</tt> and <tt>odd</tt>, and so the type looks \"from the outside\" just like the type <tt>nat_sort</tt> from the previous section.  However, <tt>add1-mod2</tt>, rather than being a constructor on this type that freely generates new terms, is instead a \"pre-existing\" canonical term of type <tt>nat_sort -> nat_sort</tt>.  In fact, there are ''four'' canonical terms of this type, the other three being\n\n<twelf import=\"ex1\">\n\n%abbrev const_even : nat_sort -> nat_sort = [s:nat_sort] [even:t] [odd:t] s even even.   % or: [s] even\n%abbrev const_odd  : nat_sort -> nat_sort = [s:nat_sort] [even:t] [odd:t] s odd  odd.    % or: [s] odd\n%abbrev identity   : nat_sort -> nat_sort = [s:nat_sort] [even:t] [odd:t] s even odd.    % or: [s] s\n\n</twelf>\n\nSimilarly, there are (2<sup>2</sup>)<sup>2</sup> = 16 canonical terms of type <tt>nat_sort -> nat_sort -> nat_sort</tt>, and 2<sup>4</sup> = 16 canonical terms of type <tt>(nat_sort -> nat_sort) -> nat_sort</tt>, and so on.  In fact, what we have here are all lambda-definable functions in the full type-hierarchy over {<tt>even</tt>, <tt>odd</tt>}, which, since this set is finite, is the same as the full (set-theoretic) type-hierarchy over {<tt>even</tt>, <tt>odd</tt>}.  And these functions are just there waiting to be used!\n\nTo see one such use, let's define the predicate <tt>plus X Y Z</tt>.  What should be its type?  We'll give two definitions, the first with minimal type information:\n\n<twelf import=\"ex1\">\n\nplus_min : nat X -> nat Y -> nat Z -> type.\n%mode plus_min +N1 +N2 -N3.\n\nplus_min_z : plus_min N1 z N1.\nplus_min_s : plus_min N1 (s N2) (s N3) <- plus_min N1 N2 N3.\n\n%worlds () (plus_min N1 N2 N3).\n%total N2 (plus_min N1 N2 N3).\n\n</twelf>\n\nThis works fine, but we can do better.  We know, for example, that if <tt>X</tt> and <tt>Y</tt> are the same, then <tt>Z</tt> will be <tt>even</tt>, and if <tt>X</tt> and <tt>Y</tt> are different, then <tt>Z</tt> will be <tt>odd</tt>.  In other words, tracking the sorts of the elements involved in an addition requires being able to compute addition mod 2.  But this is just a (finite) function in the type-hierarchy over {<tt>even</tt>, <tt>odd</tt>}, and so to get a maximally precise type for <tt>plus</tt>, we can just define the term of type <tt>nat_sort -> nat_sort -> nat_sort</tt> that represents addition mod 2, and then use that in the type:\n\n<twelf import=\"ex1\">\n\n%abbrev plus-mod2 : nat_sort -> nat_sort -> nat_sort\n   = [s1:nat_sort] [s2:nat_sort] [even:t] [odd:t] s1 (s2 even odd) (s2 odd even).\n\nplus : nat X -> nat Y -> nat (plus-mod2 X Y) -> type.\n%mode plus +N1 +N2 -N3.\n\nplus_z : plus N1 z N1.\nplus_s : plus N1 (s N2) (s N3) <- plus N1 N2 N3.\n\n%worlds () (plus N1 N2 N3).\n%total N2 (plus N1 N2 N3).\n\n</twelf>\n\n<twelflink import=\"ex1\" check=\"true\">See Twelf's output</twelflink>.  You'll see in this output that all of our abbreviations have been expanded, which makes the output a bit harder to read.  It would have been better to have used definitions rather than abbreviations, but (at present anyway) this is, for technical reasons, incompatible with Twelf's meta-checks.\n\nAlso notice that, apart from the change in name from <tt>plus_min</tt> to <tt>plus</tt>, the declarations of <tt>plus_z</tt> and <tt>plus_s</tt> are the same; it's just the type that has become more precise.  As an exercise, you may like to check that if <tt>f</tt> is any of the other 15 possible canonical forms of type <tt>nat_sort -> nat_sort</tt>, and you replace the declaration of <tt>plus</tt> above with\n\n<twelf discard=true>\nplus : nat X -> nat Y -> nat (f X Y) -> type.\n</twelf>\n\nthen at least one of the two declarations for <tt>plus_z</tt> or <tt>plus_s</tt> will no longer type-check without generating unresolved constraints.  Finally, we observe that, as compared to the definitions of even and odd in the tutorial on [[output factoring]], it is intrinsic in our encoding via the constraint domain <tt>nat_sort</tt> that every natural number is either even or odd, and so this is not something that needs to be proved.\n\n== Example 2: Polarities ==\n\nFor our next example, we are going to use the same constraint domain that we used in Example 1, and for a similar purpose (although we will be renaming it to suit the current situation).  Suppose that we have a language with a type system that includes a function-space operator, <tt>=></tt>, along possibly with some others, such as products, sums, and type constants, and we have represented these as canonical forms of an LF type <tt>tp</tt>.  We want to add an operator <tt>mu</tt> to represent ''positive inductive types''.  What this means is that if we have a type expression <tt>F : tp -> tp</tt> such that for any <tt>x : tp</tt>, the type <tt>F x</tt> only has ''positive'' occurrences of <tt>x</tt> (that is, every occurrence of <tt>x</tt> is on the left-hand side of an even number of <tt>=></tt> operators), then we want to be able to form <tt>mu F : tp</tt>.  Furthermore, these are the ''only'' <tt>mu</tt>-types that we want to form; i.e., we want this to be an [[Intrinsic and extrinsic encodings|intrinsic encoding]].  All of these types will have introduction and elimination forms, but for the purposes of this example, we will just focus on the types themselves.\n\n=== An approach via predicates ===\n\nA natural approach to this problem is to try to represent the positivity condition as a predicate <tt>pos</tt> on <tt>tp -> tp</tt> and to define this predicate mutually with another predicate <tt>neg</tt> on <tt>tp -> tp</tt>, as follows:\n\n<twelf import=\"start\" export=\"ex2a\">\ntp : type.\n\npos : (tp -> tp) -> type.\nneg : (tp -> tp) -> type.\n\nun : tp.                                       % unit type\n*  : tp -> tp -> tp.    %infix right 11 *.     % product type\n=> : tp -> tp -> tp.    %infix right 10 =>.    % function type\nmu : {F:tp -> tp} pos F -> tp.                 % inductive type\n\npos_id : pos ([a] a).\n\npos_un : pos ([a] un).\npos_*  : pos ([a] F1 a) -> pos ([a] F2 a) -> pos ([a] F1 a * F2 a).\npos_=> : neg ([a] F1 a) -> pos ([a] F2 a) -> pos ([a] F1 a => F2 a).\npos_mu : ({b:tp} pos ([a] b) -> pos ([a] F a b)) -> pos ([a] mu ([b] F a b) _).\n\nneg_un : neg ([a] un).\nneg_*  : neg ([a] F1 a) -> neg ([a] F2 a) -> neg ([a] F1 a * F2 a).\nneg_=> : pos ([a] F1 a) -> neg ([a] F2 a) -> neg ([a] F1 a => F2 a).\nneg_mu : ({b:tp} neg ([a] b) -> neg ([a] F a b)) -> neg ([a] mu ([b] F a b) _).\n</twelf>\nSome comments about this code are in order:\n\n* We have chosen to the make the type constructor <tt>F</tt> an [[explicit parameter]] of <tt>mu</tt> in order to make <tt>mu</tt>-terms appear more natural, with the positivity proof relegated to second position.  However, we could just as easily have left this parameter implicit, declaring <tt>mu : pos F -> tp</tt>, since we would still have access to <tt>F</tt> through unification with terms involving type ascriptions, as in <tt>mu (P : pos F)</tt>.\n\n* We define <tt>pos F</tt> and <tt>neg F</tt> by induction on the body of <tt>F</tt>, taking advantage of the inductive characterization of LF canonical forms of type <tt>tp -> tp</tt> as the canonical forms of type <tt>tp</tt> in a context that includes an extra assumption <tt>a : tp</tt>.  The cases for <tt>mu</tt> say that a type <tt>a</tt> occurs positively (or negatively) in a <tt>mu</tt>-type if it occurs positively (or negatively) in its body, and are necessary if we want to allow nested <tt>mu</tt>-types (but see below!).  The proof components of the <tt>mu</tt>-type are not used, hence the underscores <tt>_</tt> in these declarations.\n\n* We have chosen to define <tt>pos</tt> and <tt>neg</tt> using types involving the <tt>-></tt> arrow rather than the <tt>&lt;-</tt> arrow that is typical in logic-programming-style definitions, e.g.,\n<pre style=\"border:0px; background-color:white\">\n    pos_* : pos ([a] F1 a * F2 a)\n              <- pos ([a] F1 a)\n              <- pos ([a] F2 a).\n</pre>\n: There are two reasons.  First, these declarations are not the same:  using the earlier declaration, a term of the form <tt>pos_* P1 P2 : pos ([a] F1 a * F2 a)</tt> has <tt>P1</tt> as the positivity proof for <tt>F1</tt> and <tt>P2</tt> as the positivity proof for <tt>F2</tt>, whereas in the declaration just given, it is reversed!  Second, we prefer to use <tt>-></tt> when we are representing data (i.e., making object-level definitions) and <tt>&lt;-</tt> when we are representing programs (i.e., proving metatheorems), but this is a matter of style.\n\nAll of this appears to work, and we were able, in passing, to make some useful comments about the code, but unfortunately there is a problem here, and the problem has to do with nested <tt>mu</tt>-types.  As a simple example, take the μ-type μ<tt>X</tt>. μ<tt>Y</tt>. <tt>X * Y</tt> (which could be a considered the type of infinite streams of infinite streams of infinite streams of ...).  In order for the outer <tt>mu</tt> in any representation of this type to be well-formed, it's body, the inner <tt>mu</tt>, must have only positive occurrences of <tt>X</tt> in its body (which it seems to have) and similarly for the positivity of <tt>Y</tt> in the body of the inner <tt>mu</tt>, which is <tt>X * Y</tt>.  However, you can see in the clause for <tt>pos_*</tt> above that, for <tt>Y</tt> to be positive in <tt>X * Y</tt>, not only does it have to be positive in <tt>Y</tt>, which it is by <tt>pos_id</tt>, but it also has to be positive in <tt>X</tt>, which we have not arranged to be the case.\n\nNow, since every occurrence of a variable is both positive and negative in an expression in which it does not occur&mdash;vacuously&mdash;we could add two [[catch-all case]]s to our declarations to fix this problem:\n\n<twelf import=\"ex2a\">\npos_vac : pos ([a] F).\nneg_vac : neg ([a] F).\n</twelf>\n\nWe could then represent our μ-type μ<tt>X</tt>. μ<tt>Y</tt>. <tt>X * Y</tt> with the term\n\n<twelf import=\"ex2a\">\nstreams : tp = mu ([x] mu ([y] x * y) (pos_* pos_vac pos_id)) (pos_mu ([y][py] pos_* pos_id py)).\n</twelf>\n\nHowever, as mentioned in the [[catch-all case|tutorial on catch-all cases]], this creates ''non-determinism'', since it is now possible to have multiple proofs of positivity for the same type constructor.  For example, we have:\n<twelf import=\"ex2a\">\nproof1 : pos ([a] un * un) = pos_* pos_un  pos_un.\nproof2 : pos ([a] un * un) = pos_* pos_vac pos_un.\nproof3 : pos ([a] un * un) = pos_* pos_un  pos_vac.\nproof4 : pos ([a] un * un) = pos_* pos_vac pos_vac.\nproof5 : pos ([a] un * un) = pos_vac.\n</twelf>\nand so, filling in the hole labeled <tt>%{proof}%</tt> in the term\n<twelf discard=\"true\">\nmu ([x] un * un) ( %{proof}% )\n</twelf>\nwith each of the five proofs above, we would get five different canonical terms of type <tt>tp</tt> representing the same μ-type, μ<tt>X</tt>. <tt>1 * 1</tt> ! This destroys the [[adequacy]] of our representation, and is why it's best to avoid catch-all cases in object representations.  On the other hand, the same can't be said, in general, of [[metatheorem]] representation, since there we are usually more concerned about the ''existence'' of proofs rather than their unique representation (whatever that means: if you really figure out what it means for two proofs to be \"equal\", let me know!)  Finally, just as we mentioned in connection with Example 1 that some proposed extensions to LF to include ''refinement types'' could give a nice solution to the representation of even and odd natural numbers (among many others such \"subsorts\"), we should also mention here that some proposed extensions to LF to include ''proof-irrelevance'' could address the problem we have described above, by identifying all elements, or \"proofs\", of certain types, restoring adequacy of such representations.\n\n<twelflink import=\"ex2a\" check=\"true\">See Twelf's output</twelflink> for the code above.\n\n=== Is there an adequate intrinsic encoding? ===\n\nSo how can we achieve an adequate intrinsic encoding of μ-types?  The situation is worse than you might think:  there doesn't seem to be any hope of getting such an encoding.  We've seen that adding a catch-all case destroys adequacy, but yet we've also seen that, in representing the μ-type μ<tt>X</tt>. μ<tt>Y</tt>. <tt>X * Y</tt>, we need a positivity assumption about <tt>X</tt> in order to show that <tt>Y</tt> occurs positively in <tt>X * Y</tt>.  So our only hope seems to be to add it to the argument of <tt>mu</tt>, thus:\n\n<twelf discard=\"true\">\nmu : {F:{a:tp} pos ([b] a) -> tp} pos F -> tp.\n</twelf>\n\nBut this is not well-typed unless we also either\n\n# change the type of <tt>pos</tt> so that it accepts arguments of the same type as <tt>F</tt>, or\n# extract the underlying constructor of type <tt>tp -> tp</tt> from <tt>F</tt> and use that instead as the argument to <tt>pos</tt>.\n\nBut neither of these is possible:  we can't do 1 because <tt>pos</tt> would then have to be declared as\n\n<twelf discard=\"true\">\npos : ({a:tp} pos ([b] a) -> tp) -> type\n</twelf>\n\nwhich is circular, and we can't do 2, because to get a <tt>tp</tt> output from <tt>F</tt>, we'd need first to construct something of type <tt>pos ([b] a)</tt>, which is exactly the problem we were trying to solve in the first place.  So, it seems that our search for an adequate intrinsic encoding of μ-types is doomed.  Or is it?\n\n=== Using the even/odd constraint domain ===\n\nYou may remember our original characterization of what it means for a type expression <tt>F : tp -> tp</tt> to have only positive occurrences of its bound variable, namely, that every occurrence of the variable is on the left-hand side of an ''even'' number of <tt>=></tt> operators.  This suggests that, in the same way that we used the <tt>nat_sort</tt> constraint domain in Example 1 as an index to <tt>nat</tt> in order to capture the even (and odd) natural numbers, we can also use it here as an index to <tt>tp</tt> to capture occurrences on the left of an even (and odd) number of <tt>=></tt>s.  When we follow this idea to its logical conclusion, this is what we get:\n\n<twelf import=\"start\" export=\"ex2b\">\nt : type.\n\n%abbrev pol : type = t -> t -> t.                              % polarities\n%abbrev opp : pol -> pol = [p:pol] [pos:t] [neg:t] p neg pos.  % the opposite polarity\n\ntp : pol -> type.\n\nun : tp P.                                                     % unit type\n*  : tp P -> tp P -> tp P.            %infix right 11 *.       % product type\n=> : tp (opp P) -> tp P -> tp P.      %infix right 10 =>.      % function type\nmu : (tp P -> tp P) -> tp P.                                   % inductive type\n</twelf>\n\nThat's it!  You may find it hard to believe that this works, so let's look at it more closely.  The constraint domain is the same one we used before, with <tt>nat_sort</tt> renamed to <tt>pol</tt> and <tt>add1-mod2</tt> renamed to <tt>opp</tt>.  In all of the type constructors the polarity index is implicitly quantified, so each will apply to both polarities, but the individual polarities themselves have no meaning&mdash;there isn't a \"positive\" polarity or a \"negative\" polarity, for example&mdash;so we haven't given them names.  The main force of the polarities is to be found in the rules for <tt>=></tt> and <tt>mu</tt>.  In the case of <tt>=></tt>, the rule says that, whatever polarity is to be assigned to the type <tt>A => B</tt>, the same polarity must be assigned to <tt>B</tt> and the opposite polarity must be assigned to <tt>A</tt>.  And in the case of <tt>mu</tt>, the fact that the functional argument to <tt>mu</tt> has domain and codomain types with the ''same'' polarity means that, if we consider this functional argument to be an abstract syntax tree with instances of the bound variable at the leaves, then an even number of applications of <tt>opp</tt> must occur between the root of this tree and any occurrence of the bound variable at the leaves.\n\nIn short, you can think of the rules as giving conditions for a particular simultaneous polarity assignment to all of the subterms of a given term to be ''coherent'', and you'll notice that if one polarity assignment is coherent, then so is its opposite, reinforcing the idea that the individual polarities are meaningless.  (We might say, following Einstein, that positivity and negativity are not ''absolute'' notions, but are only meaningful relative to other instances of one another!)  Thus, since each of the type constructors relates the polarity of its \"output\" to the polarities of its \"inputs\" (with, in the case of <tt>mu</tt>, an assumption about the polarity of the bound type variable), a given term representing one of our types will have, overall, either zero or exactly two polarity assignments for its subterms that can be coherent, with only the latter case corresponding to the type being well-formed.  It follows that the product type <tt>{P:pol} tp P</tt> adequately represents our informal notion of positive inductive types.\n\nHere are some sample encodings of μ-types, starting with the two examples we discussed before:\n\n<twelf import=\"ex2b\">\n%abbrev pos_ind : type = {P:pol} tp P.\n\nstreams : pos_ind = [P] mu [x] mu [y] x * y.\nones    : pos_ind = [P] mu [x] un * un.\n\nex1 : pos_ind = [P] mu [x] un => x.\nex2 : pos_ind = [P] mu [x] (x => un) => x.\nex3 : pos_ind = [P] mu [x] (x * x => un) => x * x.\nex4 : pos_ind = [P] mu [x] (mu [y] x => y) => x.\n</twelf>\n\n<twelflink import=\"ex2b\" check=\"true\">See Twelf's output</twelflink>.\n\nYou might also like to check that each of these definitions fails to type-check:\n\n<twelf discard=\"true>\nex5 : pos_ind = [P] mu [x] x => un.\nex6 : pos_ind = [P] mu [x] x => x.\nex7 : pos_ind = [P] mu [x] x * (mu [y] x => y).\n</twelf>\n\nCuriously, if you remove the type ascriptions and polarity abstractions from these three ill-formed <tt>mu</tt>-types, then they ''do'' type-check, but only because Twelf, during type-reconstruction, abstracts a variable <tt>X</tt> of type <tt>t</tt> from these definitions and then assigns the \"constant polarity\" <tt>[t1][t2] X</tt> (which is its own opposite!) to the contradictory subterms.  This illustrates again the reliance of this method on the fact that the basic type <tt>t</tt> cannot have any canonical elements.\n\n== Example 3: Uniform syntactic categories ==\n\nLooking over the examples from the previous two sections, you may have noticed a pattern in the method we used to achieve simplification in each case, a method that we might call ''intrinsification by indexing''.  That is, we were given a type <tt>A</tt> with some unary predicates <tt>P</tt> on that type and we \"intrinsified\" those predicates by turning <tt>A</tt> into a type family <tt>A'</tt> that was indexed by a particular constraint domain whose elements represented those predicates; for any predicate <tt>P</tt>, the elements of <tt>A' P</tt> were exactly the original elements of <tt>A</tt> that satisfied <tt>P</tt>.  This opened up the possibility of giving more precise types to functions defined on <tt>A</tt> that respected the predicates, since we were are able to \"track\" their behavior on the indices by using definable functions in the type-hierarchy over the constraint domain.\n\nThus, in Example 1, the type <tt>A</tt> was <tt>nat</tt> and the predicates were <tt>even</tt> and <tt>odd</tt>.  These predicates became elements of a constraint domain <tt>nat_sort</tt> that we used to index <tt>A</tt>, and the functions <tt>s</tt> and (via its graph) <tt>plus</tt> could be tracked by functions <tt>add1-mod2</tt> and <tt>plus-mod2</tt> on <tt>nat_sort</tt>.  And in Example 2, the type <tt>A</tt> was <tt>tp -> tp</tt> and the predicates were <tt>pos</tt> and <tt>neg</tt>.  These predicates became elements of a constraint domain <tt>pol</tt> and the various type constructors were tracked with the help of (the identity function and) the function <tt>opp</tt> on <tt>pol</tt>.\n\nWe will continue to explore this theme by using a couple of examples from the typed lambda calculus and LF itself.  But first, let's look a little more carefully at the conditions under which we can expect the methods of the previous two sections to work.  Clearly, if we want there to be a bijection between <tt>A</tt> and the collection of types <tt>A' P</tt> indexed by the predicates <tt>P</tt>, then the extensions of these predicates must form a partition of <tt>A</tt> (i.e., they must be pairwise disjoint and collectively exhaustive).  This may seem like a severe restriction, but there are some ways around it, as we will see shortly.  But another restriction of the method is that, if we want to give more informative types for functions defined on <tt>A</tt>, these must must not only respect the predicates, but the induced functions on the indices must also be ''uniform'' in the sense that they can be defined parametrically on the index.  These restrictions will become clearer as we look at more examples.\n\n=== Simply-typed lambda calculus with values ===\n\nOur next example won't actually require a constraint domain, but it nevertheless illustrates the intrinsification-by-indexing theme we are developing, and it shows how you can sometimes get around some of the limitations of the method that were discussed at the end of the previous section.  Suppose we want to represent a simply-typed call-by-value lambda-calculus with a (big-step) evaluation relation that relates arbitrary terms with their values under evaluation, and we decide to represent typed terms intrinsically and values extrinsically:\n\n<twelf import=\"start\" export=\"ex3a\">\ntp : type.\n=> : tp -> tp -> tp.   %infix right 10 =>.\n\nexp : tp -> type.\nlam : (exp A -> exp B) -> exp (A => B).\napp : exp (A => B) -> exp A -> exp B.\n\nval : exp A -> type.\nlam-val : val (lam [x] E x).\n\neval : exp A -> exp A -> type.\neval-lam : eval (lam [x] E x) (lam [x] E x).\neval-app : eval (app E1 E2) V\n            <- eval E1 (lam [x] E1' x)\n            <- eval E2 V2\n            <- eval (E1' V2) V.\n</twelf>\n\nThat is, the encoding of typed terms here is intrinsic in that we are only representing well-typed terms (along with their types), and not separate types and (not necessarily well-typed) terms that are related by a typing judgment.  And our encoding of values is extrinisic in that we are representing values as a subset of terms through a separate judgment, instead of similarly building the notion into the terms.  (See the tutorial on [[Intrinsic and extrinsic encodings]], which uses some similar examples.)\n\n<twelflink import=\"ex3a\" check=\"true\">See Twelf's output</twelflink> for the above declarations.\n\nNow, we'd like to \"intrinsify\" the representation of values in this encoding, but there is an obstacle here that wasn't present in our previous examples:  we have two predicates here corresponding to values and general terms, but they aren't disjoint:  every values is a general term.  The solution is to introduce a separate predicate for ''non-values'', which, along with values, partition the set of terms.  Fortunately, this is possible here, since non-values have a simple inductive definition:  they are precisely the applications.  Here is the final result:\n\n<twelf import=\"start\" export=\"ex3b\">\ntp : type.\n=> : tp -> tp -> tp.  %infix right 10 =>.\n\nstlc_sort : type.\nval : stlc_sort.\nnon-val : stlc_sort.\n\nexp : stlc_sort -> tp -> type.\n\nlam : (exp val A -> exp S B) -> exp val (A => B).\napp : exp S1 (A => B) -> exp S2 A -> exp non-val B.\n\neval : exp S A -> exp val A -> type.\nev-lam : eval (lam [x] E x) (lam [x] E x).\nev-app : eval (app E1 E2) V\n          <- eval E1 (lam [x] E1' x)\n          <- eval E2 V2\n          <- eval (E1' V2) V.\n</twelf>\n\nNow we can see why a constraint domain wasn't required in this case:  there are no special functions needed to track <tt>lam</tt> and <tt>app</tt> on the indices.  Yet we still get an intrinsic encoding with more informative types for <tt>lam</tt>, <tt>app</tt>, and <tt>eval</tt>.  And whereas with the extrinisic encoding we would have to prove a metatheorem that if <tt>eval E V</tt> then <tt>val V</tt>, with the intrinsic encoding this comes for free.\n\n<twelflink import=\"ex3b\" check=\"true\">See Twelf's output</twelflink>.\n\n=== The syntax of Canonical LF ===\n\nIn modern presentations of the LF type theory (see the glossary entry for [[canonical form]]s for more information), the set of syntactic objects is divided into five categories:  kinds, canonical types, atomic type families, canonical terms, and atomic terms, often denoted by the letters K, A, P, M, and R.  This stratification of syntax necessitates a similar stratification of the typing judgment (or, as we will call it, the classification judgment), the [[hereditary substitution]] judgment, and the statements of theorems about these judgments, for example the substitution theorem.\n\nIn this section, we will show how it is possible to define a constraint domain <tt>cat</tt> of ''(syntactic) categories'' to allow an economical presentation of the syntax, judgments, and metatheorems of LF.  In particular, we will have one type family of terms, one classification judgment, one substitution judgment, and one substitution theorem statement, each of which is indexed by a syntactic category.  In order to achieve this unification, we will have to make use of some functions in the type hierarchy over <tt>cat</tt>, much the way we did with <tt>add1-mod2</tt>, <tt>plus-mod2</tt>, and <tt>opp</tt> above.  To simplify the presentation for this tutorial, we will not be representing signatures, (type family or term) constants, subordination, the simple-type subscripts to hereditary substitution, or the bi-directionality of the typing judgments and substitution theorem.\n\n==== The constrain domain of syntactic categories ====\n\nWe first define the constraint domain, <tt>cat</tt>.  There are two subtleties here.  First, because our unified classification judgment relates a syntactic object to its classifier, it will be necessary for the purpose of uniformity to introduce a category to classify kinds; we call it \"unit\" (letter: U) and give it a unique element <tt>*</tt> (this element might be called a \"hyperkind\").  Second, the hereditary substitution operation, when applied to an atomic term ''R'', can produce either a canonical term or an atomic term, depending on whether the substitution variable occurs at the head of ''R'' or not.  Consequently, we introduce a syntactic category to represent the disjoint union of canonical and atomic terms (letter: M+R), and we introduce two injections from M and R into M+R as term constructors.\n\nHere is the definition of the constraint domain:\n\n<twelf import=\"start\" export=\"ex3d\">\nt : type.\n\n%abbrev cat : type = t -> t -> t -> t -> t -> t -> t -> t.  % seven elt type\n\n%abbrev k   : cat = [k][a][p][m][r][m+r][u] k.\n%abbrev a   : cat = [k][a][p][m][r][m+r][u] a.\n%abbrev p   : cat = [k][a][p][m][r][m+r][u] p.\n%abbrev m   : cat = [k][a][p][m][r][m+r][u] m.\n%abbrev r   : cat = [k][a][p][m][r][m+r][u] r.\n%abbrev m+r : cat = [k][a][p][m][r][m+r][u] m+r.\n%abbrev u   : cat = [k][a][p][m][r][m+r][u] u.\n</twelf>\n\n==== Terms and term constructors ====\n\nWe can now introduce the type <tt>tm</tt> of terms, which is indexed by <tt>cat</tt>, as well as the various term constructors:\n\n<twelf import=\"ex3d\">\ntm  : cat -> type.\n\ntyp      : tm k.                               % type (the base kind)\npi_k     : tm a -> (tm r -> tm k) -> tm k.     % kind-level product\n\ncoer_pa  : tm p -> tm a.                       % type coercion\npi_a     : tm a -> (tm r -> tm a) -> tm a.     % type-level product\n\napp_p    : tm p -> tm m -> tm p.               % atomic family application\n\ncoer_rm  : tm r -> tm m.                       % term coercion\nlam_m    : (tm r -> tm m) -> tm m.             % term-level lambda abstraction\n\napp_r    : tm r -> tm m -> tm r.               % atomic term application\n\ncanon    : tm m -> tm m+r.                     % left injection\natom     : tm r -> tm m+r.                     % right injection\n\n*        : tm u.                               % unit\n</twelf>\n\nHere, we have used the standard [[higher-order abstract syntax]] representations of binders, which in this case always abstract over atomic term variables.  We have also included explicit coercions from atomic to canonical types and terms, since we really have disjoint syntactic categories here, instead of the usual overlapping ones, so some operation is needed to move from one category to another.\n\n==== Main judgments ====\n\nWe come now to the main judgments, classification and substitution.  We haven't yet made any special use of the constraint domain&mdash;for everything above, we could have used an ordinary type&mdash;but this is where we will need it.  The reason is that, in order to state these judgments in a general enough way to include all of the usual stratified LF judgments, we will need to be able to track the functions that take a category to the category of objects that classifies it, as well as the function that takes a category to the category of objects that result from substitutions into it (recall the subtlety with M+R).  These are provided by the functions <tt>class</tt> and <tt>subst</tt>, respectively:\n\n<twelf import=\"ex3d\">\n%abbrev class : cat -> cat = [X:cat] [k][a][p][m][r] [m+r][u]\n                              X       u  u  k  a  a   a    u.\n\n%abbrev subst : cat -> cat = [X:cat] [k][a][p][m][r] [m+r][u]\n                              X       k  a  p  m  m+r m+r  u.\n\nclassj : tm X -> tm (class X) -> type.\n\nsubstj : (tm r -> tm X) -> tm m -> tm (subst X) -> type.\n</twelf>\n\nHere, <tt>classj U V</tt> means that <tt>U</tt> is classified by (has type, has kind, has hyperkind) <tt>V</tt>, and <tt>substj ([x] E x) M E'</tt> means that <tt>E'</tt> is the result of substituting <tt>M</tt> for <tt>x</tt> in <tt>E</tt>.  Also, notice that the category index of each of these judgments is ''implicit'', so you won't see any categories mentioned in the rules that follow.\n\n==== Rules for classification ====\n\nWe now give the encodings of the rules for classification.  For the purposes of this tutorial, it is not necessary that you study these rules in detail (unless they interest you!); just notice that Twelf is, in each case, able to infer the syntactic categories of all syntactic constituents of these rules by the using the term constructors involved, as well as the <tt>class</tt> function used to track the category of the classifier.\n\n<twelf import=\"ex3d\">\ncanon_kind_type : classj typ *.\n\ncanon_kind_pi   : classj (pi_k A2 [y] K y) *\n                   <- classj A2 *\n                   <- {y} classj y A2 -> classj (K y) *.\n\ncanon_fam_pi    : classj (pi_a A2 [y] A y) *\n                   <- classj A2 *\n                   <- ({y} classj y A2 -> classj (A y) *).\n\ncanon_fam_atom  : classj (coer_pa P) *\n                   <- classj P typ.\n\natom_fam_app    : classj (app_p P1 M2) K\n                  <- classj P1 (pi_k A2 [y] K1 y)\n                  <- classj M2 A2\n                  <- substj ([x] K1 x) M2 K.\n\ncanon_term_lam  : classj (lam_m [y] M y) (pi_a A2 [y] A y)\n                   <- ({y} classj y A2 -> classj (M y) (A y)).\n\ncanon_term_atom : classj (coer_rm R) (coer_pa P)\n                   <- classj R (coer_pa P).\n\n% atom_term_var not necessary\n\natom_term_app   : classj (app_r R1 M2) A\n                   <- classj R1 (pi_a A2 [y] A1 y)\n                   <- classj M2 A2\n                   <- substj ([x] A1 x) M2 A.\n\ncanon_atom_can  : classj (canon M) A\n                   <- classj M A.\n\ncanon_atom_atom : classj (atom R) A\n                   <- classj R A.\n\nunit_unit       : classj * *.\n</twelf>\n\n==== Rules for substitution ====\n\nSimilarly, we present the rules for substitution.  Just notice here that categories are inferred in the same way as with classification, with the added subtlety of the disjoint union type returned by substitutions into atomic terms:\n\n<twelf import=\"ex3d\">\nsubst_k_type  : substj ([x] typ) M0 typ.\n\nsubst_k_pi    : substj ([x] pi_k (A x) [y] K x y) M0 (pi_k A' [y] K' y)\n                 <- substj ([x] A x) M0 A'\n                 <- {y} substj ([x] y) M0 (atom y)\n                    -> substj ([x] K x y) M0 (K' y).\n\nsubst_a_p     : substj ([x] coer_pa (P x)) M0 (coer_pa P')\n                 <- substj ([x] P x) M0 P'.\n\nsubst_a_pi    : substj ([x] pi_a (A2 x) [y] A x y) M0 (pi_a A2' [y] A' y)\n                 <- substj ([x] A2 x) M0 A2'\n                 <- {y} substj ([x] y) M0 (atom y)\n                    -> substj ([x] A x y) M0 (A' y).\n\nsubst_p_app   : substj ([x] app_p (P x) (M x)) M0 (app_p P' M')\n                 <- substj ([x] P x) M0 P'\n                 <- substj ([x] M x) M0 M'.\n\nsubst_m_lam   : substj ([x] lam_m [y] M x y) M0 (lam_m [y] M' y)\n                 <- {y} substj ([x] y) M0 (atom y)\n                    -> substj ([x] M x y) M0 (M' y).\n\nsubst_m_rh  : substj ([x] coer_rm (R x)) M0 M'\n               <- substj ([x] R x) M0 (canon M').\n\nsubst_m_r   : substj ([x] coer_rm (R x)) M0 (coer_rm R')\n               <- substj ([x] R x) M0 (atom R').\n\nsubst_rh_var  : substj ([x] x) M0 (canon M0).\n\n% subst_r_var not necessary\n\nsubst_rh_app : substj ([x] app_r (R1 x) (M2 x)) M0 (canon M'')\n                <- substj ([x] R1 x) M0 (canon (lam_m [y] M' y))\n                <- substj ([x] M2 x) M0 M2'\n                <- substj ([y] M' y) M2' M''.\n\nsubst_r_app : substj ([x] app_r (R1 x) (M2 x)) M0 (atom (app_r R1' M2'))\n                <- substj ([x] R1 x) M0 (atom R1')\n                <- substj ([x] M2 x) M0 M2'.\n\nsubst_m+r_canon : substj ([x] canon (M x)) M0 (canon M')\n                   <- substj ([x] M x) M0 M'.\n\nsubst_m+r_atom  : substj ([x] atom (P x)) M0 (atom P')\n                   <- substj ([x] P x) M0 (atom P').\n\nsubst_unit_unit : substj ([x] *) M0 *.\n</twelf>\n\n==== Statement of the substitution theorem ====\n\nWe finish up this example with one more illustration of the unification afforded by our constraint domain: the statement of the substitution theorem for LF.  The theorem statement involves an implicit quantification over the syntactic category.  This means, in particular, that it isn't necessary to prove this by a mutual induction over the syntactic category, as is usually the case.  (Note, however, that because of the simplifications to LF that we have used for this presentation, it won't be possible to prove the theorem in this form.)\n\n<twelf import=\"ex3d\">\nsub_thm : {T:tm r -> tm X} classj M0 A0\n           -> ({x:tm r} classj x A0 -> classj (T x) (C x))\n           -> substj ([x] C x) M0 C'\n           %%---------------------------------------------\n           -> {T':tm (subst X)}\n              substj ([x] T x) M0 T'\n           -> classj T' C'\n           -> type.\n</twelf>\n\n<twelflink import=\"ex3d\" check=\"true\">See Twelf's output</twelflink> for all the code in this section.  Expansion of abbreviations is really hurting us here in this output, since <tt>nat</tt> expands to a type with seven arrows!\n\n== Example 4: Lists of length ''n'' ==\n\nAll of the constraint domains that we have used so far have been finite.  For our last example, we will use an infinite constraint domain to implement one of the examples from the Twelf Manual that was used to illustrate the built-in constraint domain of rational numbers.  The example defines a dependent type of lists of items, where the index is the length of the list.  It then defines an append function, using the integer addition function to track the index of the result.  We can achieve that result here by using a Church encoding of the natural numbers:\n\n<twelf import=\"start\" export=\"ex4\">\nt : type.\n\n%abbrev nat = (t -> t) -> t -> t.\n\n%abbrev 0   = [s:t -> t] [z:t] z.\n%abbrev s   = [n:nat] [s:t -> t] [z:t] s (n s z).\n%abbrev +   = [n:nat] [m:nat] [s:t -> t] [z:t] n s (m s z).  %infix right 10 +.\n\nitem : type.\nlist : nat -> type.    % list N = item lists of length N\n\nnil  : list 0.\ncons : item -> list N -> list (s N).\n\nappend : list M -> list N -> list (M + N) -> type.\n\nappend_nil  : append nil L L.\nappend_cons : append (cons T L1) L2 (cons T L3)\n               <- append L1 L2 L3.\n</twelf>\n\nIt is interesting to note here that, in order to type-check the declarations for <tt>append_nil</tt> and <tt>append_cons</tt>, Twelf needs to prove for itself that the natural numbers defined above satisfy, respectively,\n\n# 0 + <tt>X</tt> = <tt>X</tt>, for all <tt>X</tt> in <tt>nat</tt>, and\n# <tt>X + Y = Z</tt> implies <tt>(s X) + Y = (s Z)</tt>, for all <tt>X</tt>, <tt>Y</tt>, and <tt>Z</tt> in <tt>nat</tt>.\n\nThese are statements&mdash;an equation and an implication between two equations&mdash;that are universally quantified over an infinite set, and are normally the kind of statement that is proved by induction on the natural numbers.  So, is Twelf secretly proving statements by induction during type-checking?  No, but that would be nice!  In fact, in the case of 1, if you apply the definition of <tt>+</tt> to <tt>0</tt> and a ''free variable'' <tt>X</tt> of type <tt>nat</tt> and then (beta-eta) normalize the result, you will see that it is equal (i.e., beta-eta equivalent) to <tt>X</tt>.  Similarly, if you apply the definitions of <tt>+</tt> and <tt>s</tt> to <tt>(s X) + Y</tt>, on the one hand, and <tt>s(X + Y)</tt> on the other, for free variables <tt>X</tt> and <tt>Y</tt> of type <tt>nat</tt>, you will see that they are again equal.  Thus, all Twelf needs in order to prove 1 and 2 above is beta-eta equivalence!\n\n<twelflink import=\"ex4\" check=\"true\">See Twelf's output</twelflink>\n\n== Conclusion ==\n\nThe techniques described in this tutorial fit into the general category of using indexing of types instead of predicates to make encodings more intrinsic.  Our so-called user-defined constraint domains were one variety of index type that we found to be useful in this regard, since they allow us to define \"tracking functions\" that would be impossible to define with a free representation.\n\nHowever, there are still some issues that we have not yet examined.  For example,\n\n* All of our domains were defined in terms of a type <tt>t</tt>, and we saw that it was necessary for the method that the type hierarchy over <tt>t</tt> (or at least the part of it that we are using) doesn't acquire any new canonical elements other than those that exist for all <tt>t</tt>, but we didn't talk about the best way to insure this in our developments.\n\n* The examples we gave where certain ill-formed terms produced unresolved constraints when we tried to type-check them are in a kind of nether world between terms that type-check and terms that fail to type-check.  We would like to believe that the set of constraints produced on these examples by Twelf's type-checker are unresolvable, but there is no part of Twelf that can check that.\n\nNevertheless, these examples illustrate once again the power of LF as a representational framework."
          },
          "sha1": "nz4glmi3r32qparivnbb2uft88ewxq1"
        }
      },
      {
        "title": "Using a metric",
        "ns": 0,
        "id": 1733,
        "redirect": {
          "@title": "Structural metrics",
          "#text": null
        },
        "revision": {
          "id": 2925,
          "timestamp": "2006-10-17T00:05:16Z",
          "contributor": {
            "username": "DanielKLee",
            "id": 5
          },
          "comment": "[[Using a metric]] moved to [[Structural metrics]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 32,
            "#text": "#REDIRECT [[Structural metrics]]"
          },
          "sha1": "eevskztve10qnquc3khd5x3g131qu9t"
        }
      },
      {
        "title": "Using nat-less with %reduces",
        "ns": 0,
        "id": 1508,
        "revision": {
          "id": 1983,
          "parentid": 1980,
          "timestamp": "2006-09-27T18:26:36Z",
          "contributor": {
            "username": "DanielKLee",
            "id": 5
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 2470,
            "#text": "This is an extension of the example given in the [[%reduces]] article. The theorem <tt>nat-plus-reduces-s</tt> is used in conjunction with some standard properties about addition over the natural numbers to show <tt>nat-less-reduces</tt>, which allows <tt>nat-less</tt> to be used in termination arguments about other metatheorems. \n\n<twelf>nat : type.\n\nnat/z\t: nat.\nnat/s\t: nat -> nat.\n\n\n\nnat-plus : nat -> nat -> nat -> type.\n\nnat-plus/z\t: nat-plus nat/z N N.\n\nnat-plus/s\t: nat-plus (nat/s N1) N2 (nat/s N3)\n\t\t   <- nat-plus N1 N2 N3.\n\n\n\nnat-plus-reduces-s\t: {N2}{N3}\n\t\t\t   nat-plus (nat/s N1) N2 N3\n\t\t\t   -> type.\n%mode nat-plus-reduces-s +D1 +D2 +D3.\n\n-\t: nat-plus-reduces-s _ _ (nat-plus/s nat-plus/z).\n\n-\t: nat-plus-reduces-s _ _ (nat-plus/s DL)\n\t   <- nat-plus-reduces-s _ _ DL.\n\n%worlds () (nat-plus-reduces-s _ _ _).\n%reduces N2 < N3 (nat-plus-reduces-s N2 N3 _).\n%total {D1} (nat-plus-reduces-s _ _ D1).\n\n\n\nnat-less-plus\t: nat-less N1 N2\n\t\t   -> nat-plus N1 (nat/s _) N2\n\t\t   -> type.\n%mode nat-less-plus +D1 -D2.\n\n\n-\t: nat-less-plus nat-less/z nat-plus/z.\n\n-\t: nat-less-plus (nat-less/s DL) (nat-plus/s DP)\n\t   <- nat-less-plus DL DP.\n\n%worlds () (nat-less-plus _ _).\n%total {D1} (nat-less-plus D1 _).\n\n\n\nnat-plus-z\t: {N}\n\t\t   nat-plus N nat/z N\n\t\t   -> type.\n%mode nat-plus-z +D1 -D2.\n\n-\t: nat-plus-z nat/z nat-plus/z.\n\n-\t: nat-plus-z _ (nat-plus/s DP)\n\t   <- nat-plus-z _ DP.\n\n%worlds () (nat-plus-z _ _).\n%total {D1} (nat-plus-z D1 _).\n\n\n\nnat-plus-s\t: nat-plus N1 N2 N3\n\t\t   -> nat-plus N1 (nat/s N2) (nat/s N3)\n\t\t   -> type.\n%mode nat-plus-s +D1 -D2.\n\n-\t: nat-plus-s nat-plus/z nat-plus/z.\n\n-\t: nat-plus-s (nat-plus/s DP1) (nat-plus/s DP2)\n\t   <- nat-plus-s DP1 DP2.\n\n%worlds () (nat-plus-s _ _).\n%total {D1} (nat-plus-s D1 _).\n\n\n\nnat-plus-commute\t: nat-plus N1 N2 N3\n\t\t\t   -> nat-plus N2 N1 N3\n\t\t\t   -> type.\n%mode nat-plus-commute +D1 -D2.\n\n-\t: nat-plus-commute nat-plus/z DP\n\t   <- nat-plus-z _ DP.\n\n-\t: nat-plus-commute (nat-plus/s DP1) DP2\n\t   <- nat-plus-commute DP1 DP1'\n\t   <- nat-plus-s DP1' DP2.\n\n%worlds () (nat-plus-commute _ _).\n%total {D1} (nat-plus-commute D1 _).\n\n\n\nnat-less-reduces\t: {N1}{N2}\n\t\t\t   nat-less N1 N2\n\t\t\t   -> type.\n%mode nat-less-reduces +D1 +D2 +D3.\n\n-\t: nat-less-reduces _ _ DL\n\t   <- nat-less-plus DL DP\n\t   <- nat-plus-commute DP DP'\n\t   <- nat-plus-reduces-s _ _ DP'.\n\n%worlds () (nat-less-reduces _ _ _).\n%reduces N1 < N2 (nat-less-reduces N1 N2 _).\n%total {} (nat-less-reduces _ _ _).</twelf>\n\n[[Category:Twelf code]]"
          },
          "sha1": "l8bpsmnutpg7dbk3mkscvzqkirj75o5"
        }
      },
      {
        "title": "Verifications and uses",
        "ns": 0,
        "id": 2224,
        "revision": {
          "id": 6165,
          "parentid": 6159,
          "timestamp": "2010-10-17T04:42:51Z",
          "contributor": {
            "username": "Cmartens",
            "id": 35
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 12598,
            "#text": "%{ This article describes a Twelf formalization of \nlogic in terms of ''verifications'' and ''uses'' and a Twelf proof of global soundness and completeness \nfor this logic. For a full discussion of logics of verifications and uses, see \nFrank Pfenning's [http://www.cs.cmu.edu/~fp/courses/15816-s10/lectures/01-judgments.pdf lecture notes] \nfrom the spring 2010 course on Modal Logic. \nTwo critical properties of a logic are  its ''global completeness'' - that in any situation where we can \nuse a proof of <tt>A</tt> we can also verify <tt>A</tt> - \nand its ''global soundness'' - if we can verify the truth of proposition <tt>A</tt>, and then use an assumption\nthat <tt>A</tt> is true to verify the truth of <tt>B</tt>, then we can also verify the truth of \n<tt>B</tt> without the assumption that <tt>A</tt> is true.\n\nWe can also think of the logic of verifications of uses, by way of the [[w:Curry-Howard correspondence|Curry-Howard correspondence]], as\na (\"Church-style\") [[intrinsic encoding]] of the [[canonical forms]] of the [[simply-typed lambda calculus]]. In this view, the\nconstructive content of the global completeness theorem is η-expansion and the constructive content of\nglobal soundness is [[hereditary substitution]]. Therefore, this article is closely connected to the case\nstudy on [[hereditary substitution for the STLC]]. The case study is structured quite differently than this\narticle, however. That article defines a terminating partial function called \"hereditary substitution\" \nthat operates on untyped (\"Curry-style\") lambda-calculus terms, and then works through the process of showing that, \ngiven well-typed inputs, the function is actually total. That view is helpful when thinking about dependent type \nsystems, [[bidirectional type checking]], or the implementation of a logical framework, but\ncertain problems can be greatly simplified when we think of terms as intrinsically typed. }% \n\n%{ == Propositions and rules == }%\n\n%{ The following is a straightforward representation of a natural deduction\nsystem with verifications and uses, with one exception: in most presentations, \n<tt>use A</tt> and <tt>hyp A</tt> are conflated, which makes the \n<tt>var</tt> rule unnecessary. However, it is somewhat convenient \nto do things this way, and also foreshadows a number of other interesting\ndevelopments. }%\n\nprop : type.\natom : type.\n%block bl_atom : block {qp : atom}.\n\na : atom -> prop.\n⊃ : prop -> prop -> prop. %infix right 9 ⊃.\n∧ : prop -> prop -> prop. %infix right 8 ∧.\n\nhyp   : prop -> type.\nverif : prop -> type.\nuse   : prop -> type.\n%block bl_hyp : some {A : prop} block {x : hyp A}.\n\nvar : hyp A -> use A.\natm : use (a Q) -> verif (a Q).\n⊃I  : (hyp A -> verif B) -> verif (A ⊃ B).\n⊃E  : use (A ⊃ B) -> verif A -> use B.\n∧I  : verif A -> verif B -> verif (A ∧ B).\n∧E₁ : use (A ∧ B) -> use A.\n∧E₂ : use (A ∧ B) -> use B.\n\n%{ == Global completeness == }%\n\n%{ The global completeness (or η-expansion) theorem for the logic of verifications and uses\nis expressed by the  theorem: if we can use a proof that use <tt>A</tt> under certain assumptions, then\nunder the same assumptions we can verify that <tt>A</tt> is true. It is therefore critical to note that \nthe output of the global completeness theorem is a function <tt>(use A -> verif A)</tt> and not a function \n<tt>(hyp A -> verif A)</tt>. Assumptions of <tt>hyp A</tt> alone are sufficient to describe the logic itself, \nbut in order to describe completeness we have to actually assume proofs of <tt>use A</tt>. }%\n\neta : {A : prop} (use A -> verif A) -> type.\n%mode eta +A -N.\n\n- : eta (a Q) ([r] atm r).\n- : eta (A ⊃ B) ([r] ⊃I ([y] (N₂ (⊃E r (N₁ (var y))))))\n     <- eta A ([r₁] N₁ r₁)\n     <- eta B ([r₂] N₂ r₂).\n- : eta (A ∧ B) ([r] ∧I (N₁ (∧E₁ r)) (N₂ (∧E₂ r)))\n     <- eta A ([r₁] N₁ r₁)\n     <- eta B ([r₂] N₂ r₂).\n\n%worlds (bl_atom | bl_hyp) (eta _ _).\n%total A (eta A _).\n\n%{ == Detour == }%\n\n%{ Before we proceed to global soundness, we \nhave to deal with the core annoyance of doing things \nnatural-deduction style as opposed to sequent-calculus style. \nIt is unavoidable that we must consider the case where we substitute\na verification into a use - if we associate the the metavariables \n<tt>M</tt> and <tt>N</tt> with derivations of <tt>verif A</tt> and \nthe metavariable <tt>R</tt> with \nderivations of <tt>use B</tt>, this looks like <tt>[N/x]R</tt>. In these\ncases, we have to do something very different depending on whether\nthe \"head variable\" (the variable all the way on the inside of <tt>R</tt>) \nis <tt>x</tt> (the variable we're substituting for) or\nwhether it is something else. \nSpecifically, if the variable is <tt>x</tt> we need to substitute\n<tt>N</tt> in and then perform a series of reductions, but \nif it is something else we can leave the structure of the term basically the \nsame. \n\nThe tutorial on [[hereditary substitution for the STLC]] deals with this \nproblem by defining hereditary substitution in such a way that Twelf cannot\nimmediately establish that it is total, and then showing totality after the\nfact. We want to immediately establish totality, and to do this we will\ndefine a judgment that asks \"am I in the case where I need to have a series\nof reductions performed (<tt>reduce_me</tt>), or are such\nreductions unnecessary (<tt>just_fine</tt>)? }%\n\njust_fine : (hyp A -> use B) -> type.\njfx  : just_fine ([x] var Y).\njf⊃  : just_fine ([x] R x) -> just_fine ([x] ⊃E (R x) (M x)).\njf∧₁ : just_fine ([x] R x) -> just_fine ([x] ∧E₁ (R x)).\njf∧₂ : just_fine ([x] R x) -> just_fine ([x] ∧E₂ (R x)).\n\nreduce_me : (hyp A -> use B) -> type.\nrmx  : reduce_me ([x] var x).\nrm⊃  : reduce_me ([x] R x) -> reduce_me ([x] ⊃E (R x) (M x)).\nrm∧₁ : reduce_me ([x] R x) -> reduce_me ([x] ∧E₁ (R x)).\nrm∧₂ : reduce_me ([x] R x) -> reduce_me ([x] ∧E₂ (R x)).\n\njf_or_rm : (hyp A -> use B) -> type.\nrm : reduce_me ([x] R x) -> jf_or_rm ([x] R x).\njf : just_fine ([x] R x) -> jf_or_rm ([x] R x).\n\n%{ Now, we prove a metatheorem that ''every'' possible substitution instance\neither needs to ask hereditary substitution to <tt>reduce_me</tt>\nor else is <tt>just_fine</tt>. This has to use a bunch of \n[[output factoring]] lemmas but is otherwise straightforward. }%\n\nalways_jf_or_rm : {R : hyp A -> use B} jf_or_rm ([x] R x) -> type.\n%mode always_jf_or_rm +R -JFRM. \n\n- : always_jf_or_rm ([x] var x) (rm rmx).\n- : always_jf_or_rm ([x] var Y) (jf jfx).\n\nlem : jf_or_rm ([x] R x) -> {N} jf_or_rm ([x] ⊃E (R x) (N x)) -> type.\n- : lem (jf JF) _ (jf (jf⊃ JF)).\n- : lem (rm RM) _ (rm (rm⊃ RM)).\n%mode lem +JFRM +N -JFRM'. \n%worlds (bl_atom | bl_hyp) (lem _ _ _). \n%total {} (lem _ _ _).\n\n- : always_jf_or_rm ([x] ⊃E (R x) (N x)) JFRM'\n     <- always_jf_or_rm ([x] R x) (JFRM : jf_or_rm ([x] R x))\n     <- lem JFRM ([x] N x) (JFRM' : jf_or_rm ([x] ⊃E (R x) (N x))).\n\nlem : jf_or_rm ([x] R x) -> jf_or_rm ([x] ∧E₁ (R x)) -> type.\n- : lem (jf JF) (jf (jf∧₁ JF)).\n- : lem (rm RM) (rm (rm∧₁ RM)).\n%mode lem +JFRM -JFRM'.\n%worlds (bl_atom | bl_hyp) (lem _ _).\n%total {} (lem _ _).\n\n- : always_jf_or_rm ([x] ∧E₁ (R x)) JFRM'\n     <- always_jf_or_rm ([x] R x) (JFRM : jf_or_rm ([x] R x))\n     <- lem JFRM (JFRM' : jf_or_rm ([x] ∧E₁ (R x))).\n\nlem : jf_or_rm ([x] R x) -> jf_or_rm ([x] ∧E₂ (R x)) -> type.\n- : lem (jf JF) (jf (jf∧₂ JF)).\n- : lem (rm RM) (rm (rm∧₂ RM)).\n%mode lem +JFRM -JFRM'.\n%worlds (bl_atom | bl_hyp) (lem _ _).\n%total {} (lem _ _).\n\n- : always_jf_or_rm ([x] ∧E₂ (R x)) JFRM'\n     <- always_jf_or_rm ([x] R x) (JFRM : jf_or_rm ([x] R x))\n     <- lem JFRM (JFRM' : jf_or_rm ([x] ∧E₂ (R x))).\n\n%worlds (bl_atom | bl_hyp) (always_jf_or_rm _ _).\n%total R (always_jf_or_rm R _).\n\n%{ One way to avoid this ugly detour is to use [[spine form]], another way is considered in the page on [[verifications and uses with zippers]]. }%\n\n%{ == Global soundness == }%\n\n%{ Showing that every (hyp A -> use B) always either is <tt>just_fine</tt>\nor needs hereditary substitution to <tt>reduce_me</tt> is the entirety of the \n\"ugly\" part of the hereditary substitution/global completeness, theorem. The \ntheorem is made up of four mutually inductive theorems. \n\n* <tt>hsubst_n</tt> represents substitutions <tt>[M<sub>0</sub>/x]M</tt>.\n* <tt>hsubst_r</tt> represents substitutions <tt>[M<sub>0</sub>/x]R</tt> where <tt>R</tt> has atomic type. It is basically an [[output factoring]] lemma that dispatches to <tt>hsubst_rr</tt> and <tt>hsubst_rn</tt>.\n* <tt>hsubst_rr</tt> represents substitutions <tt>[M<sub>0</sub>/x]R</tt> where the variable <tt>x</tt> is not the root of <tt>R</tt>.\n* <tt>hsubst_rn</tt> represents substitutions <tt>[M<sub>0</sub>/x]R</tt> where the variable <tt>x</tt> '''is''' the root of <tt>R</tt>. This means that if we substitute <tt>M<sub>0</sub></tt> for x and then start reducing the use <tt>R</tt>, we will get back a verification <tt>N</tt>. Luckily, the type of <tt>N</tt> is known ahead of time, and so we can use this to know something about the shape of <tt>N</tt>. This case makes critical use of a <tt>[[%reduces]]</tt> declaration, and is also the only case where the type <tt>A</tt> is different in a recursive call. }%\n\nhsubst_n : {A}{M₀ : verif A}{M : hyp A -> verif B} verif B -> type.\nhsubst_r : {A}{M₀ : verif A}{R : hyp A -> use (a Q)} jf_or_rm R -> verif (a Q) -> type.\nhsubst_rr: {A}{M₀ : verif A}{R : hyp A -> use B} just_fine R -> use B -> type.\nhsubst_rn: {A}{B}{M₀ : verif A}{R : hyp A -> use B} reduce_me R -> verif B -> type.\n%mode hsubst_n +A +M₀ +M -N.\n%mode hsubst_r +A +M₀ +R +JFRM -N.\n%mode hsubst_rr +A +M +R +JF -N.\n%mode hsubst_rn +A +B +M +R +RM -N.\n\n- : hsubst_n A M₀ ([x] ⊃I [y] M x y) (⊃I [y] N y)\n     <- {y : hyp B₁} hsubst_n A M₀ ([x] M x y) (N y : verif B₂).\n- : hsubst_n A M₀ ([x] ∧I (M₁ x) (M₂ x)) (∧I N₁ N₂)\n     <- hsubst_n A M₀ ([x] M₁ x) (N₁ : verif B₁)\n     <- hsubst_n A M₀ ([x] M₂ x) (N₂ : verif B₂).\n- : hsubst_n A M₀ ([x] atm (R x)) N\n     <- always_jf_or_rm ([x] R x) (JFRM : jf_or_rm ([x] R x))\n     <- hsubst_r A M₀ ([x] R x) JFRM N.\n\n- : hsubst_r A M₀ ([x] R x) (jf JF) (atm R')\n     <- hsubst_rr A M₀ ([x] R x) JF R'.\n- : hsubst_r A M₀ ([x] R x) (rm RM) N\n     <- hsubst_rn A _ M₀ ([x] R x) RM N.\n\n- : hsubst_rr A M₀ ([x] ⊃E (R x) (M x)) (jf⊃ JF) (⊃E R' N)\n     <- hsubst_rr A M₀ ([x] R x) JF R' \n     <- hsubst_n A M₀ ([x] M x) N.\n- : hsubst_rr A M₀ ([x] ∧E₁ (R x)) (jf∧₁ JF) (∧E₁ R')\n     <- hsubst_rr A M₀ ([x] R x) JF R'.\n- : hsubst_rr A M₀ ([x] ∧E₂ (R x)) (jf∧₂ JF) (∧E₂ R')\n     <- hsubst_rr A M₀ ([x] R x) JF R'.\n- : hsubst_rr A M₀ ([x] var Y) jfx (var Y).\n\n- : hsubst_rn A B₂ M₀ ([x] ⊃E (R x) (M x)) (rm⊃ RM) N'\n     <- hsubst_rn A (B₁ ⊃ B₂) M₀ ([x] R x) RM ((⊃I [y] N y) : verif (B₁ ⊃ B₂))\n     <- hsubst_n A M₀ ([x] M x) (M' : verif B₁)\n     <- hsubst_n B₁ M' N (N': verif B₂).\n- : hsubst_rn A B₁ M₀ ([x] ∧E₁ (R x)) (rm∧₁ RM) N₁\n     <- hsubst_rn A (B₁ ∧ B₂) M₀ ([x] R x) RM (∧I N₁ N₂ : verif (B₁ ∧ B₂)).\n- : hsubst_rn A B₂ M₀ ([x] ∧E₂ (R x)) (rm∧₂ RM) N₂\n     <- hsubst_rn A (B₁ ∧ B₂) M₀ ([x] R x) RM (∧I N₁ N₂ : verif (B₁ ∧ B₂)).\n- : hsubst_rn A A M₀ ([x] var x) rmx M₀.\n\n%worlds (bl_atom | bl_hyp)\n(hsubst_n _ _ _ _)\n(hsubst_r _ _ _ _ _) \n(hsubst_rr _ _ _ _ _) \n(hsubst_rn _ _ _ _ _ _).\n\n%{ A critical part of proving termination is showing that, during the hereditary substitution process, the second argument is no larger than the first - this is why\nwe are allowed to make the recursive call <tt>hsubst_n B<sub>1</sub> M' N (N': verif B<sub>2</sub>)</tt> in the <tt>&sup;E</tt> case of <tt>hsubst_rn</tt>: we know <tt>A</tt> is no larger than <tt>B<sub>1</sub> &sup; B<sub>2</sub></tt>, and therefore <tt>B<sub>2</sub></tt> is strictly smaller.\nThis is established by the following <tt>[[%reduces]]</tt> declaration. }%\n\n%reduces B <= A (hsubst_rn A B _ _ _ _).\n\n%{ The completeness of hereditary substitution is established first by lexicographic induction, \nfirst on the type <tt>A</tt> and second on the term <tt>M</tt>\nthat we are substituting into.\nThe statement of <tt>hsubst_r</tt> has to come after <tt>hsubst_rr</tt> and\n<tt>hsubst_rn</tt> in order for termination checking to work, because the \nformer theorem calls the latter two theorems with all the same arguments. }%\n\n%total {(A B C D) (M R S T)}\n(hsubst_n A _ M _)\n(hsubst_rr C _ S _ _) \n(hsubst_rn D _ _ T _ _)\n(hsubst_r B _ R _ _)."
          },
          "sha1": "syh5ledp5mn1qut0l435cxbc1qfnoim"
        }
      },
      {
        "title": "Verifications and uses in HLF",
        "ns": 0,
        "id": 2228,
        "revision": {
          "id": 6158,
          "parentid": 6157,
          "timestamp": "2010-09-21T05:18:17Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 4939,
            "#text": "%{ This example can only be run in the Hybrid LF implementation of Twelf \ncreated by Jason Reed as part of his Ph.D. Thesis, \n\"A Hybrid Logical Framework.\" It shouldn't be suprising that the\nlittle box to the right says \"Status: %% ABORT %%,\" in other words. The example on [[verifications and uses with zippers]] has essentially the same content but actually works in non-HLF extended Twelf.\n\nThis code is primarily here so it can be referenced by a [http://requestforlogic.blogspot.com/2010/09/natural-deduction-and-sequent-calculus.html blog post] by [[User:Rsimmons|Rob]]. \n}%\n\n%hlf.\n\n%{ == Propositions and rules == }% \n\nprop : type.\natom : type.\n%block bl_atom : block {qp : atom}.\n\na : atom -> prop.\n⊃ : prop -> prop -> prop. %infix right 9 ⊃.\n∧ : prop -> prop -> prop. %infix right 8 ∧.\n\nhyp   : prop -> @type.\nverif : prop -> @type.\nuse   : prop -> @type.\n\natm : hyp A -> (use A -o use (a Q)) -> verif (a Q).\n⊃I  : (hyp A₁ -> verif A₂) -> verif (A₁ ⊃ A₂).\n⊃E  : use (A₁ ⊃ A₂) -o verif A₁ -> use A₂.\n∧I  : verif A₁ -> verif A₂ -> verif (A₁ ∧ A₂).\n∧E₁ : use (B₁ ∧ B₂) -o use B₁.\n∧E₂ : use (B₁ ∧ B₂) -o use B₂.\n\n%block bl_hyp : some {A : prop} block {x : hyp A e}.\n%block bl_use : some {A : prop} block {α}{x : use A α}.\n%worlds (bl_atom | bl_hyp | bl_use) (verif _ _) (use _ _) (hyp _ _).\n\n%{ == Global completeness == }%\n\neta : {A} ({B} hyp B -> (use B -o use A) -> verif A) -> type.\n%mode eta +A -B.\n\n- : eta (a Q) ([B][x : hyp B][r : use B -o use (a Q)] \n          atm x ([u :^ (use B)] r ^ u)).\n- : eta (A₁ ⊃ A₂) ([B][x : hyp B][r : use B -o use (A₁ ⊃ A₂)] \n          ⊃I ([y : hyp A₁] N₂ B x ([u :^ (use B)]\n            ⊃E ^ (r ^ u) (N₁ A₁ y ([u :^ (use A₁)] u)))))\n     <- eta A₁ ([B] N₁ B : hyp B -> (use B -o use A₁) -> verif A₁)\n     <- eta A₂ ([B] N₂ B : hyp B -> (use B -o use A₂) -> verif A₂).\n- : eta (A₁ ∧ A₂) ([B][x : hyp B][r : use B -o use (A₁ ∧ A₂)]\n          ∧I (N₁ B x ([u :^ (use B)] ∧E₁ ^ (r ^ u))) \n             (N₂ B x ([u :^ (use B)] ∧E₂ ^ (r ^ u))))\n     <- eta A₁ ([B] N₁ B : hyp B -> (use B -o use A₁) -> verif A₁)\n     <- eta A₂ ([B] N₂ B : hyp B -> (use B -o use A₂) -> verif A₂).\n\n%worlds (bl_atom | bl_hyp | bl_use) (eta _ _).\n%total A (eta A _).\n\n%solve s : {q}{r}{s} eta (a q ⊃ a r ⊃ a s) (X q r s).\n%solve s : {q}{r}{s} eta ((a q ⊃ a r) ⊃ a s) (X q r s).\n\n%{ == Global soundness == }%\n\nhsubst_n  : {A}    verif A -> (hyp A -> verif B)        -> verif B -> type.\nhsubst_rr : {A}    verif A -> (hyp A -> use C -o use B) -> (use C -o use B) -> type.\nhsubst_rn : {A}{B} verif A -> (hyp A -> use A -o use B) -> verif B -> type.\n%mode hsubst_n  +A    +M₀ +M -N.\n%mode hsubst_rr +A    +M₀ +R -R'.\n%mode hsubst_rn +A +B +M₀ +R -N.\n\n- : hsubst_n A M₀ ([x : hyp A] ⊃I [y : hyp B₁] M x y) (⊃I [y : hyp B₁] N y)\n     <- {y : hyp B₁} hsubst_n A M₀ ([x : hyp A] M x y) (N y : verif B₂).\n- : hsubst_n A M₀ ([x : hyp A] ∧I (M₁ x) (M₂ x)) (∧I N₁ N₂)\n     <- hsubst_n A M₀ M₁ (N₁ : verif B₁)\n     <- hsubst_n A M₀ M₂ (N₂ : verif B₂).\n- : hsubst_n A M₀ ([x : hyp A] atm x ([u :^ (use A)] R x ^ u)) N\n     <- hsubst_rn A (a Q) M₀ R (N : verif (a Q)).\n- : hsubst_n A M₀ ([x : hyp A] atm Y (R x)) (atm Y R')\n     <- hsubst_rr A M₀ R (R' : use C -o use (a Q)).\n\n- : hsubst_rr A M₀ ([x : hyp A][u :^ (use C)] ⊃E ^ (R x ^ u) (M x)) \n          ([u :^ (use C)] ⊃E ^ (R' ^ u) N)        \n     <- hsubst_rr A M₀ R (R' : use C -o use (B₁ ⊃ B₂)) \n     <- hsubst_n A M₀ M (N : verif B₁).\n- : hsubst_rr A M₀ ([x : hyp A][u :^ (use C)] ∧E₁ ^ (R x ^ u)) \n          ([u :^ (use C)] ∧E₁ ^ (R' ^ u))\n     <- hsubst_rr A M₀ R (R' : use C -o use (B₁ ∧ B₂)).\n- : hsubst_rr A M₀ ([x : hyp A][u :^ (use C)] ∧E₂ ^ (R x ^ u)) \n          ([u :^ (use C)] ∧E₂ ^ (R' ^ u))\n     <- hsubst_rr A M₀ R (R' : use C -o use (B₁ ∧ B₂)).\n- : hsubst_rr A M₀ ([x : hyp A][u :^ (use C)] u) ([u :^ (use C)] u).\n\n- : hsubst_rn A B₂ M₀ ([x : hyp A][u :^ (use A)] ⊃E ^ (R x ^ u) (M x)) N'\n     <- hsubst_rn A (B₁ ⊃ B₂) M₀ R ((⊃I [y : hyp B₁] N y) : verif (B₁ ⊃ B₂))\n     <- hsubst_n A M₀ M (M' : verif B₁)\n     <- hsubst_n B₁ M' N (N' : verif B₂).\n- : hsubst_rn A B₁ M₀ ([x : hyp A][u :^ (use A)] ∧E₁ ^ (R x ^ u)) N₁\n     <- hsubst_rn A (B₁ ∧ B₂) M₀ R (∧I N₁ N₂ : verif (B₁ ∧ B₂)).\n- : hsubst_rn A B₂ M₀ ([x : hyp A][u :^ (use A)] ∧E₂ ^ (R x ^ u)) N₂\n     <- hsubst_rn A (B₁ ∧ B₂) M₀ R (∧I N₁ N₂ : verif (B₁ ∧ B₂)).\n- : hsubst_rn A A M₀ ([x : hyp A][u :^ (use A)] u) M₀.\n\n%worlds (bl_atom | bl_hyp)\n(hsubst_n _ _ _ _)\n(hsubst_rr _ _ _ _) \n(hsubst_rn _ _ _ _ _).\n\n%reduces B <= A (hsubst_rn A B _ _ _).\n\n%total {(A B C) (M R S)}\n(hsubst_n A _ M _)\n(hsubst_rr B _ R _) \n(hsubst_rn C _ _ S _)."
          },
          "sha1": "tvl4448jkm54vgyc3v6v0kn6pu91eyv"
        }
      },
      {
        "title": "Verifications and uses with zippers",
        "ns": 0,
        "id": 2226,
        "revision": {
          "id": 6160,
          "parentid": 6153,
          "timestamp": "2010-09-21T05:20:57Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 6163,
            "#text": "%{ In the [[verifications and uses]] article we saw a typical presentation of a logic of verifications and uses, and in article on [[hereditary substitution with zippers]] we saw an attempt to clean up the \"ugly part\" of that proof by defining a zipper-like structure over terms. The reason that global soundness for this system did not hold is that Twelf could not verify (without the use of a [[structural metric]]) that a \"zipped\" use was the same size as an \"unzipped\" use, so [[termination checking]] failed when a recursive\ncall was made on a term that had been unzipped. \n\nIn this article, we give a different solution. This system has something of the flavor of a [[spine form]] presentation; however, as we discussed in the \n[[hereditary substitution with zippers]], it is still much closer to a natural deduction system - the analogue of the natural deduction term <tt>atm (⊃E (⊃E (⊃E (var x) N<sub>1</sub>) N<sub>2</sub>)\nN<sub>3</sub>)</tt> in the natural deduction system is \n<tt>atm x (⊃E (⊃E (⊃E end N<sub>1</sub>) N<sub>2</sub>) N<sub>3</sub>)</tt> in this version of \"natural deduction\" - the form of proofs stays the same\nwith the exception that the head variable <tt>x</tt> has been pulled out into the front. }%\n\n%{ == Propositions and rules == }%\n\nprop : type.\natom : type.\n%block bl_atom : block {qp : atom}.\n\na : atom -> prop.\n⊃ : prop -> prop -> prop. %infix right 9 ⊃.\n∧ : prop -> prop -> prop. %infix right 8 ∧.\n\nhyp   : prop -> type.\nverif : prop -> type.\nuse   : prop -> prop -> type.\n%block bl_hyp : some {A : prop} block {x : hyp A}.\n\nend : use A A.\natm : hyp A -> use A (a Q) -> verif (a Q).\n⊃I  : (hyp A -> verif B) -> verif (A ⊃ B).\n⊃E  : use A (B₁ ⊃ B₂) -> verif B₁ -> use A B₂.\n∧I  : verif A₁ -> verif A₂ -> verif (A₁ ∧ A₂).\n∧E₁ : use A (B₁ ∧ B₂) -> use A B₁.\n∧E₂ : use A (B₁ ∧ B₂) -> use A B₂.\n\n%{ == Global completeness == }%\n\n%{ Because we have changed the logic, the η-expansion theorem has changed somewhat. Recall that, in the pure system of [[verifications and uses]], the statement of global completeness/η-expansion was that, for all <tt>A</tt>, we can verify the truth of <tt>A</tt> in any context where we can use the fact that <tt>A</tt> is true. In this system, however, we don't ever use <tt>A</tt> in a vacuum - we always take a hypothesis of <tt>B</tt> and then prove that, given <tt>B</tt>, we can use <tt>A</tt>.\nThe eta expansion theorem reflects this: it says that, for any <tt>A</tt>, given an arbitrary <tt>B</tt> that we have hypothesized to be true and a proof\nthat we can use <tt>A</tt> given <tt>B</tt>, we can prove <tt>A</tt>.\n\nThe structure of the η-expansion theorem's proof is then mostly unchanged from the system of [[verifications and uses]]. }%\n\neta : {A} ({B} hyp B -> use B A -> verif A) -> type.\n%mode eta +A -B.\n\n- : eta (a Q) ([B][x][r] atm x r).\n- : eta (A₁ ⊃ A₂) ([B][x][r] ⊃I [y] N₂ B x (⊃E r (N₁ A₁ y end)))\n     <- eta A₁ ([B] N₁ B : hyp B -> use B A₁ -> verif A₁)\n     <- eta A₂ ([B] N₂ B : hyp B -> use B A₂ -> verif A₂).\n- : eta (A₁ ∧ A₂) ([B][x][r] ∧I (N₁ B x (∧E₁ r)) (N₂ B x (∧E₂ r)))\n     <- eta A₁ ([B] N₁ B : hyp B -> use B A₁ -> verif A₁)\n     <- eta A₂ ([B] N₂ B : hyp B -> use B A₂ -> verif A₂).\n\n%worlds (bl_atom | bl_hyp) (eta _ _).\n%total A (eta A _).\n\n%{ Let's see some examples of η-expansions: | check = decl }%\n\n%solve _ : {q1}{q2}{q3} eta (a q1 ⊃ a q2 ⊃ a q3) (X q1 q2 q3).\n\n%{ | check = decl }%\n\n%solve _ : {q1}{q2}{q3} eta ((a q1 ⊃ a q2) ⊃ a q3) (X q1 q2 q3).\n\n%{ == Global soundness == }%\n\n%{ The real benefit of this modified natural deduction system is that we no longer need to take any detours to prove the hereditary substitution theorem: when we reach\nthe <tt>atm</tt> case where we must verify an atomic proposition by using a proof of its truth, we know exactly what hypothesis we are using. If the\nhypothesis is the one we're substituting for, then we call out to the <tt>hsubst_rn</tt> theorem where we do repeated reductions, and if the hypothesis\nis not, we call out to the <tt>hsubst_rr</tt> theorem where the structure of the use stays essentially the same. }%\n\nhsubst_n  : {A}    verif A -> (hyp A -> verif B) -> verif B -> type.\nhsubst_rr : {A}    verif A -> (hyp A -> use C B) -> use C B -> type.\nhsubst_rn : {A}{B} verif A -> (hyp A -> use A B) -> verif B -> type.\n%mode hsubst_n  +A    +M₀ +M -N.\n%mode hsubst_rr +A    +M₀ +R -R'.\n%mode hsubst_rn +A +B +M₀ +R -N.\n\n- : hsubst_n A M₀ ([x] ⊃I [y] M x y) (⊃I [y] N y)\n     <- {y : hyp B₁} hsubst_n A M₀ ([x] M x y) (N y : verif B₂).\n- : hsubst_n A M₀ ([x] ∧I (M₁ x) (M₂ x)) (∧I N₁ N₂)\n     <- hsubst_n A M₀ ([x] M₁ x) (N₁ : verif B₁)\n     <- hsubst_n A M₀ ([x] M₂ x) (N₂ : verif B₂).\n- : hsubst_n A M₀ ([x] atm x (R x)) N\n     <- hsubst_rn A (a Q) M₀ ([x] R x) N.\n- : hsubst_n A M₀ ([x] atm Y (R x)) (atm Y R')\n     <- hsubst_rr A M₀ ([x] R x) R'.\n\n- : hsubst_rr A M₀ ([x] ⊃E (R x) (M x)) (⊃E R' N)\n     <- hsubst_rr A M₀ ([x] R x) R' \n     <- hsubst_n A M₀ ([x] M x) N.\n- : hsubst_rr A M₀ ([x] ∧E₁ (R x)) (∧E₁ R')\n     <- hsubst_rr A M₀ ([x] R x) R'.\n- : hsubst_rr A M₀ ([x] ∧E₂ (R x)) (∧E₂ R')\n     <- hsubst_rr A M₀ ([x] R x) R'.\n- : hsubst_rr A M₀ ([x] end) end.\n\n- : hsubst_rn A B₂ M₀ ([x] ⊃E (R x) (M x)) N'\n     <- hsubst_rn A (B₁ ⊃ B₂) M₀ ([x] R x) ((⊃I [y] N y) : verif (B₁ ⊃ B₂))\n     <- hsubst_n A M₀ ([x] M x) (M' : verif B₁)\n     <- hsubst_n B₁ M' ([y] N y) (N' : verif B₂).\n- : hsubst_rn A B₁ M₀ ([x] ∧E₁ (R x)) N₁\n     <- hsubst_rn A (B₁ ∧ B₂) M₀ ([x] R x) (∧I N₁ N₂ : verif (B₁ ∧ B₂)).\n- : hsubst_rn A B₂ M₀ ([x] ∧E₂ (R x)) N₂\n     <- hsubst_rn A _ M₀ ([x] R x) (∧I N₁ N₂ : verif (B₁ ∧ B₂)).\n- : hsubst_rn A A M₀ ([x] end) M₀.\n\n%worlds (bl_atom | bl_hyp)\n(hsubst_n _ _ _ _)\n(hsubst_rr _ _ _ _) \n(hsubst_rn _ _ _ _ _).\n\n%reduces B <= A (hsubst_rn A B _ _ _).\n\n%total {(A B C) (M R S)}\n(hsubst_n A _ M _)\n(hsubst_rr B _ R _) \n(hsubst_rn C _ _ S _)."
          },
          "sha1": "a7hq3i3onz8ozkkelr0695ijz6bnagu"
        }
      },
      {
        "title": "Weak focusing",
        "ns": 0,
        "id": 2179,
        "revision": {
          "id": 5935,
          "parentid": 5879,
          "timestamp": "2009-03-13T22:23:56Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 19293,
            "#text": "%{ == Polarized logic == }% \n\npolarity : type.\t\t\t%name polarity S.\npos : polarity.\nneg : polarity.\n\natm : polarity -> type.                 %name atm Q q.\nprop : polarity -> type.                %name prop A.\n\natom : atm S -> prop S.\nup : prop pos -> prop neg.\ndown : prop neg -> prop pos.\n* : prop pos -> prop pos -> prop pos.   %infix right 10 *.\n+ : prop pos -> prop pos -> prop pos.   %infix right 9 +.\n-o : prop pos -> prop neg -> prop neg.  %infix right 8 -o.\n\n%block bl_atmpos : block {qp:atm pos}.\n%block bl_atmneg : block {qn:atm neg}.\n\n\n\n%{ == Sequent calculus for polarized logic == }%\n\n%{ === Logic definition === }%\n\n%{ \nA sequent is written\n h1: hyp A1, ..., hn: hyp An |- conc A \n A1, ..., An |- A\n}%\n\nhyp : prop S -> type.                   %name hyp H h.\nconc : prop S -> type.                  %name conc D.\n\n%block bl_hyp : some {S:polarity} {A:prop S} block {h:hyp A}.\n\ninit : hyp (atom Q) -> conc (atom Q).\n\nupR : conc P\n       -> conc (up P).\nupL : (hyp P -> conc C)\n       -> (hyp (up P) -> conc C).\n\ndownL : (hyp N -> conc C)\n\t    -> (hyp (down N) -> conc C).\ndownR : conc N\n\t -> conc (down N).\n\n*R : conc P1 -> conc P2 -> conc (P1 * P2).\n*L : (hyp P1 -> hyp P2 -> conc C)\n      -> (hyp (P1 * P2) -> conc C).\n\n+R1 : conc P1 -> conc (P1 + P2).\n+R2 : conc P2 -> conc (P1 + P2).\n+L : (hyp P1 -> conc C)\n      -> (hyp P2 -> conc C)\n      -> (hyp (P1 + P2) -> conc C).\n\n-oR : (hyp P -> conc N)\n       -> (conc (P -o N)).\n-oL : conc P\n       -> (hyp N -> conc C)\n       -> (hyp (P -o N) -> conc C).\n\n%worlds (bl_atmpos | bl_atmneg | bl_hyp)\n  (hyp A) (conc C).\n\n%{ == Focused sequent calculus == }%\n\n%{ === Logic definition === }%\n\n%{ \nNeutral sequent:\n l1:left P1, ..., ln:left Pn |- right N\n P1, ..., Pn |- N\n\nLeft-focused sequent:\n l1:left P1, ..., ln:left Pn |- lfoc N1 N2\n P1, ..., Pn [N1] |- N2\n\nRight-focused sequent:\n l1:left P1, ..., ln:left Pn |- rfoc P\n P1, ..., Pn |- [P]\n\nThese can be generically expressed as:\n l1:left P1, ..., ln:left Pn |- conseq C\n P1, ..., Pn |- C\n}%\n\nleft : prop pos -> type.                %name left L l.\n\nconclusion : type.                      %name conclusion C.\nconseq : conclusion -> type.            %name conseq R.\nconc-lfoc : prop neg -> prop neg -> conclusion.\nconc-rfoc : prop pos -> conclusion.\nconc-right : prop neg -> conclusion.\n\n%abbrev rfoc = [P] conseq (conc-rfoc P).\n%abbrev lfoc = [N][N'] conseq (conc-lfoc N N').\n%abbrev right = [N] conseq (conc-right N).\n\n%block bl_left : some {P:prop pos} block {l:left P}.\n\ninitR' : left (atom Qp) -> rfoc (atom Qp).\ninitL' : lfoc (atom Qn) (atom Qn).\n\nupR' : rfoc P\n        -> right (up P).\nupL' : (left P -> right N)\n        -> (lfoc (up P) N).\n\ndownR' : right N\n          -> rfoc (down N).\ndownL' : (lfoc N N')\n          -> (left (down N) -> right N').\n\n*R' : rfoc P1\n       -> rfoc P2\n       -> rfoc (P1 * P2).\n*L' : (left P1 -> left P2 -> right N')\n       -> (left (P1 * P2) -> right N').\n\n+R1' : rfoc P1\n        -> rfoc (P1 + P2).\n+R2' : rfoc P2 \n        -> rfoc (P1 + P2).\n+L' : (left P1 -> right N')\n       -> (left P2 -> right N')\n       -> (left (P1 + P2) -> right N').\n\n-oR' : (left P -> right N) \n        -> (right (P -o N)).\n-oL' : rfoc P\n        -> (lfoc N N')\n        -> (lfoc (P -o N) N').\n\n%worlds (bl_atmpos | bl_atmneg | bl_left)\n  (left P) (conseq C).  % = (right N) (left N N') (rfoc P).\n\n%{ === Cut admissibility === }%\n\ncut< : {N} lfoc N' N -> (lfoc N NC) -> lfoc N' NC -> type.\ncut- : {N} right N -> (lfoc N NC) -> right NC -> type.\ncut+ : {P} rfoc P -> (left P -> conseq C) -> conseq C -> type.\n%mode cut< +N +D +E -F.\n%mode cut- +N +D +E -F.\n%mode cut+ +P +D +E -F.\n\n%{ ==== Identity cuts ==== }% \n\n- : cut+ (atom Qp) (initR' D) ([l] initR' l) (initR' D).\n- : cut< (atom Qn) (initL') (initL') (initL').\n\n%{ ==== Principal cuts ==== }%\n\n- : cut- (up P) (upR' (D : rfoc P)) (upL' (E : left P -> right N)) F\n     <- cut+ P D E (F : right N).\n\n- : cut+ (down N) (downR' (D : right N)) \n     ([l:left (down N)] downL' (E l : lfoc N NC) l) G\n     <- cut+ (down N) (downR' D) E (F : lfoc N NC)\n     <- cut- N D F (G : right NC).\n\n- : cut+ (P1 * P2) (*R' (D1 : rfoc P1) (D2 : rfoc P2)) \n     ([l:left (P1 * P2)] *L' (E l : left P1 -> left P2 -> right N) l) G\n     <- ({l1:left P1}{l2: left P2} \n           cut+ (P1 * P2) (*R' D1 D2) ([l:left (P1 * P2)] E l l1 l2)\n           (F l1 l2 : right N))\n     <- ({l1:left P1} cut+ P2 D2 ([l2:left P2] F l1 l2) (F' l1 : right N))\n     <- cut+ P1 D1 F' (G : right N).\n\n- : cut+ (P1 + P2) (+R1' (D1 : rfoc P1))\n     ([l:left (P1 + P2)] +L' (E1 l : left P1 -> right N) (E2 l) l) F\n     <- ({l1:left P1}\n           cut+ (P1 + P2) (+R1' D1) ([l:left (P1 + P2)] E1 l l1)\n           (E1' l1 : right N))\n     <- cut+ P1 D1 E1' (F : right N).\n\n- : cut+ (P1 + P2) (+R2' (D2 : rfoc P2))\n     ([l:left (P1 + P2)] +L' (E1 l) (E2 l : left P2 -> right N) l) F\n     <- ({l2:left P2}\n           cut+ (P1 + P2) (+R2' D2) ([l:left (P1 + P2)] E2 l l2)\n           (E2' l2 : right N))\n     <- cut+ P2 D2 E2' (F : right N).\n\n- : cut- (N -o P) (-oR' (D1 : left N -> right P))\n     (-oL' (E1 : rfoc N) (E2 : lfoc P NC)) F\n     <- cut+ N E1 D1 (F1 : right P)\n     <- cut- P F1 E2 (F : right NC).\n\n%{ ==== Left commutative cuts ==== }%\n\n- : cut< N (upL' D) E (upL' F)\n     <- ({l1} cut- N (D l1) E (F l1)).\n- : cut- N (downL' D L) E (downL' F L)\n     <- cut< N D E F.\n- : cut- N (*L' D L) E (*L' F L)\n     <- ({l1}{l2} cut- N (D l1 l2) E (F l1 l2)).\n- : cut- N (+L' D1 D2 L) E (+L' F1 F2 L)\n     <- ({l1} cut- N (D1 l1) E (F1 l1))\n     <- ({l2} cut- N (D2 l2) E (F2 l2)).\n- : cut< N (-oL' D1 D2) E (-oL' D1 F2)\n     <- cut< N D2 E F2.\n\n%{ ==== Right commutative cuts ==== }%\n\n- : cut+ P D ([l] initR' L) (initR' L).\n- : cut+ P D ([l] initL') (initL').\n- : cut+ P D ([l] upR' (E l)) (upR' F)\n     <- cut+ P D ([l] E l) F.\n- : cut+ P D ([l] upL' [l1] E l l1) (upL' F)\n     <- ({l1} cut+ P D ([l] E l l1) (F l1)).\n- : cut+ P D ([l] downR' (E l)) (downR' F)\n     <- cut+ P D ([l] E l) F.\n- : cut+ P D ([l] downL' (E l) L) (downL' F L)\n     <- cut+ P D ([l] E l) F.\n- : cut+ P D ([l] *R' (E1 l) (E2 l)) (*R' F1 F2)\n     <- cut+ P D ([l] E1 l) F1\n     <- cut+ P D ([l] E2 l) F2.\n- : cut+ P D ([l] *L' ([l1][l2] E l l1 l2) L)\n     (*L' ([l1][l2] F l1 l2) L)\n     <- ({l1}{l2} cut+ P D ([l] E l l1 l2) (F l1 l2)).\n- : cut+ P D ([l] +R1' (E l)) (+R1' F)\n     <- cut+ P D ([l] E l) F.\n- : cut+ P D ([l] +R2' (E l)) (+R2' F)\n     <- cut+ P D ([l] E l) F.\n- : cut+ P D ([l] +L' ([l1] E1 l l1) ([l2] E2 l l2) L)\n     (+L' F1 F2 L)\n     <- ({l1} cut+ P D ([l] E1 l l1) (F1 l1))\n     <- ({l2} cut+ P D ([l] E2 l l2) (F2 l2)).\n- : cut+ P D ([l] -oR' (E l)) (-oR' F)\n     <- {l1} cut+ P D ([l] E l l1) (F l1).\n- : cut+ P D ([l] -oL' (E1 l) (E2 l)) (-oL' F1 F2)\n     <- cut+ P D ([l] E1 l) F1\n     <- cut+ P D ([l] E2 l) F2.\n\n%worlds (bl_atmpos | bl_atmneg | bl_left)\n(cut< _ _ _ _)\n(cut- _ _ _ _)\n(cut+ _ _ _ _).\n\n%total {(N1 N2 P3) [(D1 D2 D3) (E1 E2 E3)]}\n(cut< N1 D1 E1 _)\n(cut+ N2 D2 E2 _)\n(cut- P3 D3 E3 _).\n\n%{ ==== Corollary - unfocused cut ==== }%\n\ncut-unfoc+ : right (up P) -> (left P -> right N) -> right N -> type.\n%mode cut-unfoc+ +D +E -F.\n\n- : cut-unfoc+ D E F\n     <- cut- (up P) D (upL' E) F.\n\n%worlds (bl_atmpos | bl_atmneg | bl_left) (cut-unfoc+ _ _ _).\n%total [] (cut-unfoc+ _ _ _).\n\ncut-unfoc- : right A -> (left (down A) -> right C) -> right C -> type.\n%mode cut-unfoc- +A +B -C.\n\n- : cut-unfoc- D E F\n     <- cut+ (down A) (downR' D) E F.\n\n%worlds (bl_atmpos | bl_atmneg | bl_left) (cut-unfoc- _ _ _).\n%total [] (cut-unfoc- _ _ _).\n\n\n\n%{ === Identity === }%\n\n%{ ==== Eta expansion lemmas ==== }%\n\neta- : {N:prop neg} ({N':prop neg} lfoc N N' -> right N') -> right N -> type.\neta+ : {P:prop pos} (rfoc P -> right N') -> (left P -> right N') -> type.\n%mode eta- +N +R -R'.\n%mode eta+ +P +R -R'.\n\n%block bl_rfoc : some {P:prop pos} block {rf:rfoc P}.\n\n- : eta+ (atom Qp) ([rf] R rf) ([l] R (initR' l)).\n\n- : eta- (atom Qn) ([n'] [lf] R n' lf) (R (atom Qn) initL').\n\n- : eta- (up P) ([n'] [lf] R n' lf) (R (up P) (upL' ([l] R' l)))\n     <- eta+ P ([rf] upR' rf) ([l] R' l).\n\n- : eta+ (down N) ([rf] R rf) ([l:left (down N)] R (downR' (R' l))) \n     <- ({l:left (down N)} eta- N ([n'] [lf] downL' lf l) (R' l)). \n\n- : eta+ (P1 * P2) ([rf] R rf) ([l] *L' ([l1] [l2] R'' l1 l2) l)\n     <- ({rf1:rfoc P1} eta+ P2 ([rf2] R (*R' rf1 rf2)) ([l2] R' rf1 l2))\n     <- ({l2:left P2} eta+ P1 ([rf1] R' rf1 l2) ([l1] R'' l1 l2)).\n\n- : eta+ (P1 + P2) ([rf] R rf) (+L' R1 R2)\n     <- eta+ P1 ([rf1] R (+R1' rf1)) ([l1:left P1] R1 l1 : right N)\n     <- eta+ P2 ([rf1] R (+R2' rf1)) ([l2:left P2] R2 l2 : right N).\n\n- : eta- (P1 -o N2) ([n'] [lf] R n' lf) (-oR' [l1] R1 l1)\n     <- ({rf1:rfoc P1}\n           eta- N2 ([n'] [lf2] R n' (-oL' rf1 lf2)) (R2  rf1))\n     <- eta+ P1 ([rf1] R2 rf1) ([l1] R1 l1).\n\n%worlds (bl_atmpos | bl_atmneg | bl_left | bl_rfoc)\n  (eta- N R R') (eta+ P R R').\n\n%total (N P) (eta- N _ _) (eta+ P _ _).\n\n\n%{ ==== Identity corollaries ==== }%\n\nidp : {P:prop pos} (left P -> right (up P)) -> type.\n%mode idp +P -R.\n\n- : idp P R <- eta+ P ([rf] upR' rf) R.\n\n%worlds (bl_atmpos | bl_atmneg | bl_left | bl_rfoc) (idp _ _).\n%total [] (idp _ _).\n\nidn : {N:prop neg} (left (down N) -> right N) -> type.\n%mode idn +N -R.\n\n- : idn N ([l] R l)\n     <- ({l:left (down N)} eta- N ([qn] [lf] downL' lf l) (R l)). \n\n%worlds (bl_atmpos | bl_atmneg | bl_left | bl_rfoc) (idn _ _).\n%total [] (idn _ _).\n\n\n\n%{ == Soundness == }%\n\nsdR : right N -> conc N -> type.\nsd+ : rfoc P -> conc P -> type.\nsd- : lfoc N N' -> (hyp N -> conc N') -> type.\nsdL : left P -> hyp P -> type.\n%mode sdR +R -D.\n%mode sd+ +R -D.\n%mode sd- +R -D.\n%mode sdL +L -H.\n\n- : sd+ (initR' L) (init H)\n     <- sdL L H.\n- : sd- (initL') ([h] init h).\n- : sdR (upR' R) (upR D)\n     <- sd+ R D.\n- : sd- (upL' [l] R l) ([h] upL ([hp] D hp) h)\n     <- ({l} {hp} sdL l hp -> sdR (R l) (D hp)).\n- : sd+ (downR' R) (downR D)\n     <- sdR R D.\n- : sdR (downL' R L) (downL ([hn] D hn) H)\n     <- sd- R ([hn] D hn)\n     <- sdL L H.\n- : sd+ (*R' R1 R2) (*R D1 D2)\n     <- sd+ R1 D1\n     <- sd+ R2 D2.\n- : sdR (*L' ([l1] [l2] R l1 l2) L12) (*L ([h1] [h2] D h1 h2) H12)\n     <- ({l1} {h1} sdL l1 h1\n           -> {l2} {h2} sdL l2 h2\n           -> sdR (R l1 l2) (D h1 h2))\n     <- sdL L12 H12.\n- : sd+ (+R1' R1) (+R1 D1)\n     <- sd+ R1 D1.\n- : sd+ (+R2' R2) (+R2 D2)\n     <- sd+ R2 D2.\n- : sdR (+L' ([l1] R1 l1) ([l2] R2 l2) L) (+L ([h1] D1 h1) ([h2] D2 h2) H)\n     <- ({l1} {h1} sdL l1 h1 -> sdR (R1 l1) (D1 h1))\n     <- ({l2} {h2} sdL l2 h2 -> sdR (R2 l2) (D2 h2))\n     <- sdL L H.\n- : sdR (-oR' [l] R l) (-oR [h] D h)\n     <- ({l} {h} sdL l h -> sdR (R l) (D h)).\n- : sd- (-oL' R1 R2) ([h] -oL D1 ([h2] D2 h2) h)\n     <- sd+ R1 D1\n     <- sd- R2 ([h2] D2 h2).\n\n%block bl_sdL : some {P:prop pos} block {l:left P} {h:hyp P} {_:sdL l h}.\n\n%worlds (bl_atmpos | bl_atmneg | bl_sdL) (sdR _ _) (sd+ _ _) (sd- _ _) (sdL _ _).\n%total [] (sdL _ _).\n%total (R1 R2 R3) (sdR R1 _) (sd+ R2 _) (sd- R3 _).\n\n\n\n%{ == Completeness == }%\n\n%{ === Unfocused admissibility === }%\n\nadm*R : right (up P1) -> right (up P2) -> right (up (P1 * P2)) -> type.\n%mode adm*R +R1 +R2 -R.\n\n- : adm*R (R1 : right (up P1)) (R2 : right (up P2)) R\n     <- ({rf1:rfoc P1} eta+ P2 ([rf2:rfoc P2] upR' (*R' rf1 rf2)) \n           ([l2:left P2] R3 rf1 l2))\n     <- ({l2:left P2} eta+ P1 ([rf1:rfoc P1] R3 rf1 l2) ([l1] R4 l1 l2))\n     <- ({l2:left P2} cut-unfoc+ R1 ([l1:left P1] R4 l1 l2) (R5 l2))\n     <- cut-unfoc+ R2 ([l2:left P2] R5 l2) R.\n\n%worlds (bl_atmpos | bl_atmneg | bl_left) (adm*R _ _ _).\n%total [] (adm*R _ _ _).\n\nadm+R1 : right (up P1) -> right (up (P1 + P2)) -> type.\n%mode +{P1:prop pos} +{P2:prop pos} +{R1:right (up P1)}\n      -{R:right (up (P1 + P2))} (adm+R1 R1 R).\n\n- : adm+R1 (R1 : right (up P1)) R\n     <- eta+ P1 ([rf1:rfoc P1] upR' (+R1' rf1))\n        (R1' : left P1 -> right (up (P1 + P2)))\n     <- cut-unfoc+ R1 ([l1] R1' l1) R.\n\n%worlds (bl_atmpos | bl_atmneg | bl_left) (adm+R1 _ _).\n%total [] (adm+R1 _ _).\n\nadm+R2 : right (up P2) -> right (up (P1 + P2)) -> type.\n%mode +{P1:prop pos} +{P2:prop pos} +{R2:right (up P2)}\n      -{R:right (up (P1 + P2))} (adm+R2 R2 R).\n\n- : adm+R2 (R2 : right (up P2)) R\n     <- eta+ P2 ([rf2:rfoc P2] upR' (+R2' rf2))\n        (R2' : left P2 -> right (up (P1 + P2)))\n     <- cut-unfoc+ R2 ([l2] R2' l2) R.\n\n%worlds (bl_atmpos | bl_atmneg | bl_left) (adm+R2 _ _).\n%total [] (adm+R2 _ _).\n\nadm-oL : right (up P1)\n\t  -> (left (down N2) -> right N')\n\t  -> (left (down (P1 -o N2)) -> right N')\n\t  -> type.\n%mode adm-oL +R1 +R2 -R.\n\n- : adm-oL (R1 : right (up P1)) (R2 : left (down N2) -> right N')\n     (R : left (down (P1 -o N2)) -> right N')\n     <- ({l:left (down (P1 -o N2))} {rf1:rfoc P1}\n           eta- N2 ([n][lf2] downL' (-oL' rf1 lf2) l) (R3 rf1 l : right N2))\n     <- ({l} eta+ P1 ([rf1] R3 rf1 l) ([l1] R4 l l1))\n     <- ({l} {l1} cut-unfoc- (R4 l l1) ([l2] R2 l2) (R5 l l1))\n     <- ({l} cut-unfoc+ R1 ([l1] R5 l l1) (R l)).\n\n%worlds (bl_atmpos | bl_atmneg | bl_left) (adm-oL _ _ _).\n%total [] (adm-oL _ _ _).\n\n%{ === Completeness === }%\n\ncph+ : hyp P -> left P -> type.\ncph- : hyp N -> left (down N) -> type.\ncp- : conc N -> right N -> type.\ncp+ : conc P -> right (up P) -> type.\n%mode cph+ +Hp -L.\n%mode cph- +Hn -L.\n%mode cp- +Dn -R.\n%mode cp+ +Dp -R.\n\n- : cp+ (init Hp) (upR' (initR' L))\n     <- cph+ Hp L.\n- : cp- (init Hn) (downL' (initL') L)\n     <- cph- Hn L.\n\n- : cp- (upR Dp) R\n     <- cp+ Dp R.\n- : cp- (upL ([hp] Dn1 hp) Hn) (downL' (upL' ([l] R1 l)) L)\n     <- cph- Hn L\n     <- ({hp:hyp P} {l:left P}\n           cph+ hp l -> cp- (Dn1 hp) (R1 l)).\n- : cp+ (upL ([hp] Dp1 hp) Hn) (downL' (upL' ([l] R1 l)) L)\n     <- cph- Hn L\n     <- ({hp:hyp P} {l:left P}\n\t   cph+ hp l -> cp+ (Dp1 hp) (R1 l)).\n\n- : cp+ (downR Dn) (upR' (downR' R))\n     <- cp- Dn R.\n- : cp- (downL ([hn] Dn hn) Hp) (R L)\n     <- cph+ Hp L\n     <- ({hn:hyp N} {l:left (down N)}\n           cph- hn l -> cp- (Dn hn) (R l)).\n- : cp+ (downL ([hn] Dp hn) Hp) (R L)\n     <- cph+ Hp L\n     <- ({hn:hyp N} {l:left (down N)}\n           cph- hn l -> cp+ (Dp hn) (R l)).\n\n- : cp+ (*R Dp1 Dp2) R12\n     <- cp+ Dp1 R1\n     <- cp+ Dp2 R2\n     <- adm*R R1 R2 R12.\n- : cp- (*L ([hp1] [hp2] Dn hp1 hp2) Hp) (*L' ([l1] [l2] R l1 l2) L)\n     <- cph+ Hp L\n     <- ({hp1:hyp P1} {l1:left P1} cph+ hp1 l1\n           -> {hp2:hyp P2} {l2:left P2} cph+ hp2 l2\n           -> cp- (Dn hp1 hp2) (R l1 l2)).\n- : cp+ (*L ([hp1] [hp2] Dp hp1 hp2) Hp) (*L' ([l1] [l2] R l1 l2) L)\n     <- cph+ Hp L\n     <- ({hp1:hyp P1} {l1:left P1} cph+ hp1 l1\n           -> {hp2:hyp P2} {l2:left P2} cph+ hp2 l2\n           -> cp+ (Dp hp1 hp2) (R l1 l2)).\n\n- : cp+ (+R1 Dp1) R12\n     <- cp+ Dp1 R1\n     <- adm+R1 R1 R12.\n- : cp+ (+R2 Dp2) R12\n     <- cp+ Dp2 R2\n     <- adm+R2 R2 R12.\n- : cp- (+L ([h1] D1 h1) ([h2] D2 h2) H) (+L' R1 R2 L)\n     <- cph+ H L\n     <- ({h1}{l1} cph+ h1 l1 -> cp- (D1 h1) (R1 l1))\n     <- ({h2}{l2} cph+ h2 l2 -> cp- (D2 h2) (R2 l2)).\n- : cp+ (+L ([h1] D1 h1) ([h2] D2 h2) H) (+L' R1 R2 L)\n     <- cph+ H L\n     <- ({h1}{l1} cph+ h1 l1 -> cp+ (D1 h1) (R1 l1))\n     <- ({h2}{l2} cph+ h2 l2 -> cp+ (D2 h2) (R2 l2)).\n\n- : cp- (-oR [hp] Dn hp) (-oR' [l] R l)\n     <- ({hp:hyp P} {l:left P}\n           cph+ hp l -> cp- (Dn hp) (R l)).\n- : cp- (-oL Dp1 ([hn2] Dn2 hn2) Hn) (R12 L)\n     <- cph- Hn L\n     <- cp+ Dp1 R1\n     <- ({hn2:hyp N2} {l2:left (down N2)}\n           cph- hn2 l2 -> cp- (Dn2 hn2) (R2 l2))\n     <- adm-oL R1 ([l2] R2 l2) ([l] R12 l).\n- : cp+ (-oL Dp1 ([hn2] Dp2 hn2) Hn) (R12 L)\n     <- cph- Hn L\n     <- cp+ Dp1 R1\n     <- ({hn2:hyp N2} {l2:left (down N2)}\n           cph- hn2 l2 -> cp+ (Dp2 hn2) (R2 l2))\n     <- adm-oL R1 ([l2] R2 l2) ([l] R12 l).\n\n%block bl_cph+ : some {P:prop pos} block {hp:hyp P} {l:left P} {_:cph+ hp l}.\n%block bl_cph- : some {N:prop neg} block {hn:hyp N} {l:left (down N)} {_:cph- hn l}.\n\n%worlds (bl_atmpos | bl_atmneg | bl_cph+ | bl_cph-)\n   (cp- _ _) (cp+ _ _) (cph- _ _) (cph+ _ _).\n\n%total [] (cph+ Hp _).\n%total [] (cph- Hn _).\n%total (Dn Dp) (cp- Dn _) (cp+ Dp _).\n\n\n%{ == Translating into focused logic == }%\n\n%{ A simple proof which is isomorphic in the unfocused and\nfocused system, establishing <tt>|- a * b -o b * a</tt>\nfor positive a and b.}%\n\n%abbrev ' = [q] atom q.\nr0 : {a:atm pos} {b:atm pos} right (' a * ' b -o up (' b * ' a))\n   = [a] [b] -oR' ([lab] *L' ([la] [lb] upR' (*R' (initR' lb) (initR' la))) lab).\nd0 : {a:atm pos} {b:atm pos} conc (' a * ' b -o up (' b * ' a))\n   = [a] [b] -oR ([hab] *L ([ha] [hb] upR (*R (init hb) (init ha))) hab).\n\n%{|check=decl}%\n\n%query 1 * {a}{b} sdR (r0 a b) (D0 a b).\n\n%{|check=decl}%\n\n%query 1 * {a}{b} cp- (d0 a b) (R0 a b).\n\n%{ === Reducing the number of proofs === }%\n\n%{ This first example is already in \"focused form\" - invertible rules\nare applied only \"before\" upR is applied to prove \n<tt>|- (a + b) -> up (a + b)</tt> |check=decl}% \n%query 1 *\n   {a: atm pos}{b: atm pos} \n   cp- (-oR ([h: hyp (atom a + atom b)]\n\t\t    +L ([ha: hyp (atom a)] upR (+R1 (init ha)))\n\t\t       ([hb: hyp (atom b)] upR (+R2 (init hb))) h))\n            (D a b).\n\n%{ This a proof of the same sequent, but upR is applied before +L, which\nis fine in the unfocused system but not in the focused system, where upR\nstarts a focusing phase and makes it impossible to apply invertible rules like\n+L. Translation produces the same focused proof from these two different\nunfocused proofs. |check=decl}% \n%query 1 *\n   {a: atm pos}{b: atm pos} \n   cp- (-oR ([h: hyp (atom a + atom b)] \n\t\t    upR (+L ([ha: hyp (atom a)] +R1 (init ha))\n\t\t\t    ([hb: hyp (atom b)] +R2 (init hb)) h)))\n            (D a b).\n\n\n\n%{ === Forward and backward chaining === }%\n\n%{ Finally, consder the following unfocused sequent proof. The proof\nproceeds in what we generally consider a \"forward-chaining\" manner, using\nthe hypothesis (atom A) to obtain the hypothesis (atom B), which is then\nused to obtain the hypothesis (atom C), which is then used to obtain\nthe hypothesis (atom D), which is finally used to finish. }%\n\nimplies-proof =\n   [A: atm neg][B: atm neg][C: atm neg][D: atm neg]\n   -oR (downL [ha: hyp (atom A)]\n   -oR (downL [hab: hyp (down (atom A) -o (atom B))]\n   -oR (downL [hbc: hyp (down (atom B) -o (atom C))]\n   -oR (downL [hcd: hyp (down (atom C) -o (atom D))] \n    (-oL (downR (init ha)) \n     ([hb: hyp (atom B)]\n      -oL (downR (init hb))\n      ([hc: hyp (atom C)]\n       -oL (downR (init hc))\n       ([hd: hyp (atom D)] init hd) \n       hcd)\n      hbc)\n     hab))))).\n\n%{ Because negative polarity forces search to be goal directed, translating\nthis proof into the focused system will flip the order in which the \nimplications are considered, and no facts (beyond the four in the implication)\nwill ever be added to the context. | check=decl }%\n   \n%query 1 * \n   {a: atm neg}{b: atm neg}{c: atm neg}{d: atm neg}\n   cp- (implies-proof a b c d) _.\n\n%{ Finally, we can show the proof of a successful attempt to prove\n<tt>right (A -o (A -o B) -o (B -o C) -o C)</tt> in the weakly focused system.\nIn general, this could cause an infinite loop as Twelf has no problem\nwith deriving multiple copies of the same fact, but here we use all\nnegative atoms, and the resulting backward-chaining semantics\ncorresponds nicely to Twelf's built-in backward-chaining semantics. \n|check=decl}%\n\n%solve p : \n   {a: atm neg}{b: atm neg}{c: atm neg}\n   right (down (' a)\n          -o down (down (' a) -o ' b) \n            -o down (down (' b) -o ' c) -o ' c)."
          },
          "sha1": "fo9bvpr6mzpvi7esa370n3x0jzmu403"
        }
      },
      {
        "title": "Weakening",
        "ns": 0,
        "id": 1501,
        "redirect": {
          "@title": "Weakening lemma",
          "#text": null
        },
        "revision": {
          "id": 1921,
          "timestamp": "2006-09-25T04:42:25Z",
          "contributor": {
            "username": "DanielKLee",
            "id": 5
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 29,
            "#text": "#REDIRECT [[Weakening lemma]]"
          },
          "sha1": "1wwny3csxhokdd1t1hg2bwfxf3uf8bz"
        }
      },
      {
        "title": "Weakening lemma",
        "ns": 0,
        "id": 1502,
        "revision": {
          "id": 4452,
          "parentid": 4182,
          "timestamp": "2007-03-20T20:38:25Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "minor": null,
          "comment": "--category",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 2439,
            "#text": "'''Weakening''' is the property of a hypothetical judgment that if Γ {{vdash}} J, then Γ, A {{vdash}} J. That is, if a judgment holds in a context Γ, then it holds in Γ extended with additional hypotheses. Weakening holds for most logics, but its absence is central to the formulation of substructural logics such as [[linear logic]].\n\nOften, we represent an an object-language hypothetical judgement by [[higher-order judgements|using LF binding to model hypotheses]].  When a judgement is represented in such a fashion, weakening comes \"for free\" from the LF representation.  In particular, we may weaken a derivation by wrapping LF lambdas around it.\n\nFor example, consider the following simply typed λ-calculus:\n\n<twelf>\n%% Syntax\n\ntp : type.\n \ntp/unit  : tp.\ntp/arrow : tp -> tp -> tp.\n \nexp : type.\n \nexp/unit : exp.\nexp/lam  : tp -> (exp -> exp) -> exp.\nexp/app  : exp -> exp -> exp.\n\n\n%% Typing \n\nof : exp -> tp -> type.\n \nof/unit : of exp/unit tp/unit.\n \nof/lam  : of (exp/lam T E) (tp/arrow T T')\n           <- ({x:exp} of x T\n                -> of (E x) T').\n \nof/app  : of (exp/app E1 E2) T'\n           <- of E2 T\n           <- of E1 (tp/arrow T T').\n</twelf> \n\nObject-language typing is a hypothetical judgement; we represent it using LF variables to model hypotheses (see {{proving|title=Representing the judgements of the STLC}} for more discussion of this representation).  \n\nWe can prove weakening for this hypothetical judgement as a metatheorem: \n\n<twelf check=\"true\"> \nwkn : {T':tp}\n       of E T\n       -> ({x} of x T' -> of E T)\n       -> type.\n%mode wkn +T' +D1 -D2.\n\n- : wkn T' D1 ([x][dx:of x T'] D1).\n\n%block of-block : some {T} block {x : exp} {dx : of x T}.\n%worlds (of-block) (wkn _ _ _).\n%total {} (wkn _ _ _). \n</twelf>\n\nThe proof is direct: given any derivation <tt>D1</tt>, we can wrap LF lambdas around it to create a derivation under the necessary hypotheses.  The fact that this works corresponds to the fact that weakening is admissible for LF, which is why we say that the object language inherits the hypothetical structure of the meta-language.  \n\nAlthough we proved weakening as a metatheorem here for illustrative purposes, in practice it is unnecessary to write such proofs. Uses of weakening can be \"inlined\" by simply introducing LF lambdas when necessary.\n\n{{needs|example of using weakening in another proof.}}\n\n== See also ==\n\n* [[Exchange lemma]]\n* [[Substitution lemma]]\n\n{{tutorial}}"
          },
          "sha1": "mbffctmrp5gs7zzlj095uxuy9i4w3ay"
        }
      },
      {
        "title": "What's new",
        "ns": 0,
        "id": 1384,
        "revision": {
          "id": 8013,
          "parentid": 8011,
          "timestamp": "2016-01-17T19:01:02Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "more archive",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 7056,
            "#text": ";January 17, 2015\n*After a year of issues stemming from the age of our old server, twelf.org has been moved to a new machine. Some features, like Twelf Live and syntax highlighting, still only exist on the [http://twelf.plparty.org old site]. Let [[User:Rsimmons|Rob]] know about any other deficiencies in the new site.\n\n;June 10, 2013\n* Taus Brock-Nannestad, Chris Martens, and Carsten Schürmann to hold a [http://www.twelf.org/wiki/CADE_Tutorial Twelf Tutorial at CADE].\n\n;October 26, 2012\n* John Boyland's [https://github.com/boyland/twelf-library Twelf library] is available on Github.\n\n<includeonly>''To read about older updates, see the [[What's new?]] page.''</includeonly><noinclude>\n== Archived posts ==\n<!--\n|\n| ================ BEGIN ARCHIVE SECTION ========================\n|\n| Posts below this point will no longer be shown on the main page. To archive\n| more posts move this notice along with the subhead and the\n| < noinclude > and < include only > tags \n| above it to a point higher on the page -->\n\n;September 2, 2011\n* We've finally moved from twelf.plparty.org to twelf.org! All old links will continue to work through at least August 2013 (and they should actually continue to work indefinitely).\n\n;March 19, 2011\n* After many years of new features being added only to the subversion branch, Twelf now has a new official point release! Twelf 1.7.1 contains many fixes and new features that are documented on this site, and using any version of Twelf prior to 1.7 is highly discouraged. The \"development\" version of Twelf in the subversion repository remains quite stable and is also recommended. Go to the [[download]] page to get Twelf.\n\n;September 1, 2010\n* The Twelf Wiki has undergone an upgrade, and in the process code underlying the syntax-highlighing [[TwelfTag]] system has been substantially rewritten and simplified. However, this meant several deprecated-but-still-used options to the <nowiki><twelf></nowiki> tags now don't work and print error messages. Leave a note on [[User_talk:Rsimmons | Rob's talk page]] if you see any weird error messages around Twelf code.\n\n;February 22, 2009\n* [[User:Rsimmons|Rob]] has a case study on [[lax logic]] that uses the [[admissibility of cut]] and identity show a sound and complete correspondence between two sequent calculus presentations of lax logic.\n\n;October 1, 2008\n*  [[User:Carsten|Carsten]] says: As a result of the work of some overly active system administrators at the ITU, the twelf mailing list was accidentally erased a few weeks ago.  Since then I have tried to reconstruct the  subscriber list with more or less success, but there are still some that I have missed.  Therefore, if you haven't received any mail from the list lately, but you expect to be on it, please resubscribe under [[http://mail.itu.dk/mailman/listinfo/twelf-list http://mail.itu.dk/mailman/listinfo/twelf-list]]. \n\n;September 19, 2008\n* '''We are running a [[POPL Tutorial|Twelf Tutorial]] co-located with POPL 2009.'''\n\n;July 19, 2008\n* [[User:Drl|Dan]] added [[Summer school 2008|course materials for the UofO summer school]].\n\n;January 28, 2008\n* [[User:Boyland|John]] took Rob's example to the next step and directly provided a bijection between a [[HOAS nat bijection|HOAS  encoding of lambdas and natural numbers]].\n\n;October 4, 2007\n* [[User:Rsimmons|Rob]] posted a page on [[concrete representation]] based on a question by [[User:Boyland|John]] about demonstrating a correspondence between HOAS and concrete term representations.\n\n;April 25, 2007\n* [[User:Twilson|Todd]] posted a [[tutorial]] on using Church encodings to create [[user-defined constraint domain]]s.\n\n;April 11, 2007\n* If you think up some exercises while you're learning Twelf, add them to the [[Proving metatheorems:Summary: the natural numbers|intro tutorial]].\n\n;March 21, 2007\n* Official launch day! Thanks to [[Project:Contributors|everyone]] who has contributed so far, and welcome to new visitors.\n\n;March 16, 2007\n* [[User:Drl|Dan]] has revised and expanded several of the [[tutorials]], and written new ones on [[catch-all case]]s, [[numeric termination metrics]], and [[hereditary substitution for the STLC|hereditary substitution]].\n\n;March 14, 2007\n* [[User:Drl|Dan]] has finished a draft of the introductory article [[Proving metatheorems with Twelf]].  \n\n;February 28, 2007\n* The Twelf Project wiki now supports uploading SVG images! Check out the article on [[tabled logic programming]] for an example of the unnecessarily beautiful illustrations this allows.\n\n'''February 24, 2007'''\n* [[User:Rsimmons|Rob]] has  extended the [[Project:TwelfTag|TwelfTag]] feature to facilitate using [[Project:Literate Twelf|Literate Twelf]].\n\n'''January 25, 2007'''\n* [[User:Rsimmons|Rob]] has developed a beta [http://twelf.plparty.org/builds build system] that has source, Linux binary, and Windows installer versions of \"CVS Twelf.\"\n\n'''December 1, 2006'''\n* [[User:Tom7|Tom]] added a category for [[:category:undocumented features|undocumented features]] \n\n'''October 30, 2006'''\n* [[User:Tom7|Tom]] posted a [[case studies|case study]] on [[Admissibility of cut]].\n\n'''October 20, 2006'''\n* [[User:JakeD|Jake]] posted a [[tutorials|tutorial]] on [[Strengthening]].\n\n'''October 19, 2006'''\n* [[User:Varming|Carsten]] is developing a [[case studies|case study]] on [[Heterogeneous_lists|lists]].\n\n'''October 18, 2006'''\n* [[User:Tom7|Tom]] posted a [[case studies|case study]] for [[Classical S5]].\n\n'''October 16, 2006'''\n\n* [[User:Crary|Karl]] posted a [[Case studies|case study]] on [[Linear logic]].\n\n'''October 14, 2006'''\n\n* An alpha version of \"[[Project:AJALF|AJALF]]\"-powered [[Twelf Live]] is online\n* [[User:DanielKLee|Dan]] has started the [[Ask Twelf Elf]] project providing Twelf help over email\n\n'''October 13, 2006'''\n\n* The editor interface now has a [[Project:TwelfTag#Quick check|quick check]] button for Twelf code, thanks to \"[[Project:AJALF|AJALF]]\" technology.\n\n'''October 9, 2006'''\n\n* The [[Project:TwelfTag|TwelfTag]] system now allows for direct checking of code in the wiki. \n* [[User:Varming|Carsten]] has added code proving various properties of [[Lily]] to the [[case studies]].\n\n'''October 5, 2006'''\n\n* [[User:Tom7|Tom]] posted an advanced [[:category:tutorials|tutorial]] on [[CPS conversion]].\n\n'''September 30, 2006'''\n\n* The wiki has been moved to its real home on the [http://moog.concert.cs.cmu.edu/ Moog server], and given a permanent domain name, twelf.plparty.org.\n* A first draft of the non-technical [[quick introduction]] has been introduced for consideration.\n\n'''September 28, 2006'''\n\n* [[Substitution lemma]] &mdash; [[User:DanielKLee|Dan Lee]]'s thorough explanation of the different ways substitution lemmas are dealt with by Twelf.\n* [[Software#Twelf CVS|Twelf CVS]] &mdash; We have instructions from the Software page on downloading the development version of Twelf from the CVS repository. The CVS version of Twelf has undocumented features which are being described on the wiki, such as its capacity for working with [[holes in metatheorems]].\n\n</noinclude>"
          },
          "sha1": "kfto2c33r5tlkvue5bh1xmmiufgsr6n"
        }
      },
      {
        "title": "What's new?",
        "ns": 0,
        "id": 1707,
        "redirect": {
          "@title": "What's new",
          "#text": null
        },
        "revision": {
          "id": 2770,
          "timestamp": "2006-10-13T21:24:43Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "Redirecting to [[What's new]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 24,
            "#text": "#REDIRECT [[What's new]]"
          },
          "sha1": "4v9q7h8zxxc9twc7rqflnwpx9haavxu"
        }
      },
      {
        "title": "Working with higher-order judgements",
        "ns": 0,
        "id": 2037,
        "redirect": {
          "@title": "Reformulating languages to use hypothetical judgements",
          "#text": null
        },
        "revision": {
          "id": 5087,
          "timestamp": "2008-03-04T04:40:36Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "comment": "[[Working with higher-order judgements]] moved to [[Reformulating languages to use hypothetical judgements]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 68,
            "#text": "#REDIRECT [[Reformulating languages to use hypothetical judgements]]"
          },
          "sha1": "0ihovylciesjx89dhihe4xii51d1k36"
        }
      },
      {
        "title": "World",
        "ns": 0,
        "id": 1974,
        "redirect": {
          "@title": "%worlds",
          "#text": null
        },
        "revision": {
          "id": 4541,
          "timestamp": "2007-03-21T02:17:02Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "comment": "Redirecting to [[%worlds]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 21,
            "#text": "#REDIRECT [[%worlds]]"
          },
          "sha1": "0jtdy7wnk96spj887p00qwvmaysabch"
        }
      },
      {
        "title": "World subsumption",
        "ns": 0,
        "id": 1947,
        "revision": {
          "id": 4562,
          "parentid": 4437,
          "timestamp": "2007-03-21T04:16:32Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 383,
            "#text": "'''World subsumption''' is a sufficient condition that a [[metatheorem]] proved for one set of LF contexts can be reused in another set of contexts.\n\nEventually, this page will contain a self-contained explanation for world subsumption.  For now, please read the discussion in {{proving|title=Proving totality assertions in non-empty contexts}} and on the [[%worlds]] page.\n\n{{stub}}"
          },
          "sha1": "7lwms0e1qna0na92mjfan5l6kafpe46"
        }
      },
      {
        "title": "Zermelo Frankel",
        "ns": 0,
        "id": 1394,
        "revision": {
          "id": 4397,
          "parentid": 2948,
          "timestamp": "2007-03-20T07:30:34Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "minor": null,
          "comment": "case study",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 2821,
            "#text": "This [[case studies|case study]] is an encoding of '''Zermelo Frankel''' ('''ZFC''') set theory.\n\n{{needs|some explanatory text}}\n\n<twelf>\n%% ZFC \n%% by Daniel C. Wang\n%% Transliterated from AUTOMATH definition \n%% http://www.cs.ru.nl/~freek/zfc-etc/zfc.aut\nprop : type.\npf: prop -> type.\nset : type.\n\n%% First Order Logic\nfalse : prop.\nimp : prop -> prop -> prop.\nall : (set -> prop) -> prop. \neq : set -> set -> prop.\nin : set -> set -> prop.\nnot : prop -> prop = [a] imp a false.\nand : prop -> prop -> prop = [a][b] not (imp a (not b)).\nor : prop -> prop -> prop = [a][b] imp (not a) b.\niff : prop -> prop -> prop = [a][b] and (imp a b) (imp b a).\nex : (set -> prop) -> prop = [p] not(all([z]not (p z))).\nunique : (set -> prop) -> prop =\n [p] all([z] imp (p z) (all ([z'] imp (p z') (eq z z')))).\nex_unique : (set -> prop) -> prop = [p]\n   and (ex p) (unique p).\nimp_i : (pf A -> pf B) -> pf (imp A B).\nimp_e : pf (imp A B) -> pf A -> pf B.\nall_i : ({z}pf (P z)) -> pf (all P).\nall_e : pf (all P) -> {z}pf (P z).\nclassical : pf (not(not A)) -> pf A. \n\neq_i : pf (eq A A).\neq_e : pf (eq A B) -> {s:(set -> prop)} pf (s A) -> pf (s B).\n\nif : prop -> set -> set -> set.\nif_then : pf P -> pf (eq (if P X Y) X). \nif_else : pf (not P) -> pf (eq (if P X Y) Y).\n\n%% Set Theory theory\nempty    : set.\ndouble   : set -> set -> set.  % {x,y} \nunions   : set -> set.         % union sets in sets \npowerset : set -> set.\nreplace  : set -> (set -> set) -> set.\nomega    : set.\n\nsingle : set -> set = [x] double x x.\nrestrict : set -> (set -> prop) -> set =\n [x][q] unions (replace x ([z] if (q z) (single z) empty)).\ninter : set -> set -> set = [x][y] restrict x ([z] in z y).\nunion : set -> set -> set = [x][y] unions (double x y).\nzero : set = empty.\nsucc : set -> set = [x] union x (single x).\nsubset : set -> set -> prop = [x][y]all[z] imp (in z x) (in z y).\ndisjoint : set -> set -> prop = [x][y] eq (inter x y) empty.\nomega_closed : set -> prop = [x]\n and (in empty x) (all [n] imp (in n x) (in (succ n) x)).\n\n%% Axioms ZF\nextensionality : pf (iff (eq X Y) (all[z] iff (in z X) (in z Y))).\nfoundation     : pf (ex([z] and (in z X) (disjoint z X))).\nemtpy_ax       : pf (not (in X empty)).\ndouble_ax      : pf (iff (in Z (double X Y)) (or (in Z X) (in Z Y))).\nunion_ax       : pf (iff (in Z (unions X)) (ex[y] and (in Z y) (in y X))).\npowerset_ax    : pf (iff (in Z (powerset X)) (subset Z X)).\nreplace_ax     : pf (iff (in Z (replace X F)) (ex[y] and (in y X) (eq Z (F y)))).\nomega_ax       : pf (and (omega_closed omega)\n  \t\t          (all[o] imp (omega_closed o) (subset omega o))).\n\n%% C\nchoice_ax      : pf\n (imp (all[y1] imp (in y1 X)\n        (all[y2] imp (in y2 X) (disjoint y1 y2)))\n     (ex [x'](all[y] imp (in y X)\n  \t\t (ex_unique ([y'] (and (in y' x') (in y' y))))))).</twelf>\n\n[[Category:Twelf code]]\n{{case study}}"
          },
          "sha1": "oqhwfs97tlr8pkf3zkwdxyo3lmz1cjg"
        }
      },
      {
        "title": "Talk:% define",
        "ns": 1,
        "id": 1718,
        "redirect": {
          "@title": "Talk:Define declaration",
          "#text": null
        },
        "revision": {
          "id": 2834,
          "timestamp": "2006-10-14T13:43:08Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "comment": "[[Talk:% define]] moved to [[Talk:Define declaration]]: space is perhaps difficult to spot, but maybe we should try to fix the root problem",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 37,
            "#text": "#REDIRECT [[Talk:Define declaration]]"
          },
          "sha1": "5i1sq5ka85cdn2hv9odpx99g3ul91p2"
        }
      },
      {
        "title": "Talk:%covers",
        "ns": 1,
        "id": 2024,
        "revision": {
          "id": 4990,
          "timestamp": "2007-10-18T02:41:30Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "comment": "mention my extension",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 528,
            "#text": "==<tt>%partial</tt>==\nIf you're interested in a <tt>%covers</tt> that \"does the right thing\" (input, output, freeness, and checking of other type families in subgoals), I have a simple implementation of the <tt>%partial</tt> declaration. This declaration does the same thing as <tt>%total</tt> but does not perform the totality check. From it you get a \"partial correctness\" property: a <tt>%partial</tt> relation will either search forever or it will succeed. &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 22:41, 17 October 2007 (EDT)"
          },
          "sha1": "2qjauyl60wmp1fgue2h1kybk4dppbae"
        }
      },
      {
        "title": "Talk:%freeze",
        "ns": 1,
        "id": 1808,
        "revision": {
          "id": 3402,
          "parentid": 3399,
          "timestamp": "2006-12-25T05:15:36Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "comment": "/* Soundness */",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 1181,
            "#text": "==Version==\nDoes anyone know what versions freeze and autofreeze are available in? I have the impression that they are new features (being undocumented). &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 14:22, 1 December 2006 (EST)\n: I think freeze has been available since around 1.5, but it wasn't in 1.4, I'm almost certain. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 18:53, 20 December 2006 (EST)\n\n==Soundness==\nCan unsoundness also result if there is no autofreeze? I'm not sure what Twelf's behavior was in this case. &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 14:22, 1 December 2006 (EST)\n: It should - you could prove <tt>eq (s N) N</tt> implied <tt>absurd</tt>, and then add a case to <tt>eq</tt> to make that theorem no longer true... — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 18:52, 20 December 2006 (EST)\n::Certainly if it continued to accept the totality of that theorem for the new extended <tt>eq</tt>. But if any worlds/total/etc. declarations were invalidated by new declarations for a type family, I think that might still be sound. Did Twelf do that? Probably not. &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 00:15, 25 December 2006 (EST)"
          },
          "sha1": "pb8uqqfkoq2i8qns5nna5f3gbb9ynzl"
        }
      },
      {
        "title": "Talk:%reduces",
        "ns": 1,
        "id": 1507,
        "revision": {
          "id": 7913,
          "parentid": 1979,
          "timestamp": "2013-06-03T13:53:48Z",
          "contributor": {
            "username": "Boyland",
            "id": 17
          },
          "comment": "Mutual reduction",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 1367,
            "#text": "== Splitting this up ==\n\nAt this point, this article is pretty incomplete as there is still much to be said about the %reduces directive. I did want to get a code example in, though. The addition of the <tt>nat-less-reduces</tt> stuff makes the code example longer than necessary. We might want to just cut it off after <tt>nat-plus-reduces-s</tt> or <tt>nat-plus-reduces</tt> and have the entire proof of <tt>nat-less-reduces</tt> as its own code example/tutorial. --[[User:DanielKLee|DanielKLee]] 10:08, 27 September 2006 (MST)\n* In my opinion it's important to be as brief as possible with code snippets; they should be only the minimal size needed to illustrate the relevant point. Perhaps breaking it up into two sections would be the right way to go. &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 10:39, 27 September 2006 (MST)\n\n== Mutual recursion ==\n\nSometimes when I prove an inversion lemma, I need to use recursion sometimes but not all always\nand determining whether to use recursion requires a case analysis.  This means we have a mutual\nmeta-theorem.  I would like to show that the main inversion lemma has a '<' reduction, but the helper lemma\nonly has a '<=' recursion.  I just figured out how to handle this: first prove the mutual reduction with '<=', and then separately prove the main reduction with '<'. [[User:Boyland|Boyland]] 09:53, 3 June 2013 (EDT)"
          },
          "sha1": "elz6ludcqan4c67p5n9iqyfajobf9h0"
        }
      },
      {
        "title": "Talk:%thaw",
        "ns": 1,
        "id": 1836,
        "revision": {
          "id": 3821,
          "parentid": 3820,
          "timestamp": "2007-02-28T21:27:51Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 2445,
            "#text": "== Gee that's bad ==\n\nARGH! The current Twelf CVS allows you to \n\n<twelf>\nnat : type.\ns : nat -> nat.\nz : nat.\n\nplus : nat -> nat -> nat -> type.\np-z : plus z N N.\np-s : plus (s N1) N2 (s N3) <- plus N1 N2 N3.\n\n%mode plus +A +B -C.\n%worlds () (plus _ _ _).\n%total T (plus T _ _).\n</twelf>\n\nTake 1:\n<twelf check=decl discard=true>\nfake : nat.\n%solve _ : plus fake z _.\n</twelf>\n\nTake 2:\n<twelf check=decl discard=true>\n%thaw nat.\nfake : nat.\n%solve _ : plus fake z _.\n</twelf>\n\nargh. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 22:06, 29 December 2006 (EST)\n\n:: Fixing this is a three-line patch to Twelf, but because it would break potential existing code I've asked Frank for permission to commit the patch — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 22:25, 29 December 2006 (EST)\n::: How would it break existing code? My feeling is that %thaw should pretty much be removed from the language. It doesn't seem to have any legitimate use to me (unlike say %trustme). &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 10:18, 28 February 2007 (EST)\n:::: See <tt>/twelf/examples/lp/test.cfg</tt> for the only significant code I broke banning Thaw. If you've frozen your language of atoms and you now need more atoms, you can declare them dynamically, which is an enormous mess in this example, or you can just thaw your base atom type knowing you're justified by the way you wrote all your <tt>[[%block]]</tt> and <tt>[[%worlds]]</tt> directives. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 12:49, 28 February 2007 (EST)\n::::: OK, I buy that use. I'm not sure it's really an enormous mess to introduce them dynamically, but that is certainly clean to do it this way. On the other hand, maybe I should never defend a use of unsafe features that's not clearly necessary? &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 14:26, 28 February 2007 (EST)\n:::::: I also would say that we shouldn't advocate it's ''use'' so much, but there's a code compatibility issue; perfectly legitimate code written before autofreeze, in particular, may need extensive rewriting, whereas if that code is not crucial it's a decent hack to just thaw things. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 15:13, 28 February 2007 (EST)\n::::::: Agreed—I meant specifically ''me'' in that will I be able to sleep well at night if I support that? ;) &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 16:27, 28 February 2007 (EST)"
          },
          "sha1": "e0vjaqch2dxkiozofbs67znlwqb3igu"
        }
      },
      {
        "title": "Talk:%theorem",
        "ns": 1,
        "id": 2031,
        "revision": {
          "id": 5045,
          "parentid": 5044,
          "timestamp": "2008-02-07T15:12:55Z",
          "contributor": {
            "username": "Boyland",
            "id": 17
          },
          "minor": null,
          "comment": "not anonymous",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 1183,
            "#text": "This page seems too terse and erroneous too.\n%theorem is equivalent to a type family definition and a mode definition\n(and much more readable!).\nIt does NOT include %worlds.\nI know that ''real'' Twelf users don't ever use it, even\nwhen it would make their meta-theorems much easier to read.\nI think this is a shame.  %theorem declarations are \nperfectly compatible with manual theorem proving.\n<twelf>\nbool : type.\n\n\ntrue : bool.\n\nfalse : bool.\n\n\n%freeze bool.\n\n\n\neq : bool -> bool -> type.\n\n\neq/ : eq B B.\n\n\n\n%theorem eq-reflexive : \n        forall {X} \n        exists {E:eq X X} \n        true.\n\n- : eq-reflexive _ eq/.\n\n%worlds () (eq-reflexive _ _).\n%total { } (eq-reflexive _ _).\n</twelf>\n[[User:Boyland|Boyland]] 22:36, 24 January 2008 (EST)\n\nThe confusion here, I believe, is that %theorem does perform the %worlds job when being used as part of the [[theorem prover]], but not when being used in totality-declaration-style. I think the edit here is accurate, if you want to run with it it could use a simple example. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 16:08, 30 January 2008 (EST)\n\nSeems fine now [[User:boyland|John]] 11:33, 6 February 2008 (EST)"
          },
          "sha1": "c4gnlx76wrfsnrin0m25tu0ayy95r2q"
        }
      },
      {
        "title": "Talk:%worlds",
        "ns": 1,
        "id": 1980,
        "revision": {
          "id": 4614,
          "timestamp": "2007-03-21T15:20:12Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "comment": "New page: This is a good article. Kudos. ~~~~",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 96,
            "#text": "This is a good article. Kudos. &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 11:20, 21 March 2007 (EDT)"
          },
          "sha1": "53ot573vtafghdzd3rjshr3udsx7be8"
        }
      },
      {
        "title": "Talk:Ad hoc binding structures",
        "ns": 1,
        "id": 2026,
        "revision": {
          "id": 4998,
          "timestamp": "2007-10-19T04:07:25Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "New page: Would \"Ad-hoc binding structures\" be a better name? Maybe I'm just wrong, but \"Ad hoc\" looks weird to me. ~~~~",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 198,
            "#text": "Would \"Ad-hoc binding structures\" be a better name? Maybe I'm just wrong, but \"Ad hoc\" looks weird to me. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 00:07, 19 October 2007 (EDT)"
          },
          "sha1": "g950109qtxcby036he2riw4sibf0cnb"
        }
      },
      {
        "title": "Talk:Admissibility of cut",
        "ns": 1,
        "id": 1775,
        "revision": {
          "id": 4169,
          "parentid": 4163,
          "timestamp": "2007-03-15T22:38:10Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "comment": "/* Sectioning looks off */",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 556,
            "#text": "== Questions on Sequent Calculus ==\n\nIf init works at any prop, why do you need the two judgements when you do the encoding?\n\nIf you give these two rules for and, is it right-asynch or left-asynch or both?  And I thought making one connective  both was bad.\n[[User:Drl|Drl]] 09:38, 26 October 2006 (EDT)\n\n== Sectioning looks off ==\n\nAre the other \"... cuts\" supposed to be indented an additional level? [[User:Drl|Drl]] 17:45, 15 March 2007 (EDT)\n* Nope. I fixed it. Thanks for spotting it! &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 18:38, 15 March 2007 (EDT)"
          },
          "sha1": "g8ir1vyxa5yaeogy2kxrmnvidaxkh49"
        }
      },
      {
        "title": "Talk:Alpha-equivalence",
        "ns": 1,
        "id": 2246,
        "revision": {
          "id": 6234,
          "parentid": 6222,
          "timestamp": "2011-03-16T02:46:36Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 655,
            "#text": "The definition is not correct.\nIt's not enough to say that y is not a free variable of e.\nYou must also have y free for x in e.\n\n:: Not sure where you're taking issue here: a counterexample might be helpful, and you're welcome to edit the actual page to clarify if you'd like. Certainly it is the case that alpha equivalence is quite subtle, which is one of the reasons we like that Twelf takes care of all of it for us :-) — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 14:21, 27 February 2011 (EST)\n\n:::: The usual definition has the additional condition that y != x.  Is that what you meant? [[User:Drl|Drl]] 22:46, 15 March 2011 (EDT)"
          },
          "sha1": "hbzgky2jv02377h3on0vbdygdn7t7bd"
        }
      },
      {
        "title": "Talk:Ask Twelf Elf",
        "ns": 1,
        "id": 1711,
        "revision": {
          "id": 290198,
          "parentid": 9602,
          "timestamp": "2021-03-29T14:49:37Z",
          "contributor": {
            "username": "Euisuny",
            "id": 305435
          },
          "comment": "/* Twelf pre-built Mac OS distro needs update */ new section",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 42524,
            "#text": "== Archives ==\n\n* [[Talk:Ask Twelf Elf/Archive 1|Archive 1]] (October 2006-March 2007)\n* [[Talk:Ask Twelf Elf/Archive 2|Archive 2]] (April 2007-October 2007)\n\n== LF representation of complete development ==\n\nConsider pure lambda terms:\n\n trm : type.\n lam : (trm -> trm) -> trm.\n app : trm -> trm -> trm.\n\nTait/Martin-Loef parallel reduction is represented in Frank Pfenning's paper on Church-Rosser as:\n\n => : trm -> trm -> type.  %infix none 10 =>.\n pr1_beta : (app (lam M) N) => M' N'\n           <- ({x:trm} x => x -> M x => M' x)\n           <- N => N'.\n pr1_app  : (app M N) => (app M' N')\n           <- N => N'\n           <- M => M'.\n pr1_lam  : lam M => lam M'\n           <- ({x:trm} x => x -> M x => M' x).\n\nI'm not completely satisfied by the explanation in Frank's paper for why the pr1_beta rule has higher-order premise \"{x:trm} x => x\", but pr1 is reflexive, and that premise seems necessary to prove it.\n\nThe complete development relation is informally given by the following rules:\n\n -----------\n   x ==> x\n\n M ==> M'  N ==> N'\n -----------------  (M is not a lambda)\n (M N) ==> (M' N')\n\n  M ==> N\n --------------\n \\x.M ==> \\x.N\n\n M ==> M'  N ==> N'\n ------------------------\n (\\x.M) N ==> M'[x::=N']\n\nInformally, ==> is the same as => except for the side condition \"M is not a lambda\" on the application rule.  This removes the non-determinism of => and forces ==> to contract every redex in the input term; ==> goes as far as any => can.  ==> is a subrelation of =>.\n\nMy question is how to represent ==> in LF.  There seem to be two issues: how to represent the side condition (the informal system accepts both applications and variables), and what to do about the higher-order premise \"{x:trm} x => x\"  (because ==> is not reflexive).\n\nThanks,\n[[User:Rpollack|Rpollack]] 10:16, 28 February 2008 (EST) Randy\n\n\n: Hi Randy.  This is a great question.  I've started a tutorial answering it: [[Working with higher-order judgements]].  Feel free to discuss the tutorial on its [[Talk:Working with higher-order judgements|talk page]] if it's at all unclear.  [[User:Drl|Drl]] 15:07, 28 February 2008 (EST)\n\n== Question Regarding Explicit LF Specification Generation ==\n\nQuestion: can Twelf produce a fully explicit LF specification from one that is not fully explicit?  By \"fully explicit\", I mean one that needs no further term reconstruction (all type parameters are explicitly bound).  Twelf-sml's Print.sgn is close, but doesn't provide explicit (or even original) %solve or %query directives (nor would I expect it to, as that is not the function's purpose).  As a note, Print.sgn places terms declared as infix in head position, which is fine for my use.\n\nThe reason I am interested in such functionality is that I want to perform some syntactic analyses of LF specifications.  I would like to use existing Twelf specifications as input, but I don't want to manually make type parameters explicit, nor do I want to reimplement term reconstruction.  However the analyses require fully explicit input.\n\nThanks!\n\n== Queries with non-empty contexts? ==\n\nIs it possible to use pi-types in the in the goals for %query? The example below shows what I'm trying to do. Since the workaround using a dummy type family works it does not seem to be an inherent limitation in the logic programming engine...\nThis is Twelf 1.5R1, Mar 8, 2005 (tabling).\n\n<twelf>\nexp : type.\n\napp : exp -> exp -> exp.\nlam : (exp -> exp) -> exp.\n\ntp : type.\n\nunit : tp.\narrow : tp -> tp -> tp.\n\nof : exp -> tp -> type.\n\nof-app : (of E1 (arrow T1 T2)) -> (of E2 T1) -> of (app E1 E2) T2.\nof-lam : of (lam ([x] Body x)) (arrow T1 T2)\n\t  <- {x : exp} {Hx : of x T1} of (Body x) T2.\n\n%% finds a solution as expected:\n%query 1 1 \n  of (lam ([x] (lam ([y] (app x y))))) T.\n\n%% \"found 0\" solutions.\n%query 1 1\n  {x : exp} {Hx : of x (arrow unit unit)}\n  {y : exp} {Hy : of y unit}\n    of (app x y) T.\n\n%% This works, however.\ndummy  : tp -> type.\ndummy1 : dummy T \n\t  <- {x : exp} {Hx : of x (arrow unit unit)}\n\t     {y : exp} {Hy : of y unit}\n\t     of (app x y) T.\n%query 1 1 dummy T.\n</twelf>\n\n== normalization theorems? ==\n\nHello, \n\nI was wandering if the meta logic of Twelf can somehow express (weak or strong) \nnormalization properties.  Or if it currently cannot, what would be a natural extension \nof this meta logic suitable for this?\n\nThanks, \n Andrei Popescu\n\n: See [[Hereditary substitution for the STLC]] for an example of normalization of the simply-typed lambda calculus. The common way of stating theorems in Twelf does not extend to logical relations arguments defined by induction on a type; however, see [[http://www.twelf.org/slr/ Structural Logical Relations]] for a slightly different way to encode these in Twelf (as it currently exists).\n— [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 02:26, 12 October 2008 (EDT)\n\n== More exercises. ==\n\nDear Elves,\n\n    the Twelf web-page is great to learn about it, but I wish you guys could\npost more exercises with answers. It makes it easier to teach teach in the\nclassroom, and it helps self-learners like me. I have coded a simple\nexercise using even/odd numbers, and I am sending it to you guys, so that\nmaybe you could post it at:\nhttp://twelf.plparty.org/wiki/Proving_metatheorems:Natural_numbers:_Answers_to_exercises\n\nAll the best,\n\n[[Special:Contributions/71.106.190.54|71.106.190.54]] 18:25, 23 October 2008 (EDT)Fernando\n\n----------------------------------------------------------------------------\n\nWe have already seen how to proof a theorem showing that the addition of\ntwo even numbers produces an even number. This theorem can be stated as\nfollows:\n\nsum-evens : even N1 -> even N2 -> plus N1 N2 N3 -> even N3 -> type.\n%mode sum-evens +D1 +D2 +D3 -D4.\n\nThe proof of our theorem is a simple case analysis on the possible\nderivations of even numbers:\n\nsez : sum-evens even-z DevenN2 plus-z DevenN2.\n\nses : sum-evens \n       (even-s EvenN1)\n       EvenN2\n       (plus-s (plus-s PlusN1N2N3))\n       (even-s EvenN3)\n       <- sum-evens EvenN1 EvenN2 PlusN1N2N3 EvenN3.\n\n%worlds () (sum-evens _ _ _ _).\n%total D (sum-evens D _ _ _).\n\nIn what follows, you will be asked to write proofs for three similar\ntheorems. Exercise 2 defines lemmas that will be useful in the\nproofs in Exercise 3.\n\nExercise 1: define the odd numbers. Start with one, e.g, s z as your base\ncase, and define the other odd numbers inductively.\n\nAnswer: ==================================================================\n% Odd natural numbers:\nodd   : nat -> type.\nodd-1 : odd (s z).\nodd-s : odd N -> odd (s (s N)).\nAnswer: ==================================================================\n\nExercise 2: now that we have defined the odd numbers, you are asked to\nprove a simple relation between odd and even numbers. First, state and\nprove a Theorem succ-even that shows that the successor of an even number\nis an odd number. After that, state and prove a Theorem succ-odd that\nshows that the successor of an odd number is an even number.\n\nAnswer: ==================================================================\nsucc-even : even N -> odd (s N) -> type.\n%mode succ-even +D1 -D2.\n\nsez : succ-even even-z odd-1.\n\nses : succ-even (even-s EvenA) (odd-s OddA)\n       <- succ-even EvenA OddA.\n\n%worlds () (succ-even _ _).\n%total D (succ-even D _).\n\nsucc-odd : odd N -> even (s N) -> type.\n%mode succ-odd +D1 -D2.\n\nso1 : succ-odd odd-1 (even-s even-z).\n\nsos : succ-odd (odd-s OddA) (even-s EvenA)\n       <- succ-odd OddA EvenA.\n\n%worlds () (succ-odd _ _).\n%total D (succ-odd D _).\nAnswer: ==================================================================\n\nExercise 3: now we would like to prove theorems that state the relation\nbetween sums of odd and even numbers, and between odd numbers.\n\n(3a) First, state and prove the theorem sum-even-odd that shows that the sum\nof an even and an odd number results in an odd number:\n\nAnswer: ==================================================================\nsum-even-odd : even N1 -> odd N2 -> plus N1 N2 N3 -> odd N3 -> type.\n%mode sum-even-odd +D1 +D2 +D3 -D4.\n\nseoz : sum-even-odd even-z OddN2 plus-z OddN2.\n\nseos : sum-even-odd\n       (even-s EvenN1)\n       OddN2\n       (plus-s (plus-s PlusN1N2N3))\n       (odd-s OddN3)\n       <- sum-even-odd EvenN1 OddN2 PlusN1N2N3 OddN3.\n\n%worlds () (sum-even-odd _ _ _ _).\n%total D (sum-even-odd D _ _ _).\nAnswer: ==================================================================\n\n(3b) State and prove a theorem sum-odd-even that shows that the sum of an\nodd plus an even number produces an odd number:\n\nAnswer: ==================================================================\nsum-odd-even : odd N1 -> even N2 -> plus N1 N2 N3 -> odd N3 -> type.\n%mode sum-odd-even +D1 +D2 +D3 -D4.\n\nsoe1 : sum-odd-even odd-1 EvenN2 _ OddN3\n\t<- succ-even EvenN2 OddN3.\n\nsoes : sum-odd-even\n\t(odd-s OddN1)\n\tEvenN2\n\t(plus-s (plus-s PlusN1N2N3))\n\t(odd-s OddN3)\n\t<- sum-odd-even OddN1 EvenN2 PlusN1N2N3 OddN3.\n\n%worlds () (sum-odd-even _ _ _ _).\n%total D (sum-odd-even D _ _ _).\nAnswer: ==================================================================\n\n(3c) Finally, state and prove a theorem sum-odds that shows that the sum\nof two odd numbers produces an even number:\n\nAnswer: ==================================================================\nsum-odds : odd N1 -> odd N2 -> plus N1 N2 N3 -> even N3 -> type.\n%mode sum-odds +D1 +D2 +D3 -D4.\n\nsoz : sum-odds odd-1 OddN2 _ EvenN3\n       <- succ-odd OddN2 EvenN3.\n\nsos : sum-odds (odd-s OddN1) OddN2 (plus-s (plus-s PlusN1N2N3)) (even-s EvenN3)\n       <- sum-odds OddN1 OddN2 PlusN1N2N3 EvenN3.\n\n%worlds () (sum-odds _ _ _ _).\n%total D (sum-odds D _ _ _).\nAnswer: ==================================================================\n\n== %Undefine ==\n\nIs there a way to do the 'opposite' of %abbrev in Twelf? \nConsider the following definition of 'and':\n\n  and : o -> o -> o =\n    [A][B] forall [C] (A imp B imp C) imp C.\n  and_i   : pf A -> pf B -> pf (A and B) = ...\n  and_e1  : pf (A and B) -> pf A = ...\n  and_e2  : pf (A and B) -> pf B = ...\n\nHow could I prevent Twelf from expanding 'and' after this point?\nI'm working on an automated prover based on Felty's and Appel's ideas and\nunnecessary expansion causes the prover to terminate with unintelligible output,\nwhenever it fails to prove something. (The prover outputs all unfinished goals.)\n\n:: Hey! Feel free to contact us by email, I can give you a bit of advice depending on what your precise goals are. I think in Twelf the way of doing this is probably <tt>[[%clause]]</tt>, but it turns out to be a bit messy to do things that way. I discuss two styles of Appel & Felty style proving in the article on [[tactical theorem proving]]. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 09:56, 2 February 2009 (EST)\n\n== hypothetical judgments vs judgments with premises ==\n\nI am having trouble understanding when hypothetical judgments can be used in place of judgments with premises.\nIn the code segment below, the two queries at the bottom look logically equivalent, but Twelf only finds a solution for one of the queries.\nAny help is appreciated.\nThanks,\n--[[Special:Contributions/128.119.240.174|128.119.240.174]] 11:04, 9 February 2009 (EST)\nJohn\n\n<twelf>\n\n% Define elements\nelem : type.\ni : elem.\nj : elem.\n\n% Define lists\nlist : type.\nnil : list.\n, : elem -> list -> list. %infix right 10 ,.\n\n% neq = not equal relation judging when two elements are not equal\nneq : elem -> elem -> type.\n\n% notin A L = A is an element that is not in L\nnotin : elem -> list -> type.\nnotin/nil   : notin A nil.\nnotin/skip  : notin A (B, L)\n\t\t\t  <- neq A B\n\t\t\t  <- notin A L.\n\nsample-list : list = j , j , nil.\n% Solution found for this query:\n%query 1 1 Y : notin i sample-list <- neq i j.\n\n% Solution NOT found this query:\n%query 1 1 Z : {x:neq i j} notin i sample-list.\n\n</twelf>\n\n== proving things about an intensional property ==\n\nI find it easy to prove a Twelf metatheorem that an extensional definiton satsifies certain intensional properties.\nFor example, suppose I define some relation P |- Q using extensional rules (like a sequent calculus).\nSuppose now I have a semantics s |= P that means that P is true in situation s.  Now I want to talk\nabout an intensional property P |= Q, which says forall s such that s |= P, we have s |= Q.\nIn Twelf, it is natural to write a meta theorem that says forall s such that s |= P and P |- Q, then s |= Q.\nIn other words, we can express the idea that the extensional relation satisfies the intensional relation.\n\nBut now I want to prove some theorems such as P |= Q and Q |= R implies Q |= R.\nBut I don't know how to express this idea in Twelf.  This question must come up a lot.\nCan you point me to a tutorial on it?\n\n[[User:Boyland|Boyland]] 16:29, 27 February 2009 (EST)\n\n: I'm not sure I know a way to express this without using a heavy structural-logical-relations-style formulation - it's outside of the forall-exists fragment if you expand the definitions. However, it seems that whenever such a property would be ''needed'' in a proof you could acquire it by calling the theorem you described twice - is that not the case? — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 22:36, 1 March 2009 (EST)\n\n:: Yes, if I needed transitivity, it can easily be proved at that point. But I'm going to try to prove a host of theorems like A * B |= B * A  (which can be rephrased with |=) and P |= Q, A |= B implies P * A |= Q * B which cannot be easily rephrased.  Can you point me to the cleanest tutorial on logical relations? [[User:Boyland|Boyland]] 13:57, 2 March 2009 (EST)\n\n: An interesting side-note.  I tried phrasing |= in Twelf anyway using\n<twelf>\nimplies : term -> term -> type.\n\nimplies/def : ({s} models s P -> models s Q) -> implies P Q.\n</twelf>\nThis works great for proving transitivity, but is terrible at proving anything else, like A * B |= B * A. [[User:Boyland|Boyland]] 13:57, 2 March 2009 (EST)\n\n:: It seems like you want a computational function, not an LF function; I'm working on a framework that would provide you with that: [http://www.cs.cmu.edu/~rwh/papers/unibind/short.pdf A Universe of Binding and Computation].  Would \"mixed datatypes\" in the sense of the introduction of that paper be useful in your definition of \"|=\"? [[User:Drl|Drl]] 19:33, 3 March 2009 (EST)\n\n::: Yes, that is what I need, but it seems not to be part of Twelf! [[User:Boyland|Boyland]] 22:25, 7 July 2009 (EDT)\n\n: A further update: I started working through the structural logical relations paper and got the impression I needed to design a simple sequent calculus with atomic rules specific to my application and then prove a cut elimination theorem (or cut admissibility theorem).  I did this (and learned a bit more about cut elimination).  But then when I went further, I think I bumped into a show stopper: the relation P |= Q includes universal quantification over heaps and thus with the normal Twelf  way, hypothetical heaps. The problem is that I have a lot of theorems about heaps (e.g., associativity of heap addition) and as far as I can understand, none of them will work if there might be a hypothetical heap in the context.\n\n: To be a little more concrete: suppose one has a nat type and a plus operation with an effectiveness lemma.  Suppose one further has a simple assertion language expressed in a sequent calculus with an atomic rule (form/plus N1 N2 N3) defined as true precisely when (plus N1 N2 N3) is true.  Now if I try to form the assertion:forall N exists N2:(form/plus N N N2) , then I cannot use my effectiveness lemma, right?  The \"solution\" is to put every single theorem one needs about nats into the context whenever one has a hypothetical nat.  Is this right?  If so, this approach seems useless.\n\n: I guess the problem is that Twelf doesn't \"know\" that this hypothetical value must be of one of the declared forms (z or s) if it is ever substituted.  I wonder why Twelf doesn't have this ability. Would it make the logic unsound? [[User:Boyland|Boyland]] 22:25, 7 July 2009 (EDT)\n\n::I tried this out in Twelf and got the expected worlds violation:(this code requires my nat.elf \"library\" signature)\n<twelf>\nform : type.\n\nform/plus : nat -> nat -> nat -> form.\n\nform/forall : (nat -> form) -> form.\n\nform/exists : (nat -> form) -> form.\n\n\nhyp   : form -> type.\n\nconc  : form -> type.\n\n\nconc/plus : plus N1 N2 N3 -> conc (form/plus N1 N2 N3).\n\nax    : hyp F -> conc F.\n\nallr  : ({n:nat} conc (F n)) -> conc (form/forall F).\n\nalll  : {n:nat} (hyp (F n) -> conc H) -> hyp (form/forall F) -> conc H.\n\nsomer : {n:nat} (conc (F n)) -> conc (form/exists F).\n\nsomel : ({n:nat} (hyp (F n) -> conc H)) -> hyp (form/exists F) -> conc H.\n\n\n%theorem assert-exists-double :\n\tforall {N}\n\texists {AE: (conc (form/exists ([n] (form/plus N N n))))}\n        true.\n\n- : assert-exists-double N (somer N2 (conc/plus P))\n    <- plus-total P.\n\n%worlds () (assert-exists-double _ _).\n%total { } (assert-exists-double _ _).   % Just fine.\n\n\n%theorem assert-exists-double2 :\n\texists {AE: (conc (form/forall ([n] (form/exists ([n2] (form/plus n n n2))))))}\n        true.\n\n- : assert-exists-double2 \n     (allr ([n:nat] (somer (N2 n) (conc/plus (P n)))))\n    <- ({n:nat} plus-total* n n (N2 n) (P n)).\n\n%worlds () (assert-exists-double2 _).   %  NB: world violation!\n%total { } (assert-exists-double2 _).\n</twelf>\n::: It makes sense that this is rejected in Twelf, because the \"function\" (N2 n) has no ability to be expressed in LF.  But this does mean that the limitation of Twelf's metatheorems is a live issue: not put to rest by the \"Structural Logical Relations\" paper.\n\n: After some discussion with Karl Crary, it seems that the best solution is to define an empty relation, define some trustme \"metatheorems\" that express the desired properties and then prove all theorems in a context (worlds) with a variable of the empty relation.  This ensures that Twelf will not split on the empty relation. [[User:Boyland|Boyland]] 15:26, 20 February 2010 (EST)\n\n== Negative premises ==\n\nI'm attempting to express the operational semantics of concurrent calculi like CCS in Twelf, but the inference rules for these calculi often require negative premises. I was wondering if such a thing is possible in Twelf.\n\nBelow is my specification for (part of) a CCS-like language without the rule for hiding actions. Here, 'trans P1 A P2' represents a transition from P1 to P2 labelled with A.\n\n<twelf>\nlabel : type.\nproc : type.\n\na : label.\nb : label.\nc : label.\nd : label.\n0 : proc.\n\n, : label -> proc -> proc.\n+ : proc -> proc -> proc.\n| : proc -> proc -> proc.\n\n%infix right 12 ,.\n%infix left 10 +.\n%infix left 9 |.\n\ntrans : proc -> label -> proc -> type.\n\npref-rule : {A:label} {P:proc} trans (A , P) A P.\nsuml-rule : {A:label} {P1:proc} {Q:proc} {P2:proc} trans P1 A P2 -> trans (P1 + Q) A P2.\nsumr-rule : {A:label} {P1:proc} {Q:proc} {P2:proc} trans P1 A P2 -> trans (Q + P1) A P2.\nparl-rule : {A:label} {P1:proc} {Q:proc} {P2:proc} trans P1 A P2 -> trans (P1 | Q) A (P2 | Q).\nparr-rule : {A:label} {P1:proc} {Q:proc} {P2:proc} trans P1 A P2 -> trans (Q | P1) A (Q | P2).\n</twelf>\n\nIn order to encode the rule for hiding, I would need something like this:\n\n<twelf>\n\\ : proc -> label -> proc.  %infix left 11.\n\nhide-rule: {A:label} {P1:proc} {P2:proc} trans P1 A P2 -> A != B -> trans (P1 \\ B) A (P2 \\ B)\n</twelf>\n\nwhere A != B is meant to be inequality of labels. Is there a simple way of encoding such negative premise?\n\n:: Unfortunately, no: you'll have to define the != judgement inductively yourself, by giving a case for each pair of non-equal labels (and then you may need to prove that A != A is a contradiction).  But we're working on [http://www.cs.cmu.edu/~drl/pubs/lh09unibind/lh09unibind.pdf a framework where you could express this directly], so thanks for the example!  [[User:Drl|Drl]] 14:28, 4 May 2009 (EDT)\n\n== Coverage checking ==\n\nI am having trouble understanding the behavior of the coverage checker on this example, a snippet of a dependently-typed functional language encoding:\n<code>\ntp : type.\n\nvl : tp -> type.\t % values\ntm : tp -> type.\t % terms\nobs : tp -> tp -> type.\t % \"observations\"\n\n! : vl A -> tm A.\n  %prefix 90 !.\ncut: obs A B -> vl A -> tm B.\n\n%% body is a functional relation, defining each value\n%% as a \"map from observations to terms\".\nbody : vl A -> obs A X -> tm X -> type.\n%mode body +V +C -E.\n\n%% We introduce one kind of type, pi (and non-depenendent =>)...\npi : {a:tp} (vl a -> tp) -> tp.\n=> : tp -> tp -> tp = [A] [B] pi A [_]B.\n  %infix right 120 =>.\n\n%% With one kind of observation on pi...\n@ : {x:vl A}obs (B* x) C -> obs (pi A B*) C.\n  %infix right 120 @.\n\n%% Now we define function abstraction...\nfn : ({x:vl A}vl (B* x)) -> vl (pi A B*).\nfn/_ : body (fn E*) (V @ K) E'\n\t<- body (E* V) K E'.\n\n%% At this point, we could verify that body covers and is unique,\n%% by uncommenting the following lines...\n% %worlds () (body V C _).\n% %covers body +V +C -E.\n% %unique body +V +C -E.\n\n%% Now we define *non-dependent* function application...\napp-nd : vl (A => B) -> vl A -> vl B.\napp-nd/_ : body (app-nd F V) C E'\n\t<- body F (V @ C) E'.\n\n%% Again, we could verify that body covers and is unique...\n% %worlds () (body V C _).\n% %covers body +V +C -E.\n% %unique body +V +C -E.\n\n%% However, now consider *dependent* function application,\n%% with essentially the same body clause...\napp : vl (pi A ([x]B* x)) -> {x:vl A} vl (B* x).\napp/_ : body (app F V) C E'\n\t<- body F (V @ C) E'.\n\n%% Suddenly, the coverage check fails...\n% %worlds () (body V C _).\n% %covers body +V +C -E.\n% %unique body +V +C -E.\n</code>\nAny ideas? Thanks, [[User:Noam|Noam]] 07:43, 19 September 2009 (EDT)\n\n: Okay now I see that the problem is [[Debugging_coverage_errors#Inactive_Splits|Inactive Splits]]. I don't quite understand what the suggested workaround is (is there an example somewhere?), but I figured out something, which may or may not amount to the same thing...\n\n: Begin by defining a tp to internalize the LF application:\n<code>\ntapp : (vl A -> tp) -> vl A -> tp.\nt@ : obs (B* V) X -> obs (tapp B* V) X.\n</code>\n: Then assign app a type in terms of tapp, and give a slightly tweaked body clause:\n<code>\napp : vl (pi A ([x]B* x)) -> {x:vl A} vl (tapp B* x).\napp/_ : body (app F V) (t@ C) E'\n\t<- body F (V @ C) E'.\n</code>\n: Now this coverage checks! [[User:Noam|Noam]] 00:58, 20 September 2009 (EDT)\n\n== Twelf User Manual ==\n\nIs the user manual for Twelf version 1.5 available? I only noticed that for version 1.4 on Twelf Web site.\n\n== freezing violation: X would depend on Y ==\n\nOccasionally the Twelf type checker will generate variables of type such as term -> nat and then complain that nat would depend on term in that case.  I find this error message frustrating since (1) I didn't create this variable -- it was generated from an implicit underscore, (2) Since nat does NOT depend on term (e.g.), then why does Twelf generate the dependency, and (3) Just because we have a value of type term -> nat, it doesn't mean that nat depends on term, but rather that the function must ignore its argument.  \n\nAnother frustrating thing is that it interferes with incremental proof development: I often supply cases to theorem after earlier (unsuccessfully) checking totality.\nIn this case I get the error message \"Freezing violation: constant - extends type family X\" which I ignore and then check totality again.\nWhen totality succeeds, I conclude that the theorem is done, but if I read the theorem in over again, it gets this \"nat would depend on term\" error message.\n\nBTW: I'm using latest CVS Twelf (1.5R3) which apparently has been frozen for a few years.  Is this a bug that has since been fixed?\n\nIf it would be helpful, I can try to generate a small example which causes this behavior.[[User:Boyland|Boyland]] 15:37, 20 February 2010 (EST)\n\n:Here is a relatively small example that indicates the problem:\n<twelf>\n%%%% Definitions\n\n%% Define natural numbers\n\nnat : type.\n\nz : nat.\ns : nat -> nat.\n\n\n\n%% Define terms\n\nterm : nat -> type.\n\n%abbrev t = term z.\n\n\nlit : nat -> t.\n\n\n%% equality on terms\n\neq : term N1 -> term N2 -> type.\n\n\neq/ : eq T T.\n\n\n\n\n%%% Variable levels and nolevel\n\n\nvar : term N -> type.\n\n%block blockvar : some {n} block {t:term n} {v:var t}.\n\n% without this, we get a freezing violation: var would depend on var\nfake : type.\n- : (var X -> var X') -> fake.\n\n\n\n%%% Variable lists\n\n\nvarlist : type.\n\nvarlist/0 : varlist.\n\nvarlist/+ : {N} {V:term N} var V -> varlist -> varlist.\n\n\n\n%%% Operations on variable lists:\n\n\ncount : varlist -> nat -> nat -> type.\n\nlookup : varlist -> term N -> varlist -> type.\n\n\ncount/0 : count varlist/0 N z.\n\ncount/= : count VL N M ->\n    count (varlist/+ N V _ VL) N (s M).\n\n\nlookup/= : lookup (varlist/+ _ V _ VL) V VL.\n\nlookup/!= :\n\tlookup VL V VL' ->\n    lookup (varlist/+ _ _ _ VL) V VL'.\n\n\n\n%%% Theorems about operations on varlists.\n\n\n%theorem count-independent:\n\tforall* {N} {N'} {M} {VL}\n\tforall\t{FC: {v:term N} (var v) -> count VL N' M}\n\texists\t{C: count VL N' M}\n\ttrue.\n\n- : count-independent ([v] [i] count/0) count/0.\n\n- : count-independent ([v] [i] count/= (FC v i)) (count/= C)\n    <- count-independent FC C.\n\n%worlds (blockvar) (count-independent _ _).\n%total (C) (count-independent C _).\n\n\n%theorem lookup-count-independent:\n\tforall* {N} {N'} {FVL} {FFVL'} {M}\n\tforall\t{FFL: {v': term N'} {i': var v'} {v: term N} {i: var v}\n\t\t       lookup (FVL v i) v (FFVL' v' i' v i)}\n\t\t{FFC: {v': term N'} {i': var v'} {v: term N} {i: var v}\n\t\t       count (FFVL' v' i' v i) N M}\n\texists\t{FVL': {v: term N} {i:var v} varlist}\n                {FL: {v: term N} {i:var v} lookup (FVL v i) v (FVL' v i)}\n\t\t{FC: {v: term N} {i:var v} count (FVL' v i) N M}\n\ttrue.\n\n- : lookup-count-independent ([v'] [i'] [v] [i] lookup/=) FFC _ ([v] [i] lookup/=) FC\n    <- ({v} {i} count-independent ([v'] [i'] FFC v' i' v i) (FC v i)).\n\n- : lookup-count-independent ([v':term N'] [i':var v'] [v:term N] [i:var v] lookup/!= (FFL v' i' v i)) FFC ([v] [i] FVL v i)\n     ([v:term N] [i:var v] lookup/!= (FL v i)) FC\n    <- lookup-count-independent FFL FFC _ FL FC.\n\n%worlds (blockvar) (lookup-count-independent _ _ _ _ _).\n%total (L) (lookup-count-independent L _ _ _ _).\n</twelf>\n:: This code checks fine with the online version of Twelf.  It must be a problem with Twelf-CVS.\n:: Update: The code still fails with the latest truck from SVN.  So it seems the online twelf checker has a different version than twelf-CVS/SVN.  older? [[User:Boyland|Boyland]] 18:17, 22 February 2010 (EST)\n\n== Termination and %mode ==\n\nHi Twelf Elf: I've just started getting into twelf and have been working my way through Frank Pfenning's Computation and Deduction notes  (http://www.cs.cmu.edu/~fp/courses/comp-ded/handouts/cd.pdf). I got so far as trying to get twelf to confirm that doubling 2 yields 4, but it gets stuck. (I'm also using the latest release of twelf, not the nightly build version.)\n\nBelow is my complete program; when I run it in twelf, it does not seem to terminate.\n\nAny advice?\n\nThanks,\nRobby\n\n<twelf discard=true>\n exp : type.\n z : exp.\n s : exp -> exp.\n case : exp -> exp -> (exp -> exp) -> exp.\n lam : (exp -> exp) -> exp.\n app : exp -> exp -> exp.\n fix : (exp -> exp) -> exp.\n\n eval : exp -> exp -> type.\n ev_z : eval z z.\n ev_s : eval E V -> eval (s E) (s V).\n ev_case_z : eval E1 z -> eval E2 V -> eval (case E1 E2 ([y:exp] E3 y)) V.\n ev_case_s : eval E1 (s V1)\n          -> eval (E3 V1) V\n          -> eval (case E1 E2 E3) V.\n ev_lam : eval (lam F) (lam F).\n ev_app : eval E1 (lam F) -> eval E2 V2 -> eval (F V2) V -> eval (app E1 E2) V.\n ev_fix : eval (E1 (fix E1)) V -> eval (fix E1) V.\n\n double : exp = fix ([double : exp] \n \t\t\t\t\t  (lam [i : exp] \n \t\t\t\t\t\t (case i\n \t\t\t\t\t\t\tz \n \t\t\t\t\t\t\t([iminusone : exp] (s (s (app double iminusone))))))).\n \n %query 1 1 D : eval (app double (s z)) (s (s z)).\n</twelf>\n\n---------\n\nHi Robby! Glad you're using Twelf. I'd definitely encourage you to use the \"nightly build\" - it's currently very stable and has lots of improvements (and fewer bugs) than the last release. Also, it's a good idea to sign your comment with four tildes <nowiki>~~~~</nowiki> \n\nAnyway - I had a hunch, that turned out to be right, that the right thing to do was to write a <tt>[[%mode]]</tt> declaration <tt>%mode eval +E -V.</tt>, which basically means \"it makes sense to run <tt>eval</tt> as a function with input <tt>E</tt> and output <tt>V</tt>. Sure enough, it complains about both the rule <tt>ev_case_s</tt> and <tt>ev_app</tt>. If I reorder the premises so it no longer complains, the two rules look like this:\n<twelf>\nev_case_s : eval (E3 V1) V\n         -> eval E1 (s V1)\n         -> eval (case E1 E2 E3) V.\nev_app : eval (F V2) V \n         -> eval E2 V2 \n         -> eval E1 (lam F) \n         -> eval (app E1 E2) V.\n</twelf>\nIn general, it's better to use backwards arrows when you intend to be running something as a logic program; the above program \"looks better\" written as this equivalent program:\n<twelf>ev_case_s : eval (case E1 E2 E3) V\n         <- eval E1 (s V1)\n         <- eval (E3 V1) V.\nev_lam : eval (lam F) (lam F).\nev_app : eval (app E1 E2) V\n         <- eval E1 (lam F) \n         <- eval E2 V2 \n         <- eval (F V2) V.\n</twelf>Good luck learning Twelf, let us know if we can help you in the future! — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 16:04, 1 November 2010 (EDT)\n-------\n\nAlso, you can use this to run programs even if you don't know the answer:\n<twelf hidden=true import=modequestion>\nexp : type.\nz : exp.\ns : exp -> exp.\ncase : exp -> exp -> (exp -> exp) -> exp.\nlam : (exp -> exp) -> exp.\napp : exp -> exp -> exp.\nfix : (exp -> exp) -> exp.\neval : exp -> exp -> type.\nev_z : eval z z.\nev_s : eval E V -> eval (s E) (s V).\nev_case_z : eval E1 z -> eval E2 V -> eval (case E1 E2 ([y:exp] E3 y)) V.\nev_case_s : eval (case E1 E2 E3) V\n         <- eval E1 (s V1)\n         <- eval (E3 V1) V.\nev_lam : eval (lam F) (lam F).\nev_app : eval (app E1 E2) V\n         <- eval E1 (lam F) \n         <- eval E2 V2 \n         <- eval (F V2) V.\nev_fix : eval (E1 (fix E1)) V -> eval (fix E1) V.\ndouble : exp = \n  fix ([double : exp] \n    (lam [i : exp] \n      (case i z ([iminusone : exp] (s (s (app double iminusone))))))).\n%mode eval +A -B.\n</twelf>\n<twelf import=modequestion check=decl>\n %query 1 1 eval (app double (app double (app double (s (s (s z)))))) V.\n</twelf><twelflink import=modequestion>See the corrected Twelf code along with this query</twelflink> — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 16:14, 1 November 2010 (EDT)\n\n-------\n\nThanks! I had read about %mode, and had even tried it with the definition of eval I posted above (getting the errors you allude to), but what I read about modes didn't suggest that ordering of the premises had any influence on the mode declaration. (Of course, I've now tried out your revision and sure enough I see that it does.). Is there more I should read about that? (So far I've just read 4.5 in _Computation and Deduction_.)\n\nAnd yes, I do know how to run things without knowing the answer; of course it also didn't work for the example given. I put in the precise answer in a futile hope that that would help twelf terminate. Thanks also for the wiki advice. I'm amazed that it's taken me this long to post on one.... one question about wiki's tho: I had to come back here to see you'd posted. Is there a way to get email notification? (I had already clicked the \"watch this page\" checkbox.)\n\n[[User:Robby|Robby]] 11:28, 2 November 2010 (EDT)\n\n-------\n\nI think this wiki has email turned off, actually. To understand the effect of %mode  you might find it helpful to read some general stuff about logic programming, which is where a lot of the intuition behind proving metatheorems comes from. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 12:11, 4 November 2010 (EDT)\n\n== POPL tutorial slides location? ==\n\nThe slides linked to from [[POPL Tutorial]] are 404. I tried to use Google to find the slides, but it was no help. [[User:Jbapple|Jbapple]] 15:09, 15 January 2011 (EST)\n\n== Twelf 1.7.1 ? ==\n\nIt seems Twelf 1.7.1 is released, but the documentation still seems to be at 1.4\n(with some wiki pages for 1.5 additions.)\n\n(1) Is there any summary of changes since 1.4/1.5 ?\n\n(2) Any plans to update the 1.4 documentation?\n\n:: I don't know of any plans to do so (I think the wiki is now, for better or worse, the primary documentation). We should probably go through the wiki and turn some of the tags indicating \"this is a SVN-only feature\" to tags indicating \"this is a Twelf 1.7 feature,\" though. There is a [[revision history]] on the wiki. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 21:33, 24 August 2011 (EDT)\n\n== Problem to find an induction metric ==\n\nI would like to prove that if two numbers are the same, e.g., N0 = N1, then, if I set the K-th position of a list to N0, or to N1, I get the same resulting list. The proof is not obvious to me because I cannot, in this case, do induction on the derivation rules of lists. I have these signatures for numbers:\n\n<twelf>\nnat   : type.\nz     : nat.\ns     : nat -> nat.\n\n% eq N1 N2 is true if N1 and N2 represent the same number.\neq : nat -> nat -> type.\n%mode eq +N1 +N2.\neq_z : eq z z.\neq_s : eq (s N1) (s N2)\n    <- eq N1 N2.\n%worlds () (eq N1 N2).\n%terminates {N1 N2} (eq N1 N2).\n</twelf>\n\nAnd these signatures for the list:\n\n<twelf>\nlist : type.\nelement : type.\nnil : list.\ncon : element -> list -> list.\nvalue : nat -> element.\n\n% set L E N L' == L' is the same list as L, except that its N-th cell has\n% been set to E.\nset : list -> element -> nat -> list -> type.\n%mode set +L +E +N -L'.\nset_z : set (con E' EL) E z (con E EL).\nset_s : set (con E' L) E (s N) (con E' L')\n    <- set L E N L'.\n</twelf>\n\nAnd below is the theorem that I would like to prove:\n\n<twelf>\neq_set : eq N N' -> set L (value N') V L' -> set L (value N) V L' -> type.\n%mode eq_set +Eq +Set' -Set.\n\neq_set_z : eq_set eq_z Set Set.\n% eq_set_s ???\n\n%worlds () (eq_set _ _ _).\n%total Eq (eq_set Eq _ _).\n</twelf>\n\n:: I think you need to determine an equality judgment on L', and prove \n<twelf>\n        eq_set : eq N N' -> set L (value N') V L' -> set L (value N) V L' -> eq-list L L' -> type.\n        %mode eq_set +Eq +Set' +Set -Eq'.\n</twelf>\n:: Does that help at all? — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 16:55, 18 June 2012 (EDT)\n\n== trouble with twelf server ==\n\nHi,\n\nIm doing my final year project on LF and imperative languages and Ive decided to use Twelf to mechanize the theory, however, I'm finding it difficult to start the server on Linux, while on OsX had no problem. Please help. I've dwnloaded the pre-installed Linux version on Ubuntu and straight away I call bin/twelf-server, however this error comes up:\n\n@ubuntu:~/twelf$ bin/twelf-server \nbin/twelf-server: error while loading shared libraries: libgmp.so.3: cannot open shared object file: No such file or directory\n\nWhat am I missing? For what ive understood I do not need to use Make as is pre-installed, right? So I should be a ble to run it from scratch....\n\nLooking forward to hear from you,\nJ. Dominguez\n\n\n:: Sorry for not noticing this before; the MLton-compiled binary depends on the GMP BigNum library, which you should be able to get with apt-get on ubuntu. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 16:52, 18 June 2012 (EDT)\n\n== How to prove totality in this case? ==\n\nI am formalizing a programming language. One of the things I need is a conditional statement and prove its totality (this is needed for dynamic semantics, that has to search through an associative list, and the keys have decidable equality). I can do a simple one, like this:\n\n<pre>\nbool : type.\ntrue : bool.\nfalse : bool.\n\n% my language has expressions and computations\nexpr : type.\ncomp : type.\n\n% lambda abstraction and injection of expressions into computations create a headache later on\nfun : (expr -> comp) -> expr.\nval : comp -> expr.\n\ncond-expr : bool -> expr -> expr -> expr -> type.\n%mode cond-expr +B +E +E' -E''.\n\n- : cond-expr true E _ E.\n- : cond-expr false _ E' E'.\n\n%worlds () (cond-expr _ _ _ _).\n%total {B E E'} (cond-expr B E E' _).\n</pre>\n\nSo far so good. But I actually need a slightly more complicated conditional:\n\n<pre>\n%abbrev cow = (expr -> (expr -> comp) -> comp).\n\ncond-cow : bool -> cow -> cow -> cow -> type.\n%mode cond-cow +B +Moo +Moo' -Moo''.\n\n- : cond-cow true Moo _ Moo.\n- : cond-cow false _ Moo' Moo'.\n</pre>\n\nNow suppose we want to check totality of <code>cond-cow</code>:\n\n<pre>\n%worlds () (cond-cow _ _ _ _).\n%total {B Moo Moo'} (cond-cow B Moo Moo' _).\n</pre>\n\nThen we get this error message:\n<pre>\nWhile checking constant %-%:\nFamily expr has no worlds declaration\n%% ABORT %%\n</pre>\n\nSo one would like to add <code>%worlds</code> for <code>expr</code> and <code>comp</code>. But if I try something like\n<pre>\n%worlds () (expr).\n%worlds () (comp).\n</pre>\nI get \"<code>comp</code> would depend on <code>expr</code>\".  And I think that <code>val</code> and <code>fun</code> can be a further source of trouble. \n\nI am stumped. Why is it even analyzing <code>cow</code>? What is Twelf thinking and how to I fix it?\n\nThanks! Andrej Bauer (please notify me by email about the answer at Andrej.Bauer@andrej.com)\n\n: I think you need to declare the worlds of both expr and comp together as in\n<pre>\n%worlds () (expr) (comp).\n</pre>\n: [[User:Boyland|Boyland]] 15:28, 5 June 2013 (EDT)\n\n== %reduces not as smart as what is done in %total, it seems ==\n\nI don't see a way to prove %reduces through a lambda abstraction,\nalthough, it appears that %total checking is able to reason about\nthese.  For example:\n\n<twelf>\n%% HOAS for LC\n\nt : type.\n\nlam : (t -> t) -> t.\n\napp : t -> t -> t.\n\n\nm : t -> t -> type.\n\nm/0 : m T T.\n\nm/app1 : m T1 T2 -> m (app T1 _) T2.\n\nm/app2 : m T1 T2 -> m (app _ T1) T2.\n\nm/lam : ({x} m (F x) T) -> m (lam ([x] F x)) T.\n\n%reduces T2 <= T1 (m T1 T2).\n</twelf>\n\nThis gives error\n\nReduction violation:\nPi (T) <= (F x) ---> (T) <= (lam ([x:t] F x))\n\nIs there a workaround to this problem?\n[[User:Boyland|Boyland]] 05:07, 3 October 2013 (EDT)\n\n:: What's an example where this works for %total?\n\nHere's one that checks just fine: [[User:Boyland|Boyland]] 08:51, 11 October 2013 (EDT)\n<twelf>\n\nnat : type.\n\nz : nat.\n\ns : nat -> nat.\n\nmax : nat -> nat -> nat -> type.\n%mode max +N1 +N2 -N3.\n\nmax/zz : max z z z.\n\nmax/sz : max (s N) z (s N).\n\nmax/zs : max z (s N) (s N).\n\nmax/ss : max N1 N2 N3 -> max (s N1) (s N2) (s N3). \n\n%worlds () (max _ _ _).\n%total (N) (max N _ _).\n\n\nheight : t -> nat -> type.\n%mode height +T -N.\n\n%block hb : block {x} {h:height x z}.\n\nheight/lam : ({x} (height x z) -> height (F x) N) -> height (lam F) (s N).\n\nheight/app : height (app T1 T2) (s N3)\n    <- height T1 N1\n    <- height T2 N2\n    <- max N1 N2 N3.\n\n%worlds (hb) (height _ _).\n%total (T) (height T _).\n</twelf>\n\n== dictionary in which keys are variable names ==\n\nDear Elfs,\n\nWe are using Twelf for implementing a language semantics. We have typing judgement of the form:\n\nΓ |- e : τ : Ω\n\n- Γ is the context\n- e is the expression\n- τ is the type\n-  Ω is a set of relations between variables in e and a label\n\nFor this typing judgement, we would like to have the following mode: \n\n%mode of +E -T -L.\n\nFor instance:\n\nx : int, y: int |- x + y + 1 : int : {x:low, y: high} \n\nIn our typing semantics, we have some rules that modifies Ω and others that retrieve a label given a specific variable name. \n\nTo implement this, we have 2 options:\n- implement a complex way to deal with variables which means redefining substitution and so on (very tedious)\n- use twelf variables in our expression to write expressions such as \"λx:int.x\" as \"lambda int ([x] x)\" but we need an elfy magic trick to implement Ω\n\nDo you have examples or ideas about how to implement some sort of dictionary in which keys are actual variable names?  \n\nI hope all of this was clear. \n\nThank you. \n\nThierry\n\n: Either way should be possible.  \n:If you implement explicit (non-LF) variables, then as you say, you need to define substitution etc yourself, which is a pain.  But you can use the set/map types in my Twelf library.\n:Otherwise, trying to implement a true (\"adequate\") map from variables to sets of labels is very tricky.  It can be done but will pollute your context with tons of extra things.  See [[HOAS nat bijection]].\n:The big problem is \"inequality\".  It's very difficult to determine if two variables are equal or not in Twelf.\n:[[User:Boyland|Boyland]] 11:02, 13 January 2014 (EST)\n\n== Twelf bug reports? ==\n\nIs Twelf still being maintained?  I have a (BIG) example where type reconstruction doesn't terminate in Twelf 1.7.1+ (r1887M).  Is anyone interested in bug reports?\n\n== Syntax highlighting for IntelliJ IDEA ==\n\nGood evening Twelf Elf, \n\nI have created an IntelliJ plugin for Twelf which can be downloaded from the IntelliJ plugin repository: \nhttp://plugins.jetbrains.com/plugin/7533\n\nThe source code is also available on Github:  \nhttps://github.com/alahijani/Jelf\n\nYou can download IntelliJ IDEA community edition from: \nhttp://www.jetbrains.com/idea/download/\n\nSorry, I could not find a publicly editable notice board. Is there a place where I can post instructions?\n\n[[User:Ali|Ali]] 02:23, 19 August 2014 (EDT)\n\n== Problems with pages ==\n\nSee for example [[Lax logic]] where errors reported with: \"Failed to parse (PNG conversion failed; check for correct installation of latex, dvips, gs, and convert)\" occur very frequently.\n\n[[User:Fairflow|Fairflow]] 04:11, 9 December 2014 (EST)\n\nI don't see the problem.  Perhaps (1) it has been rsolved, or (2) it may be browser related?\n[[User:Boyland|Boyland]] ([[User talk:Boyland|talk]]) 21:00, 21 October 2016 (UTC)\n\n== Can’t solve obvious goal or is it me? ==\n\nI’m new to Twelf (have to see it matches what I’m planning to do).\n\nTesting the very simple sample below:\n\n    nat : type.\n    z : nat.\n    s : nat -> nat.\n    sum : nat -> nat -> nat -> type.\n    sum/z : sum z N N.\n    sum/s : sum M (s N) (s S) <- sum M N S.\n\nThen querying this:\n\n    %query 1 * sum (s z) (s z) X.\n\nIt fails. While if `sum/s` is changed from `sum/s : sum M (s N) (s S) <- sum M N S.` to `sum/s : sum (s M) N (s S) <- sum M N S.` it works.\n\nUnless I’m wrong, the goal should be as much solvable is both case. Is this me missing something?\n\n== Twelf pre-built Mac OS distro needs update ==\n\nDear Twelf Elves,\n\nMac OS X Catalina deprecated running 32-bit apps, and the pre-built Mac OSX distro of Twelf does not work anymore.\n(Building from source with SMLNJ still works.)\n\nCould this be updated?\n\nThanks."
          },
          "sha1": "1irnwpar15flqpib5ojsi9ev3kp0mc5"
        }
      },
      {
        "title": "Talk:Ask Twelf Elf/Archive 1",
        "ns": 1,
        "id": 1906,
        "revision": {
          "id": 4184,
          "timestamp": "2007-03-16T01:03:51Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "archive",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 5188,
            "#text": "The idea for having a rotating position for someone who is responsible for answering questions about Twelf was suggested during a meeting with Karl today. If the idea of answering e-mails about Twelf in a timely fashion appeals to you, please volunteer. Right now, the e-mail address is on gmail. There might be a better option, but right now I think gmail is not a terrible idea, because who cares if google is secretly monitoring the knowledge we'd like to share, and also because I'd like to use google calendar to keep track of who is on rotation. This was also the 50th article on the Twelf wiki! I am going to set down a charter for people on the rotation. This is essentially customer service, so I'm setting down a reasonable set of rules to make sure we do a good job. --[[User:DanielKLee|DanielKLee]] 18:06, 13 October 2006 (EDT)\n\nThis is probably going to be a pretty low work job for a while (hopefully this will change once the wiki goes public). I think two week rotations are reasonable while this has no/very little traffic, but we may drop this to a week of this becomes a demanding job. --[[User:DanielKLee|DanielKLee]] 18:11, 13 October 2006 (EDT)\n\nCharter and rotation moved to [[Twelf Elf Rotation Charter]].\n\n== Volunteer here ==\n\n*Ooh! Me Me! :P  --[[User:DanielKLee|DanielKLee]] 18:06, 13 October 2006 (EDT)\n*Volunteering, though this is an aspect of this grand experiment I am unceratian about I'll admit. You need to let others edit the google calendar somehow. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 19:04, 13 October 2006 (EDT)\n\n\n\n== Wiki? ==\n\nI think this is a good idea, but why don't we use the Wiki to do it? I think this would increase usage and increase the likelihood that answers get posted to the Wiki, which means that the effort has more broad results. If there's some technological issue, I'm sure we can figure out how to get around it. We're smart. &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 18:12, 13 October 2006 (EDT)\n: There's a way to do input forms to automatically insert things in to wiki pages. I also am uncertain that the best way to do this is email, and given that that the best way to do it is gmail... What about the coffee@cs.cmu.edu model, where it forwards to a mailing list even though you may think it's just a person? — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 19:02, 13 October 2006 (EDT)\n:: I'm definitely open to better technology for doing this (especially if it is integrated into the wiki). Gmail isn't necessarily the best way to handle the e-mail (the other alternative is IMAP which I'm okay with), it's just a way that seemed reasonable when I decided to get the ball rolling. We can setup Gmail to forward to everyone on the rotation (or anyone who wants all the incoming e-mails). The most important aspect of this is that there is someone whose job it is to answer questions. So this person can watch the mailbox, a mailing list, the wiki, whatever, as long as he checks it once a day. Although I do think we'll need to keep the e-mail address for people who are too shy to ask the question on the wiki, but would grudgingly ask it over e-mail. --[[User:DanielKLee|DanielKLee]] 20:32, 13 October 2006 (EDT)\n:: I'm suggesting that people actually leave their questions on the wiki itself. Why not? &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 20:34, 13 October 2006 (EDT)\n::: I suppose there is an argument for people being more likely to just email a person rather than an anonymous list, and perhaps I kind of buy it. However, having created [[manipulating proof witnesses as inputs]] I'm a little worried that this project may make the wiki itself look like a ''small'' time-waster... — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 01:10, 14 October 2006 (EDT)\n:::: OK, we can leave the e-mail open too. I think we should encourage people to post their questions, though (perhaps anonymously). Can't we do the calendar on the wiki? &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 10:01, 14 October 2006 (EDT)\n::::: I agree, do we need google calendar, given a signup on the wiki? I am a big fan of google calendar, but adding a new item to every single day is more than a bit of a pain. And we can just forward the twelfelf account to another account for the duration of our on-duty periods, which would make it easier to give this the correct amount of continuous partial attention. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 12:57, 14 October 2006 (EDT)\n:::::: Adding an all-day event for two weeks is a single action. Maybe we should phase out the calendar in favor of a protected page, though. The forwarding is easy to do.--[[User:DanielKLee|DanielKLee]] 18:17, 14 October 2006 (EDT)\n\n== Want anything here? ==\n\nWe should clear these procedural discussions if this is the place people will be asking questions.  Anyone want anything on this page, or should I just delete it?  [[User:Drl|Drl]] 18:28, 15 March 2007 (EDT)\n:: How about we just archive it? — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 20:17, 15 March 2007 (EDT)\n::: OK. I don't know how to do that, but please do!  [[User:Drl|Drl]] 20:35, 15 March 2007 (EDT)"
          },
          "sha1": "lstjmyiju7mra6m3gsaf8m312ft5ref"
        }
      },
      {
        "title": "Talk:Ask Twelf Elf/Archive 2",
        "ns": 1,
        "id": 2029,
        "revision": {
          "id": 5021,
          "timestamp": "2007-10-28T23:45:40Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "Create Archive 2",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 19909,
            "#text": "== two questions from a complete novice. ==\n\n1 I can't find any papers comparing Coq and Twelf.  Can someone summarize the differences?\n\n2 Can you explain the vast difference in style between the examples shown on this site and what is done by Andrew Appel at Princeton?  The two styles seem as if they are two completely different languages!\n\nThanks.\n-Michael Fortson\n\n: Hi Michael; thanks for your questions!  I've started answering them on the [[Ask Twelf Elf:Short answers|Answers page]]. [[User:Drl|Drl]] 16:43, 8 April 2007 (EDT)\n\n== Forcing coverage checker to split on particular variables ==\n\nI'm writing a proof of something that involves a relation (synchronizes-with) between\ntwo evaluation relations.  Evaluation is defined (basically) as a pair of two execution\nstates, each including a program term.  Something like:\n  eAdd : plus I1 I2 I3 -> eval (add (lit I1) (lit I2)) (lit I3)\n(Here's I'm highly simplifying my example).\n\nNow in my proof, I do case analysis based on the evaluation relation\n  eAdd: ..\n  eSub: ...\n  ...\nBut the Twelf coverage checker insists on splitting on the term syntax instead,\nand so finds hundreds of cases I haven't handled, such as\n  eval (add (lit I1) (lit I2)) (sub (lit I3) (lit I4))\nbut of course, I don't handle this case because it doesn't occur.\n\nTurning chatter on to 6, I can see that the coverage checker considers splitting\non the evaluation relation but then finds that the syntax has fewer\nchoices and so decides to split on it instead; and because syntax is recursive,\nit can do such splits indefinitely until it gives up.\n\nHow can I convince the input coverage checker (called with %total)\nto split on the \"correct\" variable?\n\nFor completeness, here is the lemma itself.\nIt uses many thousands of lines of previous Twelf code that I could\nzip up if it would help, but I expect that other people have encountered\nthe same problem before:\n<twelf>\n%theorem synchs-with?-total*/hold+synch :\n\tforall* {G} {P1} {M1} {KN1} {A1} {O1} {O1'} {S1'}\n                    {P2} {M2} {KN2} {A2} {O2} {T2}  {S2'} {CO}\n        forall \n        {E1:eval G P1 (state/ M1 KN1 (hold A1 O1 (lit O1'))) S1'}\n        {E2:eval G P2 (state/ M2 KN2 (synch A2 (lit O2) T2)) S2'}\n        {CMPO:compare O1 O2 CO}\n        {TNA1: thread-not-ancestor P1 P2}\n        {TNA2: thread-not-ancestor P2 P1}\n        exists {B} {SW?:synchs-with? E1 E2 B}\n\ttrue.\n\n...\n\n- : synchs-with?-total*/hold+synch _ (eAcqS2 _ _ _) _ N1 N2 _\n\t(synchs-with?/no (not-synchs-with/eRelS+eAcqS N1 N2)).\n\n%worlds () (synchs-with?-total*/hold+synch _ _ _ _ _ _ _).\n%total (E) (synchs-with?-total*/hold+synch _ E _ _ _ _ _).\n</twelf> \nI'm using Twelf 1.5R1, but would switch to 1.5R3 if this is a known problem fixed in 1.5R3.\n\n: I don't really understand the problem yet, it may be that I need either more code or a better understanding of what you're doing. In general, [[reasoning from false]] that is a solution that works when you are trying to get Twelf to recognize that a problem can't occur, you show that in cases where Twelf's coverage checker can't find a problem, there is nevertheless a contradiction. It's also a possibility that the coverage checker doesn't behave correctly in this case because of the <tt>%theorem</tt> syntax, while this is doubtful it's worth confirming that this *doesn't* work.\n:: It's not the theorem syntax. Here [[reasoning from false]] would be incredibly painful here: I would have to enumerate each possible syntax pattern and program state that a hold or synch '''cannot''' evaluate to. But I may be forced to do this.[[User:Boyland|Boyland]] 03:37, 18 May 2007 (EDT)\n\n<twelf>\nsynchs-with?-total*/hold+synch : \n        eval G P1 (state/ M1 KN1 (hold A1 O1 (lit O1'))) S1' ->\n        eval G P2 (state/ M2 KN2 (synch A2 (lit O2) T2)) S2' ->\n        compare O1 O2 CO ->\n        thread-not-ancestor P1 P2 ->\n        thread-not-ancestor P2 P1 ->\n        %% => \n        {B} synchs-with? E1 E2 B -> type.\n%mode synchs-with?-total*/hold+synch +E1 +E2 +C +T1 +T2 -B -S.\n</twelf>\n: Assuming that's not the problem, since (I believe) coverage checking goes from the later arguments to the earlier arguments, it might also be worth trying to change the order of the arguments. I may have this incorrect or backwards, however, so take with a grain of salt:\n:: I moved E1 and E2 to the end, and the coverage checker dutifully considers them first:\n    Split E2 in synchs-with?-total*/hold+synch CMPO TNA1 TNA2 E1 E2 B SW?\n    Inactive split:\n    synch X1 (lit N1) X2 = X3 X4.\n    Split E1 in synchs-with?-total*/hold+synch CMPO TNA1 TNA2 E1 E2 B SW?\n    Inactive split:\n    hold X1 N1 (lit N2) = X2 X3.\n    Split CMPO in synchs-with?-total*/hold+synch CMPO TNA1 TNA2 E1 E2 B SW?\n:: The \"Inactive split\" messages (chatter 7) are interesting and may be the key to why coverage is failing. For some reason, Twelf doesn't want to split on the variable it needs to if it wishes to prove the theorem. [[User:Boyland|Boyland]] 04:20, 18 May 2007 (EDT)\n<twelf>\nsynchs-with?-total*/hold+synch : \n        thread-not-ancestor P1 P2 ->\n        thread-not-ancestor P2 P1 ->\n        compare O1 O2 CO ->\n        eval G P1 (state/ M1 KN1 (hold A1 O1 (lit O1'))) S1' ->\n        eval G P2 (state/ M2 KN2 (synch A2 (lit O2) T2)) S2' ->\n        %% => \n        {B} synchs-with? E1 E2 B -> type.\n%mode synchs-with?-total*/hold+synch +E1 +E2 +C +T1 +T2 -B -S.\n</twelf>\n: As another idea, it could be the case that, if you already have something like a progress theorem for the language, that the problem is that the last argument to <tt>eval</tt> is being treated like an ''input'' instead of like an ''output'', and that the <tt>%mode</tt> on your theorem needs to be modified to recognize that.\n: Hope one of these suggestions is somewhat enlightening... — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 09:46, 14 May 2007 (EDT)\n\n:: I don't understand the details your example, but in my experience this sort of error message (the coverage checker finding a bunch of uncovered cases, albeit not by splitting the term you want it to) often results from a bug in a proof.  Though I've heard that there are some pathological cases where the coverage checker splits the wrong term and is consequently unable to split the term it needs to split, I've personally never run into such a case.  When I've gotten an error message like this, it's been because my proof is wrong (but the coverage checker's error message is somewhat surprising because it's not splitting the same term that I would split).  So the problem may have nothing to do with the details of the coverage checker; it's possible that you simply haven't defined a total relation.  The technique described in [[Debugging coverage errors]] might help you debug.  And, as Rob said, it may be a situation where you need to explicitly contradict some cases (using [[reasoning from false]]) because the coverage checker isn't automatically ruling them out.  [[User:Drl|Drl]] 12:27, 16 May 2007 (EDT)\n\n::: It is indeed possible that I have omitted a case, however, it sure would be easier to find it if the coverage checker split on the variable I want it to: by splitting on the wrong variables, it ends up with 4000 lines of cases not considered!   I'll let you know if/when I resolve the issue.  It seems the \"Inactive Split\" message is key. I'm not sure why it is using a higher ordered type here.  Here <tt>eval*</tt> (and friends) have type\n<twelf>\nstate : kind -> type.\nstate/ : {K:kind} map -> %map% -> term K -> state K.\neval* : {K:kind} unit -> nat -> state K -> state K -> type.\n</twelf>\n::: <tt>eval</tt> is abbreviated as <tt>eval*</tt> with the first parameter (<tt>kind</tt>) implicit. (Don't be alarmed by the <nowiki>%map%</nowiki> vs. <nowiki>map</nowiki>. It's due to my C-preprocessor-based functor system for Twelf. I've proved many, many things already with these things. Also, the variable <tt>K</tt> for <tt>state/</tt> is implicit.  This is from the server output.  In the theorem in question <tt>K</tt> is always <tt>exprk</tt>)\n::: Maybe someone out there knows why the coverage checker gets the higher-order constraints (and then fails).[[User:Boyland|Boyland]] 04:20, 18 May 2007 (EDT)\n::: The \"Inactive Split\" is indeed key: it means that because higher-order unification failed, that Twelf won't split on the variable.  I was able to fix this by introducing an equality indirection so that Twelf wouldn't try to unify \"(F X)\" with \"(lit O)\" (for example).  Maybe somebody (me?) should write up a trouble-shooting tip about this, or is it to esoteric?  [[User:Boyland|Boyland]] 23:45, 20 May 2007 (EDT)\n\n:::: Glad you resolved the problem.  It would be great if you'd contribute a trouble-shooting tip about this!  [[User:Drl|Drl]] 11:40, 22 May 2007 (EDT)\n\n== Mapping HOAS isomorphically to the natural numbers ==\n\nI need an arbitrary isomorphic mapping between terms and the natural numbers.\nWithout higher-order abstract syntax, this is uninteresting grunt work.\nWith higher-order abstract syntax, I am able to define the mapping:\n<twelf>\n%%%% Definition\n\n\n\n%%% Untyped lambda calculus using HOAS\n\n\nexp : type.\n\n\napp : exp -> exp -> exp.\n\nlam : (exp -> exp) -> exp.\n\n\n\n%%% Mapping exp isomorphically to the natural numbers\n\n\nvarlevel : exp -> nat -> type.\n\n%% only inhabited dynamically\n\n\n\nexp2nat : nat -> exp -> nat -> type.\n\n%% exp2nat D E N   convert E into a number N assuming we are inside D lambda expressions.\n\n\n\nexp2nat/app : exp2nat D (app E1 E2) (s N)\n    <- exp2nat D E1 N1\n    <- exp2nat D E2 N2\n    <- pair2nat (natpair/ N1 N2) N3\n    <- plus N3 N3 N4\n    <- plus D N4 N.\n\nexp2nat/lam : exp2nat D (lam ([x] B x)) N\n    <- ({x} varlevel x D -> exp2nat (s D) (B x) N1)\n    <- plus N1 N1 N2\n    <- plus D N2 N.\n\n\nexp2nat/var : exp2nat D V N\n    <- varlevel V L\n    <- plus (s L) N D.\n\n\n\n\n%%%% Blocks\n\n\n\n%block bind : some {l:nat} block {x:exp} {D:varlevel x l}.\n\n\n</twelf>\nThe first parameter to <tt>exp2nat</tt> is the depth of lambdas we are in.  It is used to \"leave space\" for the variables in the encoding of the body.  When asking for the number for a top-level term, one uses zero.\n<pre>\n?- exp2nat z (lam ([x] (lam [y] y))) N.\nSolving...\nN = s (s z).\nMore? no\n?- exp2nat z (lam ([x] x)) N.\nSolving...\nN = z.\nMore? no\n?- exp2nat z (lam ([x] (lam [y] x))) N.\nSolving...\nN = s (s (s (s (s (s z))))).\nMore? no\n?- exp2nat z (app (lam ([x] x)) (lam ([y] y))) N.\nSolving...\nN = s z.\nMore? no\n?- exp2nat z (app (lam ([x] x)) (app (lam ([x] x)) (lam ([y] y)))) N.\nSolving...\nN = s (s (s z)).\nMore? no\n</pre>\nI don't see how to prove things about it.  \nAssuming <tt>natpair</tt> has a provably isomorphic mapping\nto the natural numbers (I can post that too if you want) and that we have all the theorems about plus\nwe could care about, plus division and multiplication thrown in \"for free\", it still seems tricky.\n\nThe big problem is proving 1-1 and onto.  I have zero experience with non-trivial \"worlds\", but it seems\nto me that a lemma will have to use that the \"varlevel\" bindings are all distinct, and indeed fill up the values 0,1,...,D-1 where D is the depth parameter to <tt>exp2nat</tt>.  I don't see how to do this.\n\nPerhaps there's a better way to define the mapping?  (In fact, my encoding may be incorrect---I haven't proved it is correct!) [[User:Boyland|Boyland]] 21:28, 26 June 2007 (EDT)\n\n\n----\n\n\nI can rephrase the problem ignoring the messiness of arithmetic, by asking about an isomorphism between HOAS and nameless\nterms, since nameless terms are normal syntax for which I know how to make provable isomorphisms to the natural numbers.\nAs an added bonus, the following Twelf code is self-contained:\n<twelf>\n%%%% Definitions\n\n\n\n%%% Natural numbers\n\n\nnat : type.\n\nz : nat.\n\ns : nat -> nat.\n\n\n\n%%% Untyped lambda calculus using HOAS\n\n\nexp : type.\n\n\napp : exp -> exp -> exp.\n\nlam : (exp -> exp) -> exp.\n\n\n\n%%% deBruijn variables\n\n\ndbvar : nat -> type.\n\n\n0 : dbvar (s N).\n\n^ : dbvar N -> dbvar (s N).\n\n\n\n%%% deBruijn terms\n\n\ndbterm : nat -> type.\n\n\ndbuse : dbvar N -> dbterm N.\n\ndblam : dbterm (s N) -> dbterm N.\n\ndbapp : dbterm N -> dbterm N -> dbterm N.\n\n\n\n%%% Mapping exp isomorphically to debruijn terms\n\n\nvarlevel : exp -> nat -> type.   % only inhabited dynamically\n\n\n\nexp2db : {N} exp -> dbterm N -> type.\n\nnat2db : {N} nat -> dbvar N -> type.\n\n\nexp2db/app : exp2db D (app E1 E2) (dbapp DB1 DB2)\n    <- exp2db D E1 DB1\n    <- exp2db D E2 DB2.\n\nexp2db/lam : exp2db D (lam ([x] B x)) (dblam DB)\n    <- ({x} varlevel x D -> exp2db (s D) (B x) DB).\n\nexp2db/var : exp2db D V (dbuse DBV)\n    <- varlevel V L\n    <- nat2db D L DBV.\n\n\nnat2db/0 : nat2db (s z) z 0.\n\nnat2db/^ : nat2db D N V -> nat2db (s D) N (^ V).\n\nnat2db/- : nat2db (s D) N 0 -> nat2db (s (s D)) (s N) 0.\n</twelf>\nThe definition of deBruijn terms is carefully written to ensure that there\nis only one way to write each lambda expression.  (The representation in the\nthe Twelf source examples directory does not enjoy this property.)\nSo my challenge to Twelfers everywhere is prove\n\n1. that exp2db is total: for every E there exists D such that exp2db z E D.\n\n2. that exp2db is deterministic: there exists exactly one such D\n\n3. that exp2db is onto: for every deBruijn term D, there exists E such that exp2nat z E D\n\n4. that exp2db is one2one: there exists exactly one such E.\n\n(Or provide a counter example if I have an error in my \"isomorphism.\")\n[[User:Boyland|Boyland]] 22:09, 16 August 2007 (EDT)\n\n: This took a little while - I think the end result is pleasant enough, but some of the arguments for how to get there weren't obvious. My approach is rather different than yours, but the end result is the same - a correspondence between closed HOAS terms and closed de Bruijn terms (my de Bruijn terms are slightly different than yours because they have an extra index encoding a [[structural metric]], but it is obvious to me, and it shouldn't be hard to prove, that these are in correspondance with your encoding of de Bruijn terms.\n\n: It might be worth trying something similar with this \"varlevel\" machinery, but I'm not sure all the induction hypotheses that are needed end up working. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 10:02, 4 October 2007 (EDT)\n\n== commutativity of plus in the introduction ==\n\nI've added a [[Proving metatheorems:Natural numbers: Answers to exercises|solution]] to the first problem posed in Dan's tutorial.  However, since I'm just learning Twelf now, I suspect that it could be improved, but couldn't get anything else to go through.  Could someone experienced have a look and determine if it is the best proof?\n\nAny style tips would also be appreciated.  I've got a couple other exercises, which I'll add once I'm sufficiently confident that I'm doing things in a reasonable way.\n\n--[[User:Ccasin|Ccasin]] 15:37, 2 October 2007 (EDT)\n\n:: Those solutions seem pretty good to me! The only style note I have is lemma naming. This is really a complete matter of personal preference, but similar to how I write <tt>plus/s: plus N M P -> plus (s N) M (s P).</tt>, I find it is more memorable to call what you called \"<tt>plus-flip</tt>\" \"<tt>plus-s</tt>,\" because it's doing roughly the same thing as <tt>plus/s</tt> but in another direction (and as a metatheorem, not a constructor). Happy Twelfing! — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 09:54, 4 October 2007 (EDT)\n\n%{\n== definition violation ==\n\n\nI defined a simple dependently-typed language but when I went to prove Preservation I get this error message which is mystifying me.\n\n  Definition violation: family preserv |> expr, which occurs as\n  right-hand side of a type-level definition.\n\nI checked the manual on Subordination but I don't understand how preserv can be a subterm of expr.\n\nI also noticed that the Wiki page on Subordination seems to use flipped syntax from the manual, which isn't helping.\n\nPrint.subord uses #> syntax for which I cannot find a definition.\n\n\n<twelf>\n% Expressions (also types)\nexpr : type. %name expr E.\ntp   = expr.\n\n$    : expr -> expr -> expr. %infix left 50 $.\nlam  : expr -> (expr -> expr) -> expr.\npi   : expr -> (expr -> expr) -> expr.\nstar : expr.\nbox  : expr.\n=>   = [a:expr] [b:expr] pi a ([_] b). %infix right 50 =>.\n%freeze expr.\n\nallowed-kinds : expr -> expr -> type.\n%mode allowed-kinds +E1 +E2.\nakss : allowed-kinds star star.\nakbb : allowed-kinds box box.\nakbs : allowed-kinds box star.\naksb : allowed-kinds star box.\n%worlds () (allowed-kinds _ _).\n%terminates {} (allowed-kinds _ _).\n\n% Values\nvalue : expr -> type.\n%mode value +E1.\nvalue-lam : value (lam _ _).\nvalue-pi  : value (pi _ _).\nvalue-star : value star.\nvalue-box  : value box.\n%worlds () (value _).\n%terminates {} (value _).\n\n% Call-by-name small step operational semantics.\n|-> : expr -> expr -> type. %infix left 10 |->.\n%mode |-> +E1 -E2.\n|->$    : E1 $ E2 |-> E1' $ E2\n           <- E1 |-> E1'.\n|->beta : lam _ E1 $ E2 |-> E1 E2.\n%worlds () (|-> _ _).\n%terminates E (|-> E _).\n\n% Multi-step\n|->* : expr -> expr -> type. %infix left 10 |->*.\n%mode |->* +E1 -E2.\n|->*refl  : E |->* E.\n|->*trans : E |->* E'' <- E |-> E' <- E' |->* E''.\n%worlds () (|->* _ _).\n\n% Normal form\nnf : expr -> expr -> type.\n%mode nf +E1 -E2.\nnf-value : nf E E <- value E.\nnf-multi : nf E E' <- E |->* E' <- value E'.\n%worlds () (nf _ _).\n\n% Type-checking\nof : expr -> tp -> type.\n%mode of +E1 -E2.\nof-star : of star box.\nof-$    : of (E1 $ E2) (RT E2)\n           <- of E1 T\n           <- nf T (pi AT RT)\n           <- of E2 AT.\nof-lam  : of (lam AT E1) (pi AT RT)\n           <- ({x:expr} of x AT -> of (E1 x) (RT x)).\nof-pi   : of (pi A B) T\n           <- of A S'\n           <- nf S' S\n           <- ({x:expr} of x A -> of (B x) T')\n           <- nf T' T\n           <- allowed-kinds S T.\n%freeze of.\n\n\n\npreserv : of E T -> E |-> E' -> of E' T -> type.\n%mode preserv +D1 +D2 -D3.\n% - : preserv (of-$ DofE2AT DnfT DofE1T) (|->$ DstepE1E1')\n%      (of-$ DofE2AT DnfT DofE1'T)\n%      <- preserv DofE1T DstepE1E1' DofE1'T.\n% ...\n%worlds () (preserv _ _ _).\n%total D (preserv _ D _).\n\n% Definition violation: family preserv |> expr, which occurs as\n% right-hand side of a type-level definition.\n\n% excerpts from manual\n\n% We say that type family b subordinates type family a, (written b |>\n% a) if a term of type b ... might occur as a subterm of a term of\n% type a.\n\n% preserv |> expr  =  preserv subordinates expr\n\n% \"a term of type preserv might occur as a subterm of a term of type expr.\"\n\n\n% Print.subord\n% expr #> expr \n% tp |> \n% allowed-kinds #> expr \n% value #> expr \n% |-> #> |-> expr \n% |->* #> |->* |-> expr \n% nf #> |->* value expr \n% of #> of nf allowed-kinds expr \n% preserv #> of expr\n</twelf>\n\n\n=== Response ===\n\nThis is poorly explained on the wiki right now, but when you're doing metatheorems then writing things like:\n\n<twelf>% Expressions (also types)\nexpr : type. %name expr E.\ntp   = expr.</twelf>\n\n... is a problem - the last line is a ''type-level definition'' and is a part of Twelf that was added for very different reasons (see [[tactical theorem proving]]). In general, defining a type to be equal to another type is something you should never do if you're writing [[metatheorem|metatheroems]] at all. You may be able to partially address your problem by using an [[abbrev declaration]].\n\n<twelf>% Expressions (also types)\nexpr : type. %name expr E.\n%abbrev tp   = expr.</twelf>\n\nHowever, without looking closely at your example there may be a problem with <tt>tp = expr</tt> - is your intention to make your types and expressions indistinguisable? — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 13:27, 26 October 2007 (EDT)\n\nAdding %abbrev did help, in that I am now facing the usual Coverage error.  I did intend to make types and expressions the same, in fact, the tp = expr was an afterthought because the original language does not contain a separate family for types (and typechecking is of : expr -> expr -> type).  - [[User:Mrd|mrd]]"
          },
          "sha1": "m5xq236ph7fin6m6s2iysbic6xxetcs"
        }
      },
      {
        "title": "Talk:CPS conversion",
        "ns": 1,
        "id": 1666,
        "revision": {
          "id": 8071,
          "parentid": 8026,
          "timestamp": "2016-01-30T18:01:40Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "minor": null,
          "comment": "Reverted edits by [[Special:Contributions/5.167.114.39|5.167.114.39]] ([[User talk:5.167.114.39|talk]]) to last revision by [[User:Tom7|Tom7]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 2176,
            "#text": "== Strange world declarations ==\n\nCan anybody pinpoint the reason that Twelf requires these odd world and mode declarations? Is it a bug? &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 17:51, 5 October 2006 (EDT)\n\n== Termination order backwards? ==\n\nIt seems that the documentation in the guide is the opposite of what is actually implemented. With the total declaration\n\n<twelf>%total (A B C D) \n          (tocpsv- A _ _) \n          (tocpsv+ B _ _) \n          (tocps- _ C _ _ _) \n          (tocps+ _ D _ _ _).</twelf>\n\nI can call <tt>tocps-</tt> from <tt>tocps+</tt> on the same derivation. The documentation says the opposite: that earlier theorems can call later ones. (See {{guide|chapter=8|section=51|title=mutual recursion}}). Am I crazy? &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 17:55, 5 October 2006 (EDT)\n\n: I was under the impression it was later theorems that can call earlier ones (at least that's how I've used it in the past). --[[User:DanielKLee|DanielKLee]] 16:48, 6 October 2006 (EDT)\n\n== Twelf output ==\n\nThe Twelf output indicates a syntax error in the example. Yay technology. --[[User:DanielKLee|DanielKLee]] 16:48, 6 October 2006 (EDT)\n: Yeah, I was gonna mention that fact at some point. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 17:19, 6 October 2006 (EDT)\n:: We owe Tom an apology, he writes brillant code; he included type information in his code that was not part of the signature. Which is exactly what <nowiki><twelf noinclude=\"true\"></nowiki> is for. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 23:08, 6 October 2006 (EDT)\n::: Word. &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 23:52, 8 October 2006 (EDT)\n:::: You should use <tt><nowiki><twelf noinclude=\"true\" check=\"decl\"></nowiki></tt> to link to a [[%solve]] that establishes those derivations too, perhaps? — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 23:59, 8 October 2006 (EDT)\n::::: I'm really just using the twelf tag here to display a term with syntax highlighting; I don't think it needs to be checked. (Actually, I think it would distract from what's actually important.) &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 14:41, 9 October 2006 (EDT)"
          },
          "sha1": "ebmhtrci6snqqjp6xsqqu4gr80aempc"
        }
      },
      {
        "title": "Talk:Canonical forms lemma",
        "ns": 1,
        "id": 1649,
        "revision": {
          "id": 8066,
          "parentid": 8020,
          "timestamp": "2016-01-30T18:01:36Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "minor": null,
          "comment": "Reverted edits by [[Special:Contributions/37.113.34.32|37.113.34.32]] ([[User talk:37.113.34.32|talk]]) to last revision by [[User:DanielKLee|DanielKLee]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 868,
            "#text": "[[canonical form]] should be its own page (not a redirect) for the LF notion of canonical form. I deleted the redirect until we have such a page. &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 17:32, 30 September 2006 (EDT)\n\n\nI just realized after writing the examples, that to make canonical forms seem relevant, I had to do progress proofs anyway. I am considering re-doing this article as \"Progress when you get canonical forms for free vs. progress when you need to prove canonical forms\". --[[User:DanielKLee|DanielKLee]] 19:05, 30 September 2006 (EDT)\n\nI just also realized there is a way to do progress for the second type system and still get CFLs for free. GAH. Not sure whether I should do a third example to show it off, or just pretend it doesn't exist to make the second example still seem relevant. --[[User:DanielKLee|DanielKLee]] 19:05, 30 September 2006 (EDT)"
          },
          "sha1": "iaqb8x72m30usn46yodsyt62p76d6dg"
        }
      },
      {
        "title": "Talk:Case studies",
        "ns": 1,
        "id": 1689,
        "revision": {
          "id": 8075,
          "parentid": 8060,
          "timestamp": "2016-01-30T18:03:15Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "rollback",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 2487,
            "#text": "I don't really think [[CPS conversion]] is a case study; it's meant to be a contrived tutorial. (I have a much larger code base from my thesis project that would be the \"case study\".) But I don't mind it being here until there's more to fill out this page... &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 20:23, 11 October 2006 (EDT)\n: I guess in my mental separation, a tutorial answers a question someone might ask or shows a technique someone might use directly, whereas a case study says \"this is how you do something cool and non-trivial in Twelf.\" - to borrow Karl's separation from two ConCert meetings ago, tutorials are \"let's think about how to do work in Twelf\" and case studies are \"used Twelf, got things done\", and I saw CPS conversion more as \"got things done.\" However, perhaps the best solution in these cases is to list it in both places, which I think would be entirely appropriate. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 20:49, 11 October 2006 (EDT)\n:: Well, the CPS example is for a toy language specifically designed for pedagogical purposes, so it's not an example of getting things done&mdash;even though it was an offshoot of real work. But sure, let's put it in both places. &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 20:59, 11 October 2006 (EDT)\n::: Perhaps my problem is that we need a new category that isn't quite \"Advanced Proof Techinques\"... Trying to make a good sort of the things that are tutorials seems to get me in trouble every time. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 21:35, 11 October 2006 (EDT)\n:::: Sounds like another Twelf coffee is in order! &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 22:09, 11 October 2006 (EDT)\n::::: Indeed, especially as I've now started the leak, apparently - Carsten, Brigette, and Kevin are aware of this project (intentional), Carsten may point some of his students to upload examples (encouraged), and Brigette may be sharing this with her McGill Computation and Deduction course (yipes!). — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 22:49, 11 October 2006 (EDT)\n:: Might I suggest an \"Illustrative Examples\" category. Illustrative examples are minimal examples that highlight one or two particular encoding or proof techniques. The emphasis being on how a particular thing is done, rather than focusing on general techniques (tutorials) or larger proofs with their own agendas (case studies). --[[User:DanielKLee|DanielKLee]] 00:01, 12 October 2006 (EDT)"
          },
          "sha1": "9vyu3jpzaqz5dg4suykfo8zyfzlcz0w"
        }
      },
      {
        "title": "Talk:Classical S5",
        "ns": 1,
        "id": 1774,
        "revision": {
          "id": 3163,
          "parentid": 3162,
          "timestamp": "2006-10-24T22:54:24Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 380,
            "#text": "=> is getting turned into =&amp;gt; in the <tt>&lt;twelf></tt> block. Any idea why? [[User:Jcreed|Jcreed]] 18:11, 24 October 2006 (EDT)\n\n: It must be something that got changed in the syntax highlighting module, ugh. I am due for another rewriting of that stupid module soon, looks like. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 18:54, 24 October 2006 (EDT)"
          },
          "sha1": "3vsx3pdetzcy6eup1hkm5lfwm79nlp8"
        }
      },
      {
        "title": "Talk:Congruence lemma",
        "ns": 1,
        "id": 1789,
        "redirect": {
          "@title": "Talk:Respects lemma",
          "#text": null
        },
        "revision": {
          "id": 3260,
          "timestamp": "2006-11-01T15:53:06Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "comment": "[[Talk:Congruence lemma]] moved to [[Talk:Respects lemma]]: congruence lemmas are a particular mode of use of respects lemmas",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 33,
            "#text": "#REDIRECT [[Talk:Respects lemma]]"
          },
          "sha1": "rm8gohmeh05lufl14uzdjsydf2ozts1"
        }
      },
      {
        "title": "Talk:Constraint domains and coverage checking",
        "ns": 1,
        "id": 1797,
        "revision": {
          "id": 4494,
          "parentid": 3290,
          "timestamp": "2007-03-20T22:15:59Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "comment": "redlink patrol",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 435,
            "#text": "This page should start with a definition of what a constraint domain is. (Or else it is a page about constraint domains and metatheorems?)) &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 13:42, 3 November 2006 (EST)\n: Yes, you had that thought 15 minutes before but independently of me - I just clicked on the redlink in [[Tutorials]] and went crazy. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 13:56, 3 November 2006 (EST)"
          },
          "sha1": "7bjuoaqosejsofbjxv9hn9eyof5a52c"
        }
      },
      {
        "title": "Talk:Converting between implicit and explicit parameters",
        "ns": 1,
        "id": 1680,
        "revision": {
          "id": 6038,
          "parentid": 2547,
          "timestamp": "2010-01-09T03:36:15Z",
          "contributor": {
            "username": "Boyland",
            "id": 17
          },
          "comment": "/* Using abbreviations to convert from explicit to implicit */ new section",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 926,
            "#text": "== Annotation example ==\n\nI tried for an hour to come up with a simple example where this trick is required, but I couldn't. (I've used it in much more complicated stuff, though, so it definitely comes up.) Anybody else more clever at minimal examples? &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 11:47, 10 October 2006 (EDT)\n\n== Using abbreviations to convert from explicit to implicit ==\n\nI frequently use abbreviations to define a shortcut version of a relation omitting those extra parameters.\nThus\n<twelf>\n%abbrev translate-i : of M A -> of M' A -> type = translate-e M A M'.\n</twelf>\nOr even\n<twelf>\n%abbrev translate-i = translate-e _ _ _.\n</twelf>\nThe advantage of the abbreviation technique is that you don't need to transform things back and forth: you just use whichever form is more convenient.  The only place where abbreviations CANNOT be used is in call patterns. [[User:Boyland|Boyland]] 22:36, 8 January 2010 (EST)"
          },
          "sha1": "i7wc09oadvzcpad5cce7s1iqgcp6gu8"
        }
      },
      {
        "title": "Talk:Coverage checking",
        "ns": 1,
        "id": 1979,
        "revision": {
          "id": 4593,
          "timestamp": "2007-03-21T13:10:38Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "Freeness/coverage",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 310,
            "#text": "== Freeness/coverage ==\n\nDo you consider output freeness to be an aspect of coverage checking? It is a position that makes sense; I suppose I'd just thought of it as an auxillary check that <tt>[[%total]]</tt> performs. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 09:10, 21 March 2007 (EDT)"
          },
          "sha1": "1mrqwxbcu92v16e2weo5zesbr8mdbla"
        }
      },
      {
        "title": "Talk:Debugging coverage errors",
        "ns": 1,
        "id": 2217,
        "revision": {
          "id": 6037,
          "timestamp": "2009-12-27T14:31:28Z",
          "contributor": {
            "username": "Boyland",
            "id": 17
          },
          "comment": "Added discussion of coverage errors in nasty situations",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 477,
            "#text": "When I have higher-order terms (in particular if I have a judgment that handles transitivity of higher-order contexts -- I can given an example) and do case analysis on them, I frequently get a nasty case of inactive splits AND nontermination.  The only solution I have found is to split the metatheorem into two parts: one to handle the higher-order term in general and a second to do a case analysis between fixed terms. [[User:Boyland|Boyland]] 09:31, 27 December 2009 (EST)"
          },
          "sha1": "eh6863vge5845zuzebzyc5htiin7l9u"
        }
      },
      {
        "title": "Talk:Define declaration",
        "ns": 1,
        "id": 1716,
        "revision": {
          "id": 2833,
          "parentid": 2830,
          "timestamp": "2006-10-14T13:43:08Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "minor": null,
          "comment": "[[Talk:% define]] moved to [[Talk:Define declaration]]: space is perhaps difficult to spot, but maybe we should try to fix the root problem",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 363,
            "#text": "== Name ==\n\nWow, that's weird. As near as I can tell, it's because 'de' (and also maybe 'f') are hex characters, so %25de is being interpreted as malformed unicode or something like that. I'm going to move to [[define declaration]] though, because the space is pretty weird for an article title. &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 09:42, 14 October 2006 (EDT)"
          },
          "sha1": "0u8yem1unimmmorpg45hu21bhwjkmjq"
        }
      },
      {
        "title": "Talk:Documentation",
        "ns": 1,
        "id": 1759,
        "revision": {
          "id": 8115,
          "parentid": 8114,
          "timestamp": "2016-02-10T15:38:30Z",
          "contributor": {
            "username": "Boyland",
            "id": 17
          },
          "comment": "Undo SPAM revision 8107 by [[Special:Contributions/46.246.87.122|46.246.87.122]] ([[User talk:46.246.87.122|talk]])",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 358,
            "#text": "== includes ==\n\nIs there a better way to include the front page text on this page?  They're both serving as portals, so I think the duplication is reasonable: the docs page is the \"real\" source for the list of intro material, but we happen to have all of it duplicated on the front page for convenience right now.[[User:Drl|Drl]] 00:24, 24 October 2006 (EDT)"
          },
          "sha1": "8i5bond68rmj4zodusrbbsqnwcbzqxn"
        }
      },
      {
        "title": "Talk:Download",
        "ns": 1,
        "id": 1439,
        "revision": {
          "id": 9608,
          "parentid": 6284,
          "timestamp": "2019-03-29T22:59:52Z",
          "contributor": {
            "username": "Hibou57",
            "id": 15420
          },
          "comment": "/* Building with MLTon */ new section",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 6408,
            "#text": "Perhaps this will be controversial, but I think the software page should have instructions about how to get/install Twelf CVS. %trustme is commonly used by myself, Karl, and Dan Licata in our Twelf code development, and occasionally Twelf code that requires it is publically released. --[[User:DanielKLee|DanielKLee]] 21:46, 5 September 2006 (MST)\n\n* I completely agree. In fact, that's a decent way of giving this page a purpose - to say \"either go to the static software page over here, or get stuff from the CVS repository here\". Does the repository have read-only anon. access? I'm actually using 1.5R1 :-P. [[User:Rsimmons|Rsimmons]] 06:48, 6 September 2006 (MST)\n\n* Definitely. &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 16:15, 9 September 2006 (MST)\n\n== Solved, yet confusing, problem ==\n\nI downloaded the CVS version, and it has the same problem with my SML as other versions have. I don't understand the source of this problem but can't believe I'm the only one who has been tripped up by it. The files <tt>twelf-server.sml</tt> looks like this, and <tt>twelf-sml.sml</tt> is similar.\n\n<code>(* comment out first line if undefined in your version of SMLofNJ *)\n(* call sml-cm with @SMLdebug=/dev/null instead *)\nSMLofNJ.Internals.GC.messages false;\nCM.make' \"server.cm\";\nSMLofNJ.exportFn (\"bin/.heap/twelf-server\", Server.server);</code>\n\nNo version of SML I've used in the last year supports <tt>CM.make'</tt>, I've had to manually delete the apostrophe. If we include CVS information publicly, we should either fix this problem or explain the workaround. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 10:28, 8 September 2006 (MST)\n: Does the mlton build work? mlton will produce code that is several times faster, so we ought recommend that in my opinion. &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 16:15, 9 September 2006 (MST)\n:: I've built the CVS version with MLton, but it requires changing around a .cm file (dependencies, I guess). I suppose I should inform the Twelf developers of that... --[[User:DanielKLee|DanielKLee]] 16:21, 9 September 2006 (MST)\n::: Yeah - at the very least, the code should work for mlton *OR* SML/NJ. And we should explain the changes that need to be made on the installation page, if it only works for one or the other (as it seems currently to work \"out of box\" for neither...) — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 18:01, 9 September 2006 (MST)\n:: And of course, if you're me and not Carsten you can't make mlton work on a 64-bit box... — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 18:02, 9 September 2006 (MST)\n::: I sshed onto linux1.gp.cs.cmu.edu and used the MLton there to build my twelf-server, which then runs fine off my normal machine. Your afs home is the same on both machines. --[[User:DanielKLee|DanielKLee]] 19:34, 9 September 2006 (MST)\n\n== Protection ==\n\nRob suggested the possibility of protecting this page, since it points to executable software and could be vandalized. Protection would mean that no users that have not been marked administrators by Rob or myself would be able to edit the page. They would still be able to leave messages on this talk page. Since we have so many administrators and all know each other, I think there's no reason not to protect the software page. Any objections? &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 11:59, 22 September 2006 (MST)\n\n: '''''Do''''' it. --[[User:DanielKLee|DanielKLee]] 12:18, 22 September 2006 (MST)\n\nProtecting the page might be give some sense of security, *but* I've just lost some time asking around for a solution of the make' problem; now I've created a wiki account to add a hint to the Download page about this, and find it protected. If you protect that page, I suggest you at least move such information to the protected page. Thanks. (BTW speaking for myself, I like if software is released with an OpenPGP (gpg) signature; this is more secure, and then wouldn't really require protecting the page.) --[[User:pflanze]] Tue Mar 17 17:25:44 EDT 2009\n\n: I thought in the currently available version, running <tt>make -f smlnj/Makefile</tt> circumvented the <tt>make'</tt> bizarreness, does it not? You're right about the OpenPGP signature, and we should definitely do that, though that doesn't necessarily change the point that we want to have those links protected. Sorry you were forced to run in circles, though, can you give me a better idea what you need help with/wanted to fix? ----\n\n== cvsnt? ==\n\nDoesn't cygwin have CVS? I think we should instruct them to install that version, which will simplify the process a little. &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 14:14, 9 January 2007 (EST)\n\n: Cygwin is 1) heavyweight and 2) not available on my home computer, which I get in trouble for installing lots of things on. I agree, essentially. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 20:24, 9 January 2007 (EST)\n:: Sorry, I misread the article. I thought it said to install cygwin and then install cvsnt. &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 09:58, 10 January 2007 (EST)\n::: I've removed most of said information; now that I can create new executible distributions in ~5minutes, I don't see the need as much. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 00:21, 28 January 2007 (EST)\n:::: Good, I think that frequent binary releases are a good way to go. I think most potential Twelf users will know how to use CVS anyway. &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 01:33, 30 January 2007 (EST)\n\n== Software links? ==\n\nIs it possible to get the \"CVS build\" links right on this page? I'd do it myself but the windows installer filename seems to be generated from the date (this might be a bad idea). &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 11:11, 21 March 2007 (EDT)\n\n: I have to do some manual work to update windows anyway; I may change the PHP script in the future, but for now I've just created a symlink http://twelf.plparty.org/builds/twelf.exe to the most recent version. I'm not sure what you have in mind, so feel free to go wild :). — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 11:38, 21 March 2007 (EDT)\n\n== Building with MLTon ==\n\nTwelf cannot be built with latest MLTon, which complains about invalid file suffix, “.cm”.\n\nBy the way, the binary archive cannot work on current Linux distributions, which does not provide libgmp 3 anymore, only libgmp 10."
          },
          "sha1": "6rtv1v5xcp0pnooji3h9wgr7lr5llw5"
        }
      },
      {
        "title": "Talk:Effectiveness lemma",
        "ns": 1,
        "id": 1864,
        "revision": {
          "id": 3838,
          "parentid": 3773,
          "timestamp": "2007-03-01T17:09:08Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 2831,
            "#text": "Why \"effectiveness\" rather than \"totality\" ?  As far as I can tell, proving \"effectiveness\" is the same\nas proving totality at the meta-leval. [[User:Boyland|Boyland]] 22:41, 25 February 2007 (EST)\n\n: I think it just dates back to some choices made in the Typed Assembly Language Two formalization. I think we thought that calling it a \"totality lemma\" would just cause confusion of a different sort, not that effectiveness is an obvious alternative by any means. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 23:40, 25 February 2007 (EST)\n\nThis sentence is pretty confusing: \"Proving an effectiveness lemma essentially establishes the same fact that a %total directive does, but does so in a way that can be used by other metatheorems.\" You use %total to prove any metatheorem, and any lemma so proved can be used by other metatheorems.\n\nAn effectiveness lemma says that some relation is in fact an algorithm (hence \"effective\"), and returns for any inputs a derivation of the relation which witnesses that fact. [[User:JakeD]] 00:33, 26 February 2007 (EST)\n\n: I mean, that works for me too :) — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 01:04, 26 February 2007 (EST)\n:: I edited it to try to simplify. We definitely should not lead with confusing stuff about metatheorems (since that is hard to wrap ones head around, especially given all the different takes on what a metatheorem is!), but a section in this article about its relationship to <tt>[[%total]]</tt> is warranted, I think, because it is an obvious question. &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 09:33, 26 February 2007 (EST)\n\n: I think language that connects \"effectivenss\" with totality is warranted.  I don't see it in the article any more. There needs to be something on the order of \"Proving an effectivessness lemma for a relation essentially establishes the same fact that a %total directive does for the relation, but does so in a way that the totality itself is named and can be used in proofs.\"  Otherwise people will wonder.  Also, personally (as an outsider), I find it annoying that one basically has to restate the entire definition of the relation in order to prove meta-totality (\"effectivessness\"), but Twelf's own wiki doesn't need to reflect my biased opinions. [[User:Boyland|Boyland]] 21:03, 26 February 2007 (EST)\n\n:: I agree: effectiveness lemmas are just a workaround for limitations of Twelf.  When you do a %total for, say, plus, Twelf proves \"for all N1, N2, there exists an N3 and D:plus N1 N2 N3\".   When you do a %total for plus-effective, Twelf proves \"for all N1, N2, there exist N3 and D:plus N1 N2 N3 and D':plus-effective N1 N2 N3 D D'\".   The only reason to do this is to work around the fact that Twelf won't let you name the output of a subgoal.  [[User:Drl|Drl]] 12:09, 1 March 2007 (EST)"
          },
          "sha1": "164smxajcer6aonqhix6r6x9yrjkm8w"
        }
      },
      {
        "title": "Talk:Equality",
        "ns": 1,
        "id": 1518,
        "revision": {
          "id": 8147,
          "parentid": 8146,
          "timestamp": "2016-02-10T16:17:22Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "Big revert (thanks John)",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 3749,
            "#text": "== Deep equality ==\n\nNot all equalities that are are ''not'' syntactic equality are \"defined inductively over the structure of terms\". I know of some algorithmic equalities that are a combination of syntax directed and type directed. Some declarative equality systems aren't necessarily anything directed. \n\nIs \"deep\" equality meant to describe equalities that are defined as part of a logic? --[[User:DanielKLee|DanielKLee]] 18:23, 27 September 2006 (MST)\n\n== Equality vs. equivalence ==\n\nI don't really understand why people draw a distinction between \"equality\" and \"equivalence\". We often call things equal that are not the same; equality up to alpha-conversion is a great example. What purpose is the distinction supposed to serve? Originally, I had simply said: One can define equivalence relations in Twelf. You can choose to use LF's built-in notion of equality to do so, or you can define it yourself. To me, this is less confusing because it does not introduce distinctions between things that are not really different. &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 10:39, 9 October 2006 (EDT)\n\n=== Where I'm going ===\n\nIn the (possibly if not probably non-standard) classification system in my head, \"equivalence\" is a special case of \"equality\" where equality is established by way of an equivalence relation rather than by way of being indistinguishable (i.e. \"identity\", which is then another special case of \"equality\"). Obviously I am tripping a bit over terminology here; I've also left the article in a series of inconsistant states - I'm going to shorten this article to something short but non-harmful and do work in User: space for a bit.\n\nI think this may need to turn into a disambiguation page going to two or three different tutorial-type articles. I don't know for sure what to *call* these articles.\n\n* ''Two things are the same if they are indistinguishable'' - Equality via LF's built-in identity. This is what, at first, I saw this article being used for; essentially it is about what Dan Lee calls \"respects lemmas\" and Dan Licata calls \"congruence lemmas,\" which are what make using this notion possible.\n* ''Two things are the same if they are related by an equivalence relation'' - Equality via some relation - this can use the tree example by creating a notion of trees that are equivalent modulo swapping left and right children of a pair node.\n* ''Two things are the same if they have the same canonical form'' - since Karl uses this approach successfully with the singleton kinds work I think it should be discussed - this uses the tree example by making a \"canonical tree\" one whose left branch is larger than the right (for some unambiguous value of \"larger\") - then I'd like to show that the canonical form definition is logically equivalent (yipes overloading!) to the canonical form usage.\n\n— [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 12:20, 9 October 2006 (EDT)\n:* But you can make ''respects'' lemmas for both deep and shallow equality (and sometimes you have to). They're just really easy if you define equality by way of LF's notion of equality. The fact that we have to write these lemmas at all is a demonstration that Twelf has no special support that would distinguish the first and second bullets as being really different. The third is just another example of defining an equivalence relation (in this case by quotienting), which is a good example but not a distinct category. (IMO) (Maybe I should put \"(IMO)\" in my sig. ;)) &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 14:45, 9 October 2006 (EDT)\n\n::* I think I now have something that makes sense based on your comments - Tom, care to weigh in? — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 16:03, 9 October 2006 (EDT)"
          },
          "sha1": "ac49nbjqyscgvrbpnbr3u6ymt4un65k"
        }
      },
      {
        "title": "Talk:Exchange lemma",
        "ns": 1,
        "id": 1521,
        "revision": {
          "id": 2059,
          "parentid": 2056,
          "timestamp": "2006-09-28T03:43:06Z",
          "contributor": {
            "username": "DanielKLee",
            "id": 5
          },
          "comment": "/* Needs more information? */",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 1039,
            "#text": "== Needs more information? ==\n\nI understand what's going on in this article, and think it's a good thing to show, but I think the article needs a descripition of how this would be encountered in practice - how the explicit exchange metatheorem would actually be avoided by rearranging the order of the lambdas... — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 19:03, 27 September 2006 (MST)\n\n: I editted the commentary on the code snippet to point to the substitution lemma example where it is being used. I'm not sure if there's a better/simpler example that could just be inlined. --[[User:DanielKLee|DanielKLee]] 19:45, 27 September 2006 (MST)\n\n:: The code doesn't have to make LOTS of sense out of context - for me, it helps to just see it. What do you think of these changes? — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 20:28, 27 September 2006 (MST)\n\n::: This snippet works for me. I re-worded it slightly and fixed a missing </tt>. --[[User:DanielKLee|DanielKLee]] 20:43, 27 September 2006 (MST)"
          },
          "sha1": "qedlefr9wvwl7c839zrs8rafqd79bhp"
        }
      },
      {
        "title": "Talk:General Description of Twelf",
        "ns": 1,
        "id": 1757,
        "redirect": {
          "@title": "Talk:General description of Twelf",
          "#text": null
        },
        "revision": {
          "id": 3078,
          "timestamp": "2006-10-23T20:03:58Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "comment": "[[Talk:General Description of Twelf]] moved to [[Talk:General description of Twelf]]: fine by me, but use lowercase in titles so that they can be inlined in sentences",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 47,
            "#text": "#REDIRECT [[Talk:General description of Twelf]]"
          },
          "sha1": "aohk2p4i2s3ktkfpvws3u9ci1o82os9"
        }
      },
      {
        "title": "Talk:General description of Twelf",
        "ns": 1,
        "id": 1637,
        "revision": {
          "id": 8065,
          "parentid": 8019,
          "timestamp": "2016-01-30T18:01:35Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "minor": null,
          "comment": "Reverted edits by [[Special:Contributions/37.113.34.32|37.113.34.32]] ([[User talk:37.113.34.32|talk]]) to last revision by [[User:Rsimmons|Rsimmons]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 328,
            "#text": "Kepler conjecture link is broken and the Economist article is available to subscribers only...\nAndrew Grey\n\n:: Thanks for leaving a note. I fixed the Kepler conjecture link, at least, it's too bad the Economist locks up their archives... — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 11:00, 5 August 2010 (EDT)"
          },
          "sha1": "arbv93kwq1ph73dnrwjs1fyoee7pfie"
        }
      },
      {
        "title": "Talk:Get started",
        "ns": 1,
        "id": 1849,
        "redirect": {
          "@title": "Talk:Introductions to Twelf",
          "#text": null
        },
        "revision": {
          "id": 3583,
          "timestamp": "2007-02-17T17:27:22Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "comment": "[[Talk:Get started]] moved to [[Talk:Introductions to Twelf]]: redoing terminology on main page",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 41,
            "#text": "#REDIRECT [[Talk:Introductions to Twelf]]"
          },
          "sha1": "150tkis2ry9xr689vh5z8w04pxiniz7"
        }
      },
      {
        "title": "Talk:Glossary",
        "ns": 1,
        "id": 1926,
        "revision": {
          "id": 6538,
          "parentid": 6537,
          "timestamp": "2012-08-18T15:24:14Z",
          "contributor": {
            "username": "RickFleischer",
            "id": 1563
          },
          "comment": ">>",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 265,
            "#text": "TODO (delete from this page when done):\n\nbasic:\n* <math>\\gg</math>  http://en.wikipedia.org/wiki/List_of_mathematical_symbols shows it as \"much greater than.\"  I see it in \n<math>\nn \\gg N \\over\n\\mathsf{succ}(n) \\gg \\texttt{s}(N)\n</math>\n\nhigh priority:\n* [[%total]]"
          },
          "sha1": "f03xuq0a07fudzcll5x7ufqxe3w2n95"
        }
      },
      {
        "title": "Talk:Heterogeneous lists",
        "ns": 1,
        "id": 1743,
        "redirect": {
          "@title": "Talk:Lists",
          "#text": null
        },
        "revision": {
          "id": 2990,
          "timestamp": "2006-10-20T16:34:05Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "[[Talk:Heterogeneous lists]] moved to [[Talk:Lists]]: Better teminology.",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 24,
            "#text": "#REDIRECT [[Talk:Lists]]"
          },
          "sha1": "9ou3lomisc2oa5igvolp0php4k040kq"
        }
      },
      {
        "title": "Talk:Holes in metatheorems",
        "ns": 1,
        "id": 2028,
        "redirect": {
          "@title": "Talk:Incremental metatheorem development",
          "#text": null
        },
        "revision": {
          "id": 5007,
          "timestamp": "2007-10-24T15:45:01Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "[[Talk:Holes in metatheorems]] moved to [[Talk:Incremental metatheorem development]]: This page is the second hit for \"metatheorems\" in google; one might get the wrong idea.",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 54,
            "#text": "#REDIRECT [[Talk:Incremental metatheorem development]]"
          },
          "sha1": "61cri8o2wz84dv57c6ttbu690ar74zp"
        }
      },
      {
        "title": "Talk:Implicit and explicit parameters",
        "ns": 1,
        "id": 1728,
        "revision": {
          "id": 8069,
          "parentid": 8023,
          "timestamp": "2016-01-30T18:01:38Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "minor": null,
          "comment": "Reverted edits by [[Special:Contributions/37.113.34.32|37.113.34.32]] ([[User talk:37.113.34.32|talk]]) to last revision by [[User:Tom7|Tom7]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 2956,
            "#text": "== Universal quantification ==\n\nIs the implication supposed to be that only implicit parameters are universally quantified? In the type theory, both are exactly the same: Πs. I think this may be misleading. (Or is there some interpretation in logic programming that I'm missing?) &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 13:35, 16 October 2006 (EDT)\n:: No, you're right - seems like the right way to say it is that this is two different ways to do universal quantification, in fact. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 11:26, 12 November 2006 (EST)\n\n== This article or section needs a moral stand ==\n\nIs there a reason that this article doesn't say \"don't use explicit parameters unless there is a good reason to; here are the only good reasons: {termination, mode}\"? [[User:Drl|Drl]] 20:29, 14 March 2007 (EDT)\n* Well, I think there are good stylistic reasons to use explicit parameters (much like it is sometimes good style to use explicit type annotations or explicit quantification in SML) which are hard to circumscribe. I'd rather describe it in terms of pros and cons. (And actually, I don't think [[%mode]] is even necessarily a good reason, since it is possible to give modes to implicit arguments.) &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 21:43, 14 March 2007 (EDT)\n:* I would be inclined to agree, in that we should take \"moral stands\" where such are clear - don't start constants with capital letters, don't define an inductive notion of equality when what you mean is identity on LF terms. However, the article should probably say \"we usually default to this style,\" which is what I tried to say. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 22:20, 14 March 2007 (EDT)\n\n== Always prints out the parameters ==\n\nI don't think it's true that Twelf always prints out the implicit parameters. For example, I think that implicit parameters to parameters are not always shown? This is why sometimes you see a <tt>{A:typ}</tt> where <tt>A</tt> appears nowhere else. Does anyone understand the actual rules? (Jason?) &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 17:01, 26 October 2007 (EDT)\n\nIt prints out implicit ''parameters'' but not implicit ''arguments.'' I think this demonstrates the <tt>{A:typ}</tt> thing, I think I should change the example to something more like this. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 11:55, 28 October 2007 (EDT)\n\n<twelf>\n\ntp : type.\ntp/unit : tp.\n\nexp : tp -> type.\nunit : exp tp/unit.\nabort/1 : exp A.\nabort/2 : {A} exp A.\n\n</twelf><twelf check=decl>\n\nstep : exp A -> exp B -> type.\nstep/raise : step unit abort/1.\nstep/raise : step unit (abort/2 A).\n\n</twelf>\n:: What's the difference between an implicit argument and an implicit parameter? Or you mean, it always prints out the implicit Π bindings, but never the implicit occurrences? Anyway, yes, I think this is a good example. &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 18:47, 28 October 2007 (EDT)"
          },
          "sha1": "bc230mbbjftfios3050uerm6ytnx6fe"
        }
      },
      {
        "title": "Talk:Incremental metatheorem development",
        "ns": 1,
        "id": 1472,
        "revision": {
          "id": 5006,
          "parentid": 1823,
          "timestamp": "2007-10-24T15:45:01Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "minor": null,
          "comment": "[[Talk:Holes in metatheorems]] moved to [[Talk:Incremental metatheorem development]]: This page is the second hit for \"metatheorems\" in google; one might get the wrong idea.",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 1956,
            "#text": "== Bottom-up vs. Top-down ==\n\nI'm not sure if the motivation for using %trustme to maintain a bottom-up development style is completely accurate here. Without %trustme, proofs must be done in a bottom-up way. That's just how math is built up. In practice, I've seen two modes of use of %trustme. The first is to work bottom-up until you hit something that will be pretty time-consuming/hard/impossible to do, and then you %trustme that particular lemma so you can keep working bottom-up. The other, which I've seen used by a particular Twelf master who happens to have an office right next to a stairwell in a corner on the 8th floor of Wean, is to %trustme a lot of boring/uninteresting lemmas which you are pretty sure are true, and then focus on the actual hard proof, and then fill in the boring holes at some point. The second strategy is very much a top-down approach.\n--[[User:DanielKLee|DanielKLee]] 09:19, 22 September 2006 (MST)\n\n: I agree that there are multiple models of use, go ahead and put whatever you think is a more accurate motivation over what is there now (in general, I'd advocate a \"change and explain why you did it on the Talk pages\" as opposed to a \"talk about changing on the Talk page\" strategy here :) ). — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 09:26, 22 September 2006 (MST)\n: I think that we are just using opposite definitions of \"top-down\" and \"bottom-up\"; for me, the end of the proof is the bottom. I guess it depends on how you think of it. (We had all sorts of similar terminological issues in automated theorem proving and computer graphics class..) We should just be more clear about what we mean. &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 11:52, 22 September 2006 (MST)\n:: Yeah, I think that's where the confusion is. I think of the main result being at the \"top\", and being built up from the smaller ones \"below\" it, like a tree. --[[User:DanielKLee|DanielKLee]] 10:30, 23 September 2006 (MST)"
          },
          "sha1": "fesplsatrwtqt18mmbhpw6ke9wgx9xy"
        }
      },
      {
        "title": "Talk:Introductions to Twelf",
        "ns": 1,
        "id": 1761,
        "revision": {
          "id": 8181,
          "parentid": 8180,
          "timestamp": "2016-12-13T00:24:28Z",
          "contributor": {
            "username": "Boyland",
            "id": 17
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 3163,
            "#text": "If you have suggestions for an audience that is not addressed by the existing tutorials, please leave them here.\n\nI'd like to add a page with the following on how to run twelf programs. How can I do this? Note that this is for non-emacs users. If there are similar (quick and easy) instructions on how to run twelf on emacs, let me know and I'll link them from this page. [[User:Giselle|Giselle]] ([[User talk:Giselle|talk]]) 19:47, 12 December 2016 (UTC)\n\nGreat!  Thanks.  I started making a new page and discovered we have a page already for this.\nTake a look at [[Twelf without Emacs]].  Perhaps you can use your examples to make it\nmore concrete? [[User:Boyland|Boyland]] ([[User talk:Boyland|talk]]) 00:24, 13 December 2016 (UTC)\n\n----\n\n== Running your first program ==\n\nNow that you have installed Twelf, it is time to run your first program. Open a file (in any text editor of your choice) and type the following:\n\n nat : type.\n z : nat.\n s : nat -> nat. <br>\n add : nat -> nat -> nat -> type.\n add/z : add z N N.\n add/s : add M N P -> add (s M) N (s P). <br>\n %mode add +M +N -P.\n %worlds () (add _ _ _).\n %total {M N} (add M N _).\n\nSave this file as <code>my_first_twelf.elf</code> (twelf files have the extension <code>.elf</code>). Now go to a terminal, preferably to the directory where you have the twelf file and start the twelf-server by running <code>twelf-server</code> if it is in your path or <code>/path/to/twelf/bin/twelf-server</code>. You should see something like this:\n\n Twelf 1.7.1+ (rUnversioned directory, built 12/05/16 at 12:27:57 on narnia)\n %% OK %%\n\nThis is twelf's [https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop repl]. You can see a list of available commands by typing <code>help</code> following by ''Enter''. To load the file you have just created, type: <code>loadFile my_first_twelf.elf</code> (if this is in a different directory, make sure to type with the right path). Twelf typechecks the code and returns successfully, which you can see by the <code>%% OK %%</code> at the end.\n\n %% OK %%\n loadFile my_first_twelf.elf\n [Opening file my_first_twelf.elf]\n nat : type.\n z : nat.\n s : nat -> nat.\n add : nat -> nat -> nat -> type.\n add/z : {N:nat} add z N N.\n add/s : {M:nat} {N:nat} {P:nat} add M N P -> add (s M) N (s P).\n %mode +{M:nat} +{N:nat} -{P:nat} (add M N P).\n %worlds () (add _ _ _).\n %total {M N} (add M N _).\n [Closing file my_first_twelf.elf]\n %% OK %%\n\nYou can enter in querying mode by typing <code>top</code> following by ''Enter'' in the repl. This is indicated by the symbol <code>?-</code>. In this mode, you can ask twelf to compute things in a prolog-like manner. Note that this is independent of the <code>%mode</code> declared in the source file. Typing <code>Ctrl+c</code> exits the querying mode. Here's an example of querying twelf:\n\n %% OK %%\n top\n ?- add (s z) (s (s z)) X.\n Solving...\n X = s (s (s z)).\n More? y\n No more solutions\n ?- add X (s z) (s (s z)).\n Solving...\n X = s z.\n More? y\n No more solutions\n ?- ^C\n interrupt\n %% OK %%\n\nTo understand better what just happened and what all the words in this file represent, move on to [[Proving_metatheorems_with_Twelf]]."
          },
          "sha1": "8ooan04p6b4861rhyv5p7ht94o1clii"
        }
      },
      {
        "title": "Talk:Language with references",
        "ns": 1,
        "id": 1921,
        "redirect": {
          "@title": "Talk:Mutable state",
          "#text": null
        },
        "revision": {
          "id": 4310,
          "timestamp": "2007-03-19T15:21:57Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "[[Talk:Language with references]] moved to [[Talk:Mutable state]]: More descriptive name",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 32,
            "#text": "#REDIRECT [[Talk:Mutable state]]"
          },
          "sha1": "t4lsa0yi1t5fxwfh7cz14vq6rt6lpyo"
        }
      },
      {
        "title": "Talk:Letrec",
        "ns": 1,
        "id": 2023,
        "revision": {
          "id": 4987,
          "timestamp": "2007-10-16T19:22:53Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "comment": "New page: == Different formalism? ==  The formalism on the current page is probably the right thing to do for \"real-world binding\", since it's closest to the actual syntax that people will have in m...",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 911,
            "#text": "== Different formalism? ==\n\nThe formalism on the current page is probably the right thing to do for \"real-world binding\", since it's closest to the actual syntax that people will have in mind.  \n\nHowever, it looks a little funny to me to have projection from an object as a language construct, without the objects themselves being first class.  Would it be better to do a version with objects and define letrec as syntactic sugar for an object that you immediately split?  I guess that doesn't show off the binding issues as well, since an object only binds one name and the components are accessed by projection.\n\nMaybe at the end of this case study, we can say that letrec doesn't need to primitive, and elaborate it as\n<code>\nletrec x1 = e1 ... in e\n</code>\n\ntranslates to\n\n<code>\nlet o = obj x is (e1[pi_1 o/x1], ...) in\nlet x1 = pi_1 o in\n    ...\nin e\n</code>\n\n[[User:Drl|Drl]] 15:22, 16 October 2007 (EDT)"
          },
          "sha1": "b3qb8uh201a76wks4xmnhirwosl5gx7"
        }
      },
      {
        "title": "Talk:Lily",
        "ns": 1,
        "id": 1737,
        "revision": {
          "id": 2950,
          "timestamp": "2006-10-19T21:32:54Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 490,
            "#text": "This is obviously a huge and impressive body of code, but it could use a lot more descriptive text. In particular, there should be an introduction that says what Lily is (and point to a paper) along with some context of what will be proved. It would also make sense to describe in English the important theorems that you prove, when they come up. Otherwise I don't think there's any way anybody can get anything out of it. &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 17:32, 19 October 2006 (EDT)"
          },
          "sha1": "j91qacz4lyegh4csojfolh9o78x4wbw"
        }
      },
      {
        "title": "Talk:Lists",
        "ns": 1,
        "id": 1739,
        "revision": {
          "id": 4763,
          "parentid": 4762,
          "timestamp": "2007-08-10T11:19:13Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "minor": null,
          "comment": "/* Polymorphic list type? */ sign",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 3824,
            "#text": "== Heterogeneous? ==\n\nI don't understand in what sense these are heterogeneous lists; it seems that they only hold terms of type 'tp'. Is this a mistake in terminology, or am I missing something? &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 09:44, 20 October 2006 (EDT)\n: You can define lists that all have to be the same 'tp,' I think is the distinction. However, I think that is a confusing distinction as well, because this is what we think of when we think of lists in Twelf and it's not what we think of when we think of heterogeneous lists. Move to move page to [[Lists]] — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 09:53, 20 October 2006 (EDT)\n:: In that interpretation homogeneous lists are trivial: they are just natural numbers saying how many of the one allowed element are in the list. That can't be right. I agree: move to [[lists]]. &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 10:37, 20 October 2006 (EDT)\n\n== Tp ==\n\nAlso, rather than defining one thing of type <tt>tp</tt>, <tt>stuff</tt>, wouldn't it be better to do the proofs in a world with arbitrary types? I'm still learning how worlds are used in practice, so I'm not certain; would it make the definitions and proofs less easily usable elsewhere, perhaps, because people would have to modify the worlds? — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 09:58, 20 October 2006 (EDT)\n\n: Eek - Carsten, <tt>tp</tt> is a confusing list object to use - this is a list of types, but to narrate you have to use \"list of types\" and \"things that have [LF] type list\" and it would be much less confusing if it was \"list of nats\" and \"things that have type nat or type list.\" I probably should have argued this point with you better earlier on, but how would you feel about switching <tt>tp</tt> to something less <tt>tp</tt>-ey? — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 10:26, 20 October 2006 (EDT)\n:: Yes, agreed: <tt>elt</tt> for element? &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 10:33, 20 October 2006 (EDT)\n\n== Math ==\n\nWhat do we think about the BNF notation introducing the object language? I think I like it but would like comments. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 10:28, 20 October 2006 (EDT)\n\n== Dependent lists ==\n\nLists are a poster child for dependent types: the type <tt>list N</tt> with <tt>N : nat</tt> has as members lists of length <tt>N</tt>. If this article is expanded to a general tutorial on lists, then this possibility should be considered. (It also has some drawbacks!) &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 10:37, 20 October 2006 (EDT)\n: That might be better as a second article - [[Lists]] and [[Indexed lists]] perhaps. But yes, totally in agreement, I was going to say it so I'm glad you did. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 10:47, 20 October 2006 (EDT)\n:: I was thinking of doing an article on indexed lists. Apparently other people had similar thoughts! It's somewhere on my queue, so I'll end up doing it if no one beats me to it. --[[User:DanielKLee|DanielKLee]] 13:56, 20 October 2006 (EDT)\n\n== Polymorphic list type? ==\n\nTwelf doesn't like {{{list : type -> type.}}} very much.  Is there a simple (no nasty encoding tricks like Google pointed me to) way to express polymorphic lists and list lemmata in Twelf? -- [[User:Stefan O'Rear|Stefan O&#39;Rear]] 05:27, 10 August 2007 (EDT)\n:: The short answer is no; Twelf is not polymorphic because making it so would complicate Twelf's ability to deal with [[metatheorems]]. Depending on what it is you want to do, however, there are any number of techniques that can be used to do what you want to do (though some of them probably fall into the \"nasty encoding tricks\" category). — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 07:19, 10 August 2007 (EDT)"
          },
          "sha1": "3vpu4hg7mclnwzp0v18nlk9k0bbgquf"
        }
      },
      {
        "title": "Talk:Main Page",
        "ns": 1,
        "id": 1390,
        "revision": {
          "id": 7996,
          "parentid": 7995,
          "timestamp": "2014-11-09T14:27:23Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "minor": null,
          "comment": "Protected \"[[Talk:Main Page]]\" ([edit=sysop] (indefinite) [move=sysop] (indefinite))",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 295,
            "#text": "== How to edit the main page ==\n\nIn rough order of how likely they are to need to be edited. If you want to edit a certain page, click on it and choose edit.\n\n*[[What's new?]] \n*[[Template:The Twelf Project/Introduction]] (About The Twelf Project)\n*[[Template:The Twelf Project/Getting Started]]"
          },
          "sha1": "l7rupfjblvnt5sw6896rf1ejqwftbdp"
        }
      },
      {
        "title": "Talk:Meta-logic",
        "ns": 1,
        "id": 1833,
        "revision": {
          "id": 3470,
          "timestamp": "2006-12-29T21:53:22Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 261,
            "#text": "== Relational metatheory redlink ==\n\nDoes anyone think we need the redlink for relational metatheory? I removed the link, because I wasn't clear what it was going for. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 16:53, 29 December 2006 (EST)"
          },
          "sha1": "4dts2fr941b1t7zp3j7ewee1m6qhkbw"
        }
      },
      {
        "title": "Talk:Metatheorem",
        "ns": 1,
        "id": 1749,
        "revision": {
          "id": 8068,
          "parentid": 8022,
          "timestamp": "2016-01-30T18:01:37Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "minor": null,
          "comment": "Reverted edits by [[Special:Contributions/37.113.34.32|37.113.34.32]] ([[User talk:37.113.34.32|talk]]) to last revision by [[User:Rsimmons|Rsimmons]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 4094,
            "#text": "== Placeholder ==\n\nI'm going to work on this based on Dan's notes, with the idea that I'll fix it based on whatever total consensus arises with all interested parties. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 17:12, 20 October 2006 (EDT)\n\n== I agree, Tom ==\n\nThe point about totality checking being *more* conservative than the fixed search strategy of logic programming is a good one - the need for factoring lemmas being the perfect example here - so I think that change is good. Does the article seem reasonable otherwise, because I'm not certain the approach is even the right one here. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 19:16, 9 March 2007 (EST)\n::I think it's a hard subject but this is a reasonable take on it and a good start, yes. &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 14:01, 12 March 2007 (EDT)\n\n== Why \"meta\" ? ==\n\nTo an outsider, all the \"meta\"-theorem stuff seems like unnecessary baggage.  Normally, I would think a meta-theorem is a theorem about theorems.  Here's what I think the answer to my question is:  In the olden days, one implemented XYZ logic in Twelf and wrote a theorem that XYZ theorems were valid.  But now, we use Twelf to directly encode our theorems about object languages.  The \"meta\" is not really appropriate any more.  I suppose for historical reasons people are used to \"metatheorem\", but it might make more sense just to dispense with \"meta\" and just talk about theorems.  Or if not, then a better explanation of \"meta\" is needed than \"for historical reasons\" [[User:Boyland|Boyland]] 01:35, 13 March 2007 (EDT)\n\n: You're right that this needs to be explained more clearly.  The point of the \"meta\" is to distinguish between \n# a ''theorem'' in an encoded deductive system, and\n# a ''metatheorem'' about an encoded deductive system.\n: For example, if I encoded a logic with a judgement <tt>A true</tt>, then <tt>(all [a:prop] impl a a) true</tt> might be a theorem in the encoded logic (if I can come up with an LF term of that type), whereas cut elimination for the logic is a metatheorem about it. [[User:Drl|Drl]] 10:14, 13 March 2007 (EDT)\n:: To answer another point (we edit-conflicted each other making the same first point), I don't see this as an issue of \"historical resasons\" at all, this is the way I understand the research community working now - the two-year-old workshop on doing this sort of thing is called the [http://www.cis.upenn.edu/~sweirich/wmm/ Worshop on Mechanizing Metatheory]. People still think of Prolog as a \"theorem prover\" for Horn clauses (see the [[w:Prolog|Wikipedia page on Prolog]]), and those kinds of theorems are the same kinds of \"theorems\" (<tt>plus 3 4 7</tt>, <tt>of (lam [x] E x) (arrow unit unit)</tt>) that are discussed on this page - they are nothing like {{forall}}{{exists}}-statement metatheorems. Dan/John/others, where do you think this article could explain this better? — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 10:30, 13 March 2007 (EDT)\n\n:: Reading the current article, I'm okay with the explanation of \"theorem\", but the transition to the Totality assertion section should rehash the discussion at the top about \"metatheorem\" being a statement about an object language and contrast it with theorem (I missed the definition of \"metatheorem\" at the top on the first read).  Also, when I used the word \"theorem\" this way, Frank objected that he likes to reserve \"theorem\" for a judgement defining truth in a logic (so not all derivable object-language judgements are \"theorems\").  Not sure if we want to use the word that way or not.  [[User:Drl|Drl]] 12:39, 13 March 2007 (EDT)\n::: I'll work on the first point - as for the second point, perhaps I could add in to the example something with a logic - just <math>A \\wedge B</math>, and say \"we could reserve 'theorem' for this kind of statement, but to avoid saying 'derivable object-language judgment' too many times we often blur the distinction by referring to both as theorems. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 08:41, 14 March 2007 (EDT)"
          },
          "sha1": "bfiswdfedkopuzsh6fk7l75q3cwpeg0"
        }
      },
      {
        "title": "Talk:Modes of use",
        "ns": 1,
        "id": 1987,
        "revision": {
          "id": 4693,
          "parentid": 4686,
          "timestamp": "2007-04-09T20:57:02Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "minor": null,
          "comment": "[[Talk:The two Twelfs]] moved to [[Talk:Modes of use]]: better name",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 229,
            "#text": "Anyone think of a better name for this? I realized the best way to explain this was basically to write down Bob's lecture on the subject... — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 13:37, 9 April 2007 (EDT)"
          },
          "sha1": "5jsgw5ptg8ipf91fy3ghsuvue91fs8t"
        }
      },
      {
        "title": "Talk:Mutable state",
        "ns": 1,
        "id": 1909,
        "revision": {
          "id": 4477,
          "parentid": 4309,
          "timestamp": "2007-03-20T21:55:17Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "minor": null,
          "comment": "redlink patrol",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 838,
            "#text": "Something looks screwy with the two families named \"update-lemma\", one of which's body gets escaped into normal text because it's block-commented out.  Otherwise, cool! [[User:Drl|Drl]] 11:51, 16 March 2007 (EDT)\n:: Fixed. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 12:29, 16 March 2007 (EDT)\n\n== Rename? ==\n\nSomehow I think [[language with references]] is a little weird of a title for this page; can I suggest [[mutable state]] or encoding references or \nencoding store or something like that? I think it would be more in line with our other tutorials/case studies. &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 08:42, 19 March 2007 (EDT)\n: Agreed, I couldn't think of a good name when I wrote the page. I'll use [[mutable state]]. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 11:21, 19 March 2007 (EDT)"
          },
          "sha1": "pmo7gh8hv8lhwgmhc5pfcnz0akg8y2r"
        }
      },
      {
        "title": "Talk:Natural numbers with inequality",
        "ns": 1,
        "id": 1449,
        "revision": {
          "id": 1626,
          "parentid": 1621,
          "timestamp": "2006-09-06T20:37:17Z",
          "contributor": {
            "username": "TheTwelfElf",
            "id": 1
          },
          "comment": "agreed",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 677,
            "#text": "It would probably be a good idea to standardize on one name for the uninhabited type in our tutorials. My vote goes to \"void\" since that is its common name in type theory. I think \"false\" is not a good choice since we often have terms inhabiting a type called false (in an encoding of classical logic, for instance). \"Absurd\" seems a little hokey to me, but I don't have a good argument against it... &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 13:28, 6 September 2006 (MST)\n\n: I'm all for void, I'll make a note of it in [[Twelf style guide]], since that's exactly the sort of thing that goes in a twelf style guide. - [[User:TheTwelfElf|TheTwelfElf]] 13:37, 6 September 2006 (MST)"
          },
          "sha1": "nydd1ma9fzt5e10o041u4h3b0xtposo"
        }
      },
      {
        "title": "Talk:Numeric termination metrics",
        "ns": 1,
        "id": 1905,
        "revision": {
          "id": 4160,
          "timestamp": "2007-03-15T21:13:37Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "comment": "New page: I stole this code from Karl's Comp+Ded class.  Does anyone remember off-hand which cases actually use the metric?  I don't want to have to do them until I find one that does.  ~~~~",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 219,
            "#text": "I stole this code from Karl's Comp+Ded class.  Does anyone remember off-hand which cases actually use the metric?  I don't want to have to do them until I find one that does.  [[User:Drl|Drl]] 17:13, 15 March 2007 (EDT)"
          },
          "sha1": "mv2v1obnrcrtzztzkukey90q503mqso"
        }
      },
      {
        "title": "Talk:Output factoring",
        "ns": 1,
        "id": 1899,
        "revision": {
          "id": 4730,
          "parentid": 4728,
          "timestamp": "2007-04-19T21:57:26Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 1137,
            "#text": "I think we should just delete the discussion of the hypothetical auto-factorer and Karl's comment at the end.  Thoughts? [[User:Drl|Drl]] 00:01, 15 March 2007 (EDT)\n: Agreed, that's just from the old article :) — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 01:03, 15 March 2007 (EDT)\n\n== typo: \"progress\" should be \"preservation\"? ==\n\nIn the section of this page labeled \"Progress\", this text appears:\n\n\"We prove progress for the STLC presented in Representing the judgements of the STLC in the tutorial Proving metatheorems with Twelf. For review, here is the LF signature for the STLC:\"\n\nActually, that section (currently) discusses only preservation.  Should the word \"progress\" have instead been \"preservation\"?\n\nHesitant to edit,\n\n[[User:Clements|Clements]] 16:16, 19 April 2007 (EDT)\n\n: Heh, English is fun. The parentheses I wanted were \"We prove progress for (the STLC presented in Representing the judgements of the STLC in the tutorial Proving metatheorems with Twelf)\", not the other association.  New wording should be less ambiguous.  Thanks for the suggestion!  [[User:Drl|Drl]] 17:57, 19 April 2007 (EDT)"
          },
          "sha1": "etb2qcllwwi904hw7lbewx1k6iay9hm"
        }
      },
      {
        "title": "Talk:Output freeness",
        "ns": 1,
        "id": 1456,
        "revision": {
          "id": 8063,
          "parentid": 8016,
          "timestamp": "2016-01-30T18:01:17Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "minor": null,
          "comment": "Reverted edits by [[Special:Contributions/37.113.34.32|37.113.34.32]] ([[User talk:37.113.34.32|talk]]) to last revision by [[User:Tom7|Tom7]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 1556,
            "#text": "This topic was on the other wiki as well: http://fp.logosphere.cs.cmu.edu/twelf/?n=Answers.Freeness . It's by Geoff Washburn, not me, so if you include a lot from that file you'll need to add a <nowiki>{{license-by-sa}}</nowiki> tag. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 16:57, 7 September 2006 (MST)\n* Oops, I didn't notice that. Well, my MIT-license version seems to have all the same info, so I don't think there's any need to import it, though perhaps the example could be a little simpler. &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 06:54, 11 September 2006 (MST)\n\n== How does output coverage differ from output freeness? ==\n\nThat question deserves a thorough answer, but Jason and I came up with this program while screwing around: observe that <tt>fake-thm</tt> output covers, even though the subgoal invocation of <tt>ff</tt> in the <tt>ft/z</tt> case is not \"output free\" because the output argument is a ground term:\n\n<twelf>\nnat : type.\ns : nat -> nat.\nz : nat.\n\nbool : type.\nt : bool.\nf : bool.\n\nadd : nat -> nat -> nat -> type.\n%mode add +M +N -O.\n\nadd/z : add M z M.\nadd/s : add M (s N) (s O')\n     <- add M N O'.\n\n%worlds () (add _ _ _).\n%total N (add _ N _).\n\nboolcont : bool -> type.\n@ : {B} boolcont B.\n\nff : {B : bool} {C : boolcont B} type.\n%mode ff +B -C.\n- : ff B (@ B).\n\nfake-thm : {M : nat} type.\n%mode fake-thm -N.\n\nft/z : fake-thm z\n <- ff t (@ t).\n\n%worlds () (ff _ _) (fake-thm _).\n%total D (ff D _).\n%total [] (fake-thm _).\n</twelf>\n::: &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 16:58, 26 October 2006 (EDT)"
          },
          "sha1": "e08kxzq785byt0pj5akkdhr2n82vvtl"
        }
      },
      {
        "title": "Talk:Programming language theory with Twelf",
        "ns": 1,
        "id": 2050,
        "revision": {
          "id": 5183,
          "timestamp": "2008-07-03T18:22:24Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "comment": "New page: Hey Todd!  Writing Twelf code for all of this material and assembling it into one coherent story is a great idea!  Have you taught a course along these lines with Twelf (or are you going t...",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 259,
            "#text": "Hey Todd!  Writing Twelf code for all of this material and assembling it into one coherent story is a great idea!  Have you taught a course along these lines with Twelf (or are you going to?)?  Or is it just for fun?  [[User:Drl|Drl]] 14:22, 3 July 2008 (EDT)"
          },
          "sha1": "laqr0e7e90heoykv3s3u35n0p0dg7jx"
        }
      },
      {
        "title": "Talk:Proving metatheorems with Twelf",
        "ns": 1,
        "id": 1862,
        "revision": {
          "id": 8112,
          "parentid": 8111,
          "timestamp": "2016-02-10T15:35:07Z",
          "contributor": {
            "username": "Boyland",
            "id": 17
          },
          "comment": "Undo SPAM revision 8111 by [[Special:Contributions/178.73.219.233|178.73.219.233]] ([[User talk:178.73.219.233|talk]])",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 2307,
            "#text": "The content is good, but I'm not sure if it's directed to the right\naudience.  It seems to be directed to someone who wants to\nknow what's ''really'' going on in Twelf.  If someone just wants to see\nhow to use Twelf, they might get bogged down in Simply-Typed LF,\nwondering when the interesting content is going to come.\n[[User:Boyland|Boyland]] 22:30, 25 February 2007 (EST)\n\n: I've actually been looking at the [http://haskell.org Haskell Wiki] lately - I see this as one way to get an idea of what we're going for here (Twelf's not Haskell, but it's a good successful model). They have an article [[haskell:Haskell in 5 steps|Haskell in 5 steps]] that might be a model for something a little simpler than this; however, I'm not sure what audience we'd be directing towards such a tutorial.  The thing we've tried to think about for the [[introductions to Twelf]] is how we want to direct various audiences, as the intro says this aims to be the \"I've read Types and Programming Languages\" audience - i.e. people that are interested in the type theory of what they're doing. What would your say is the audience we're missing here? — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 23:30, 25 February 2007 (EST)\n\n:: The audience you're missing are the people who have read TAPL, have written their own natural language proofs and want to write machine-checked proofs.  I'm also assuming they understand pattern-matching and logic programming at a practical level.  The article claims to address the audience but then goes on a long time about LF's type system.  Their interested in ''their own'' type system, not ''yours.''  Sure, if they find Twelf expressive, they'll want to learn more, but to expound upon the type system before you've sold them on the usefulness is probably counter-productive.  And anyway, if they are type aficionados, they'll turn up their nose(s) at the lack of higher-order. [[User:Boyland|Boyland]] 20:01, 26 February 2007 (EST)\n\n== The third layer ==\n\nDoes this line \"The third layer presents some more-interesting proofs and introduces one additional feature of Twelf, the ability to do proofs about open terms.\" need to be tweaked with the restructuring of the tutorial? — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 20:25, 14 March 2007 (EDT)"
          },
          "sha1": "n1zau0ff9vabo6gvstsij92xgl2evzk"
        }
      },
      {
        "title": "Talk:Quick introduction",
        "ns": 1,
        "id": 1754,
        "redirect": {
          "@title": "Talk:General description of Twelf",
          "#text": null
        },
        "revision": {
          "id": 3326,
          "parentid": 3072,
          "timestamp": "2006-11-12T16:16:40Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "path compression",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 47,
            "#text": "#REDIRECT [[Talk:General description of Twelf]]"
          },
          "sha1": "aohk2p4i2s3ktkfpvws3u9ci1o82os9"
        }
      },
      {
        "title": "Talk:Reformulating languages to use hypothetical judgements",
        "ns": 1,
        "id": 2036,
        "revision": {
          "id": 5102,
          "parentid": 5088,
          "timestamp": "2008-03-04T15:34:30Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 1967,
            "#text": "Thanks Dan, very useful.\n\nHere's two other inductive properties of complete development:  \n\nFirst, ==> is not only deterministic, but total: for every M there is some X s.t. M ==> X.\n\nSecond, ==> completes any =>:\n\n  cd_pr_triangle: (M ==> N) -> (M => L) -> (L => N).\n\nThese two properties give an easy proof that => has the diamond property: put two of these triangles together along their ==> side.\n\n[[User:Rpollack|Rpollack]] 17:04, 28 February 2008 (EST)\n\n: Cool.  I know there's a proof of CR in the Twelf examples directory, but I think it proves diamond for parallel reduction directly.  If I get a chance, I'll Twelf these theorems up and then maybe turn this page into a case study instead of a tutorial.  [[User:Drl|Drl]] 16:08, 3 March 2008 (EST)\n\n:: Done, but not commented yet: [[Church-Rosser via Complete Development]].\n[[User:Drl|Drl]] 10:34, 4 March 2008 (EST)\n\n---------\nHow about improving the rule ==>/beta to:\n\n  ==>/beta : (app (lam M) N) ==> M' N'\n            <- (lam M) ==> (lam M')\n            <- N ==> N'.\n\nThis simplifies the proof of \"sound\" too.\n\n[[User:Rpollack|Rpollack]] 15:34, 29 February 2008 (EST)\n\n: Good idea---it makes sense to localize the binding here.  I've seen situations where this move actually gives you less information (e.g., a typed beta-reduction rule in a calculus with a definitional equality rule---you can't invert the derivation of (lam M : A -> B) to get a hypothetical), but for this tutorial it makes sense.  [[User:Drl|Drl]] 16:08, 3 March 2008 (EST)\n\n:: Actually, there's one downside to this reformulation: in the original version, Twelf can prove => total automatically, but in the new version, it gets tripped up by the inversion that if (lam M) => N then N is (lam N1).  I changed the definition back because I want to let Twelf prove this totality for me in [[Church-Rosser via Complete Development]], and I want the code here to stay synchronized with that.  [[User:Drl|Drl]] 10:34, 4 March 2008 (EST)"
          },
          "sha1": "5hwmomblpo359eja2nqyq0jbu701svc"
        }
      },
      {
        "title": "Talk:Respects lemma",
        "ns": 1,
        "id": 1741,
        "revision": {
          "id": 3877,
          "parentid": 3875,
          "timestamp": "2007-03-09T16:44:13Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 13610,
            "#text": "== Not general enough ==\n\nI don't know if we are defining ''congruence lemma'' or if we're taking the definition from somewhere else, but I think that this definition is perhaps needlessly specialized. In almost any system these lemmas must concern more than just a single relation R. For instance:\n\n<twelf>\nexp : type.\nval : type.\n\n\npair : val -> val -> val.\n% values are expressions\nvalue : val -> exp.\nlam : (val -> exp) -> val.\nlet : exp -> (val -> exp) -> exp.\n\neq-val : val -> val -> type.\neq-val/ : eq-val V V.\n\neq-exp : exp -> exp -> type.\neq-exp/ : eq-exp M M.\n\npair-cong : eq-val V1 V1' -> eq-val V2 V2' -> eq-val (pair V1 V2) (pair V1' V2') -> type.\nlet-cong  : eq-exp M M' -> ({v} eq-exp (N v) (N' v)) -> eq-exp (let M N) (let M' N') -> type.\nvalue-cong : eq-val V V' -> eq-exp (value V) (value V') -> type.\nlam-cong  : ({v} eq-exp (M v) (M' v)) -> eq-val (lam M) (lam M') -> type.\n</twelf>\n\n<tt>pair-cong</tt> is a congruence lemma as you defined. But the others are not: <tt>let-cong</tt>, uses only <tt>eq-exp</tt> but the statement of the lemma needs to quantify over values (\"for all v, if R(N v) and R(N' v) ...\") so it doesn't fit the form. <tt>val-cong</tt>'s premise is a different relation. <tt>lam-cong</tt> has both problems.\n\nMoreover, all of these are instances of what Karl and Tom and probably others call \"respects\" lemmas. Do we have an article about that, or should this article be about that instead? I think it would be a more useful subject. If \"congruence lemma\" is already taken by other mathematicians, we need a new name for such \"respects\" lemmas. &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 10:13, 20 October 2006 (EDT)\n\n: This was another one of those \"I had a conversation with Dan Licata and then wrote things on the wiki\" moments (like [[shallow equality]] versus [[identity]]) - I don't see a problem with calling all of your lemmas above congruence lemmas or respects lemmas, and I don't understand your objection - if the component parts of an expression <tt>value V</tt> are equal (in this case as defined by a different relation) then the entire expression is equal. However, I realize now that while I think drl used the word \"congruence,\" I recognized it because it's exactly the word we used for this \"respects\" property in FPCC HOL. Now googling things I find that it is from Leibniz dealing with geometry, and I can't find any use of the word the way I think of it. I'll ask drl if he remembers what it was I actually meant today, and if I can't come up with a good argument I'll move it to [[respects lemma]]. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 10:45, 20 October 2006 (EDT)\n:: My objection is simply that there is not a single relation ''R'' in question, so your definition is not general enough to account for several of the lemmas above. It's a minor technical quibble, but if we're going to define something mathematically, it should cover the cases we're interested in. (I actually think examples of the technique will be plenty in this case.) &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 14:48, 20 October 2006 (EDT)\n::: Is this statment closer to what you're looking for, and does the distinction between the two definitions make sense? Should I change the <math>f</math> to a <math>\\mathcal{R}</math> for the [[respects lemma]] comment? — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 03:00, 21 October 2006 (EDT)\n:::: I'm being bold and rewriting it. &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 10:53, 1 November 2006 (EST)\n\n== Why is compatibility a respects lemma? ==\n\nI don't understand why compatibility is a respects lemma?  What relation is being shown to respect bin-eq in \n\n<twelf>\n1-compat : bin-eq M M' -> bin-eq (1 M) (1 M') -> type.\n</twelf>\n\n?\n\nOr, in what sense is 1 a relation?\n\nI would reserve \"respects\" for the sense in which you use it in the first part of the article, namely showing that a type family respects particular relations on its indices.  I don't think of congruence/compat as being an instance of that.\n* I guess the definition of a \"respects\" lemma should also say term constructors, or else you're right that it doesn't fit. I'll fix it. The reason for lumping them all together is that people like Karl and myself and DKLee use <tt>-resp</tt> in our code for compatibility lemmas as well. &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 13:38, 3 November 2006 (EST)\n\nAlso, I'm not convinced that it makes sense to define this terminology in general for arbitrary relations.  E.g., is showing that if M:A and A<:B then M:B a \"respects\" lemma, assuming I'm working in a system where this is only admissible?  What relations, other than identity, do we need to use this terminology for?\n::: I've seen it for inequality, for instance (see [[division over the natural numbers]]). &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 13:38, 3 November 2006 (EST)\n\nThe way I'd tell the overall story is this:\n* Often, we need to internalize LF equality---which, by adequacy, corresponds to equality of informal object-language entities---as a judgement.  Usually this is so that we can state and prove metatheorems that involve equality (e.g., that a judgement's outputs are unique).\n* There are several ways of doing this:\n** Identity (least relation containing reflexivity)\n** Compatibility rules for each constructor\n** Compatibility rules for each airity of constructor (Tom's trick)\n** Compatibility rules plus explicit refl, sym, trans rules\n: All of these define the same relation.  However, it turns out that identity is the easiest definition to work with: it gives you the most information when reasoning ''from'' equality and it's almost as easy to show that the remaining rules (compitibility, S and T) are admissible as it is to write them as explicit rules. \n\n* You often need to show that a type family's indices respect equality---that you can replace equals with equals.  When you've defined equality to be identity, these respects lemmas are always trivial to prove because...\n\n[[User:Drl|Drl]] 18:01, 2 November 2006 (EST)\n:::I think you should look at the [[equality]] page to incorporate that story, but this page isn't about equality... (?) &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 13:38, 3 November 2006 (EST)\n\n== Fixing this, uniqueness, etc. ==\n\nMost of these '''... lemma''' articles don't hold together. I've grepped through a lot of the TALT code, and Tom is right that code (at least in <tt>iequalities.thm</tt>) supports the idea that <tt>value-cont</tt> above is a \"respects lemma\". \n\nThat said, \n* the vast majority of theorems in TALT with the token <tt>resp</tt>, as well as\n* all the theorems with the token <tt>respects</tt> in DRL's <tt>exp-evaluation</tt>, <tt>lc-height</tt>, and <tt>list-append-assoc</tt> \nencode the idea of ''referential transparency'' as Stephen Brookes explains it. Every online source on referential transparency is crap, as far as I can find; according to Brooks the term embodies the idea of Frege: ''The meaning of a sentence must remain unchanged when a part of the sentence is replaced by an expression having the same meaning.'' Your example of equals-for-equals for <tt>and</tt> embodies this fact, so does this theorem from TALT: \n<twelf>\nelab_operand_resp_same : same_operands O O' -> elab_operand LI N O OE -> elab_operand LI N O' OE -> type.\n</twelf>\nThe inputs are always a bunch of type families saying \"things are equivalent in some way\", plus one relation that isn't considered \"equivalence\" (<tt>and</tt> in your example, <tt>elab_operand</tt> in the above example)). The output is that same relation, but with equals replaced for equals. This, I think, is a great way to explain what we mean by \"respects lemmas\" - in this formulation, \"respects lemmas\" have something very fundamental to do with equality/equivalence.\n\nAnother example from TALT doesn't have precisely this form, but still fits into the idea of substutiting equals for equals, becuase it is implicitly operates based on the idea that <tt>N*M</tt> and <tt>N*M'</tt> are the same thing.\n<twelf>\nbinary_size_resp3 : product N M N*M -> product N M N*M' -> binary_int E V (B : binary N*M) -> binary_int E V (B' : binary N*M') -> type.\n%mode binary_size_resp3 +X1 +X2 +X3 -X4.\n</twelf>\n\nOn the other hand, TALT also has this theorem: \n<twelf>\nii_add_resp : eaddress_eq E E' -> oper_eq O O' -> iinst_eq (ii_add N E O) (ii_add N E' O') -> type.\n</twelf> \nThis describes what I wanted to call \"congruence\" early on and which you disagreed with. However, think about if, instead of <tt>ii_add</tt> being a function, \n<twelf>ii_add : {Nsz:nat} eaddress Nsz -> oper Nsz -> iinst.</twelf>\nit was a total relation with three inputs and an output.  \n<twelf>ii_add : {Nsz:nat} eaddress Nsz -> oper Nsz -> iinst -> type.</twelf> \nThen the theorem above would be \n<twelf>\nii_add_resp : eaddress_eq E E' -> oper_eq O O' -> ii_add N E O II -> ii_add N E' O' II' -> iinst_eq II II' -> type.\n%mode ii_add_resp +Eq1 +Eq2 +OP2 +OP1 -Eq3.\n</twelf>\nThis is the form of a [[uniqueness lemma]], and not a statement about referential transparency as the vast majority of <tt>resp</tt>-proofs in TALT are; the same goes for every one of the <tt>cong</tt> lemmas that Tom mentions at the top. \n\nHere is what I propose we either write (or else write something similar), or else delete all three of these confusing crazy articles and start over.\n* [[Respects lemmas]] are lemmas that embody referential transparency. They deal with a relation ''respecting'' an equivalence relation by permitting the substitution of equals for equals. Part and parcel of this is that the relation that respect equivalence (<tt>and</tt> or <tt>binary_int</tt> or <tt>elab_operand</tt>) don't need to be thought of as having \"inputs\" and \"outputs.\" \n* [[Congruence lemmas]] show that if A and A' are related in some way (equality, inequality, whatever), and a transformation (specifically adding or removing a function symbol like <tt>pair</tt>, <tt>s</tt>, <tt>let</tt>, or <tt>value</tt>) transforms A to B and A' to B', then B and B' are related in some way (equality, inequality, whatever). \n* [[Uniqueness lemmas]] show that if A and A' are equivalent, and F maps A to B, and F maps A' to B', then \n\nCongruence lemmas and uniqueness lemmas, then, are a more general case of something that seems to look like this (Noam helped me with the category theory, though I'm obviously going to botch it here):\n<pre>A ------> B\n|     f   |\n| R       | R'\n|     f   |\nA' -----> B'</pre>\nwhere in congruence we say ''<tt>f</tt> is a function symbol, not a relation'', and in uniqueness we say ''<tt>f</tt> is a relation, not a function symbol'' and ''<tt>R</tt> and <tt>R'</tt> are both some sort of equivalence relation.'' We write articles for these two things rather than all the other generalzations, because they show up alot, awesome. \n\nSorry for writing so much — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 23:30, 8 March 2007 (EST)\n\n: I'm mostly okay with this terminology, since it's close to what I've been advocating from the start.  Here's how I use the words:\n: * Respects: a relation respects the equivalence of its subjects:  R(...,M,...) and M = M' implies R(...,M',...).\n: * Uniqueness: a relation determines some positions uniquely:  R(...,M,...) and R(...,M',...) implies M = M'.\n: * Congruence: an equivalence relation commutes with the term formers.  M = M' implies f M = f M'.  Since we have different notions of equivalence at different types, the relation in the premise will not always be the same as the relation in the conclusion.  \n\n: It might be better to call these \"compatibility\" rather than \"congruence\", if we want the same terminology for non-equivalence-relations.  Congruence and compatibility are \"already taken\" in math, so we shouldn't break with their established meanings.  A congruence is an equivalence relation that commutes with term formers; a compatible relation does not have to be an equivalence relation.  \n\n: Also, I don't think it's right to call an \"upside-down congruence lemma\" a congruence lemma, since I can write down a congruence that doesn't satisfy such inversion properties.  I call them inversions.  \n\n: Someone at some point (Tom?) made an argument for why a congruence lemma was a respects lemma, but I don't remember what that argument was.\n\n: [[User:Drl|Drl]] 11:44, 9 March 2007 (EST)\n\n:: I figured this well might be what you were always trying to say; I've just been lost in the woods about this and needed to work it out for myself. Do I understand you correctly when you say that \"compatibility\" does fit the meaning you say it has in mathland? If so, great; maybe we should just have the page \"Congruence lemma\" and mention that \"Compatibility lemma\" is a generalized case of this? I think the original point of these techniques were that they were specific and showed up all the time; therefore it would be nice to be as specific as is reasonable. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 10:53, 9 March 2007 (EST)\n\n::: I think I have the definition of compatibility right.  William is the one who corrected my use of congruence on non-equiv relations, so ask him.  I'm thinking that it would be most clear if we just have one page on identity types that introduces this terminology in that specific context, with subsections for respects, congruence, ... .  Then we can say that we use the terminology analogously for other equiv rels and relations in general.  That will be less abstract than defining the terms in the context of a general discussion of equiv rels.  [[User:Drl|Drl]] 11:44, 9 March 2007 (EST)"
          },
          "sha1": "nhkb364igdk90giccvw8ii7o1d8mdsz"
        }
      },
      {
        "title": "Talk:Software",
        "ns": 1,
        "id": 1668,
        "redirect": {
          "@title": "Talk:Download",
          "#text": null
        },
        "revision": {
          "id": 2405,
          "timestamp": "2006-10-06T16:26:09Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "[[Talk:Software]] moved to [[Talk:Download]]: Every other site in the world calls this page \"Download,\" we might as well.",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 27,
            "#text": "#REDIRECT [[Talk:Download]]"
          },
          "sha1": "jqmkgilk64t22jgykhgak27idm3qwhk"
        }
      },
      {
        "title": "Talk:Strengthening",
        "ns": 1,
        "id": 1902,
        "revision": {
          "id": 4173,
          "parentid": 4172,
          "timestamp": "2007-03-15T23:35:45Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 2361,
            "#text": "This tutorial is great! I have a few suggestions:\n# It would be helpful to discuss, for intuition, why the variables cannot occur in the term you get out of the store.  What is the invariant on the store that makes this work?  Right now, I'm not seeing it.\n# It might be clearer to decompose the second strengthening lemma into first a respects lemma and then one\n<twelf>\ntm-wf-strengthen :\n  ({v:tm}{d:tm-var v} tm-wf T S) ->\n%%\n  tm-wf T S ->\n  type.\n%mode tm-wf-strengthen +X1 -X3.\n</twelf>\n[[User:Drl|Drl]] 15:16, 15 March 2007 (EDT)\n\nI just fixed 1. in the article; let me know if that satisfies. For 2., I tried to do it that way in the original proof, but I was unable to use the respects lemma where I needed it (a termination problem I couldn't figure out; something to do with subterm ordering under a binder). I will reconstruct it and see if somebody can help me fix the problem. [[User:JakeD|JakeD]] 16:41, 15 March 2007 (EDT)\n\n: OK, it makes sense that that particular variable isn't in the thing from the store because the store itself doesn't mention it.  Is there some stronger invariant on things in the store, though?  Why can they have free variables at all?  Should they be values?  I guess I'm hunting around for a different strengthening theorem that says \"if the store seems to depend on variable <tt>x</tt>, in fact it doesn't\".  This is orthogonal to the one you prove here, but it might be worth commenting that it holds (if it does), so people (like me) don't get confused. [[User:Drl|Drl]] 17:10, 15 March 2007 (EDT)\n\n: And oh, maybe you forgot to put a [[%reduces]] on the respects lemma?  That would cause termination trouble if you tried to use the respects lemma before the inductive call.  [[User:Drl|Drl]] 17:11, 15 March 2007 (EDT)\n\n:: Yes, the store only ever contains values, but that's an invariant preserved by evaluation (not intrinsic to the definition of a store). We could define stores so that it is intrinsic (I think we'd need to make evaluation intrinsically return a value) and perhaps that would be clearer.\n:: I tried [[%reduces]] and it didn't work; the problem was that the inductive call is under a binder. Maybe there is a way to declare [[%reduces]] under a binder?[[User:JakeD|JakeD]] 19:01, 15 March 2007 (EDT)\n\n::: Dunno.  Post the code here and I'll look... [[User:Drl|Drl]] 19:35, 15 March 2007 (EDT)"
          },
          "sha1": "03s8xwrn18egfgf1xq5yapt3arzc5z5"
        }
      },
      {
        "title": "Talk:Substitution lemma",
        "ns": 1,
        "id": 1500,
        "revision": {
          "id": 8003,
          "parentid": 1920,
          "timestamp": "2015-03-04T03:32:46Z",
          "contributor": {
            "username": "Twilson",
            "id": 15
          },
          "comment": "Comment about the inefficiency of catch-all cases.",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 2641,
            "#text": "== Suggestions for points that require clarification ==\n\nGo wild. --[[User:DanielKLee|DanielKLee]] 21:07, 24 September 2006 (MST)\n\n== exchange can be subtle ==\n\nthe current draft suggests that exchange is valid whenever a variable cannot occur in a subsequent type, but unfortunately this simple statement is not true in general.  the reason is that the well-formation of a subsequent type may depend on the preceding variable, even if the type itself does not involve that variable!  this would come up in situations where the equational theory of types is such as to permit deduction of equations from existence of variables of preceding types, eg x : False, y : Garbage wouldn't permit exchange if the formation of Garbage depended on knowing that x : False is a contradiction!\n\na related point is strengthening: it is NOT true in general that if a variable doesn't occur, then the variable can be dropped.  it is in general a deep property of a type theory that non-occurring variables can be dropped.  this was a main complication for the metatheory of lf itself: it is quite non-obvious how to prove strengthening, but this is necessary for some proofs of decidability for beta-eta conversion.\n\n[[User:Rwh|Rwh]] 21:18, 24 September 2006 (MST)\n\n: Point noted. Language modified. --[[User:DanielKLee|DanielKLee]] 21:36, 24 September 2006 (MST)\n\n== on the use of catch-all cases ==\n\nI want to pick a nit about the use of catch-all cases in definitions like substitution. They are no doubt convenient, since they obviate the need to introduce a base case for the new variable when recurring under a binder and save some of the associated complexity in the context blocks, but they are (IMHO) objectionable for at least two reasons, one minor and one more serious:\n\n# they violate the aesthetic principle that all information about fresh variables should be contained in the context along with the variable, which is after all the purpose of a context block; and\n# from a logic-programming standpoint, they introduce ''exponential non-determinism'', since, in a vacuous substitution, the substitution goal will match both the catch-all case and the case for its outermost constructor, and the same will be true at ''every one of its subterms''; thus a vacuous substitution into a term of size n will have 2^n different derivations.\n\nOf course, if we are just talking about truth, then something that is true 2^n different ways is not any more or less true than something that is true in just one way, but again, why not \"code\" things up more efficiently if we can? Anyway, just a thought.\n\n[[User:Twilson|Twilson]] 22:32, 3 March 2015 (EST)"
          },
          "sha1": "2002tqsx6yulhwr6y5qh2frer0r4kv5"
        }
      },
      {
        "title": "Talk:The two Twelfs",
        "ns": 1,
        "id": 1989,
        "redirect": {
          "@title": "Talk:Modes of use",
          "#text": null
        },
        "revision": {
          "id": 4694,
          "timestamp": "2007-04-09T20:57:02Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "[[Talk:The two Twelfs]] moved to [[Talk:Modes of use]]: better name",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 31,
            "#text": "#REDIRECT [[Talk:Modes of use]]"
          },
          "sha1": "cup93xe9omwyc6xeszxnoh1h4ct0sfc"
        }
      },
      {
        "title": "Talk:Totality assertion",
        "ns": 1,
        "id": 1882,
        "revision": {
          "id": 4480,
          "parentid": 3962,
          "timestamp": "2007-03-20T21:57:52Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "comment": "/* Why I somewhat rudely deleted the whole page and redirected to something I wrote previously */",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 6281,
            "#text": "== Why I somewhat rudely deleted the whole page and redirected to something I wrote previously ==\n\nI found the previous version of this troubling, mainly just because it was confusing, but also because I'm not sure what a page on \"totality assertion\" is supposed to contain. I redirected to my summary at [[%total]]; that summary is brief and should be expanded (especially with examples). But when a sentence needs to be bullet-pointed, I think it's either saying way too much for one sentence or way too little for us to understand! I propose that we have a page about [[metatheorem]] that discusses why you'd like to make a [[%total]] declaration and what it means for metatheory, and a page about [[%total]] (still needs work obviously) that explains how you do it and specifically what it means in terms of logic programming.\n\nIn case you disagree and recreate this, specifically:\n* there are no infinite-sized terms; if we have a LF term then it is of finite size.\n* Though a %total does prove it's \"always possible to derive an object..\" it is stronger than that: Twelf's logic program search procedure will always succeed.\n* It's critical for correctness that the inputs are ground, and the outputs are also guaranteed to be ground.\n* There may be no inputs or no outputs (or neither), so using the word \"some\" might be misleading (it can be read as \"exists\")\n* I'd say (defined by [[%worlds]] consisting of zero or more [[%block]]s), since that's all that worlds are.\n::::&nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 10:20, 9 March 2007 (EST)\n\n=== Original ===\nA '''totality assertion''' states the following:\n\n* Given one or more [[LF]] type families indexed by some number of objects\n* If some of those indices are treated as inputs and some are treated as outputs (as defined by a [[%mode]] for each family)\n* If the relevant part of the LF context is formed in a certain way (defined by <tt>[[%worlds]]</tt> and zero or more [[blocks]])\n* Then given terms for each of the indices treated as inputs, it is always possible to derive an object of any one of the type families, which means that it is possible to construct an object for each of the output types. Furthermore, based on an induction metric (defined by <tt>[[%total]]</tt>), this term has finite size.\n\nIf a type family is indexed by judgments, then a totality assertion proves the [[metatheorem]] that for all proof terms witnessing the truth of inputs, there exist proof terms witnessing the truth of each of the outputs; therefore, the totality assertion can be seen as the statement of a theorem that has the form {{forall}}A{{exists}}B for some sets of propositions A and B.\n\n== See also ==\n\n* [[Metatheorem]]\n* [[%mode]]\n* [[%block]]\n* [[%worlds]]\n* [[%total]]\n\n== What it should have contained ==\n\nThe page on totality assertions should have contained a general discussion of totality assertions for LF type families.  This is a different concept than %total.  The abstract notion of a totality assertion for a type family has nothing to do with the details of how Twelf proves some of them.  You can write down type family and a true totality assertion for it that Twelf can't prove with %total, or even that we can't prove in Twelf at all.  If %total changes (say, Carsten finishes his logic programming project on permitting more general orderings, or we switch to a functional meta-language), the notion of a totality assertion for a type family doesn't change.  That's why I think they should be separate pages.  Neither Rob nor I have had time to write more than the place-holder for TAs yet though.  Is there an easy way to undo the redirect?  [[User:Drl|Drl]] 11:51, 9 March 2007 (EST)\n:Yeah, it's really easy to undo by using history to navigate to an old version, then ''edit''ing that version, and saving. I'm not sure I understand why [[totality assertion]] shouldn't be a part of [[metatheorem]] but what you say makes sense. I think it's important though that this page doesn't appear to be documentation for Twelf's current notion of totality, since that could potentially be very confusing. &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 15:25, 9 March 2007 (EST)\n::In fact, [[metatheorem]] already has a section called [[metatheorem#totality assertion|totality assertion]]; perhaps that would be a satisfactory redirect target? &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 15:33, 9 March 2007 (EST)\n:::The whole point about [[metatheorem]] as I wrote it was to be hopelessly general - I don't even use dependent types. Then there is a separate issue of how we ''specify'' totality assertions over \"Twelf things\" - that was the idea for this article, which is basically what Dan said. While I don't see why you deleted rather than blanking, one might as well just start over, all I did last night was give the page complete sentences, which it did not have before. As you said in the edit to [[metatheorem]], you can specify true totality assertions that <tt>%total</tt> can't check, so a totality assertion is something different than a <tt>%total</tt>. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 19:26, 9 March 2007 (EST)\n::::I didn't delete it, I just redirected it. Also, feel free to revert if you don't think that was sensible... I'm just being bold and I have a lot of wiki ego hitpoints, don't worry! I'm not disagreeing that there are various levels at which we could discuss what a totality assertion is: clearly there is what is currently implemented in Twelf CVS; there is what ought to be implemented; there is what's in Carsten's thesis; there is what might be implemented due to current research; there is the general notion of totality on Twelf relations, both in the sense of totality assertions that are recursively enumerable and the sort of undecidable Platonic math set-of-all-total relations; there is the more general still notion of totality on not-necessarily-Twelf relations, etc. But we ought not have an article on all of these! So what's the pedagogical reason for an article on [[totality assertion]] that isn't covered by [[%total]] or [[metatheorem]]? My feeling is that it is an unnecessary middle ground, at least not nearly as important as most of the redlinks on [[Twelf glossary]]. &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 16:39, 12 March 2007 (EDT)"
          },
          "sha1": "gtgbos4l8d93a0y9ofo5zhnfo9upu2k"
        }
      },
      {
        "title": "Talk:Try Twelf now",
        "ns": 1,
        "id": 1710,
        "redirect": {
          "@title": "Talk:Twelf Live",
          "#text": null
        },
        "revision": {
          "id": 2778,
          "timestamp": "2006-10-13T21:33:47Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "[[Talk:Try Twelf now]] moved to [[Talk:Twelf Live]]: Separate page with a name. Horray for AJALF!",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 29,
            "#text": "#REDIRECT [[Talk:Twelf Live]]"
          },
          "sha1": "7k6juj6vkfif485tb963ullngdzhiru"
        }
      },
      {
        "title": "Talk:Tutorials",
        "ns": 1,
        "id": 1695,
        "revision": {
          "id": 4861,
          "parentid": 4265,
          "timestamp": "2007-10-02T20:09:18Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "comment": "/* Tutorials that need written */",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 7216,
            "#text": "== Tutorials that need written ==\n\n* Double negation translation - ''Jcreed''\n* Classical logic - ''Will''\n* Lexographic induction - ''Jcreed'' (it would be good to have something more direct than cut elimination, which certainly uses lexicographic induction, but that's not the main point of the article)\n* Translating between logics - \n* Reverse the polarity -\n* Closure conversion - ''tom'' if he does it for his thesis\n* from svn repository: ipc-taut?, systemf-bidi?\n* dklee's as-pattern trick\n\n== Output factoring/freeness ==\n\nOutput factoring/freeness ''are'' similar problems - output factoring is the way you solve the fact that Twelf thinks you have a problem with output freeness, to put it simply. Do you think it's more or less confusing to have the two different tutorials and just have them perhaps refer to each other? — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 01:05, 12 October 2006 (EDT)\n* Factoring is more generally a problem with output ''coverage''. Output freeness is part of output coverage, but we needed to do factoring even with the unsound Twelf before the freeness check was introduced. Freeness is not documented anywhere, which is why it's important to have a page about it on the wiki. The articles should definitely be separate, IMO. &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 08:34, 12 October 2006 (EDT)\n\n== order? == \n\nWhat does everyone think about moving the proof techniques and illustrative examples up and the troubleshooting down?  Right now, when you go to this page it says to me \"Twelf is hard to use; here's how you work around the trouble.\"\nWe can compensate by outlining a path through the tutorials.\n[[User:Drl|Drl]] 00:18, 24 October 2006 (EDT)\n\n: Agreed. Also, we can factor things out of this page whenever it gets too large, and \"troubleshooting\" is a good canidate for factoring whenever that point comes. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 10:00, 24 October 2006 (EDT)\n\n== What is the difference between troubleshooting and proof techniques? ==\n\nI don't understand the difference between troubleshooting and proof techniques.  At what point does \"a way to fix a common problem\" become a proof technique?  If we want to make any distinction at all, I propose that there should be an \"Understanding error messages\" section that contains articles about what went wrong, and a \"proof techniques\" section that tells you how to fix it (if the fix requires enough of an idiom to warrant a separate page).  In particular, I moved output factoring to the \"techniques\" rather than \"troubleshooting\", and then either someone moved it back or I screwed up the edit and forgot to delete it.  But I don't think it should be in both places, since this page should read like a table of contents, not like a list of tags.  Thoughts? [[User:Drl|Drl]] 16:39, 13 March 2007 (EDT)\n\n: So I think we've reached the point of needing to factor things out that I mention above... I propose we just have \"Beginner\" \"Advanced\" and \"Illustrative examples,\" and we say in the preamble of \"Illustrative examples\" that  there is significant overlap between 'illustrative examples' and [[Case studies]]. I would then say that \"Data structures in Twelf\" and \"Error messages\" get their own articles, but I don't know how to organize that in the greater structure of the wiki... — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 22:27, 14 March 2007 (EDT)\n\n:: I dunno, I think this is a good place for articles on understanding error messages.  What about collapsing data structures into an appropriate category (illustrative examples?)  That might make it feel less sprawling.  I think we have about as many top-level places to look for documentation (i.e., what's in the sidebar) as we can handle already.  Maybe I'll play with this page later to try some ideas.  [[User:Drl|Drl]] 23:34, 14 March 2007 (EDT)\n\n::: So collapse troubleshooting into proof techniques, or just some of the troubleshooting things into proof techniques (like [[output factoring]])? Also, I'd like to think about where we put other extended introductions (Computation and Deduction, Hints on Proving Theorems (appel), Boyland's tutorial, etc) - on this page or in a less-privlidged section in the \"Introductions\" page (my mind reacts negatively to all the whitespace on the introductions page, though I know this is a false reaction). — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 00:47, 15 March 2007 (EDT)\n\n== the problem with the organization of this page ==\n\nThe problem with the organization of this page is that there are multiple ways of indexing this data: what we prove, and how we prove it.  Right now, the breakdown seems to be\n* proof techniques: here's '''how''' you prove this in twelf\n* illustrative examples: here's how you prove '''this''' in twelf (as long as it's not too involved, in which case it's a case study instead)\n\nThe current organization puts an article in the category that best describes it, but there are overlaps (e.g., output factoring could be an example of proving progress, but the focus is more on the technique than the theorem; cut elim could be a proof technique for lexicographic induction, but the focus is on the example, not the technique).  Then troubleshooting gets used for debugging hints that don't require any particular devices (so output factoring is a proof technique, not a troubleshooting).  \n\nAlternative organizations:\n# list articles under both indexings on one page\n# have two different \"sortings\" for the tutorials page\nThe downside is that these might appear more complicated, and it will be harder for the reader to figure out what he's read and what he hasn't.  And we'd have to maintain multiple indices as we add new tutorials.  Also, there are some tutorials that fit into one sort but not the other (e.g., proof techniques that only have a toy examples).\n\nSince this is relatively early in the learning-Twelf chain, I think the interface here needs to be particularly clean.  \n\nThoughts on what's best?  I think I'm in favor of the current organization, where we put something into the best category for it, even though that makes it a little unclear where things should go.\n\n[[User:Drl|Drl]] 11:04, 15 March 2007 (EDT)\n\n:: I think I'm currently questioning the \"too involved\" line between case studies and illustrative examples... maybe those we could factor out, but then where would data structures go? I'd argue \"case studies,\" but I'm not sure. Or perhaps \"Case studies\" should just move to \"Illustrative examples\" — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 11:58, 16 March 2007 (EDT)\n\n::: I think you're right---let's move the whole illustrative examples section (including data structures) to the case studies.  I do think we should then make a beginner/advanced distinction on the case studies page, since some of them are more accessible and more heavily commented than others.  This will simplify the organization considerably (tutorial for '''how''', case study for '''this''').  Just because of the length, I'm thinking we should maintain separate pages, rather than moving the case studies here. [[User:Drl|Drl]] 17:40, 16 March 2007 (EDT)"
          },
          "sha1": "tiv9cv1re7j7idfky2qs972m85tij91"
        }
      },
      {
        "title": "Talk:Twelf Live",
        "ns": 1,
        "id": 1696,
        "revision": {
          "id": 6530,
          "parentid": 6521,
          "timestamp": "2012-06-18T21:08:53Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "/* Broken? */",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 1136,
            "#text": "== Sandboxing ==\nMaybe we should suggest <tt>check=\"decl\"</tt> for sandboxing so that people can actually see their code without linking - if you're sandboxing, you're going to put everything in one box anyway. Yes, I made up the word ''sandboxing''. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 01:07, 12 October 2006 (EDT)\n\n== Front page ==\n\nAnd I'm not sure we should promote this off the front page - it's kind of an inconvienent way to try twelf unless you happen to be a MediaWiki hacker. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 01:20, 12 October 2006 (EDT)\n\n== Broken? ==\n\nI was really looking forward to this, great idea for giving people a chance to try twelf, but it seems to be broken.\n:: Fixed (sort of, for the moment) — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 11:41, 9 September 2010 (EDT)\n:::Thanks a lot! excellent. [[Special:Contributions/134.157.168.250|134.157.168.250]] 12:51, 9 September 2010 (EDT)\n\nI think one of my queries brought it down.\n:: Don't do that! — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 17:08, 18 June 2012 (EDT)"
          },
          "sha1": "9two1zy1qbh9ovclrdgy1d1nq68w8np"
        }
      },
      {
        "title": "Talk:Twelf style guide",
        "ns": 1,
        "id": 1451,
        "revision": {
          "id": 8067,
          "parentid": 8021,
          "timestamp": "2016-01-30T18:01:37Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "minor": null,
          "comment": "Reverted edits by [[Special:Contributions/37.113.34.32|37.113.34.32]] ([[User talk:37.113.34.32|talk]]) to last revision by [[User:Boyland|Boyland]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 19406,
            "#text": "== Uninhabited type flame war goes here ==\n\nI noticed there was some discussion about this in another place, but while I believe it would be a good idea to standardize on the name of the uninhabited type, \"void\" is not really standard or \"common practice\" yet. (I've seen false, falsity, absurd, and void. I use \"uninhabited\"). We probably need to have a \"standards\"/style guide meeting to decide these sorts of issues. \n--[[User:DanielKLee|DanielKLee]] 23:33, 6 September 2006 (MST)\n:: The spirit of the thing was to put something down and then we can argue about it. It will be expedient to any sort of \"standards\"/style guide if we have a document to argue from. Tom recommended <tt>void</tt>, I use <tt>absurd</tt>, we should pick something. I think <tt>void</tt> is best from a type-theory point of view, I think <tt>false</tt> is best from a readability point of view, I think <tt>uninhabited</tt> is best from a idiot-proof point of view. — this is a [[User:rsimmons|rob]] (a [[User talk:rsimmons|what?]]) 05:26, 7 September 2006 (MST)\n::: I think <tt>false</tt> is bad, because it is the most natural judgment to use when defining classical logic. &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 07:28, 7 September 2006 (MST)\n\n== Note: you *can* use uppercase identifiers ==\n\nThe following twelf code checks (1.5R1) (and in fact syntax highlights much more correctly than it does under the wiki syntax highlighter. I won't bother fixing the wiki syntax highlighting modules - the syntax module only needs to highlight code that is well-styled for me to be happy.\n\n<twelf>NAT : type.\n\nZ : NAT.\nS : NAT -> NAT.\n\nSIX = (S (S (S (S (S (S Z)))))).</twelf>\n\nSo we should not say the parser doesn't allow it, we should say that the parser doesn't allow it but ''use is punishable by '''eternal damnation'''''. — this is a [[User:rsimmons|rob]] (a [[User talk:rsimmons|what?]]) 05:42, 7 September 2006 (MST)\n\n== %abbrev ==\n\nIs there really any sense in which %abbrev is \"local\"? It seems to me that if you ever say <tt>%abbrev s nat/s</tt> you might as well have called it <tt>s</tt> in the first place. &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 09:11, 7 September 2006 (MST)\n: I'm thinking about using libraries - if you're pulling in someone else's <tt>nat</tt>, you expect things to be named <tt>nat/s</tt> and <tt>nat/z</tt>. Also, if you define <tt>s</tt> with %abbrev as the successor to a natural number, and someone else defines it as the successor to an integer with <tt>%abbrev s = int/s.</tt>, then both users can use their conceptual definition of <tt>s</tt> in their files without interfering with their ability to refer to <tt>nat/s</tt> and <tt>int/s</tt> directly. Or if I really like referring to the zero and successor constants as <tt>0</tt> and <tt>++</tt>, then I can do that without interfering with anyone elses definition - as long as everyone else follows the naming convention those definitions will never shadow anything else. — this is a [[User:rsimmons|rob]] (a [[User talk:rsimmons|what?]]) 10:13, 7 September 2006 (MST)\n\n== Terms judgments with \"/\" ==\n\nThis occured to me during the presentation with Karl. His proofs would have been much more bulky if he had used the full \"/\" notation for his language (though you could argue either way as to whether it would have been more clear to represent what kind of object each piece of syntax belonged to). \n\nIn general, it seems to me like we use Twelf at three different levels. This is I (think) the best way to classify the groups.\n\n# Object language (tp, nat, set, exp) - Constant defintions use forward arrows (<tt>abs : (exp T1 -> exp T2) -> exp (arr T1 T2)</tt>). I don't think there is consensus for using the /-notation for type constants here.\n# Judgments and relations (typed,plus,in-set, selfify) - Constants use backwards arrows. I don't think there's strong opposition to using the /-notation for type constants here.\n# Meta-judgments (progress,associative-plus,superset-trans) - The <tt>%total</tt> call is used in order to prove a meta theorem. Contstants here are all called \"<tt>-</tt>\", so the /-notation is besides the point.\n\nThe problem with using \"/\" in object language notation is that you'd need to use <tt>exp/abs</tt> instead of <tt>abs</tt>. If you did this, what would the evaluation rules be called? <tt>eval-e/abs</tt> or <tt>eval-e/exp/abs</tt>?\n\nPerhaps this isn't an entirely complete thought, hopefully the point I'm making is somewhat evident. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 13:04, 10 September 2006 (MST)\n\n: Using a \"/\" in the object language notation is probably not necessary if you are working in a small language without many strata. Karl's example was limited to the singleton calculus, so managing different strata wasn't necessary for him. In my own work, I've got lots of strata (5 different things called \"unit\", and pair/projection at 3 different levels, 2 different things called sigma etc) so I need to do what I can to organize things. In response to the <tt>eval-e/exp/abs</tt> issue, I've been known to pun it and call the judgment something like <tt>eval-exp</tt> and then the cases are <tt>eval-exp/abs</tt>. --[[User:DanielKLee|DanielKLee]] 08:52, 23 September 2006 (MST)\n\n:: What do you think about what I put there yesterday, then? It seems pretty compatible from my perspective - i.e. \"feel free to use single identifiers at your own risk in an outermost strata.\" I think <tt>eval-exp/abs</tt> makes a great deal of sense - <tt>eval-exp/abs</tt> is reasonably close to <tt>eval-e-exp/abs</tt>, which is what I was trying to recommend yesterday. However, since I put that section in the context of judgment factoring, the only situation I've encounterd it in, that section would probably greatly benefit from a rewrite by you (the whole document would :) - but that section especially). — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 09:00, 23 September 2006 (MST)\n\n::: Yeah, that looks fine. --[[User:DanielKLee|DanielKLee]] 09:58, 23 September 2006 (MST)\n\n== Jargonwatch and types of equality ==\n\nI was trying to write a section under \"specific naming conventions\" that talked about the [[Main_Page#Rephrasing_.22equality.22|two ways]] to describe [[equality]] - they should have standard, and different, names. It seems to me that <tt>eq1</tt> (''syntatic equality''? ''default equality''? ''meta-equality''?) from the example should be the default equality (i.e. should get the distinction <tt>eq-nat</tt>, but what about the other kind (''definitional equality''? ''inductive equality''? ''structrual equality''?)? \n\nWhat should its designation be? I want to avoid the use of <tt>eq'-nat</tt> or <tt>eq-nat'</tt>, because previous experience with apostrophies in identifiers are that they are a terrible mistake. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 15:54, 22 September 2006 (MST)\n* I believe that ''shallow'' and ''deep'' are other common terms. I think to call the first \"equality\" and the other \"deep\" or \"structural\" equality sounds good. &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 18:47, 23 September 2006 (MST)\n:* So an identifer \"deq\" for deep equailty instead of \"eq\" for shallow inequality might be in order? — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 17:51, 27 September 2006 (MST)\n::* Dan Licata (and by transitivity me) has used \"deq\" for declarative/definitional equality in the past, and aeq for algorithmic equality. These equalties were type equalities in systems where you could have equivalent types that were written differently. I tend to use eq/seq for syntactic equality (what you call shallow). I've seen others use \"id\". Usually seq. What do you plan on writing about \"deep\" equality? Maybe there are object logics where it might be useful, but at the meta-level shallow equality is very flexible and all you need. --[[User:DanielKLee|DanielKLee]] 18:15, 27 September 2006 (MST)\n:* \"Shallow\" vs. \"deep\" equality already has a meaning in Lisp and imperative languages that copy this meaning from Lisp.  The distinction is basically irrelevant in ML/Twelf.   Semantic equality and syntactic/structural equality is what we're talking about here.  And doesn't an \"adequate\" representation ensure that these kinds of equality co-incide?  So maybe \"semantic equality\" should instead be called an \"equivalence\" ? [[User:Boyland|Boyland]] 01:44, 12 March 2007 (EDT)\n::* Since \"identity\" is what we mean most of the time, I think that calling it \"equivalence\" of a certain sort when that is what we mean is the right solution. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 11:20, 12 March 2007 (EDT)\n\n== Whitespace ==\n\nThis is nitpicking, but if I have a really stupid lemma I may just want to get it out of the way as quickly as possible: <twelf>nat-neq-symm : nat-neq N1 N2 -> nat-neq N2 N1 -> type.\n%mode nat-neq-symm +D1 -D2.\n- : nat-neq-symm nat-neq/gt nat-neq/lt.\n- : nat-neq-symm nat-neq/lt nat-neq/gt.\n- : nat-neq-symm (nat-neq/s N1) (nat-neq/s N2)\n     <- nat-neq-symm N1 N2.\n%worlds () (nat-neq-symm _ _).\n%total T (nat-neq-symm T _).</twelf> \nDo you think the whitespace currently recommended in the document is necessary in these cases? — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 16:15, 22 September 2006 (MST)\n\n\n: Necessary to make the proof understandable? Probably not. Necessary to keep the structure of the code-base uniform? Probably. I try not to differentiate between how I format stupid lemmas and lemmas that make me feel stupid, out of karmic fear that the lemmas will catch on and I'll have to do more of the second kind. --[[User:DanielKLee|DanielKLee]] 09:58, 23 September 2006 (MST)\n\n:: I'll buy it. So is this the style we're going for? — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 12:49, 23 September 2006 (MST)\n<twelf>nat-neq-symm : nat-neq N1 N2 -> nat-neq N2 N1 -> type.\n%mode nat-neq-symm +D1 -D2.\n\n- : nat-neq-symm nat-neq/gt nat-neq/lt.\n\n- : nat-neq-symm nat-neq/lt nat-neq/gt.\n\n- : nat-neq-symm (nat-neq/s N1) (nat-neq/s N2)\n     <- nat-neq-symm N1 N2.\n\n%worlds () (nat-neq-symm _ _).\n%total T (nat-neq-symm T _).</twelf>\n\n\n:: Yes. --[[User:DanielKLee|DanielKLee]] 12:57, 23 September 2006 (MST)\n\n: I actually prefer the less-space version.  I wrote the rational signature with 200+ theorems. By omitting blank lines except between theorems, it easily parses into a series of chunks.  If I used two blank lines between each theorem and one line between each case, the whole thing would turn into a horrid mess. [[User:Boyland|Boyland]] 23:55, 11 March 2007 (EDT)\n\n: After some testing, I realize I was wrong.  It looks fine with more whitespace.  [[User:Boyland|Boyland]] 19:06, 25 April 2007 (EDT)\n\n== Word order ==\n\nI'm going to just start the word order argument now. I'm not positive if the style guide should be making suggestions about word order. If there is a consensus that the style guide should be making such suggestions, then I'll detail my preferences (which happen to deviate from the guidelines given). --[[User:DanielKLee|DanielKLee]] 09:58, 23 September 2006 (MST)\n\n: My motivation on word order is code reuse in general, and this floaty idea of a Twelf Standard Library in specific. If we're going to ever have something that approaches a common base version of <tt>nat</tt>, there needs to be clarity over whether it's <tt>nat-plus</tt> or <tt>plus-nat</tt>, and whether it's <tt>nat-plus-assoc</tt>, <tt>assoc-plus-nat</tt>, <tt>plus-nat-assoc</tt>, or <tt>assoc-nat-plus</tt>. Furthermore, it would be helpful if there were ''predective'' guidelines by which someone could then figure out, with a high degree of accuracy, what the metatheorem establishing the associtivity property for lists of natural numbers is (by my rules I beleive it would be <tt>append-list-nat-assoc</tt>). ''However'', and I probably can't emphasize this enough, I see no reason to go with ''my'' preferences - if by writing down my preferences I get you to write down yours in disagreement, I'm, in general, peachy keen on going with yours (especially if it's somewhat predictive). I also hold the belief that if we can point to where the rationale for our naming conventions is, it will make our proofs more readable by others. \n\n: 'Consensus' is going to be a funny animal in this world - unless by ''consensus'' you mean ''Tom, could you weigh in'' ;-) — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 12:40, 23 September 2006 (MST)\n\n:: I'll concede for a Twelf Standard Library, naming conventions would make it more organized. \n\n:: My preferences for the naming judgments is to usually do what best \"organizes\" things in the absence of a module system. For operations over natural numbers, I like to frontload the nat, so <tt>nat-plus</tt> instead of <tt>plus-nat</tt>. That way, all my definitions about arithmetic over natural numbers begins with <tt>nat-</tt> and I can sort of pretend its a nice little module. \n\n:: But I'll deviate from this if there is a family of judgments that is mutually recursively defined over two levels of an object language. So I would prefer <tt>step-exp</tt> and <tt>step-md</tt> over <tt>exp-step</tt> and <tt>md-step</tt> because I sort of consider the family of step judgments to be their own module. I personally fluctuate between whether - or / is the correct seperator in these cases. As a result, my ML stuff is actually a little inconsistent between - and / and at some point I need to go back and clean that up.\n\n:: Theorems can be pretty hard to name, especially when you have lots of them that don't really have canonical names. My rationale with them is whatever \"organizes\" them best, but that is subjective and not necessarily consistent from day to day. --[[User:DanielKLee|DanielKLee]] 13:33, 23 September 2006 (MST)\n\n:: I actually don't have much opinion on this at all. For the standard library we will need a naming convention, in the absense of a module system; with a module system the convention will be less important. For code written by programmers at the leaves, I don't think there is any particular need to enforce a naming convention. But, if we had to choose something, I would suggest that we use least general to most general, as if the / were . in the SML module system. &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 18:46, 23 September 2006 (MST)\n\n== Forking off naming conventions ==\n\nI was looking over the style guide, and I noticed the stuff about \"word-order\" and \"specific naming conventions\" really throws off the flow of the article. In particular, it pushes the stuff on whitespace pretty low on the page. Karl-style whitespace makes Twelf code a lot easier to read, so I feel it shouldn't get pushed too low on the article. Any disagreement on this? --[[User:DanielKLee|DanielKLee]] 15:30, 27 September 2006 (MST)\n\n: None - I'd leave the \"naming convention\" stuff about using hyphens instead of underscores and the forward slash to present individual cases, so we have two large sections: \"Identifiers\" and \"Whitespace\" - the details can get moved to the artice on [[Twelf naming conventions]]. This has the added advantage of putting largely non-controversial stuff in this article. You'll probably get around to this before me but I may try to do it before the weekend if you don't. Another thought is that it's not necessarily a bad idea to move whitespace up above the section on identifiers. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 17:49, 27 September 2006 (MST)\n\n== Anticipating modules ==\n\nI'd like to use a naming convention that simulates modules: short names that are then abbrev'ed at the end to have a name like SIG.name, except that of course you can't use \".\".  Any opinions on what character would be used as a module separator, should modules ever be added?  It'd be nice if the character were low-impact (ink-wise). Currently I'm experimenting with backquote.  \n<twelf>\n%%%% Imports\n\n%abbrev nat = nat`nat.\n%abbrev rat = rat`rat.\n%abbrev equ = rat`equ.\n%abbrev gre = rat`gre.\n\n\n%%%% Definitions\n\n\nfrv : type.\n\none : rat -> nat -> frv.\n\n\neq : frv -> frv -> type.\n\neq/ : frv_eq F F.\n\n\nge : frv -> frv -> type.\n\nge/ : frv_ge (one X O) (one Y O')\n    <- nat`eq O O'           %% abbreviated import not necessary\n    <- gre X Y.\n\n...\n\n%%%% Exports\n\n%abbrev frv`frv = frv.\n%abbrev frv`eq = eq.\n%abbrev frv`ge = ge.\n</twelf>\n(Module names can't be UPPERCASE without a lot of pain.)\nTo those abbrev-sceptics, it makes a difference because identifiers (like \"eq\") can be reused between \"modules\" if there is an \"abbrev\"iated (!) long name. [[User:Boyland|Boyland]] 00:18, 12 March 2007 (EDT)\n: Just need to add that slash (the character recommended by the existing style guide for this purpose) doesn't seem like a good idea since it is already (over-)used for other things. [[User:Boyland|Boyland]] 00:23, 12 March 2007 (EDT)\n\n:: In the current planned concrete syntax for the module system, the separator will in fact be \".\" (and, just like in SML, whitespace won't be permitted in long identifiers, so you'll be able to tell it from the declaration-ending period, which must be followed by whitespace).  [[User:Drl|Drl]] 00:33, 12 March 2007 (EDT)\n\n::: I think it was an idea to use the slash for roughly this purpose; however if it seems overused, I think <tt>`-_+/\\</tt> all make equally decent separators, so I would say do whatever works in terms of this.\n::: I've used an \"abbrev import\" style before myself, but not quite the same way. If you use short names (<tt>eq</tt>) and then re-declare them as long names with abbrev (<tt>frv`eq</tt>) as you do, then the emacs buffer is going to be filled with shadowed <tt>%eq%</tt>, and you may have to go back into your \"module\" to export 50 more things like <tt>gt/</tt> in order to prove metatheorems later. If, alternatively, you write things in \"long style\" and then try to abbrev them down when you need them in a particular place (so you do \"abbrev import\" but not \"abbrev export\"), you don't have that metatheorem problem (you can always access anything with the long name). From my experience trying this, it is sometimes hard to read error messages when you write down as <tt>(s (s (s (s z))))</tt> and the emacs buffer displays <tt>(nat/s (nat/s (nat/s (nat/s nat/z))))</tt> - but you may find that this is not a significant problem for you. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 11:16, 12 March 2007 (EDT)\n:::: Of <tt>`-_+/\\,</tt> only <tt>`-/,</tt> can be typed on a US keyboard without modifiers, so I think those are to be slightly preferred. I use / since I like - as a word separator. &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 14:05, 12 March 2007 (EDT)\n::::: Right, I'd forgotten that that was why <tt>_</tt> fell out of favor, good point. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 19:06, 12 March 2007 (EDT)\n:::: Regarding the need the reload a whole buffer to export an additional thing; in my current code where I use this convention, I use a perl script to export *everything*.  Regarding ` vs. / vs -: I also use '-' as a word separator in theorems.  I don't want / since I want something that can clearly be substituted with <tt>.</tt> (the character shouldn't be overloaded) when real modules arrive.  (It seems modules have been heralded since 2001.  What's their status?).  [[User:Boyland|Boyland]] 20:50, 12 March 2007 (EDT)"
          },
          "sha1": "0o15sox4z5j1emcb184lvalhfnvnr4f"
        }
      },
      {
        "title": "Talk:Twelf with Emacs",
        "ns": 1,
        "id": 2046,
        "revision": {
          "id": 5160,
          "timestamp": "2008-05-07T21:31:56Z",
          "contributor": {
            "username": "Boyland",
            "id": 17
          },
          "comment": "created; questions about the emacs",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 1002,
            "#text": "== Emacs Mode maintenance ==\n\nI have some questions:\n\n- Are the changes suggested for use with frames useful for everyone?  If so, are they added to the CVS/SVN repository for future release?\n\n- I defined a <tt>twelf-check-declaration-forward</tt> command for checking all declarations in the current buffer starting from the point.  I have found it useful.  I sent Rob a diff.  Is that the right way to contribute changes?\n\n- Is the emacs code being maintained?  It seems the syntax highlighting is worse than linear.  Or at least has a high constant factor.  Highlighting a file of 8000 lines can take a minute on a fast machine (MacBook Pro with dual-core, 2GB RAM).  Since highlighting is done automatically when a twelf file is visited, this delay is frequent and unavoidable unless one turns off highlighting,\n\n- More on maintenance: the emacs mode in CVS (twelf -1.5 R3) used the wrong names for parameters (debugging etc).  Has this been fixed?\n\n[[User:Boyland|Boyland]] 17:31, 7 May 2008 (EDT)"
          },
          "sha1": "529vlb45k807z3vkbr1w2aoaiwusga5"
        }
      },
      {
        "title": "Talk:Uniqueness lemma",
        "ns": 1,
        "id": 1885,
        "revision": {
          "id": 8070,
          "parentid": 8025,
          "timestamp": "2016-01-30T18:01:39Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "minor": null,
          "comment": "Reverted edits by [[Special:Contributions/5.167.114.39|5.167.114.39]] ([[User talk:5.167.114.39|talk]]) to last revision by [[User:Rsimmons|Rsimmons]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 399,
            "#text": "Revisions of this page should account for the fact that the thing we're showing unique doesn't have to be an output (in the %mode sense).  [[User:Drl|Drl]] 13:18, 9 March 2007 (EST)\n\n== Rewrite ==\n\nI just rewrote the top half of the article to set up some ideas that I needed in the bottom half.  Let me know if you have any complaints about the changes.  [[User:Drl|Drl]] 16:58, 14 March 2007 (EDT)"
          },
          "sha1": "9sdjw20plsbq0h4fkc7fcen74ax3zoq"
        }
      },
      {
        "title": "Talk:User's Guide",
        "ns": 1,
        "id": 1464,
        "revision": {
          "id": 1744,
          "parentid": 1737,
          "timestamp": "2006-09-21T21:27:14Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "minor": null,
          "comment": "[[Talk:UserGuide]] moved to [[Talk:User's Guide]]: proper title",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 393,
            "#text": "The official Twelf User Guide is out-of-date and inaccurate it some places. In addition, I've occasionally run into undocumented error messages. We should keep an eye out for potential articles that fill in gaps or correct errors in the User Guide. Ideally, the User Guide would be wikified, but who actually has time to do that? --[[User:DanielKLee|DanielKLee]] 18:46, 17 September 2006 (MST)"
          },
          "sha1": "meztjg6q6m2s3gxjz0k70udrqotlyq6"
        }
      },
      {
        "title": "Talk:UserGuide",
        "ns": 1,
        "id": 1466,
        "redirect": {
          "@title": "Talk:User's Guide",
          "#text": null
        },
        "revision": {
          "id": 1745,
          "timestamp": "2006-09-21T21:27:14Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "comment": "[[Talk:UserGuide]] moved to [[Talk:User's Guide]]: proper title",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 31,
            "#text": "#REDIRECT [[Talk:User's Guide]]"
          },
          "sha1": "coc56zs7jhebzq7q3tmog8s0vdslrmy"
        }
      },
      {
        "title": "Talk:Using nat-less with %reduces",
        "ns": 1,
        "id": 1532,
        "revision": {
          "id": 2091,
          "parentid": 2081,
          "timestamp": "2006-09-28T22:55:38Z",
          "contributor": {
            "username": "DanielKLee",
            "id": 5
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 936,
            "#text": "What do you think about turning this into a tutorial on ''strong induction over natural numbers''? &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 11:45, 28 September 2006 (MST)\n\n: Makes sense to me, as it's an extention of the [[%reduces]] article. Also, some of the code may need to be jiggled to work correctly with the parser - I'll add it to the parser to do list, but I'm not sure I can get it to *not* highlight <tt>thing1</tt> in:\n\n<twelf>name-of-metatheorem : {N}\n    thing1 N z N\n    -> thing2 z N N\n    -> type.</twelf>\n\n: — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 15:09, 28 September 2006 (MST)\n\n:: That might be a good idea. Any fun ideas for a theorem to prove using strong induction? The other target for the \"Strong induction\" tutorial would be the nat-division stuff, which already has an example of using %reduces to get the induction right. --[[User:DanielKLee|DanielKLee]] 15:55, 28 September 2006 (MST)"
          },
          "sha1": "gnp4mw3k2enkccvkw8p43qdi5uh915z"
        }
      },
      {
        "title": "Talk:What's new",
        "ns": 1,
        "id": 1704,
        "revision": {
          "id": 2766,
          "parentid": 2762,
          "timestamp": "2006-10-13T21:22:56Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "minor": null,
          "comment": "[[Template talk:Front-Blog Updates]] moved to [[Talk:What's new]]: Better name! The template can live with a redirect.",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 129,
            "#text": "I like the archiving old posts idea! — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 17:18, 13 October 2006 (EDT)"
          },
          "sha1": "onjcf52c9ioaaqoxti8llm7lbrrelou"
        }
      },
      {
        "title": "Talk:Working with higher-order judgements",
        "ns": 1,
        "id": 2038,
        "redirect": {
          "@title": "Talk:Reformulating languages to use hypothetical judgements",
          "#text": null
        },
        "revision": {
          "id": 5089,
          "timestamp": "2008-03-04T04:40:37Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "comment": "[[Talk:Working with higher-order judgements]] moved to [[Talk:Reformulating languages to use hypothetical judgements]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 73,
            "#text": "#REDIRECT [[Talk:Reformulating languages to use hypothetical judgements]]"
          },
          "sha1": "jj88d9y361m47ce2mvevo08o35l3a8a"
        }
      },
      {
        "title": "User:Boyland",
        "ns": 2,
        "id": 1863,
        "revision": {
          "id": 8113,
          "parentid": 8109,
          "timestamp": "2016-02-10T15:36:03Z",
          "contributor": {
            "username": "Boyland",
            "id": 17
          },
          "comment": "Undo SPAM revision 8109 by [[Special:Contributions/46.246.83.233|46.246.83.233]] ([[User talk:46.246.83.233|talk]])",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 10187,
            "#text": "John Boyland,\nProfessor, University of Wisconsin--Milwaukee.\n\nI'm interested in using Twelf and have\nwritten a biased and under-informed [http://www.cs.uwm.edu/~boyland/proof/using-twelf.html tutorial] of Twelf.\nI also have defined some [https://github.com/boyland/twelf-library library signatures] for Twelf.\n\n== Desired Features ==\n\nHere are some features that I would like to see in Twelf.\nI start with the simplest to implement (in my opinion).\n\n=== What free variables? ===\n\nIn Twelf, if you neglect to declare all the free variables in a theorem, you\nget the error message \"Free variables In theorem.\"  It would be nice\nif the error message included the names of these free variables.  Update: of course Control-C Control-L will tell you all the free variables that have names. Of course, the implicit ones don't show.  A %block declaration will show you the reconstructed term; it would be nice if %theorem did too.\n\n=== An <tt>exists*</tt> keyword ===\n\nIn Twelf currently, a theorem has the form\n<twelf>\nmy-theorem :\n    forall* {K1} {K2} {V1:term K1} {V2: term K2}\n    forall {D:rule V1 V2}\n    exists {K3} {V3:term K3} {DP:rule2 V1 V2 V3}\n    true.\n</twelf>\nSometimes the existentially bound variables are as extraneous as the <tt>forall*</tt>\nbound variables.  One would like to write\n<twelf>\nmy-theorem :\n    forall* {K1} {K2} {V1:term K1} {V2: term K2}\n    forall {D:rule V1 V2}\n    exists* {K3} \n    exists {V3:term K3} {DP:rule2 V1 V2 V3}\n    true.\n</twelf>\nCurrently my workaround is to avoid the theorem syntax and use an explicit mode declaration:\n<twelf>\nmy-theorem : (rule V1 V2) -> ({V3} (rule2 V1 V2 V3)) -> type.\n%mode +{K1} +{K2} +{V1:term K1} +{V2: term K2} +{D:rule V1 V2} \n            -{K3} -{V3:term K3} -{DP:rule2 V1 V2 V3}\n            (my-theorem D DP).\n</twelf>\nAn <tt>exists*</tt> keyword should be a trivial addition.\n\n=== Multiple <tt>%reduces</tt> for a type family ===\n\nIf one declares two <tt>%reduces</tt> for a type family, the first is forgotten.\nSince '%reduces` is very important for later reduction/totality checks, it would be\nvery helpful to collect all that are attached.\n\n=== Output coverage checking ===\n\nIt would be desirable to have output coverage checking done at the same time as mode checking, or at least to have the ability to check output coverage before a total declaration.  I have often found it frustrating to get an output coverage error late in the process of writing a proof.  And the \"covers\" check doesn't include output coverage\n\n=== Totality checker and theorem prover integration ===\n\nCurrently the theorem prover and totality checker live in different worlds,\nand neither trusts the other.  This seems peculiar to a user of Twelf\nwho may wish to use the theorem prover for certain obvious lemmas but\nthe totality checker for more complex theorems.  Currently this is impossible\nexcept in unsafe mode with the addition of assertions and \"trustme\" declarations.\n\nI propose\n\n1. The theorem prover should accept proved theorems:  If a totality flag is set on a metatheorem, it should accept it as proved.\n\n2. The totality checker should accept metatheorems proved automatically. If necessary, the theorem prover should deliver the proof to the totality checker internally (invisibly) for re-checking.\n\n3. The <tt>%assert</tt> and <tt>%trustme</tt> declarations should have the same effect: in unsafe mode make the metatheorem trusted by both the totality checker and the theorem prover.\n\n=== Local Type Inference ===\n\nAfter using Twelf for about a year and writing 100K lines of Twelf, the most frustrating and time consuming process is \"debugging\" coverage errors.  Because unification is bidirectional, any mistake in the middle of a theorem will cause the pattern taht one is trying to match to not be exhaustive, even though it appears to be.  It would be nice to use a system with a slightly less powerful type inference system that would prevent this long-distance effect of unification.  Pierce and Turner have defined \"Local Type Inference\".  It is interesting to wonder what this would mean for Twelf.\n\n== Known Bugs ==\n\nIn decreasing order of imporance.\n\n=== Type Reconstruction Nontermination ===\nType reconstruction sometimes fails to terminate\n<twelf>\n\nxxtag : type.\n\nxxtag/a : xxtag.\n\n\nxxterm : xxtag -> type.\n\nxxa : xxterm xxtag/a.\n\n\nxxoutput : xxtag -> type.\n\nxxoutput/base : xxterm K -> xxoutput K.\n\nxxoutput/exists : (xxterm K -> xxoutput K') -> xxoutput K'.\n\n\nxxtrans : xxoutput K -> xxoutput K -> type.\n\nxxtrans/transitive : xxtrans E1 E2 -> xxtrans E2 E3 -> xxtrans E1 E3.\n\nxxtrans/inside : ({v} xxtrans (FE1 v) (FE2 v)) ->\n\txxtrans (xxoutput/exists FE1) (xxoutput/exists FE2).\n\nxxtrans/gen-exists : {K1} {K2} {F:xxterm K1 -> xxoutput K2} {T}\n\txxtrans (F T) (xxoutput/exists F).\n\n\nxxtrans-open-exists :\n\t(xxtrans (xxoutput/exists FE1) E2) ->\n\t({v:xxterm K} xxtrans (FE1 v) E2) ->\n\ttype.\n\n- : {K1} {K2} {O}\n    xxtrans-open-exists\n\t (xxtrans/gen-exists K1 K2 ([v] (xxoutput/exists ([v'] FF v v'))) O) \n        ([v'] (xxtrans/transitive \n\t\t (xxtrans/gen-exists _ _\n\t\t    ([v] (FF v v')) O)\n\t\t (xxtrans/inside ([v] (xxtrans/gen-exists _ _ _ v'))))).\n\n</twelf>\nThe last term is incorrectly typed because <tt>FF</tt> depends on K1 and K2, but is not declared explicitly.\nBut in my version of twelf (twelf 1.5R3, with trustme, allegedly from August 2005) doesn't\nappear to terminate when attempting to type it.\n\n:Update:  Apparently this is a known bug for which a fix was found by Jason Reed. http://en.scientificcommons.org/47856338\n\n:The bug is still is in Twelf 1.7.1+ (r1887M)\n\n=== Coverage Checker Nontermination ===\n\nThe coverage checker sometimes fails to terminate.\n<twelf>\n%%%% coverage checking doesn't always terminate\n\n%%%% Definitions\n\nvoid : type.\n\n\nexpr : type.\n\nunit : expr. \nadd : expr -> expr -> expr.\n\n\n%%% Nested for evaluation\n\n\nexpr-in-expr : (expr -> expr) -> type.\n\n\nexpr-in-expr/add1 : expr-in-expr ([E] (add E _)).\n\nexpr-in-expr/add2 : expr-in-expr ([E] (add unit E)).\n\n\n%%% ready for atomic evaluation\n\n\natomic-expr : expr -> type.\n\n\natomic-expr/add : atomic-expr (add unit unit).\n\n\n%% this \"theorem\" is actually false\n\n%theorem expr-in-atomic-expr-contradiction :\n\tforall* {E} {T}\n\tforall {AE:atomic-expr (T E)}\n               {Tok:expr-in-expr T}\n\texists {F:void}\n\ttrue.\n\n%worlds () (expr-in-atomic-expr-contradiction _ _ _).\n%total { } (expr-in-atomic-expr-contradiction _ _ _).\n</twelf>\n\n=== Broken Invariant in Coverage Checker ===\n\nApparently (I learned of this problem from Rob Simmons), the coverage checker\nsometimes reports a broken invariant when checking code that\nuses the explicit-context idiom.  This problem is not well understood, but manifests itself in several examples from the wiki, including [[Concrete representation]] and [[Tethered modal logic]].\n\n=== Coverage checker checking with functions of type A -> A when A is not subordinate to itself. ===\n\nIf the coverage check, when expanding cases comes upon a term that might depend on a formal \nparameter of the same type, it will require a case that handles such a function, even if the\ntype in question in not subordinate to itself.  Such a case normally cannot be written because of freezing.\n(Example to come later).\n\n=== Higher-Order Blocks ===\n\nAgain, I learned of this problem from Rob Simmons:\nIf a \"block\" includes a higher order function, then the coverage checker doesn't work.\nNo example yet.  This bug is considered low-priority.\n\n=== Not a block ===\n\nIf you use the name of something that is not a block\nwhere a block is expected:\n\n    %worlds (nat) (foo _ _ _).\n\nthen there is an \"uncaught exception\" rather than a helpful error message.\n\n=== Theorem Prover Nontermination ===\n\nThe prover sometimes fails to terminate.\nSee example in \n[http://cs.nju.edu.cn/boyland/proof/using-twelf.html my tutorial] (Section 2.3)\nI have copied it here for completeness:\n<twelf>\n%%% Example of Twelf from \"using-twelf\" paper\n\nterm : type.\n\ntrue : term.\nfalse : term.\nif : term -> term -> term -> term.\nzero : term.\n\nty : type.\n\nbool : ty.\nint : ty.\n\n\n%% relations\nis_value : term -> type.\n\nis_value/true : is_value true.\nis_value/false : is_value false.\nis_value/zero : is_value zero.\n\neval : term -> term -> type.\n\neval/if_true : eval (if true X _) X.\neval/if_false : eval (if false _ X) X.\neval/if : eval (if E E1 E2) (if E' E1 E2)\n    <- eval E E'.\n\nnot_stuck : term -> type.\n\nnot_stuck/value : not_stuck X <- is_value X.\nnot_stuck/eval : not_stuck X <- eval X X'.\n\nof : term -> ty -> type.\n\nof/true : of true bool.\nof/false : of false bool.\nof/zero : of zero int.\nof/if : of X bool -> of Y T -> of Z T -> of (if X Y Z) T.\n\n%% theorems\n\nprogress : (of X T) -> (not_stuck X) -> type.\n%mode progress +D1 -D2.\n%prove 2 T (progress T _).\n</twelf>\nThe theorem prover is deprecated in Twelf, and fixing this bug is not required before producing\na new release of Twelf.\n\n== Challenges ==\n\n=== Is HOAS countable? ===\n\nA challenge: define a mapping from HOAS to the natural numbers (or equivalently to a nameless term representation) and then prove that the mapping is isomorphic ''using Twelf''.  For details and sample mappings, see question on the Twelf Elf page: [[Talk:Ask_Twelf_Elf#Mapping_HOAS_isomorphically_to_the_natural_numbers]].\n\nUpdate: [[User:Rsimmons|Rob]] has posted a solution ([[Concrete_representation]]) that defines a mapping between HOAS and nameless terms and proves that it is bijective.\n(I asked for an \"isomorphic\" mapping between HOAS and natural numbers, but should have said \"bijective mapping.\")  Thanks Rob!\n\nMy personal challenge is to write a general technique for generating bijective mappings (with proof) between many kinds of terms and natural numbers.\nIn general, of course, this would be undecidable. I hope only to handle cases that are used as AST types.\n\nUpdate: I did it for a simple HOAS before POPL 2008\n(see [[HOAS nat bijection]]), and in May 2008, finished a more complex\nexample [[Indexed HOAS nat bijection]] that handle an indexed term language.\n\nSuccess: I have implemented a bijection generator. See http://www.cs.uwm.edu/~boyland/papers/map-natural.html\n\n:: Cool! — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 02:08, 12 December 2010 (EST)"
          },
          "sha1": "9wq5y36ygviznmc40e8fkz9lrjikgek"
        }
      },
      {
        "title": "User:Carsten",
        "ns": 2,
        "id": 2380,
        "revision": {
          "id": 6797,
          "parentid": 6796,
          "timestamp": "2013-04-18T21:23:30Z",
          "contributor": {
            "username": "Carsten",
            "id": 38
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 17,
            "#text": "[[CADE_Tutorial]]"
          },
          "sha1": "jhp7ah4ef9fkiz1lvs9xlr0mnksfra3"
        }
      },
      {
        "title": "User:Ccasin",
        "ns": 2,
        "id": 2001,
        "revision": {
          "id": 4859,
          "timestamp": "2007-10-02T19:38:23Z",
          "contributor": {
            "username": "Ccasin",
            "id": 25
          },
          "comment": "New page: I'm Chris Casinghino, a grad student at U Penn, formerly of CMU.",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 64,
            "#text": "I'm Chris Casinghino, a grad student at U Penn, formerly of CMU."
          },
          "sha1": "8gww4sjnb0w7zh7sdmovirm35udluq0"
        }
      },
      {
        "title": "User:Cmartens",
        "ns": 2,
        "id": 2080,
        "revision": {
          "id": 8185,
          "parentid": 8184,
          "timestamp": "2017-01-23T02:17:06Z",
          "contributor": {
            "username": "Boyland",
            "id": 17
          },
          "minor": null,
          "comment": "Reverted edits by [[Special:Contributions/DorothySwomo|DorothySwomo]] ([[User talk:DorothySwomo|talk]]) to last revision by [[User:Cmartens|Cmartens]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 68,
            "#text": "Tutorial Sunday, Oct 17, 2010.\n\n[[TAT/plus.elf]]\n\n[[TAT/church.elf]]"
          },
          "sha1": "6qolszqzmhwvgnzm8lnbmo6rh5yvgh0"
        }
      },
      {
        "title": "User:Crary",
        "ns": 2,
        "id": 1745,
        "revision": {
          "id": 3000,
          "timestamp": "2006-10-20T19:02:52Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 71,
            "#text": "'''Karl Crary''''s [http://www.cs.cmu.edu/~crary/ home page] is at CMU."
          },
          "sha1": "dse3xjjfdw9v9rldys1e04su80ia1sb"
        }
      },
      {
        "title": "User:DanielKLee",
        "ns": 2,
        "id": 1438,
        "revision": {
          "id": 2057,
          "parentid": 1738,
          "timestamp": "2006-09-28T03:38:03Z",
          "contributor": {
            "username": "DanielKLee",
            "id": 5
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 615,
            "#text": "2nd (as of Fall 2006) year PhD student at CMU. More info at [http://www.cs.cmu.edu/~dklee my homepage]. I'm lucky enough that my research heavily involves formalization and metatheorem proving in Twelf. Among other things, I try to contribute interesting/advanced examples to the Twelf wiki. With the help of the other wiki elves, these examples become informative ''and'' human consumable. I've seen and fought a number of strange and challenging Twelf metatheorem proving related beasts in my travels, so if you've got questions or requests make a note in [[User talk:DanielKLee]] or [[The Twelf Project: To do]]."
          },
          "sha1": "rxxm2p5cj2okgpadcny7i44ataz87v3"
        }
      },
      {
        "title": "User:Drl",
        "ns": 2,
        "id": 1751,
        "revision": {
          "id": 6055,
          "parentid": 4629,
          "timestamp": "2010-03-01T16:10:09Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 652,
            "#text": "My name is Dan Licata.  I'm a PhD student at CMU.  Here's my [http://www.cs.cmu.edu/~drl/ Web site].\n\nSometimes, I get the urge to write introductions to LF and Twelf.  The second time this happened, it resulted in a [http://www.cs.cmu.edu/~drl/pubs/hl07mechanizing/hl07mechanizing.pdf journal article].  The first time this happened, it resulted in a very chatty tutorial, which, the third time this happened, turned into [[Proving metatheorems with Twelf]].\n\nI also use Twelf regularly in my research; see the page on [[research projects using Twelf]] or visit my Web site for some links.\n\nRandom Bits of Twelf Code:\n* [[Modally Propositional Logic]]"
          },
          "sha1": "5qsjqllq4acw9dnzt1vleyiduxhgjst"
        }
      },
      {
        "title": "User:Hdeyoung",
        "ns": 2,
        "id": 2195,
        "revision": {
          "id": 5988,
          "parentid": 5940,
          "timestamp": "2009-04-24T00:12:52Z",
          "contributor": {
            "username": "Hdeyoung",
            "id": 47
          },
          "minor": null,
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 54,
            "#text": "Henry's user page.\n\n* [[User:Hdeyoung/monweakfoc.elf]]"
          },
          "sha1": "jeaxm61qk3a4bl9yuih5dlkf4chgort"
        }
      },
      {
        "title": "User:Hdeyoung/monweakfoc.elf",
        "ns": 2,
        "id": 2211,
        "revision": {
          "id": 5987,
          "timestamp": "2009-04-24T00:07:21Z",
          "contributor": {
            "username": "Hdeyoung",
            "id": 47
          },
          "comment": "Completeness of monadic weak focusing",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 30710,
            "#text": "%{\nCompleteness\n}%\n\npol : type.  %name pol S.\n\npos : pol.\nneg : pol. \n\n\n\nsort : type.  %name sort S.\n\nprin : sort.\n\n%block sort-block : block {s : sort}.\n\n\n\nterm : sort -> type.  %name term T x.\n\n%block term-block : some {S : sort} block {x : term S}.\n\n\n\natm : pol -> type.  %name atm P.\n\n%block atm-block : some {S : pol} block {p : atm S}.\n\n\n\natm-eq : atm S -> atm S -> type.\n\natm-eq/refl : atm-eq P+- P+-.\n\n\n\nprop : pol -> type.  %name prop A.\n\natom : atm S -> prop S.\ntensor : prop pos -> prop pos -> prop pos.\none : prop pos. \n% exists : {S : sort} (term S -> prop pos) -> prop pos.\ndown : prop neg -> prop pos.\nlolli : prop pos -> prop neg -> prop neg.\n% forall : {S : sort} (term S -> prop neg) -> prop neg.\nmonad : prop pos -> prop neg.\nsays : term prin -> prop pos -> prop neg.\n\n\n\nprop-eq : prop S -> prop S -> type.\n\nprop-eq/refl : prop-eq A+- A+-.\n\n\n\nprop-resp-atm-eq : {A+- : atm S -> prop S'} atm-eq P1+- P2+- -> prop-eq (A+- P1+-) (A+- P2+-) -> type.\n%mode prop-resp-atm-eq +A+- +Deq -Deq'.\n\n- : prop-resp-atm-eq A+- atm-eq/refl prop-eq/refl.\n\n%worlds (sort-block | term-block | atm-block) (prop-resp-atm-eq _ _ _).\n%total {} (prop-resp-atm-eq _ _ _).\n\n\n\nprop-eq-trans : prop-eq A+- B+- -> prop-eq B+- C+- -> prop-eq A+- C+- -> type.\n%mode prop-eq-trans +Deq1 +Deq2 -Deq3.\n\n- : prop-eq-trans prop-eq/refl prop-eq/refl prop-eq/refl.\n\n%worlds (sort-block | term-block | atm-block) (prop-eq-trans _ _ _). \n%total {} (prop-eq-trans _ _ _).\n\n\nprop-resp-prop-eq : {A+- : prop S -> prop S'} prop-eq B1+- B2+- -> prop-eq (A+- B1+-) (A+- B2+-) -> type.\n%mode prop-resp-prop-eq +A+- +Deq -Deq'.\n\n- : prop-resp-prop-eq A+- prop-eq/refl prop-eq/refl.\n\n%worlds (sort-block | term-block | atm-block) (prop-resp-prop-eq _ _ _). \n%total {} (prop-resp-prop-eq _ _ _).\n\n\n\nleft : prop pos -> type.  %name left L l.\n\n%block left-block : some {A+ : prop pos} block {l : left A+}.\n\n\n\nleft-resp-prop-eq : left A1+- -> prop-eq A1+- A2+- -> left A2+- -> type.\n%mode left-resp-prop-eq +L +Deq -L'.\n\n- : left-resp-prop-eq L prop-eq/refl L.\n\n%worlds (sort-block | term-block | atm-block | left-block) (left-resp-prop-eq _ _ _).\n%total {} (left-resp-prop-eq _ _ _).\n\n\n\njudgment : type.  %name judgment J.\n\ntrue : prop neg -> judgment.\nlax : prop pos -> judgment.\naffirms : term prin -> prop pos -> judgment.\n\n\n\nconclusion : type.  %name conclusion C.\n\nconclusion/right : judgment -> conclusion.\nconclusion/rfoc : prop pos -> conclusion.\nconclusion/lfoc : prop neg -> judgment -> conclusion.\n\n\n\nconseq : conclusion -> type.  %name conseq D.\n\n%abbrev right : judgment -> type = [j] conseq (conclusion/right j).\n%abbrev rfoc : prop pos -> type = [a+] conseq (conclusion/rfoc a+).\n%abbrev lfoc : prop neg -> judgment -> type = [a-] [j] conseq (conclusion/lfoc a- j).\n\n%block rfoc-block : some {A+ : prop pos} block {rf : rfoc A+}.\n\ninit+ : left (atom P+) -> rfoc (atom P+).\ninit- : lfoc (atom P-) (true (atom P-)).\ntensorR : rfoc A+ -> rfoc B+ -> rfoc (tensor A+ B+).\ntensorL : (left A+ -> left B+ -> right J) -> (left (tensor A+ B+) -> right J).\noneR : rfoc one.\noneL : right J -> (left one -> right J).\n% existsR : {T : term S} rfoc (A+ T) -> rfoc (exists S A+).\n% existsL : ({a : term S} left (A+ a) -> right J) -> (left (exists S A+) -> right J).\ndownR : right (true A-) -> rfoc (down A-).\ndownL : lfoc A- J -> (left (down A-) -> right J).\nlolliR : (left A+ -> right (true B-)) -> right (true (lolli A+ B-)).\nlolliL : rfoc A+ -> lfoc B- J -> lfoc (lolli A+ B-) J.\n% forallR : ({a : term S} right (true (A- a))) -> right (true (forall S A-)).\n% forallL : {T : term S} lfoc (A- T) J -> lfoc (forall S A-) J.\nlaxR : rfoc A+ -> right (lax A+).\nmonadR : right (lax A+) -> right (true (monad A+)).\nmonadL : (left A+ -> right (lax C+)) -> lfoc (monad A+) (lax C+). \naffirmsR : rfoc A+ -> right (affirms K A+). \nsaysR : right (affirms K A+) -> right (true (says K A+)).\nsaysL : (left A+ -> right (affirms K C+)) -> lfoc (says K A+) (affirms K C+). \n\n\n\neta+ : {A+} (rfoc A+ -> right J) -> (left A+ -> right J) -> type. \n%mode eta+ +A+ +D -E.\neta- : {A-} ({J} lfoc A- J -> right J) -> right (true A-) -> type.\n%mode eta- +A- +D -E.\n\n- : eta+ (atom P+) \n     (D : rfoc (atom P+) -> right J)\n     ([l : left (atom P+)] D (init+ l)).\n\n- : eta+ (tensor A+ B+)\n     (D : rfoc (tensor A+ B+) -> right J)\n     ([l : left (tensor A+ B+)] tensorL E2 l)\n     <- ({rfb : rfoc B+}\n\t   eta+ A+ ([rfa : rfoc A+] D (tensorR rfa rfb)) (E1 rfb : left A+ -> right J))\n     <- ({la : left A+}\n\t   eta+ B+ ([rfb : rfoc B+] E1 rfb la) (E2 la : left B+ -> right J)).\n\n- : eta+ one\n     (D : rfoc one -> right J)\n     ([l : left one] oneL (D oneR) l).\n\n- : eta+ (down A-)\n     (D : rfoc (down A-) -> right J)\n     ([l : left (down A-)] D (downR (E l)))\n     <- ({l : left (down A-)}\n\t   eta- A- ([j] [lfa : lfoc A- j] downL lfa l) (E l : right (true A-))).\n\n%worlds (sort-block | term-block | atm-block | left-block | rfoc-block) (eta+ _ _ _) (eta- _ _ _).\n%trustme %total (A+ A-) (eta+ A+ _ _) (eta- A- _ _).\n\n\n\ncut+ : {A+} rfoc A+ -> (left A+ -> conseq C) -> conseq C -> type. \n%mode cut+ +A+ +D +E -F.\ncut- : {A-} right (true A-) -> lfoc A- J -> right J -> type. \n%mode cut- +A- +D +E -F.\ncut< : {A-} lfoc B- (true A-) -> lfoc A- J -> lfoc B- J -> type.\n%mode cut< +A- +D +E -F.\ncut+lax : {A+} right (lax A+) -> (left A+ -> right (lax C+)) -> right (lax C+) -> type.\n%mode cut+lax +A+ +D +E -F. \ncut+lax-lfoc : {A+} lfoc B- (lax A+) -> (left A+ -> right (lax C+)) -> lfoc B- (lax C+) -> type.\n%mode cut+lax-lfoc +A+ +D +E -F.\ncut+affirms : {A+} right (affirms K A+) -> (left A+ -> right (affirms K C+)) -> right (affirms K C+) -> type.\n%mode cut+affirms +A+ +D +E -F. \ncut+affirms-lfoc : {A+} lfoc B- (affirms K A+) -> (left A+ -> right (affirms K C+)) -> lfoc B- (affirms K C+) -> type.\n%mode cut+affirms-lfoc +A+ +D +E -F.\n\n%worlds (sort-block | term-block | atm-block | left-block | rfoc-block)\n        (cut+ _ _ _ _)\n        (cut- _ _ _ _)\n        (cut< _ _ _ _)\n        (cut+lax _ _ _ _) (cut+lax-lfoc _ _ _ _)\n        (cut+affirms _ _ _ _) (cut+affirms-lfoc _ _ _ _).\n%trustme %total {(A1+ A2- A3- A4+ A5+ A6+ A7+) [(D1 D2 D3 D4 D5 D6 D7) (E1 E2 E3 E4 E5 E6 E7)]}\n        (cut+ A1+ D1 E1 _)\n        (cut- A2- D2 E2 _)\n        (cut< A3- D3 E3 _)\n        (cut+lax A4+ D4 E4 _) (cut+lax-lfoc A5+ D5 E5 _)\n        (cut+affirms A6+ D6 E6 _) (cut+affirms-lfoc A7+ D7 E7 _).\n\n\n\n\natm' : type.  %name atm' P'. \n\n%block atm'-block : block {p' : atm'}. \n\n\n\nprop' : type.  %name prop' A'.\n\natom' : atm' -> prop'.\ntensor' : prop' -> prop' -> prop'.\none' : prop'.\n% exists' : {S : sort} (term S -> prop') -> prop'. \nlolli' : prop' -> prop' -> prop'.\n% forall' : {S : sort} (term S -> prop') -> prop'.\nmonad' : prop' -> prop'.\nsays' : term prin -> prop' -> prop'.\n\n\n\nhyp : prop' -> type.  %name hyp H h.\n\n%block hyp-block : some {A : prop'} block {h : hyp A}. \n\n\n\njudgment' : type.  %name judgment' J'.\n\njudgment'/true : prop' -> judgment'.\njudgment'/lax : prop' -> judgment'.\njudgment'/affirms : term prin -> prop' -> judgment'.\n\n\n\nconc : judgment' -> type.  %name conc D.\n\n%abbrev true' : prop' -> type = [a] conc (judgment'/true a).\n%abbrev lax' : prop' -> type = [a] conc (judgment'/lax a).\n%abbrev affirms' : term prin -> prop' -> type = [k] [a] conc (judgment'/affirms k a).\n\ninit' : hyp (atom' P) -> true' (atom' P).\ntensor'R : true' A -> true' B -> true' (tensor' A B).\ntensor'L : (hyp A -> hyp B -> conc J') -> (hyp (tensor' A B) -> conc J').\none'R : true' one'.\none'L : conc J' -> (hyp one' -> conc J'). \n% exists'R : {T : term S} true' (A T) -> true' (exists' S A).\n% exists'L : ({a : term S} hyp (A a) -> conc J') -> (hyp (exists' S A) -> conc J').\nlolli'R : (hyp A -> true' B) -> true' (lolli' A B). \nlolli'L : true' A -> (hyp B -> conc J') -> (hyp (lolli' A B) -> conc J'). \n% forall'R : ({a : term S} true' (A a)) -> true' (forall' S A). \n% forall'L : {T : term S} (hyp (A T) -> conc J') -> (hyp (forall' S A) -> conc J'). \nlax'R : true' A -> lax' A.\nmonad'R : lax' A -> true' (monad' A). \nmonad'L : (hyp A -> lax' C) -> (hyp (monad' A) -> lax' C).\naffirms'R : true' A -> affirms' K A.\nsays'R : affirms' K A -> true' (says' K A). \nsays'L : (hyp A -> affirms' K C) -> (hyp (says' K A) -> affirms' K C).\n\n\n\n\nerase-atm : atm S -> atm' -> type.\n\n%block erase-atm-block : some {S : pol}\n\t\t\t block {p : atm S} {p' : atm'} {erase-atm/p : erase-atm p p'}.\n\n%worlds (erase-atm-block) (erase-atm _ _).\n \n\nerase-atm-unique : erase-atm P1+- P -> erase-atm P2+- P -> atm-eq P1+- P2+- -> type.\n%mode erase-atm-unique +E1 +E2 -Deq.\n\n- : erase-atm-unique E E atm-eq/refl.\n\n%worlds (erase-atm-block) (erase-atm-unique _ _ _).\n%total {} (erase-atm-unique _ _ _).\n\n\n\nerase-prop : prop S -> prop' -> type.\n\nerase-prop/atom : erase-prop (atom P+-) (atom' P)\n\t\t   <- erase-atm P+- P.\nerase-prop/tensor : erase-prop (tensor A+ B+) (tensor' A B)\n\t\t     <- erase-prop A+ A\n\t\t     <- erase-prop B+ B.\nerase-prop/one : erase-prop one one'.\n% erase-prop/exists : erase-prop (exists S A+) (exists' S A)\n% \t\t     <- ({a : term S} erase-prop (A+ a) (A a)).\nerase-prop/down : erase-prop (down A-) A\n\t\t   <- erase-prop A- A.\nerase-prop/lolli : erase-prop (lolli A+ B-) (lolli' A B)\n\t\t    <- erase-prop A+ A\n\t\t    <- erase-prop B- B.\n% erase-prop/forall : erase-prop (forall S A-) (forall' S A)\n% \t\t     <- ({a : term S} erase-prop (A- a) (A a)).\nerase-prop/monad : erase-prop (monad A+) (monad' A)\n\t\t    <- erase-prop A+ A.\nerase-prop/says : erase-prop (says K A+) (says' K A)\n\t\t   <- erase-prop A+ A.\n\n%worlds (sort-block | term-block | erase-atm-block) (erase-prop _ _).\n\n\n\nerase-prop-unique : erase-prop A1+- A -> erase-prop A2+- A -> prop-eq A1+- A2+- -> type.\n%mode erase-prop-unique +E1 +E2 -Deq.\n\n- : erase-prop-unique \n     (erase-prop/atom (E : erase-atm P+- P)) \n     (erase-prop/atom E) \n     prop-eq/refl.\n\n- : erase-prop-unique \n     (erase-prop/tensor (E12 : erase-prop B1+ B) (E11 : erase-prop A1+ A))\n     (erase-prop/tensor (E22 : erase-prop B2+ B) (E21 : erase-prop A2+ A))\n     Deq \n     <- erase-prop-unique E11 E21 (Deq1 : prop-eq A1+ A2+)\n     <- erase-prop-unique E12 E22 (Deq2 : prop-eq B1+ B2+)\n     <- prop-resp-prop-eq ([a1+] tensor a1+ B1+) Deq1 (Deq3 : prop-eq (tensor A1+ B1+) (tensor A2+ B1+))\n     <- prop-resp-prop-eq ([b1+] tensor A2+ b1+) Deq2 (Deq4 : prop-eq (tensor A2+ B1+) (tensor A2+ B2+))\n     <- prop-eq-trans Deq3 Deq4 (Deq : prop-eq (tensor A1+ B1+) (tensor A2+ B2+)).\n\n- : erase-prop-unique erase-prop/one erase-prop/one prop-eq/refl.\n\n- : erase-prop-unique \n     (erase-prop/down (E1 : erase-prop A1- A))\n     (erase-prop/down (E2 : erase-prop A2- A))\n     Deq'\n     <- erase-prop-unique E1 E2 (Deq : prop-eq A1- A2-)\n     <- prop-resp-prop-eq ([a-] down a-) Deq (Deq' : prop-eq (down A1-) (down A2-)).\n\n- : erase-prop-unique\n     (erase-prop/lolli (E12 : erase-prop B1- B) (E11 : erase-prop A1+ A))\n     (erase-prop/lolli (E22 : erase-prop B2- B) (E21 : erase-prop A2+ A))\n     Deq \n     <- erase-prop-unique E11 E21 (Deq1 : prop-eq A1+ A2+)\n     <- erase-prop-unique E12 E22 (Deq2 : prop-eq B1- B2-)\n     <- prop-resp-prop-eq ([a1+] lolli a1+ B1-) Deq1 (Deq3 : prop-eq (lolli A1+ B1-) (lolli A2+ B1-))\n     <- prop-resp-prop-eq ([b1-] lolli A2+ b1-) Deq2 (Deq4 : prop-eq (lolli A2+ B1-) (lolli A2+ B2-))\n     <- prop-eq-trans Deq3 Deq4 (Deq : prop-eq (lolli A1+ B1-) (lolli A2+ B2-)).\n\n- : erase-prop-unique \n     (erase-prop/monad (E1 : erase-prop A1+ A))\n     (erase-prop/monad (E2 : erase-prop A2+ A))\n     Deq'\n     <- erase-prop-unique E1 E2 (Deq : prop-eq A1+ A2+)\n     <- prop-resp-prop-eq ([a+] monad a+) Deq (Deq' : prop-eq (monad A1+) (monad A2+)).\n\n- : erase-prop-unique \n     (erase-prop/says (E1 : erase-prop A1+ A))\n     (erase-prop/says (E2 : erase-prop A2+ A))\n     Deq'\n     <- erase-prop-unique E1 E2 (Deq : prop-eq A1+ A2+)\n     <- prop-resp-prop-eq ([a+] says K a+) Deq (Deq' : prop-eq (says K A1+) (says K A2+)).\n\n%worlds (sort-block | term-block | erase-atm-block) (erase-prop-unique _ _ _).\n%total E1 (erase-prop-unique E1 _ _).\n\n\n\nerase-judgment : judgment -> judgment' -> type. \n\nerase-judgment/true : erase-judgment (true A-) (judgment'/true A)\n\t\t       <- erase-prop A- A.\nerase-judgment/lax : erase-judgment (lax A+) (judgment'/lax A)\n\t\t      <- erase-prop A+ A.\nerase-judgment/affirms : erase-judgment (affirms K A+) (judgment'/affirms K A)\n\t\t\t  <- erase-prop A+ A.\n\n\n\n\n% adm-forallL : (left (down (A- T)) -> right J) -> (left (down (forall S A-)) -> right J) -> type.\n% %mode adm-forallL +D -E.\n\n% %worlds (sort-block | term-block | atm-block | left-block | rfoc-block) (adm-forallL _ _).\n% %trustme %total D (adm-forallL D _).\n\n\n\ncmp-conc : conc J' -> erase-judgment J J' -> right J -> type.\n%mode cmp-conc +D +E -F.\ncmp-lax : true' A -> erase-prop A+ A -> right (lax A+) -> type.\n%mode cmp-lax +D +E -F.\ncmp-affirms : true' A -> erase-prop A+ A -> right (affirms K A+) -> type.\n%mode +{A} +{A+} +{K} +{D : true' A} +{E : erase-prop A+ A} -{F : right (affirms K A+)} (cmp-affirms D E F).\ncmp-lolli : true' A -> erase-prop A+ A -> (left (down B-) -> right J) -> (left (down (lolli A+ B-)) -> right J) -> type. \n%mode cmp-lolli +D +E +F -G.\ncmp-hyp : hyp A -> erase-prop A+ A -> left A+ -> type.\n%mode cmp-hyp  +H -E -L.\ncmp-hyp+ : hyp (atom' P) -> erase-prop A+ (atom' P) -> left A+ -> type.\n%mode cmp-hyp+ +H +E -L.\n\n- : cmp-hyp+ \n     (H : hyp (atom' P))\n     (E : erase-prop A+ (atom' P))\n     L'\n     <- cmp-hyp H (E' : erase-prop A'+ (atom' P)) (L : left A'+)\n     <- erase-prop-unique E' E (Deq : prop-eq A'+ A+)\n     <- left-resp-prop-eq L Deq (L' : left A+).\n\n\n- : cmp-conc\n     (init' (H : hyp (atom' P)))\n     (erase-judgment/true (erase-prop/atom (E : erase-atm P- P)))\n     (downL init- L)\n     <- cmp-hyp+ H (erase-prop/down (erase-prop/atom E)) L.\n\n- : cmp-conc\n     (tensor'L (D : hyp A -> hyp B -> conc J') (H : hyp (tensor' A B)))\n     (E : erase-judgment J J')\n     (tensorL F L)\n     <- cmp-hyp H (erase-prop/tensor (E2 : erase-prop B+ B) (E1 : erase-prop A+ A)) (L : left (tensor A+ B+))\n     <- ({ha : hyp A} {la : left A+} cmp-hyp ha E1 la \n\t   -> {hb : hyp B} {lb : left B+} cmp-hyp hb E2 lb\n\t   -> cmp-conc (D ha hb) E (F la lb : right J)).\n\n- : cmp-conc\n     (one'L (D : conc J') (H : hyp one'))\n     (E : erase-judgment J J')\n     (oneL F L)\n     <- cmp-hyp H erase-prop/one (L : left one)\n     <- cmp-conc D E (F : right J).\n \n% - : cmp-conc\n%      (exists'L (D : {a : term S} hyp (A a) -> conc J') (H : hyp (exists' S A)))\n%      (E : erase-judgment J J')\n%      (existsL F L)\n%     <- cmp-hyp H (erase-prop/exists (E1 : {x : term S} erase-prop (A+ x) (A x))) (L : left (exists S A+))\n%     <- ({a : term S}\n%\t   {ha : hyp (A a)} {la : left (A+ a)} cmp-hyp ha (E1 a) la\n%\t   -> cmp-conc (D a ha) E (F a la : right J)).\n\n- : cmp-conc\n     (lolli'R (D : hyp A -> true' B))\n     (erase-judgment/true (erase-prop/lolli (E2 : erase-prop B- B) (E1 : erase-prop A+ A)))\n     (lolliR F)\n     <- ({ha : hyp A} {la : left A+} cmp-hyp ha E1 la -> cmp-conc (D ha) (erase-judgment/true E2) (F la : right (true B-))).\n\n- : cmp-conc\n     (lolli'L (D1 : true' A) (D2 : hyp B -> conc J') (H : hyp (lolli' A B)))\n     (E : erase-judgment J J')\n     (F L)\n     <- cmp-hyp H (erase-prop/down (erase-prop/lolli (E2 : erase-prop B- B) (E1 : erase-prop A+ A))) (L : left (down (lolli A+ B-)))\n     <- ({hb : hyp B} {lb : left (down B-)} cmp-hyp hb (erase-prop/down E2) lb -> cmp-conc (D2 hb) E (F2 lb : right J))\n     <- cmp-lolli D1 E1 F2 (F : left (down (lolli A+ B-)) -> right J).\n\n% - : cmp-conc\n%     (forall'R (D : {a: term S} true' (A a)))\n%     (erase-judgment/true (erase-prop/forall (E : {x : term S} erase-prop (A- x) (A x))))\n%     (forallR F)\n%     <- ({a: term S} cmp-conc (D a) (erase-judgment/true (E a)) (F a)).\n\n% - : cmp-conc\n%     (forall'L (T : term S) (D : hyp (A T) -> conc J') (H : hyp (forall' S A)))\n%     (E : erase-judgment J J')\n%     (F' L)\n%     <- cmp-hyp H (erase-prop/down (erase-prop/forall (E1 : {x : term S} erase-prop (A- x) (A x)))) (L : left (down (forall S A-))) \n%     <- ({ha : hyp (A T)} {la : left (down (A- T))} cmp-hyp ha (erase-prop/down (E1 T)) la -> cmp-conc (D ha) E (F la : right J))\n%     <- adm-forallL F (F' : left (down (forall S A-)) -> right J).\n\n- : cmp-conc (lax'R (D : true' A)) (erase-judgment/lax (E : erase-prop A+ A)) F\n     <- cmp-lax D E (F : right (lax A+)).\n\n- : cmp-conc\n     (monad'R (D : lax' A))\n     (erase-judgment/true (erase-prop/monad (E : erase-prop A+ A)))\n     (monadR F)\n     <- cmp-conc D (erase-judgment/lax E) F.\n\n- : cmp-conc\n     (monad'L (D : hyp A -> lax' C) (H : hyp (monad' A)))\n     (erase-judgment/lax (E : erase-prop C+ C))\n     (downL (monadL F) L)\n     <- cmp-hyp H (erase-prop/down (erase-prop/monad (E1 : erase-prop A+ A))) (L : left (down (monad A+)))\n     <- ({ha : hyp A} {la : left A+} cmp-hyp ha E1 la\n\t   -> cmp-conc (D ha) (erase-judgment/lax E) (F la : right (lax C+))).\n\n- : cmp-conc\n     (affirms'R (D : true' A)) \n     (erase-judgment/affirms (E : erase-prop A+ A))\n     F\n     <- cmp-affirms D E (F : right (affirms K A+)).\n\n- : cmp-conc\n     (says'R (D : affirms' K A))\n     (erase-judgment/true (erase-prop/says (E : erase-prop A+ A)))\n     (saysR F)\n     <- cmp-conc D (erase-judgment/affirms E) F.\n\n- : cmp-conc\n     (says'L (D : hyp A -> affirms' K C) (H : hyp (says' K A)))\n     (erase-judgment/affirms (E : erase-prop C+ C))\n     (downL (saysL F) L)\n     <- cmp-hyp H (erase-prop/down (erase-prop/says (E1 : erase-prop A+ A))) (L : left (down (says K A+)))\n     <- ({ha : hyp A} {la : left A+} cmp-hyp ha E1 la\n\t   -> cmp-conc (D ha) (erase-judgment/affirms E) (F la : right (affirms K C+))).\n\n\n- : cmp-lax\n     (init' (H : hyp (atom' P)))\n     (erase-prop/atom (E : erase-atm P+ P))\n     (laxR (init+ L))\n     <- cmp-hyp+ H (erase-prop/atom E) (L : left (atom P+)).\n\n- : cmp-lax\n     (tensor'R (D1 : true' A) (D2 : true' B))\n     (erase-prop/tensor (E2 : erase-prop B+ B) (E1 : erase-prop A+ A))\n     F6\n     <- cmp-lax D1 E1 (F1 : right (lax A+)) \n     <- cmp-lax D2 E2 (F2 : right (lax B+))\n     <- ({rfa : rfoc A+} eta+ B+ ([rfb : rfoc B+] laxR (tensorR rfa rfb)) (F3 rfa : left B+ -> right (lax (tensor A+ B+))))\n     <- ({lb : left B+} eta+ A+ ([rfa : rfoc A+] F3 rfa lb) (F4 lb : left A+ -> right (lax (tensor A+ B+))))\n     <- ({lb : left B+} cut+lax A+ F1 (F4 lb) (F5 lb : right (lax (tensor A+ B+))))\n     <- cut+lax B+ F2 F5 (F6 : right (lax (tensor A+ B+))).\n\n- : cmp-lax\n     (tensor'L (D : hyp B1 -> hyp B2 -> true' A) (H : hyp (tensor' B1 B2)))\n     (E : erase-prop A+ A)\n     (tensorL F L)\n     <- cmp-hyp H (erase-prop/tensor (E2 : erase-prop B2+ B2) (E1 : erase-prop B1+ B1)) (L : left (tensor B1+ B2+))\n     <- ({hb1 : hyp B1} {lb1 : left B1+} cmp-hyp hb1 E1 lb1 \n\t   -> {hb2 : hyp B2} {lb2 : left B2+} cmp-hyp hb2 E2 lb2\n\t   -> cmp-lax (D hb1 hb2) E (F lb1 lb2 : right (lax A+))).\n\n- : cmp-lax one'R erase-prop/one (laxR oneR).\n\n- : cmp-lax\n     (one'L (D : true' A) (H : hyp one'))\n     (E : erase-prop A+ A)\n     (oneL F L)\n     <- cmp-hyp H erase-prop/one (L : left one)\n     <- cmp-lax D E (F : right (lax A+)).\n\n% - : cmp-lax\n%     (exists'R (T : term S) (D : true' (A T)))\n%     (erase-prop/exists (E : {x : term S} erase-prop (A+ x) (A x)))\n%     F3\n%     <- cmp-lax D (E T) (F1 : right (lax (A+ T)))\n%     <- eta+ (A+ T) ([rfa : rfoc (A+ T)] laxR (existsR T rfa)) (F2 : left (A+ T) -> right (lax (exists S A+)))\n%     <- cut+lax (A+ T) F1 F2 (F3 : right (lax (exists S A+))).\n\n% - : cmp-lax\n%     (exists'L (D : {a : term S} hyp (B a) -> true' A) (H : hyp (exists' S B)))\n%     (E : erase-prop A+ A)\n%     (existsL F L)\n%     <- cmp-hyp H (erase-prop/exists (E1 : {x : term S} erase-prop (B+ x) (B x))) (L : left (exists S B+))\n%     <- ({a : term S}\n%\t   {hb : hyp (B a)} {lb : left (B+ a)} cmp-hyp hb (E1 a) lb\n%\t   -> cmp-lax (D a hb) E (F a lb : right (lax A+))).\n\n- : cmp-lax\n     (D : true' A)\n     (erase-prop/down (E : erase-prop A- A))\n     (laxR (downR F))\n     <- cmp-conc D (erase-judgment/true E) (F : right (true A-)).\n\n- : cmp-lax\n     (lolli'L (D1 : true' B1) (D2 : hyp B2 -> true' A) (H : hyp (lolli' B1 B2)))\n     (E : erase-prop A+ A)\n     (F L)\n     <- cmp-hyp H (erase-prop/down (erase-prop/lolli (E2 : erase-prop B2- B2) (E1 : erase-prop B1+ B1))) (L : left (down (lolli B1+ B2-)))\n     <- ({hb2 : hyp B2} {lb2 : left (down B2-)} cmp-hyp hb2 (erase-prop/down E2) lb2 -> cmp-lax (D2 hb2) E (F2 lb2 : right (lax A+)))\n     <- cmp-lolli D1 E1 F2 (F : left (down (lolli B1+ B2-)) -> right (lax A+)).\n\n% - : cmp-lax\n%     (forall'L (T : term S) (D : hyp (B T) -> true' A) (H : hyp (forall' S B)))\n%     (E : erase-prop A+ A)\n%     (F' L)\n%     <- cmp-hyp H (erase-prop/down (erase-prop/forall (E1 : {x : term S} erase-prop (B- x) (B x)))) (L : left (down (forall S B-))) \n%     <- ({hb : hyp (B T)} {lb : left (down (B- T))} cmp-hyp hb (erase-prop/down (E1 T)) lb -> cmp-lax (D hb) E (F lb : right (lax A+)))\n%     <- adm-forallL F (F' : left (down (forall S B-)) -> right (lax A+)).\n\n\n- : cmp-affirms \n     (init' (H : hyp (atom' P)))\n     (erase-prop/atom (E : erase-atm P+ P))\n     (affirmsR (init+ L))\n     <- cmp-hyp+ H (erase-prop/atom E) (L : left (atom P+)).\n\n- : cmp-affirms\n     (tensor'R (D1 : true' A) (D2 : true' B))\n     (erase-prop/tensor (E2 : erase-prop B+ B) (E1 : erase-prop A+ A))\n     F6\n     <- cmp-affirms D1 E1 (F1 : right (affirms K A+)) \n     <- cmp-affirms D2 E2 (F2 : right (affirms K B+))\n     <- ({rfa : rfoc A+} eta+ B+ ([rfb : rfoc B+] affirmsR (tensorR rfa rfb)) (F3 rfa : left B+ -> right (affirms K (tensor A+ B+))))\n     <- ({lb : left B+} eta+ A+ ([rfa : rfoc A+] F3 rfa lb) (F4 lb : left A+ -> right (affirms K (tensor A+ B+))))\n     <- ({lb : left B+} cut+affirms A+ F1 (F4 lb) (F5 lb : right (affirms K (tensor A+ B+))))\n     <- cut+affirms B+ F2 F5 (F6 : right (affirms K (tensor A+ B+))).\n\n- : cmp-affirms\n     (tensor'L (D : hyp B1 -> hyp B2 -> true' A) (H : hyp (tensor' B1 B2)))\n     (E : erase-prop A+ A)\n     (tensorL F L)\n     <- cmp-hyp H (erase-prop/tensor (E2 : erase-prop B2+ B2) (E1 : erase-prop B1+ B1)) (L : left (tensor B1+ B2+))\n     <- ({hb1 : hyp B1} {lb1 : left B1+} cmp-hyp hb1 E1 lb1 \n\t   -> {hb2 : hyp B2} {lb2 : left B2+} cmp-hyp hb2 E2 lb2\n\t   -> cmp-affirms (D hb1 hb2) E (F lb1 lb2 : right (affirms K A+))).\n\n- : cmp-affirms one'R erase-prop/one (affirmsR oneR).\n\n- : cmp-affirms\n     (one'L (D : true' A) (H : hyp one'))\n     (E : erase-prop A+ A)\n     (oneL F L)\n     <- cmp-hyp H erase-prop/one (L : left one)\n     <- cmp-affirms D E (F : right (affirms K A+)).\n\n% - : cmp-affirms\n%     (exists'R (T : term S) (D : true' (A T)))\n%     (erase-prop/exists (E : {x : term S} erase-prop (A+ x) (A x)))\n%     F3\n%     <- cmp-affirms D (E T) (F1 : right (affirms K (A+ T)))\n%     <- eta+ (A+ T) ([rfa : rfoc (A+ T)] affirmsR (existsR T rfa)) (F2 : left (A+ T) -> right (affirms K (exists S A+)))\n%     <- cut+affirms (A+ T) F1 F2 (F3 : right (affirms K (exists S A+))).\n\n% - : cmp-affirms\n%     (exists'L (D : {a : term S} hyp (B a) -> true' A) (H : hyp (exists' S B)))\n%     (E : erase-prop A+ A)\n%     (existsL F L)\n%     <- cmp-hyp H (erase-prop/exists (E1 : {x : term S} erase-prop (B+ x) (B x))) (L : left (exists S B+))\n%     <- ({a : term S}\n%\t   {hb : hyp (B a)} {lb : left (B+ a)} cmp-hyp hb (E1 a) lb\n%\t   -> cmp-affirms (D a hb) E (F a lb : right (affirms K A+))).\n\n- : cmp-affirms\n     (D : true' A)\n     (erase-prop/down (E : erase-prop A- A))\n     (affirmsR (downR F))\n     <- cmp-conc D (erase-judgment/true E) (F : right (true A-)).\n\n- : cmp-affirms\n     (lolli'L (D1 : true' B1) (D2 : hyp B2 -> true' A) (H : hyp (lolli' B1 B2)))\n     (E : erase-prop A+ A)\n     (F L)\n     <- cmp-hyp H (erase-prop/down (erase-prop/lolli (E2 : erase-prop B2- B2) (E1 : erase-prop B1+ B1))) (L : left (down (lolli B1+ B2-)))\n     <- ({hb2 : hyp B2} {lb2 : left (down B2-)} cmp-hyp hb2 (erase-prop/down E2) lb2 -> cmp-affirms (D2 hb2) E (F2 lb2 : right (affirms K A+)))\n     <- cmp-lolli D1 E1 F2 (F : left (down (lolli B1+ B2-)) -> right (affirms K A+)).\n\n% - : cmp-affirms\n%     (forall'L (T : term S) (D : hyp (B T) -> true' A) (H : hyp (forall' S B)))\n%     (E : erase-prop A+ A)\n%     (F' L)\n%     <- cmp-hyp H (erase-prop/down (erase-prop/forall (E1 : {x : term S} erase-prop (B- x) (B x)))) (L : left (down (forall S B-))) \n%     <- ({hb : hyp (B T)} {lb : left (down (B- T))} cmp-hyp hb (erase-prop/down (E1 T)) lb -> cmp-affirms (D hb) E (F lb : right (affirms K A+)))\n%     <- adm-forallL F (F' : left (down (forall S B-)) -> right (affirms K A+)).\n\n\n- : cmp-lolli\n     (init' (H : hyp (atom' P)))\n     (erase-prop/atom (E : erase-atm P+ P))\n     (F : left (down B-) -> right J)\n     G2\n     <- cmp-hyp+ H (erase-prop/atom E) (L : left (atom P+))\n     <- ({l : left (down (lolli (atom P+) B-))}\n\t   eta- B- ([j] [lfb : lfoc B- j] downL (lolliL (init+ L) lfb) l) (G1 l : right (true B-)))\n     <- ({l : left (down (lolli (atom P+) B-))}\n\t   cut+ (down B-) (downR (G1 l)) F (G2 l : right J)). \n\n- : cmp-lolli\n     (tensor'R (D1 : true' A1) (D2 : true' A2))\n     (erase-prop/tensor (E2 : erase-prop A2+ A2) (E1 : erase-prop A1+ A1))\n     (F : left (down B-) -> right J)\n     G6\n     <- cmp-lolli D2 E2 F (G1 : left (down (lolli A2+ B-)) -> right J) \n     <- cmp-lolli D1 E1 G1 (G2 : left (down (lolli A1+ (lolli A2+ B-))) -> right J)\n     <- ({l : left (down (lolli (tensor A1+ A2+) B-))} {rfa1 : rfoc A1+} {rfa2 : rfoc A2+}\n\t   eta- B- ([j] [lfb : lfoc B- j] downL (lolliL (tensorR rfa1 rfa2) lfb) l) (G3 l rfa1 rfa2 : right (true B-)))\n     <- ({l : left (down (lolli (tensor A1+ A2+) B-))} {rfa1 : rfoc A1+}\n\t   eta+ A2+ ([rfa2 : rfoc A2+] G3 l rfa1 rfa2) (G4 l rfa1 : left A2+ -> right (true B-)))\n     <- ({l : left (down (lolli (tensor A1+ A2+) B-))} {la2 : left A2+}\n\t   eta+ A1+ ([rfa1 : rfoc A1+] G4 l rfa1 la2) (G5 l la2 : left A1+ -> right (true B-)))\n     <- ({l : left (down (lolli (tensor A1+ A2+) B-))}\n\t   cut+ (down (lolli A1+ (lolli A2+ B-))) (downR (lolliR ([la1 : left A1+] lolliR ([la2 : left A2+] G5 l la2 la1)))) G2 (G6 l : right J)).\n\n- : cmp-lolli\n     (tensor'L (D : hyp B1 -> hyp B2 -> true' A) (H : hyp (tensor' B1 B2)))\n     (E : erase-prop A+ A)\n     (F : left (down B-) -> right J)\n     ([l : left (down (lolli A+ B-))] tensorL ([lb1 : left B1+] [lb2 : left B2+] G lb1 lb2 l) L)\n     <- cmp-hyp H (erase-prop/tensor (E2 : erase-prop B2+ B2) (E1 : erase-prop B1+ B1)) (L : left (tensor B1+ B2+))\n     <- ({hb1 : hyp B1} {lb1 : left B1+} cmp-hyp hb1 E1 lb1 \n\t   -> {hb2 : hyp B2} {lb2 : left B2+} cmp-hyp hb2 E2 lb2\n\t   -> cmp-lolli (D hb1 hb2) E F (G lb1 lb2 : left (down (lolli A+ B-)) -> right J)).\n\n- : cmp-lolli \n     one'R\n     erase-prop/one\n     (F : left (down B-) -> right J)\n     G2\n     <- ({l : left (down (lolli one B-))}\n\t   eta- B- ([j] [lfb : lfoc B- j] downL (lolliL oneR lfb) l) (G1 l : right (true B-)))\n     <- ({l : left (down (lolli one B-))} \n\t   cut+ (down B-) (downR (G1 l)) F (G2 l : right J)).\n\n- : cmp-lolli\n     (one'L (D : true' A) (H : hyp one'))\n     (E : erase-prop A+ A)\n     (F : left (down B-) -> right J)\n     ([l : left (down (lolli A+ B-))] oneL (G l) L)\n     <- cmp-hyp H erase-prop/one (L : left one)\n     <- cmp-lolli D E F (G : left (down (lolli A+ B-)) -> right J).\n\n% - : cmp-lolli\n%     (exists'R (T : term S) (D : true' (A T)))\n%     (erase-prop/exists (E : {x : term S} erase-prop (A+ x) (A x)))\n%     (F : left (down B-) -> right J)\n%     G4\n%     <- cmp-lolli D (E T) F (G1 : left (down (lolli (A+ T) B-)) -> right J) \n%     <- ({l : left (down (lolli (exists S A+) B-))} {rfa : rfoc (A+ T)}\n%\t   eta- B- ([j] [lfb : lfoc B- j] downL (lolliL (existsR T rfa) lfb) l) (G2 l rfa : right (true B-)))\n%     <- ({l : left (down (lolli (exists S A+) B-))}\n%\t   eta+ (A+ T) ([rfa : rfoc (A+ T)] G2 l rfa) (G3 l : left (A+ T) -> right (true B-)))\n%     <- ({l : left (down (lolli (exists S A+) B-))}\n%\t   cut+ (down (lolli (A+ T) B-)) (downR (lolliR ([la : left (A+ T)] G3 l la))) G1 (G4 l : right J)).\n\n% - : cmp-lolli\n%     (exists'L (D : {a : term S} hyp (B1 a) -> true' A) (H : hyp (exists' S B1)))\n%     (E : erase-prop A+ A)\n%     (F : left (down B-) -> right J)\n%     ([l : left (down (lolli A+ B-))] existsL ([a : term S] [lb1 : left (B1+ a)] G a lb1 l) L)\n%     <- cmp-hyp H (erase-prop/exists (E1 : {x : term S} erase-prop (B1+ x) (B1 x))) (L : left (exists S B1+))\n%     <- ({a : term S}\n%\t   {hb1 : hyp (B1 a)} {lb1 : left (B1+ a)} cmp-hyp hb1 (E1 a) lb1\n%\t   -> cmp-lolli (D a hb1) E F (G a lb1 : left (down (lolli A+ B-)) -> right J)).\n\n- : cmp-lolli\n     (D : true' A)\n     (erase-prop/down (E : erase-prop A- A))\n     (F : left (down B-) -> right J)\n     G3\n     <- cmp-conc D (erase-judgment/true E) (G1 : right (true A-))\n     <- ({l : left (down (lolli (down A-) B-))}\n\t   eta- B- ([j] [lfb : lfoc B- j] downL (lolliL (downR G1) lfb) l) (G2 l : right (true B-)))\n     <- ({l : left (down (lolli (down A-) B-))}\n\t   cut+ (down B-) (downR (G2 l)) F (G3 l : right J)).\n\n- : cmp-lolli\n     (lolli'L (D1 : true' B1) (D2 : hyp B2 -> true' A) (H : hyp (lolli' B1 B2)))\n     (E : erase-prop A+ A)\n     (F : left (down B-) -> right J)\n     ([l : left (down (lolli A+ B-))] G2 l L)\n     <- cmp-hyp H (erase-prop/down (erase-prop/lolli (E2 : erase-prop B2- B2) (E1 : erase-prop B1+ B1))) (L : left (down (lolli B1+ B2-)))\n     <- ({hb2 : hyp B2} {lb2 : left (down B2-)} cmp-hyp hb2 (erase-prop/down E2) lb2 \n\t   -> cmp-lolli (D2 hb2) E F (G1 lb2 : left (down (lolli A+ B-)) -> right J))\n     <- ({l : left (down (lolli A+ B-))}\n\t   cmp-lolli D1 E1 ([lb2 : left (down B2-)] G1 lb2 l) (G2 l : left (down (lolli B1+ B2-)) -> right J)).\n\n% - : cmp-lolli\n%     (forall'L (T : term S) (D : hyp (B1 T) -> true' A) (H : hyp (forall' S B1)))\n%     (E : erase-prop A+ A)\n%     (F : left (down B-) -> right J)\n%     ([l : left (down (lolli A+ B-))] G2 l L)\n%     <- cmp-hyp H (erase-prop/down (erase-prop/forall (E1 : {x : term S} erase-prop (B1- x) (B1 x)))) (L : left (down (forall S B1-))) \n%     <- ({hb1 : hyp (B1 T)} {lb1 : left (down (B1- T))} cmp-hyp hb1 (erase-prop/down (E1 T)) lb1\n%\t   -> cmp-lolli (D hb1) E F (G1 lb1 : left (down (lolli A+ B-)) -> right J))\n%     <- ({l : left (down (lolli A+ B-))}\n%\t   adm-forallL ([lb1 : left (down (B1- T))] G1 lb1 l) (G2 l : left (down (forall S B1-)) -> right J)).\n\n\n\n%block cmp-hyp-block : some {A : prop'} {A+ : prop pos} {E : erase-prop A+ A}\n\t\t       block {h : hyp A} {l : left A+} {cmp-hyp/h : cmp-hyp h E l}.\n%worlds (sort-block | term-block | erase-atm-block | cmp-hyp-block | rfoc-block | left-block)\n        (cmp-conc _ _ _)\n        (cmp-lax _ _ _)\n        (cmp-affirms _ _ _)\n        (cmp-lolli _ _ _ _)\n        (cmp-hyp _ _ _)\n        (cmp-hyp+ _ _ _).\n\n%total (D1 D2 D3 D4 H5 H6)\n       (cmp-conc D1 _ _)\n       (cmp-lax D2 _ _)\n       (cmp-affirms D3 _ _)\n       (cmp-lolli D4 _ _ _)\n       (cmp-hyp H5 _ _)\n       (cmp-hyp+ H6 _ _)."
          },
          "sha1": "ak69na5okg0xipero7id2eezkdc6ref"
        }
      },
      {
        "title": "User:JakeD",
        "ns": 2,
        "id": 1467,
        "revision": {
          "id": 1747,
          "timestamp": "2006-09-21T21:43:27Z",
          "contributor": {
            "username": "JakeD",
            "id": 8
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 39,
            "#text": "Hi. I am a 2nd year PhD student at CMU."
          },
          "sha1": "801xuh6b3348oji0akdsk6gr3uy30gp"
        }
      },
      {
        "title": "User:Jcreed",
        "ns": 2,
        "id": 1771,
        "revision": {
          "id": 6670,
          "parentid": 3141,
          "timestamp": "2013-03-23T20:52:14Z",
          "contributor": {
            "username": "Jcreed",
            "id": 9
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 103,
            "#text": "Once upon a time I was a graduate student at CMU. I have a web page at [http://jcreed.org/ jcreed.org]."
          },
          "sha1": "45af6b10tf355q7u8s6mbzx9i63p6cw"
        }
      },
      {
        "title": "User:Jcreed/Sandbox",
        "ns": 2,
        "id": 1699,
        "revision": {
          "id": 6010,
          "parentid": 2699,
          "timestamp": "2009-05-27T16:54:04Z",
          "contributor": {
            "username": "Jcreed",
            "id": 9
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 16308,
            "#text": "<twelf check=\"false\">\npos : type.\nneg : type.\n\n+ :    pos -> pos -> pos.               % binary sums\nvoid : pos.                             % void\n* :    pos -> pos -> pos.               % binary products\nunit : pos.                             % unit\n=> :   pos -> neg -> neg.\t\t% functions\n|| :  neg -> neg -> neg.\t\t% negative disjunction\ndown : neg -> pos.\t\t\t% down shift\nup :   pos -> neg.\t\t\t% up shift\nrec : (pos -> pos) -> pos.              % recursive types\n\\> :   neg -> pos -> pos.\t\t% wtf?\n↑ : pos -> neg -> neg.\n↓ : neg -> neg -> neg.\n%infix right 13 +. %infix right 14 *. %infix right 12 =>.\n%infix right 12 \\>. %infix right 13 ||.\n%infix right 11 ↑. %infix right 10 ↓.\n\nbool = unit + unit.                     % booleans\nnat = rec [X] unit + X.                 % naturals\ntree = [A] rec [X] A + X * X.\t\t% binary trees\nstream = [A] rec [X] unit + A * down (unit => up X).  % lazy lists\nint : pos.                              % machine integers\n\ni : type.\n%mode i.\nz : i.\ns : i -> i.   %prefix 10 s.\nadd : i -> i -> i -> type.  %mode add +M +N -P.\nadd/z : add z N N.\nadd/s : add (s M) N (s P) <- add M N P.\n%worlds () (add M _ _). %total (M) (add M _ _). %unique add +M +N -P.\n\nmult : i -> i -> i -> type.  %mode mult +M +N -P.\nmult/z : mult z N z.\nmult/s : mult (s M) N Q <- mult M N P <- add P N Q.\n%worlds () (mult M _ _). %total (M) (mult M _ _). %unique mult +M +N -P.\n\nframe : type.\n⋅ : frame.\n, : frame -> frame -> frame.\nvhol : neg -> frame.\nkhol : pos -> pos -> frame.\n%infix right 11 ,.\n\npat+ : frame -> pos -> type.\npat- : (pos -> frame) -> neg -> type.\n%mode pat+ -FΔ +A.\n%mode pat- -FΔ +A.\n\nn   : i -> pat+ ⋅ int.\ninl : pat+ FΔ A -> pat+ FΔ (A + B).\ninr : pat+ FΔ B -> pat+ FΔ (A + B).\nu   : pat+ ⋅ unit.\npair : pat+ FΔ₁ A -> pat+ FΔ₂ B -> pat+ (FΔ₁ , FΔ₂) (A * B).\nfold : pat+ FΔ (A (rec A)) -> pat+ FΔ (rec A).\napp : pat+ FΔ₁ A -> pat- FΔ₂* B -> pat- ([C] FΔ₁ , FΔ₂* C) (A => B).\n** : pat- FΔ₁* A -> pat+ (FΔ₁* B) (A \\> B).\nsw : pat- FΔ₁* A -> pat- FΔ₂* B -> pat- ([C] FΔ₁* C , FΔ₂* C) (A || B).\npapp : pat+ FΔ₁ A -> pat- FΔ₂* B -> pat- ([C] FΔ₁ , FΔ₂* C) (A ↑ B).\nbnd : pat- FΔ* B -> pat- ([C] vhol A , FΔ* C) (A ↓ B).\n\nvvar : pat+ (vhol A) (down A).\nkvar : pat- (khol A) (up A).\n\ntt : pat+ ⋅ bool = inl u.\nff : pat+ ⋅ bool = inr u.\nzz : pat+ ⋅ nat = fold (inl u).\nss : pat+ FΔ nat -> pat+ FΔ nat = [p] fold (inr p).  %prefix 9 ss.\nleaf : pat+ FΔ A -> pat+ FΔ (tree A) = [p] fold (inl p).\nnode : pat+ FΔ₁ (tree A) -> pat+ FΔ₂ (tree A) -> pat+ (FΔ₁ , FΔ₂) (tree A) = [p₁] [p₂] fold (inr (pair p₁ p₂)).\nnil : pat+ ⋅ (stream A) = fold (inl u).\ncons : pat+ FΔ A -> pat+ (FΔ , vhol (unit => up (stream A))) (stream A) = [p] fold (inr (pair p vvar)).\n\nj : type.\nrfoc : pos -> j.\nlinv : pos -> pos -> j.\nrinv : neg -> j.\nlfoc : neg -> pos -> j.\nall : frame -> j.\nneu : pos -> j.\nabs : (pos -> j) -> j.\n\ntm : j -> type.\n⊢ : frame -> j -> j.   %infix right 9 ⊢.\n\nλ_ : tm J -> tm (FΔ ⊢ J).\nλ, : tm (FΔ₁ ⊢ FΔ₂ ⊢ J) -> tm (FΔ₁ , FΔ₂ ⊢ J).\nλval : (tm (rinv A) -> tm J) -> tm (vhol A ⊢ J).\nλcon : (tm (linv A B) -> tm J) -> tm (khol A B ⊢ J).\nλsub : (tm (all FΔ) -> tm J) -> tm (FΔ ⊢ J).\n%prefix 9 λ_. %prefix 9 λ,. %prefix 9 λval. %prefix 9 λcon. %prefix 9 λsub.\n\nval+ : pat+ FΔ A -> tm (all FΔ) -> tm (rfoc A).\ncon- : pat- FΔ* A -> tm (all (FΔ* B)) -> tm (lfoc A B).\npar : ({p} tm (C p)) -> tm (abs C).\n\nsval : tm (rinv A) -> tm (all (vhol A)).\nscon : tm (linv A B) -> tm (all (khol A B)).\nsnil :  tm (all ⋅).\nsjoin : tm (all FΔ₁) -> tm (all FΔ₂) -> tm (all (FΔ₁ , FΔ₂)).\n\nreturn : tm (rfoc A) -> tm (neu A).\ncall- : tm (lfoc A B) -> tm (rinv A) -> tm (neu B).\ncall+ : tm (linv A B) -> tm (neu A) -> tm (neu B).\nlet : tm (all FΔ) -> tm (FΔ ⊢ neu A) -> tm (neu A).\n\nkbody : tm (linv A B) -> pat+ FΔ A -> tm (FΔ ⊢ neu B) -> type.\n%mode kbody +K +P -E.\n\nvbody : tm (rinv A) -> pat- FΔ* A -> tm (abs [B] FΔ* B ⊢ neu B) -> type.\n%mode vbody +V +D -E.\n\n%worlds () (kbody K P _). %total P (kbody K P _). %unique kbody +K +P -E.\n%worlds () (vbody V D _). %total D (vbody V D _). %unique vbody +V +D -E.\n\nresult : type.\nhalt : i -> result.\n\nload : tm (all FΔ) -> tm (FΔ ⊢ J) -> tm J -> type.\nstep : tm (neu A) -> tm (neu A) -> type.\neval : tm (neu A) -> tm (rfoc A) -> type.\n%mode load +Sσ +T -T'.\n%mode step +E -E'.\n%mode eval +E -V.\n\nld/_ : load Sσ (λ_ T) T.\nld/join : load (sjoin Sσ₁ Sσ₂) (λ, T) T'' <- load Sσ₁ T T' <- load Sσ₂ T' T''.\nld/val : load (sval V) (λval T*) (T* V).\nld/con : load (scon K) (λcon T*) (T* K).\nld/sub : load Sσ (λsub T) (T Sσ).\n\nst/call- : step (call- (con- D Sσ) V) (let Sσ (E _))\n   <- vbody V D (par E).\nst/call+ : step (call+ K (return (val+ P Sσ))) (let Sσ E)\n   <- kbody K P E.\nst/cong : step (call+ K E) (call+ K E')\n   <- step E E'.\nst/let :  step (let Sσ E) E'\n   <- load Sσ E E'.\n\nev/return : eval (return V) V.\nev/step : eval E V\n\t<- step E E'\n\t<- eval E' V.\n\n%worlds () (load _ _ _). %total (Sσ) (load Sσ _ _). %unique load +Sσ +T -T.\n% %worlds () (step _ _). %covers step +E -R. %unique step +E -R.\n% %worlds () (eval _ _). %covers eval +E -R. %unique eval +E -R.\n\nidk : tm (linv A A).\nidk/x : kbody idk P (λsub [σ] return (val+ P σ)).\n\n%total P (kbody K P _). %unique kbody +K +P -E.\n%total D (vbody V D _). %unique vbody +V +D -E.\n\nplus : tm (linv (int * int) int).\nplus/mn : kbody plus (pair (n M) (n N)) (λ_ return (val+ (n P) snil))\n             <- add M N P.\n\ntimes : tm (linv (int * int) int).\ntimes/mn : kbody times (pair (n M) (n N)) (λ_ return (val+ (n P) snil))\n             <- mult M N P.\n\n%total P (kbody K P _). %unique kbody +K +P -E.\n%total D (vbody V D _). %unique vbody +V +D -E.\n\nsucc : tm (linv nat nat).\nsucc/n : kbody succ N (λsub [σ] return (val+ (ss N) σ)).\n\nplus' : tm (linv (nat * nat) nat).\nplus'/zn : kbody plus' (pair zz N) (λ, λ_ λsub [σ] return (val+ N σ)).\nplus'/sn : kbody plus' (pair (ss M) N) (λ, λsub [σ₁] λsub [σ₂]\n                call+ succ (call+ plus' (return (val+ (pair M N) (sjoin σ₁ σ₂))))).\n\nadd1 : tm (linv int int).\nadd1/n : kbody add1 (n N) (λ_ return (val+ (n (s N)) snil)).\n\n%total P (kbody K P _). %unique kbody +K +P -E.\n%total D (vbody V D _). %unique vbody +V +D -E.\n\nn0 = n z.\nn1 = n (s z).\nn2 = n (s s z).\nn3 = n (s s s z).\nn4 = n (s s s s z).\n\n%query 1 *\n  eval (call+ add1 (return (val+ n2 snil))) R.\n\n%query 1 *\n  eval (call+ plus (return (val+ (pair n2 n2) (sjoin snil snil)))) R.\n\n%query 1 *\n  eval (call+ plus' (return (val+ (pair (ss ss zz) (ss ss zz)) (sjoin snil snil)))) R.\n\n%% various useful continuations/values\n\nfst : tm (linv (A * B) A).\nfst/xy : kbody fst (pair P1 P2) (λ, λsub [σ₁] λsub [σ₂] return (val+ P1 σ₁)).\nsnd : tm (linv (A * B) B).\nsnd/xy : kbody snd (pair P1 P2) (λ, λsub [σ₁] λsub [σ₂] return (val+ P2 σ₂)).\n\ncase : tm (linv A C) -> tm (linv B C) -> tm (linv (A + B) C).\ncase/inl : kbody (case K1 K2) (inl P) E1 <- kbody K1 P E1.\ncase/inr : kbody (case K1 K2) (inr P) E2 <- kbody K2 P E2.\n\nlam : tm (linv A B) -> tm (rinv (A => up B)).\nlam/x : vbody (lam K) (app P kvar) (par [_] λ, λsub [σ] λcon [k] call+ k (call+ K (return (val+ P σ)))).\n\nunlam : tm (rinv (A => up B)) -> tm (linv A B).\nunlam/x : kbody (unlam V) P (λsub [σ] call- (con- (app P kvar) (sjoin σ (scon idk))) V).\n\ncon : ({Δ} pat+ Δ A -> tm (all Δ) -> tm (neu C)) -> tm (linv A C).\ncon/x : kbody (con K) P (λsub [σ] K _ P σ).\n\nconV : (tm (rfoc A) -> tm (neu C)) -> tm (linv A C).\nconV/x : kbody (conV K) P (λsub [σ] K (val+ P σ)).\n\nfn : (tm (rfoc A) -> tm (rinv B)) -> tm (rinv (A => B)).\nfn/x : vbody (fn V) (app P D) (par [_] λ, λsub [σ₁] λsub [σ₂] let σ₂ (E (val+ P σ₁) _))\n\t<- {x} vbody (V x) D (par (E x)).\n\nletV : tm (neu A) -> (tm (rfoc A) -> tm (neu C)) -> tm (neu C) = [E] [f] call+ (conV f) E.\n\nletVp : tm (neu A) -> ({Δ} pat+ Δ A -> tm (all Δ) -> tm (neu C)) -> tm (neu C) = [E] [f] call+ (con f) E.\n\n∘ : tm (linv B C) -> tm (linv A B) -> tm (linv A C)\n  = [K1] [K2] conV [x] call+ K1 (call+ K2 (return x)).\n%infix left 12 ∘.\n\ndelay : tm (rinv A) -> tm (neu (down A))\n = [V] return (val+ vvar (sval V)).\n\ngrab : (tm (rinv A) -> tm (neu C)) -> tm (linv (down A) C).\ngrab/x : kbody (grab E*) vvar (λval E*).\n\nthunk : tm (neu C) -> tm (linv unit C).\nthunk/u : kbody (thunk E) u (λ_ E).\n\nthunk' : tm (neu C) -> tm (rinv (up C)).\nthunk'/k : vbody (thunk' E) kvar (par [_] λcon [k] call+ k E).\n\nforce : tm (neu (down A)) -> tm (rinv A).\nforce/u : vbody (force E) D (par [_] λsub [σ] call+ (grab [x] call- (con- D σ) x) E).\n\n%% EFFECTS\n%% effectful terms encoded as negative values of type (A -> B) -> C...\n\ntrip' : pos -> neg -> neg -> neg = [A] [B] [C] (A ↑ B) ↓ C.\ntrip : pos -> pos -> pos -> neg = [A] [B] [C] down (A => up B) => up C.\neff : pos -> pos -> pos -> j = [A] [B] [C] rinv (trip A B C).\n\nshift : (tm (linv A B) -> tm (eff D D C)) -> tm (eff A B C).\nshift/k : vbody (shift E) (app vvar kvar) (par [_] λ, λval [x] λcon [k]\n       call- (con- (app vvar kvar) (sjoin (sval (lam idk)) (scon k))) (E (unlam x))).\n\nreset : tm (eff B B A) -> tm (eff A C C).\nreset/e : vbody (reset E) (app vvar kvar) (par [_] λ, λval [x] λcon [k]\n       call+ k (call- (con- (app vvar kvar) (sjoin (sval (lam idk)) (scon (unlam x)))) E)).\n\nplug : tm (eff A B C) -> tm (linv A B) -> tm (neu C)\n   = [V] [k] call- (con- (app vvar kvar) (sjoin (sval (lam k)) (scon idk))) V.\n\n! : tm (neu A) -> tm (eff A C C).\n!/x : vbody (! E) (app vvar kvar) (par [_] λ, λval [x] λcon [k]\n       call+ k (call+ (unlam x) E)).\n%prefix 9 !.\n\neapp : tm (linv A B) -> tm (eff A C1 C2) -> tm (eff B C1 C2).\neapp/x : vbody (eapp K E) (app vvar kvar) (par [_] λ, λval [x] λcon [k]\n       call- (con- (app vvar kvar) (sjoin (sval (lam ((unlam x) ∘ K))) (scon k))) E).\n\n;; : tm (eff unit C2 C3) -> tm (eff unit C1 C2) -> tm (eff unit C1 C3)\n   = [e1] [e2] shift [k] !\n\t       plug e1 (thunk (\n\t       plug e2 (thunk (call+ k (return (val+ u snil)))))).\n%infix left 8 ;;.\n\n%total P (kbody K P _). %unique kbody +K +P -E.\n%total D (vbody V D _). %unique vbody +V +D -E.\n\n%% stuff\n\ncaseB : tm (neu C) -> tm (neu C) -> tm (linv bool C)\n = [E1] [E2] case (conV [_] E1) (conV [_] E2).\n\ncmpB : tm (linv (bool * bool) bool).\ncmpB/tt : kbody cmpB (pair tt tt) (λ_ return (val+ tt snil)).\ncmpB/ff : kbody cmpB (pair ff ff) (λ_ return (val+ tt snil)).\ncmpB/tf : kbody cmpB (pair tt ff) (λ_ return (val+ ff snil)).\ncmpB/ft : kbody cmpB (pair ff tt) (λ_ return (val+ ff snil)).\n\ncmpI : tm (linv (int * int) bool).\ncmpI/zz : kbody cmpI (pair (n z) (n z)) (λ_ return (val+ tt snil)).\ncmpI/ss : kbody cmpI (pair (n (s N1)) (n (s N2))) (λ_ call+ cmpI (return (val+ (pair (n N1) (n N2)) (sjoin snil snil)))).\ncmpI/zs : kbody cmpI (pair (n z) (n (s _))) (λ_ return (val+ ff snil)).\ncmpI/zs : kbody cmpI (pair (n (s _)) (n z)) (λ_ return (val+ ff snil)).\n\n&& : tm (neu bool) -> tm (neu bool) -> tm (neu bool)\n   = [E1] [E2] call+ (caseB E2 (return (val+ ff snil))) E1.\n%infix left 9 &&.\n\ncmpS : tm (linv (A * A) bool) -> tm (linv (stream A * stream A) bool).\ncmpS/nil :  kbody (cmpS F) (pair nil nil) (λ_ return (val+ tt snil)).\ncmpS/cons : kbody (cmpS F) (pair (cons P1) (cons P2)) (λ, λ, λsub [σ₁] λval [x₁] λ, λsub [σ₂] λval [x₂]\n\tcall+ F (return (val+ (pair P1 P2) (sjoin σ₁ σ₂))) &&\n        call- (con- (app u kvar) (sjoin snil (scon (con [_] [p1'] [σ₁']\n        call- (con- (app u kvar) (sjoin snil (scon (con [_] [p2'] [σ₂']\n\t     call+ (cmpS F) (return (val+ (pair p1' p2') (sjoin σ₁' σ₂')))))))\n\t    x₂)))) x₁).\ncmpS/nc :  kbody (cmpS F) (pair nil (cons _)) (λ_ return (val+ ff snil)).\ncmpS/cn :  kbody (cmpS F) (pair (cons _) nil) (λ_ return (val+ ff snil)).\n\nvisit : tm (linv (tree A) (down (trip unit (stream A) (stream A)))).\nvisit/leaf : kbody visit (leaf P) (λsub [σ]\n\tdelay (shift [k] ! return (val+ (cons P) (sjoin σ (sval (lam k)))))).\nvisit/node : kbody visit (node P1 P2) (λ, λsub [σ₁] λsub [σ₂]\n\tdelay (force (call+ visit (return (val+ P1 σ₁))) ;; force (call+ visit (return (val+ P2 σ₂))))).\n\nfringe : tm (linv (tree A) (stream A))\n  = conV [x] plug\n     (reset ((force (call+ visit (return x))) ;; (fn [_] thunk' (return (val+ nil snil)))))\n     idk.\n\nsame : tm (linv (tree int * tree int) bool).\nsame/xy : kbody same (pair P1 P2) (λ, λsub [σ₁] λsub [σ₂]\n\tletVp (call+ fringe (return (val+ P1 σ₁))) [_] [p1'] [σ₁']\n\tletVp (call+ fringe (return (val+ P2 σ₂))) [_] [p2'] [σ₂']\n\tcall+ (cmpS cmpI) (return (val+ (pair p1' p2') (sjoin σ₁' σ₂')))).\n\n%query 1 *\n  eval (call+ same (return (val+ (pair (leaf n1) (leaf n1)) _))) S1.\n\n%query 1 *\n  eval (call+ same (return (val+ (pair (leaf n1) (leaf n0)) _))) S2.\n\n%query 1 *\n  eval (call+ same (return (val+ (pair (node (leaf n1) (leaf n2)) (node (leaf n1) (leaf n2))) _))) S3.\n\n%query 1 *\n  eval (call+ same (return (val+ (pair (node (node (leaf n1) (leaf n2)) (leaf n3)) (node (leaf n1) (node (leaf n2) (leaf n3)))) _))) S4.\n\n%query 1 *\n  eval (call+ same (return (val+ (pair (node (node (leaf n1) (leaf n2)) (leaf n3)) (node (leaf n1) (node (leaf n3) (leaf n3)))) _))) S5.\n\n%total P (kbody K P _). %unique kbody +K +P -E.\n%total D (vbody V D _). %unique vbody +V +D -E.\n\n%% Direct-style with shift + reset\n\n%abbrev expOf : pos -> pos -> pos -> type = [A] [B] [C] tm (eff A B C).\n%abbrev valOf : pos -> type = [A] tm (rfoc A).\n%abbrev conOf : pos -> pos -> type = [A] [B] tm (linv A B).\n\nV : valOf A -> expOf A C C = [V] ! return V.\nEApp : conOf A B -> expOf A C1 C2 -> expOf B C1 C2 = eapp.\n\nPair : expOf A C2 C3 -> expOf B C1 C2 -> expOf (A * B) C1 C3\n   = [e1] [e2] shift [k] !\n\t       plug e1 (con [_] [p1] [σ₁]\n\t       plug e2 (con [_] [p2] [σ₂]\n               call+ k (return (val+ (pair p1 p2) (sjoin σ₁ σ₂))))).\n\n%abbrev Fst : expOf (A * B) C1 C2 -> expOf A C1 C2 = [e] eapp fst E.\n%abbrev Snd : expOf (A * B) C1 C2 -> expOf B C1 C2 = [e] eapp snd E.\n\nInl : expOf A C1 C2 -> expOf (A + B) C1 C2\n   = [e] shift [k] ! plug e (con [_] [p] [σ] call+ k (return (val+ (inl p) σ))).\nInr : expOf B C1 C2 -> expOf (A + B) C1 C2\n   = [e] shift [k] ! plug e (con [_] [p] [σ] call+ k (return (val+ (inr p) σ))).\nCase : expOf (A + B) C2 C3 -> (valOf A -> expOf C C1 C2) -> (valOf B -> expOf C C1 C2) -> expOf C C1 C3\n   = [e] [f] [g] shift [k] !\n\tplug e (case (conV [x] plug (f x) k) (conV [y] plug (g y) k)).\n\nFn : (valOf A -> expOf B C1 C2) -> valOf (down (A => trip B C1 C2))\n   = [f] val+ vvar (sval (fn f)).\n\nApp : expOf (down (A => trip B C1 C2)) C0 C3 -> expOf A C2 C0 -> expOf B C1 C3\n   = [e1] [e2] shift [k] !\n       plug e1 (grab [f]\n       plug e2 (con [_] [p] [σ]\n       call- (con- (app p (app vvar kvar)) (sjoin σ (sjoin (sval (lam k)) (scon idk)))) f)).\n\nShift : (conOf A B -> expOf D D C) -> expOf A B C = shift.\nReset : expOf B B A -> expOf A C C = reset.\n\nZ : expOf int C C = ! (return (val+ (n z) snil)).\nS : expOf int C1 C2 -> expOf int C1 C2 = [e] eapp add1 e.  %prefix 9 S.\n\nPlus : expOf int C2 C3 -> expOf int C1 C2 -> expOf int C1 C3\n   = [e1] [e2] shift [k] !\n\t       plug e1 (con [_] [p1] [σ₁]\n\t       plug e2 (con [_] [p2] [σ₂]\n               call+ k (call+ plus (return (val+ (pair p1 p2) (sjoin σ₁ σ₂)))))).\n\nTimes : expOf int C2 C3 -> expOf int C1 C2 -> expOf int C1 C3\n   = [e1] [e2] shift [k] !\n\t       plug e1 (con [_] [p1] [σ₁]\n\t       plug e2 (con [_] [p2] [σ₂]\n               call+ k (call+ times (return (val+ (pair p1 p2) (sjoin σ₁ σ₂)))))).\n\nAbort0 : expOf A B int = shift [k] ! return (val+ n0 snil).\nAbort1 : expOf A B int = shift [k] ! return (val+ n1 snil).\n\n%abbrev run : expOf A A int -> i -> type = [t] [x] eval (call- (con- (app vvar kvar) (sjoin (sval (lam idk)) (scon idk))) t) (val+ (n x) snil).\n\n%query 1 * run (Plus (S S Z) (S S S Z)) N1.                     % N1 = 5\n%query 1 * run (Plus (S S Z) Abort1) N2.                        % N2 = 1\n%query 1 * run (Plus Abort0 Abort1) N3.                         % N3 = 0\n%query 1 * run (Times (S S Z) (S S S Z)) N4.                    % N4 = 6\n%query 1 * run (Times (S S Z) (Shift [k] Plus (S Z) (EApp k (EApp k (EApp k (S Z)))))) N5.       % N5 = 9\n%query 1 * run (App (V (Fn [x] Plus (V x) (S Z))) (S Z)) N6.    % N6 = 2\n\n</twelf>"
          },
          "sha1": "1sp2zmw9f6t73g4q71yzkez99qeokr3"
        }
      },
      {
        "title": "User:NewTestUser",
        "ns": 2,
        "id": 1855,
        "revision": {
          "id": 3686,
          "timestamp": "2007-02-22T07:27:04Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "standard message, less red.",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 160,
            "#text": "[[User:rsimmons|Rob]] created this user to have someone he could use to log in to who only had \"generic user\" permission. Leave Rob any messages you might have."
          },
          "sha1": "ksrxmfy7qu1boera6tlcj97petgj3cq"
        }
      },
      {
        "title": "User:Rsimmons",
        "ns": 2,
        "id": 1369,
        "revision": {
          "id": 5142,
          "parentid": 5141,
          "timestamp": "2008-04-08T03:24:23Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "minor": null,
          "comment": "/* Scratch space */",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 2056,
            "#text": "My name is Robert J. Simmons. I am a first-year graduate student at Carnegie Mellon University.\n\n* Web page: http://www.cs.cmu.edu/~rjsimmon/\n* Wikipedia: [[w:User:Sirmob]]\n* Girard Reading Group Wiki: http://locuspocus.hyperkind.org/\n\nI am the background maintainer for this website, and [http://moog.concert.cs.cmu.edu moog] lives in my office. I developed the the [[Project:TwelfTag|TwelfTag]] extension for syntax highlighting automatically checking included Twelf code, the [[Project:Literate Twelf|Literate Twelf]] extension to facilitate offline editing, and generally attempt to keep things working. Leave me a [http://twelf.plparty.org/w/index.php?title=User_talk:Rsimmons&action=edit&section=new message] if anything needs to be done.\n\n== Scratch space ==\n\nSince writing [[Project:Literate Twelf|Literate Twelf]], I tend to incorporate the Wiki into my development process. Often I only use the preview feature, but sometimes I save drafts in my namespace. Some of these would probably make good case studies if I get around to it.\n\n* [[User:Rsimmons/primop.elf]] - Broken.\n* [[User:Rsimmons/Subtype]] - Incomplete - an attempt at doing a reasonable encoding of (width,depth) subtyping for n-ary tuples.\n* [[User:Rsimmons/Handled exceptions]] - An encoding of exceptions where the type system can statically determine code to be non-exception-raising.\n* [[User:Rsimmons/Fluid binding]] - A more organized example than handled exceptions. This encodes \"deep binding,\" requiring the dynamic semantics to search the stack for the correct binding; the type system ensures that some binding will be found. I was worried that the unsatisfactory encoding of sets would run into trouble, but it's actually a very context-like encoding of sets of fluid variables (weakening and exchange need to be proven explicitly, etc etc). This is the first encoding where I've wanted \"Twelf functors\" to abstract over the variable names - I can't use hypotheticals because I need decidable equality/inequality.\n\n== Things to do ==\n\n* <tt>[[%terminates]]</tt>\n* [[LF]]"
          },
          "sha1": "2zgme0lhhiyvki2gtfiv9wrl5811ufd"
        }
      },
      {
        "title": "User:Rsimmons/CR2",
        "ns": 2,
        "id": 2135,
        "revision": {
          "id": 5673,
          "timestamp": "2008-11-22T20:17:22Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "saving work",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 4184,
            "#text": "%{ == Syntax == }%\n\nexp : type.  %name exp E.\nlam : (exp -> exp) -> exp.\napp : exp -> exp -> exp.\n\n%{ \n\nWhen we use this <tt>%block</tt>, it expresses that we can be working in a \ncontext with arbitrary expression variables. \n\n}%\n\n%block exps : block {x: exp}.\n%worlds (exps) (exp).\n\n%{ == Reduction == }%\n%{ \n\nWe can reduce under binders and \nreduce both sides of an application \"in parallel.\" If we have a β-redex \n<tt>(λx.ea) eb</tt>, then after reducing <tt>ea</tt> (with <tt>x</tt> free) to \n<tt>ea'</tt> (with <tt>x</tt> free) and reducing <tt>eb</tt> to <tt>eb'</tt>,\nwe can return <tt>[eb'/x]ea'</tt>, the substitution of <tt>eb'</tt> into\n<tt>ea'</tt>. When we introduce a new variable, we always add in the fact \nthat it can evaluate to itself.\n\nThe <tt>%block</tt> <tt>exps_id</tt> \nexplicitly states that we will be reducing in a setting \nwith free variables, with the invariant that every variable is added\nwith the invariant that it can evaluate to itself.\n\n}%\n\nreduce : exp -> exp -> type.\n%mode reduce +E -E'.\n\n%block exps_id : block {x: exp}{d: reduce x x}.\n\nreduce/lam : reduce (lam E) (lam E')\n              <- ({x:exp} reduce x x -> reduce (E x) (E' x)).\n\nreduce/app : reduce (app E1 E2) (app E1' E2')\n              <- reduce E1 E1'\n              <- reduce E2 E2'.\n\nreduce/beta : reduce (app (lam E1) E2) (E1' E2')\n              <- ({x:exp} reduce x x -> reduce (E1 x) (E1' x))\n              <- reduce E2 E2'.\n\n%worlds (exps_id) (reduce _ _).\n%total E (reduce E _).\n\n%{ == Substitution == }%\n%{ \n\nThe substitution theorem says that if we have a term <tt>e</tt> with \n<tt>x</tt> free that reduces to <tt>e'</tt> (with <tt>x</tt> still free)\nand <tt>e<sub>arg</sub></tt> reduces to <tt>e'<sub>arg</sub></tt>, \nthen <tt>[e<sub>arg</sub>/x]e</tt> reduces to <tt>[e'<sub>arg</sub>/x]e'</tt>. \n\nThe proof is by induction on the structure of the term with the free variable.\n\n}%\n\nsubstitute \n   : ({x: exp} reduce x x -> reduce (E x) (E' x))\n      -> reduce Earg Earg'\n      -> reduce (E Earg) (E' Earg') -> type.\n%mode substitute +D +Darg -D'.\n\n%{ \n\nWe actually need to think about what block this theorem will take place in.\nThe \"variable case\" of our lemma is one where the first argument is\n<tt>[x: exp] [idx: red x x] y</tt>, where <tt>y</tt> is ''not'' equal to\n<tt>x</tt>. In this case, we will need to insert into the context the lemma\nthat, if \n\n}%\n\n%block exp_subst \n   : block {x: exp}{idx: reduce x x}\n      {subst\n         : {z: exp}{z': exp}{red: reduce z z'} substitute ([_][_] idx) red idx}.\n\n- : substitute\n     ([x] [idx: reduce x x] idx)\n     (D : reduce Earg Earg') D.\n\n- : substitute \n     ([x] [idx: reduce x x] \n        reduce/lam \n        (D x idx : {y} reduce y y -> reduce (E x y) (E' x y)))            \n     (Darg: reduce Earg Earg')\n     (reduce/lam D'\n        : reduce (lam ([y] (E Earg) y)) (lam ([y] (E' Earg') y)))\n     <- ({y} {idy: reduce y y}\n           ({z}{z'}{red_z: reduce z z'} substitute ([_] [_] idy) red_z idy)\n           -> substitute ([x] [idx: reduce x x] D x idx y idy) Darg \n              (D' y idy : reduce (E Earg y) (E' Earg' y))).\n\n- : substitute\n     ([x] [idx: reduce x x]\n        reduce/app\n        (Db x idx : reduce (Eb x) (Eb' x))\n        (Da x idx : reduce (Ea x) (Ea' x)))\n     (Darg: reduce Earg Earg')\n     (reduce/app Db' Da' \n        : reduce (app (Ea Earg) (Eb Earg)) (app (Ea' Earg') (Eb' Earg')))\n     <- substitute Da Darg (Da': reduce (Ea Earg) (Ea' Earg'))\n     <- substitute Db Darg (Db': reduce (Eb Earg) (Eb' Earg')).\n\n- : substitute\n     ([x] [idx: reduce x x]\n        reduce/beta\n        (Db x idx : reduce (Eb x) (Eb' x))\n        (Da x idx : {y} reduce y y -> reduce (Ea x y) (Ea' x y)))\n     (Darg: reduce Earg Earg')\n     (reduce/beta Db' Da'\n        : reduce (app (lam (Ea Earg)) (Eb Earg)) ((Ea' Earg') (Eb' Earg')))\n     <- ({y} {idy: reduce y y}\n           ({z}{z'}{red_z: reduce z z'} substitute ([_] [_] idy) red_z idy)\n           -> substitute ([x] [idx: reduce x x] Da x idx y idy) Darg \n              (Da' y idy : reduce (Ea Earg y) (Ea' Earg' y)))\n     <- substitute Db Darg (Db': reduce (Eb Earg) (Eb' Earg')).\n\n%worlds (exp_subst) (substitute _ _ _).\n%total D (substitute D _ _)."
          },
          "sha1": "3vzyb84of08kgdb1ai373vwg3ezblv9"
        }
      },
      {
        "title": "User:Rsimmons/Fluid binding",
        "ns": 2,
        "id": 2044,
        "revision": {
          "id": 8204,
          "parentid": 8203,
          "timestamp": "2018-03-20T20:18:15Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "minor": null,
          "comment": "Protected \"[[User:Rsimmons/Fluid binding]]\" ([Edit=Allow only administrators] (indefinite) [Move=Allow only administrators] (indefinite))",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 36366,
            "#text": "%{ == Fluid variable sets == }%\n\nuninhabited : type.\nfluid : type.\nfluids : type.\n# : fluids. \n, : fluid -> fluids -> fluids. %infix right 10 ,.\n\n%{ === Individual fluid variables === }%\n\n%{ We treat typing rules as if there are *no* concrete fluid variables,\nbut we have to define specific fluid variables for the dynamic semantics. }%\n\na : fluid. \nb : fluid. \nc : fluid. \nd : fluid.  \n\n%block bfluid : block {f: fluid}.\n\neqfluid : fluid -> fluid -> type.\neqfluid/refl : eqfluid A A.\n\nneqfluid : fluid -> fluid -> type.\nneqfluid/ab : neqfluid a b.\nneqfluid/ac : neqfluid a c.\nneqfluid/ad : neqfluid a d.\nneqfluid/ba : neqfluid b a.\nneqfluid/bc : neqfluid b c.\nneqfluid/bd : neqfluid b d.\nneqfluid/ca : neqfluid c a.\nneqfluid/cb : neqfluid c b.\nneqfluid/cd : neqfluid c d.\nneqfluid/da : neqfluid d a.\nneqfluid/db : neqfluid d b.\nneqfluid/dc : neqfluid d c.\n\ndecidable-fluid : fluid -> fluid -> type.\ndecidable-fluid/eq : decidable-fluid A A.\ndecidable-fluid/neq : neqfluid A B -> decidable-fluid A B.\n\neq-or-neq-total : {A}{B} decidable-fluid A B -> type.\n- : eq-or-neq-total a a (decidable-fluid/eq).\n- : eq-or-neq-total a b (decidable-fluid/neq neqfluid/ab).\n- : eq-or-neq-total a c (decidable-fluid/neq neqfluid/ac).\n- : eq-or-neq-total a d (decidable-fluid/neq neqfluid/ad).\n- : eq-or-neq-total b a (decidable-fluid/neq neqfluid/ba).\n- : eq-or-neq-total b b (decidable-fluid/eq).\n- : eq-or-neq-total b c (decidable-fluid/neq neqfluid/bc).\n- : eq-or-neq-total b d (decidable-fluid/neq neqfluid/bd).\n- : eq-or-neq-total c a (decidable-fluid/neq neqfluid/ca).\n- : eq-or-neq-total c b (decidable-fluid/neq neqfluid/cb).\n- : eq-or-neq-total c c (decidable-fluid/eq).\n- : eq-or-neq-total c d (decidable-fluid/neq neqfluid/cd).\n- : eq-or-neq-total d a (decidable-fluid/neq neqfluid/da).\n- : eq-or-neq-total d b (decidable-fluid/neq neqfluid/db).\n- : eq-or-neq-total d c (decidable-fluid/neq neqfluid/dc).\n- : eq-or-neq-total d d (decidable-fluid/eq).\n%mode eq-or-neq-total +A +B -D.\n%worlds () (eq-or-neq-total _ _ _).\n%total {} (eq-or-neq-total _ _ _).\n\nexclusive-fluid : eqfluid A B -> neqfluid A B -> uninhabited -> type.\n%mode exclusive-fluid +A +B -C. \n%worlds () (exclusive-fluid _ _ _).\n%total {} (exclusive-fluid _ _ _).\n\n%{ === Operations on sets of fluid variables === }%\n\nin : fluid -> fluids -> type.\nin/z : in A (A , As).\nin/s : in A As -> in A (B , As).\n\nsubset : fluids -> fluids -> type.\nsubset/z : subset # As.\nsubset/s : in A Bs -> subset As Bs -> subset (A , As) Bs.\n\nmerge : fluids -> fluids -> fluids -> type.\nmerge/z : merge # Bs Bs.\nmerge/s : merge (A , As) Bs (A , Cs)\n           <- merge As Bs Cs.\n\n%{ === Structural properties === }%\n\nin-subset : in A Bs -> subset Bs Cs -> in A Cs -> type.\n- : in-subset in/z (subset/s In Sub : subset (A , Bs) Cs) In.\n- : in-subset (in/s (In: in A Bs)) (subset/s In' Sub : subset (B , Bs) Cs) In''\n     <- in-subset In Sub (In'' : in A Cs).\n%mode in-subset +A +B -C.\n%worlds (bfluid) (in-subset _ _ _).\n%total T (in-subset T _ _).\n\nin-merge1 : in A As -> merge As Bs Cs -> in A Cs -> type.\n- : in-merge1 in/z (merge/s _) in/z.\n- : in-merge1 (in/s In) (merge/s Merge) (in/s In') <- in-merge1 In Merge In'.\n%mode in-merge1 +A +B -C.\n%worlds () (in-merge1 _ _ _).\n%total T (in-merge1 _ T _).\n\nin-merge2 : in A Bs -> merge As Bs Cs -> in A Cs -> type.\n- : in-merge2 In merge/z In.\n- : in-merge2 In (merge/s Merge) (in/s In')\n     <- in-merge2 In Merge In'.\n%mode in-merge2 +A +B -C.\n%worlds () (in-merge2 _ _ _).\n%total T (in-merge2 _ T _).\n\n\neq-or-in : fluid -> fluid -> fluids -> type.\neq-or-in/eq : eq-or-in A A Cs.\neq-or-in/in : in A Cs -> eq-or-in A B Cs.\n\n% exclude : {A}{B}{Cs} uninhabited -> eq-or-in A B Cs -> type.\n% mode exclude +A +B +C +D -E. \n% worlds (bfluid) (exclude _ _ _ _ _). \n% total {} (exclude _ _ _ _ _).\n% \n% in-inversion' : decidable-fluid A B -> in A (B , Cs) -> eq-or-in A B Cs -> type.\n% - : in-inversion' _ in/z eq-or-in/eq.\n% - : in-inversion' decidable-fluid/eq in-s D\n%      <- exclusive-fluid \n\nin-inversion : in A (B , Cs) -> eq-or-in A B Cs -> type.\n- : in-inversion in/z eq-or-in/eq.\n- : in-inversion (in/s Sub) (eq-or-in/in Sub).\n%mode in-inversion +A -B.\n%worlds (bfluid) (in-inversion _ _). \n%total {} (in-inversion _ _).\n\nsubset-trans : subset As Bs -> subset Bs Cs -> subset As Cs -> type.\n- : subset-trans subset/z _ subset/z.\n- : subset-trans (subset/s In Sub) (Sub') (subset/s In Sub'')\n     <- subset-trans Sub Sub' (Sub'': subset FS HS).\n- : subset-trans (subset/s (In: in A Bs) (Sub: subset As Bs)) \n     (Sub': subset Bs Cs) (subset/s In' Sub'')\n     <- subset-trans Sub Sub' (Sub'': subset As Cs)\n     <- in-subset In Sub' (In' : in A Cs).\n%mode subset-trans +FG +GH -FH.\n%worlds (bfluid) (subset-trans _ _ _).\n%total T (subset-trans T _ _).\n\nsubset-weaken : {C} subset Bs Cs -> subset Bs (C , Cs) -> type.\n- : subset-weaken C subset/z subset/z.\n- : subset-weaken C (subset/s In Sub : subset (B , Bs) Cs) \n     (subset/s (in/s In) Sub' : subset (B , Bs) (C , Cs))\n     <- subset-weaken C Sub (Sub' : subset Bs (C , Cs)).\n%mode subset-weaken +A +AS -Sub.\n%worlds (bfluid) (subset-weaken _ _ _).\n%total T (subset-weaken _ T _).\n\nsubset-refl : {FS} subset FS FS -> type.\n- : subset-refl # subset/z.\n- : subset-refl (A , As) (subset/s in/z Sub')\n     <- subset-refl As (Sub: subset As As)\n     <- subset-weaken A Sub (Sub': subset As (A , As)).\n%mode subset-refl +As -S.\n%worlds (bfluid) (subset-refl _ _).\n%total T (subset-refl T _).\n\nmerge-subset1 : merge As Bs Cs -> subset As Cs -> type.\n- : merge-subset1 merge/z subset/z.\n- : merge-subset1 (merge/s Merge : merge (A , As) Bs (A , Cs))\n     (subset/s in/z Sub')\n     <- merge-subset1 Merge Sub\n     <- subset-weaken A Sub Sub'.\n%mode merge-subset1 +A -B.\n%worlds (bfluid) (merge-subset1 _ _).\n%total T (merge-subset1 T _).\n\n\n\n%{ == Syntax == }%\n\n%{ === Types === }%\n\nty : type.\nty/nat : ty.                    % nat\nty/arrow : ty -> ty -> ty.      % tau1 tau2\nty/mayuse : ty -> fluids -> ty. % [C] tau\n\n%{ ==== Type equality ==== }%\n\neqty : ty -> ty -> type.\neqty/refl : eqty T T.\n\n%{ ==== Individual fluid types ==== }%\n\nfluidty : fluid -> ty -> type.\n%block ftyblock : some {T: ty} block {f: fluid} {d: fluidty f T}.\n\nfluidty/a : fluidty a ty/nat.\nfluidty/b : fluidty b (ty/arrow ty/nat (ty/mayuse ty/nat (a , c , #))).\nfluidty/c : fluidty c ty/nat.\nfluidty/d : fluidty d (ty/arrow ty/nat ty/nat).\n\n\nfluidty-uniq : fluidty A T -> fluidty A T' -> eqty T T' -> type.\n\n- : fluidty-uniq fluidty/a fluidty/a eqty/refl.\n- : fluidty-uniq fluidty/b fluidty/b eqty/refl.\n- : fluidty-uniq fluidty/c fluidty/c eqty/refl.\n- : fluidty-uniq fluidty/d fluidty/d eqty/refl.\n\n%mode fluidty-uniq +A +B -C. \n%worlds () (fluidty-uniq _ _ _). \n%total {} (fluidty-uniq _ _ _).\n\n%{ === Terms === }%\n\ntm : type.\ntm/lam : ty -> (tm -> tm) -> tm.\ntm/app : tm -> tm -> tm.\ntm/z : tm.\ntm/s : tm -> tm.\ntm/if : tm -> tm -> (tm -> tm) -> tm.\ntm/fix : ty -> (tm -> tm) -> tm.\ntm/access : fluid -> tm.\ntm/fluid-let : fluid -> tm -> tm -> tm.\ntm/susp : tm -> tm.\ntm/unsusp : tm -> tm.\ntm/let : tm -> ty -> (tm -> tm) -> tm = [e][t][f] tm/app (tm/lam t f) e.\n\n%{ ==== Term equality ==== }%\n\neqtm : tm -> tm -> type.\neqtm/refl : eqtm E E.\n\n%{ === Values === }%\n\nv : tm -> type.\nv/lam : v (tm/lam T ([x] E x)).\nv/z : v tm/z.\nv/s : v E -> v (tm/s E).\nv/susp : v (tm/susp E).\n\n%{ === Frames and stacks === }%\n\nframe : type.\n-- : type.\n--- : --.\n\nf/app1 : -- -> tm -> frame.\nf/app2 : {t} v t -> -- -> frame.\nf/s : -- -> frame.\nf/if : -- -> tm -> (tm -> tm) -> frame.\nf/fluid-let : fluid -> -- -> tm -> frame.\nf/fluid-bind : fluid -> {t} v t -> frame.\nf/unsusp : -- -> frame.\n\nstack : type.\nemp : stack.\n; : frame -> stack -> stack. %infix right 10 ;.\n\n%{ === Machine States === }%\n\nstate : type.\n\n>> : stack -> tm -> state.\n<< : stack -> {t} v t -> state.\n\n\n\n\n%{ == Static semantics == }%\n\nof : tm -> ty -> fluids -> type.   % May access the mentioned fluids\n\nof/weaken : of E T Bs -> subset Bs Cs -> of E T Cs.\n\nof/lam : ({x} of x T # -> of (E x) T' #) -> of (tm/lam T E) (ty/arrow T T') #.\nof/app : of E1 (ty/arrow T T') Bs -> of E2 T Bs -> of (tm/app E1 E2) T' Bs.\nof/z : of tm/z ty/nat #.\nof/s : of E ty/nat Bs -> of (tm/s E) ty/nat Bs.\nof/if : of E ty/nat Bs -> of E1 T Bs -> ({x} of x ty/nat # -> of (E2 x) T Bs) \n -> of (tm/if E E1 ([x] E2 x)) T Bs. \nof/fix : ({x} of x T # -> of (E x) T #) -> of (tm/fix T ([x] E x)) T #.\nof/access : fluidty A T -> of (tm/access A) T (A , #).\nof/fluid-let : fluidty A Tf -> of E1 Tf Bs -> of E2 T (A , Bs) \n -> of (tm/fluid-let A E1 E2) T Bs.\nof/susp : of E T Bs -> of (tm/susp E) (ty/mayuse T Bs) #.\nof/unsusp : merge As Bs Cs -> of E (ty/mayuse T As) Bs -> of (tm/unsusp E) T Cs.\n\n\nofframe : frame -> ty -> fluids -> ty -> fluids -> type.\n\nofframe/app1 : of E2 T' Bs -> offrame (f/app1 --- E2) (ty/arrow T' T) Bs T Bs.\nofframe/app2 : of E1 (ty/arrow T' T) # -> offrame (f/app2 E1 V ---) T' Bs T Bs.\nofframe/s : offrame (f/s ---) ty/nat Bs ty/nat Bs.\nofframe/if : of E1 T Bs -> ({x} of x ty/nat # -> of (E2 x) T Bs) \n -> offrame (f/if --- E1 ([x] E2 x)) ty/nat Bs T Bs.\nofframe/fluid-let : fluidty A T -> of E T' (A , Bs) \n -> offrame (f/fluid-let A --- E) T Bs T' Bs.\nofframe/fluid-bind : fluidty A Tf -> of E Tf #\n -> offrame (f/fluid-bind A E Dv) T (A , Bs) T Bs.\nofframe/unsusp : merge As Bs Cs \n -> offrame (f/unsusp ---) (ty/mayuse T As) Bs T Cs.\n\nofstack : stack -> ty -> fluids -> type.\n\nofstack/weaken :  ofstack K T Cs -> subset Bs Cs -> ofstack K T Bs.\n\nofstack/emp : ofstack emp T #.\nofstack/frame : offrame F Bs T Bs' Cs' -> ofstack K Bs' Cs' \n -> ofstack (F ; K) Bs T.\n\nok : state -> type.\nok>> : ofstack K T Bs -> of E T Bs -> ok (>> K E).\nok<< : ofstack K T Bs -> of E T Bs -> {V: v E} ok (<< K E V).\n\n\n\n\n\n%{ == Dynamic semantics == }%\n\n%{ === Deep binding lookup === }%\n\nlookup : fluid -> stack -> {t: tm} v t -> type.\nlookup/app1 : lookup F K Val Dv -> lookup F (f/app1 --- E2 ; K)        Val Dv.\nlookup/app2 : lookup F K Val Dv -> lookup F (f/app2 E1 DV --- ; K)     Val Dv.\nlookup/s    : lookup F K Val Dv -> lookup F (f/s --- ; K)              Val Dv.\nlookup/if   : lookup F K Val Dv -> lookup F (f/if --- E1 E2 ; K)       Val Dv.\nlookup/flet : lookup F K Val Dv -> lookup F (f/fluid-let A --- E2 ; K) Val Dv.\nlookup/ususp: lookup F K Val Dv -> lookup F (f/unsusp --- ; K)         Val Dv.\nlookup/hit  : eqfluid A B -> lookup A (f/fluid-bind B Val Dv ; K) Val Dv.\nlookup/miss : neqfluid A B -> lookup A K Val Dv  \n -> lookup A (f/fluid-bind B _ _ ; K) Val Dv.\n\n%{ === Small-step evaluation === }%\n\nstep : state -> state -> type.\nstep/lam   : step\n              (>> K (tm/lam T ([x] E x)))\n              (<< K (tm/lam T ([x] E x)) v/lam).\nstep/app1  : step \n              (>> K (tm/app E1 E2))\n              (>> (f/app1 --- E2 ; K) E1).\nstep/app2  : step\n              (<< (f/app1 --- E2 ; K) V DV) \n              (>> (f/app2 V DV --- ; K) E2).\nstep/appr  : step \n              (<< (f/app2 (tm/lam T E) DV --- ; K) V _) \n              (>> K (E V)).\nstep/z     : step\n              (>> K tm/z)\n              (<< K tm/z v/z).\nstep/s     : step\n              (>> K (tm/s E))\n              (>> (f/s --- ; K) E).\nstep/sr    : step\n              (<< (f/s --- ; K) V DV) \n              (<< K  (tm/s V) (v/s DV)).\nstep/if    : step \n              (>> K (tm/if E E1 E2)) \n              (>> (f/if --- E1 E2 ; K) E).\nstep/ifz   : step \n              (<< (f/if --- E1 E2 ; K) tm/z _) \n              (>> K E1).\nstep/ifs   : step \n              (<< (f/if --- E1 E2 ; K) (tm/s E) _) \n              (>> K (E2 E)).\nstep/fix   : step \n              (>> K (tm/fix T ([x] E x))) \n              (>> K (E (tm/fix T ([x] E x)))).\nstep/access : lookup A K V Dv -> step (>> K (tm/access A)) (<< K V Dv).\nstep/flet1 : step \n              (>> K (tm/fluid-let A E1 E2)) \n              (>> (f/fluid-let A --- E2 ; K) E1).\nstep/flet2 : step \n              (<< (f/fluid-let A --- E2 ; K) V DV)\n              (>> (f/fluid-bind A V DV ; K) E2).\nstep/fletr : step \n              (<< (f/fluid-bind A Vbound DVbound ; K) V DV)\n              (<< K V DV).\nstep/susp  : step\n              (>> K (tm/susp E))\n              (<< K (tm/susp E) v/susp).\nstep/ususp : step\n              (>> K (tm/unsusp E))\n              (>> (f/unsusp --- ; K) E).\nstep/ususpr: step\n              (<< (f/unsusp --- ; K) (tm/susp E) _) \n              (>> K E).\n\n\n%{ == Progress == }%\n\n%{ === Not stuck === }%\n\nnstuck : state -> type.\nnstuck/step  : step E E' -> nstuck E.\nnstuck/final : nstuck (<< emp V DV).\n\n%{ === First deep stack access theorem === }%\n\naccess-stack : in A Bs  \n                -> ofstack K T Bs \n                -> lookup A K E Dv \n                -> fluidty A Tf\n                -> of E Tf #\n                -> type.\n%mode access-stack +A +B -C -D -E.\nread-stack : eq-or-in A B Cs\n              -> decidable-fluid A B \n              -> offrame (f/fluid-bind B E Dv) T (B , Cs) T Cs\n              -> ofstack K T Cs\n              -> lookup A (f/fluid-bind B E Dv ; K) Ev Dval\n              -> fluidty A Tf\n              -> of Ev Tf # -> type.\n%mode read-stack +A +G +B +C -D -E -F.\n- : read-stack eq-or-in/eq _ (offrame/fluid-bind \n                              (Dfluid: fluidty B Tf) \n                              (Dval: of E Tf #)) _\n     (lookup/hit eqfluid/refl) Dfluid Dval.\n- : read-stack _ (decidable-fluid/eq) (offrame/fluid-bind \n                              (Dfluid: fluidty B Tf) \n                              (Dval: of E Tf #)) _\n     (lookup/hit eqfluid/refl) Dfluid Dval.\n- : read-stack (eq-or-in/in In) (decidable-fluid/neq Neq) _ Dstack \n     (lookup/miss Neq Look) Dfluid Dval\n     <- access-stack In Dstack Look Dfluid Dval.\n\n- : access-stack (In: in A Bs) (ofstack/weaken Dt (Sub: subset Bs Cs))\n     Lookup Df Dvt\n     <- in-subset In Sub In'\n     <- access-stack In' Dt Lookup Df Dvt.\n- : access-stack In (ofstack/frame (offrame/app1 _) Dt) \n     (lookup/app1 Look) Df Dvt\n     <- access-stack In Dt Look Df Dvt.\n- : access-stack In (ofstack/frame (offrame/app2 _) Dt) \n     (lookup/app2 Look) Df Dvt\n     <- access-stack In Dt Look Df Dvt.\n- : access-stack In (ofstack/frame (offrame/s) Dt) \n     (lookup/s Look) Df Dvt\n     <- access-stack In Dt Look Df Dvt.\n- : access-stack In (ofstack/frame (offrame/if _ _) Dt)\n     (lookup/if Look) Df Dvt\n     <- access-stack In Dt Look Df Dvt.\n- : access-stack In (ofstack/frame (offrame/fluid-let _ _) Dt)\n     (lookup/flet Look) Df Dvt\n     <- access-stack In Dt Look Df Dvt.\n- : access-stack (In : in A (B , Cs)) (ofstack/frame Dframe Dstack)\n     Look Df Dvt\n     <- in-inversion In (Deq-or-in : eq-or-in A B Cs)\n     <- eq-or-neq-total A B (Deq-or-neq : decidable-fluid A B)\n     <- read-stack Deq-or-in Deq-or-neq Dframe Dstack \n        (Look: lookup A (f/fluid-bind B _ _ ; _) _ _)\n        (Df: fluidty A Tf) \n        (Dvt: of E Tf #).\n- : access-stack In (ofstack/frame (offrame/unsusp (Merge: merge As Bs Cs)) \n                       (Dt: ofstack K T Cs))\n     (lookup/ususp Look) Df Dvt\n     <- in-merge2 In Merge In'\n     <- access-stack In' (Dt: ofstack K T Cs) Look Df Dvt.\n%worlds () (access-stack _ _ _ _ _) (read-stack _ _ _ _ _ _ _).\n%total (T S) (access-stack _ T _ _ _) (read-stack _ _ _ S _ _ _).\n\n\n\n%{ === Canonical Forms === }%\n\ncanon-arrow : of E1 (ty/arrow T1 T2) Bs \n               -> v E1\n               -> eqtm E1 (tm/lam T1 ([x] E x)) -> type.\n- : canon-arrow (of/weaken T _) Dv Eq <- canon-arrow T Dv Eq.\n- : canon-arrow (of/lam _) v/lam eqtm/refl.\n%mode canon-arrow +A +B -C. \n%worlds () (canon-arrow _ _ _). \n%total T (canon-arrow T _ _).\n\nz-or-s : tm -> type.\nz-or-s/z : z-or-s tm/z.\nz-or-s/s : z-or-s (tm/s E).\n\ncanon-nat : of E1 ty/nat Bs \n               -> v E1\n               -> z-or-s E1 -> type.\n- : canon-nat (of/weaken T _) Dv Eq <- canon-nat T Dv Eq.\n- : canon-nat (of/z) (v/z) (z-or-s/z).\n- : canon-nat (of/s _) (v/s _) (z-or-s/s).\n%mode canon-nat +A +B -C. \n%worlds () (canon-nat _ _ _). \n%total T (canon-nat T _ _).\n\ncanon-mayuse : of E1 (ty/mayuse T As) Bs\n                -> v E1\n                -> eqtm E1 (tm/susp E) -> type.\n- : canon-mayuse (of/weaken T _) Dv Eq <- canon-mayuse T Dv Eq.\n- : canon-mayuse (of/susp _) v/susp eqtm/refl.\n%mode canon-mayuse +A +B -C.\n%worlds () (canon-mayuse _ _ _).\n%total T (canon-mayuse T _ _).\n\n\n%{ === Progress === }%\n\nprogress>> : ofstack K T Bs \n              -> of E T Bs\n              -> step (>> K E) S' -> type.\n\n- : progress>> TK (of/weaken TE Sub) Step\n     <- progress>> (ofstack/weaken TK Sub) TE Step.\n- : progress>> TK (of/lam _) step/lam.\n- : progress>> TK (of/app _ _) step/app1.\n- : progress>> TK (of/z) step/z.\n- : progress>> TK (of/s _) step/s.\n- : progress>> TK (of/if _ _ _) step/if.\n- : progress>> TK (of/fix _) step/fix.\n- : progress>> TK (of/access (TA : fluidty A T)) (step/access Look)\n     <- access-stack in/z TK Look _ _.\n- : progress>> TK (of/fluid-let _ _ _) step/flet1.\n- : progress>> TK (of/susp _) step/susp.\n- : progress>> TK (of/unsusp _ _) step/ususp. \n\n%mode progress>> +A +B -C.\n%worlds () (progress>> _ _ _). \n%total T (progress>> _ T _).\n\nprogress<< : ofstack K T Bs\n              -> of E T Bs\n              -> {Dv : v E} nstuck (<< K E Dv) -> type.\n%mode progress<< +A +B +C -D.\n\n- : progress<< (ofstack/weaken TK Sub) TE Dv NS\n     <- progress<< TK (of/weaken TE Sub) Dv NS.\n- : progress<< (ofstack/emp) TE Dv nstuck/final.\n- : progress<< (ofstack/frame (offrame/app1 TE2) TK) TE1 Dv \n     (nstuck/step step/app2).\n\np1 : eqtm E1 (tm/lam T1 ([x] E x)) \n      -> {Dv}{K}{E2}{Dv'}\n         step (<< (f/app2 E1 Dv --- ; K) E2 Dv') S' -> type.\n- : p1 _ _ _ _ _ step/appr. \n%mode p1 +A +B +C +D +E -F.\n%worlds () (p1 _ _ _ _ _ _). %total {} (p1 _ _ _ _ _ _). \n\n- : progress<< (ofstack/frame\n                  (offrame/app2 TE1 : offrame (f/app2 E1 Dv ---) T' Bs T Bs) TK)\n     TE2 _ (nstuck/step Step)\n     <- canon-arrow TE1 Dv Eq\n     <- p1 Eq _ _ _ _ Step.\n\n- : progress<< (ofstack/frame offrame/s TK) TE1 Dv (nstuck/step step/sr).\n\np2 : z-or-s E\n      -> {E1}{E2}{K}{Dv}\n         step (<< (f/if --- E1 E2 ; K) E Dv) S' -> type.\n- : p2 z-or-s/z _ _ _ _ step/ifz.\n- : p2 z-or-s/s _ _ _ _ step/ifs.\n%mode p2 +A +B +C +D +F -E. \n%worlds () (p2 _ _ _ _ _ _). %total {} (p2 _ _ _ _ _ _).\n\n- : progress<< (ofstack/frame (offrame/if _ _) TK) TE Dv (nstuck/step Step)\n     <- canon-nat TE Dv Eq\n     <- p2 Eq _ _ _ _ Step.\n- : progress<< (ofstack/frame (offrame/fluid-let _ _) TK) TE Dv \n     (nstuck/step step/flet2).\n- : progress<< (ofstack/frame (offrame/fluid-bind _ _) TK) TE Dv\n     (nstuck/step step/fletr).\n\n%{ Note: when I write in <tt>eqtm E (tm/susp E)</tt> here and then\ntry to check the case, the error I get is worrisome, occurs-check wise. }%\n\np3 : eqtm E (tm/susp E')\n      -> {K}{Dv}\n         step (<< (f/unsusp --- ; K) E Dv) S' -> type.\n- : p3 eqtm/refl _ _ step/ususpr. \n%mode p3 +A +B +D -C. %worlds () (p3 _ _ _ _). %total {} (p3 _ _ _ _).\n\n- : progress<< (ofstack/frame (offrame/unsusp _) TK) TE Dv (nstuck/step Step)\n     <- canon-mayuse TE Dv Eq\n     <- p3 Eq _ _ Step.\n\n%worlds () (progress<< _ _ _ _).\n%total T (progress<< T _ _ _).\n\nprogress : ok S -> nstuck S -> type.\n- : progress (ok>> TK TE) (nstuck/step Step) <- progress>> TK TE Step.\n- : progress (ok<< TK TE Dv) NS <- progress<< TK TE Dv NS.\n%mode progress +A -B.\n%worlds () (progress _ _).\n%total {} (progress _ _).\n\n%{ == Preservation == }%\n\n%{ === Second deep stack access theorem === }%\n\naccess-stack' : in A Bs  \n                -> ofstack K T Bs \n                -> lookup A K E Dv \n                -> fluidty A Tf\n                -> of E Tf #\n                -> type.\n%mode access-stack' +A +B +C -D -E.\nread-stack' : eq-or-in A B Cs\n              -> decidable-fluid A B \n              -> offrame (f/fluid-bind B E Dv) T (B , Cs) T Cs\n              -> ofstack K T Cs\n              -> lookup A (f/fluid-bind B E Dv ; K) Ev Dval\n              -> fluidty A Tf\n              -> of Ev Tf # -> type.\n%mode read-stack' +A +G +B +C +D -E -F.\n- : read-stack' eq-or-in/eq _ (offrame/fluid-bind \n                              (Dfluid: fluidty B Tf) \n                              (Dval: of E Tf #)) _\n     (lookup/hit eqfluid/refl) Dfluid Dval.\n- : read-stack' _ (decidable-fluid/eq) (offrame/fluid-bind \n                              (Dfluid: fluidty B Tf) \n                              (Dval: of E Tf #)) _\n     (lookup/hit eqfluid/refl) Dfluid Dval.\n- : read-stack' (eq-or-in/in In) (decidable-fluid/neq Neq) _ Dstack \n     (lookup/miss Neq Look) Dfluid Dval\n     <- access-stack' In Dstack Look Dfluid Dval.\n\n- : access-stack' (In: in A Bs) (ofstack/weaken Dt (Sub: subset Bs Cs))\n     Lookup Df Dvt\n     <- in-subset In Sub In'\n     <- access-stack' In' Dt Lookup Df Dvt.\n- : access-stack' In (ofstack/frame (offrame/app1 _) Dt) \n     (lookup/app1 Look) Df Dvt\n     <- access-stack' In Dt Look Df Dvt.\n- : access-stack' In (ofstack/frame (offrame/app2 _) Dt) \n     (lookup/app2 Look) Df Dvt\n     <- access-stack' In Dt Look Df Dvt.\n- : access-stack' In (ofstack/frame (offrame/s) Dt) \n     (lookup/s Look) Df Dvt\n     <- access-stack' In Dt Look Df Dvt.\n- : access-stack' In (ofstack/frame (offrame/if _ _) Dt)\n     (lookup/if Look) Df Dvt\n     <- access-stack' In Dt Look Df Dvt.\n- : access-stack' In (ofstack/frame (offrame/fluid-let _ _) Dt)\n     (lookup/flet Look) Df Dvt\n     <- access-stack' In Dt Look Df Dvt.\n- : access-stack' (In : in A (B , Cs)) (ofstack/frame Dframe Dstack)\n     Look Df Dvt\n     <- in-inversion In (Deq-or-in : eq-or-in A B Cs)\n     <- eq-or-neq-total A B (Deq-or-neq : decidable-fluid A B)\n     <- read-stack' Deq-or-in Deq-or-neq Dframe Dstack \n        (Look: lookup A (f/fluid-bind B _ _ ; _) _ _)\n        (Df: fluidty A Tf) \n        (Dvt: of E Tf #).\n- : access-stack' In (ofstack/frame (offrame/unsusp (Merge: merge As Bs Cs)) \n                       (Dt: ofstack K T Cs))\n     (lookup/ususp Look) Df Dvt\n     <- in-merge2 In Merge In'\n     <- access-stack' In' (Dt: ofstack K T Cs) Look Df Dvt.\n%worlds () (access-stack' _ _ _ _ _) (read-stack' _ _ _ _ _ _ _).\n%total (T S) (access-stack' _ T _ _ _) (read-stack' _ _ _ S _ _ _).\n\n%{ === Effect-free value theorem === }%\n\n%{ Yipes! This is actually a complicated induction principle, because we need \nto induct on two things at once - either the typing derivation or the\nvalue derivation gets smaller with every recursive call. Perhaps this could\nbe factored out into two non-mutually-recursive lemmas? }%\n\neffect-value : v E -> of E T Bs -> of E T # -> type.\n- : effect-value V (of/weaken T Sub) T'\n     <- effect-value V T T'. \n- : effect-value v/lam T T.\n- : effect-value v/susp T T.\n- : effect-value v/z T T.\n- : effect-value (v/s V) (of/s T) (of/s T')\n     <- effect-value V T T'.\n%mode effect-value +A +B -C.\n%worlds () (effect-value _ _ _).\n%total [S T] (effect-value S T _).\n\n\n\n%{ === Inversion === }%\n\ninv-lam : of (tm/lam T1 ([x] E x)) T Bs \n           -> eqty T (ty/arrow T1 T2)\n           -> ({x} of x T1 # -> of (E x) T2 #) -> type.\n- : inv-lam (of/weaken T Sub) Eq Tf\n     <- inv-lam T Eq Tf.\n- : inv-lam (of/lam F) eqty/refl F.\n%mode inv-lam +A -B -C. %worlds () (inv-lam _ _ _). %total T (inv-lam T _ _).\n\ninv-app : of (tm/app E1 E2) T Cs\n           -> subset Bs Cs\n           -> of E1 (ty/arrow T' T) Bs\n           -> of E2 T' Bs -> type.\n- : inv-app (of/weaken T Sub') Sub'' T1 T2 \n     <- inv-app T Sub T1 T2\n     <- subset-trans Sub Sub' Sub''.\n- : inv-app (of/app T1 T2) Sub T1 T2 <- subset-refl _ Sub.\n%mode inv-app +A -D -B -C. %worlds () (inv-app _ _ _ _).\n%total T (inv-app T _ _ _).\n\ninv-s : of (tm/s E) T Cs \n         -> subset Bs Cs\n         -> eqty T ty/nat \n         -> of E ty/nat Bs -> type.\n- : inv-s (of/weaken T Sub') Sub'' Eq T'\n     <- inv-s T Sub Eq T'\n     <- subset-trans Sub Sub' Sub''.\n- : inv-s (of/s T) Sub eqty/refl T <- subset-refl _ Sub.\n%mode inv-s +A -B -D -C. %worlds () (inv-s _ _ _ _). %total T (inv-s T _ _ _).\n\ninv-if : of (tm/if E E1 E2) T Cs\n          -> subset Bs Cs\n          -> of E ty/nat Bs \n          -> of E1 T Bs\n          -> ({x} of x ty/nat # -> of (E2 x) T Bs) -> type.\n- : inv-if (of/weaken Tif Sub') Sub'' T T1 T2\n     <- inv-if Tif Sub T T1 T2\n     <- subset-trans Sub Sub' Sub''.\n- : inv-if (of/if T T1 T2) Sub T T1 T2 <- subset-refl _ Sub.\n%mode inv-if +A -B -C -D -E. %worlds () (inv-if _ _ _ _ _).\n%total T (inv-if T _ _ _ _).\n\ninv-fix : of (tm/fix T' F) T Cs\n           -> eqty T T'\n           -> of (tm/fix T F) T #\n           -> ({x} of x T # -> of (F x) T #)\n           -> type.\n- : inv-fix (of/weaken Tfix Sub) Eq Tfix' Tfn\n     <- inv-fix Tfix Eq Tfix' Tfn.\n- : inv-fix (of/fix T) eqty/refl (of/fix T) T.\n%mode inv-fix +A -B -C -D. \n%worlds () (inv-fix _ _ _ _). \n%total T (inv-fix T _ _ _).\n\ninv-access : of (tm/access A) T Cs\n              -> in A Cs\n              -> fluidty A T\n              -> type.\n- : inv-access (of/weaken Taccess Sub) In' FT\n     <- inv-access Taccess In FT\n     <- in-subset In Sub In'.\n- : inv-access (of/access FT) in/z FT.\n%mode inv-access +A -B -C. \n%worlds () (inv-access _ _ _). \n%total T (inv-access T _ _).\n\ninv-fluid-let : of (tm/fluid-let A E1 E2) T Cs\n                 -> subset Bs Cs\n                 -> fluidty A Tf\n                 -> of E1 Tf Bs\n                 -> of E2 T (A , Bs) -> type.\n- : inv-fluid-let (of/weaken Tfluid Sub') Sub'' FT T1 T2\n     <- inv-fluid-let Tfluid Sub FT T1 T2\n     <- subset-trans Sub Sub' Sub''.\n- : inv-fluid-let (of/fluid-let FT T1 T2) Sub FT T1 T2\n     <- subset-refl _ Sub.\n%mode inv-fluid-let +A -B -C -D -E.\n%worlds () (inv-fluid-let _ _ _ _ _).\n%total T (inv-fluid-let T _ _ _ _).\n\ninv-unsusp : of (tm/unsusp E) T Ds\n              -> subset Cs Ds\n              -> of E (ty/mayuse T As) Bs\n              -> merge As Bs Cs -> type.\n- : inv-unsusp (of/weaken Tun Sub') Sub'' T M\n     <- inv-unsusp Tun Sub T M\n     <- subset-trans Sub Sub' Sub''.\n- : inv-unsusp (of/unsusp Merge T) Sub T Merge\n     <- subset-refl _ Sub.\n%mode inv-unsusp +A -B -C -D.\n%worlds () (inv-unsusp _ _ _ _).\n%total T (inv-unsusp T _ _ _).\n\ninvf-app1 : ofstack (f/app1 --- E2 ; K) T Bs\n            -> subset Bs Cs\n            -> eqty T (ty/arrow T1 T2)\n            -> ofstack K T2 Cs\n            -> of E2 T1 Cs -> type.\n- : invf-app1 (ofstack/weaken TK (Sub: subset As Bs))\n     (Sub'': subset As Cs) Eq TK' TE'\n     <- invf-app1 TK (Sub': subset Bs Cs) Eq TK' TE'\n     <- subset-trans Sub Sub' Sub''.\n- : invf-app1 (ofstack/frame (offrame/app1 (TE : of E2 T1 Cs)) \n                (TK: ofstack K T2 Cs)) Sub eqty/refl TK TE\n     <- subset-refl _ Sub.\n%mode invf-app1 +A -E -B -C -D. \n%worlds () (invf-app1 _ _ _ _ _).\n%total T (invf-app1 T _ _ _ _).\n\ninvf-app2 : ofstack (f/app2 E1 Dv --- ; K) Targ Bs\n            -> subset Bs Cs\n            -> of E1 (ty/arrow Targ Tres) Cs\n            -> ofstack K Tres Cs -> type.\n- : invf-app2 (ofstack/weaken TK Sub) Sub'' TE' TK'\n     <- invf-app2 TK Sub' TE' TK'\n     <- subset-trans Sub Sub' Sub''.\n- : invf-app2 (ofstack/frame (offrame/app2 TE) TK) Sub \n     (of/weaken TE subset/z) TK \n     <- subset-refl _ Sub.\n%mode invf-app2 +A -B -C -D .\n%worlds () (invf-app2 _ _ _ _).\n%total T (invf-app2 T _ _ _).\n\ninvf-s : ofstack (f/s --- ; K) T Bs\n         -> subset Bs Cs\n         -> eqty T ty/nat\n         -> ofstack K ty/nat Cs -> type.\n- : invf-s (ofstack/weaken TK Sub) Sub'' Eq TK'\n     <- invf-s TK Sub' Eq TK'\n     <- subset-trans Sub Sub' Sub''.\n- : invf-s (ofstack/frame offrame/s TK) Sub eqty/refl TK\n     <- subset-refl _ Sub.\n%mode invf-s +A -B -C -D.\n%worlds () (invf-s _ _ _ _).\n%total T (invf-s T _ _ _).\n\ninvf-if : ofstack (f/if --- E1 E2 ; K) Tn Bs\n           -> subset Bs Cs\n           -> eqty Tn ty/nat\n           -> of E1 T Cs\n           -> ({x} of x ty/nat # -> of (E2 x) T Cs)\n           -> ofstack K T Cs -> type.\n- : invf-if (ofstack/weaken TK Sub) Sub'' Eq TE1 TE2 TK'\n     <- invf-if TK Sub' Eq TE1 TE2 TK'\n     <- subset-trans Sub Sub' Sub''.\n- : invf-if (ofstack/frame (offrame/if T1 T2) TK) Sub eqty/refl T1 T2 TK\n     <- subset-refl _ Sub.\n%mode invf-if +A -B -C -D -E -F.\n%worlds () (invf-if _ _ _ _ _ _).\n%total T (invf-if T _ _ _ _ _).\n\ninvf-fluid-let : ofstack (f/fluid-let A --- E2 ; K) Tf Bs\n                  -> subset Bs Cs\n                  -> fluidty A Tf\n                  -> of E2 T (A , Cs)\n                  -> ofstack K T Cs -> type.\n- : invf-fluid-let (ofstack/weaken TK Sub) Sub'' TF T2 TK'\n     <- invf-fluid-let TK Sub' TF T2 TK'\n     <- subset-trans Sub Sub' Sub''.\n- : invf-fluid-let (ofstack/frame (offrame/fluid-let FT T2) TK) Sub FT T2 TK\n     <- subset-refl _ Sub.\n%mode invf-fluid-let +A -B -C -D -E.\n%worlds () (invf-fluid-let _ _ _ _ _).\n%total T (invf-fluid-let T _ _ _ _).\n\ninvf-fluid-bind : ofstack (f/fluid-bind A E Dv ; K) T Bs\n                  -> subset Bs (A , Cs)\n                  -> ofstack K T Cs -> type.\n- : invf-fluid-bind (ofstack/weaken TK Sub) Sub'' TK'\n     <- invf-fluid-bind TK Sub' TK'\n     <- subset-trans Sub Sub' Sub''.\n- : invf-fluid-bind (ofstack/frame (offrame/fluid-bind _ _) TK) \n     (subset/s in/z Sub') TK\n     <- subset-refl _ Sub\n     <- subset-weaken _ Sub Sub'.\n%mode invf-fluid-bind +A -B -C.\n%worlds () (invf-fluid-bind _ _ _).\n%total T (invf-fluid-bind T _ _).\n\n%{ === Preservation === }%\n\npreservation : step S S' -> ok S -> ok S' -> type.\n%mode preservation +A +B -C.\n\n- : preservation step/lam (ok>> TK TE) (ok<< TK TE v/lam).\n- : preservation step/app1 (ok>> TK TE) \n     (ok>> (ofstack/frame (offrame/app1 T2) (ofstack/weaken TK Sub)) T1)\n     <- inv-app TE Sub T1 T2.\np1 : eqty T (ty/arrow T1 T2) -> of E T Bs -> of E (ty/arrow T1 T2) Bs -> type.\n- : p1 eqty/refl T T. \n%mode p1 +A +B -C. %worlds () (p1 _ _ _). %total {} (p1 _ _ _).\n- : preservation step/app2 (ok<< (TK: ofstack (f/app1 --- E2 ; K) T Bs) TE Dv)\n     (ok>> (ofstack/frame (offrame/app2 TE1'') TK') TE2'\n        : ok (>> (f/app2 E1 Dv --- ; K) E2))\n     <- invf-app1 TK (Sub: subset Bs Cs) (Eq: eqty T (ty/arrow T1 T2)) \n         (TK' : ofstack K T2 Cs) (TE2': of E2 T1 Cs)\n     <- p1 Eq TE TE1'\n     <- effect-value Dv TE1' (TE1'': of E1 (ty/arrow T1 T2) #).\np3 : eqty (ty/arrow Ta Tb) (ty/arrow T' T'')\n      -> ofstack K Tb Cs\n      -> ({x} of x T' # -> of (E x) T'' #)\n      -> of E2 Ta #\n      -> ok (>> K (E E2)) -> type.\n- : p3 eqty/refl TK TE1 TE2 (ok>> TK (of/weaken (TE1 _ TE2) subset/z)).\n%mode p3 +A +B +C +D -E. %worlds () (p3 _ _ _ _ _). %total {} (p3 _ _ _ _ _).\n- : preservation step/appr (ok<< TK TE2 Dv) \n     (Ans: ok (>> K (E E2)))\n     <- effect-value Dv TE2 (TE2': of E2 Ta #)\n     <- invf-app2 \n        (TK: ofstack (f/app2 (tm/lam T' E) V --- ; K) Ta Bs) \n        (Sub: subset Bs Cs) \n        (T1 : of (tm/lam T' E) (ty/arrow Ta Tb) Cs) \n        (TK'' : ofstack K Tb Cs)\n     <- inv-lam T1 \n        (Eq: eqty (ty/arrow Ta Tb) (ty/arrow T' T'')) \n        (Tfunc: {x} of x T' # -> of (E x) T'' #)\n     <- p3 Eq TK'' Tfunc TE2' Ans.\n- : preservation step/z (ok>> TK TE) (ok<< TK TE v/z).\np2 : eqty T ty/nat -> ofstack K T Bs -> ofstack K ty/nat Bs -> type.\n- : p2 eqty/refl T T.\n%mode p2 +A +B -C. %worlds () (p2 _ _ _). %total {} (p2 _ _ _).\n- : preservation step/s (ok>> (TK: ofstack E T Bs) TE) \n     (ok>> (ofstack/frame offrame/s (ofstack/weaken TK' Sub)) TE')\n     <- inv-s TE Sub Eq TE'\n     <- p2 Eq TK TK'.\np6 : eqty T ty/nat -> of E T Bs -> of E ty/nat Bs -> type.\n- : p6 eqty/refl T T.\n%mode p6 +A +B -C. %worlds () (p6 _ _ _). %total {} (p6 _ _ _).\n- : preservation step/sr (ok<< TK TE Dv) \n     (ok<< TK' (of/weaken (of/s TE') Sub)  (v/s Dv))\n     <- invf-s (TK: ofstack (f/s --- ; K) T Bs) Sub \n        (Eq: eqty T ty/nat) (TK': ofstack K ty/nat Cs)\n     <- p6 Eq TE TE'.\n- : preservation step/if (ok>> TK TE) \n     (ok>> (ofstack/frame (offrame/if T1 T2) (ofstack/weaken TK Sub)) T)\n     <- inv-if TE Sub T T1 T2.\n- : preservation step/ifz (ok<< TK TE Dv) (ok>> TK' TE1)\n     <- invf-if (TK: ofstack (f/if --- E1 E2 ; K) T Bs) \n        (Sub: subset Bs Cs)\n        (Eq : eqty T ty/nat) \n        (TE1 : of E1 T' Cs) _ (TK' : ofstack K _ Cs).\n- : preservation step/ifs (ok<< TK TE Dv) \n     (ok>> TK' (TE2 _ (of/weaken TN Sub#)))\n     <- invf-if (TK: ofstack (f/if --- E1 E2 ; K) T Bs) \n        (Sub: subset Bs Cs)\n        (Eq : eqty T ty/nat) \n        _ (TE2: {x} of x ty/nat # -> of (E2 x) T' Cs) (TK' : ofstack K T' Cs)\n     <- effect-value Dv TE TE'\n     <- inv-s TE' (Sub# : subset As #) _ (TN: of N ty/nat As).\np6 : eqty T T'\n      -> of (tm/fix T F) T #\n      -> ({x:tm} of x T # -> of (F x) T #)\n      -> of (tm/fix T' F) T #\n      -> ({x:tm} of x T # -> of (F x) T #) -> type.\n- : p6 eqty/refl T F T F.\n%mode p6 +A +B +C -D -E. \n%worlds () (p6 _ _ _ _ _). \n%total {} (p6 _ _ _ _ _).\n- : preservation step/fix (ok>> TK TE)\n     (ok>> TK (of/weaken (Tfn' _ Tfix') subset/z))\n     <- inv-fix (TE: of (tm/fix T' F) T Bs) \n        (Eq: eqty T T') (Tfix: _) Tfn\n     <- p6 Eq Tfix Tfn Tfix' Tfn'.\n\np5 : eqty T T' -> of E T # -> of E T' # -> type.\n- : p5 eqty/refl T T. \n%mode p5 +A +B -C. %worlds () (p5 _ _ _). %total {} (p5 _ _ _).\n- : preservation (step/access (Look : lookup A K V Dv))\n     (ok>> TK TE) (ok<< TK (of/weaken TE'' subset/z) Dv : ok (<< K V Dv))\n     <- inv-access TE (In: in A Bs) (FT: fluidty A T)\n     <- access-stack' In TK Look (FT': fluidty A T') (TE': of V T' #)\n     <- fluidty-uniq FT' FT Eq\n     <- p5 Eq TE' TE''.\n- : preservation step/flet1 (ok>> TK TE) \n     (ok>> (ofstack/frame (offrame/fluid-let FT T2) (ofstack/weaken TK Sub)) T1)\n     <- inv-fluid-let (TE: of (tm/fluid-let A E1 E2) T Cs)\n        (Sub: subset Bs Cs)\n        (FT: fluidty A Tf) \n        (T1: of E1 Tf Bs) \n        (T2: of E2 T (A , Bs)).\n- : preservation step/flet2 (ok<< TK TE Dv) \n     (ok>> (ofstack/frame (offrame/fluid-bind FT TE') TK') T2)\n     <- invf-fluid-let (TK: ofstack (f/fluid-let A --- E2 ; K) Tf Bs)\n        (Sub: subset Bs Cs)\n        (FT: fluidty A Tf)\n        (T2: of E2 T (A , Cs))\n        (TK': ofstack K T Cs)\n     <- effect-value Dv TE (TE': of E1 Tf #).\n- : preservation step/fletr (ok<< TK TE Dv)\n     (ok<< TK' (of/weaken TE' subset/z) Dv)\n     <- effect-value Dv TE TE'\n     <- invf-fluid-bind TK _ TK'.\n- : preservation step/susp (ok>> TK TE) (ok<< TK TE v/susp).\n- : preservation step/ususp (ok>> (TK: ofstack K T Ds) \n                               (TE: of (tm/unsusp E) T Ds)) \n     (ok>> (ofstack/frame \n              (offrame/unsusp (Merge: merge As Bs Cs)) \n              (ofstack/weaken TK (Sub: subset Cs Ds))) \n        (TE': of E (ty/mayuse T As) Bs))\n     <- inv-unsusp TE Sub TE' Merge.\n\ninv-susp : of (tm/susp E) T Cs \n            -> eqty T (ty/mayuse T' As)\n            -> of (tm/susp E) (ty/mayuse T' As) #\n            -> of E T' As -> type.\n- : inv-susp (of/weaken Ts Sub) Eq Ts' T\n     <- inv-susp Ts Eq Ts' T.\n- : inv-susp (of/susp T) eqty/refl (of/susp T) T.\n%mode inv-susp +A -B -C -D. \n%worlds () (inv-susp _ _ _ _). \n%total T (inv-susp T _ _ _).\n\ninvf-unsusp : ofstack (f/unsusp --- ; K) T B's\n               -> subset B's Bs\n               -> eqty T (ty/mayuse T' As)\n               -> merge As Bs Cs\n               -> ofstack K T' Cs -> type.\n- : invf-unsusp (ofstack/weaken TK Sub) Sub'' Eq Merge TK'\n     <- invf-unsusp TK Sub' Eq (Merge: merge As Bs Cs) TK'\n     <- subset-trans Sub Sub' Sub''.\n- : invf-unsusp (ofstack/frame \n                   (offrame/unsusp (Merge: merge As Bs Cs)) \n                   (TK: ofstack K T Cs))\n     Sub eqty/refl Merge TK\n     <- subset-refl Bs Sub.\n%mode invf-unsusp +A -B -C -D -E.\n%worlds () (invf-unsusp _ _ _ _ _).\n%total T (invf-unsusp T _ _ _ _).\n\np7 : eqty T (ty/mayuse T' As)\n   -> eqty T (ty/mayuse T'' As')\n   -> ofstack K T'' Cs -> ofstack K T' Cs -> type.\n- : p7 eqty/refl eqty/refl T T.\n%mode p7 +A +B +C -D. %worlds () (p7 _ _ _ _). %total {} (p7 _ _ _ _).\np8 : eqty T (ty/mayuse T' As)\n   -> eqty T (ty/mayuse T'' As')\n   -> merge As' B's Cs -> merge As B's Cs -> type.\n- : p8 eqty/refl eqty/refl T T.\n%mode p8 +A +B +C -D. %worlds () (p8 _ _ _ _). %total {} (p8 _ _ _ _).\n\n- : preservation step/ususpr (ok<< (TK: ofstack (f/unsusp --- ; K) T Bs)\n                                (TE: of (tm/susp E) T Bs) Dv)\n     (ok>> (ofstack/weaken (TK'' : ofstack K T' Cs) (Sub: subset As Cs))\n        TE')\n     <- inv-susp TE (Eq: eqty T (ty/mayuse T' As)) _ (TE' : of E T' As)\n     <- invf-unsusp TK\n        (Sub': subset Bs B's) \n        (Eq2: eqty T (ty/mayuse T'' As')) \n        (Merge: merge As' B's Cs) \n        (TK' : ofstack K T'' Cs)\n     <- p7 Eq Eq2 TK' TK''\n     <- p8 Eq Eq2 Merge Merge'\n     <- merge-subset1 Merge' Sub.\n\n\n%worlds () (preservation _ _ _).\n%total {} (preservation _ _ _)."
          },
          "sha1": "ce5dh0xe6jj8g00977dpzrvcd184xsd"
        }
      },
      {
        "title": "User:Rsimmons/Handled exceptions",
        "ns": 2,
        "id": 2042,
        "revision": {
          "id": 290194,
          "parentid": 5134,
          "timestamp": "2020-12-18T22:47:29Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "minor": null,
          "comment": "Protected \"[[User:Rsimmons/Handled exceptions]]\" ([Edit=Allow only administrators] (indefinite) [Move=Allow only administrators] (indefinite))",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 15547,
            "#text": "%{ == Syntax == }%\n\n%{ === Types === }%\n\nty : type.\nty/nat : ty.               % nat\nty/arrow : ty -> ty -> ty. % tau1 tau2\nty/mayraise : ty -> ty.    % [*] tau\n\n%{ We have to pick some type associated with exceptions. \nHere, we'll just use nat. }%\n\nty/exn = ty/nat.\n\n%{ ==== Type equality ==== }%\n\neqty : ty -> ty -> type.\neqty/refl : eqty T T.\n\n%{ === Terms === }%\n\ntm : type.\ntm/lam : ty -> (tm -> tm) -> tm.\ntm/app : tm -> tm -> tm.\ntm/z : tm.\ntm/s : tm -> tm.\ntm/if : tm -> tm -> (tm -> tm) -> tm.\ntm/fix : ty -> (tm -> tm) -> tm.\ntm/raise : tm -> tm.\ntm/handle : tm -> (tm -> tm) -> tm.\ntm/susp : tm -> tm.\ntm/unsusp : tm -> tm.\ntm/let : tm -> ty -> (tm -> tm) -> tm = [e][t][f] tm/app (tm/lam t f) e.\n\n\n\n%{ == Static semantics == }%\n\nof : tm -> ty -> type.   % Will not throw exceptions\nof* : tm -> ty -> type.  % May or may not throw exceptions\n\nof*/weaken : of E T -> of* E T.\n\nof/lam : ({x} of x T -> of (E x) T') -> of (tm/lam T E) (ty/arrow T T').\nof/app : of E1 (ty/arrow T T') -> of E2 T -> of (tm/app E1 E2) T'.\nof/z : of tm/z ty/nat.\nof/s : of E ty/nat -> of (tm/s E) ty/nat.\nof/if : of E ty/nat -> of E1 T -> ({x} of x ty/nat -> of (E2 x) T) \n -> of (tm/if E E1 ([x] E2 x)) T. \nof/fix : ({x} of x T -> of (E x) T) -> of (tm/fix T ([x] E x)) T.\nof/handle : of* E T -> ({x} of x ty/exn -> of (E' x) T) \n -> of (tm/handle E ([x] E' x)) T.\nof/susp : of* E T -> of (tm/susp E) (ty/mayraise T).\n\nof*/app : of* E1 (ty/arrow T T') -> of* E2 T -> of* (tm/app E1 E2) T'.\nof*/s : of* E ty/nat -> of* (tm/s E) ty/nat.\nof*/if : of* E ty/nat -> of* E1 T -> ({x} of x ty/nat -> of* (E2 x) T) \n -> of* (tm/if E E1 ([x] E2 x)) T. \nof*/raise : of* E ty/exn -> of* (tm/raise E) T.\nof*/handle : of* E T -> ({x} of x ty/exn -> of* (E' x) T) \n -> of* (tm/handle E ([x] E' x)) T.\nof*/unsusp : of* E (ty/mayraise T) -> of* (tm/unsusp E) T.\n\n\n%{ == Dynamic semantics == }%\n\n%{ === Values === }%\n\nv : tm -> type.\nv/lam : v (tm/lam T ([x] E x)).\nv/z : v tm/z.\nv/s : v E -> v (tm/s E).\nv/susp : v (tm/susp E).\n\n%{ === Small-step evaluation === }%\n\nstep : tm -> tm -> type.\nstep/app1   : step E1 E1' -> step (tm/app E1 E2) (tm/app E1' E2).\nstep/app1x  : v E -> step (tm/app (tm/raise E) _) (tm/raise E).\nstep/app2   : v E1 -> step E2 E2' -> step (tm/app E1 E2) (tm/app E1 E2').\nstep/app2x  : v E -> v E1 -> step (tm/app E1 (tm/raise E)) (tm/raise E).\nstep/appr   : v E2 -> step (tm/app (tm/lam T ([x] E x)) E2) (E E2).\nstep/s      : step E E' -> step (tm/s E) (tm/s E').\nstep/sx     : v E -> step (tm/s (tm/raise E)) (tm/raise E).\nstep/if     : step E E' -> step (tm/if E E1 ([x] E2 x))(tm/if E' E1 ([x] E2 x)).\nstep/ifz    : step (tm/if tm/z E1 ([x] E2 x)) E1.\nstep/ifs    : v E -> step (tm/if (tm/s E) E1 ([x] E2 x)) (E2 E). \nstep/ifx    : v E -> step (tm/if (tm/raise E) E1 ([x] E2 x)) (tm/raise E).\nstep/fix    : step (tm/fix T ([x] E x)) (E (tm/fix T ([x] E x))).\nstep/raise  : step E E' -> step (tm/raise E) (tm/raise E').\nstep/raisex : v E -> step (tm/raise (tm/raise E)) (tm/raise E).\nstep/handle : step E1 E1' -> step (tm/handle E1 ([x] E2 x)) (tm/handle E1' E2).\nstep/handler: v E -> step (tm/handle E _) E.\nstep/handlex: v E -> step (tm/handle (tm/raise E) ([x] E2 x)) (E2 E).\nstep/unsusp : step E E' -> step (tm/unsusp E) (tm/unsusp E').\nstep/unsuspr: step (tm/unsusp (tm/susp E)) E.\nstep/unsuspx: v E -> step (tm/unsusp (tm/raise E)) (tm/raise E).\n\n\n\n%{ == Progress == }%\n\n%{ === Not stuck === }%\n\nnstuck : tm -> type.\nnstuck/step  : step E E' -> nstuck E.\nnstuck/value : v E -> nstuck E.\n\nnstuck* : tm -> type.\nnstuck*/step  : step E E' -> nstuck* E.\nnstuck*/value : v E -> nstuck* E.\nnstuck*/raise : v E -> nstuck* (tm/raise E).\n\nns-weaken : nstuck E -> nstuck* E -> type.\n- : ns-weaken (nstuck/step E) (nstuck*/step E).\n- : ns-weaken (nstuck/value V) (nstuck*/value V).\n%mode ns-weaken +A -B. %worlds () (ns-weaken _ _). %total {} (ns-weaken _ _).\n\n%{ === Mobile value === }%\n\n%{ This theorem really isn't as interesting as its name makes\nit sound, though it is necessary in one place. Otherwise,\nall of the little factoring lemmas are only case analysis, not induction. }%\n\nmobile : v E -> of* E T -> of E T -> type.\n- : mobile v/lam (of*/weaken (of/lam F)) (of/lam F).\n- : mobile v/z (of*/weaken of/z) of/z.\n- : mobile (v/s V) (of*/weaken (of/s S)) (of/s S).\n- : mobile (v/s V) (of*/s S) (of/s S') <- mobile V S S'.\n- : mobile v/susp (of*/weaken (of/susp T)) (of/susp T).\n%mode mobile +A +B -C. %worlds () (mobile _ _ _). %total T (mobile T _ _).\n\n%{ === Progress === }%\n\nprogress : of E T -> nstuck E -> type.\nprogress* : of* E T -> nstuck* E -> type.\n%mode progress +A -B.\n%mode progress* +A -B.\n\n- : progress* (of*/weaken T) NS* <- progress T NS <- ns-weaken NS NS*.\n\n- : progress (of/lam _) (nstuck/value v/lam).\np0 : of E (ty/arrow T1 T2)\n      -> nstuck E -> nstuck E' -> nstuck (tm/app E E') -> type.\n- : p0 _ (nstuck/step E) _ (nstuck/step (step/app1 E)).\n- : p0 _ (nstuck/value V) (nstuck/step E) (nstuck/step (step/app2 V E)).\n- : p0 (of/lam _) (nstuck/value _) (nstuck/value V) (nstuck/step (step/appr V)).\n%mode p0 +A +B +C -D. %worlds () (p0 _ _ _ _). %total {} (p0 _ _ _ _).\n- : progress (of/app T1 T2) NS \n     <- progress T1 NS1 <- progress T2 NS2 <- p0 T1 NS1 NS2 NS.\n- : progress of/z (nstuck/value v/z).\np1 : of E ty/nat -> nstuck E -> nstuck (tm/s E) -> type.\n- : p1 _ (nstuck/step E) (nstuck/step (step/s E)).\n- : p1 _ (nstuck/value V) (nstuck/value (v/s V)).\n%mode p1 +A +B -C. %worlds () (p1 _ _ _). %total {} (p1 _ _ _). \n- : progress (of/s T) NS <- progress T NS1 <- p1 T NS1 NS.\np2 : {E1}{E2} of E ty/nat -> nstuck E -> nstuck (tm/if E E1 ([x] E2 x)) -> type.\n- : p2 _ _ _ (nstuck/step E) (nstuck/step (step/if E)).\n- : p2 _ _ _ (nstuck/value v/z) (nstuck/step step/ifz).\n- : p2 _ _ _ (nstuck/value (v/s V)) (nstuck/step (step/ifs V)).\n%mode p2 +E +F +A +B -C. %worlds () (p2 _ _ _ _ _). %total {} (p2 _ _ _ _ _).\n- : progress (of/if T T1 T2) NS <- progress T NS1 <- p2 _ _ T NS1 NS.\n- : progress (of/fix T) (nstuck/step step/fix).\np3 : {E'} of* E T -> nstuck* E -> nstuck (tm/handle E E') -> type.\n- : p3 _ _ (nstuck*/step E) (nstuck/step (step/handle E)).\n- : p3 _ _ (nstuck*/value V) (nstuck/step (step/handler V)).\n- : p3 _ _ (nstuck*/raise V) (nstuck/step (step/handlex V)).\n%mode p3 +A +B +C -D. %worlds () (p3 _ _ _ _). %total {} (p3 _ _ _ _).\n- : progress (of/handle T T2) NS <- progress* T NS1 <- p3 _ T NS1 NS.\n- : progress (of/susp _) (nstuck/value v/susp).\n\np9 : of* E (ty/arrow T1 T2)\n      -> nstuck* E -> nstuck* E' -> nstuck* (tm/app E E') -> type.\n- : p9 _ (nstuck*/step E) _ (nstuck*/step (step/app1 E)).\n- : p9 _ (nstuck*/raise V) _ (nstuck*/step (step/app1x V)).\n- : p9 _ (nstuck*/value V) (nstuck*/step E) (nstuck*/step (step/app2 V E)).\n- : p9 _ (nstuck*/value V') (nstuck*/raise V) (nstuck*/step (step/app2x V V')).\n- : p9 (of*/weaken T) (nstuck*/value V1) (nstuck*/value V2) NS*\n     <- p0 T (nstuck/value V1) (nstuck/value V2) NS <- ns-weaken NS NS*.\n%mode p9 +A +B +C -D. %worlds () (p9 _ _ _ _). %total {} (p9 _ _ _ _).\n- : progress* (of*/app T1 T2) NS \n     <- progress* T1 NS1 <- progress* T2 NS2 <- p9 T1 NS1 NS2 NS.\np5 : of* E ty/nat -> nstuck* E -> nstuck* (tm/s E) -> type.\n- : p5 _ (nstuck*/step E) (nstuck*/step (step/s E)).\n- : p5 _ (nstuck*/value V) (nstuck*/value (v/s V)).\n- : p5 _ (nstuck*/raise V) (nstuck*/step (step/sx V)).\n%mode p5 +A +B -C. %worlds () (p5 _ _ _). %total {} (p5 _ _ _).\n- : progress* (of*/s T) NS <- progress* T NS1 <- p5 T NS1 NS.\np6 : {E1}{E2} of* E ty/nat -> nstuck* E -> nstuck* (tm/if E E1 E2) -> type.\n- : p6 _ _ _ (nstuck*/step E) (nstuck*/step (step/if E)).\n- : p6 _ _ T* (nstuck*/value V) NS*\n     <- mobile V T* T <- p2 _ _ T (nstuck/value V) NS <- ns-weaken NS NS*.\n- : p6 _ _ _ (nstuck*/raise V) (nstuck*/step (step/ifx V)).\n%mode p6 +A +B +C +D -E. %worlds () (p6 _ _ _ _ _). %total {} (p6 _ _ _ _ _).\n- : progress* (of*/if T T1 T2) NS <- progress* T NS1 <- p6 _ _ T NS1 NS.\npA : nstuck* E -> nstuck* (tm/raise E) -> type.\n- : pA (nstuck*/step E) (nstuck*/step (step/raise E)).\n- : pA (nstuck*/value V) (nstuck*/raise V).\n- : pA (nstuck*/raise V) (nstuck*/step (step/raisex V)).\n%mode pA +A -B. %worlds () (pA _ _). %total {} (pA _ _).\n- : progress* (of*/raise T) NS <- progress* T NS1 <- pA NS1 NS.\n- : progress* (of*/handle T T2) NS \n     <- progress* T NS1 <- p3 _ T NS1 NS* <- ns-weaken NS* NS.\np7 : v E -> of E (ty/mayraise T) -> step (tm/unsusp E) E' -> type.\n- : p7 _ _ step/unsuspr.\n%mode p7 +A +B -C. %worlds () (p7 _ _ _). %total {} (p7 _ _ _).\np8 : of* E (ty/mayraise T) -> nstuck* E -> nstuck* (tm/unsusp E) -> type.\n- : p8 _ (nstuck*/step E) (nstuck*/step (step/unsusp E)).\n- : p8 (of*/weaken T) (nstuck*/value V) (nstuck*/step E) <- p7 V T E.\n- : p8 _ (nstuck*/raise V) (nstuck*/step (step/unsuspx V)).\n%mode p8 +A +B -C. %worlds () (p8 _ _ _). %total {} (p8 _ _ _).\n- : progress* (of*/unsusp T) NS <- progress* T NS1 <- p8 T NS1 NS.\n\n%worlds () (progress _ _) (progress* _ _). \n%total (T T*) (progress T _) (progress* T* _).\n\n\n%{ == Preservation == }%\n\n%{ === Inversion === }%\n\ninv-lam : of* (tm/lam T' E) T\n           -> ({x} of x T' -> of (E x) T'') -> eqty T (ty/arrow T' T'') -> type.\n- : inv-lam (of*/weaken (of/lam F)) F eqty/refl.\n%mode inv-lam +A -B -C. %worlds () (inv-lam _ _ _). %total {} (inv-lam _ _ _).\n\ninv-app : of* (tm/app E1 E2) T -> of* E1 (ty/arrow T' T) -> of* E2 T' -> type.\n- : inv-app (of*/app T1 T2) T1 T2.\n- : inv-app (of*/weaken (of/app T1 T2)) (of*/weaken T1) (of*/weaken T2).\n%mode inv-app +A -B -C. %worlds () (inv-app _ _ _). %total {} (inv-app _ _ _).\n\ninv-s : of* (tm/s E) T -> of* E ty/nat -> eqty T ty/nat -> type.\n- : inv-s (of*/s T) T eqty/refl.\n- : inv-s (of*/weaken (of/s T)) (of*/weaken T) eqty/refl.\n%mode inv-s +A -B -C. %worlds () (inv-s _ _ _). %total {} (inv-s _ _ _).\n\ninv-if : of* (tm/if E E1 E2) T \n   -> of* E ty/nat -> of* E1 T -> ({x} of x ty/nat -> of* (E2 x) T) -> type.\n- : inv-if (of*/if T T1 T2) T T1 T2.\n- : inv-if (of*/weaken (of/if T T1 T2)) \n     (of*/weaken T) (of*/weaken T1) ([x][d] of*/weaken (T2 x d)).\n%mode inv-if +A -B -C -D. %worlds () (inv-if _ _ _ _). \n%total {} (inv-if _ _ _ _).\n\ninv-raise : of* (tm/raise E) T -> of* E ty/exn -> type.\n- : inv-raise (of*/raise T) T.\n%mode inv-raise +A -B. %worlds () (inv-raise _ _). %total {} (inv-raise _ _).\n\ninv-handle : of* (tm/handle E ([x] H x)) T \n              -> of* E T -> ({x} of x ty/exn -> of* (H x) T) -> type.\n- : inv-handle (of*/handle T H) T H.\n- : inv-handle (of*/weaken (of/handle T H)) T\n     ([x][d] (of*/weaken (H x d))).\n%mode inv-handle +A -B -C. %worlds () (inv-handle _ _ _). \n%total {} (inv-handle _ _ _).\n\ninv-susp : of* (tm/susp E) T -> of* E T' -> eqty T (ty/mayraise T') -> type.\n- : inv-susp (of*/weaken (of/susp T)) T eqty/refl.\n%mode inv-susp +A -B -C. %worlds () (inv-susp _ _ _). \n%total {} (inv-susp _ _ _).\n\ninv-unsusp : of* (tm/unsusp E) T -> of* E (ty/mayraise T) -> type.\n- : inv-unsusp (of*/unsusp T) T.\n%mode inv-unsusp +A -B. %worlds () (inv-unsusp _ _). %total {} (inv-unsusp _ _).\n\n%{ === Preservation === }%\n\npreservation: step E E' -> of E T -> of E' T -> type.\npreservation*: step E E' -> of* E T -> of* E' T -> type.\n%mode preservation +A +B -C.\n%mode preservation* +A +B -C.\n\n%{ ==== Application ==== }%\n\n- : preservation (step/app1 E) (of/app T1 T2) (of/app T1' T2)\n     <- preservation E T1 T1'.\n- : preservation (step/app2 V E) (of/app T1 T2) (of/app T1 T2')\n     <- preservation E T2 T2'.\n- : preservation (step/appr V) (of/app (of/lam Tf) (T2 : of E T)) (Tf E T2).\n\n- : preservation* (step/app1 E) T (of*/app T1' T2)\n     <- inv-app T T1 T2 <- preservation* E T1 T1'.\n- : preservation* (step/app1x V) T (of*/raise Texn)\n     <- inv-app T T1 T2 <- inv-raise T1 Texn.\n- : preservation* (step/app2 V E) T (of*/app T1 T2')\n     <- inv-app T T1 T2 <- preservation* E T2 T2'.\n- : preservation* (step/app2x V V') T (of*/raise Texn)\n     <- inv-app T T1 T2 <- inv-raise T2 Texn.\nq2 : eqty (ty/arrow T3 T4) (ty/arrow T1 T5)\n      -> ({x} of x T1 -> of (E2 x) T5)\n      -> of E6 T3\n      -> of (E2 E6) T4 -> type.\n- : q2 eqty/refl F E (F _ E).\n%mode q2 +A +B +C -D. %worlds () (q2 _ _ _ _). %total {} (q2 _ _ _ _).\n- : preservation* (step/appr V) T (of*/weaken Tres)\n     <- inv-app T T1 T2* <- mobile V T2* T2 \n     <- inv-lam T1 F Eq <- q2 Eq F T2 Tres.\n\n%{ ==== Natural numbers ==== }%\n\n- : preservation (step/s E) (of/s T) (of/s T') <- preservation E T T'.\n- : preservation (step/if E) (of/if T T1 T2) (of/if T' T1 T2)\n     <- preservation E T T'.\n- : preservation (step/ifz) (of/if of/z T1 _) T1.\n- : preservation (step/ifs V) (of/if (of/s T) _ T2) (T2 _ T).\n\nq1 : of* E ty/nat -> eqty T ty/nat -> of* (tm/s E) T -> type.\n- : q1 T _ (of*/s T). \n%mode q1 +A +B -C. %worlds () (q1 _ _ _). %total {} (q1 _ _ _).\n- : preservation* (step/s E) Ts Ts'\n     <- inv-s Ts T Eq <- preservation* E T T' <- q1 T' Eq Ts'.\nq3 : of* (tm/raise E) ty/nat -> eqty TN ty/nat -> of* (tm/raise E) TN -> type.\n- : q3 T _ T.\n%mode q3 +A +B -C. %worlds () (q3 _ _ _). %total {} (q3 _ _ _).\n- : preservation* (step/sx V) DTs DT'\n   <- inv-s DTs (DT: of* (tm/raise E) ty/nat) (Eq: eqty TN ty/nat)\n   <- q3 DT Eq DT'.\n- : preservation* (step/if E) Tif (of*/if T' T1 T2)\n     <- inv-if Tif T T1 T2 <- preservation* E T T'.\n- : preservation* (step/ifz) Tif T1\n     <- inv-if Tif (DT: of* tm/z ty/nat) (T1: of* E1 T) _.\n- : preservation* (step/ifs (V: v N)) DTif (T2 N Tn)\n     <- inv-if DTif Tsn* T1 (T2: {x} of x ty/nat -> of* (E2 x) T)\n     <- inv-s Tsn* (Tn* : of* N ty/nat) _\n     <- mobile V Tn* Tn.\n- : preservation* (step/ifx V) DTif (of*/raise DTexn)\n     <- inv-if DTif DT _ _\n     <- inv-raise DT DTexn.\n\n%{ ==== Fix/raise/handle ==== }%\n\n- : preservation (step/fix) (of/fix F) (F _ (of/fix F)).\n- : preservation (step/handle E) (of/handle T* T) (of/handle T'* T)\n     <- preservation* E T* T'*.\n- : preservation (step/handler V) (of/handle T* T) T' <- mobile V T* T'.\n- : preservation (step/handlex V) (of/handle (of*/raise Texn*) T) (T _ Texn)\n     <- mobile V Texn* Texn.\n\n- : preservation* (step/fix) (of*/weaken T) (of*/weaken T')\n     <- preservation step/fix T T'.\n- : preservation* (step/raise E) (of*/raise T) (of*/raise T')\n     <- preservation* E T T'.\n- : preservation* (step/raisex E) (of*/raise T) (of*/raise Texn)\n     <- inv-raise T Texn.\n- : preservation* (step/handle DE) (DT: of* (tm/handle E H) T) \n     (of*/handle DT1' DT2)\n     <- inv-handle DT DT1 DT2 \n     <- preservation* DE DT1 DT1'.\n- : preservation* (step/handler V) (DT) DT1\n     <- inv-handle DT DT1 DT2.\n- : preservation* (step/handlex V) (DT: of* (tm/handle (tm/raise E) H) T) \n     (DT2 E DTexn')\n     <- inv-handle DT (DT1 : of* (tm/raise E) T) DT2\n     <- inv-raise DT1 (DTexn : of* E ty/exn)\n     <- mobile V DTexn DTexn'.\n- : preservation* (step/unsusp DE) (DT: of* (tm/unsusp E) T) (of*/unsusp DT'')\n     <- inv-unsusp DT (DT': of* E (ty/mayraise T))\n     <- preservation* DE DT' (DT'': of* E' (ty/mayraise T)).\nd4 : eqty (ty/mayraise T) (ty/mayraise T') -> of* E T' -> of* E T -> type.\n- : d4 _ T T. %mode d4 +A +B -C. %worlds () (d4 _ _ _). %total {} (d4 _ _ _).\n- : preservation* (step/unsuspr) (DT: of* (tm/unsusp (tm/susp E)) T) DT'''\n     <- inv-unsusp DT (DT': of* (tm/susp E) (ty/mayraise T))\n     <- inv-susp DT' (DT'': of* E T') \n        (Eq: eqty (ty/mayraise T) (ty/mayraise T'))\n     <- d4 Eq DT'' DT'''.\n- : preservation* (step/unsuspx V) DT (of*/raise DTexn)\n     <- inv-unsusp DT (DT' : of* (tm/raise E) (ty/mayraise T))\n     <- inv-raise DT' (DTexn : of* E ty/exn).\n\n%worlds () (preservation _ _ _) (preservation* _ _ _).\n%total (E E*) (preservation E _ _) (preservation* E* _ _)."
          },
          "sha1": "ggoqugcruabw72e1004lg9fj5110mnm"
        }
      },
      {
        "title": "User:Rsimmons/Homework 6",
        "ns": 2,
        "id": 2105,
        "revision": {
          "id": 5516,
          "parentid": 5515,
          "timestamp": "2008-11-20T14:24:05Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 7070,
            "#text": "%{ \n\nFirst: look to the right ---->\n\nWhere it says \"Code: here\" click on that link. This will you to grab the code for this webpage in a form that you can cut and paste into a file and use in Twelf.\n\nUnless you want to do this whole assignment in [[Twelf Live]], then you will need to download Twelf on your machine. \n\n* [http://twelf.plparty.org/builds/twelf-linux.tar.gz Linux (tgz)]\n* [http://twelf.plparty.org/builds/twelf.exe Windows (exe)]\n* [http://twelf.plparty.org/builds/twelf-osx-intel.dmg Mac OS 10.4 or 10.5 (Intel only) (dmg)]\n* [http://twelf.plparty.org/builds/twelf-src.tar.gz Source tarball (tgz)].  You will need [http://www.mlton.org MLton] or [http://www.smlnj.org sml/nj]. \n\n'''''Handing in:''''' Place the file <tt>hw06.elf</tt> in your handin directory by midnight on '''''Monday, November 24'''''\n\n}%\n\n%{ == Part 1: Natural Numbers == }%\n\n%{ In the last section of [http://www.andrew.cmu.edu/course/15-814/homeworks/hw05.html Homework 5], I developed natural numbers in System F and then made some inductive definitions. I will do that again, but in Twelf, not System F.\n\nNatural numbers are no longer an interesting System F type, they're just something I define: }%\n\nnat : type.\nz : nat.\ns : nat -> nat.\n\n%{ Again, I can outright define the various natural numbers if I care to, and I can even define an LF term <tt>succ</tt> that takes a natural number and returns its successor, though this is kind of a dumb function, because it just applies the <tt>s</tt> constructor: }%\n\n0 : nat = z.\n1 : nat = s z.\n2 : nat = s (s z).\n3 : nat = s (s (s z)).\n4 : nat = s (s (s (s z))).\n5 : nat = s (s (s (s (s z)))).\n6 : nat = s (s (s (s (s (s z))))).\n\nsucc : nat -> nat = [n: nat] s n.\n\n%{ === Inductive descriptions of functions... well, of total relations === }%\n\n%{ As before, I want to inductively define functions on natural numbers, and I want to know they're ''functions'' - that I'll get an \ninput for every output (actually, what we're showing here is that they are \"total\" or \"effective\" relations - that for every input there is an output - and not that that output is unique. We can treat a relation as a function if it satisfies uniqueness and effectiveness, but that is not something we care about in this assignment.\n\nOur approach to inductively defining an effective relation is to describe the logic program that actually does describe a function. }%\n\n%{ \n'''Addition:''' ''n+m=p'' is defined by induction on ''n''. If ''n = 0'' then ''n+m=m'', and if ''n = n'+1'' and ''n'+m=p'', then ''n+m=p+1''. \n}%\n\nsum : nat -> nat -> nat -> type.\n%mode sum +N +M -P.\n\nsum/z : sum z M M.\nsum/s : sum (s N') M (s P)\n         <- sum N' M P.\n\n%worlds () (sum _ _ _).\n%total N (sum N _ _).\n\n%{ \n'''Multiplication:''' ''n×m=p'' is defined by induction on ''n''. If ''n = 0'', then ''n×m=0'', and if ''n = n'+1'' and ''n'×m=p'', then ''n×m=m+p''.\n}%\n\nmult : nat -> nat -> nat -> type.\n%mode mult +N +M -P.\n\nmult/z : mult z M z.\nmult/s : mult (s N') M P'\n          <- mult N' M P\n          <- sum M P P'.\n\n%worlds () (mult _ _ _).\n%total N (mult N _ _).\n\n%{\n'''Exponentiation:''' ''n^m=p'' is defined by induction on ''m'' ('''not''' ''n''). If ''m = 0'', then ''n^m=1'', and if ''m = m'+1'' and ''n^m'=p'', then ''n^m=n*p''.\n}%\n\npow : nat -> nat -> nat -> type.\n%mode pow +N +M -P.\n\npow/z : pow N z (s z).\npow/s : pow N (s M) P'\n         <- pow N M P\n         <- mult N P P'.\n\n%worlds () (pow _ _ _).\n%total M (pow _ M _).\n\n%{ === Question 1: Specification from code === }%\n\n%{ What function the following relations define? (Again, <tt>%total</tt> proves only that they are total relations, but these relations\nalso happen to be unique, meaning that they are functions.) \n\nA word or two should suffice in each case. }%\n\n\n%{ ==== Relation 1 ==== }%\n\nrel1 : nat -> nat -> type.\n%mode rel1 +N -M.\n\nrel1/z : rel1 z (s z).\nrel1/s : rel1 (s N') P'\n          <- rel1 N' P\n          <- mult (s N') P P'.\n\n%worlds () (rel1 _ _).\n%total N (rel1 N _).\n\n\n%{ ==== Relation 2 ==== }%\n\nrel2 : nat -> nat -> nat -> type.\n%mode rel2 +N +M -P.\n\nrel2/z1 : rel2 N z N.\nrel2/z2 : rel2 z M M.\nrel2/s : rel2 (s N) (s M) (s P)\n          <- rel2 N M P.\n\n%worlds () (rel2 _ _ _).\n%total [N M] (rel2 N M _).\n\n\n%{ ==== Relation 3 ==== }%\n\nrel3 : nat -> nat -> type.\n%mode rel3 +N -M.\n\nrel3/z : rel3 z (s z).\nrel3/1 : rel3 (s z) (s z).\nrel3/s : rel3 (s (s N')) P\n          <- rel3 N' P1\n          <- rel3 (s N') P2\n          <- sum P1 P2 P. \n         \n%worlds () (rel3 _ _).\n%total N (rel3 N _).\n\n%{ == Part 2: Lists and Trees == }%\n\n%{ We had lists and trees in Homework 5, and now we have them again. We don't have to give them System F types, we can just define the constructors in a straightforward manner:\n\nIn BNF:\n  l ::= nil | cons n l\n  t ::= leaf | node n t t \n\nIn Twelf:}%\n\nlist : type.\nnil : list.\ncons : nat -> list -> list.\n\ntree : type.\nleaf : tree.\nnode : nat -> tree -> tree -> tree.\n\n%{ Remember this example?\n       2\n      / \\\n     *   1\n        / \\\n       6   *\n      / \\\n     /   \\\n    5     2\n   / \\   / \\\n  *   * 3   *\n       / \\\n      *   *\nI gave a System F term for that tree in the previous assignment, and all I had to do was cut and paste here:}%\n\nmytree : tree = node 2 leaf (node 1 (node 6 (node 5 leaf leaf) (node 2 (node 3 leaf leaf) leaf)) leaf).\n\n%{ === Question 2: Code from specification === }%\n\n%{ Define <tt>append</tt> and <tt>flip</tt> as defined in [http://www.andrew.cmu.edu/course/15-814/homeworks/hw05.html Homework 5]. The <tt>infix</tt> relation is defined for you, but you will need to define <tt>append</tt> before Twelf will accept that <tt>infix</tt> is total. }%\n\n%{ ==== Append ==== }%\n\nappend : list -> list -> list -> type.\n%mode append +L1 +L2 -L.\n\n% Write code here\n\n%worlds () (append _ _ _).\n%% %total L (append L _ _). % Uncomment me to finish\n\n%{ ==== Flip ==== }%\n\nflip : tree -> tree -> type.\n%mode flip +T -T'.\n\n% Write code here\n\n%worlds () (flip _ _).\n%% %total T (flip T _). % Uncomment me to finish\n\n\n%{ ==== Infix ==== }%\n\ninfix : tree -> list -> type.\n%mode infix +T -L.\n\ninfix/z : infix leaf nil.\ninfix/s : infix (node N T1 T2) L\n           <- infix T1 L1\n           <- infix T2 L2\n           <- append L1 (cons N L2) L.\n\n%worlds () (infix _ _).\n%% %total T (infix T _). % Uncomment me once append works.\n\n%{ === Test cases === }%\n\n%% %query 1 * append (cons 4 (cons 5 nil)) (cons 3 (cons 1 nil)) (cons 4 (cons 5 (cons 3 (cons 1 nil)))).\n%% %query 1 * append nil (cons 4 (cons 5 (cons 6 nil))) (cons 4 (cons 5 (cons 6 nil))).\n%% %query 1 * append (cons 4 (cons 5 (cons 6 nil))) nil (cons 4 (cons 5 (cons 6 nil))).\n%% %query 1 * flip (node 2 leaf leaf) (node 2 leaf leaf).\n%% %query 1 * flip (node 3 (node 1 leaf leaf) leaf) (node 3 leaf (node 1 leaf leaf)).\n%% %query 1 * flip \n%%             mytree \n%%             (node 2\n%%               (node 1 \n%%                 leaf \n%%                 (node 6 \n%%                   (node 2 leaf (node 3 leaf leaf)) \n%%                   (node 5 leaf leaf)))\n%%               leaf).\n%% %query 1 * infix mytree (cons 2 (cons 5 (cons 6 (cons 3 (cons 2 (cons 1 nil))))))."
          },
          "sha1": "3w1bwqutwogwi8nr18fggxkkxea7k1l"
        }
      },
      {
        "title": "User:Rsimmons/Homework 7: Proofs In Twelf",
        "ns": 2,
        "id": 2141,
        "revision": {
          "id": 5705,
          "parentid": 5704,
          "timestamp": "2008-11-25T01:03:13Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "minor": null,
          "comment": "Protected \"[[User:Rsimmons/Homework 7: Proofs In Twelf]]\": Current assignment for 15-815 [edit=sysop:move=sysop]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 3985,
            "#text": "%{ Due Wednesday, December 3, by 11:59pm. Turn in as hw07.elf in your handin directory. }%\n\n%{ == Definition == }%\n%{ === Natural numbers === }%\n%{ ==== On paper ==== \n\n n ::= z | s n\n\n}%\n\n%{ ==== In Twelf ==== }%\n\nnat : type.\nz : nat.\ns : nat -> nat.\n\n%{ === Addition === }%\n%{ ==== On paper ==== \n\n ---------------- sum/z\n sum(z,n,n)\n\n sum(n,m,p)\n ---------------- sum/s\n sum(s(n),m,s(p))\n\n}%\n\n%{ ==== In Twelf ==== }%\n\nsum : nat -> nat -> nat -> type.\nsum/z : sum z N N.\nsum/s : sum (s N) M (s P) <- sum N M P.\n\n%{ === Less-than === }%\n%{ ==== On paper ==== \n\n'''''QUESTION 1:''''' Give the inductive definition for the judgment <tt>n < n'</tt> that corresponds to to what is defined below.\n\n}%\n\n%{ ==== In Twelf ==== }%\n\nlt : nat -> nat -> type.\nlt/z : lt z (s N).\nlt/s : lt (s N) (s M) <- lt N M.\n\n%{ === Even/odd === }%\n%{ ==== On paper ==== \n\n ---------------- even/z\n even z\n\n odd n\n ---------------- even/s\n even s(n)\n\n even n\n ---------------- odd/s\n odd s(n)\n\n}%\n\n%{ ==== In Twelf ==== }%\n\neven : nat -> type.\nodd : nat -> type.\n\n%{ '''''QUESTION 2:''''' Define in LF the rules for <tt>even</tt> and <tt>odd</tt> below. }% \n\n\n\n\n%{ == Proof: Sum Commutes == }%\n%{ === Lemma:  N + 0 = N === }%\n%{ ==== On paper ====\n\nFor all natural numbers <tt>n</tt>, <tt>sum(n,z,n)</tt>.\n\nProof by induction on <tt>n</tt>.\n\nCase <tt>n=z</tt>. We need to show <tt>sum(z,z,z)</tt>, which we can show by rule <tt>sum/z</tt>.\n\nCase <tt>n=s(n')</tt>. We need to show <tt>sum(s(n'),z,s(n'))</tt>. By the induction hypothesis, <tt>sum(n',z,n')</tt>. By rule <tt>sum/s</tt>, we have <tt>sum(s(n'),z,s(n'))</tt>.\n\n}%\n\n%{ ==== In Twelf ==== }%\n\nsum-ident : {N: nat} sum N z N -> type.\n%mode sum-ident +N -D. \n\n- : sum-ident z (sum/z : sum z z z).\n\n- : sum-ident (s N) (sum/s D : sum (s N) z (s N))\n   <- sum-ident N (D: sum N z N).\n\n%worlds () (sum-ident _ _).\n%total N (sum-ident N _).\n\n%{ === Lemma: N + M = P implies N + (s M) = (s P) === }% \n%{ ==== On paper ====\n\n'''''QUESTION 3:''''' State the \"on paper\" version of the lemma below.\n\n}%\n\n%{ ==== In Twelf ==== }%\n\nsum-incr : sum N M P -> sum N (s M) (s P) -> type.\n%mode sum-incr +D1 -D2.\n\n- : sum-incr sum/z (sum/z : sum z (s N) (s N)).\n\n- : sum-incr (sum/s D) (sum/s D' : sum (s N) (s M) (s (s P))) \n   <- sum-incr D (D': sum N (s M) (s P)).\n\n%worlds () (sum-incr _ _).\n%total D (sum-incr D _).\n\n\n\n\n\n%{ === Theorem: N + M = P implies M + N = P === }%\n%{ ==== On paper ====\n\nIf <tt>sum(n,m,p)</tt>, then <tt>sum(m,n,p)</tt>.\n\nProof by induction on the derivation of <tt>sum(n,m,p)</tt>.\n\nCase sum/z:\n |            | n = z\n | ---------- | m = p \n | sum(z,m,m) |\n\nTo show: <tt>sum(m,z,m)</tt>. Immediate by the first lemma.\n\nCase sum/s:\n | sum(n',m,p')      | n = s(n')\n | ----------------- | p = s(p')\n | sum(s(n'),m,s(p') |\n\nTo show: <tt>sum(m,s(n'),s(p'))</tt>.\n\nBy the induction hypothesis, <tt>sum(m,n',p')</tt>. By the second lemma, <tt>sum(m,s(n'),s(p'))</tt>.\n\n}%\n\n%{ ==== In Twelf ==== }%\n\nsum-commutes : sum N M P -> sum M N P -> type.\n%mode sum-commutes +D1 -D2.\n\n- : sum-commutes (sum/z : sum z N N) D\n   <- sum-ident N (D : sum N z N).\n\n- : sum-commutes (sum/s D : sum (s N) M (s P)) D''\n   <- sum-commutes D (D': sum M N P)\n   <- sum-incr D' (D'' : sum M (s N) (s P)).\n\n%worlds () (sum-commutes _ _).\n%total D (sum-commutes D _).\n\n%{ === Theorem :  N + (s M) = P implies N < P === }%\n%{ ==== On paper ==== \n\nIf <tt>sum(n,s(m),p)</tt>, then <tt>n < p</tt>. Proof by induction on <tt>sum(n,s(m),p)</tt>.\n\nCase <tt>sum/z</tt>:\n |                  | n = z\n | ---------------- | p = s(m)\n | sum(z,s(m),s(m)) |\n\nTo show: <tt>z < s(m)</tt>. Immediate by rule <tt>lt/z</tt>.\n\nCase <tt>sum/s</tt>:\n | sum(n',s(m),p')       | n = s(n')\n | --------------------- | p = s(p')\n | sum(s(n'),s(m),s(p')) |\n\nTo show: <tt>s(n') < s(p')</tt>. \n\nBy the induction hypothesis, <tt>n' < p'</tt>. By rule <tt>lt/s</tt>, we have <tt>s(n') < s(p')</tt>.\n\n}%\n\n%{ ==== In Twelf ==== }%\n\n%{ '''''QUESTION 4:''''' State and prove the above theorem in Twelf. }%"
          },
          "sha1": "bgs9950hkskboc46zrpb4r3qcqa089s"
        }
      },
      {
        "title": "User:Rsimmons/Lecture20",
        "ns": 2,
        "id": 2092,
        "redirect": {
          "@title": "User:Rsimmons/Lecture 20: Logic Programming",
          "#text": null
        },
        "revision": {
          "id": 5423,
          "timestamp": "2008-11-12T17:48:49Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "[[User:Rsimmons/Lecture20]] moved to [[User:Rsimmons/Lecture 20: Logic Programming]]: Better page name",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 57,
            "#text": "#REDIRECT [[User:Rsimmons/Lecture 20: Logic Programming]]"
          },
          "sha1": "1gdqrr3ji4jxvrcvrfnog2vh0p1drzi"
        }
      },
      {
        "title": "User:Rsimmons/Lecture 20: Logic Programming",
        "ns": 2,
        "id": 2091,
        "revision": {
          "id": 5427,
          "parentid": 5426,
          "timestamp": "2008-11-12T18:55:14Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "minor": null,
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 3800,
            "#text": "%{\n__NOTOC__\n\nIn this lecture, Karl uses Prolog notation. I'm going to skip a step and go ahead and start using Twelf, since I've got all this infrastructure set up to incorporate pretty Twelf into web pages. For the purpose of this exercise, this only means that we have to declare types for things and that we write <tt>connect a b</tt> instead of <tt>connect(a,b)</tt>\nfor facts representing a connection from <tt>a</tt>\nto <tt>b</tt>, and we say <tt>D <- A <- B <- C</tt> instead of <tt>D :- A, B, C</tt> for a three-premise rule.\n\nYou'll notice there's a box on the upper-right hand corner that calls this page \"Literate Twelf.\" This is related to the idea of [http://www.literateprogramming.com/ Literate Programming] - this wiki page is itself a page of valid Twelf code.\n\nIf you'll forgive the ugly illustration, we're interesting in answering questions about rechability on this acyclic graph (we want it to be an acyclic graph!)\n\n<code>\n   -> b <-\n  /       \\   \n /         \\ \na---------->c----->d\n</code>\n\n}%\n\nnode : type.\na : node.\nb : node.\nc : node.\nd : node.\n\nconnect : node -> node -> type.\nreaches : node -> node -> type.\n\nconnect/a-b : connect a b.\nconnect/a-c : connect a c.\nconnect/c-b : connect c b.\nconnect/c-d : connect c d.\n\nreach/refl  : {X: node} reaches X X.\nreach/trans : {X: node} {Y: node} {Z: node} reaches Y Z -> connect X Y -> reaches X Z.\n\n%{\n\n'''NOTE:''' You don't have to write the &Pi; bound things, so you could have used:\n<twelf name=dsfadsf>\nreach/refl  : reaches X X.\nreach/trans : reaches Y Z -> connect X Y -> reaches X Z.\n</twelf>\n(Twelf assumes you meant to &Pi;-bind capitalized things but were too lazy to write the &Pi;, so it does it for you.\n\nI can ask the engine to ask questions about reachability, which will essentially perform a depth-first search on the graph.\n\nI can confirm that there is one way through the graph from <tt>a</tt> to \n<tt>d</tt> (the notation <tt>%query 1 *</tt> isn't important for you to remember, but it means that I want one answer\nno matter how many times I try)\n\n|check=decl}% \n\n%query 1 * reaches a d. \n\n%{\n\n...I can ask the engine to verify that there are no paths through the graph from <tt>b</tt> to <tt>a</tt>:\n\n|check=decl}%\n\n%query 0 * reaches b a.\n\n%{ \n\n...finally, I can use a capital letter (metavariable or substitution variable) <tt>Z</tt> to ask, what is EVERY path, starting from\n<tt>a</tt>, in the graph? Turns out there are 5 (<tt>b</tt> can be reached in two different ways):\n\n|check=decl}%\n\n%query 5 * reaches a Z.\n\n%.\n\n= The LF Logical Framework =\n\n== Syntax ==\n\n<math>\nK ::= \\texttt{type} \\mid A \\rightarrow K\n</math>\n\n<math>\nA ::= \\Pi x{:}A.A \\mid \\lambda x{:}A.A \\mid A~M \\mid \\texttt{a}\n</math>\n\n<math>\nM ::= x \\mid \\lambda x{:}A.M \\mid M~M \\mid \\texttt{c}\n</math>\n\n== Typing Rules ==\n\n=== Kinds ===\n\nKinds ''K'' classify types ''A''.\n\n<br/>\n\n<math>\n{}\n\\over\n{\\texttt{type} : \\texttt{kind}}\n</math>\n\n<br/>\n\n<math>\n{A : \\texttt{type} \\qquad\nK : \\texttt{kind}}\n\\over\n{A \\rightarrow K : \\texttt{kind}}\n</math>\n\n=== Types ===\n\nTypes ''A'' classify terms ''M'' and are classified by kinds ''K''.\n\n<br/>\n\n<math>\n{A : \\texttt{type}\\qquad\nx : A \\vdash B : \\texttt{type}}\n\\over\n{\\Pi x{:}A.B : \\texttt{type}}\n</math>\n\n<br/>\n\n<math>\n{A : \\texttt{type} \\qquad\nx : A \\vdash B : K}\n\\over\n{\\lambda x{:}A.B : A \\rightarrow K}\n</math>\n\n<br/>\n\n<math>\n{A : A' \\rightarrow K \\qquad\nM : A'}\n\\over\n{A~M : K}\n</math>\n\n<br/>\n\n<math>\n{\\texttt{a} : K \\in \\Sigma}\n\\over\n{\\texttt{a} : K}\n</math>\n\n=== Terms ===\n\nTerms ''M'' are classified by types ''A''.\n\n<math>\n{A : \\texttt{type} \\qquad\nx : A \\vdash M : A'}\n\\over\n{\\lambda x{:}A . M : \\Pi x {:} A . A'}\n</math>\n\n<br/>\n\n<math>\n{M_1 : \\Pi x{:}A . A' \\qquad\nM_2 : A}\n\\over\n{M_1~M_2 : A'[M_2/x]}\n</math>\n\n<br/>\n\n<math>\n{\\texttt{c} : A \\in \\Sigma}\n\\over\n{\\texttt{c} : A}\n</math>"
          },
          "sha1": "ey0jqwmbr08isusvdeth0u4wplwmnd8"
        }
      },
      {
        "title": "User:Rsimmons/Lecture 22: Proofs In Twelf",
        "ns": 2,
        "id": 2142,
        "redirect": {
          "@title": "User:Rsimmons/Homework 7: Proofs In Twelf",
          "#text": null
        },
        "revision": {
          "id": 5698,
          "timestamp": "2008-11-24T23:06:06Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "[[User:Rsimmons/Lecture 22: Proofs In Twelf]] moved to [[User:Rsimmons/Homework 7: Proofs In Twelf]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 55,
            "#text": "#REDIRECT [[User:Rsimmons/Homework 7: Proofs In Twelf]]"
          },
          "sha1": "sh8hk6diznr7tci9lemzwo0ub2d8e0c"
        }
      },
      {
        "title": "User:Rsimmons/Lecture 23: Proofs In Twelf",
        "ns": 2,
        "id": 2140,
        "redirect": {
          "@title": "User:Rsimmons/Lecture 23: Typed Lambda Calculus in Twelf",
          "#text": null
        },
        "revision": {
          "id": 5691,
          "timestamp": "2008-11-24T18:44:36Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "[[User:Rsimmons/Lecture 23: Proofs In Twelf]] moved to [[User:Rsimmons/Lecture 23: Typed Lambda Calculus in Twelf]]: Truth in advertising",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 70,
            "#text": "#REDIRECT [[User:Rsimmons/Lecture 23: Typed Lambda Calculus in Twelf]]"
          },
          "sha1": "4c0w1qryo6tto5dn1w03gen1zfqoexp"
        }
      },
      {
        "title": "User:Rsimmons/Lecture 23: Typed Lambda Calculus in Twelf",
        "ns": 2,
        "id": 2139,
        "revision": {
          "id": 8202,
          "parentid": 8201,
          "timestamp": "2018-03-20T20:17:46Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "minor": null,
          "comment": "Protected \"[[User:Rsimmons/Lecture 23: Typed Lambda Calculus in Twelf]]\" ([Edit=Allow only administrators] (indefinite) [Move=Allow only administrators] (indefinite))",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 4691,
            "#text": "%{ == Syntax == }%\n%{\n\nWe have a programming language that we started last time that we want to represent in Twelf. First the types \"on paper:\"\n \n τ ::= unit | τ → τ\n\n... and then, we can see those types in Twelf:\n\n}%\n\ntp : type.\n\nunit : tp.\narrow : tp -> tp -> tp.\n\n%{\n\nNext, the terms \"on paper:\"\n\n e ::= x | * | λx:τ.e | e e\n\n... and in Twelf:\n\n}%\n\nexp : type.\n\n* : exp.\nlam : tp -> (exp -> exp) -> exp.\napp : exp -> exp -> exp.\n\n%{\n\nNote that there is no case for \"variables\" <tt>x</tt>. \n\n}%\n\n%{ == Static semantics (typing rules) == }%\n%{\n\nThe old judgment for typing was <tt>e : τ</tt> - in other words, it was a two-place relation that took an expression and a type. We will describe this in Twelf as <tt>of</tt>.\n\n}%\n\nof : exp -> tp -> type.\n\n%{\n\nOkay - now we need to describe this rule:\n\n -------- of/star\n * : unit\n\n}%\n\nof/star : of * unit.\n\n\n%{\n\nNext we describe the more interesting rule for application:\n\n e<sub>1</sub> : τ → τ'\n e<sub>2</sub> : τ\n ------------ of/app\n e<sub>1</sub> e<sub>2</sub> : τ'\n}%\n\nof/app : of (app E1 E2) T\n  <- of E1 (arrow T T')\n  <- of E2 T.\n\n%{ \n\nThe rule for abstractions uses a hypothetical! We're going to pull this off by using a Pi-binding (represented in Twelf as <tt>{x: exp}</tt> to create a ''fresh'' variable, and then using an LF arrow <tt>-></tt> to say that you are proving <tt>of (E x) T'</tt> under the ''hypothetical assumption'' that <tt>of x T</tt>, which matches exactly with how we've been using assumptions all semester.\n\n x : τ |- e : τ'\n --------------- of/lam\n λx:τ.e : τ → τ'\n\n}%\n\nof/lam : of (lam T ([x] E x)) (arrow T T')\n  <- ({x: exp} of x T -> of (E x) T').\n\n\n%{ === Example derivation === }%\n%{ On paper: \n\n -------------------- hyp\n x : unit |- e : unit\n ----------------------- of/lam\n λx:unit.e : unit → unit\n\nIn Twelf:\n\n| check=decl }%\n\n_ = of/lam (_) : of (lam unit ([x] x)) (arrow unit unit).\n\n%{ Okay, it looks like we need something (<tt>X1</tt>) of type <tt>{x:exp} of x unit -> of x unit</tt>, in other words, something of type <tt>Πx:exp. of x unit -> of x unit</tt> - this is the type of a (dependent) function that takes a term with type <tt>exp</tt> (call it <tt>x</tt>), and returns a (not dependent) function that takes a term with type <tt>of x unit</tt> and then returns a term with type <tt>of x unit</tt>. In other words, take an expression and then give me the identity function!\n\nYou guys should know what to do from here (it's just like what you were doing in Homework 5, but for LF instead of System F!). We want <tt>λx:exp. λd:of x unit. d</tt>.\n| check=decl }%\n\n_ = of/lam ([x: exp] [d: of x unit] d) : of (lam unit ([x] x)) (arrow unit unit).\n\n%{ The absolutely correct observation made about this in class was that '''Hypotheticals in the object language are represented as functions in the metalanguage.''' }%\n\n\n%{ == Dynamic semantics (evaluation rules) == }%\n%{\n\nFirst, values <tt>e value</tt>:\n\n ------------ value/star\n * value\n\n ------------ value/lam\n λx:τ.e value\n\n}%\n\nvalue : exp -> type.\n\nvalue/star : value *.\n\nvalue/lam : value (lam T ([x] E x)).\n\n%{\n\nNext, evaluation rules <tt>e -> e</tt>\n\n e<sub>1</sub> -> e'<sub>1</sub>\n --------------------- step/app1\n e<sub>1</sub> e<sub>2</sub> -> e'<sub>1</sub> e<sub>2</sub>\n\n e<sub>1</sub> value\n e<sub>2</sub> -> e'<sub>2</sub>\n --------------------- step/app2\n e<sub>1</sub> e<sub>2</sub> -> e<sub>1</sub> e'<sub>2</sub>\n\n e<sub>2</sub> value\n --------------------- step/applam\n (λx:τ.e) e<sub>2</sub> -> e<sub>1</sub> e'<sub>2</sub>\n\n}%\n\nstep : exp -> exp -> type.\n\nstep/app1 : step (app E1 E2) (app E1' E2)\n  <- step E1 E1'.\n\nstep/app2 : step (app E1 E2) (app E1 E2')\n  <- value E1\n  <- step E2 E2'.\n\nstep/applam : step (app (lam T ([x] E x)) E2) (E E2)\n  <- value E2.\n\n\n%{ == Coda: Type Safety == }%\n%{\n\n[[User:Rsimmons/Lecture 22: Proofs In Twelf| Last time]], we used the commutativity of addition to write a logic program that took in a term of type <tt>sum N1 N2 N3</tT> and produced a term of type <tt>sum N2 N1 N3</tt>. In other words, we proved this theorem:\n\n'''''Sum commutes''''': if <tt>sum(n<sub>1</sub>, n<sub>2</sub>, n<sub>3</sub>)</tt> then <tt>sum(n<sub>1</sub>, n<sub>1</sub>, n<sub>1</sub>)</tt>\n\n...by writing this in Twelf and proving it to be a total relation: \n\n<twelf>\nsum-commutes : sum N1 N2 N3 -> sum N2 N1 N3 -> type.\n%mode sum-commutes +D1 -D2.\n</twelf>\n\nSo we an prove this theorem:\n\n'''''Preservation''''': if <tt>e : τ</tt> and <tt>e -> e'</tt>, then <tt>e' : τ</tt>\n\n...by writing this in Twelf and proving it to be a total relation:\n\n}%\n\npreservation : of E T -> step E E' -> of E' T -> type.\n%mode preservation +D1 +D2 -D2.\n\n%{ Thus ends today's lesson. }%"
          },
          "sha1": "3zfra4m45ek9wmbd7ob5inzswqoyo6g"
        }
      },
      {
        "title": "User:Rsimmons/fillholes.elf",
        "ns": 2,
        "id": 2220,
        "revision": {
          "id": 6059,
          "timestamp": "2010-03-20T02:22:07Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "Created page with '%{}% elem : type. z : elem.  list : type.  nil : list. cons : elem -> list -> list.  %block bl_elem : block {x : elem}.  id : list -> list -> type. refl : id L L.  fillx : (elem ...'",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 7228,
            "#text": "%{}%\nelem : type.\nz : elem.\n\nlist : type.\n\nnil : list.\ncons : elem -> list -> list.\n\n%block bl_elem : block {x : elem}.\n\nid : list -> list -> type.\nrefl : id L L.\n\nfillx : (elem -> list) -> list -> type.\nfillx1 : fillx ([x] nil) nil.\nfillx2 : fillx ([x] cons x (L₁ x)) L₂ \n         <- fillx ([x] L₁ x) L₂.\nfillx3 : fillx ([x] cons Y (L₁ x)) (cons Y L₂)\n         <- fillx ([x] L₁ x) L₂.\n\nfill : {D : elem -> list} fillx D E -> type.\n- : fill ([x] nil) fillx1.\n- : fill ([x] cons x (D x)) (fillx2 D⟦·⟧) <- fill D D⟦·⟧.\n- : fill ([x] cons Y (D x)) (fillx3 D⟦·⟧) <- fill D D⟦·⟧.\n%mode fill +D -D⟦·⟧.\n%worlds (bl_elem) (fill _ _).\n%total D (fill D _).\n\nfillR : (elem -> list) -> elem -> list -> type.\nfillR0 : fillR ([x] L x) R (L R).\n\nfillR-cons-cong : {Rh} \n                   fillR L R LR\n                   -> fillR ([x] (cons Rh (L x))) R (cons Rh LR)\n                   -> type.\n%mode fillR-cons-cong +X1 +X2 -X3.\n- : fillR-cons-cong _ fillR0 fillR0.\n%worlds (bl_elem) (fillR-cons-cong _ _ _).\n%total {} (fillR-cons-cong _ _ _).\n\nvoid : type.\n%worlds () (void).\n\nfill-nil-contra : fillR ([x] nil) R₂ (cons R₁ L2)\n                   -> void\n                   -> type.\n%mode fill-nil-contra +X1 -X2.\n%worlds (bl_elem) (fill-nil-contra _ _).\n%total {} (fill-nil-contra _ _).\n\nabort/fillR : {L}{R}{LR} void -> fillR L R LR -> type.\n%mode abort/fillR +X1 +X2 +X3 +X4 -X5.\n%worlds (bl_elem) (abort/fillR _ _ _ _ _).\n%total {} (abort/fillR _ _ _ _ _).\n\nabort/fillx : {L}{Lx} void -> fillx L Lx -> type.\n%mode abort/fillx +X1 +X3 +X4 -X5.\n%worlds (bl_elem) (abort/fillx _ _ _ _).\n%total {} (abort/fillx _ _ _ _).\n\nfillRx2 : fillR L R LR\n           -> fillR ([x] cons x (L x)) R (cons R LR)\n           -> type.\n%mode fillRx2 +X1 -X2.\n- : fillRx2 fillR0 fillR0.\n%worlds (bl_elem) (fillRx2 _ _).\n%total {} (fillRx2 _ _).\n\nthm' : {D□R : elem -> list}\n      {D·□ : elem -> list}\n      fillR ([x] D·□ x) R D·R\n   -> fillx ([x] D□R x) D·R\n   -> {D□□ : elem -> elem -> list}\n      ({y} fillx ([x] D□□ x y) (D·□ y))\n   -> ({x} fillR ([y] D□□ x y) R (D□R x))\n   -> type. \n%abbrev thm : {D□R : elem -> list}\n      {D·□ : elem -> list}\n      fillx ([x] D□R x) D·R\n   -> fillR ([x] D·□ x) R D·R\n   -> {D□□ : elem -> elem -> list}\n      ({y} fillx ([x] D□□ x y) (D·□ y))\n   -> ({x} fillR ([y] D□□ x y) R (D□R x))\n   -> type = [x1] [x2] [x3] [x4] [x5] [x6] [x7] thm' x1 x2 x4 x3 x5 x6 x7. \n\n\n- : thm ([x] nil) ([y] nil) fillx1 F1 \n     ([x][y] nil) ([x] fillx1) ([x] fillR0).\n- : thm ([x] cons x (L1 x)) ([y] L2 y) (fillx2 F1) fillR0 \n     ([x][y] cons x (L x y)) \n     ([y] fillx2 (B y)) \n     ([x] C' x : fillR ([y] cons x (L x y)) R (cons x (L1 x)))\n     <- thm L1 L2 F1 fillR0 \n        ([x][y] L x y) \n        ([y] B y : fillx ([x] L x y) (L2 y))\n        ([x] C x : fillR ([y] L x y) R (L1 x))\n     <- ({x:elem} fillR-cons-cong x (C x) (C' x)).\n\n- : thm ([x] cons R₁ (L1 x)) ([x] nil) (fillx3 F3) \n     (F1 : fillR ([x] nil) R₂ (cons R₁ L2'))\n     ([x] [y] nil) %% garbage \n     B\n     C\n     <- fill-nil-contra F1 XX\n     <- ({x} abort/fillx _ _ XX (B x))\n     <- ({x} abort/fillR _ _ _ XX (C x)).\n\n- : thm ([x] cons R₁ (L1 x)) ([x] cons R₁ (L2 x)) (fillx3 F1) \n     (fillR0 : fillR ([x] cons R₁ (L2 x)) R₂ (cons R₁ (L2 R₂)))\n     ([x][y] cons R₁ (L x y)) \n     ([y] fillx3 (F1' y)) \n     ([x] B' x : fillR ([y:elem] cons R₁ (L x y)) R₂ (cons R₁ (L1 x)))\n     <- thm L1 L2 F1 fillR0 ([x][y] L x y) \n        ([y] F1' y : fillx ([x] L x y) (L2 y))\n        ([x] B x : fillR ([x1:elem] L x x1) R₂ (L1 x))\n     <- ({x:elem} fillR-cons-cong R₁ (B x) (B' x)).\n\n- : thm ([x] cons R₁ (L1 x)) ([x] cons x (L2 x)) (fillx3 F1) \n     (fillR0 : fillR ([x] cons x (L2 x)) R₁ (cons R₁ (L2 R₁)))\n     ([x][y] cons y (L x y))\n     ([y] (fillx3 (F1' y)))\n     ([x] B' x : fillR ([y] cons y (L x y)) R₁ (cons R₁ (L1 x)))\n     <- thm L1 L2 F1 fillR0 ([x][y] L x y) \n        ([y] F1' y)\n        ([x] B x : fillR ([y] L x y) R₁ (L1 x))\n     <- ({x} fillRx2 (B x) (B' x)).\n\n%worlds (bl_elem) (thm' _ _ _ _ _ _ _).\n%covers thm' +A +B +C +D -E -F -G.\n%mode thm' +A +B +C +D -E -F -G.\n%total D (thm' D _ _ _ _ _ _).\n\ncom·· : {D□□ : elem -> elem -> list} \n         ({y} fillx ([x] D□□ x y) (D·□ y))\n      -> ({x} fillx ([y] D□□ x y) (D□· x))\n      -> (fillx ([y] D·□ y) D··)\n      -> (fillx ([x] D□· x) D··)\n      -> type.\n- : com·· ([x][y] nil) ([y] fillx1) ([x] fillx1) fillx1 fillx1.\n- : com·· ([x][y] cons E (L x y))\n     ([y] fillx3 (Fx y)) ([x] fillx3 (Fy x)) (fillx3 Fxy) (fillx3 Fyx)\n     <- com·· L Fx Fy Fxy Fyx.\n- : com·· ([x][y] cons x (L x y)) \n     ([y] fillx2 (Fx y)) ([x] fillx3 (Fy x)) Fxy (fillx2 Fyx)\n     <- com·· L Fx Fy Fxy Fyx.\n- : com·· ([x][y] cons y (L x y))\n     ([y] fillx3 (Fx y)) ([x] fillx2 (Fy x)) (fillx2 Fxy) Fyx\n     <- com·· L Fx Fy Fxy Fyx.\n%mode com·· +A +B +C +D -E.\n%worlds (bl_elem) (com·· _ _ _ _ _).\n%total T (com·· T _ _ _ _).\n\ncomR· : {D□□ : elem -> elem -> list}\n         ({x} fillx ([y] D□□ x y) (D□· x))\n      -> (fillx ([y] D□□ R y) (D□· R))\n      -> type.\n- : comR· ([x][y] nil) ([x] fillx1) fillx1.\n- : comR· ([x][y] cons E (L x y)) ([x] fillx3 (Fy x)) (fillx3 Fxy)\n     <- comR· L Fy Fxy.\n- : comR· ([x][y] cons x (L x y)) ([x] fillx3 (Fy x)) (fillx3 Fxy)\n     <- comR· L Fy Fxy.\n- : comR· ([x][y] cons y (L x y)) ([x] fillx2 (Fy x)) (fillx2 Fxy)\n     <- comR· L Fy Fxy.\n%mode +{D□·:elem -> list} +{A:elem -> elem -> list} +{R:elem}\n   +{C:{x:elem} fillx ([y:elem] A x y) (D□· x)}\n   -{E:fillx ([y:elem] A R y) (D□· R)} (comR· A C E).\n%worlds (bl_elem) (comR· _ _ _).\n%total T (comR· T _ _).\n\nfilleq : {R₁} ({x:elem} fillR ([y] D□□ x y) R₂ (D□R x))\n          -> fillR ([x] D□□ R₁ x) R₂ (D□R R₁)\n          -> type.\n- : filleq _ ([x] fillR0) fillR0.\n%worlds (bl_elem) (filleq _ _ _).\n%mode filleq +A +C -B.\n%total {} (filleq _ _ _).\n\nholeswap : {R₁}\n           {R₂}\n           {D□R : elem -> list}\n           {D·□ : elem -> list}\n           fillR D□R R₁ DRR\n        -> fillx D□R D·R\n        -> fillR D·□ R₂ D·R\n        -> fillx D·□ D··\n        -> {D□· : elem -> list}\n           {DR□ : elem -> list}\n           fillx D□· D··\n        -> fillR D□· R₁ DR·\n        -> fillx DR□ DR·\n        -> fillR DR□ R₂ DRR\n        -> type.\n\n- : holeswap R₁ R₂ D□R D·□ fillR0 D□R⟦x⟧ fillR0 D·□⟦y⟧ \n     D□· ([y] D□□ R₁ y) D□·⟦x⟧ fillR0 DR□⟦y⟧ D□R⟦R⟧\n     <- thm' D□R D·□ fillR0 D□R⟦x⟧ D□□\n        ([y] D□□⟦x⟧ y : fillx ([x] D□□ x y) (D·□ y)) \n        ([x] D□□⟦R⟧ x : fillR ([y] D□□ x y) R₂ (D□R x))\n     <- ({x} fill ([y] D□□ x y) (D□□⟦y⟧ x : fillx ([y] D□□ x y) (D□· x)))\n     <- com·· D□□ D□□⟦x⟧ D□□⟦y⟧ D·□⟦y⟧ D□·⟦x⟧\n     <- comR· D□□ D□□⟦y⟧ DR□⟦y⟧\n     <- filleq _ D□□⟦R⟧ D□R⟦R⟧.\n\n%worlds (bl_elem) (holeswap _ _ _ _ _ _ _ _ _ _ _ _ _ _).\n%mode holeswap +A +B +C +D +E +F +G +H -I -K -L -M -N -O.\n%total {} (holeswap _ _ _ _ _ _ _ _ _ _ _ _ _ _)."
          },
          "sha1": "99nl26jvfvcwoo0142w8a319fcattut"
        }
      },
      {
        "title": "User:Spoons",
        "ns": 2,
        "id": 1777,
        "revision": {
          "id": 4853,
          "parentid": 4852,
          "timestamp": "2007-09-27T12:04:58Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "minor": null,
          "comment": "Reverted edits by [[Special:Contributions/65.44.66.100|65.44.66.100]] ([[User_talk:65.44.66.100|Talk]]); changed back to last version by [[User:Spoons|Spoons]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 154,
            "#text": "Hi, everyone!  My name is Dan Spoonhower, and I am a graduate student at CMU.  You can read more about me on my [http://www.cs.cmu.edu/~spoons/ homepage]."
          },
          "sha1": "oqbi9sak3hmneeyg2did7703er0twnd"
        }
      },
      {
        "title": "User:TestUser",
        "ns": 2,
        "id": 1372,
        "revision": {
          "id": 5065,
          "parentid": 1376,
          "timestamp": "2008-02-17T20:42:26Z",
          "contributor": {
            "username": "TestUser",
            "id": 3
          },
          "minor": null,
          "comment": "minor edits",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 169,
            "#text": "[[User:rsimmons|Rob]] created this user to have someone he could use to log in as someone who only had \"generic user\" permission.\n\nLeave Rob any messages you might have."
          },
          "sha1": "tnu7ytdpg8irzcilxwfck8ptrfr7ir1"
        }
      },
      {
        "title": "User:TheTwelfElf",
        "ns": 2,
        "id": 1367,
        "revision": {
          "id": 8187,
          "parentid": 8186,
          "timestamp": "2017-02-11T15:03:29Z",
          "contributor": {
            "username": "Boyland",
            "id": 17
          },
          "minor": null,
          "comment": "Reverted edits by [[Special:Contributions/Judithlob|Judithlob]] ([[User talk:Judithlob|talk]]) to last revision by [[User:TheTwelfElf|TheTwelfElf]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 720,
            "#text": "The dude in the green hat. You may notice that every college's Facebook.com account has an account for \"The Creator\" that is presumably used when the admins at The Facebook want to look around as members of a school as members of that account. TheTwelfElf was the first account, and so has full control of the wiki, but so do [[Project:Administrators | other people]] so it's not really necessary for a development system.\n\n[[User:rsimmons|Rob]] has loose control over this account and sometimes forgets to log out and so edits as the Elf. That control could naturally change in the future. This is not a good place to leave a message, for that you should find an [[Project:Administrators | admin]] that actually exists."
          },
          "sha1": "70boc10n5fdur64m2dry4rkbyhian53"
        }
      },
      {
        "title": "User:Tom7",
        "ns": 2,
        "id": 1436,
        "revision": {
          "id": 3318,
          "parentid": 3253,
          "timestamp": "2006-11-04T04:53:46Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "comment": "/* Photographs of me with the Twelf Elf */ dab",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 857,
            "#text": "Hi, I'm '''Tom Murphy VII''', known colloquially as '''Tom 7'''. I am a graduate student at Carnegie Mellon University, nearing completion. My real home page is at [http://tom7.org tom7.org].\n\n== Notes ==\n* I always have trouble remembering [[Special:Allmessages]].\n* I also have trouble remembering [[MediaWiki:Edittools]].\n* I want to customize the site so it doesn't look exactly like Wikipedia. [http://en.wikipedia.org/wiki/Help:User_style This page] has some explanation of [[MediaWiki:Monobook.css]] div IDs, etc.\n* Here I can experiment with crazy [http://meta.wikimedia.org/wiki/ParserFunctions template features].\n* To do: add parameterized resp technique to [[congruence lemmas]], along with semi-tasteless tricks\n\n== Photographs of me with the Twelf Elf ==\n\n[[Image:Tom_Twelfelf2.jpg|thumb|left|400px|Tom (left) with Twelf Elf, Halloween 2006.]]"
          },
          "sha1": "o7qqys7lyq2tlbrmk1znraao6sj5wa0"
        }
      },
      {
        "title": "User:Tom7/test.elf",
        "ns": 2,
        "id": 1702,
        "revision": {
          "id": 2741,
          "timestamp": "2006-10-13T15:41:39Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 242,
            "#text": "AJALF test!\n\n<nowiki><twelf>this is no-wikied</twelf>\n\n</nowiki>\n\n<twelf>% Here's some twelf.\n\ntheorem : type.\nyes : theorem.\n%mode theorem.\n</twelf>\n\n\nsome \"literate twelf\" here...\n\n<twelf>\n%worlds () (theorem).\n%total {} (theorem).\n</twelf>"
          },
          "sha1": "e2j71cztfn6ex3vrsmotdsst5xnvjw6"
        }
      },
      {
        "title": "User:Twilson",
        "ns": 2,
        "id": 2000,
        "revision": {
          "id": 4870,
          "parentid": 4856,
          "timestamp": "2007-10-03T06:13:11Z",
          "contributor": {
            "ip": "24.131.192.122"
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 141,
            "#text": "Todd Wilson is a faculty member at California State University, Fresno, and was a visiting scholar at Carnegie Mellon in the Spring of  2007."
          },
          "sha1": "mwrsrdt2v8h1qhvcm9jyccvy7ji7bqk"
        }
      },
      {
        "title": "User:Varming",
        "ns": 2,
        "id": 1677,
        "revision": {
          "id": 2516,
          "parentid": 2515,
          "timestamp": "2006-10-09T22:14:19Z",
          "contributor": {
            "username": "Varming",
            "id": 10
          },
          "minor": null,
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 155,
            "#text": "Carsten Varming<br />\nCMU CSD Wean Hall 4212<br />\n5000 Forbes Avenue<br />\nPittsburgh PA 15213<br />\nUSA\n\n[[http://www.cs.cmu.edu/~cvarming/ My web page]]"
          },
          "sha1": "ej05bdzwmuhi3zxcxn53dz289sman70"
        }
      },
      {
        "title": "User:William Lovas",
        "ns": 2,
        "id": 1838,
        "revision": {
          "id": 3522,
          "timestamp": "2007-01-15T06:24:23Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 50,
            "#text": "Welcome to William Lovas's bog standard user page."
          },
          "sha1": "2pqs4bxp3fd25qxwl6ehbkd8tlu9pyv"
        }
      },
      {
        "title": "User talk:128.2.223.28",
        "ns": 3,
        "id": 1747,
        "revision": {
          "id": 3196,
          "parentid": 3003,
          "timestamp": "2006-10-26T21:04:06Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 92,
            "#text": "you still should log in! &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 15:47, 20 October 2006 (EDT)"
          },
          "sha1": "f7uxgwj2xk814yxudt9m00ty81jl9n6"
        }
      },
      {
        "title": "User talk:128.237.241.108",
        "ns": 3,
        "id": 1770,
        "revision": {
          "id": 3142,
          "parentid": 3136,
          "timestamp": "2006-10-24T19:38:32Z",
          "contributor": {
            "username": "Jcreed",
            "id": 9
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 91,
            "#text": "You should log in!\n\nYeah, I should have [[User:Jcreed|Jcreed]] 15:38, 24 October 2006 (EDT)"
          },
          "sha1": "nsx6mbb5f8k443akkozeiwlwop9obfx"
        }
      },
      {
        "title": "User talk:Aleffert",
        "ns": 3,
        "id": 1730,
        "revision": {
          "id": 2890,
          "timestamp": "2006-10-16T18:17:49Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 2,
            "#text": "hi"
          },
          "sha1": "moiryvew7z1nh6cf1srex5j09y58bpe"
        }
      },
      {
        "title": "User talk:Alepa",
        "ns": 3,
        "id": 2271,
        "revision": {
          "id": 6277,
          "timestamp": "2011-07-16T16:59:03Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "challenge (/response?)",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 393,
            "#text": "Hello, user Alepa. I don't know why you created a random page with a link to Google, and would like to. Please let me know if you were just trying to learn about how wiki software works or something! Otherwise, because we've had a great deal of trouble with vandalism, I'm likely to diable your account. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 12:59, 16 July 2011 (EDT)"
          },
          "sha1": "5s22kcxv841l6qb2oevz5c4lbev0xuh"
        }
      },
      {
        "title": "User talk:Boyland",
        "ns": 3,
        "id": 1852,
        "revision": {
          "id": 5046,
          "parentid": 5040,
          "timestamp": "2008-02-07T15:17:09Z",
          "contributor": {
            "username": "Boyland",
            "id": 17
          },
          "minor": null,
          "comment": "/* Hoas/Natural Numbers */ ready but not perfect",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 1887,
            "#text": "Welcome! — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 09:44, 21 February 2007 (EST)\n\n\nI don't see a place where known bugs, problems are posted.  So I'll put them here.\n\n: It might not be a bad idea to collect such things. Perhaps [[known bugs]] or [[known issues]] is a good place for this - it would be good to collect things like this and issues such as the warning about [[constraint domains and coverage checking]].\n\n:: it would be a very good idea.  I'll let you do it.  Feel free to take any content you find useful. [[User:Boyland|Boyland]] 02:48, 15 May 2007 (EDT)\n\n::: I've moved the contents to my user page. [[User:Boyland|Boyland]] 10:49, 22 August 2007 (EDT)\n\nThe coverage checker sometimes fails to terminate. [...]\n\n: This is a known bug - it can occur when coverage checking is done on a lambda expression (here, the guilty party is the <tt>(expr -> expr)</tt> part of <tt>expr-in-expr : (expr -> expr) -> type</tt>, and non-termination will usually happen on theorems that are not true, like this one.\n\nThe prover sometimes fails to terminate.\n\n: The bug here, as much as anything, is that Twelf accepcts the theorem proving (<tt>%prove</tt>) syntax at all. I don't like it either, but it is actually not difficult or even unexpected to get the theorem prover to nonterminate. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 21:11, 14 May 2007 (EDT)\n\n== Hoas/Natural Numbers ==\n\nThanks for the great page! Is it in a state where you're comfortable with me listing it from the front page? — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 16:04, 30 January 2008 (EST)\n\nIt's OK with me to post it, but best would be to fix all the %% %%% and %%%% section marks to be Wiki sections: %{ ==== }% %{ === }% and %{ == }% I think.  Perhaps you have an easy way to do this??? [[User:Boyland|Boyland]] 10:17, 7 February 2008 (EST)"
          },
          "sha1": "icv2pv74wduw5n0wtk5dkbs4byoehfh"
        }
      },
      {
        "title": "User talk:Ccasin",
        "ns": 3,
        "id": 2002,
        "revision": {
          "id": 4860,
          "timestamp": "2007-10-02T20:08:53Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "comment": "New page: Welcome to the Twelf Party! ~~~~",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 94,
            "#text": "Welcome to the Twelf Party! &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 16:08, 2 October 2007 (EDT)"
          },
          "sha1": "aqcyaby3amsz9grgwqibr8imlk5qkg3"
        }
      },
      {
        "title": "User talk:Crary",
        "ns": 3,
        "id": 1731,
        "revision": {
          "id": 2892,
          "timestamp": "2006-10-16T18:42:33Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 123,
            "#text": "You're now an [[Project:Administrators|administrator]]. &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 14:42, 16 October 2006 (EDT)"
          },
          "sha1": "1mszdw30dk7kydm48zpx6nmhdzhunwq"
        }
      },
      {
        "title": "User talk:DanielKLee",
        "ns": 3,
        "id": 1448,
        "revision": {
          "id": 2623,
          "parentid": 2622,
          "timestamp": "2006-10-11T21:45:00Z",
          "contributor": {
            "username": "DanielKLee",
            "id": 5
          },
          "comment": "/* \"Group\" doesn't work anymore */",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 4709,
            "#text": "== My To-Do/Wish List ==\n\n* Fill in the %trustme example for the [[%trustme]] article\n* Tutorial: Introductory series. Tutorials for people who start knowing nothing about Twelf\n* Tutorial: Manually proving substitution lemmas [for dependently typed languages], i.e. the slide\n\nYou should add that stuff to the page I made at [[Project:To do]] - I've already listed your adoption of the %trustme article — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 07:43, 22 September 2006 (MST)\n\n== Fixup ==\n\nI deleted the fictonal blog entries - until we know what we're doing, when we're doing it, and where things are permanently hosted, I don't think we should spend time on the blog - it's just something I wanted to make sure was there as part of the equation. In any case, my thought is that blog updates will be something along the lines of \"we've now added a tutorial describing closure conversion,\" a paragraph about why that's important/hard/easy, and a link to a page on the wiki, where we have pretty things like syntax highlighting.\n\nYou can find links that let you edit individual sections of the front page at [[Talk:Main Page]], a fact which I have added to [[Project:Contributing]].\n\nAlso, was something like [[Project:Style guide]] what you were thinking about? We also should think about a [[Twelf style guide]], which also might have been what you were thinking about. - [[User:Rsimmons|Rsimmons]] 09:05, 6 September 2006 (MST)\n\n== CVS ==\n\nYou were going to add information on anon CVS download when you got a chance, just a reminder :). — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 19:49, 7 September 2006 (MST)\n\n== Simpler version of \"slide\" ==\n\nWould a simpler version of your \"slide\" example be the storetype weakining issue I described at http://fp.logosphere.cs.cmu.edu/twelf/?n=Answers.WorldsAndWeakening ? One of my to-dos is to transwiki things from the old wiki; I can expand that example if it would be useful as a simple case of what you're describing. Alternatively, if what you're describing does what I did better, I could hold off on the transwiki. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 10:32, 22 September 2006 (MST)\n\n: That is the non-dependent types version of the technique. I was planning on doing a more generalized explanation of this (the current write-up is very Rob's thesis specific and fails to call the \"extra induction\" a substitution lemma), which would lead into the version for dependent types. The \"slide\" substitution for dependent types isn't as generally useful as explicit contexts, but it's among the most badass Twelf hacks I know. If you don't mind, I'd like to take this one over, but definitely do transwiki the other answers from the old Q&A.\n\n:: 'swhy I asked. Go for it, and horray for general solutions! [[User:128.2.223.28|128.2.223.28]] 11:57, 22 September 2006 (MST)\n\n== <tt>can</tt> vs. expressiveness ==\n\nDo you still call the <tt>can-</tt> lemmas expressiveness lemmas? That section should include a link to a page about expressiveness lemmas, or whatever we call them, even if it's a redlink for now. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 14:42, 23 September 2006 (MST)\n\n: I'm unaware of any category of lemmas called expressiveness lemmas. Is this something from the old wiki? I can't seem to find a reference to them. --[[User:DanielKLee|DanielKLee]] 14:51, 23 September 2006 (MST)\n\n:: Eek - susmit actually called them \"Effectiveness lemmas\" - whatever it is you call the <tt>can-</tt> lemmas, I feel like they have, or should have, some name. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 15:02, 23 September 2006 (MST)\n\n== Twelf coffee ==\n\nI'm at home today, so no coffee for me. Doesn't seem like anybody did anything since last week anyway. ;) &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 16:41, 4 October 2006 (EDT)\n\n== \"Group\" doesn't work anymore ==\n\nUsing include=\"...\" works similarly - I had to change it to handle multiple inheritance. See [[Project:TwelfTag|the TwelfTag page]] for an explanation of the modified feature, I'm sorry about that. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 17:22, 11 October 2006 (EDT)\n\n: Oh I see... *cry* --[[User:DanielKLee|DanielKLee]] 17:34, 11 October 2006 (EDT)\n\n:: Hang on - I'm going to make \"group\" a silent alias for \"include\". Just don't use it anymore! — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 17:38, 11 October 2006 (EDT)\n\n::: Done. Don't say I never did anything for you :). — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 17:44, 11 October 2006 (EDT)\n\n::: Thanks!! --[[User:DanielKLee|DanielKLee]] 17:45, 11 October 2006 (EDT)"
          },
          "sha1": "44cft70v1rn0dw1ldehm6v78xsz9yw4"
        }
      },
      {
        "title": "User talk:Drdreyer",
        "ns": 3,
        "id": 1981,
        "revision": {
          "id": 4621,
          "timestamp": "2007-03-21T19:02:29Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "minor": null,
          "comment": "New page: Yo! ~~~~",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 94,
            "#text": "Yo! — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 15:02, 21 March 2007 (EDT)"
          },
          "sha1": "k9b5hrwmj86bpv5qhioug4cj136ex28"
        }
      },
      {
        "title": "User talk:Drl",
        "ns": 3,
        "id": 1755,
        "revision": {
          "id": 6249,
          "parentid": 6243,
          "timestamp": "2011-05-20T15:24:05Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "minor": null,
          "comment": "Reverted edits by [[Special:Contributions/Hua220|Hua220]] ([[User talk:Hua220|talk]]) to last revision by [[User:Drl|Drl]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 14162,
            "#text": "Hello! I actually like the monospaced presentation better:\n\n<math>\\texttt{even}(N) \\over \\texttt{even}(s \\, (s \\, N))</math>\n\nYou've got admin rights, btw. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 16:02, 23 October 2006 (EDT)\n\n\n== Sidebar ==\n\nYou might be interested in editing the [[Mediawiki:sidebar|sidebar]]. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 16:51, 23 October 2006 (EDT)\n\n== Oh yeah ==\n\nYou did write one of those papers-about-twelf things, now didn't you? :-) — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 21:50, 20 March 2007 (EDT)\n\n== Aite ==\n\nI'm showering, driving to school, and emailing! — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 09:18, 21 March 2007 (EDT)\n\n== Some small feature requests (didn't want to lose track of these completely) ==\n\n* %reduces under a binder (comes up, e.g. in [[strengthening]]).  When you know (forall x. A x < B), you could at least conclude A < B when x doesn't occur, which as I recall is enough for this example.\n* new emacs mode with karl's macros\n* for world violations, move some of the info that gets printed on higher chatter to the default, so it's easier to debug\n\n== Example (which Adam did much <strike>better</strike> slower than me) == \n\n<twelf>\n\ntp : type.\nunit : tp.\narrow : tp -> tp -> tp.\n\nexp : type.\nlam : (exp -> exp) -> exp.\napp : exp -> exp -> exp.\n\nof : exp -> tp -> type.\nof/app : of (app E1 E2) T\n        <- of E1 (arrow T2 T)\n        <- of E2 T2.\nof/lam : of (lam E) (arrow T2 T)\n       <- {x : exp} of x T2 -> of (E x) T.\n\nfalse : type.\n\n%block ofb : some {T : tp} block {x : exp} {dx : of x T}.\n\nid : tp -> tp -> type.\nrefl : id T T.\n\nlemma : ({x} {dx : of x T} of x T')\n      -> ({x} of x T -> of x (arrow T' T0)) \n      -> false\n      -> type.\n%mode lemma +X1 +X2 -X3.\n\n%worlds (ofb) (lemma _ _ _).\n%total {} (lemma _ _ _).\n\nthm : of (lam [x] (app x x)) T -> false -> type.\n%mode thm +X1 -X2.\n\n- : thm (of/lam [x] [dx] (of/app (D x dx) (D' x dx))) XXX\n  <- lemma D D' XXX. \n\n%worlds (ofb) (thm X Y).\n%total {} (thm X Y).\n\n</twelf>\n\n=== Any var, not just the last one ===\n\n<twelf>\ntp : type.                                                                                                                                                                        ar : tp -> tp -> tp. %infix right 10 ar.                                                                                                                                          \nb : tp.                                                                                                                                                                           \n                                                                                                                                                                                  \nexp : type.                                                                                                                                                                       \napp : exp -> exp -> exp.                                                \nlam : (exp -> exp) -> exp.                                                                                                                                                        \n                                                                                                                                                                                  \nof : exp -> tp -> type.                                                                                                                                                           \nof_app : of E1 (T1 ar T2) -> of E2 T1 -> of (app E1 E2) T2.                                                                                                                       \nof_lam : ({x}of x T1 -> of (E x) T2) -> of (lam E) (T1 ar T2).                                                                                                                    \n                                                                                                                                                                                  \n%block ofblock : some {T:tp} block {x:exp}{u: of x T}.                                                                                                                            \n%worlds (ofblock) (of _ _).                                                                                                                                                       \n                                                                                                                                                                                  \nfalse : type.                                                                                                                                                                     \n                                                                                                                                                                                  \nisvar : exp -> type.                                                                                                                                                              \n                                                                                                                                                                                  \n                                                                                                                                                                                  \n                                                                                                                                                                                  \n%block varBlock : some {T:tp} block {x:exp}{u: of x T}{v:isvar x}.                                                                                                                \n                                                                                                                                                                                  \ncontra : isvar X -> of X T1 -> of X (T1 ar T2) -> false -> type.                                                                                                                  \n%mode contra +V +D1 +D2 -E.                                                                                                                                                       \n%worlds (varBlock) (contra _ _ _ _).                                                                                                                                              \n%total {E1 D1 D2} (contra E1 D1 D2 _).                                                                                                                                            \n                                                                                                                                                                                  \nboo : isvar X -> of (app X X) T -> false -> type.                                                                                                                                 \n%mode boo +X +D -E.                                                                                                                                                               \nboo_lam : boo X (of_app D1 D2) B                                                                                                                                                  \n           <- contra X D2 D1 B.                                                                                                                                                                                                                                                                                                                                   \n                                                                                                                                                                                  \n%worlds (varBlock) (boo _ _ _).                                                                                                                                                   \n%total {} (boo _ _ _).                            \n</twelf>\n\n=== Delphin Version by Adam === \n\n<code>\nsig <tp : type> %name A t                                                                                                                                                         \n    <ar : tp -> tp -> tp> %infix right 10                                                                                                                                         \n    <b : tp> ;                                                                                                                                                                    \n                                                                                                                                                                                  \nsig <exp : type>                                                                                                                                                                  \n    <app : exp -> exp -> exp>                                                                                                                                                     \n    <lam : (exp -> exp) -> exp>;                                                                                                                                                  \n                                                                                                                                                                                  \nsig <of : exp -> tp -> type>                                                                                                                                                      \n    <of_app : of E1 (T1 ar T2) -> of E2 T1 -> of (app E1 E2) T2>                                                                                                                  \n    <of_lam : ({x}of x T1 -> of (E x) T2) -> of (lam E) (T1 ar T2)>;                                                                                                              \n                                                                                                                                                                                  \nsig <false : type>;                                                                                                                                                               \n                                                                                                                                                                                  \nsig <eq : tp -> tp -> type> -> of X (T1 ar T2) -> false -> type.                                                                                                                  \n    <eqid : eq T1 T1>;                                                                                                                                                            \n                                                                                                                                                                                  \nparams = <exp>, <of (E#) T>;                                                                                                                                                      \n                                                                                                                                                                                  \n                                                                                                                                                                                  \ntype contextProp = <x:exp#> -> <(of x T1)> -> <(of x T2)> -> <eq T1 T2>;                                                                                                          \n                                                                                                                                                                                                                                                                                                                                 \n\nfun contraEq : <eq (T1 ar T2) T1> -> <false> = fn .;                                                                                                                              \n                                                                                                                                                                                  \nfun impossible1 : contextProp -> <of (lam [x] app x x) T> -> <false>                                                                                                              \n   = fn C <of_lam ([x][d] of_app (D1 x d) (D2 x d))> =>                                                                                                                           \n           (case {<x>}{<d:of x T1>} contraEq ((C with <x> <d> <d> => <eqid>) <x> <D1 x d> <D2 x d>)                                                                               \n             of {<x>}{<d>}<bot> => <bot>);                                                                                                                                        \n                                                                                            d                                                                                     \n                                                                                                                                                                                  \nfun impossibleGeneral : contextProp -> <x:exp#> -> <of (app x x) T> -> <false>                                                                                                    \n   = fn C <x> <of_app D1 D2> => contraEq (C <x> <D1> <D2>); \n</code>"
          },
          "sha1": "4qebmans0pel7w8jpprlektjkl0b1g4"
        }
      },
      {
        "title": "User talk:Hdeyoung",
        "ns": 3,
        "id": 2209,
        "revision": {
          "id": 5984,
          "timestamp": "2009-04-22T04:12:52Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "Created page with '== Hey, you're on the wiki ==  Made you a member of the \"party-elf\" group; now you should be able to make edits without CAPTCHA-ing! ~~~~'",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 223,
            "#text": "== Hey, you're on the wiki ==\n\nMade you a member of the \"party-elf\" group; now you should be able to make edits without CAPTCHA-ing! — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 00:12, 22 April 2009 (EDT)"
          },
          "sha1": "anzkksrf0jxkys330dqxw14tnhdsu4k"
        }
      },
      {
        "title": "User talk:JakeD",
        "ns": 3,
        "id": 1635,
        "revision": {
          "id": 2264,
          "timestamp": "2006-09-30T05:24:52Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 2,
            "#text": "hi"
          },
          "sha1": "moiryvew7z1nh6cf1srex5j09y58bpe"
        }
      },
      {
        "title": "User talk:Jcreed",
        "ns": 3,
        "id": 1671,
        "revision": {
          "id": 6525,
          "parentid": 6524,
          "timestamp": "2012-06-18T19:18:18Z",
          "contributor": {
            "username": "Jcreed",
            "id": 9
          },
          "comment": "/* Modal encoding */",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 4319,
            "#text": "hi — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 00:43, 7 October 2006 (EDT)\n\n=== Tom7's Twelf Mystery Du Jour ===\nThis is the thing that curiously didn't work:\n<twelf>\no : type.\nk : o.\n\npred : o -> type.\npred2 : (o -> o) -> type.\n\n\npred2/ : {A:o -> o} pred2 A -> pred (A k).\n\nlemma : pred k -> type.\n%mode lemma +T.\n\n- : lemma (pred2/ _ _).\n\n\n%worlds () (lemma _).\n%total D (lemma D).\n</twelf>\nThis is the thing that finally worked:\n<twelf>\nbool : type.\n\no : type.\nk : o.\nl : o.\neq : o -> o -> type.\nrefl : eq X X.\n\npred : o -> type.\npred2 : (o -> o) -> type.\n\npred/k : bool -> pred k.\npred/l : pred l.\npred2/ : {A:o -> o} pred2 A -> pred (A k).\n\nlemma : {A} pred A -> eq A k -> bool -> type.\n%mode lemma +A +T +E -B.\n\n% - : lemma _ (pred2/ _ _) _ true.\n\n- : lemma k (pred/k B) EQ B.\n\n%block bb : block {b : bool} {x:o}.\n%worlds (bb) (lemma _ _ _ _).\n%total D (lemma _ D _ _).\n</twelf>\n\n=== Modal encoding ===\n<twelf>\n% sorts\nsort : type. %name sort S.\nsrc : sort. % term from source language\nrs : sort. % resource\nfm : sort. % frame\nwd : sort. % kripke modal world\nsx : sort. % sequent\n\n\n% terms\ntm : sort -> type. %name tm X.\nz : tm src.\ns : tm src -> tm src.\n/ : tm wd -> tm fm -> tm sx. %infix right 19 /.\n* : tm wd -> tm wd -> tm wd. %infix right 21 *.\n↝ : tm wd -> tm fm -> tm fm. %infix right 20 ↝.\n\n% props\nspos : type. %name spos P.\nsneg : type. %name sneg N.\n\ntpos : type. %name tpos TP.\ntneg : type. %name tneg TN.\n\n-o : spos -> sneg -> sneg.  %infix right 10 -o.\n⊗ : spos -> spos -> spos.  %infix right 11 ⊗.\n&  : sneg -> sneg -> sneg.  %infix right 11 &.\n↑ : spos -> sneg.\n◇ : spos -> sneg.\n↓ : sneg -> spos.\n□ : sneg -> spos.\natm+ : tm src -> spos.\natm- : tm src -> sneg.\n\n⇒ : tpos -> tneg -> tneg.  %infix right 10 ⇒.\n∧ : tpos -> tpos -> tpos.  %infix right 11 ∧.\n∨ : tneg -> tneg -> tneg.  %infix right 10 ∨.\n⇑ : tpos -> tneg.\n∃ : (tm S -> tpos) -> tpos.\n∀ : (tm S -> tneg) -> tneg.\n⇓ : tneg -> tpos.\n≤ : tm S -> tm S -> tpos. %infix right 8 ≤.\n• : tm sx -> tneg.\n\n%abbrev $ = [x] [y] • (x / y).\n%infix right 19 $.\n\nxlpn : spos -> (tm wd -> tneg) -> tneg -> type.\nxlnn : sneg -> (tm fm -> tneg) -> tneg -> type.\n\nxlpn/⊗ : xlpn (P1 ⊗ P2) K Z1\n          <- ({a1} xlpn P2 ([a2] K (a1 * a2)) (Z2 a1))\n          <- xlpn P1 ([a1] Z2 a1) Z1.\n\nxlnn/-o : xlnn (P -o N) K Z1\n          <- ({a} xlnn N ([f] K (a ↝ f)) (Z2 a))\n          <- xlpn P ([a] Z2 a) Z1.\n\nxlnn/↑ : xlnn (↑ P) K (∀ [f] ⇓ (Z f) ⇒ K f)\n          <- {f} xlpn P ([a] a $ f) (Z f).\n\nxlpn/↓ : xlpn (↓ N) K (∀ [a] ⇓ (Z a) ⇒ K a)\n          <- {a} xlnn N ([f] a $ f) (Z a).\n\nxlpp : spos -> tm wd -> tpos -> type.\nxlnp : sneg -> tm fm -> tpos -> type.\n\nxlpp/⊗ : xlpp (P1 ⊗ P2) A (∃ [a1] Z1 a1 ∧ ∃ [a2] Z2 a2 ∧ (a1 * a2 ≤ A))\n          <- ({a1} xlpp P1 a1 (Z1 a1))\n          <- ({a2} xlpp P2 a2 (Z1 a2)).\n\nxlnp/-o : xlnp (P -o N) F (∃ [a] Z1 a ∧ ∃ [f] Z2 f ∧ (a ↝ f ≤ F))\n          <- ({a} xlpp P a (Z1 a))\n          <- ({f} xlnp N f (Z2 f)).\n\nxlpn/↓ : xlpp (↓ N) A (⇓ (∀ [f] (Z f) ⇒ A $ f))\n          <- {f} xlnp N f (Z f).\n\nxlpn/↑ : xlnp (↑ P) F (⇓ (∀ [a] (Z a) ⇒ a $ F))\n          <- {a} xlpp P a (Z a).\n\n</twelf>\n\n=== Looking at the equality proof ===\n\nA simple test of looking at the equality proof and seeing that in each case it is refl:\n\n<twelf>\nlook-at-eq : {A : o -> o} eq (A k) k -> type.\n%mode look-at-eq +A +D.\n\n- : look-at-eq ([x] x) refl.\n- : look-at-eq ([x] k) refl.\n\n%worlds () (look-at-eq _ _).\n%total {} (look-at-eq _ _).\n</twelf>\n\nDoes this show that you can do any decomposition you'd want to do?\n[[User:Drl|Drl]] 18 October 2007\n\n=== A Copy Function ===\n<twelf>\no : type.\neq : o -> o -> type.\nrefl : eq X X.\nk : o.\nl : o.\n\nho : (o -> o) -> type.\n\n%block b : some {A : o -> o} block {x : ho A}.\n\nsrc : o -> type.\ndst : o -> type.\n\nsrc/base : src X.\nsrc/ho : ho A -> src (A k).\n\ndst/base : dst k.\ndst/ho : ho A -> dst k.\n\nlemma :  src A -> eq A k -> dst k -> type.\n- : lemma src/base EQ dst/base.\n- : lemma (src/ho HO) EQ (dst/ho HO).\n\n%mode lemma +S +E -D.\n%worlds (b) (lemma _ _ _).\n%total D (lemma D _ _ ).\n\ncopy :  src k -> dst k -> type.\n- : copy A B <- lemma A refl B.\n\n%mode copy +S -D.\n%worlds (b) (copy _ _).\n%total D (copy D _).\n</twelf>\n[[User:Jcreed|Jcreed]] 15:15, 18 October 2007 (EDT)"
          },
          "sha1": "k8ug8fj4hsppwsa5gwsiq97zzqu9qky"
        }
      },
      {
        "title": "User talk:Neel",
        "ns": 3,
        "id": 1928,
        "revision": {
          "id": 4327,
          "timestamp": "2007-03-19T21:59:08Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "New page: Welcome to Twelf (I don't like seeing red) ~~~~",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 133,
            "#text": "Welcome to Twelf (I don't like seeing red) — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 17:59, 19 March 2007 (EDT)"
          },
          "sha1": "jfx9qtvhh40kzaiuw8tdjeh0zebytf2"
        }
      },
      {
        "title": "User talk:Popik",
        "ns": 3,
        "id": 2033,
        "revision": {
          "id": 5064,
          "timestamp": "2008-02-15T03:08:15Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "New page: You are the weakest link. Goodbye! (indefinite block) ~~~~",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 147,
            "#text": "You are the weakest link. Goodbye! (indefinite block) — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 22:08, 14 February 2008 (EST)"
          },
          "sha1": "q6di8f64n4hzrdbku1fhx1s3tgdvf2y"
        }
      },
      {
        "title": "User talk:Rpollack",
        "ns": 3,
        "id": 2035,
        "revision": {
          "id": 5072,
          "parentid": 5071,
          "timestamp": "2008-02-28T19:27:58Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "minor": null,
          "comment": "balanced parens",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 203,
            "#text": "Welcome! (You've been added to the \"known humans\" group so you don't have to fill in [[w:Captcha|Captcha]]s.) — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 14:27, 28 February 2008 (EST)"
          },
          "sha1": "ow5r793lkoepc0eo4p5pa39sqwonajp"
        }
      },
      {
        "title": "User talk:Rsimmons",
        "ns": 3,
        "id": 1440,
        "revision": {
          "id": 7906,
          "parentid": 7905,
          "timestamp": "2013-05-30T23:05:20Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "minor": null,
          "comment": "Protected \"[[User talk:Rsimmons]]\" ([edit=sysop] (indefinite) [move=sysop] (indefinite))",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 9816,
            "#text": "== Twelf Blog ==\n\nI think the environment subtyping stuff will make a great early entry into the Twelf Blog. On the announcement for it on the frontpage, I noticed that you referred to a \"Dan\" doing the entry. It takes a while for it to set it, but there are a lot of Dans in the POP group, and unfortunately both Dans who do Twelf related stuff are Dan Ls. I'm a wiki n00b, so I can't figure out how to edit that particular column (it seems locked down), but it might be less confusing to disambiguate that. Will I need to register for the blog seperately? --[[User:DanielKLee|DanielKLee]] 21:53, 5 September 2006 (MST)\n\n== linking to cats ==\n\nYou can link to a category by writing <nowiki>[[:Category:tutorials|tutorials]]</nowiki>, which looks like [[:Category:tutorials|tutorials]]. [[User:Tom7|Tom7]] 09:42, 6 September 2006 (MST)\n\n== most wanted articles ==\n\nMy list of most-wanted articles:\n* [[um.elf]] \n* [[Image:Tom_Twelfelf2.jpg|thumb|left]]\n&nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 13:54, 14 September 2006 (MST)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n== Tiny issue with syntax highlighting ==\n\nThe syntax highlighter does not consider * to be part of an identifier. See the second half of [[substitution lemma]] to see an example of what I mean. This is a pretty minor issue, all things considered. --[[User:DanielKLee|DanielKLee]] 14:30, 24 September 2006 (MST)\n\n== Wiki ==\nYou keep breakin' it! ;) &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 19:43, 4 October 2006 (EDT)\n\n== noinclude ==\n\n[http://twelf.plparty.org/w/index.php?title=User_talk%3ATom7&diff=2569&oldid=2384 re] My favorite would be if noinclude=\"true\" were a derived form for name=\"_\", meaning to bind the useless name _. If you want to rename it, I would vote for discard=\"true\", but I can't think of any reason to do that... &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 18:31, 10 October 2006 (EDT)\n* Oh, sorry, I forgot the confusion between \"include\" and \"noinclude\". I support renaming it to discard=\"true\", but maybe people can just do name=\"_\"? Is that too weird? &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 18:35, 10 October 2006 (EDT)\n\n== I LF Bees ==\n\nI started a page at [[Project:1.0]] where we can plan for a wide release, and seeded it with demands. Your thoughts are welcome... &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 13:49, 16 October 2006 (EDT)\n\n== Sad ==\n\nI yearn for the era of daily Twelfwiki breakage! Thesisland is just not as much fun... &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 13:09, 13 December 2006 (EST)\n* Hooray, someone else is editing! &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 00:18, 25 December 2006 (EST)\n\n== mlton builds ==\n\nHey, I was just helping a student build Twelf at Dagstuhl; he used the experimental mlton release for x86-Darwin. Experimental builds of mlton return a version string of 'MLTONVERSION' which then fails in the build process. Can we fix this so that the report \"version XXXX or greater required\" is actually a warning? I think a large fraction of mlton users are using experimental or CVS releases since they are programmers themselves. &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 05:29, 31 January 2007 (EST)\n:: I believe that the change has been commited to Twelf CVS. If you can, check it out and verify that it works? I just added a new if-branch for MLTONVERSION, and if that does not work I'll change the error to a warning. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 10:13, 31 January 2007 (EST)\n\n== spam filter ==\n\nAlso, can you disable the spam filter for admins?? It won't let me save my changes. &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 05:50, 31 January 2007 (EST)\n: It would be tricky to disable the spam filter regex just for admins, because if the forbidden string appears on the page then only admins would be able to edit it henceforth. However, if you need to disable some things, go ahead - just deleting style from the LocalSettings was the right thing to do; if it didn't work, go ahead and replace it with the more html-fu permissive setting from http://meta.wikimedia.org/wiki/Anti-spam_Features — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 10:11, 31 January 2007 (EST)\n:: After a few minutes (I realize you aren't up at 5:50am) I found the place where the spam filter was defined and temporarily disabled it so that I could make the edits I need to. If it continues to be a problem I'll see about improving the filter... &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 17:15, 31 January 2007 (EST)\n::: I'm up then more than I should be; just make sure to leave the spam filter \"weakened\", like I said, pages with spam-filter-opposing content are effectively uneditable. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 17:57, 31 January 2007 (EST)\n:::: Point taken, but this is for {{tl|click-inline}} which IMO should never be edited by non-admins (or really ever at all). &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 06:11, 1 February 2007 (EST)\n\n== Tex broke ==\n\nThe <nowiki><math></nowiki> tag ain't workin'; viz [[lists]]. &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 23:32, 24 February 2007 (EST)\n: This is why I keep the old mediawiki files around for awhile after an upgrade; we're back up and running, I'll have to add \"make texvc work again\" to my list of upgrade tasks. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 01:24, 25 February 2007 (EST)\n\n== SVG ==\n\nThanks for making more keyword articles. Do you think it makes sense perhaps to separate them into \"rarely used\" and \"frequently used\" or perhaps by category of what kind of thing you want to do? A lot of these keywords I don't even know what they are because I've never used them, even though I've written like tens of thousands of lines of Twelf.\n\n: Instead of that distinction, as you use Twelf in a distinctive way like most here :), and I'm not sure how to clearly categorize things, I was imagining an additional Big Four template of some sort that described %mode %block %worlds %total - the keywords you need to specify [[totality assertions]]. This is a tricky distinction - what about %covers %reduces %terminates - but however you slice it, I was going to just specify that set, and leave the rest in the big jumble on the template - I think the idea is people find these by clicking on a link in an article, anyway. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 12:20, 28 February 2007 (EST)\n:: OK, that sounds good! It's just that if I click on some of those keywords, I might get the sense that I need to understand them in order to use Twelf. As long as there is something to dispell that myth, I'm on board. &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 14:21, 28 February 2007 (EST)\n\nAlso, if you install SVG support I will make you some nice tree graphics. &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 10:23, 28 February 2007 (EST)\n\n: I already have some trees in Adobe Illustrator I was going to use, I've been unable to track down clear and decisive information about SVG and mediawiki (are you sure it doesn't already support it?) but I'll try the IRC channel again today. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 12:20, 28 February 2007 (EST)\n:: I tried uploading a SVG file and it wouldn't let me, so I'm pretty sure the extension isn't there. If you are using AI then SVG is the right format to upload in, so they can be resized and edited without losing the original form. It might be hard to get the SVG extension working though, I don't know. &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 14:21, 28 February 2007 (EST)\n\n== done ==\n\nI made reasonable stubs for most of the remaining glossary entries.  As far as I'm concerned, if you patch [[%total]] a little, we can announce. [[User:Drl|Drl]] 00:54, 21 March 2007 (EDT)\n\n== twelf sources with .cm ==\n\nFYI: the Twelf source tarball on your snazzy download page includes SML/NJ .cm directories, which are worse than useless because they can confuse/crash SML/NJ and make the tarball 3x the size it needs to be. &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 16:50, 23 October 2007 (EDT)\n: This broke because I ran a rogue compile a few weeks ago; I should be able to put it back together tomorrow. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 01:08, 24 October 2007 (EDT)\n:: Should be fixed. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 12:09, 24 October 2007 (EDT)\n\n== front page news ==\n\nHallo!\nI'm not a twelf guy, and am just looking into logic programming.\nI am unfamiliar with your specialized terms... which means that this doesn't parse for me - could you perhaps translate it back into a form of natural language?\n\n\"Rob has a case study on lax logic that uses the admissibility of cut and identity show a sound and complete correspondence between two sequent calculus presentations of lax logic.\"\n\n1. Rob [presents] a case study on lax logic.\n\n2. The lax logic model used assumes the admissibility of \"cut and identity\".\n\n*** help! Brain overflow... does not parse! *** So we guess...\n3. The lax logic model shows a \"sound and complete correspondence\" when tested using two sequent calculus presentations of lax logic?\n\nIs it self referential? Does lax logic mean something different each time it is used?\n\nI suspect there's a decent tutorial to be had just explaining that sentence. :)\n\n== Twelf Live broken? ==\n\nHi Rob. It says on the front page to contact you if anything is broken. Well, Twelf Live doesn't seem to work. I was looking forward to trying it. Cheers.\n:: Hi! Thanks for noticing that, I moved some stuff and deleted some code and forgot to update links and test that. Twelf Live is a bit rougher than it's supposed to be at the moment (lots of superfluous %% OK %%s) but it's the best I could do on short notice; I'll get back around to it. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 11:41, 9 September 2010 (EDT)"
          },
          "sha1": "8qa6zzmxifdqr7pgoncdv1ol30wa4ue"
        }
      },
      {
        "title": "User talk:Spoons",
        "ns": 3,
        "id": 1686,
        "revision": {
          "id": 2933,
          "parentid": 2932,
          "timestamp": "2006-10-18T02:29:15Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 169,
            "#text": "hi\n\nhello, everyone [[User:Spoons|Spoons]] 21:58, 17 October 2006 (EDT)\n* You're [[User:Spoons|red]]! &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 22:29, 17 October 2006 (EDT)"
          },
          "sha1": "9foj0whxi1llqoku0pxowmdxf4fj24o"
        }
      },
      {
        "title": "User talk:Twilson",
        "ns": 3,
        "id": 1982,
        "revision": {
          "id": 6248,
          "parentid": 6244,
          "timestamp": "2011-05-20T15:23:59Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "minor": null,
          "comment": "Reverted edits by [[Special:Contributions/Hua220|Hua220]] ([[User talk:Hua220|talk]]) to last revision by [[User:Rsimmons|Rsimmons]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 77,
            "#text": "Woo bugfixes! — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]])"
          },
          "sha1": "92vwe1p1v7f47ov0nw24crr12crjlf6"
        }
      },
      {
        "title": "User talk:Varming",
        "ns": 3,
        "id": 1698,
        "revision": {
          "id": 2693,
          "timestamp": "2006-10-12T13:33:22Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "comment": "red be gone",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 162,
            "#text": "== red be gone ==\n\nI hate seeing red so here is a message for you to make your talk page blue! &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 09:33, 12 October 2006 (EDT)"
          },
          "sha1": "16uteqhprz33ch8n0acinexe3an3h4v"
        }
      },
      {
        "title": "User talk:William Lovas",
        "ns": 3,
        "id": 1658,
        "revision": {
          "id": 5027,
          "parentid": 2401,
          "timestamp": "2007-11-09T18:43:56Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 307,
            "#text": "hi\n\nlo [[User:William Lovas|William Lovas]] 03:57, 6 October 2006 (EDT)\np.s. plz sign ur comments, n00b!\n\n{{vdash}} {{dia}} {{box}} {{lolli}} {{otimes}} {{top}} {{darrow}} {{forall}} {{exists}} {{oplus}} {{bottom}} — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 13:43, 9 November 2007 (EST)"
          },
          "sha1": "jluq44059y0yq1sxud1paharycmy26h"
        }
      },
      {
        "title": "The Twelf Project:1.0",
        "ns": 4,
        "id": 1729,
        "revision": {
          "id": 4613,
          "parentid": 4605,
          "timestamp": "2007-03-21T15:18:49Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "comment": "/* Tom's demands */ marking off some more things",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 7841,
            "#text": "This page is about plans for a '''1.0''' release of the Twelf Wiki.\n\n== Press Release ==\n\nSubject: New Twelf Wiki\n\nWe are pleased to announce the Twelf Wiki, a major new source of documentation about Twelf:\n\n: http://twelf.plparty.org\n\nTwelf is a tool used to specify, implement, and prove properties of deductive systems.  The wiki includes:\n* A new introduction to LF and Twelf.\n* Tutorials on common Twelf tricks and techniques.\n* Case studies of larger applications of Twelf, including encodings of and proofs about linear logic, mutable state, and CPS conversion.\n* Pre-compiled CVS builds of Twelf for Linux and Windows.\n\nWe invite you to come share what you know, learn from what's there, and ask questions about what's not.\n\nThe Twelf Wiki Team\n\n\n:* I'm tempted to say we should say \"a major ''and growing''\" or something to indicate that this is a work in progress, but perhaps [http://dictionary.oed.com/cgi/entry/50293088?query_type=word&queryword=wiki&first=1&max_to_show=10&single=1&sort_type=alpha with wiki being a real word and all] this isn't necessary... — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 03:47, 20 March 2007 (EDT)\n\n:: The thing I don't like about that is that it can give the impression that we're hedging on the \"major\"---that it will someday be major, but isn't yet (even though that's not what \"major and growing\" really means).  Also, I think the last line makes it clear that people will be adding new stuff. [[User:Drl|Drl]] 09:55, 20 March 2007 (EDT)\n\n: We should either say both \"encodings of and proofs about\" or something like that or junk them both.  We don't want to give people the impression that it's just an LF signature. [[User:Drl|Drl]] 09:26, 21 March 2007 (EDT)\n\n== PL Party Coffee - Notes ==\n\nThe first two subsections, where things are assigned, are things that we'd like to have done by next Wednesday. Things that are unassigned will be claimed before then moved to the [[Project:To do|To do]] list at that point, if not before.\n\nDoing things off the [[Project:To do|To do]] list are also good things to do!\n\n=== Come to the site, learn to use Twelf ===\n\n* Rewriting the pointers into these things: ''Tom and Dan Licata to revise''\n:* [[General description of Twelf]] - ''Will to revise''\n:* [[Reading a Twelf proof]] - ''DKLee\"\n::* How to read declarations of proofs (type family + mode + worlds + total)\n::* Why the cases in the middle don't matter at that point\n::* Adequacy!\n::* Minimal on syntax\n:* [[Proving metatheorems with Twelf]] - ''Dan Licata''\n:* The \"forest\" - Case studies, Tutorials, Glossary - Redlinks to be attacked by ''Aleffert'', ''Spoons'' (?) and others (Also see [[Special:Wantedpages]])\n\n=== Neat Things ===\n\n* <strike>Cut elimination - ''Tom''</strike>\n* Double negation translation - ''Jcreed''\n* Language with store - ''Rob''\n* Classical logic - ''Will''\n* <strike>False dependencies/strengthening - ''Jake''</strike>\n* Mutual and lexographic induction - ''Jcreed'' \n::(maybe handed in [[admissibility of cut]] already?)\n* Translating between logics - \n* Heriditary substitution - \n* Canonical forms -\n* Reverse the polarity -\n\n== Tom's demands ==\n\n: ''DRL, on March 21, says: Peace in our time!  I claim that the vast majority of Tom's demands have been appeased.''\n\nI think it is very important that we have a certain base level of content before we release this on the world. I have seen may projects like this die because they failed to gain sufficient momentum from the initial release. We have enough resources to make this wiki successful, so I will be the annoying one that insists that it meet a certain level of content and quality before we announce it.\n\nHere are some specific demands. If we already have these, or you address them, then please respond:\n\n* There needs to be a path, for a patient someone of undergraduate computer science education, to learn how to use Twelf in a basic way. They should be able to define, say, MinML and prove type safety for it. They should understand the meaning of the metatheorem, including the [[%worlds]] declaration and adequacy (it should not simply be a ''cut'n'paste'' understanding). By path, I mean that they should be able to start on some page, read a linear sequence of tutorials, and then have this knowledge.\n:: [[User:drl]]'s tutorial [[Proving metatheorems with Twelf]] will satisfy this when complete, as long as the undergraduate education had a 15-312 like class. &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 09:48, 26 February 2007 (EST)\n\n* There needs to be a stub article (at least) for each of the Twelf declarations. When reading a tutorial on the site, users need to be able to see documentation for the keywords. These can start by being short summaries with links into the User's Guide.\n:: I'm satisfied on this. &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 11:18, 21 March 2007 (EDT)\n\n* There needs to be a good article at [[metatheorem]], which could perhaps be a wikified ''How to Believe a Twelf Proof''. This material proves to be a major stumbling block for getting even eminent type theorists to understand what Twelf is and how to use it.\n: [[Metatheorem]] exists, and I think it's in a position where some criticism of it would be helpful; however, the DKLee-task-lisked HtBaTP-equivalent article is going to be [[Reading a Twelf proof]] - I'd be particularly happy to see this one by launch but I don't consider it a dealbreaker either. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 01:48, 28 February 2007 (EST)\n\n* There needs to be more content that will be new to, say, the POPLmark crowd. We should have tutorials that explain how to do some things in Twelf that people actually want to do in their research, like <s>[[linear logic]]</s>, normalization via <s>[[cut elimination]]</s>, and [[closure conversion]].\n\n* We need to have good man pages for the most important declarations for mechanizing metatheory: [[%worlds]] [[%block]] [[%total]].\n\n* We need at least minimal articles about the most important Twelf concepts, ''e.g.'' <s>[[subordination]]</s>, <s>[[LF]]</s>, <s>[[adequacy]]</s>, <s>[[canonical form]]</s>, <s>[[unification]]</s>, <s>[[ground]]</s>, [[kind]], [[subterm]]. I mean, really. If these are covered in the tutorials, we should extract those discussions to seed these pages. <s>Also, some other important articles are very incomplete, embarrassing stubs right now (''e.g.'' [[totality assertion]]).</s>\n\n::* Reading back over this list I don't disagree with most of these, and the half articles I have also identified as something I/we definitely need to address - but some of this is just the effect of us psyching ourselves out because we've held onto this too long already (i.e. \"well, it's been long enough we should have...\") which will lead to us never releasing the thing. An article on unification before the release would be great, but it absense won't prevent this from being a useful resource to some undergraduate somewhere. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 11:37, 26 February 2007 (EST)\n:::* I think it will, because questions like \"what is unification?\" or \"what is subordination?\" are very natural when learning Twelf, and if unanswered, are a large impediment to understanding what's going on. &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 16:01, 26 February 2007 (EST)\n::::* I'm not arguing with your point, but at what point does the absense of ''this wiki'' become a larger impediment than the absense of ''something on this wiki''? :-) — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 16:46, 26 February 2007 (EST)\n\n* ((more soon..))\n\n:::::::&nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 13:43, 16 October 2006 (EDT)\n:::::::&nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 09:48, 26 February 2007 (EST)\n:::::::&nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 11:18, 21 March 2007 (EDT)"
          },
          "sha1": "9lkj6pahe179q89d23wftz3cisdyfbe"
        }
      },
      {
        "title": "The Twelf Project:AJALF",
        "ns": 4,
        "id": 1724,
        "revision": {
          "id": 3454,
          "parentid": 2976,
          "timestamp": "2006-12-29T08:58:07Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "minor": null,
          "comment": "/* Bugs and issues */ redlink patrol",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 955,
            "#text": "'''AJALF''' is the technology used to power [[Twelf Live]] and the [[Project:TwelfTag#Quick_check|Quick Twelf Check]] button. It stands for \"Asynchronous Javascript and LF.\"\n\n== Quick check ==\n\nQuick check is implemented as a MediaWiki extension (extensions/AJALF.php) that introduces a new tag, <nowiki><ajalf>...</ajalf></nowiki>. The tag adds a button\n\n:<ajalf>(unused)</ajalf>\n\nwhich gleans twelf code from the edit window and passes it to the Twelf server (currently at <tt>/tomtest.php</tt>). The button only works on edit pages, so there is no reason to ever use this tag outside the editor interface. It is included in the interface via a customization of the [[MediaWiki:Copyrightwarning]] string.\n\n\n== Bugs and issues ==\n* Quick check does not support any of the [[Project:TwelfTag|TwelfTag]] parameters.\n* The output of Quick check appears to escape apostrophes for some reason.\n* The layout of the close and info buttons is terrible.\n\n{{stub}}"
          },
          "sha1": "0qgz4rrin1ykfx9nngcbx3swidk83mz"
        }
      },
      {
        "title": "The Twelf Project:About",
        "ns": 4,
        "id": 1444,
        "redirect": {
          "@title": "About The Twelf Project",
          "#text": null
        },
        "revision": {
          "id": 1586,
          "timestamp": "2006-09-06T14:12:29Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "[[The Twelf Project:About]] moved to [[About The Twelf Project]]: This page is more accurately about twelf than about the wiki.",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 37,
            "#text": "#REDIRECT [[About The Twelf Project]]"
          },
          "sha1": "3rn7b07wrurxckdlgieypcr29lzs7nu"
        }
      },
      {
        "title": "The Twelf Project:Administrators",
        "ns": 4,
        "id": 1854,
        "redirect": {
          "@title": "The Twelf Project:Contributors",
          "#text": null
        },
        "revision": {
          "id": 3683,
          "timestamp": "2007-02-22T07:20:16Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "[[The Twelf Project:Administrators]] moved to [[The Twelf Project:Contributors]]: More egalitarian; names and associations being collected is nice.",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 44,
            "#text": "#REDIRECT [[The Twelf Project:Contributors]]"
          },
          "sha1": "n1dk1x3r8ictcrm7t1lm2haoxd1lkld"
        }
      },
      {
        "title": "The Twelf Project:BY-NC",
        "ns": 4,
        "id": 1431,
        "revision": {
          "id": 1535,
          "parentid": 1534,
          "timestamp": "2006-09-05T19:57:06Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 435,
            "#text": "==Some Rights Reserved==\n\nFor any page marked with the tag <nowiki>{{license-by-nc}}</nowiki>, the content is available to you under the terms of the Creative Commons Attribution-Noncommercial license.\n\n* A summary of this license is available at http://creativecommons.org/licenses/by-nc/2.5/\n* The actual license is available at http://creativecommons.org/licenses/by-nc/2.5/legalcode\n\nSee [[Project:Copyright]] for more information."
          },
          "sha1": "6kyjf68gk7a27zcpare1ctvgj2n4qnk"
        }
      },
      {
        "title": "The Twelf Project:BY-SA",
        "ns": 4,
        "id": 1432,
        "revision": {
          "id": 1536,
          "parentid": 1533,
          "timestamp": "2006-09-05T19:57:19Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 432,
            "#text": "==Some Rights Reserved==\n\nFor any page marked with the tag <nowiki>{{license-by-sa}}</nowiki>, the content is available to you under the terms of the Creative Commons Attribution-ShareAlike license.\n\n* A summary of this license is available at http://creativecommons.org/licenses/by-sa/2.5/\n* The actual license is available at http://creativecommons.org/licenses/by-sa/2.5/legalcode\n\nSee [[Project:Copyright]] for more information."
          },
          "sha1": "np8nj1fsfpf327mkwk52xu0imrssgju"
        }
      },
      {
        "title": "The Twelf Project:Bureaucrats",
        "ns": 4,
        "id": 1634,
        "redirect": {
          "@title": "The Twelf Project:Contributors",
          "#text": null
        },
        "revision": {
          "id": 3687,
          "parentid": 2261,
          "timestamp": "2007-02-22T07:27:45Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "path compression",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 44,
            "#text": "#REDIRECT [[The Twelf Project:Contributors]]"
          },
          "sha1": "n1dk1x3r8ictcrm7t1lm2haoxd1lkld"
        }
      },
      {
        "title": "The Twelf Project:Contributing",
        "ns": 4,
        "id": 1392,
        "revision": {
          "id": 4968,
          "parentid": 4962,
          "timestamp": "2007-10-13T13:23:52Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "minor": null,
          "comment": "Reverted edits by [[Special:Contributions/129.123.104.8|129.123.104.8]] ([[User_talk:129.123.104.8|Talk]]); changed back to last version by [[User:Rsimmons|Rsimmons]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 1673,
            "#text": "Welcome to the Twelf Project. If you are interested in helping in any way, your contributions would be welcomed and appreciated! We encourage you to [[Special:Userlogin&type=signup | sign up for an account]] so that we can say hello to you by name and not IP address. However, currently the wiki is editable by anyone, so logging in is not required. \n\nThese links might be useful:\n\n* [[Project:TwelfTag]] - syntax highlighting & inline code checking\n* [[Project:Literate Twelf]] - a hack of TwelfTag that makes it very easy to write Twelf offline in a wiki-friendly way\n* [[Project:To do]] - the work queue for wiki contributors\n* [[Project:Style guide]] - a style guide for contributions to the Twelf Project Wiki (not to be confused with [[Twelf style guide]], which talks about style of Twelf code, which is also useful)\n* [[Project:Copyright]] - this wiki is generally available under a license which allows open use, but we have provisions if you cannot, or do not wish to, contribute content with that license.\n* [[Project:Administrators]] - people that can help you if you have a problem.\n* You can edit the individual sections of the front page by following the links at [[Talk:Main Page]].\n\nIf you have any need for \"admin\" status on the wiki to do things like delete pages and edit protected pages, just ask an [[Project:Administrators|current administrator]] - it should be no problem, though it would help if we know who you are and have met you in person. If you're interested in sharing your knowledge with others, become a volunteer Twelf helper by leaving a message at [[Talk:Ask Twelf Elf]].\n\nThanks and welcome!\n\n- Administrators of the Twelf Project Wiki"
          },
          "sha1": "ghei7jhbu3pwaw7uj1rz5a855m0j7ym"
        }
      },
      {
        "title": "The Twelf Project:Contributors",
        "ns": 4,
        "id": 1368,
        "revision": {
          "id": 8188,
          "parentid": 4665,
          "timestamp": "2017-02-11T15:08:04Z",
          "contributor": {
            "username": "Boyland",
            "id": 17
          },
          "minor": null,
          "comment": "Updated my listing to reflect status added last year.",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 1118,
            "#text": "If you have a question or need assistance, your best bet is probably to [http://twelf.plparty.org/w/index.php?title=User_talk:Rsimmons&action=edit&section=new leave a message for Rob] or [http://twelf.plparty.org/w/index.php?title=User_talk:Tom7&action=edit&section=new leave a message for Tom]. \n\n* [[User:Aleffert]] - Akiva Leffert\n* [[User:Boyland]] - John Boyland (Bureaucrat: can change user privileges)\n* [[User:Crary]] - Karl Crary\n* [[User:DanielKLee]] - Daniel K. Lee\n* [[User:Drdreyer]] - Derek R. Dreyer\n* [[User:Drl]] - Daniel R. Licata (Bureaucrat: can change user privileges)\n* [[User:JakeD]] - Jacob Donham\n* [[User:Jcreed]] - Jason C. Reed\n* [[User:Neel]] - Neel Krishnaswami\n* [[User:Rsimmons]] Robert J. Simmons (Bureaucrat: can change user privileges)\n* [[User:Rwh]] - Robert Harper\n* [[User:Spoons]] - Daniel Spoonhower\n* [[User:Tom7]] - Tom Murphy VII (Bureaucrat: can change user privileges)\n* [[User:Twilson]] - J. Todd Wilson\n* [[User:Varming]] - Carsten Varming\n* [[User:William Lovas]] - William Lovas\n\n== See also ==\n* [[Special:Listusers]] is always up-to-date, but has no explanatory text."
          },
          "sha1": "6t0vbjto5eitytq2592097dfv2jharh"
        }
      },
      {
        "title": "The Twelf Project:Copyright",
        "ns": 4,
        "id": 1424,
        "revision": {
          "id": 6163,
          "parentid": 6162,
          "timestamp": "2010-10-05T15:40:37Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "minor": null,
          "comment": "Protected \"[[The Twelf Project:Copyright]]\" ([edit=sysop] (indefinite) [move=sysop] (indefinite))",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 3104,
            "#text": "'''The following policy applies ''only'' to code and content posted to this wiki, NOT to any version of the Twelf program itself or to documentation linked to from the wiki (for instance, the Twelf User's Guide.)'''\n\nIn general, all edits to The Twelf Project wiki are covered by the [[Project:MIT license | MIT License]] which allows essentially unlimited use for any reason. If a page on the wiki is not tagged with one of the license tags described in the section below, then it is under the MIT License, and if you edit an article with no tag and do not add one, you are agreeing to also licence your edits under the MIT License.\n\n==Restrictive licenses==\n\nSome code and content is already licensed under different rules, and some authors do not wish to release their work to open use. While we suggest using the default open license, we want to allow the most content to be accessed from this wiki in the complicated world in which we live.\n\nIn service of this goal, we support the following four licenses, which can be invoked by placing the corresponding tag at the bottom of a page. \n\nIf you edit a page with one of these tags, you agree that your contributions are released under and controlled by that license. License tags may not be deleted unless \n* you are the one that added the tag, and\n* no one else has edited the article since you added the tag.\n* you are only removing a subset of multiple tags on a page (effectively de-multi-licensing the page)\n\nPlease contact the [[Project:Administrators | project administrators]] if you need a different license supported for some reason.\n\n===Adding a tag to an existing page===\n\nA page in the Twelf Project wiki can either start out with one of the license tags, or one can be added after the page's creation. \n\nLegally, existing content under the default MIT license can be changed to any one of the four licenses below by adding a tag. '''This is strongly discouraged and is only permitted in exceptional circumstances''', as the original author(s) intended to release the page under the MIT License. If you edit an existing page and add a license tag, [[Project:Administrators|administrators]] can and will delete all your changes (as well as the tag) if your changes are not substantial and positive.\n\n===GNU General Public License===\n\nFor GNU GPL content, add the <nowiki>{{license-gpl}}</nowiki> tag to the bottom of your page. See [[Project:GPL]] for more information.\n\n{{license-gpl}}\n\n===GNU Free Documentation License===\n\nFor GNU FDL content, add the <nowiki>{{license-gfd}}</nowiki> tag to the bottom of your page. See [[Project:GFDL]] for more information.\n\n{{license-gfdl}}\n\n===Creative Commons Attribution-ShareAlike License ===\n\nFor CC BY-SA content, add the <nowiki>{{license-by-sa}}</nowiki> tag to the bottom of your page.\n\n{{license-by-sa}}\n\n===Creative Commons Attribution-Noncommercial License ===\n\nFor CC BY-NC content, add the <nowiki>{{license-by-nc}}</nowiki> tag to the bottom of your page. ''Note: we discourage use of this license because of its extreme incompatibility with other free licenses.''\n\n{{license-by-nc}}"
          },
          "sha1": "9xwg5ghr2ouzh4t2vztqd905uudkffj"
        }
      },
      {
        "title": "The Twelf Project:Copyrights",
        "ns": 4,
        "id": 1426,
        "redirect": {
          "@title": "The Twelf Project:Copyright",
          "#text": null
        },
        "revision": {
          "id": 1508,
          "timestamp": "2006-09-04T06:09:29Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "[[The Twelf Project:Copyrights]] moved to [[The Twelf Project:Copyright]]: fix plural",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 41,
            "#text": "#REDIRECT [[The Twelf Project:Copyright]]"
          },
          "sha1": "hvfrth8l7tpnqti1fsy62bodykofk7k"
        }
      },
      {
        "title": "The Twelf Project:GFDL",
        "ns": 4,
        "id": 1428,
        "revision": {
          "id": 1530,
          "parentid": 1529,
          "timestamp": "2006-09-05T19:54:22Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "minor": null,
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 20938,
            "#text": "For any page marked with the tag <nowiki>{{license-gfdl}}</nowiki>, permission is granted to copy, distribute and/or modify the document under the terms of the GNU Free Documentation License, Version 1.1 or any later version published by the Free Software Foundation; with no Invariant Sections, no Front-Cover Texts and no Back-Cover Texts.  A copy of the license is included in the section entitled \"GNU Free Documentation License\".\n\nSee [[Project:Copyright]] for more information.\n\n== GNU Free Documentation License ==\n\n<code>\t\tGNU Free Documentation License\n\t\t  Version 1.2, November 2002\n\n\n Copyright (C) 2000,2001,2002  Free Software Foundation, Inc.\n     51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n\n0. PREAMBLE\n\nThe purpose of this License is to make a manual, textbook, or other\nfunctional and useful document \"free\" in the sense of freedom: to\nassure everyone the effective freedom to copy and redistribute it,\nwith or without modifying it, either commercially or noncommercially.\nSecondarily, this License preserves for the author and publisher a way\nto get credit for their work, while not being considered responsible\nfor modifications made by others.\n\nThis License is a kind of \"copyleft\", which means that derivative\nworks of the document must themselves be free in the same sense.  It\ncomplements the GNU General Public License, which is a copyleft\nlicense designed for free software.\n\nWe have designed this License in order to use it for manuals for free\nsoftware, because free software needs free documentation: a free\nprogram should come with manuals providing the same freedoms that the\nsoftware does.  But this License is not limited to software manuals;\nit can be used for any textual work, regardless of subject matter or\nwhether it is published as a printed book.  We recommend this License\nprincipally for works whose purpose is instruction or reference.\n\n\n1. APPLICABILITY AND DEFINITIONS\n\nThis License applies to any manual or other work, in any medium, that\ncontains a notice placed by the copyright holder saying it can be\ndistributed under the terms of this License.  Such a notice grants a\nworld-wide, royalty-free license, unlimited in duration, to use that\nwork under the conditions stated herein.  The \"Document\", below,\nrefers to any such manual or work.  Any member of the public is a\nlicensee, and is addressed as \"you\".  You accept the license if you\ncopy, modify or distribute the work in a way requiring permission\nunder copyright law.\n\nA \"Modified Version\" of the Document means any work containing the\nDocument or a portion of it, either copied verbatim, or with\nmodifications and/or translated into another language.\n\nA \"Secondary Section\" is a named appendix or a front-matter section of\nthe Document that deals exclusively with the relationship of the\npublishers or authors of the Document to the Document's overall subject\n(or to related matters) and contains nothing that could fall directly\nwithin that overall subject.  (Thus, if the Document is in part a\ntextbook of mathematics, a Secondary Section may not explain any\nmathematics.)  The relationship could be a matter of historical\nconnection with the subject or with related matters, or of legal,\ncommercial, philosophical, ethical or political position regarding\nthem.\n\nThe \"Invariant Sections\" are certain Secondary Sections whose titles\nare designated, as being those of Invariant Sections, in the notice\nthat says that the Document is released under this License.  If a\nsection does not fit the above definition of Secondary then it is not\nallowed to be designated as Invariant.  The Document may contain zero\nInvariant Sections.  If the Document does not identify any Invariant\nSections then there are none.\n\nThe \"Cover Texts\" are certain short passages of text that are listed,\nas Front-Cover Texts or Back-Cover Texts, in the notice that says that\nthe Document is released under this License.  A Front-Cover Text may\nbe at most 5 words, and a Back-Cover Text may be at most 25 words.\n\nA \"Transparent\" copy of the Document means a machine-readable copy,\nrepresented in a format whose specification is available to the\ngeneral public, that is suitable for revising the document\nstraightforwardly with generic text editors or (for images composed of\npixels) generic paint programs or (for drawings) some widely available\ndrawing editor, and that is suitable for input to text formatters or\nfor automatic translation to a variety of formats suitable for input\nto text formatters.  A copy made in an otherwise Transparent file\nformat whose markup, or absence of markup, has been arranged to thwart\nor discourage subsequent modification by readers is not Transparent.\nAn image format is not Transparent if used for any substantial amount\nof text.  A copy that is not \"Transparent\" is called \"Opaque\".\n\nExamples of suitable formats for Transparent copies include plain\nASCII without markup, Texinfo input format, LaTeX input format, SGML\nor XML using a publicly available DTD, and standard-conforming simple\nHTML, PostScript or PDF designed for human modification.  Examples of\ntransparent image formats include PNG, XCF and JPG.  Opaque formats\ninclude proprietary formats that can be read and edited only by\nproprietary word processors, SGML or XML for which the DTD and/or\nprocessing tools are not generally available, and the\nmachine-generated HTML, PostScript or PDF produced by some word\nprocessors for output purposes only.\n\nThe \"Title Page\" means, for a printed book, the title page itself,\nplus such following pages as are needed to hold, legibly, the material\nthis License requires to appear in the title page.  For works in\nformats which do not have any title page as such, \"Title Page\" means\nthe text near the most prominent appearance of the work's title,\npreceding the beginning of the body of the text.\n\nA section \"Entitled XYZ\" means a named subunit of the Document whose\ntitle either is precisely XYZ or contains XYZ in parentheses following\ntext that translates XYZ in another language.  (Here XYZ stands for a\nspecific section name mentioned below, such as \"Acknowledgements\",\n\"Dedications\", \"Endorsements\", or \"History\".)  To \"Preserve the Title\"\nof such a section when you modify the Document means that it remains a\nsection \"Entitled XYZ\" according to this definition.\n\nThe Document may include Warranty Disclaimers next to the notice which\nstates that this License applies to the Document.  These Warranty\nDisclaimers are considered to be included by reference in this\nLicense, but only as regards disclaiming warranties: any other\nimplication that these Warranty Disclaimers may have is void and has\nno effect on the meaning of this License.\n\n\n2. VERBATIM COPYING\n\nYou may copy and distribute the Document in any medium, either\ncommercially or noncommercially, provided that this License, the\ncopyright notices, and the license notice saying this License applies\nto the Document are reproduced in all copies, and that you add no other\nconditions whatsoever to those of this License.  You may not use\ntechnical measures to obstruct or control the reading or further\ncopying of the copies you make or distribute.  However, you may accept\ncompensation in exchange for copies.  If you distribute a large enough\nnumber of copies you must also follow the conditions in section 3.\n\nYou may also lend copies, under the same conditions stated above, and\nyou may publicly display copies.\n\n\n3. COPYING IN QUANTITY\n\nIf you publish printed copies (or copies in media that commonly have\nprinted covers) of the Document, numbering more than 100, and the\nDocument's license notice requires Cover Texts, you must enclose the\ncopies in covers that carry, clearly and legibly, all these Cover\nTexts: Front-Cover Texts on the front cover, and Back-Cover Texts on\nthe back cover.  Both covers must also clearly and legibly identify\nyou as the publisher of these copies.  The front cover must present\nthe full title with all words of the title equally prominent and\nvisible.  You may add other material on the covers in addition.\nCopying with changes limited to the covers, as long as they preserve\nthe title of the Document and satisfy these conditions, can be treated\nas verbatim copying in other respects.\n\nIf the required texts for either cover are too voluminous to fit\nlegibly, you should put the first ones listed (as many as fit\nreasonably) on the actual cover, and continue the rest onto adjacent\npages.\n\nIf you publish or distribute Opaque copies of the Document numbering\nmore than 100, you must either include a machine-readable Transparent\ncopy along with each Opaque copy, or state in or with each Opaque copy\na computer-network location from which the general network-using\npublic has access to download using public-standard network protocols\na complete Transparent copy of the Document, free of added material.\nIf you use the latter option, you must take reasonably prudent steps,\nwhen you begin distribution of Opaque copies in quantity, to ensure\nthat this Transparent copy will remain thus accessible at the stated\nlocation until at least one year after the last time you distribute an\nOpaque copy (directly or through your agents or retailers) of that\nedition to the public.\n\nIt is requested, but not required, that you contact the authors of the\nDocument well before redistributing any large number of copies, to give\nthem a chance to provide you with an updated version of the Document.\n\n\n4. MODIFICATIONS\n\nYou may copy and distribute a Modified Version of the Document under\nthe conditions of sections 2 and 3 above, provided that you release\nthe Modified Version under precisely this License, with the Modified\nVersion filling the role of the Document, thus licensing distribution\nand modification of the Modified Version to whoever possesses a copy\nof it.  In addition, you must do these things in the Modified Version:\n\nA. Use in the Title Page (and on the covers, if any) a title distinct\n   from that of the Document, and from those of previous versions\n   (which should, if there were any, be listed in the History section\n   of the Document).  You may use the same title as a previous version\n   if the original publisher of that version gives permission.\nB. List on the Title Page, as authors, one or more persons or entities\n   responsible for authorship of the modifications in the Modified\n   Version, together with at least five of the principal authors of the\n   Document (all of its principal authors, if it has fewer than five),\n   unless they release you from this requirement.\nC. State on the Title page the name of the publisher of the\n   Modified Version, as the publisher.\nD. Preserve all the copyright notices of the Document.\nE. Add an appropriate copyright notice for your modifications\n   adjacent to the other copyright notices.\nF. Include, immediately after the copyright notices, a license notice\n   giving the public permission to use the Modified Version under the\n   terms of this License, in the form shown in the Addendum below.\nG. Preserve in that license notice the full lists of Invariant Sections\n   and required Cover Texts given in the Document's license notice.\nH. Include an unaltered copy of this License.\nI. Preserve the section Entitled \"History\", Preserve its Title, and add\n   to it an item stating at least the title, year, new authors, and\n   publisher of the Modified Version as given on the Title Page.  If\n   there is no section Entitled \"History\" in the Document, create one\n   stating the title, year, authors, and publisher of the Document as\n   given on its Title Page, then add an item describing the Modified\n   Version as stated in the previous sentence.\nJ. Preserve the network location, if any, given in the Document for\n   public access to a Transparent copy of the Document, and likewise\n   the network locations given in the Document for previous versions\n   it was based on.  These may be placed in the \"History\" section.\n   You may omit a network location for a work that was published at\n   least four years before the Document itself, or if the original\n   publisher of the version it refers to gives permission.\nK. For any section Entitled \"Acknowledgements\" or \"Dedications\",\n   Preserve the Title of the section, and preserve in the section all\n   the substance and tone of each of the contributor acknowledgements\n   and/or dedications given therein.\nL. Preserve all the Invariant Sections of the Document,\n   unaltered in their text and in their titles.  Section numbers\n   or the equivalent are not considered part of the section titles.\nM. Delete any section Entitled \"Endorsements\".  Such a section\n   may not be included in the Modified Version.\nN. Do not retitle any existing section to be Entitled \"Endorsements\"\n   or to conflict in title with any Invariant Section.\nO. Preserve any Warranty Disclaimers.\n\nIf the Modified Version includes new front-matter sections or\nappendices that qualify as Secondary Sections and contain no material\ncopied from the Document, you may at your option designate some or all\nof these sections as invariant.  To do this, add their titles to the\nlist of Invariant Sections in the Modified Version's license notice.\nThese titles must be distinct from any other section titles.\n\nYou may add a section Entitled \"Endorsements\", provided it contains\nnothing but endorsements of your Modified Version by various\nparties--for example, statements of peer review or that the text has\nbeen approved by an organization as the authoritative definition of a\nstandard.\n\nYou may add a passage of up to five words as a Front-Cover Text, and a\npassage of up to 25 words as a Back-Cover Text, to the end of the list\nof Cover Texts in the Modified Version.  Only one passage of\nFront-Cover Text and one of Back-Cover Text may be added by (or\nthrough arrangements made by) any one entity.  If the Document already\nincludes a cover text for the same cover, previously added by you or\nby arrangement made by the same entity you are acting on behalf of,\nyou may not add another; but you may replace the old one, on explicit\npermission from the previous publisher that added the old one.\n\nThe author(s) and publisher(s) of the Document do not by this License\ngive permission to use their names for publicity for or to assert or\nimply endorsement of any Modified Version.\n\n\n5. COMBINING DOCUMENTS\n\nYou may combine the Document with other documents released under this\nLicense, under the terms defined in section 4 above for modified\nversions, provided that you include in the combination all of the\nInvariant Sections of all of the original documents, unmodified, and\nlist them all as Invariant Sections of your combined work in its\nlicense notice, and that you preserve all their Warranty Disclaimers.\n\nThe combined work need only contain one copy of this License, and\nmultiple identical Invariant Sections may be replaced with a single\ncopy.  If there are multiple Invariant Sections with the same name but\ndifferent contents, make the title of each such section unique by\nadding at the end of it, in parentheses, the name of the original\nauthor or publisher of that section if known, or else a unique number.\nMake the same adjustment to the section titles in the list of\nInvariant Sections in the license notice of the combined work.\n\nIn the combination, you must combine any sections Entitled \"History\"\nin the various original documents, forming one section Entitled\n\"History\"; likewise combine any sections Entitled \"Acknowledgements\",\nand any sections Entitled \"Dedications\".  You must delete all sections\nEntitled \"Endorsements\".\n\n\n6. COLLECTIONS OF DOCUMENTS\n\nYou may make a collection consisting of the Document and other documents\nreleased under this License, and replace the individual copies of this\nLicense in the various documents with a single copy that is included in\nthe collection, provided that you follow the rules of this License for\nverbatim copying of each of the documents in all other respects.\n\nYou may extract a single document from such a collection, and distribute\nit individually under this License, provided you insert a copy of this\nLicense into the extracted document, and follow this License in all\nother respects regarding verbatim copying of that document.\n\n\n7. AGGREGATION WITH INDEPENDENT WORKS\n\nA compilation of the Document or its derivatives with other separate\nand independent documents or works, in or on a volume of a storage or\ndistribution medium, is called an \"aggregate\" if the copyright\nresulting from the compilation is not used to limit the legal rights\nof the compilation's users beyond what the individual works permit.\nWhen the Document is included in an aggregate, this License does not\napply to the other works in the aggregate which are not themselves\nderivative works of the Document.\n\nIf the Cover Text requirement of section 3 is applicable to these\ncopies of the Document, then if the Document is less than one half of\nthe entire aggregate, the Document's Cover Texts may be placed on\ncovers that bracket the Document within the aggregate, or the\nelectronic equivalent of covers if the Document is in electronic form.\nOtherwise they must appear on printed covers that bracket the whole\naggregate.\n\n\n8. TRANSLATION\n\nTranslation is considered a kind of modification, so you may\ndistribute translations of the Document under the terms of section 4.\nReplacing Invariant Sections with translations requires special\npermission from their copyright holders, but you may include\ntranslations of some or all Invariant Sections in addition to the\noriginal versions of these Invariant Sections.  You may include a\ntranslation of this License, and all the license notices in the\nDocument, and any Warranty Disclaimers, provided that you also include\nthe original English version of this License and the original versions\nof those notices and disclaimers.  In case of a disagreement between\nthe translation and the original version of this License or a notice\nor disclaimer, the original version will prevail.\n\nIf a section in the Document is Entitled \"Acknowledgements\",\n\"Dedications\", or \"History\", the requirement (section 4) to Preserve\nits Title (section 1) will typically require changing the actual\ntitle.\n\n\n9. TERMINATION\n\nYou may not copy, modify, sublicense, or distribute the Document except\nas expressly provided for under this License.  Any other attempt to\ncopy, modify, sublicense or distribute the Document is void, and will\nautomatically terminate your rights under this License.  However,\nparties who have received copies, or rights, from you under this\nLicense will not have their licenses terminated so long as such\nparties remain in full compliance.\n\n\n10. FUTURE REVISIONS OF THIS LICENSE\n\nThe Free Software Foundation may publish new, revised versions\nof the GNU Free Documentation License from time to time.  Such new\nversions will be similar in spirit to the present version, but may\ndiffer in detail to address new problems or concerns.  See\nhttp://www.gnu.org/copyleft/.\n\nEach version of the License is given a distinguishing version number.\nIf the Document specifies that a particular numbered version of this\nLicense \"or any later version\" applies to it, you have the option of\nfollowing the terms and conditions either of that specified version or\nof any later version that has been published (not as a draft) by the\nFree Software Foundation.  If the Document does not specify a version\nnumber of this License, you may choose any version ever published (not\nas a draft) by the Free Software Foundation.\n\n\nADDENDUM: How to use this License for your documents\n\nTo use this License in a document you have written, include a copy of\nthe License in the document and put the following copyright and\nlicense notices just after the title page:\n\n    Copyright (c)  YEAR  YOUR NAME.\n    Permission is granted to copy, distribute and/or modify this document\n    under the terms of the GNU Free Documentation License, Version 1.2\n    or any later version published by the Free Software Foundation;\n    with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.\n    A copy of the license is included in the section entitled \"GNU\n    Free Documentation License\".\n\nIf you have Invariant Sections, Front-Cover Texts and Back-Cover Texts,\nreplace the \"with...Texts.\" line with this:\n\n    with the Invariant Sections being LIST THEIR TITLES, with the\n    Front-Cover Texts being LIST, and with the Back-Cover Texts being LIST.\n\nIf you have Invariant Sections without Cover Texts, or some other\ncombination of the three, merge those two alternatives to suit the\nsituation.\n\nIf your document contains nontrivial examples of program code, we\nrecommend releasing these examples in parallel under your choice of\nfree software license, such as the GNU General Public License,\nto permit their use in free software.</code>"
          },
          "sha1": "9j9sn1t8c2godrauburpd21jsb1zafu"
        }
      },
      {
        "title": "The Twelf Project:GNU Free Documentation License",
        "ns": 4,
        "id": 1429,
        "redirect": {
          "@title": "The Twelf Project:GFDL",
          "#text": null
        },
        "revision": {
          "id": 1522,
          "timestamp": "2006-09-05T19:37:23Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "[[The Twelf Project:GNU Free Documentation License]] moved to [[The Twelf Project:GFDL]]: shorter page",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 36,
            "#text": "#REDIRECT [[The Twelf Project:GFDL]]"
          },
          "sha1": "4e7rnf8bp8pyoyjis4u72tatler67to"
        }
      },
      {
        "title": "The Twelf Project:GPL",
        "ns": 4,
        "id": 1430,
        "revision": {
          "id": 1524,
          "parentid": 1523,
          "timestamp": "2006-09-05T19:41:00Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "backlink",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 18820,
            "#text": "For any page marked with the tag <nowiki>{{license-gpl}}</nowiki>, it is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.\n\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\nSee [[Project:Copyright]] for more information.\n\n== GNU General Public License ==\n\n<code>\t\t    GNU GENERAL PUBLIC LICENSE\n\t\t       Version 2, June 1991\n\n Copyright (C) 1989, 1991 Free Software Foundation, Inc.,\n 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n\t\t\t    Preamble\n\n  The licenses for most software are designed to take away your\nfreedom to share and change it.  By contrast, the GNU General Public\nLicense is intended to guarantee your freedom to share and change free\nsoftware--to make sure the software is free for all its users.  This\nGeneral Public License applies to most of the Free Software\nFoundation's software and to any other program whose authors commit to\nusing it.  (Some other Free Software Foundation software is covered by\nthe GNU Lesser General Public License instead.)  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthis service if you wish), that you receive source code or can get it\nif you want it, that you can change the software or use pieces of it\nin new free programs; and that you know you can do these things.\n\n  To protect your rights, we need to make restrictions that forbid\nanyone to deny you these rights or to ask you to surrender the rights.\nThese restrictions translate to certain responsibilities for you if you\ndistribute copies of the software, or if you modify it.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must give the recipients all the rights that\nyou have.  You must make sure that they, too, receive or can get the\nsource code.  And you must show them these terms so they know their\nrights.\n\n  We protect your rights with two steps: (1) copyright the software, and\n(2) offer you this license which gives you legal permission to copy,\ndistribute and/or modify the software.\n\n  Also, for each author's protection and ours, we want to make certain\nthat everyone understands that there is no warranty for this free\nsoftware.  If the software is modified by someone else and passed on, we\nwant its recipients to know that what they have is not the original, so\nthat any problems introduced by others will not reflect on the original\nauthors' reputations.\n\n  Finally, any free program is threatened constantly by software\npatents.  We wish to avoid the danger that redistributors of a free\nprogram will individually obtain patent licenses, in effect making the\nprogram proprietary.  To prevent this, we have made it clear that any\npatent must be licensed for everyone's free use or not licensed at all.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n\t\t    GNU GENERAL PUBLIC LICENSE\n   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\n\n  0. This License applies to any program or other work which contains\na notice placed by the copyright holder saying it may be distributed\nunder the terms of this General Public License.  The \"Program\", below,\nrefers to any such program or work, and a \"work based on the Program\"\nmeans either the Program or any derivative work under copyright law:\nthat is to say, a work containing the Program or a portion of it,\neither verbatim or with modifications and/or translated into another\nlanguage.  (Hereinafter, translation is included without limitation in\nthe term \"modification\".)  Each licensee is addressed as \"you\".\n\nActivities other than copying, distribution and modification are not\ncovered by this License; they are outside its scope.  The act of\nrunning the Program is not restricted, and the output from the Program\nis covered only if its contents constitute a work based on the\nProgram (independent of having been made by running the Program).\nWhether that is true depends on what the Program does.\n\n  1. You may copy and distribute verbatim copies of the Program's\nsource code as you receive it, in any medium, provided that you\nconspicuously and appropriately publish on each copy an appropriate\ncopyright notice and disclaimer of warranty; keep intact all the\nnotices that refer to this License and to the absence of any warranty;\nand give any other recipients of the Program a copy of this License\nalong with the Program.\n\nYou may charge a fee for the physical act of transferring a copy, and\nyou may at your option offer warranty protection in exchange for a fee.\n\n  2. You may modify your copy or copies of the Program or any portion\nof it, thus forming a work based on the Program, and copy and\ndistribute such modifications or work under the terms of Section 1\nabove, provided that you also meet all of these conditions:\n\n    a) You must cause the modified files to carry prominent notices\n    stating that you changed the files and the date of any change.\n\n    b) You must cause any work that you distribute or publish, that in\n    whole or in part contains or is derived from the Program or any\n    part thereof, to be licensed as a whole at no charge to all third\n    parties under the terms of this License.\n\n    c) If the modified program normally reads commands interactively\n    when run, you must cause it, when started running for such\n    interactive use in the most ordinary way, to print or display an\n    announcement including an appropriate copyright notice and a\n    notice that there is no warranty (or else, saying that you provide\n    a warranty) and that users may redistribute the program under\n    these conditions, and telling the user how to view a copy of this\n    License.  (Exception: if the Program itself is interactive but\n    does not normally print such an announcement, your work based on\n    the Program is not required to print an announcement.)\n\nThese requirements apply to the modified work as a whole.  If\nidentifiable sections of that work are not derived from the Program,\nand can be reasonably considered independent and separate works in\nthemselves, then this License, and its terms, do not apply to those\nsections when you distribute them as separate works.  But when you\ndistribute the same sections as part of a whole which is a work based\non the Program, the distribution of the whole must be on the terms of\nthis License, whose permissions for other licensees extend to the\nentire whole, and thus to each and every part regardless of who wrote it.\n\nThus, it is not the intent of this section to claim rights or contest\nyour rights to work written entirely by you; rather, the intent is to\nexercise the right to control the distribution of derivative or\ncollective works based on the Program.\n\nIn addition, mere aggregation of another work not based on the Program\nwith the Program (or with a work based on the Program) on a volume of\na storage or distribution medium does not bring the other work under\nthe scope of this License.\n\n  3. You may copy and distribute the Program (or a work based on it,\nunder Section 2) in object code or executable form under the terms of\nSections 1 and 2 above provided that you also do one of the following:\n\n    a) Accompany it with the complete corresponding machine-readable\n    source code, which must be distributed under the terms of Sections\n    1 and 2 above on a medium customarily used for software interchange; or,\n\n    b) Accompany it with a written offer, valid for at least three\n    years, to give any third party, for a charge no more than your\n    cost of physically performing source distribution, a complete\n    machine-readable copy of the corresponding source code, to be\n    distributed under the terms of Sections 1 and 2 above on a medium\n    customarily used for software interchange; or,\n\n    c) Accompany it with the information you received as to the offer\n    to distribute corresponding source code.  (This alternative is\n    allowed only for noncommercial distribution and only if you\n    received the program in object code or executable form with such\n    an offer, in accord with Subsection b above.)\n\nThe source code for a work means the preferred form of the work for\nmaking modifications to it.  For an executable work, complete source\ncode means all the source code for all modules it contains, plus any\nassociated interface definition files, plus the scripts used to\ncontrol compilation and installation of the executable.  However, as a\nspecial exception, the source code distributed need not include\nanything that is normally distributed (in either source or binary\nform) with the major components (compiler, kernel, and so on) of the\noperating system on which the executable runs, unless that component\nitself accompanies the executable.\n\nIf distribution of executable or object code is made by offering\naccess to copy from a designated place, then offering equivalent\naccess to copy the source code from the same place counts as\ndistribution of the source code, even though third parties are not\ncompelled to copy the source along with the object code.\n\n  4. You may not copy, modify, sublicense, or distribute the Program\nexcept as expressly provided under this License.  Any attempt\notherwise to copy, modify, sublicense or distribute the Program is\nvoid, and will automatically terminate your rights under this License.\nHowever, parties who have received copies, or rights, from you under\nthis License will not have their licenses terminated so long as such\nparties remain in full compliance.\n\n  5. You are not required to accept this License, since you have not\nsigned it.  However, nothing else grants you permission to modify or\ndistribute the Program or its derivative works.  These actions are\nprohibited by law if you do not accept this License.  Therefore, by\nmodifying or distributing the Program (or any work based on the\nProgram), you indicate your acceptance of this License to do so, and\nall its terms and conditions for copying, distributing or modifying\nthe Program or works based on it.\n\n  6. Each time you redistribute the Program (or any work based on the\nProgram), the recipient automatically receives a license from the\noriginal licensor to copy, distribute or modify the Program subject to\nthese terms and conditions.  You may not impose any further\nrestrictions on the recipients' exercise of the rights granted herein.\nYou are not responsible for enforcing compliance by third parties to\nthis License.\n\n  7. If, as a consequence of a court judgment or allegation of patent\ninfringement or for any other reason (not limited to patent issues),\nconditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot\ndistribute so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you\nmay not distribute the Program at all.  For example, if a patent\nlicense would not permit royalty-free redistribution of the Program by\nall those who receive copies directly or indirectly through you, then\nthe only way you could satisfy both it and this License would be to\nrefrain entirely from distribution of the Program.\n\nIf any portion of this section is held invalid or unenforceable under\nany particular circumstance, the balance of the section is intended to\napply and the section as a whole is intended to apply in other\ncircumstances.\n\nIt is not the purpose of this section to induce you to infringe any\npatents or other property right claims or to contest validity of any\nsuch claims; this section has the sole purpose of protecting the\nintegrity of the free software distribution system, which is\nimplemented by public license practices.  Many people have made\ngenerous contributions to the wide range of software distributed\nthrough that system in reliance on consistent application of that\nsystem; it is up to the author/donor to decide if he or she is willing\nto distribute software through any other system and a licensee cannot\nimpose that choice.\n\nThis section is intended to make thoroughly clear what is believed to\nbe a consequence of the rest of this License.\n\n  8. If the distribution and/or use of the Program is restricted in\ncertain countries either by patents or by copyrighted interfaces, the\noriginal copyright holder who places the Program under this License\nmay add an explicit geographical distribution limitation excluding\nthose countries, so that distribution is permitted only in or among\ncountries not thus excluded.  In such case, this License incorporates\nthe limitation as if written in the body of this License.\n\n  9. The Free Software Foundation may publish revised and/or new versions\nof the General Public License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\nEach version is given a distinguishing version number.  If the Program\nspecifies a version number of this License which applies to it and \"any\nlater version\", you have the option of following the terms and conditions\neither of that version or of any later version published by the Free\nSoftware Foundation.  If the Program does not specify a version number of\nthis License, you may choose any version ever published by the Free Software\nFoundation.\n\n  10. If you wish to incorporate parts of the Program into other free\nprograms whose distribution conditions are different, write to the author\nto ask for permission.  For software which is copyrighted by the Free\nSoftware Foundation, write to the Free Software Foundation; we sometimes\nmake exceptions for this.  Our decision will be guided by the two goals\nof preserving the free status of all derivatives of our free software and\nof promoting the sharing and reuse of software generally.\n\n\t\t\t    NO WARRANTY\n\n  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY\nFOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN\nOTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES\nPROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED\nOR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS\nTO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE\nPROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,\nREPAIR OR CORRECTION.\n\n  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR\nREDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,\nINCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING\nOUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED\nTO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY\nYOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER\nPROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGES.\n\n\t\t     END OF TERMS AND CONDITIONS\n\n\t    How to Apply These Terms to Your New Programs\n\n  If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these terms.\n\n  To do so, attach the following notices to the program.  It is safest\nto attach them to the start of each source file to most effectively\nconvey the exclusion of warranty; and each file should have at least\nthe \"copyright\" line and a pointer to where the full notice is found.\n\n    <one line to give the program's name and a brief idea of what it does.>\n    Copyright (C) <year>  <name of author>\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\nAlso add information on how to contact you by electronic and paper mail.\n\nIf the program is interactive, make it output a short notice like this\nwhen it starts in an interactive mode:\n\n    Gnomovision version 69, Copyright (C) year name of author\n    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n    This is free software, and you are welcome to redistribute it\n    under certain conditions; type `show c' for details.\n\nThe hypothetical commands `show w' and `show c' should show the appropriate\nparts of the General Public License.  Of course, the commands you use may\nbe called something other than `show w' and `show c'; they could even be\nmouse-clicks or menu items--whatever suits your program.\n\nYou should also get your employer (if you work as a programmer) or your\nschool, if any, to sign a \"copyright disclaimer\" for the program, if\nnecessary.  Here is a sample; alter the names:\n\n  Yoyodyne, Inc., hereby disclaims all copyright interest in the program\n  `Gnomovision' (which makes passes at compilers) written by James Hacker.\n\n  <signature of Ty Coon>, 1 April 1989\n  Ty Coon, President of Vice\n\nThis General Public License does not permit incorporating your program into\nproprietary programs.  If your program is a subroutine library, you may\nconsider it more useful to permit linking proprietary applications with the\nlibrary.  If this is what you want to do, use the GNU Lesser General\nPublic License instead of this License.</code>"
          },
          "sha1": "seolwalay2eo17ni8jiipqh2k2w5orv"
        }
      },
      {
        "title": "The Twelf Project:GeSHi Twelf extension",
        "ns": 4,
        "id": 1397,
        "revision": {
          "id": 3635,
          "parentid": 2353,
          "timestamp": "2007-02-20T05:38:47Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "minor": null,
          "comment": "TwelfTag is now in Haskell",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 5602,
            "#text": "This is Rob's first attempt at a Twelf highlighting module for the [http://qbnz.com/highlighter/ | GeSHi] extension. You probably are more interested in the page about [[The Twelf Project:Syntax Highlighting | syntax highlighting]], especially because this highlighter is depreciated and the syntax highlighter for [[Project:TwelfTag|TwelfTag]] is now written in Haskell.\n\nNOTES:\n\n* September 30, 2006 - When I upgraded from MediaWiki 1.6 to MediaWiki 1.7, I was getting the error messages that looked like this: <blockquote>Warning: Cannot modify header information - headers already sent by (output started at /usr0/www/twelf/mediawiki-1.7.1/extensions/geshi/twelf.php:174) in /usr0/www/twelf/mediawiki-1.7.1/includes/OutputPage.php on line 588</blockquote> When I removed the trailing <tt>?></tt> from the end of the file, those errors seemed to go away, but I have no idea why.\n\n<code php><?php\n/*******************************************************************************\n * twelf.php\n * --------\n * Author: Robert Simmons (http://www.cs.cmu.edu/~rjsimmon/)\n * Copyright: (c) 2006 Robert Simmons (http://www.cs.cmu.edu/~rjsimmon/)\n * Release version: 1.0.0\n * Date Started: 2006/09/02\n * Last Modified: 2006/09/02\n *\n * Twelf language file for GeSHi.\n *\n * CHANGES\n * -------\n * 2004/07/14 (1.0.0)\n *  -  First Release\n *\n * TODO\n * ----\n *******************************************************************************\n *\n *     This file is part of GeSHi.\n *\n *   GeSHi is free software; you can redistribute it and/or modify\n *   it under the terms of the GNU General Public License as published by\n *   the Free Software Foundation; either version 2 of the License, or\n *   (at your option) any later version.\n *\n *   GeSHi is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU General Public License for more details.\n *\n *   You should have received a copy of the GNU General Public License\n *   along with GeSHi; if not, write to the Free Software\n *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n ******************************************************************************/\n \n$language_data = array (\n\t'LANG_NAME' => 'Twelf',\n\t'COMMENT_SINGLE' => array(1 => '% ', 2 => '%%'),\n\t'COMMENT_MULTI' => array('%{' => '}%'),\n\t'CASE_KEYWORDS' => GESHI_CAPS_NO_CHANGE,\n\t'QUOTEMARKS' => array('\"'),\n\t'ESCAPE_CHAR' => '',\n\t'KEYWORDS' => array(\n\t\t\t    1 => array('type'),\n\t\t\t    2 => array('->','<-'),\n\t\t\t    3 => array('_'),\n\t\t\t    4 => array('='),\n\t\t\t    5 => array('%abbrev','%mode','%worlds','%solve',\n\t\t\t\t       '%total','%deterministic','%name',\n\t\t\t\t       '%prove', '%covers', '%terminates',\n\t\t\t\t       '%trustme', '%freeze') \n\t\t\t    ), \n\t'SYMBOLS' => array(':', '.', '(', ')', '[', ']', '{', '}'\n\t\t),\n\t'CASE_SENSITIVE' => array(\n\t\tGESHI_COMMENTS => false,\n\t\t1 => false,\n\t\t2 => false,\n\t\t3 => false,\n\t\t4 => false\n\t\t),\n\t'STYLES' => array(\n\t\t'KEYWORDS' => array(\n\t\t\t1 => 'font-weight: bold;',\n\t\t\t2 => '',\n\t\t\t3 => '',\n\t\t\t4 => '',\n\t\t\t5 => 'color: #6633FF;'\n\t\t\t),\n\t\t'COMMENTS' => array(\n\t\t\t1 => 'color: #990000;',\n\t\t\t2 => 'color: #990000;',\n\t\t\t'MULTI' => 'color: #990000;'\n\t\t\t),\n\t\t'ESCAPE_CHAR' => array(\n\t\t\t0 => ''\n\t\t\t),\n\t\t'BRACKETS' => array(\n\t\t\t0 => ''\n\t\t\t),\n\t\t'STRINGS' => array(\n\t\t\t0 => 'color: #006666;'\n\t\t\t),\n\t\t'NUMBERS' => array(\n\t\t\t0 => ''\n\t\t\t),\n\t\t'METHODS' => array(\n\t\t\t0 => ''\n\t\t\t),\n\t\t'SYMBOLS' => array(\n\t\t\t0 => ''\n\t\t\t),\n\t\t'REGEXPS' => array(\n\t\t\t0 => 'color: #6633FF;',\n\t\t\t1 => 'color: #000099;',\n\t\t\t2 => 'color: #990000;',\n\t\t\t3 => 'color: #990000;',\n\t\t\t4 => 'color: #990000;',\n\t\t\t5 => 'color: #009900;'\n\t\t\t),\n\t\t'SCRIPT' => array(\n\t\t\t0 => '',\n\t\t\t1 => '',\n\t\t\t2 => '',\n\t\t\t3 => ''\n\t\t\t)\n\t\t),\n\t'URLS' => array(\n\t\t1 => '',\n\t\t2 => '',\n\t\t3 => '',\n\t\t4 => ''\n\t\t),\n\t'OOLANG' => false,\n\t'OBJECT_SPLITTER' => '',\n\t'REGEXPS' => array(\n\t\t// Catches all the %keyword items - BROKEN, use \n\t\t// keyword matching instead\n      \t\t/*0 => array(\n\t\t     GESHI_SEARCH => '(%[a-z]+)',\n\t\t     GESHI_REPLACE => '\\\\1',\n\t\t     GESHI_MODIFIERS => '',\n\t\t     GESHI_BEFORE => '',\n\t\t     GESHI_AFTER => ''),*/\n\t\t// Capitalized identifiers\n      \t\t1 => array(\n\t\t     GESHI_SEARCH => '([A-Z][A-Za-z0-9\\'_]*)',\n\t\t     GESHI_REPLACE => '\\\\1',\n\t\t     GESHI_MODIFIERS => '',\n\t\t     GESHI_BEFORE => '',\n\t\t     GESHI_AFTER => ''),\n\t\t// Primary identifier catcher\n\t\t2 => array(\n\t\t     GESHI_SEARCH => '([.\\n][ \\t]*)([a-zA-Z][/a-zA-Z0-9_\\-]*)',\n\t\t     GESHI_REPLACE => '\\\\2',\n\t\t     GESHI_MODIFIERS => '',\n\t\t     GESHI_BEFORE => '\\\\1',\n\t\t     GESHI_AFTER => ''),\n\t\t// Special duplicate version catches indentifiers after\n\t\t// comments and at the beginning of the file (I think)\n\t\t3 => array(\n\t\t     GESHI_SEARCH => '(^[ \\t]*)([a-zA-Z][/a-zA-Z0-9_\\-]*)',\n\t\t     GESHI_REPLACE => '\\\\2',\n\t\t     GESHI_MODIFIERS => '',\n\t\t     GESHI_BEFORE => '\\\\1',\n\t\t     GESHI_AFTER => ''),\n\t\t// Third duplicate version catches identifiers shielded by\n\t\t// %abbrev declarations\n\t\t4 => array(\n\t\t     GESHI_SEARCH => '(%abbrev[ \\t]*)([a-zA-Z][/a-zA-Z0-9_\\-]*)',\n\t\t     GESHI_REPLACE => '\\\\2',\n\t\t     GESHI_MODIFIERS => '',\n\t\t     GESHI_BEFORE => '\\\\1',\n\t\t     GESHI_AFTER => ''),\n\t\t// Catch things in [] or {} brackets (bound identifiers)\n\t\t5 => array(\n\t             GESHI_SEARCH => '([\\[\\{][ \\t]*)([a-zA-Z][/a-zA-Z0-9_\\-]*)',\n\t\t     GESHI_REPLACE => '\\\\2',\n\t\t     GESHI_MODIFIERS => '',\n\t\t     GESHI_BEFORE => '\\\\1',\n\t\t     GESHI_AFTER => '')\t\t\n\t\t),\n\t'STRICT_MODE_APPLIES' => GESHI_NEVER,\n\t'SCRIPT_DELIMITERS' => array(),\n\t'HIGHLIGHT_STRICT_BLOCK' => array()\n);\n \n?></code>"
          },
          "sha1": "c46v7g98ctmksi3q5xrf65k0fxad4o0"
        }
      },
      {
        "title": "The Twelf Project:Literate Twelf",
        "ns": 4,
        "id": 1858,
        "revision": {
          "id": 4915,
          "parentid": 4909,
          "timestamp": "2007-10-10T05:58:38Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "minor": null,
          "comment": "Reverted edits by [[Special:Contributions/212.11.191.67|212.11.191.67]] ([[User_talk:212.11.191.67|Talk]]); changed back to last version by [[User:Rsimmons|Rsimmons]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 2172,
            "#text": "The Literate Twelf extension is a relatively simple modification of [[TwelfTag]] intended to facilitate both offline editing, as well as direct use, of pages on this wiki. Literate Twelf pages interperet text inside of multi-line comments as are automatically run through Twelf by the Literate Twelf extension, and Twelf's output (\"%% OK %%\" or \"%% ABORT %%\") is displayed in a box at the top of the page.\n\n== Using Literate Twelf ==\n\nIf a file on the wiki starts with the string <tt>%{</tt>, a preprocesser is invoked that (essentially) turns all instances of <tt>%{</tt> to <tt><nowiki></twelf></nowiki></tt> and all instances of <tt>}%</tt> into <tt><nowiki><twelf></nowiki></tt>, transforming the Twelf file with comments into a Mediawiki file with escaped TwelfTag sequences. \n\nFurthermore, if a pipe characther <tt>|</tt> appears on the same line as the <tt>}%</tt> symbol, the text between the <tt>|</tt> and the <tt>}%</tt> will be interpreted as options to the <nowiki><twelf></nowiki> tag.\n\n=== Limitations ===\n\n* Multi-line comments cannot be nested within a Literate Twelf file.\n* Section editing is disabled for Literate Twelf files on the wiki, as this could potentially lead to unpredictable results.\n\n== Demo ==\n\nThe following Literate Twelf page is demonstrated [[Project:Literate Twelf/Sample Page|here]]. Notice that because a <tt>|</tt> appears on the second line, the comment cannot be closed on that line or the entire segment <tt>Literate Twelf]].</tt> would be interpreted as TwelfTag options.\n\n<code>%{ \nSome natural numbers; a demo of [[Project:Literate Twelf|Literate Twelf]]. \n}%\n \n%{ == Syntax == }%\n \nnat: type.\nz : nat.\ns : nat -> nat.\n \n%{ == Judgments == }%\n \n%{ === Equality === }%\n \nid-nat : nat -> nat -> type.\nid-nat/refl : id-nat N N.\n \n%{ === Addition === |}%\n \nplus : nat -> nat -> nat -> type.\nplus/z : plus z N N.\nplus/s : plus N1 N2 N3 -> plus (s N1) N2 (s N3).\n\n%{ Now we can see what it looks like to run a query: |check=decl}%\n\n%solve _ : plus (s (s (s z))) (s (s z)) N.\n \n%. \n \nThis is a pretty boring presentation of the natural numbers;\nit is roughly like all the other ones, like the article on [[natural numbers]].</code>"
          },
          "sha1": "kxhcvkohzcs6eq3uyc1tsairwvzyrxr"
        }
      },
      {
        "title": "The Twelf Project:Literate Twelf/Sample Page",
        "ns": 4,
        "id": 1859,
        "revision": {
          "id": 5732,
          "parentid": 5731,
          "timestamp": "2009-01-12T06:06:57Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 640,
            "#text": "%{ \nSome natural numbers; a demo of [[Project:Literate Twelf|Literate Twelf]]. \n}%\n \n%{ == Syntax == }%\n \nnat: type.\nz : nat.\ns : nat -> nat. \n\n%{ == Judgments == }%\n \n%{ === Equality === }%\n \nid-nat : nat -> nat -> type.\nid-nat/refl : id-nat N N.\n \n%{ === Addition === |}%\n \nplus : nat -> nat -> nat -> type.\nplus/z : plus z N N.\nplus/s : plus N1 N2 N3 -> plus (s N1) N2 (s N3).\n\n%{ Now we can see what it looks like to run a query: |check=decl}%\n\n%solve _ : plus (s (s (s z))) (s (s z)) N.\n \n%. \n \nThis is a pretty boring presentation of the natural numbers;\nit is roughly like all the other ones, like the article on [[natural numbers]]."
          },
          "sha1": "em17xmem3l8p7rr6q7gvgj5l6gqlvlp"
        }
      },
      {
        "title": "The Twelf Project:MIT",
        "ns": 4,
        "id": 1860,
        "redirect": {
          "@title": "The Twelf Project:MIT license",
          "#text": null
        },
        "revision": {
          "id": 3731,
          "timestamp": "2007-02-25T03:21:16Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "comment": "[[The Twelf Project:MIT]] moved to [[The Twelf Project:MIT license]]: not a page about MIT",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 43,
            "#text": "#REDIRECT [[The Twelf Project:MIT license]]"
          },
          "sha1": "45vo2pppkyaxnwckofowpcfs6q2gby3"
        }
      },
      {
        "title": "The Twelf Project:MIT license",
        "ns": 4,
        "id": 1435,
        "revision": {
          "id": 3730,
          "parentid": 3729,
          "timestamp": "2007-02-25T03:21:16Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "minor": null,
          "comment": "[[The Twelf Project:MIT]] moved to [[The Twelf Project:MIT license]]: not a page about MIT",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 1209,
            "#text": "Copyright (c) 2006-2007 The Twelf Project. See [[Project:Copyright]] for more information.\n\nUnless otherwise indicated by a tag on an individual page, permission is hereby granted, free of charge, to any person obtaining a copy of \nthis software and associated documentation files published directly on this wiki (the \"Software\"), to deal in \nthe Software without restriction, including without limitation the rights to \nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so, \nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
          },
          "sha1": "0xwjgjwc77u52ctaw3ag9xz7wzbt6hz"
        }
      },
      {
        "title": "The Twelf Project:Policy",
        "ns": 4,
        "id": 1379,
        "revision": {
          "id": 3734,
          "parentid": 3728,
          "timestamp": "2007-02-25T03:29:41Z",
          "contributor": {
            "ip": "128.2.223.28"
          },
          "comment": "agree with tom",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 891,
            "#text": "A policy will go here when one is devised.\n\nSome highlights that I imagine will be included:\n\n* The Principles of Programming group at Carnegie Mellon University are essentally the maintainers of the wiki and project, and are final arbiters in terms of policy decisions. However, the wiki is open for anyone, including unregistered users, to embrace and extend, and the entire wiki is generally editable.\n\n* As the bottom of all pages states, unless an individual page states otherwise, The Twelf Wiki runs on the simple, permissive MIT license that allows anyone to use, modify, and extend things in the wiki for any purpose, including for commercial use. This is described in more detail at [[Project:Copyrights]].\n\n* Blocks will be pursued agressively and without remorse. [[User:rsimmons|Rob]] spent way to much time reverting spam on the old wiki to not use available tools agressively."
          },
          "sha1": "mmlxsd71bdgploun69ka1ngm4jdvt42"
        }
      },
      {
        "title": "The Twelf Project:Protected page",
        "ns": 4,
        "id": 1473,
        "revision": {
          "id": 1798,
          "timestamp": "2006-09-22T19:38:00Z",
          "contributor": {
            "ip": "128.2.223.28"
          },
          "comment": "add content to remove redlink",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 426,
            "#text": "Pages on the Twelf project wiki will be protected for one of the following reasons:\n\n* Software links - any pages that decribe download procedures or that link to downloadable resources must be protected to prevent anyone from tampering with the links.\n* Vandalism - any pages subject to vandalism will be protected. Anyone tampering with or vandalizing the Twelf project wiki will be blocked, permanently and without warning."
          },
          "sha1": "k1pv1eusvp3sxv2lw7ptwz37xjgg3pg"
        }
      },
      {
        "title": "The Twelf Project:Style guide",
        "ns": 4,
        "id": 1441,
        "revision": {
          "id": 290196,
          "parentid": 290195,
          "timestamp": "2021-02-17T08:27:38Z",
          "contributor": {
            "username": "Graceclifford",
            "id": 305430
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 7996,
            "#text": "''This page is a style guide for contributions to the Twelf Project Wiki. For a style guide for writing Twelf itself, see [[Style guide]]''\n\n== Basic style points ==\n\n* ''Twelf'' is always capitalized.\n* Always snippets of code more than one line long inside <nowiki><twelf></twelf></nowiki> tags. Constants, names of lemmas, and keywords like <tt>%total</tt> should be displayed in fixed-width fonts by inserting them into <nowiki><tt></tt></nowiki> tags.\n* Use lowercase for the titles of pages and <nowiki>==Section headers==</nowiki>, except for the first character or where English otherwise requires capitalization. (Article titles are case-sensitive except for the first character.) This facilitates linking pages inline, such as \"The %trustme declaration is often used to develop proofs with [[holes in metatheorems]].\"\n\n== Word usage ==\n\n* A period-terminated line in Twelf is a ''declaration'' or a ''top-level declaration.''\n* %-things are ''keywords,'' declarations incorporating the keyword <tt>%foo</tt> are \"<tt>%foo</tt> declarations\" (\"<tt>%foo</tt> directive\" was used in some earlier articles).\n* Use [[metatheorem]] instead of other meta-words (such as metalemma).\n* The word [[metatheorem]] is ambiguous, as it can refer to a {{forall}}{{exists}}-statement, a [[totality assertion]], a logical relations argument, etc. It is best to use the word to mean  {{forall}}{{exists}}-statement.\n* The thing which we believe to be true when we run <tt>[[%total]]</tt> directives is a ''[[totality assertion]],'' rather than a {{forall}}{{exists}}R-statement. Running a <tt>[[%total]]</tt> directive causes Twelf to either ''prove'' or ''verfiy'' a totality assertion (the latter, \"verify,\" is preferable).\n* The person using Twelf is a ''user,'' ''Twelf user,'' or (if appropriate) ''programmer.''\n\n== Editing pages ==\n\nThe MediaWiki software does not come loaded with a style guide, becuase the existing guides are not available under general-user licenses. If you need an introduction to general Wiki markup, then checking out [[w:Wikipedia:How_to_edit_a_page | how to edit a page on Wikipedia]] might be helpful.\n\n=== Tagging documents with templates ===\n\nYou can leave templates on pages by adding the tag <nowiki>{{template}}</nowiki> to the text of the page, where \"template\" is replaced by what you want to add. Tags have a few uses on this wiki:\n\n* '''Licensing''' (see [[Project:Copyright]] for more information) - <nowiki>{{license-gdfl}} {{license-gpl}}, {{license-by-nc}}, or {{license-by-sa}}</nowiki> can be added to a page at the bottom.\n* '''Indicating problems''' - the tag <nowiki>{{stub}} or {{stub tutorial}}</nowiki> should be added to the bottom of pages that are very short and need to be longer. If a page is not too short but has problems that need to be addressed, the tag <nowiki>{{needswork|Description of the problem}}</nowiki> should be added to the top (replacing \"Description of the problem\" with an actual description of the problem).\n* '''Classification''' (see sections below) - the tag <nowiki>{{tutorial}}</nowiki> should be added to tutorials, the tag <nowiki>{{case study}}</nowiki> should be added to case studies.\n\n=== Working with code (syntax highlighting) ===\n\nThe Twelf Project has syntax highlighting enabled for most major programming languages, and has a custom module that can decently highlight most normal Twelf code. The short version is that you should surround any Twelf code you post with <nowiki><twelf></twelf></nowiki> tags. If you want things to be unhighlighted but still in monospaced, pre-formatted form, you can surround the content with <nowiki><code></code></nowiki> tags.\n\nThe full story can be found at [[Project:Syntax Highlighting]].\n\nTwelf code submitted to the site, when possible, should follow the [[Twelf style guide]] when such a thing is written.\n\n== Adding new pages ==\n\nAdding new pages is relatively simple, and can be done in one of (at least) two ways. For this example, say you want to create a page titled \"Not a page.\" \n\n* You can type \"Not a page\" into the search tool on the left side of the page. (You should do this anyway to make sure there's not a similar page already!) The first line on the page that you go to will say \"'''There is no page titled \":Not a page\".''' You can [[Not a page|create this page]].\" Click on the link and you can create the page.\n* You can edit (almost) any page by clicking the \"edit\" link at top. If you add the text <nowiki>[[Not a page]]</nowiki> to the page, it will show up like this: [[Not a page]]. Click on the link and you can create a page.\n\nThe first letter of any page title can appear in uppercase or lowercase - the system always thinks of it as an uppercase letter. Other than the first word, titles of new pages should generally be in lowercase unless they are using a proper noun (like \"Twelf\").\n\n=== What goes where ===\n\nIn general, there are two main \"namespaces\" in the wiki. This page is in the \"Project\" namespace, which is why it is called and linked to as \"The Twelf Project:Style guide\" or, equivalently, \"Project:Style guide.\" Pages that start with \"The Twelf Project:\" or \"Project:\" are only for pages that ''deal with the fact that this is a wiki.'' \n\nAlternately, the \"main namespace\" (basically everything else) is for articles dealing with Twelf, the software, the user community, etc. Thus the page talking about The Twelf Project as funded ongoing research work is named [[About The Twelf Project]], and the style guide for writing Twelf code is [[Twelf style guide]]. The main namespace is relatively \"flat,\" in that it has very little directory structure. Structure is preserved in other ways, such as adding categories or tags (which have associated categories) to pages.\n\n=== Adding documentation ===\n\nThe [[Documentation]] page indexes all the documentation on the wiki.  If you're adding something new, here are rough guidelines for where it should go:\n* [[Tutorials]] - if it's an article that teaches a specific Twelf proof or troubleshooting technique.  Tutorials are primarily focused on technique.\n* [[Case studies]] - if it's an article that show how an interesting theorem is proved in Twelf.  Case studies are primarily focused on the application.  \n* [[Glossary]] - if it's an article that defines a Twelf term.\n\nThe distinction between case studies and tutorials is largely a matter of emphasis, as an example in a tutorial may be an interesting theorem, and a proof in a case study may illustrate a technique.  Put the article wherever you think it fits best.\n\nCompleted tutorials should be tagged with <nowiki>{{tutorial}}</nowiki> at the bottom, and incomplete tutorials should either be tagged with <nowiki>{{stub tutorial}}</nowiki> at the bottom or with <nowiki>{{needswork}}</nowiki> at the top.  Completed case studies should be tagged with <nowiki>{{case study}}</nowiki> at the bottom.\n\n=== Adding code examples ===\n\nThere is not currently a page listing all the code examples. The reason for this is that code here is currently primarily useful in terms of tutorials it is attached to. but all pages that are primarily a code example should include the tag <nowiki>{{twelf code}}</nowiki>, which adds the page to the [[:Category:Twelf code | category for twelf code]].\n\n=== Adding library code ===\n\nYou can add code that can be thought of as \"standard library\"-style code and can be find in students [http://www.resumesplanet.com resume], but there is not, at this time, a framework for organizing that code on this site. The reason for this is that the organizers of the project wiki have not decided whether this code should go in a code repository, directly onto the wiki, or elsewhere. If you upload your contributions to the wiki and tag the file with the <nowiki>{{twelf code}}</nowiki> tag, your contributions will get added to this eventual resource.\n\n[http://customessaywritings.co.uk/samples.php essay samples]\n\n[http://cvresumewritingservices.org buy resume]\n\n[http://perfectessay.ca/ buy essay]"
          },
          "sha1": "9bbdnh837fv8ff0zvya5ziltnyi2xe4"
        }
      },
      {
        "title": "The Twelf Project:Subversion transition",
        "ns": 4,
        "id": 2045,
        "revision": {
          "id": 5149,
          "parentid": 5148,
          "timestamp": "2008-04-17T21:12:25Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "update on successful pre-launch",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 2066,
            "#text": "On Wednesday, April 23, 2008, the Twelf Project will switch from using CVS for its version control mechanism to using Subversion. \n\n== Primary checkout ==\n\nThe last version in CVS was Revision Number 1276 when the transition was prepped on April 17, 2008. Revisions between April 17 and April 23 will be manually applied by [[User:Rsimmons|Rob]].\n\nThe trunk is be available from <tt>svn co https:&#047;&#047;cvs.concert.cmu.edu/twelf/trunk twelf</tt>. As of April 17, it is only available for read-only access for people with login to the old Twelf repository; after April 23, it will be open to general access.\n\n=== Tags ===\n\nAny tag is be accessible from <tt>svn co https:&#047;&#047;cvs.concert.cmu.edu/twelf/tags/&lt;BRANCH NAME&gt;</tt>. The tags as of April 10 are the following:\n\n<code>delphin_last_merge_main\nelphin\ninput-cover\noutput-cover1\npre-roberto\ntwelf-1-2\ntwelf-1-2pl1\ntwelf-1-2pl2\ntwelf-1-2pl3\ntwelf-1-2pl4\ntwelf-1-2pl5\ntwelf-1-2R1\ntwelf-1-2R2\ntwelf-1-2R4\ntwelf-1-2R5\ntwelf-1-2R5pl1\ntwelf-1-2R6\ntwelf-1-2R7\ntwelf-1-2R7pl1\ntwelf-1-2R8\ntwelf-1-2R8pl2\ntwelf-1-2R9pl1\ntwelf-1-2R9pl2\ntwelf-1-3\ntwelf-1-3pl1\ntwelf-1-3R0\ntwelf-1-3R1\ntwelf-1-3R2\ntwelf-1-3R3\ntwelf-1-3R5\ntwelf-1-3R6\ntwelf-1-4\ntwelf-1-4-carsten\ntwelf-1-4r1\ntwelf-1-4-r2\ntwelf-1-5-logosphere\ntwelf-1-5R2\ntwelf-1-5R4\ntwelf-branch-meta\ntwelf-poly</code>\n\n=== Branches ===\n\nAny branch is be accessible from <tt>svn co https:&#047;&#047;cvs.concert.cmu.edu/twelf/branches/&lt;BRANCH NAME&gt;</tt>. The branches as of April 10 are the following:\n\n<code>carsten-12-09\ndelphin_last_merge_main\nelphin\ninput-cover\noutput-cover1\npre-roberto\ntwelf-1-2\ntwelf-1-2pl1\ntwelf-1-2pl2\ntwelf-1-2pl3\ntwelf-1-2pl4\ntwelf-1-2pl5\ntwelf-1-2R1\ntwelf-1-2R2\ntwelf-1-2R4\ntwelf-1-2R5\ntwelf-1-2R5pl1\ntwelf-1-2R6\ntwelf-1-2R7\ntwelf-1-2R7pl1\ntwelf-1-2R8\ntwelf-1-2R8pl2\ntwelf-1-2R9pl1\ntwelf-1-2R9pl2\ntwelf-1-3\ntwelf-1-3pl1\ntwelf-1-3R0\ntwelf-1-3R1\ntwelf-1-3R2\ntwelf-1-3R3\ntwelf-1-3R5\ntwelf-1-3R6\ntwelf-1-4\ntwelf-1-4-carsten\ntwelf-1-4r1\ntwelf-1-4-r2\ntwelf-1-5-logosphere\ntwelf-1-5R2\ntwelf-1-5R4\ntwelf-branch-meta\ntwelf-poly</code>"
          },
          "sha1": "5edd9dpi6kp933bc8025teq9y1exu5q"
        }
      },
      {
        "title": "The Twelf Project:Syntax Highlighting",
        "ns": 4,
        "id": 1672,
        "redirect": {
          "@title": "The Twelf Project:Syntax highlighting",
          "#text": null
        },
        "revision": {
          "id": 2450,
          "timestamp": "2006-10-07T15:21:40Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "[[The Twelf Project:Syntax Highlighting]] moved to [[The Twelf Project:Syntax highlighting]]: Pages should be downcase",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 51,
            "#text": "#REDIRECT [[The Twelf Project:Syntax highlighting]]"
          },
          "sha1": "08p9wkt2j6jkqi0zqgj753taxas690k"
        }
      },
      {
        "title": "The Twelf Project:Syntax highlighting",
        "ns": 4,
        "id": 1393,
        "revision": {
          "id": 4809,
          "parentid": 4798,
          "timestamp": "2007-09-26T12:30:53Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "rv vandal",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 2665,
            "#text": "Syntax highlighting on this website is enabled by [[metawikipedia:GeSHiCodeTag Extension | GeSHiCodeTag]] running on the [http://qbnz.com/highlighter/ General Syntax Highlighter]. A prototype [[The Twelf Project:GeSHi Twelf extension | syntax highlighting extension]] has been written for the Twelf Wiki that can be enabled by using the <tt>&lt;code twelf&gt;&lt;/code&gt;</tt>, but this is depreciated; the syntax highlighter called when using the <tt>&lt;twelf&gt;</tt> tag of [[Project:TwelfTag|TwelfTag]] is written in Haskell.\n\nAs a result, the GeSHi Twelf extensions has bugs that will not be fixed; however, the GeSHi code extension remains for backward-compatability and for highlighting code in languages besides Twelf.\n\n== Using Syntax Highlighting ==\n\nA full list of supported languages is below - GeSHi comes with support for the PHP, C, OCaml, and others. The best way to enter code is to use the <tt><nowiki><code language></nowiki></tt> tag, where \"language\" is the language you want to use - GeSHi will print out the list of languages it supports if the one you pick is not one it recognizes. Furthermore, a tag without a language option, i.e. <tt><nowiki><code></nowiki></tt>, is a useful way to insert preformatted text into the pages. So this code:\n\n<pre><code twelf>plus_s : plus (s N1) N2 (s N3)\n\t  <- plus N1 N2 N3.</code></pre>\n\nwould appear like this:\n\n<code twelf>plus_s : plus (s N1) N2 (s N3)\n\t  <- plus N1 N2 N3.</code>\n\nHowever, to restate the point made above, you shouldn't ever do this for ''Twelf'' code, you should use [[Project:TwelfTag|TwelfTag]].\n\n=== Line numbers ===\n\nThere's also an advaced code tag that adds in line numbers (which do ''not'' get taken along for the ride if you copy and paste the text!) It would be nice to make this the common practice for large code snippiets, but because it makes the text so darn small in some browsers that it's not a good idea unless someone can figure out how to make it consistantly bigger. This code:\n\n<pre><code twelf n>nat : type.\nz: nat. s: nat -> nat.\n\nplus : nat -> nat -> nat -> type.\n%mode plus +N1 +N2 -N3.\nplus_z : plus z N N.\nplus_s : plus (s N1) N2 (s N3)\n\t  <- plus N1 N2 N3.\n%worlds () (plus _ _ _). %total N (plus N _ _).</code></pre>\n\nwill get displayed like this:\n\n<code twelf n>nat : type.\nz: nat. s: nat -> nat.\n\nplus : nat -> nat -> nat -> type.\n%mode plus +N1 +N2 -N3.\nplus_z : plus z N N.\nplus_s : plus (s N1) N2 (s N3)\n\t  <- plus N1 N2 N3.\n%worlds () (plus _ _ _). %total N (plus N _ _).</code>\n\n==Supported Languages==\n\nYou can use the same structure for a wide variety of other languages, which are all listed below.\n\n<code list> echo \"Hello World\"; </php>"
          },
          "sha1": "ixf7k65m8w5pcmbh6lnpw06n57w4cuf"
        }
      },
      {
        "title": "The Twelf Project:To do",
        "ns": 4,
        "id": 1468,
        "revision": {
          "id": 4855,
          "parentid": 4854,
          "timestamp": "2007-10-01T17:07:34Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "comment": "/* Wish-list items */  +CC",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 13991,
            "#text": "__NOTOC__\n\n\n== Ongoing to-do items ==\n\n{| border=\"1\" cellpadding=\"5\" cellspacing=\"0\"\n|-\n| '''Title''' || '''Description''' || '''Adopted By''' || '''Status'''\n|-\n| '''[[:Category:pages needing attention|Pages needing attention]]'''\n| Pages that use templates like {{tl|needs}}, or {{tl|stub}} are automatically placed in this [[:category:pages needing attention|category]]. Some jobs are small, some are large.\n| Everyone \n| ''Ongoing''\n|-\n| '''[[Special:wantedpages|Pages that don't exist]]'''\n| [[Special:wantedpages]] contains a list of the pages that are linked to but don't exist yet. Sometimes the right thing to do is to adjust the target of the link to an existing page, but usually we need to make these pages.\n| Everyone \n| ''Ongoing''\n|-\n|}\n\n== Active to-do items ==\n\n{| border=\"1\" cellpadding=\"5\" cellspacing=\"0\"\n|-\n| '''Title''' || '''Description''' || '''Adopted By''' || '''Status'''\n|-\n| '''Set/map extension'''\n| A simplification of the issues Appel/Leroy seemed to have with CIVMark - from environments to simple sets of naturals, represented by lists. This exists at [[Sets of natural numbers]].\n| Rob & Dan\n| ''Almost ready?''\n|-\n| '''Twelf Standard Library'''\n| We have a lot of code examples, but very little code that can be used as \"take this code and you can use it in your work; here's a list structure or a map structure or a tree that you can use in your proof easily\" or \"someone, by now, has really honestly proven what you want to prove about natural numbers. you don't have to write it again\" The final nature of this will depend on how we decide to distribute code (a wish-list item below), but code development would be good.\n| Rob (could use help)\n| '''Code development''' - list, sets, trees, maps\n|-\n| '''Tutorial level icons'''\n| I'm planning to make nice icons to mark the difficulty level (beginner / intermediate / advanced) of each tutorial.\n| Tom\n| ''soon''\n|-\n| '''Understanding Twelf error messages'''\n| For novices, Twelf's error messages can be confusing, especially they're not familiar with the type theory.  It might be useful to have an explanation of error messages in the context of how we are encouraging people to use Twelf (e.g. \"Expected type family, found object constant\" -- did you forget \"-> type\"? Have you read [[judgments as types]]?)\n: That's a good idea. Some error messages already have pages, like [[output freeness]] and [[ambiguous hyperkind]] (heh). Having a page with a short summary of each error and common causes would be great. I suggest [[error messages]] as a title? &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 00:08, 18 November 2006 (EST)\n: BTW, one really nice thing that Microsoft's compiler does (maybe the only nice thing) is that each error or warning has a short code number that can be used to search for that specific error message. I don't know how feasible it would be to get such a thing in Twelf, but it would make populating the list a lot easier! &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 00:08, 18 November 2006 (EST)\n| spoons\n| ''In progress''\n|-\n|}\n\n== Wish-list items ==\n\nFeel free to adopt a topic and leave the topic here if you'd like to work on it but may not have time for a bit. If you're about to start working on the project, move it to the Active items section.\n\n{| border=\"1\" cellpadding=\"5\" cellspacing=\"0\"\n|-\n| '''Title''' || '''Description''' || '''Adopted By''' || '''Status'''\n|-\n| '''Non-locking [[Project:TwelfTag|TwelfTag]]'''\n| Currently, running an infinite-looping Twelf program through TwelfTag completely locks the wiki (just MediaWiki, not apache, and not the webserver) until I log in as root and kill the process. PHP-spawned processes are already set to much lower priority than httpd, and from there runaway processes can be killed at leisure, if not automatically. So the problem is just that it locks MediaWiki, which it absolutely can't be allowed to do, and I don't have enough apache/php-fu knowledge to know how to deal with the problem.\n: Update, I've made it so that PHP disassociates itself from the process after 10 seconds; this is unsatisfying and reminds me of the way Emacs works, but it doesn't permanently lock up PHP, which is good enough for now. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 00:47, 11 October 2006 (EDT)\n:: I suggest using bash and <tt>ulimit</tt> to limit the spawned twelf process to one or two seconds of CPU. &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 10:59, 11 October 2006 (EDT)\n| Rob?\n| ''Could use improvement''\n|-\n| '''Rewrite intro'''\n| The intro on the [[main page]] sucks, and includes a link begging for editing.\n| ?\n| ''Needed''\n|-\n| '''Twelf.el'''\n| consolidate emacs hacks for new twelf.el?\n* Karl has some, I know. I have a few too. &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 18:02, 5 October 2006 (EDT)\n| Tom?\n| ''Wishlist''\n|-\n| '''More tutorials'''\n| There is a list of tutorials that need to be written on the [[Talk:Tutorials|talk page]].\n| ?\n| ''wishlist''\n|-\n| '''Offsite backup'''\n| I have the database do a full dump every day into [http://twelf.plparty.org/w/backup this folder] (the only privacy concern seems to be revealing the IP addresses of edits, which I don't think we care about - passwords are hashed against our usernames). Could someone automate a pull of this every couple of days to their home machine?\n* I'm now doing it when I do my backup cycle, but that's not very often. I suggest that you bz2 it and copy it to AFS somewhere, since they do quality backups. (If your home dir is not big enough, we can usually get project space.) &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 08:42, 16 October 2006 (EDT)\n|\n| ''Partial''\n|-\n| '''Exercises'''\n| Does it make sense to have some suggested exercises for someone wanting to learn Twelf but who doesn't have an easy research project to try it out on?\n| ?\n| ''?''\n|-\n| '''Code distribution'''\n| The wiki itself won't work for code development&mdash;it's way too high a cost to synchronize changes&mdash;but can work as an excellent index into some other code repository. My guess is that we're going to need to have a public SVN or CVS server running, preferably with a web interface that we can link to from the wiki. Either we roll our own, or we could go with SourceForge.\n* ConCert has a subversion repository; we should use that IMO. &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 15:21, 2 October 2006 (EDT)\n:* Can we get that to allow public read-only access? If so, I agree. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 17:04, 2 October 2006 (EDT)\n:** Yes, we can set up a repository on the ConCert SVN server with public read-only access.  I just need to learn/remember how. — [[User:Spoons|Spoons]] 13:33, 26 October 2006 (EDT)\n| ?\n| ''Wishlist''\n|-\n| '''um.elf'''\n| Rob and Jake both did a Twelf UM implementation - we should make them pretty, possibly tweak them to run a ''little'' better, and put them up.\n| Rob?\n| ''Low priority''\n|-\n| '''Bibliography of LF'''\n| The [[bibliography of LF]] needs cleaning up, finishing of the transwikificaition, and ultimately needs its links checked. It should also be updated with citations for more recent work (Is this second part its own wishlist item?). \n| Rob\n| ''Low priority''\n|-\n| '''Negation as failure'''\n| Karl mentioned a new trick to do \"negation as failure\" using [[deterministic declaration|%deterministic]] at the <s>ConCert</s> InCert meeting. Supposedly it's just a few lines, which would make a nice Twelf Wiki page. Maybe dklee knows how to do this and can post about it?\n|\n| ''?''\n|-\n| '''Closure conversion'''\n| I know how to do closure conversion (Karl's technique), which was previously thought to be difficult in Twelf. It's worth a tutorial. &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 13:07, 1 October 2007 (EDT)\n|\n| ''?''\n|-\n\n|}\n\n== Completed items ==\n\n{| border=\"1\" cellpadding=\"5\" cellspacing=\"0\"\n|-\n| '''Title''' || '''Description''' || '''Adopted By''' || '''Status'''\n|- \n| '''[[Glossary]]'''\n| Glossary that contains the jargon terms that we see often. Nick Benton's WMM talk complained (rightfully) about the way that experts use jargon terms that ''never appear anywhere in the manual''. There should be a single page for quickly answering the question, \"What is a ______?\"\n* examples (please expand, anyone): adequacy, extensionality, shallow and deep encodings, shallow and deep equality, intrinsic and extrinsic encodings, hackbind, functionality, metatheorem, coverage, constant, judgment, relation, signature, regular worlds, world subsumption, subordination, canonical form, subderivation, total, ...\n* rh: there's a difference (don't ask me to define it) between jargon and terminology.  we shouldn't give the impression that technical terminology is mere jargon.  for example, hackbind is jargon, but canonical form is terminology.  one difference is that terminology is really defined somewhere, even if people don't know it.\n** I agree and the distinction is important. Unfortunately for users, it's not easy to tell whether something is terminology or jargon, without first at least knowing what it means. Can a unified glossary keep this distinction? I think so. &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 04:29, 24 September 2006 (MST)\n| Dan, Rwh, Tom\n| '''Stable for now'''\n|-\n| '''Deep and shallow [[equality]]'''\n| Dan explained the solution [[Elves_talk:Main_Page#Rephrasing_.22equality.22|here]] to a question I had about how to relate the two obvious descriptions of [[equality]]\n| <strike>Rob</strike> DRL \n| '''Obsolete/Done'''\n|-\n| '''Software'''\n| The pages that hold or point to software have (mostly) now been protected. Protection should be completed, and the [[software]] and [[release history]] pages should be updated with correct information and links to the software itself.\n| Rob\n| '''Done'''\n|-\n| '''Explanation of %trustme'''\n| The page [[Holes in metatheorems]] has a description of pre-1.5R1 holes, but currently no description of %trustme\n| Dan Lee\n| '''Done'''\n|-\n| '''Debugging syntax highlighting'''\n| The syntax highlighting module is not, and isn't really built to be, perfect. If you find a quirk in the syntax highlighting, leave it at [[Project:To do/Syntax highlighting]].\n:: I rewrite the syntax highlighter in Haskell, it appears to be much faster to call out to Haskell than it was to parse in PHP. But because everything has been completely rewritten, there may be new and exciting bugs. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 21:05, 5 November 2006 (EST)\n| Everyone (discovery), Rob (fixing)\n| '''Stable'''\n|-\n| '''AJALF'''\n| (from Dan Lee) The merit of this idea is probably some combination of ridiculous, cool, useful, and interesting exercise for an undergraduate. It would be neat if we had a webserver somewhere running a cgi script that would allow you to check Twelf code off the wiki/via a web interface. Being able to check code off the wiki would allow us to develop examples directly out of the wiki, instead of cutting and pasting from our workstations. The other advantage is that people could try Twelf hacking without going through any install procedure.\n* According to Tom, Jason Reed has already written code for this. However, it will have to wait until the Wiki moves off my website to its real home, wherever that is. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 07:39, 22 September 2006 (MST)\n** Note: We could use iframes or pop-up windows to host just that part off-site. I agree this is pretty low priority though. &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 11:40, 22 September 2006 (MST)\n*** New way to do this is almost in place. &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 19:09, 12 October 2006 (EDT)\n| Tom and Rob\n| '''Stable'''\n|-\n| '''Transwiki'''\n| Get things from the [http://fp.logosphere.cs.cmu.edu/twelf/ old twelf wiki] over here\n| Rob\n| '''Done for now'''\n|-\n| '''Cute little icon'''\n| We should get one of those little icons that shows up in the navagation bar, like all the big grownup websites.\n| Tom\n| ''Done''\n|-\n| '''Explanation of substitution lemmas'''\n| An explanation of how to permute the lambdas in the LF context to prove things like substitution in a language with a store. In particular, I want to show how you can do this for a substitution lemma for a dependently typed lambda calculus without resorting to explicit contexts.\n\nI've drafted the article, but I invite people to point out points that require clarification in [[Talk:Substitution_lemma]] --[[User:DanielKLee|DanielKLee]] 21:08, 24 September 2006 (MST)\n| Dan Lee\n| '''Done for now'''\n|-\n| '''Learning Twelf'''\n| A prominent page that leads prospective users to an appropriate tutorial, should they like to learn about or learn Twelf. (appears in the lower right corner of the [[Main Page]]\n| Rob\n| '''Done (the portal part)'''\n|- \n| '''Debug Math'''\n| The math tag doesn't parse anymore, and I need to figure out what went wrong - Depot could have killed something that accidentally ended up in /user/local\n:: For some reason /usr/local/bin dropped out of the server's search path. If someone figures out why, it would be good to fix this; for now, I have recompiled the math processor with built-in absolute filenames, which makes the missing $PATH irrelevant. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 14:58, 5 October 2006 (EDT)\n| Rob\n| '''Done'''\n|-\n| '''CPS Conversion'''\n| CPS conversion is a little tricky, mainly because the natural algorithm is itself continuation based. I have done it several times, so I can write a tutorial using my best known technique. Relies on [[reversing the polarity]].\n| Tom\n| '''[[CPS conversion|done]]'''\n|-\n| '''[[Converting between implicit and explicit parameters]]'''\n| Simple tutorial on this, referenced in [[CPS conversion]]\n| Tom\n| ''[[Converting between implicit and explicit parameters|done for now]]''\n|-\n| '''[[Linear logic]]'''\n| Someone should write a tutorial on linear logic, since we have a good way to do it but it is not obvious.\n| Karl\n| ''[[linear logic|done]]''\n|-\n|}"
          },
          "sha1": "e4853x1wr6mpz78r8txp98x9nbseo19"
        }
      },
      {
        "title": "The Twelf Project:To do/Syntax highlighting",
        "ns": 4,
        "id": 1522,
        "revision": {
          "id": 2432,
          "parentid": 2431,
          "timestamp": "2006-10-07T04:54:25Z",
          "contributor": {
            "username": "Varming",
            "id": 10
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 1429,
            "#text": "* An identifier within a lemma without a leading <tt>&lt;-</tt> is interpreted as a new keyword (is this fixable?)\n\n=== Done === \n* <strike><tt>*</tt> is not recognized as part of an identifier</strike> — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 13:21, 30 September 2006 (EDT)\n* <strike><tt>%block</tt> is not recognized as a keyword</strike> — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 13:21, 30 September 2006 (EDT)\n* <strike>[[%infix]], [[%postfix]], [[%prefix]] not keywords. &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 10:49, 5 October 2006 (EDT)</strike> — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 19:06, 5 October 2006 (EDT)\n* Doesn't dig many other characters in identifiers: > < &, etc. &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 10:49, 5 October 2006 (EDT)\n:* Made some fixes, other ones will be more complicated (because it's actually syntax higlighting <nowiki>&gt</nowiki>, not >) — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 19:06, 5 October 2006 (EDT)\n::* Whoa: [[CPS conversion]] (scroll down) &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 19:11, 5 October 2006 (EDT)\n:::* I think I fixed all the crazy stuff. Did I fix all the crazy stuff? — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 00:51, 7 October 2006 (EDT)\n\n* <twelf>fuNNY : type.</twelf> looks bad. &nbsp;&mdash;&nbsp;[[User:Varming|Varming]] Sat Oct  7 00:52:14 EDT 2006"
          },
          "sha1": "fm1pn8gpkl05u6xdj6e650ftkw1c70i"
        }
      },
      {
        "title": "The Twelf Project:TwelfTag",
        "ns": 4,
        "id": 1670,
        "revision": {
          "id": 6090,
          "parentid": 6089,
          "timestamp": "2010-09-01T15:22:19Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "/* The check=decl option */",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 8556,
            "#text": "TwelfTag is [[User:Rsimmons|Rob's]] system for non-interactively checking Twelf code. This is a guide to TwelfTag for contributors; if you are a reader, then [[TwelfTag|this article]] may be more helpful. While [[Twelf Live]] allows people to interact with signatures, TwelfTag is designed for writing and checking code for use in wiki articles.\n\nNeither the <nowiki><twelf></nowiki> tag nor the <nowiki><twelflink></nowiki> tag have any required arguments. The optional arguments for <nowiki><twelf></nowiki> tags are:\n* <tt>check={true|false|decl}</tt> (default <tt>false</tt>) - cannot be used when hidden=true\n* <tt>discard={true|false}</tt> (default <tt>false</tt>)\n* <tt>hidden={true|false}</tt> (default <tt>false</tt>)\n* <tt>import=\"..something..\"</tt> (default <tt>\"main\"</tt>)\n* <tt>export=\"..something..\"</tt> (default <tt>\"main\"</tt>)\n\nThe optional arguments for <nowiki><twelflink></nowiki> tags are:\n* <tt>check={true|false}</tt> (default <tt>false</tt>)\n* <tt>import=\"..something..\"</tt> (default <tt>\"main\"</tt>)\n\nThe following document discusses the function of each of these tags.\n\n== The <tt><nowiki><twelf></nowiki></tt> tag for syntax highlighting ==\n\nThe <tt><nowiki><twelf></nowiki></tt> tag itself is simple enough, it works much like an HTML <nowiki><pre></nowiki> environment with [[Project:Syntax Highlighting|syntax highlighting]].\n\nHowever, the <tt><nowiki><twelf></nowiki></tt> tag also does a number of other interesting and useful things. At the most basic level, it crops out any whitespace at the beginning or end of the environment so that this:\n\n<pre><twelf>\n\nexp : type.\n\nabs : (exp -> exp) -> exp.\n\n</twelf></pre>\n\nWill look like this:\n\n<twelf>\n\nexp : type.\n\nabs : (exp -> exp) -> exp.\n\n</twelf>\n\n== The <tt><nowiki><twelf></nowiki></tt> and <tt><nowiki><twelflink></nowiki></tt> tags ==\n\nBehind the scenes, the content of every <tt><nowiki><twelf></nowiki></tt> tag is grouped together. So if you have a series of Twelf tags that are defining a single signature, like this (continuing from the example above):\n\n<twelf>\napp : exp -> exp -> exp.\n</twelf>\n\nand this:\n\n<twelf>\nstep : exp -> exp -> type.\n</twelf>\n\nthen TwelfTag, at this point in the process, has code for <tt>exp</tt>, <tt>abs</tt>, <tt>app</tt>, and <tt>step</tt> gathered in a group (this group is named (<tt>\"main\"</tt>), though it hasn't done anything with it yet. \n\n=== The <tt><nowiki><twelflink></nowiki></tt> tag ===\n\nYou can link to a collection of all the code that has been presented so far by using <tt><nowiki><twelflink></nowiki></tt> tags in the same way you would use <tt><nowiki><a href=...></nowiki></tt> tags in normal HTML code.\n\nAs an example, <tt><nowiki><twelflink>OMG link!</twelflink></nowiki></tt>, will appear like this: <twelflink>OMG link!</twelflink>, pointing to the four lines of code declared so far throughout the file.\n\nThe filenames are just the MD5 hashes of the code which they contain; the [http://twelf.plparty.org/code code directory] contains all these stored files.\n\n=== The <tt>check=true</tt> option ===\n\nWe are not collecting code in the background just to link to it, we're creating code so we can check it in Twelf! If you use the twelf tag with the <tt>check=true</tt> option, Twelf will execute the collected segments in Twelf and link to the output.\n\n<pre><twelf check=true>\nstep/app1 : step (app E1 E2) (app E1' E2)\n             <- step E1 E1'.\nstep/app2 : step (app E1 E2) (app E1 E2')\n             <- step E2 E2'.\nstep/appabs : step (app (abs [x] E x) E') (E E').\n</twelf></pre>\n\n<twelf check=true>\nstep/app1 : step (app E1 E2) (app E1' E2)\n             <- step E1 E1'.\nstep/app2 : step (app E1 E2) (app E1 E2')\n             <- step E2 E2'.\nstep/appabs : step (app (abs [x] E x) E') (E E').\n</twelf>\n\nYou may notice that the link above links to a file \"twelf.plparty.org/code/<obvious md5 hash>.chk\". The code that was checked is just at \"twelf.plparty.org/code/<exact sameobvious md5 hash>\" - that is, without the \".chk\".\n\nYou can use <tt><nowiki><twelflink check=true></nowiki></tt> to link to the Twelf output of checking the most recent code instead of just linking to that code code - so <tt><nowiki><twelflink check=true>See?</twelflink></nowiki></tt> just duplicates the link that was automatically entered in above. <twelflink check=true>See?</twelflink>. This works even if you haven't set <tt>check=true</tt> in any of your <tt><nowiki><twelf></nowiki></tt> tags; you could just avoid using the <tt>check=true</tt> option in your code in favor of causing checks only with <tt><nowiki><twelflink check=true></nowiki></tt>.\n\n=== The <tt>check=decl</tt> option ===\n\nIf you want to concentrate on the output of the last code fragment, for instance to examine a particular case of type reconstruction, you can use the <tt>check=decl</tt> option for the Twelf tag. In the background, TwelfTag loads the previous portions of the signature on chatter 0, and then returns to the default chatter 3 to run the current code snippet. It then does some simple manipulations on Twelf's response to remove things like useless <tt>%% OK %%</tt> notices, and then inlines the result.\n\n<pre><twelf check=decl>\n\ntest = step/app1(step/app2 step/appabs).\n\n</twelf></pre>\n\n<twelf check=decl>\n\ntest = step/app1(step/app2 step/appabs).\n\n</twelf>\n\n=== The <tt>discard=true</tt> option ===\n\nIf you add <tt><nowiki><twelf discard=true></nowiki></tt> then it will syntax highlight but will not incorporate the segment into the collected code. This is important when you want to demonstrate mistake, because otherwise Twelf will get caught up on that mistake in the future. As a result, this option is frequently used with <tt>check=decl</tt>.\n\n<pre><twelf discard=true check=decl>\n% Don't do this!\n\nstep/appabs : step E1 E2 <- step E1 E2.\n</twelf></pre>\n\n<twelf discard=true check=decl>\n% Don't do this!\n\nstep/appabs : step E1 E2 <- step E1 E2.\n</twelf>\n\n=== The <tt>import=</tt> and <tt>export=</tt> options ===\n\nThis is a tricky feature that allows you to run parallel segments of code on a single page. It should be used sparingly, as otherwise it can become extremely confusing to both readers and editors. Each <tt><nowiki><twelf></nowiki></tt> tag is associated with a value, <tt>import</tt>, that defines where it gets its code ''from'', and a value, <tt>export</tt>, that defines where it binds the concatenation of the code the previous code and the new code within the tag. \n\n* If <tt>import=</tt> is not defined, it is assumed to be <tt>\"main\"</tt>.\n* If <tt>export=</tt> is not defined, it is assumed to be the value of <tt>import</tt>. If you try to clobber an existing export, for instance by importing from <tt>\"main\"</tt> and exporting to <tt>\"alt\"</tt> twice, Twelf will complain.\n\nIn most cases <tt>discard=true</tt> should be sufficient for one's purposes.\n\nThis example is hopefully revealing:\n\n<pre><twelf import=\"nat\">\nnat : type.\n</twelf>\n\nThis is a simple way of expressing nats:\n<twelf import=\"nat\" export=\"natsimple\">\nz : nat.\ns : nat -> nat.\n</twelf>\n\nThis is a verbose way of expressing nats:\n<twelf import=\"nat\" export=\"natverbose\">\nnat/z : nat.\nnat/s : nat -> nat.\n</twelf>\n\n<twelflink import=\"natsimple\">See the simple code</twelflink>\n\n<twelflink import=\"natverbose\">See the verbose code</twelflink></pre>\n\n<twelf import=\"nat\">\nnat : type.\n</twelf>\n\nThis is a simple way of expressing nats:\n<twelf import=\"nat\" export=\"natsimple\">\nz : nat.\ns : nat -> nat.\n</twelf>\n\nThis is a verbose way of expressing nats:\n<twelf import=\"nat\" export=\"natverbose\">\nnat/z : nat.\nnat/s : nat -> nat.\n</twelf>\n\n<twelflink import=\"natsimple\">See the simple code</twelflink>\n\n<twelflink import=\"natverbose\">See the verbose code</twelflink>\n\n=== The <tt>hidden=true</tt> option ===\n\nYou can use the <tt>hidden=true</tt> option to insert Twelf into a page without having it appear to the reader. You can't use the\n<tt>check</tt> option in conjunction with this setting, but it is quite useful in conjunction with <tt>import</tt> and <tt>export</tt>.\n\nBy inserting this code into the wiki you can add a definition of \"plus\" to the code group named \"natsimple\".\n\n<pre><twelf import=\"natsimple\" hidden=true>\nplus : nat -> nat -> nat -> type.\n\nplus/z : plus z N N.\nplus/s : plus (s N1) N2 (s N3)\n          <- plus N1 N2 N3.\n</twelf></pre><twelf import=\"natsimple\" hidden=true>\nplus : nat -> nat -> nat -> type.\n\nplus/z : plus z N N.\nplus/s : plus (s N1) N2 (s N3)\n          <- plus N1 N2 N3.\n</twelf> \n\n<twelflink import=\"natsimple\">See the hidden code added to the existing natural number development.</twelflink>"
          },
          "sha1": "miua0hnfba8y84j9mqh836geeigss5f"
        }
      },
      {
        "title": "The Twelf Project talk:AJALF",
        "ns": 5,
        "id": 1725,
        "revision": {
          "id": 2873,
          "parentid": 2870,
          "timestamp": "2006-10-16T01:09:45Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 927,
            "#text": "AJALF deserves its own article. My guess is it's AJAX + Twelf server? This is also a good place to acknowledge the people who brought this sweet technology to us. It's been Jcreed, Tom7 and Rob, right? --[[User:DanielKLee|DanielKLee]] 20:29, 15 October 2006 (EDT)\n: See, my only problem with this is that we need to recognize the fact that we're, on most levels, kidding - Tom advocated for AJALF instead of my suggestion of AJAT because AJALF sounded more fundamentally ridiculous. (and the meaning of the acronym is Async. Javascript and LF, as opposed to Async. Javascript and XML)  — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 20:50, 15 October 2006 (EDT)\n::Since it's only of use to developers, I moved it to the project namespace. But it's probably a good idea to leave notes on how it works, so that someone can maintain what we did. &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 21:09, 15 October 2006 (EDT)"
          },
          "sha1": "c8uak7bz2d9jlac5plpt2jprpxh41qa"
        }
      },
      {
        "title": "The Twelf Project talk:Copyright",
        "ns": 5,
        "id": 1703,
        "revision": {
          "id": 4812,
          "parentid": 4801,
          "timestamp": "2007-09-26T12:32:47Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "rv vandal",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 2923,
            "#text": "== CC-NC licenses ==\n\nCan we remove the option for noncommercial cc licenses? They are incompatible with the GPL and GFDL, and so are pretty much a dead end for free content. Is there any indication that people want to use them? &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 13:41, 13 October 2006 (EDT)\n: Some wikis are CC-NC, and it's not dead-end if there's a home for them here :). I'm not at all opposed to getting rid of some though, I just figured it was better to have the maximum number of options. There is no indication that anyone would want to use any of these, in all honesty, introducing them was merely futureproofing. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 17:15, 13 October 2006 (EDT)\n:: OK, point taken. Well, I'd say we should at least maximally discourage noncommercial licenses. &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 17:40, 13 October 2006 (EDT)\n\n== At most one tag ==\n\nAlso, I don't see any reason why pages can't be dual- or tri-licensed. What's the idea with that restriction? &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 13:43, 13 October 2006 (EDT)\n: Two reasons - one is just simplicity and not having eight red tags on a single page. The other is that reading licenses I got the impression that there may actually be weird legal things involved in multi-licensing that I didn't quite want to understand. The subtyping relationship of multilicensing is quite complicated and might not be reasonably understood by all editors to a page. I think if someone ''did'' strongly express an opinion about wanting to actually multilicense certain pages, the issue would be different, I just couldn't imagine such an odd situation and didn't want people doing it lightly. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 17:18, 13 October 2006 (EDT)\n:: OK. The purpose of multi-licensing, actually, is to to solve the \"subtyping\" issues: since most licenses are not directly comparable, it is useful to essentially introduce \"intersection types\" by asserting that the content can be used under one of many licenses. (So if original content is licensed GPL, GFDL, and cc-by-sa, then someone can fork the content into a GPL codebase or onto Wikipedia or into some like Lessig Twelf remix song or something.) It's actually a pretty common thing on Wikipedia actually to license (especially images) GPL/GFDL/cc. But you're right, this is probably never going to come up. I just thought I'd mention it. (BTW, I do know a lot about copyright stuff in case you ever need an IANAL semi-expert.) &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 17:40, 13 October 2006 (EDT)\n::: Aah! Good to know. I am very interested in copyright issues as well... I think it's probably worth removing the one tag restriction, though really I'd rather people just license with <math>\\top</math> in this particular case. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 18:20, 13 October 2006 (EDT)"
          },
          "sha1": "h96da2ely5vpucv5uxlj4392j7oue67"
        }
      },
      {
        "title": "The Twelf Project talk:GeSHi Twelf extension",
        "ns": 5,
        "id": 1479,
        "revision": {
          "id": 4543,
          "parentid": 2313,
          "timestamp": "2007-03-21T02:19:46Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "comment": "redlink patrol",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 1670,
            "#text": "== Tom's suggestions ==\n\nCan I make a few suggestions?\n\n* Since red is used for links that don't exist, I think it ought to be avoided for the twelf syntax mode. When I'm editing wikis my eyes are immediately drawn to red as indicating a problem.\n* Similarly, I think we should color comments and constants differently. \n* Is there a way to have a regular expression for %[a-z] to catch all %commands? That way we don't have to have a keyword table.\n:: &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 18:38, 23 September 2006 (MST)\n\n=== Rob's replies ===\n\n* Not using red: what color do you think we should use? I think we'd confuse people that want to use syntax highlighting in Emacs, if we did that with constants. I'm open to suggestions, however.\n:* I don't think it will be very confusing because many people customize their emacs colors anyway (the defaults are like eye poison to me). Anything else is fine; I don't think you're using anything on, say, the brown end of the spectrum. &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 17:37, 30 September 2006 (EDT)\n* This I've tried to do - making comments bold dark grey. What do you think?\n:* Looks good to me. &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 17:37, 30 September 2006 (EDT)\n* That's what I tried at first, it didn't work so well for reasons I don't entirely understand - I think the problem is the interaction between it and other regexp searches. It's not the worst thing in the world to have a keyword table for, in any case.\n:: — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 16:05, 30 September 2006 (EDT)\n:* Okay, just wonderin'. =) &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 17:37, 30 September 2006 (EDT)"
          },
          "sha1": "3oa2h6h548le5vodp1idyow7fpfkio1"
        }
      },
      {
        "title": "The Twelf Project talk:Policy",
        "ns": 5,
        "id": 1861,
        "revision": {
          "id": 3736,
          "parentid": 3735,
          "timestamp": "2007-02-25T03:30:35Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 460,
            "#text": "I don't think there's any reason to intimate that we'll protect editors' IP addresses unless ordered by a court; there should be no reason to edit the Twelf wiki anonymously. &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 22:23, 24 February 2007 (EST)\n: Sure. I said that a long time ago anyway. [[User:128.2.223.28|128.2.223.28]] 22:29, 24 February 2007 (EST) (That was me — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 22:30, 24 February 2007 (EST))"
          },
          "sha1": "0stfvm038hxiqd8aryxjd284xt0chr5"
        }
      },
      {
        "title": "The Twelf Project talk:Style guide",
        "ns": 5,
        "id": 1460,
        "revision": {
          "id": 4489,
          "parentid": 3446,
          "timestamp": "2007-03-20T22:11:04Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "comment": "/* Metalemma vs. metatheorem */ redlink patrol",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 4601,
            "#text": "== Metalemma vs. metatheorem ==\n\nI propose we always use ''metatheorem'' when talking about the <tt>%total</tt>ity of relations, and only use the word \"lemma\" when speaking informally. The distinction between metatheorem and metalemma is needless, in my opinion, and may lead to confusion if people assume they are technically different. (Incidentally, I moved holes in Metalemmas to [[holes in metatheorems]] since the holes usually aren't ''in'' the lemmas, the holes ''are'' the (standins for) lemmas. Thoughts? &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 07:03, 12 September 2006 (MST)\n\n: I think that makes sense. So then, if you need <tt>thm-a</tt> and <tt>thm-b</tt> to prove <tt>thm-f</tt>, then all of them are metatheorems but the first two are also metalemmas in that they are lemmas of <tt>thm-f</tt>? — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 10:34, 12 September 2006 (MST)\n:: Yes, that's what I meant, though I'd also say we just avoid the word ''metalemma'' altogether. Since it would be our own new terminology, people might mistakenly believe that it has a distinct meaning from ''metatheorem'' and that the distinction is important. I don't have a strong feeling on this, though, if somebody thinks that the distinction ''is'' important. &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 11:12, 12 September 2006 (MST)\n\n== What are Twelf users called? ==\n\nIs a Twelf user a \"programmer\", \"prover\", \"logician\", \"mathematician\", \"researcher\", or \"user\"?\n:''Suppose the _____ wants to create a hole in his metatheorem.''\n\n&nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 07:26, 12 September 2006 (MST)\n\n:: Twelfer? If that's to hokey, I'd go with \"user\" or \"Twelf user\" — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 10:31, 12 September 2006 (MST)\n\n== Metasyntactic variables ==\n\nSometimes in examples on the Wiki it is useful to come up with \"dummy\" names for relations or constants. How attached are you guys to the practice of using \"foo\" and \"bar\" and \"baz\" and other classic [[:w:metasyntactic variable|metasyntactic variable]]s? Personally I find these annoying for reasons that essentially amount to taste, but I know that others (like Bob) hate them too. Somehow it seems to cheapen any example by making it feel like it should be Perl or something. My suggestion is to use variables like \"thm\" or \"a\", \"b\", \"c\". On the other hand, having the tone of the Twelf Wiki be more jargon-y might turn more people on to the project. Anyway, just putting the thought out there. &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 07:51, 12 September 2006 (MST)\n\n: I agree that we should avoid silly metasyntactic variables when doing so doesn't buy us anything I think another way to handle the issue is to assume a general understanding of certain concrete examples - using \"nat\" and \"plus-nat\" is clearly preferable to using \"foo.\" Another alternative I favor is to use \"conversational names\" - for instance, to rewrite Karl's code from the bottom of the [[factoring]] article:\n<twelf>my-case1 : relation A B C\n    <- long-drawn-out-computation A B D\n    <- another-long-computation A B (inexhaustive-match/one C).\n\nmy-case2 : relation A B C\n    <- long-drawn-out-computation A B D\n    <- another-long-computation A B (inexhaustive-match/two C).</twelf>\n: I remember how was SO CONFUSED learning some early language (it might, in fact, have been Perl - or QBASIC) because I kept trying to understand the meaning of the \"$foo\" keyword. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 18:48, 22 September 2006 (MST)\n\n== Metatheorem terminology/word usage ==\n\nWhat I put under \"Word usage\" seems to fit with my understanding, the terminology in ''Mechanizing Metatheory in a Logical Framework,'' and my understanding of consensus the last time we at least started debating it. The reason I recommend ''verify'' instead of ''prove'' to describe the interplay of a <tt>[[%total]]</tt> directive and a totality assertion is that I realized using ''prove'' gains a lot of ambiguity in a hypothetical system with interplay between a [[theorem prover]] and the current [[totality assertion]] checke. \n\nIt might be helpful, for instance, to say that the theorem prover produces output (a logic program) that witnesses the {{forall}}{{exists}}-statement's totality, and a totality assertion checker could verfiy the totality of the logic program produced. I don't feel like this terminology is incompatible with the idea that Twelf's totality assertion checker is doing theorem proving. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 03:19, 29 December 2006 (EST)"
          },
          "sha1": "thw9puj3lgaig7qt2c080vga87n4evk"
        }
      },
      {
        "title": "The Twelf Project talk:To do",
        "ns": 5,
        "id": 1503,
        "revision": {
          "id": 4462,
          "parentid": 4461,
          "timestamp": "2007-03-20T20:49:22Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "minor": null,
          "comment": "/* Namespaces */ killredlink",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 1951,
            "#text": "== \"Flying tour\" ==\n\nOne of the helpful things that ACL2 has is a [http://www.cs.utexas.edu/users/moore/acl2/v3-0/The_Tours.html flying tour] that takes people through the real basics of using ACL2 - they also have a walking tour which is much more in-depth. Right now we see the need for tutorials, and I think the glossary idea is a good one. Do you think Dan Licata's document might be effectively turned into a good \"flying tour of twelf\" through the wiki? — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 05:56, 25 September 2006 (MST)\n\n== Namespaces ==\n\nDo you think we need a new Tour: namespace that signals \"this information is safe for n003s, don't put your crazy HOAS-filled coinductive hackbind here\"? I'm realizing I'm creating tutorials like [[equality]] that teach towards a number of levels of experience and sophistication, and might want a place to put an article, like, say, Tour:Equality that only covers shallow equality briefly, and then have forward/backward links that say ''if you want {more/less} information you can go to the {tutorial on shallow and deep [[Equality]] / 'introductory tour' article Tour:Equality}'' Thoughts? — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 18:57, 27 September 2006 (MST)\n\n: Tour namespaces sound like a reasonable idea. Deriving/using equality is somewhat of an intermediate topic in my opinion; I think we could do a fine n00best tour without it. --[[User:DanielKLee|DanielKLee]] 20:25, 27 September 2006 (MST)\n\n== Alt+D ==\n\nThis wiki seems to have captured Alt+D as a \"delete page\" command. Other wikis I use don't seem to have this behavior. The default behavior for this in my browser is \"go-to location bar\", so I find myself regularly faced with the \"Confirm delete\" screen when really I just wanted to go somewhere else. Is there some preference to turn this off? I can't seem to find it. --[[User:DanielKLee|DanielKLee]] 20:25, 27 September 2006 (MST)"
          },
          "sha1": "7qz6wfr154evnm1uu26ml2blx5ocimt"
        }
      },
      {
        "title": "The Twelf Project talk:TwelfTag",
        "ns": 5,
        "id": 1673,
        "revision": {
          "id": 2556,
          "parentid": 2509,
          "timestamp": "2006-10-10T18:34:57Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "comment": "oops",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 1602,
            "#text": "== Group''s'' ==\n\nRob, this rocks. I have a feature request. In the article [[converting between implicit and explicit parameters]] I develop a starting signature and then discuss two diverging paths that one could use. I'd like to write\n\n<pre><nowiki>\n  <twelf groups=\"path1,path2\">\n    % starting signature\n  </twelf>\n \n  <twelf group=\"path1\">\n    % code for path 1\n  </twelf>\n \n  <twelf group=\"path2\">\n    % code for path 2\n  </twelf>\n\n  <twelflink group=\"path1\">see path 1</twelflink>  <twelflink group=\"path2\">see path 2</twelflink>\n</nowiki></pre>\n\nIs this possible with the current setup, or easy to add? Another useful feature which would allow me to give the impression of this is <nowiki><twelf visible=\"false\">...</twelf></nowiki> so that I could just silently include two copies of the setup. &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 12:33, 9 October 2006 (EDT)\n\nI will add the multiple groups=\"...\" tag, and I'd been contemplating that I needed a hidden=\"true\" tag (I like ''affirming'' the HTML). — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 14:00, 9 October 2006 (EDT)\n* My suggestion was a little bogus: group is of course a special case of groups, so it should probably be either group=\"a,b,c\" or allow multiple occurences of the parameter (group=\"a\" group=\"b\" group=\"c\")? But, thanks! &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 14:34, 9 October 2006 (EDT)\n:* It is done, using group=\"a,b,c\" form. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 16:30, 9 October 2006 (EDT)\n\n== oops ==\n\nhttp://twelf.plparty.org/w/index.php?title=CPS_conversion&action=edit"
          },
          "sha1": "8fye2cu1ifit9edrxapyd5hnn677i55"
        }
      },
      {
        "title": "File:Demtech.png",
        "ns": 6,
        "id": 2382,
        "revision": {
          "id": 6802,
          "timestamp": "2013-04-18T21:33:27Z",
          "contributor": {
            "username": "Carsten",
            "id": 38
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 0,
            "#text": null
          },
          "sha1": "phoiac9h4m842xq45sp7s6u21eteeq1"
        }
      },
      {
        "title": "File:Disk download.gif",
        "ns": 6,
        "id": 1845,
        "revision": {
          "id": 3559,
          "timestamp": "2007-01-31T10:36:12Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "comment": "Small \"disk\" image, made by [[:user:Tom7]] and licensed for free use.",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 69,
            "#text": "Small \"disk\" image, made by [[:user:Tom7]] and licensed for free use."
          },
          "sha1": "34ks5fxa1ulq7nsvvn1pmvogzraef54"
        }
      },
      {
        "title": "File:POPL Tutorial-IBM.jpg",
        "ns": 6,
        "id": 2168,
        "revision": {
          "id": 5842,
          "timestamp": "2009-01-29T14:43:07Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 0,
            "#text": null
          },
          "sha1": "phoiac9h4m842xq45sp7s6u21eteeq1"
        }
      },
      {
        "title": "File:POPL Tutorial-cmu.gif",
        "ns": 6,
        "id": 2174,
        "revision": {
          "id": 5848,
          "timestamp": "2009-01-29T15:14:02Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 0,
            "#text": null
          },
          "sha1": "phoiac9h4m842xq45sp7s6u21eteeq1"
        }
      },
      {
        "title": "File:POPL Tutorial-docomo-logo.gif",
        "ns": 6,
        "id": 2169,
        "revision": {
          "id": 5843,
          "timestamp": "2009-01-29T14:47:30Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 0,
            "#text": null
          },
          "sha1": "phoiac9h4m842xq45sp7s6u21eteeq1"
        }
      },
      {
        "title": "File:POPL Tutorial-google-logo.gif",
        "ns": 6,
        "id": 2170,
        "revision": {
          "id": 5844,
          "timestamp": "2009-01-29T14:47:49Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 0,
            "#text": null
          },
          "sha1": "phoiac9h4m842xq45sp7s6u21eteeq1"
        }
      },
      {
        "title": "File:POPL Tutorial-intel.jpg",
        "ns": 6,
        "id": 2172,
        "revision": {
          "id": 5846,
          "timestamp": "2009-01-29T14:55:06Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 0,
            "#text": null
          },
          "sha1": "phoiac9h4m842xq45sp7s6u21eteeq1"
        }
      },
      {
        "title": "File:POPL Tutorial-mozilla.jpg",
        "ns": 6,
        "id": 2173,
        "revision": {
          "id": 5847,
          "timestamp": "2009-01-29T15:03:03Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 0,
            "#text": null
          },
          "sha1": "phoiac9h4m842xq45sp7s6u21eteeq1"
        }
      },
      {
        "title": "File:POPL Tutorial-msr.jpg",
        "ns": 6,
        "id": 2171,
        "revision": {
          "id": 5845,
          "timestamp": "2009-01-29T14:54:31Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 0,
            "#text": null
          },
          "sha1": "phoiac9h4m842xq45sp7s6u21eteeq1"
        }
      },
      {
        "title": "File:POPL Tutorial-scslogo.gif",
        "ns": 6,
        "id": 2175,
        "revision": {
          "id": 6085,
          "parentid": 5849,
          "timestamp": "2010-09-01T07:50:44Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "uploaded a new version of &quot;[[File:POPL Tutorial-scslogo.gif]]&quot;",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 0,
            "#text": null
          },
          "sha1": "phoiac9h4m842xq45sp7s6u21eteeq1"
        }
      },
      {
        "title": "File:Searchgraph-found.svg",
        "ns": 6,
        "id": 1877,
        "revision": {
          "id": 3830,
          "timestamp": "2007-03-01T04:17:30Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 0,
            "#text": null
          },
          "sha1": "phoiac9h4m842xq45sp7s6u21eteeq1"
        }
      },
      {
        "title": "File:Searchgraph.svg",
        "ns": 6,
        "id": 1876,
        "revision": {
          "id": 3829,
          "timestamp": "2007-03-01T03:55:51Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 0,
            "#text": null
          },
          "sha1": "phoiac9h4m842xq45sp7s6u21eteeq1"
        }
      },
      {
        "title": "File:ServerOK.png",
        "ns": 6,
        "id": 1641,
        "revision": {
          "id": 2291,
          "timestamp": "2006-09-30T17:25:19Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "Interacting with Twelf through an Emacs buffer...",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 49,
            "#text": "Interacting with Twelf through an Emacs buffer..."
          },
          "sha1": "qixrmf7k0tu09gs4p441vdte3ho08nf"
        }
      },
      {
        "title": "File:Smalltree.svg",
        "ns": 6,
        "id": 1874,
        "revision": {
          "id": 3826,
          "parentid": 3823,
          "timestamp": "2007-03-01T03:42:20Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "leave note...",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 233,
            "#text": "Graphic of a tree with four leaves\n\nVery strange, when Illustrator CS1 created this file it left a bad piece of code:\n\n <flowDef  xmlns=\"&ns_flows;\">\n\nThat I had to manually make a good XML tag with \n\n <flowDef  xmlns=\"&ns_flows;\" />"
          },
          "sha1": "kbsv838aedrqiupcenmnsnowq2rnsol"
        }
      },
      {
        "title": "File:Sudokuexample.svg",
        "ns": 6,
        "id": 2004,
        "revision": {
          "id": 4864,
          "timestamp": "2007-10-02T21:26:56Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "comment": "From Wikipedia, public domain.",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 30,
            "#text": "From Wikipedia, public domain."
          },
          "sha1": "mpbpjgkw67ejh5qbpm19oth6d6fa0fi"
        }
      },
      {
        "title": "File:TWELFLIVE-1.png",
        "ns": 6,
        "id": 1840,
        "revision": {
          "id": 3546,
          "timestamp": "2007-01-28T05:32:45Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "Twelf Live, with text in the first edit window",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 46,
            "#text": "Twelf Live, with text in the first edit window"
          },
          "sha1": "asweuhhzi30dgoldisom3he7qofjfrx"
        }
      },
      {
        "title": "File:TWELFLIVE-2.png",
        "ns": 6,
        "id": 1841,
        "revision": {
          "id": 3547,
          "timestamp": "2007-01-28T05:33:35Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "Twelf Live, with checked input",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 30,
            "#text": "Twelf Live, with checked input"
          },
          "sha1": "cyzkjtwj02s8fpw1a3pry1876r47uq5"
        }
      },
      {
        "title": "File:TWELFLIVE-3.png",
        "ns": 6,
        "id": 1842,
        "revision": {
          "id": 3548,
          "timestamp": "2007-01-28T05:34:00Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "Twelf Live, with incremental checked input",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 42,
            "#text": "Twelf Live, with incremental checked input"
          },
          "sha1": "3uzbarvc86gxasc1mtstvp5eznbb4ay"
        }
      },
      {
        "title": "File:Test.svg",
        "ns": 6,
        "id": 1875,
        "revision": {
          "id": 3824,
          "timestamp": "2007-03-01T03:32:15Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 0,
            "#text": null
          },
          "sha1": "phoiac9h4m842xq45sp7s6u21eteeq1"
        }
      },
      {
        "title": "File:Tom Twelfelf2.jpg",
        "ns": 6,
        "id": 1783,
        "revision": {
          "id": 3233,
          "timestamp": "2006-10-28T07:54:52Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "Request by Tom...",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 17,
            "#text": "Request by Tom..."
          },
          "sha1": "8dszd8gjma3d7runsrvhhz0v6x04q67"
        }
      },
      {
        "title": "MediaWiki:Copyrightwarning",
        "ns": 8,
        "id": 156,
        "revision": {
          "id": 6083,
          "parentid": 2747,
          "timestamp": "2010-09-01T06:05:28Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "Turning off AJALF for now; it was in any case never made compatible with Literate Twelf, which is the more common style.",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 195,
            "#text": "By saving, you assert that you have the right and intention to license your submission to us under the $2 (see $1 for details).\n<strong>Do not submit copyrighted work without permission!</strong>"
          },
          "sha1": "ipg424o9043g99wtzu4d2be4fpnq2m7"
        }
      },
      {
        "title": "MediaWiki:Copyrightwarning2",
        "ns": 8,
        "id": 157,
        "revision": {
          "id": 2755,
          "parentid": 1687,
          "timestamp": "2006-10-13T17:32:04Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "comment": "don't know when this is used, but it might as well be the same",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 223,
            "#text": "By saving, you assert that you have the right and intention to license your submission to us under the $2 (see $1 for details).\n<strong>Do not submit copyrighted work without permission!</strong>\n\n<ajalf>unused</ajalf><br/>"
          },
          "sha1": "bcvxak60cx4wn1v95zxs5gqra3szeo3"
        }
      },
      {
        "title": "MediaWiki:Edittools",
        "ns": 8,
        "id": 232,
        "revision": {
          "id": 3186,
          "parentid": 3185,
          "timestamp": "2006-10-25T23:07:12Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "comment": "set ops",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 2332,
            "#text": "<!-- Text here will be shown below edit and upload forms. -->\n<!-- nb. the charinsert extension doesn't work, so these have to be copy and pasted manually. we should probably install charinsert. -->\n<div id=\"editpage-specialchars\" class=\"plainlinks\" style=\"margin-top: 15px; border-width: 1px; border-style: solid; border-color: #aaaaaa; padding: 2px;\">\n'''Logic:''' <charinsert>← → λ Π Σ α β γ Γ Δ η θ σ Ψ Ω ≡ ¬ ∧ ∨ ∩ ∪ ⊃ ⊂</charinsert>\n\n'''Workarounds:''' {<nowiki>{vdash}</nowiki>} {<nowiki>{dia}</nowiki>} {<nowiki>{box}</nowiki>} {<nowiki>{lolli}</nowiki>} {<nowiki>{otimes}</nowiki>} {<nowiki>{top}</nowiki>} {<nowiki>{darrow}</nowiki>} {<nowiki>{forall}</nowiki>} {<nowiki>{exists}</nowiki>} {<nowiki>{oplus}</nowiki>} {<nowiki>{bottom}</nowiki>}\n\n'''Symbols:'''  <charinsert>~ | ¡ ¿ † ‡ ↔ ↑ ↓ •</charinsert> &nbsp; <charinsert>– — … ° ≈ ± − × ÷ ← → · §</charinsert>  &nbsp;  <charinsert># ¹ ² ³ ½ ⅓ ⅔ ¼ ¾ ⅛ ⅜ ⅝ ⅞</charinsert>  &nbsp;  <charinsert>¢ $ € £ ¥</charinsert>\n\n'''Letters:''' <span class=\"latinx\"> Á á Ć ć É é Í í Ĺ ĺ Ń ń Ó ó Ŕ ŕ Ś ś Ú ú Ý ý Ź ź  &nbsp;  À à È è Ì ì Ò ò Ù ù  &nbsp;  Â â Ĉ ĉ Ê ê Ĝ ĝ Ĥ ĥ Î î Ĵ ĵ Ô ô Ŝ ŝ Û û Ŵ ŵ Ŷ ŷ  &nbsp;  Ä ä Ë ë Ï ï Ö ö Ü ü Ÿ ÿ  &nbsp;  ß  &nbsp;  Ã ã Ẽ ẽ Ĩ ĩ Ñ ñ Õ õ Ũ ũ Ỹ ỹ &nbsp;  Ç ç Ģ ģ Ķ ķ Ļ ļ Ņ ņ Ŗ ŗ Ş ş Ţ ţ  &nbsp;  Đ đ  &nbsp;  Ů ů  &nbsp;  Ǎ ǎ Č č Ď ď Ě ě Ǐ ǐ Ľ ľ Ň ň Ǒ ǒ Ř ř Š š Ť ť Ǔ ǔ Ž ž  &nbsp;  Ā ā Ē ē Ī ī Ō ō Ū ū  &nbsp;  ǖ ǘ ǚ ǜ  &nbsp;  Ă ă Ĕ ĕ Ğ ğ Ĭ ĭ Ŏ ŏ Ŭ ŭ  &nbsp;  Ċ ċ Ė ė Ġ ġ İ ı Ż ż  &nbsp;  Ł ł  &nbsp;  Ő ő Ű ű  &nbsp;  Ŀ ŀ  &nbsp;  Ħ ħ  &nbsp;  Ð ð Þ þ  &nbsp;  Œ œ  &nbsp;  Æ æ Ø ø Å å  &nbsp;  Ə ə </span>\n\n'''Greek:''' <charinsert>Α α Β β Γ γ Δ δ</charinsert> &nbsp; <charinsert>Ε ε Ζ ζ Η η Θ θ</charinsert>  &nbsp;  <charinsert>Ι ι Κ κ Λ λ Μ μ</charinsert>  &nbsp;  <charinsert>Ν ν Ξ ξ Ο ο Π π</charinsert>  &nbsp;  <charinsert>Ρ ρ Σ σ ς Τ τ Υ υ</charinsert>  &nbsp;  <charinsert>Φ φ Χ χ Ψ ψ Ω ω</charinsert>\n</div>\n\nOn '''talk pages''', please sign your comment by typing four tildes (<nowiki>~~~~</nowiki>)."
          },
          "sha1": "t5vljsbdg0npqiqc1v96xkwr9h7igz2"
        }
      },
      {
        "title": "MediaWiki:Fileinfo",
        "ns": 8,
        "id": 522,
        "revision": {
          "id": 2885,
          "parentid": 522,
          "timestamp": "2006-10-16T17:45:38Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "comment": "code is pre on this wiki, so this looks bizarre; switch to tt",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 28,
            "#text": "$1KB, MIME type: <tt>$2</tt>"
          },
          "sha1": "t5g6q518f3n2d3d32vr5gos3074290l"
        }
      },
      {
        "title": "MediaWiki:Loginreqpagetext",
        "ns": 8,
        "id": 683,
        "revision": {
          "id": 1618,
          "parentid": 683,
          "timestamp": "2006-09-06T17:14:37Z",
          "contributor": {
            "username": "TheTwelfElf",
            "id": 1
          },
          "comment": "fix confusing error message",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 388,
            "#text": "You are most likely seeing this message because you are trying to access a page starting with \"Elves:\". These pages are restricted to users that have the permission \"party-elf.\" \n\nIf you are not logged you may need to $1.\n\nIf you are logged in, let an [[Project:Administrators|administrator]], preferably one with \"Bureaucrat\" status, know that you need access to pages in this namespace."
          },
          "sha1": "kplx8pve808az1vpe4bdr0lchkdyg93"
        }
      },
      {
        "title": "MediaWiki:Monobook.css",
        "ns": 8,
        "id": 4,
        "revision": {
          "id": 5938,
          "parentid": 5937,
          "timestamp": "2009-03-14T00:01:27Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "model": "css",
          "format": "text/css",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 381,
            "#text": " /* edit this file to customize the monobook skin for the entire site */\n \n #p-logo a { background: url(/images/mediumelf.png) center center no-repeat !important; }\n #p-logo a:hover { background: url(/images/mediumelf.png) center center no-repeat !important; }\n body {background: #f9f9f9 url(/images/raster.gif) 0 0 repeat-x; }\n\n #n-Documentation {\n    margin: 0em 0em .5em 0em;\n }"
          },
          "sha1": "lii9fug6ayrargjobyil3kkg91zqhgh"
        }
      },
      {
        "title": "MediaWiki:Newwindow",
        "ns": 8,
        "id": 800,
        "revision": {
          "id": 2742,
          "parentid": 2740,
          "timestamp": "2006-10-13T15:42:12Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "comment": "don't work",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 21,
            "#text": "(opens in new window)"
          },
          "sha1": "dhrptaom9n066iw3qfzx8ry7wvxyy5o"
        }
      },
      {
        "title": "MediaWiki:Previewnote",
        "ns": 8,
        "id": 916,
        "revision": {
          "id": 2561,
          "parentid": 2560,
          "timestamp": "2006-10-10T19:23:19Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "comment": "no, I guess because it appears before the code",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 73,
            "#text": "<strong>This is only a preview; changes have not yet been saved!</strong>"
          },
          "sha1": "obe1k0i9crituzv7q4u7ohwvttmhikx"
        }
      },
      {
        "title": "MediaWiki:Privacy",
        "ns": 8,
        "id": 2020,
        "revision": {
          "id": 5903,
          "parentid": 5902,
          "timestamp": "2009-02-22T21:08:50Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 14,
            "#text": "Download Twelf"
          },
          "sha1": "dm8v0ta9cy5eqbo03dnc17toy4knkca"
        }
      },
      {
        "title": "MediaWiki:Privacypage",
        "ns": 8,
        "id": 2021,
        "revision": {
          "id": 4977,
          "timestamp": "2007-10-14T17:26:11Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "modify link",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 8,
            "#text": "Download"
          },
          "sha1": "j7nj3ah0tobongq932ehlbhmorv3k5k"
        }
      },
      {
        "title": "MediaWiki:Sidebar",
        "ns": 8,
        "id": 1090,
        "revision": {
          "id": 6044,
          "parentid": 5795,
          "timestamp": "2010-02-02T17:16:01Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 546,
            "#text": "* the twelf wiki\n** mainpage|mainpage\n** About The Twelf Project|The Twelf Project\n** Download|Download Twelf\n** Documentation|Documentation \n<!-- The space here is controlled by Mediawiki:Monobook.css -->\n** recentchanges-url|recentchanges\n** Project:Contributing|Contributing\n\n* learn twelf\n** Introductions to Twelf|Introductions\n** Tutorials|Tutorials\n** Case studies|Case studies\n** Glossary|Twelf glossary\n** Ask Twelf Elf|Ask Twelf Elf\n\n* reference\n** Bibliography of LF|LF bibliography\n** Research projects using Twelf|Research with Twelf"
          },
          "sha1": "et2nb7anphmv458z0a1todayxkffb0h"
        }
      },
      {
        "title": "MediaWiki talk:Sidebar",
        "ns": 9,
        "id": 1901,
        "revision": {
          "id": 4109,
          "timestamp": "2007-03-15T15:43:43Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "comment": "New page: Here's my attempt at rationalizing the organization of the sidebar: * Everything on the wiki should be reachable from the links in the top navigation section.  Right now, this amounts to s...",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 452,
            "#text": "Here's my attempt at rationalizing the organization of the sidebar:\n* Everything on the wiki should be reachable from the links in the top navigation section.  Right now, this amounts to saying that [[documentation]] indexes mostly everything.\n* the remaining space above the search box should be used for quick links to things we think people will go to often (right now, the main documentation sections).  \n[[User:Drl|Drl]] 11:43, 15 March 2007 (EDT)"
          },
          "sha1": "2x2myogzyrhx9rnbz1327ri590h1lsd"
        }
      },
      {
        "title": "Template:Bibtex:af04dependent",
        "ns": 10,
        "id": 1917,
        "revision": {
          "id": 4292,
          "timestamp": "2007-03-18T00:15:51Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "New page: <bibtex>@article{af04dependent,  author = \"Andrew W. Appel and Amy P. Felty\",  title = \"Dependent Types Ensure Partial Correctness of Theorem Provers\",  journal = \"Journal of Functional Pr...",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 370,
            "#text": "<bibtex>@article{af04dependent,\n author = \"Andrew W. Appel and Amy P. Felty\",\n title = \"Dependent Types Ensure Partial Correctness of Theorem Provers\",\n journal = \"Journal of Functional Programming\",\n volume = \"14\",\n number = \"1\",\n pages = \"3--19\",\n year = \"2004\",\n month = \"January\",\n note = \"Available from \\verb|http://www.cs.princeton.edu/~appel/papers/|\",\n</bibtex>"
          },
          "sha1": "ocv8kwje3xi23dhp7sbj17x9xx238nl"
        }
      },
      {
        "title": "Template:Bibtex:crary03talt",
        "ns": 10,
        "id": 1936,
        "revision": {
          "id": 4382,
          "parentid": 4381,
          "timestamp": "2007-03-20T06:51:39Z",
          "contributor": {
            "ip": "128.2.223.41"
          },
          "comment": "ack",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 218,
            "#text": "<bibtex>@InProceedings{crary03talt,\n  author = \"Karl Crary\",\n  title = \"Toward a Foundational Typed Assembly Language\",\n  booktitle = \"2003 Symposium on Principles of Programming Languages\",\n  year = \"2003\",\n}</bibtex>"
          },
          "sha1": "ncdh3wfkmt5lefqaksizzqkzd8ak8ar"
        }
      },
      {
        "title": "Template:Bibtex:fm97lax",
        "ns": 10,
        "id": 2183,
        "revision": {
          "id": 5882,
          "timestamp": "2009-02-21T22:02:47Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "New page: <bibtex>@article{264412,  author = {Matt Fairtlough and Michael Mendler},  title = {Propositional lax logic},  journal = {Inf. Comput.},  volume = {137},  number = {1},  year = {1997},  is...",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 353,
            "#text": "<bibtex>@article{264412,\n author = {Matt Fairtlough and Michael Mendler},\n title = {Propositional lax logic},\n journal = {Inf. Comput.},\n volume = {137},\n number = {1},\n year = {1997},\n issn = {0890-5401},\n pages = {1--33},\n doi = {http://dx.doi.org/10.1006/inco.1997.2627},\n publisher = {Academic Press, Inc.},\n address = {Duluth, MN, USA},\n }</bibtex>"
          },
          "sha1": "klmacv3mgxxryjopr64m9m63ebraoik"
        }
      },
      {
        "title": "Template:Bibtex:hhp93lf",
        "ns": 10,
        "id": 1937,
        "revision": {
          "id": 4384,
          "timestamp": "2007-03-20T07:02:16Z",
          "contributor": {
            "ip": "128.2.223.41"
          },
          "comment": "harperhonsellplotkin",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 364,
            "#text": "<bibtex>@article{hhp93lf,\n author = {Robert Harper and Furio Honsell and Gordon Plotkin},\n title = {A framework for defining logics},\n journal = {J. ACM},\n volume = {40},\n number = {1},\n year = {1993},\n issn = {0004-5411},\n pages = {143--184},\n doi = {http://doi.acm.org/10.1145/138027.138060},\n publisher = {ACM Press},\n address = {New York, NY, USA},\n }</bibtex>"
          },
          "sha1": "6afpkio5fgud2klrvunrusau8e506ah"
        }
      },
      {
        "title": "Template:Bibtex:hl07mechanizing",
        "ns": 10,
        "id": 1895,
        "revision": {
          "id": 4628,
          "parentid": 4060,
          "timestamp": "2007-03-22T01:38:34Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 326,
            "#text": "<bibtex>@Article{hl07mechanizing,\n  author =       {Robert Harper and Daniel R. Licata},\n  title =        {Mechanizing Metatheory in a Logical Framework},\n  journal =      {Journal of Functional Programming},\n  year =         {2007},\n  note =         {To appear. Available from \\verb|http://www.cs.cmu.edu/~drl/|},\n}\n</bibtex>"
          },
          "sha1": "netplrgoktm275jdirlu9kpezgzeb8x"
        }
      },
      {
        "title": "Template:Bibtex:lch07ml",
        "ns": 10,
        "id": 1900,
        "revision": {
          "id": 4097,
          "parentid": 4096,
          "timestamp": "2007-03-15T05:31:14Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "minor": null,
          "comment": "no linebreak symbol",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 274,
            "#text": "<bibtex>@inproceedings{ lee07ml,\n    author = \"Daniel K. Lee and Karl Crary and Robert Harper\",\n    title = \"Towards a mechanized metatheory of Standard ML\",\n    booktitle = \"ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages\",\n    year = \"2007\",\n}</bibtex>"
          },
          "sha1": "fnbqviukeakc7zwi7ydjrx4hkhdcm7v"
        }
      },
      {
        "title": "Template:Bibtex:pd01modal",
        "ns": 10,
        "id": 2184,
        "revision": {
          "id": 5884,
          "parentid": 5883,
          "timestamp": "2009-02-21T22:06:02Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 410,
            "#text": "<bibtex>@article{pd01modal,\n author = {Frank Pfenning and Rowan Davies},\n title = {A judgmental reconstruction of modal logic},\n journal = {Mathematical. Structures in Comp. Sci.},\n volume = {11},\n number = {4},\n year = {2001},\n issn = {0960-1295},\n pages = {511--540},\n doi = {http://dx.doi.org/10.1017/S0960129501003322},\n publisher = {Cambridge University Press},\n address = {New York, NY, USA},\n }</bibtex>"
          },
          "sha1": "3q8jclrrtj1igy533v5a1txfh3j11pt"
        }
      },
      {
        "title": "Template:Bibtex:pierce02tapl",
        "ns": 10,
        "id": 1908,
        "revision": {
          "id": 4213,
          "timestamp": "2007-03-16T14:58:20Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "New page: <bibtex>@book{pierce02tapl,   author = \t {Benjamin C. Pierce},   title = \t {Types and Programming Languages},   publisher =    {MIT Press},   month = \t {February},   isbn =         {978-0-...",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 231,
            "#text": "<bibtex>@book{pierce02tapl,\n  author = \t {Benjamin C. Pierce},\n  title = \t {Types and Programming Languages},\n  publisher =    {MIT Press},\n  month = \t {February},\n  isbn =         {978-0-262-16209-8},\n  year = \t {2002},\n}</bibtex>"
          },
          "sha1": "4tpe92p7dhwuuplp0pg962wmozk1ezt"
        }
      },
      {
        "title": "Template:Bottom",
        "ns": 10,
        "id": 1767,
        "revision": {
          "id": 3124,
          "timestamp": "2006-10-24T15:31:32Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "comment": "+bottom",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 227,
            "#text": "<font face=\"Lucida Sans Unicode\">⊥</font><noinclude>\n\nThis template renders the ''bottom'' (latex \\bot) symbol, with workarounds for Internet Explorer. Use it by typing <nowiki>{{bottom}}</nowiki> in an article.\n\n</noinclude>"
          },
          "sha1": "0ep1kzfupgds20dm9mnz3g1f0gzhggs"
        }
      },
      {
        "title": "Template:Box",
        "ns": 10,
        "id": 1529,
        "revision": {
          "id": 2067,
          "timestamp": "2006-09-28T13:41:21Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "comment": "modal box",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 234,
            "#text": "<font face=\"Lucida Sans Unicode\">□</font><noinclude>\n\nThis template renders the box (latex \\box) symbol from modal logic, with workarounds for Internet Explorer. Use it by typing <nowiki>{{box}}</nowiki> in an article.\n\n</noinclude>"
          },
          "sha1": "n9bs1qjjcdpyivee37w3bh8z4m512j3"
        }
      },
      {
        "title": "Template:Case study",
        "ns": 10,
        "id": 1939,
        "revision": {
          "id": 4388,
          "timestamp": "2007-03-20T07:23:39Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "new template",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 197,
            "#text": "<hr>\n<small>Read more Twelf [[case studies]] and other Twelf [[documentation]].</small>\n\n<includeonly><!-- template isn't in the category, only uses of it -->[[Category:Case studies]]</includeonly>"
          },
          "sha1": "lqpki6h6f2si2iks43u9glv6h5771sy"
        }
      },
      {
        "title": "Template:Click-inline",
        "ns": 10,
        "id": 1846,
        "revision": {
          "id": 3575,
          "parentid": 3574,
          "timestamp": "2007-02-01T11:21:28Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 847,
            "#text": "<includeonly><span style=\"position:relative; overflow:hidden; width:{{{width}}}; height:{{{height}}}; z-index:2;\">[[Image:{{{image}}}|{{{width}}}]]<span style=\"position:absolute; top:0; left:0; padding-top:3px; z-index:3;\">[[{{{link}}}|<span style=\"float:left; width:{{{width}}}; height:{{{height}}}; font-size:{{{height}}}; line-height:{{{height}}}; word-spacing:{{{width}}}; cursor:pointer;\">&nbsp; &nbsp;</span>]]</span></span></includeonly><noinclude>\nCopy of the wikipedia template for clicky images of the same name.\nUsage:\n <nowiki>{{</nowiki>click-inline\n   | image = some icon of size 20x30.png\n   | link = destination page link\n   | width = 20px\n   | height = 30px\n <nowiki>}}</nowiki>\n\nThis template doesn't work in all browsers; perhaps the [http://www.mediawiki.org/wiki/Extension:ImageMap imagemap] extension is better. \n</noinclude>"
          },
          "sha1": "i78rlh6aidgxkg2xwgf9tstlti3zcea"
        }
      },
      {
        "title": "Template:Darrow",
        "ns": 10,
        "id": 1763,
        "revision": {
          "id": 3120,
          "parentid": 3116,
          "timestamp": "2006-10-24T15:27:31Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "comment": "oops",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 242,
            "#text": "<font face=\"Lucida Sans Unicode\">⇒</font><noinclude>\n\nThis template renders the double right arrow (latex \\Rightarrow) symbol, with workarounds for Internet Explorer. Use it by typing <nowiki>{{darrow}}</nowiki> in an article.\n\n</noinclude>"
          },
          "sha1": "9ew1197ie2ijb3pmhff14kfctmr2rlz"
        }
      },
      {
        "title": "Template:Dia",
        "ns": 10,
        "id": 1528,
        "revision": {
          "id": 2066,
          "timestamp": "2006-09-28T13:40:02Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 238,
            "#text": "<font face=\"Lucida Sans Unicode\">⋄</font><noinclude>\n\nThis template renders the diamond (latex \\dia) symbol from modal logic, with workarounds for Internet Explorer. Use it by typing <nowiki>{{dia}}</nowiki> in an article.\n\n</noinclude>"
          },
          "sha1": "do6n1kl2flgwbdpjylxl97eas5ozqhp"
        }
      },
      {
        "title": "Template:Discuss",
        "ns": 10,
        "id": 1663,
        "revision": {
          "id": 2363,
          "timestamp": "2006-10-04T22:21:44Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "comment": "discuss template",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 583,
            "#text": "[[Talk:{{PAGENAME}}#{{{1}}}|<sup>[?]</sup>]]<noinclude>\n\n\nThis template places a discussion link in an article. The link takes the user to a supplied section on the talk page for the same article. (It does not work for pages outside the article namespace). To use it, write:\n\n:<nowiki>{{discuss|</nowiki>''description of issue''<nowiki>}}</nowiki>\n\nwhere ''description of issue'' is an informative section header for the talk page. You should then create that section on the talk page. The link looks like this.[[Talk:Main Page#Test of discuss template|<sup>[?]</sup>]]\n\n</noinclude>"
          },
          "sha1": "pwnarj9y4e128gbvrlb2dsjhs6pmc38"
        }
      },
      {
        "title": "Template:Draft",
        "ns": 10,
        "id": 1659,
        "revision": {
          "id": 2346,
          "parentid": 2344,
          "timestamp": "2006-10-04T20:15:37Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "minor": null,
          "comment": "try this",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 558,
            "#text": "<div style=\"float:right;border:solid #EEBBBB 1px;margin:1px;\">\n{| cellspacing=\"0\" style=\"background:#FFE7E7;\"\n| style=\"font-weight:bold;font-size:24pt;padding:6pt;line-height:1.25em;margin:12pt;\" | Draft of {{<includeonly>subst:</includeonly>CURRENTDAY}} {{<includeonly>subst:</includeonly>CURRENTMONTHNAME}} {{<includeonly>subst:</includeonly>CURRENTYEAR}}.\n|}\n</div><noinclude>\n\n\nThis template marks a page as a draft. To use it, write <nowiki>{{draft}}</nowiki> at the top of an article. That produces the box (with date) shown at the right.\n\n</noinclude>"
          },
          "sha1": "6sp18e37ovc3mjsg6s2xrt576ix04oe"
        }
      },
      {
        "title": "Template:Exists",
        "ns": 10,
        "id": 1765,
        "revision": {
          "id": 3122,
          "timestamp": "2006-10-24T15:28:49Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "comment": "+exists",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 236,
            "#text": "<font face=\"Lucida Sans Unicode\">∃</font><noinclude>\n\nThis template renders the ''there exists'' (latex \\exists) symbol, with workarounds for Internet Explorer. Use it by typing <nowiki>{{exists}}</nowiki> in an article.\n\n</noinclude>"
          },
          "sha1": "44i1ig3rt37qk9v3y32dtifd5xkhslt"
        }
      },
      {
        "title": "Template:Forall",
        "ns": 10,
        "id": 1764,
        "revision": {
          "id": 3121,
          "parentid": 3119,
          "timestamp": "2006-10-24T15:27:52Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "comment": "text",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 231,
            "#text": "<font face=\"Lucida Sans Unicode\">∀</font><noinclude>\n\nThis template renders the ''for all'' (latex \\forall) symbol, with workarounds for Internet Explorer. Use it by typing <nowiki>{{forall}}</nowiki> in an article.\n\n</noinclude>"
          },
          "sha1": "oon4uzsz7gb91wmndv0p6akto5b5paz"
        }
      },
      {
        "title": "Template:Front-Blog Updates",
        "ns": 10,
        "id": 1705,
        "redirect": {
          "@title": "What's new",
          "#text": null
        },
        "revision": {
          "id": 2765,
          "timestamp": "2006-10-13T21:22:56Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "[[Template:Front-Blog Updates]] moved to [[What's new]]: Better name! The template can live with a redirect.",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 24,
            "#text": "#REDIRECT [[What's new]]"
          },
          "sha1": "4v9q7h8zxxc9twc7rqflnwpx9haavxu"
        }
      },
      {
        "title": "Template:Front-Getting Started",
        "ns": 10,
        "id": 1381,
        "revision": {
          "id": 2670,
          "parentid": 2087,
          "timestamp": "2006-10-12T04:44:56Z",
          "contributor": {
            "username": "DanielKLee",
            "id": 5
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 215,
            "#text": "[[Try Twelf now]] from your browser! No installation necessary.\n\nTwelf runs on Windows and varieties of Unix, including Linux and Mac OS X.\n\nThe [[software]] page has downloads, as well as installation instructions."
          },
          "sha1": "fodi599rm5eb1z5ua6xyvkdp0gbmg1l"
        }
      },
      {
        "title": "Template:Front-Release History",
        "ns": 10,
        "id": 1382,
        "revision": {
          "id": 1461,
          "parentid": 1412,
          "timestamp": "2006-09-03T00:56:50Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 715,
            "#text": "* '''March 1, 2005''' - Twelf 1.5R1 is now available\n:*twelf-1-5R1.tar.gz (source distribution only)\n:*Significantly improved tabling over Twelf 1.5\n:*The documentation is not yet updated\n:*Re-packaged on March 8 in a form suitable for SML/NJ 110.0.07, SML/NJ 110.53, Poly/ML 4.1.3 and MLton 20040227\n* '''December 3, 2004''' We have made a working version of Twelf 1.5 available. It fixes a significant bug in the totality checker of Twelf 1.4 which let some false meta-theorems pass.\n:*twelf-1-5.tar.gz (source distribution only)\n:*This is a source distribution only\n:*It contains several undocumented features, among them some uniqueness checking and improved tabling.\n\n[[Release history | Full Release History]]"
          },
          "sha1": "qk6x0ko0zox2rjrhcdjomr3dkes9lzx"
        }
      },
      {
        "title": "Template:Front-What's new",
        "ns": 10,
        "id": 1383,
        "revision": {
          "id": 1408,
          "parentid": 1398,
          "timestamp": "2006-09-02T03:26:09Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "minor": null,
          "comment": "[[Template:The Twelf Project/What's new]] moved to [[Template:Front-What's new]]: renaming conventions",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 208,
            "#text": "* '''August 31, 2006''' - The ConCert group at CMU met to discuss summer projects and to brainstorm ideas for improving communication and information dissemination, including in the context of the Twelf Wiki."
          },
          "sha1": "88flo951fhj411l94gadcgthy8h5ueu"
        }
      },
      {
        "title": "Template:Guide",
        "ns": 10,
        "id": 1510,
        "revision": {
          "id": 1987,
          "timestamp": "2006-09-27T19:50:07Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "comment": "useful for linking to Twelf guide",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 650,
            "#text": "[http://www.cs.cmu.edu/~twelf/guide-1-4/twelf_{{{chapter}}}.html#SEC{{{section}}} {{{title}}}] in the [[User's Guide]]<noinclude>\n\n----\n\n'''Documentation:''' This template http-links to the Twelf [[User's Guide]]. It takes three parameters, the <tt>chapter</tt> number, <tt>section</tt> number, and the <tt>title</tt> to use. For example:\n\n::<nowiki>{{guide|chapter=8|sec=47|title=Reduction declaration}}</nowiki>\n\nyields\n\n::[http://www.cs.cmu.edu/~twelf/guide-1-4/twelf_8.html#SEC47 Reduction declaration] in the [[User's Guide]]\n\nWe should use this to link to sections in the guide, since the URL may change when the guide is updated.\n\n</noinclude>"
          },
          "sha1": "6b142agdgf95saxp99x8fp8lndbtc9m"
        }
      },
      {
        "title": "Template:Keyword",
        "ns": 10,
        "id": 1803,
        "revision": {
          "id": 5185,
          "parentid": 4499,
          "timestamp": "2008-07-12T20:35:10Z",
          "contributor": {
            "username": "Geoffw",
            "id": 33
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 1226,
            "#text": "<center><div style=\"width:50em; border-width: 1px; border-style: solid; border-color:#AAFFFF; background:#EEFFFF\">\n<b>[[:Category:keywords|Twelf keywords]]</b><br/><hr style=\"height:1px; color:#AAFFFF; background-color:#AAFFFF\" />\n<tt>[[%.]]\n[[abbrev declaration|%abbrev]]\n[[%assert]]\n[[%block]]\n[[%clause]]\n[[%covers]]\n[[define declaration|%define]]\n[[deterministic declaration|%deterministic]]\n[[%establish]]\n[[%freeze]]\n[[fixity declaration|%infix]]\n[[fixity declaration|%prefix]]\n[[fixity declaration|%postfix]]\n[[%mode]]\n[[%name]]\n[[%prove]]\n[[%query]]\n[[%querytabled]]\n[[%reduces]]\n[[%solve]]\n[[%subord]]\n[[%tabled]]\n[[%terminates]]\n[[%thaw]]\n[[%theorem]]\n[[%total]]\n[[%trustme]]\n[[%unique]]\n[[%use]]\n[[%worlds]]</tt>\n</div></center>\n<noinclude>\nThis template is intended for the bottom of articles about Twelf keywords, as an index. It also includes the article in the [[:category:keywords|keywords category]]. Use it as <nowiki>{{keyword|key=name}}</nowiki>, where ''name'' is the name by which the keyword should be sorted.\n\nThe file <tt>twelf/src/frontend/lexer.fun</tt> in the Twelf sources contains the full list.\n</noinclude>\n<includeonly>\n{{{nocat|[[Category:keywords|{{{key|{{{PAGENAME}}}}}}]]}}}\n</includeonly>"
          },
          "sha1": "j7t3rshofa4skp35d6tfxn562kquarp"
        }
      },
      {
        "title": "Template:License-by-nc",
        "ns": 10,
        "id": 1425,
        "revision": {
          "id": 1526,
          "parentid": 1517,
          "timestamp": "2006-09-05T19:49:47Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "shorten-link",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 536,
            "#text": "{| style=\"width:100%; margin-bottom:5px; border: 1px solid; background-color: #FF9999; text-align:center; font-size:0.9em;\"\n|-\n| style=\"width:100%; text-align:center; font-size:1.1em;\" | '''The content on this page is released under the [[Project:BY-NC | Creative Commons Attribution-Noncommercial License]]'''\n|-\n| style=\"width:100%; text-align:center; font-size:0.9em;\" | If you edit this page, your edits are covered by the same license. '''This tag must not be removed!''' See the [[Project:Copyright]] page for more information.\n|}"
          },
          "sha1": "61gzdh6pd72b78grycv74x2adl4pm01"
        }
      },
      {
        "title": "Template:License-by-sa",
        "ns": 10,
        "id": 1433,
        "revision": {
          "id": 1537,
          "timestamp": "2006-09-05T20:00:42Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 533,
            "#text": "{| style=\"width:100%; margin-bottom:5px; border: 1px solid; background-color: #FF9999; text-align:center; font-size:0.9em;\"\n|-\n| style=\"width:100%; text-align:center; font-size:1.1em;\" | '''The content on this page is released under the [[Project:BY-SA | Creative Commons Attribution-ShareAlike License]]'''\n|-\n| style=\"width:100%; text-align:center; font-size:0.9em;\" | If you edit this page, your edits are covered by the same license. '''This tag must not be removed!''' See the [[Project:Copyright]] page for more information.\n|}"
          },
          "sha1": "dtznn272b25htsfp9xr4eyuda7ujt89"
        }
      },
      {
        "title": "Template:License-gfdl",
        "ns": 10,
        "id": 1434,
        "revision": {
          "id": 1540,
          "parentid": 1539,
          "timestamp": "2006-09-05T20:02:12Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 516,
            "#text": "{| style=\"width:100%; margin-bottom:5px; border: 1px solid; background-color: #FF9999; text-align:center; font-size:0.9em;\"\n|-\n| style=\"width:100%; text-align:center; font-size:1.1em;\" | ''' The content of this page is released under the [[Project:GFDL | GNU Free Documentation License]]'''\n|-\n| style=\"width:100%; text-align:center; font-size:0.9em;\" | If you edit this page, your edits are covered by the same license. '''This tag must not be removed!''' See the [[Project:Copyright]] page for more information.\n|}"
          },
          "sha1": "356y8u34lg4ls8b3pjf5lihs7v8tmcx"
        }
      },
      {
        "title": "Template:License-gpl",
        "ns": 10,
        "id": 1423,
        "revision": {
          "id": 1538,
          "parentid": 1518,
          "timestamp": "2006-09-05T20:01:09Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 509,
            "#text": "{| style=\"width:100%; margin-bottom:5px; border: 1px solid; background-color: #FF9999; text-align:center; font-size:0.9em;\"\n|-\n| style=\"width:100%; text-align:center; font-size:1.1em;\" | ''' The content of this page is released under the [[Project:GPL|GNU General Public License]]'''\n|-\n| style=\"width:100%; text-align:center; font-size:0.9em;\" | If you edit this page, your edits are covered by the same license. '''This tag must not be removed!''' See the [[Project:Copyright]] page for more information.\n|}"
          },
          "sha1": "olcq8t0g9oox9s8ykz30t2rwkz6zpwz"
        }
      },
      {
        "title": "Template:Literatetwelf",
        "ns": 10,
        "id": 1857,
        "revision": {
          "id": 5489,
          "parentid": 5488,
          "timestamp": "2008-11-19T20:26:25Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 692,
            "#text": "<div id=\"literate\" style=\"float:right;border:solid #BBBBEE 1px;margin:1em;\">\n{| cellspacing=\"0\" style=\"background:#E7E7FF;\"\n| style=\"font-size:8pt;padding:4pt;line-height:1.25em;\" | This is [[Project:Literate Twelf|Literate Twelf]]<hr /><small>Code: [{{SERVER}}{{SCRIPTPATH}}/index.php?title={{FULLPAGENAMEE}}&action=raw&ctype=text/css here]<br/>Status: {{{status}}}<br />Output: [{{SERVER}}{{{output}}} here].</small>\n|}\n</div><includeonly>[[Category:Twelf code]][[Category:Literate Twelf code]]</includeonly>\n<noinclude>This template should only be used by the [[Project:Literate Twelf|Literate Twelf]] extension as a header for pages created by the Literate Twelf pre-processor</noinclude>"
          },
          "sha1": "moomvd91fbtx8ghfplnfqlk8ukv8q6v"
        }
      },
      {
        "title": "Template:Lolli",
        "ns": 10,
        "id": 1530,
        "revision": {
          "id": 2069,
          "parentid": 2068,
          "timestamp": "2006-09-28T13:44:02Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "minor": null,
          "comment": "[[Template:Multimap]] moved to [[Template:Lolli]]: alias",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 277,
            "#text": "<font face=\"Lucida Sans Unicode\">⊸</font><noinclude>\n\nThis template renders the lolli (latex \\multimap) symbol from linear logic, with workarounds for Internet Explorer. Use it by typing <nowiki>{{lolli}}</nowiki> or <nowiki>{{multimap}}</nowiki> in an article.\n\n</noinclude>"
          },
          "sha1": "ir8s8by6iyasgt9589w7vchegxovg99"
        }
      },
      {
        "title": "Template:Multimap",
        "ns": 10,
        "id": 1531,
        "redirect": {
          "@title": "Template:Lolli",
          "#text": null
        },
        "revision": {
          "id": 2070,
          "timestamp": "2006-09-28T13:44:02Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "comment": "[[Template:Multimap]] moved to [[Template:Lolli]]: alias",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 28,
            "#text": "#REDIRECT [[Template:Lolli]]"
          },
          "sha1": "llxbjt5ia4lp66uuyq1fc6466wmn0my"
        }
      },
      {
        "title": "Template:Needs",
        "ns": 10,
        "id": 1454,
        "revision": {
          "id": 2343,
          "parentid": 1672,
          "timestamp": "2006-10-04T20:06:20Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "comment": "help message",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 815,
            "#text": "<div style=\"float:left;border:solid #EEBBBB 1px;margin:1px;\">\n{| cellspacing=\"0\" style=\"background:#FFE7E7;\"\n| style=\"font-size:8pt;padding:4pt;line-height:1.25em;\" | This article or section needs {{{1}}}.\n|}\n</div><br clear=\"all\" /><includeonly>[[Category:Pages needing attention]]</includeonly><noinclude>\n\n\nThis template allows in-line todo items on pages, with a message. To use it, write:\n\n:<nowiki>{{needs|je ne sais quoi}}</nowiki>\n\nWhich produces:\n\n<div style=\"float:left;border:solid #EEBBBB 1px;margin:1px;\">\n{| cellspacing=\"0\" style=\"background:#FFE7E7;\"\n| style=\"font-size:8pt;padding:4pt;line-height:1.25em;\" | This article or section needs je ne sais quoi.\n|}\n</div><br clear=\"all\" />\n\nIt also lists the page in the [[:Category:pages needing attention|pages needing attention]] category.\n\n</noinclude>"
          },
          "sha1": "q4m9ua3v6d3wlj4gcjgx1k4luaky0k0"
        }
      },
      {
        "title": "Template:Needswork",
        "ns": 10,
        "id": 1419,
        "revision": {
          "id": 1584,
          "parentid": 1582,
          "timestamp": "2006-09-06T14:11:28Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 257,
            "#text": "{| style=\"width:100%; margin-bottom:5px; border: 1px solid; background-color: #f2dfce; text-align:center; font-size:0.9em;\"\n|-\n| style=\"align:center;\" |This page needs some work: ''{{{1}}}''\n|}\n<includeonly>[[Category:Pages needing attention]]</includeonly>"
          },
          "sha1": "pnl0jpj2lqo281gp9nc745ypvxheq8g"
        }
      },
      {
        "title": "Template:Oplus",
        "ns": 10,
        "id": 1766,
        "revision": {
          "id": 3123,
          "timestamp": "2006-10-24T15:30:08Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 231,
            "#text": "<font face=\"Lucida Sans Unicode\">⊕</font><noinclude>\n\nThis template renders the ''linear or'' (latex \\oplus) symbol, with workarounds for Internet Explorer. Use it by typing <nowiki>{{oplus}}</nowiki> in an article.\n\n</noinclude>"
          },
          "sha1": "cnoh7azv6lopodvpl1i4etx1d5ipmcg"
        }
      },
      {
        "title": "Template:Otimes",
        "ns": 10,
        "id": 1527,
        "revision": {
          "id": 2065,
          "timestamp": "2006-09-28T13:38:50Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "comment": "otimes",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 226,
            "#text": "<font face=\"Lucida Sans Unicode\">⊗</font><noinclude>\n\nThis template renders the tensor (latex \\otimes) symbol, with workarounds for Internet Explorer. Use it by typing <nowiki>{{otimes}}</nowiki> in an article.\n\n</noinclude>"
          },
          "sha1": "em055mcnwk7ejjo2z9embgzyyztdiyc"
        }
      },
      {
        "title": "Template:Proving",
        "ns": 10,
        "id": 1898,
        "revision": {
          "id": 4072,
          "parentid": 4071,
          "timestamp": "2007-03-15T02:34:33Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "try again",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 412,
            "#text": "[[Proving metatheorems:{{{title}}}|{{{title}}}]] in the tutorial [[Proving metatheorems with Twelf]]<noinclude>\n\n----\n\n'''Documentation:''' This template wiki-links to the [[User:Drl]]'s tutorial [[Proving metatheorems with Twelf]]. As an example,:\n\n::<nowiki>{{proving|title=Full LF}}</nowiki>\n\nyields\n\n::[[Proving metatheorems:Full LF|Full LF]] in the tutorial [[Proving metatheorems with Twelf]]\n\n</noinclude>"
          },
          "sha1": "gg4ac277gl1n78jkagio5qrzrsp7m9n"
        }
      },
      {
        "title": "Template:Proving metatheorems",
        "ns": 10,
        "id": 1784,
        "revision": {
          "id": 3597,
          "parentid": 3596,
          "timestamp": "2007-02-17T19:49:56Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 843,
            "#text": "{| style=\"width:100%; margin-bottom:5px; border: 1px solid #ADA; background-color: #E4F2E4; text-align:center; font-size:0.9em;\"\n|-\n| style=\"width:35%; text-align:left; font-size:0.9em;\" | {{{noprevious|Previous:<br />[[Proving metatheorems:{{{prev}}}|{{{prevname}}}]]}}}\n| style=\"width:30%;\" | <big>'''[[Proving metatheorems with Twelf]]''' </big>\n| style=\"width:35%; text-align:right;font-size:0.9em;\" | {{{nonext|Next:<br />[[Proving metatheorems:{{{next}}}|{{{nextname}}}]]}}}\n|}\n<br />__NOTOC__<noinclude>\n\nThis template is for use in the [[Proving metatheorems with Twelf]] multi-page article. It should be given arguments prev (a wiki page) and prevname (the short name to use in the link), as well as arguments next and nextname. If the arguments noprevious or nonext are specified, then these links will not show at all.\n\n</noinclude>"
          },
          "sha1": "s2avgogqtb0cbhe50sptg68zq38irzr"
        }
      },
      {
        "title": "Template:Repository",
        "ns": 10,
        "id": 1524,
        "revision": {
          "id": 2048,
          "timestamp": "2006-09-28T02:56:43Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "create repository link",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 58,
            "#text": "[https://cvs.concert.cs.cmu.edu/twelf-lib/{{{1}}} {{{2}}}]"
          },
          "sha1": "8ycnajq2cgw4jwqeuu76jxf3at5dpvp"
        }
      },
      {
        "title": "Template:Rule",
        "ns": 10,
        "id": 1768,
        "revision": {
          "id": 3131,
          "parentid": 3129,
          "timestamp": "2006-10-24T17:30:13Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "comment": "doesn't work",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 493,
            "#text": "<strong>This template does not work because template arguments are not expanded inside the <nowiki><math></nowiki> tag in the current MediaWiki. Any workarounds?</strong>\n\n\n<math>{ { {{{1}}} }\\over{ {{{2}}}  } }{\\quad \\rm {{{3}}} }</math><noinclude>\n\n<s>Render an inference rule. Use: {<nowiki>{</nowiki>rule|premise1 \\qquad premise2 ...|conclusion|name<nowiki>}</nowiki>}.\n\nIt produces:\n\n<math>{{premise1 \\qquad premise2 \\qquad ...}\\over{conclusion}}{\\quad \\rm name}</math>\n</s>\n\n</noinclude>"
          },
          "sha1": "bapmwoxl630najdseubnwtti37wup29"
        }
      },
      {
        "title": "Template:Stub",
        "ns": 10,
        "id": 1443,
        "revision": {
          "id": 1968,
          "parentid": 1574,
          "timestamp": "2006-09-26T20:05:47Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "comment": "length is not really what we want, it is completeness",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 146,
            "#text": "<hr><small>This page is incomplete. We should expand it.</small>\n<includeonly>[[Category:Stubs]][[Category:Pages needing attention]]</includeonly>"
          },
          "sha1": "irrsvj1tloisa7gk8zux9mkbiu2olwm"
        }
      },
      {
        "title": "Template:Stub tutorial",
        "ns": 10,
        "id": 1402,
        "revision": {
          "id": 1575,
          "parentid": 1451,
          "timestamp": "2006-09-06T13:58:39Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 432,
            "#text": "<hr><small>This is a tutorial that has been identified as needing to be extended, expanded, and or improved, and which does not yet a contain a full explanation of what it is meant to address. We're getting to it, leave a message for us on the discussion page or elsewhere if you need this information and we'll probably get to it faster.</small>\n<includeonly>[[Category:Stubs]][[Category:Tutorials needing attention]]</includeonly>"
          },
          "sha1": "s1iroke7q0ciqggsn0uyavn49bdnymz"
        }
      },
      {
        "title": "Template:Summer school 2008",
        "ns": 10,
        "id": 2058,
        "revision": {
          "id": 5229,
          "parentid": 5210,
          "timestamp": "2008-07-19T01:00:27Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 749,
            "#text": "{| style=\"width:40%; margin-bottom:5px; border: 1px solid #ADA; background-color: #E4F2E4; text-align:left; font-size:0.9em;\"\n|<big>'''[[Summer school 2008]]''' </big> \n|-\n|style=\"text-align:left; font-size:0.9em;\" |{{{noprevious|Previous: [[Summer school 2008:{{{prev}}}|{{{prevname}}}]]}}}\n|-\n|style=\"text-align:left;font-size:0.9em;\" |{{{nonext|Next: [[Summer school 2008:{{{next}}}|{{{nextname}}}]]}}}\n|}\n<br />__NOTOC__<noinclude>\n\nThis template is for use in the [[Summer school 2008]] course notes. It should be given arguments prev (a wiki page) and prevname (the short name to use in the link), as well as arguments next and nextname. If the arguments noprevious or nonext are specified, then these links will not show at all.\n\n</noinclude>"
          },
          "sha1": "an5fimhwtbnsancimnhrngxvorsvjx3"
        }
      },
      {
        "title": "Template:The Twelf Project/Blog Updates",
        "ns": 10,
        "id": 1386,
        "redirect": {
          "@title": "What's new",
          "#text": null
        },
        "revision": {
          "id": 2819,
          "parentid": 1407,
          "timestamp": "2006-10-14T05:24:19Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "Redirecting to [[What's new]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 24,
            "#text": "#REDIRECT [[What's new]]"
          },
          "sha1": "4v9q7h8zxxc9twc7rqflnwpx9haavxu"
        }
      },
      {
        "title": "Template:The Twelf Project/Getting Started",
        "ns": 10,
        "id": 1533,
        "revision": {
          "id": 4280,
          "parentid": 4273,
          "timestamp": "2007-03-17T21:42:16Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "comment": "new phrase",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 445,
            "#text": "[[Download]] Twelf or [[Twelf Live|try it online]].\n\nLearn Twelf:\n* Read the [[introductions to Twelf]] first.\n* The [[tutorials]] explain common Twelf tricks and techniques.\n* The [[case studies]] present interesting applications of Twelf.\n* The [[glossary]] defines Twelf terminology.\n* Have a question? [[Ask Twelf Elf]]!\n<!-- style guide will go here eventually, but it's not ready yet -->\n\nSee the [[documentation]] page for more resources."
          },
          "sha1": "irpn06oee16lvoq8ssmk3ivwc1poaii"
        }
      },
      {
        "title": "Template:The Twelf Project/Introduction",
        "ns": 10,
        "id": 1446,
        "revision": {
          "id": 4612,
          "parentid": 4408,
          "timestamp": "2007-03-21T15:16:25Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "comment": "We prefer languages to tools",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 572,
            "#text": "[[About The Twelf Project|Twelf]] is a language used to specify, implement, and prove properties of ''deductive systems'' such as programming languages and logics.  Large [[research projects using Twelf]] include the TALT typed assembly language, a foundational proof-carrying-code system, and a type safety proof for Standard ML.  \n\nVisitors without a technical background are encouraged to read the [[general description of Twelf]].\n\n<!-- (I need improvement! [http://twelf.plparty.org/w/index.php?title=Template:The_Twelf_Project/Introduction&action=edit edit me]!) -->"
          },
          "sha1": "idodolt1zxgjtvszbme5csud0tvodkn"
        }
      },
      {
        "title": "Template:The Twelf Project/Learning Twelf",
        "ns": 10,
        "id": 1844,
        "redirect": {
          "@title": "Template:The Twelf Project/Getting Started",
          "#text": null
        },
        "revision": {
          "id": 3557,
          "timestamp": "2007-01-31T10:30:10Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "comment": "[[Template:The Twelf Project/Learning Twelf]] moved to [[Template:The Twelf Project/Getting Started]]: merging mainpage info",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 56,
            "#text": "#REDIRECT [[Template:The Twelf Project/Getting Started]]"
          },
          "sha1": "t4heyx8lkcsdjcncn4k0ao96f8yowtm"
        }
      },
      {
        "title": "Template:The Twelf Project/Release History",
        "ns": 10,
        "id": 1389,
        "redirect": {
          "@title": "Template:Front-Release History",
          "#text": null
        },
        "revision": {
          "id": 1413,
          "timestamp": "2006-09-02T03:26:42Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "[[Template:The Twelf Project/Release History]] moved to [[Template:Front-Release History]]: Renaming convention",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 44,
            "#text": "#REDIRECT [[Template:Front-Release History]]"
          },
          "sha1": "4029sqob2c81zf94wzm7vq9l5h587tn"
        }
      },
      {
        "title": "Template:The Twelf Project/What's new",
        "ns": 10,
        "id": 1387,
        "redirect": {
          "@title": "Template:Front-What's new",
          "#text": null
        },
        "revision": {
          "id": 1409,
          "timestamp": "2006-09-02T03:26:09Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "[[Template:The Twelf Project/What's new]] moved to [[Template:Front-What's new]]: renaming conventions",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 39,
            "#text": "#REDIRECT [[Template:Front-What's new]]"
          },
          "sha1": "pcvns68iqgmv6848egrweqqcupyxpbl"
        }
      },
      {
        "title": "Template:Tl",
        "ns": 10,
        "id": 1509,
        "revision": {
          "id": 1986,
          "timestamp": "2006-09-27T19:25:18Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "comment": "useful, from wikipedia",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 332,
            "#text": "<nowiki>{{</nowiki>[[Template:{{{1}}}|{{{1}}}]]<nowiki>}}</nowiki><noinclude>\n\nThis template can be used for linking to other templates in expository text. For instance, to link to [[Template:vdash]], write <nowiki>{{tl|vdash}}</nowiki>, which renders as <nowiki>{{</nowiki>[[Template:vdash|vdash]]<nowiki>}}</nowiki>.\n\n</noinclude>"
          },
          "sha1": "ev11xli0d50aw9nla7zxihy8rfof3sl"
        }
      },
      {
        "title": "Template:Top",
        "ns": 10,
        "id": 1662,
        "revision": {
          "id": 2360,
          "timestamp": "2006-10-04T22:02:17Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "comment": "add workaround for top",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 216,
            "#text": "<font face=\"Lucida Sans Unicode\">⊤</font><noinclude>\n\nThis template renders the top (or 'true') symbol, with workarounds for Internet Explorer. Use it by typing <nowiki>{{top}}</nowiki> in an article.\n\n</noinclude>"
          },
          "sha1": "0ia6k5ylwe9x0f9jd83vk2g82y9e0nm"
        }
      },
      {
        "title": "Template:Tutorial",
        "ns": 10,
        "id": 1409,
        "revision": {
          "id": 4138,
          "parentid": 4135,
          "timestamp": "2007-03-15T18:35:44Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "comment": "the old tag didn't really fit with the current scope of the tutorials; it's tighter to just give the links, which are the main point of this tag",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 191,
            "#text": "<hr>\n<small>Read more Twelf [[tutorial]]s and other Twelf [[documentation]].</small>\n\n<includeonly><!-- template isn't in the category, only uses of it -->[[Category:Tutorials]]</includeonly>"
          },
          "sha1": "3xo2o1lzsbj6xims00vnt3o3901ndu3"
        }
      },
      {
        "title": "Template:Twelf code",
        "ns": 10,
        "id": 1447,
        "revision": {
          "id": 1663,
          "parentid": 1612,
          "timestamp": "2006-09-07T16:42:43Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "comment": "last lcase",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 237,
            "#text": "<hr><small>The above page contains an example of [[:Category:Twelf code|Twelf code]]. It may be attached to a [[tutorial]] as an illustrative example, or it may stand on its own.</small>\n<includeonly>[[Category:Twelf code]]</includeonly>"
          },
          "sha1": "54ew7xb1chixrd62rg94a29vslhjtle"
        }
      },
      {
        "title": "Template:Undocumented",
        "ns": 10,
        "id": 1805,
        "revision": {
          "id": 4269,
          "parentid": 4268,
          "timestamp": "2007-03-17T15:23:03Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 688,
            "#text": "<div style=\"float:right;border:solid #BBBBEE 1px;margin:1em;\">\n{| cellspacing=\"0\" style=\"background:#E7E7FF;\"\n| style=\"font-size:8pt;padding:4pt;line-height:1.25em;\" | This {{{1|article or section}}} describes an [[:category:undocumented features|undocumented feature]] of Twelf.<br/>The information may be incomplete and subject to change.\n|}\n</div><includeonly>[[Category:Undocumented features]]</includeonly><noinclude><br clear=\"all\" />\n\nThis template also lists the page in the [[:Category:undocumented features|undocumented features]] category. Use with an optional argument to change the text \"article or section\" (''e.g.'' <nowiki>{{undocumented|article}}</nowiki>).\n\n</noinclude>"
          },
          "sha1": "mq245mwzvkb0lpajjgee8wbdfdvmtcr"
        }
      },
      {
        "title": "Template:Vdash",
        "ns": 10,
        "id": 1504,
        "revision": {
          "id": 2064,
          "parentid": 1985,
          "timestamp": "2006-09-28T13:29:25Z",
          "contributor": {
            "ip": "66.167.250.10"
          },
          "comment": "lucida sans unicode seems to work better.",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 332,
            "#text": "<font face=\"Lucida Sans Unicode\">⊦</font><noinclude>\n\nThis template renders the turnstile (latex \\vdash) symbol, with workarounds for Internet Explorer. Use it by typing <nowiki>{{vdash}}</nowiki> in an article.\n\n{{needs|more testing on versions of internet explorer. some systems have different behavior. any tips?}}\n</noinclude>"
          },
          "sha1": "ez8n2fr325faslf00j2131wre0hykbx"
        }
      },
      {
        "title": "Template talk:Bibtex:hl07mechanizing",
        "ns": 11,
        "id": 1897,
        "revision": {
          "id": 4067,
          "parentid": 4063,
          "timestamp": "2007-03-15T02:21:42Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 263,
            "#text": "Cool! &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 22:19, 14 March 2007 (EDT)\n: Why thanks! At some point I'll need to translate the rest of the extension to English from French. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 22:21, 14 March 2007 (EDT)"
          },
          "sha1": "mla8ocorzyoe5u48bctgdd7q1vjeo0v"
        }
      },
      {
        "title": "Template talk:Click-inline",
        "ns": 11,
        "id": 1847,
        "revision": {
          "id": 3573,
          "timestamp": "2007-02-01T11:15:28Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "comment": "licensing / history",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 139,
            "#text": "History: This template is copied from the GFDL template of the same name [http://en.wikipedia.org/wiki/Template:Click-Inline at wikipedia]."
          },
          "sha1": "3xrqs9v3090sckios6buuyuk3fmta3t"
        }
      },
      {
        "title": "Template talk:Front-Blog Updates",
        "ns": 11,
        "id": 1706,
        "redirect": {
          "@title": "Talk:What's new",
          "#text": null
        },
        "revision": {
          "id": 2767,
          "timestamp": "2006-10-13T21:22:56Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "[[Template talk:Front-Blog Updates]] moved to [[Talk:What's new]]: Better name! The template can live with a redirect.",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 29,
            "#text": "#REDIRECT [[Talk:What's new]]"
          },
          "sha1": "e5rxfx62ejbn0jtxvwaz9f0gaa28eq8"
        }
      },
      {
        "title": "Template talk:Guide",
        "ns": 11,
        "id": 1515,
        "revision": {
          "id": 2014,
          "timestamp": "2006-09-28T00:35:06Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "Guide gets updated and...",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 295,
            "#text": "== Guide gets updated and... ==\n\nWon't this template be a problem if the section numbers in the guide change? Ideally this template should be <nowiki>{{guide4}}</nowiki> or something, I would think... — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 17:35, 27 September 2006 (MST)"
          },
          "sha1": "phhu8acsjk7rfbvwhj2mep6rbaxkwgz"
        }
      },
      {
        "title": "Template talk:The Twelf Project/Introduction",
        "ns": 11,
        "id": 1752,
        "revision": {
          "id": 3106,
          "parentid": 3105,
          "timestamp": "2006-10-24T05:21:50Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "minor": null,
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 345,
            "#text": "Are piped links considered bad style on this wiki?\n[[User:Drl|Drl]] 15:12, 23 October 2006 (EDT)\n\n== length requirements ==\n\nI want this paragraph to be short enough that both introductions are on the first screenfull on my 1024x768 monitor.  If someone could add ''gracefulness'' that would be cool.[[User:Drl|Drl]] 01:21, 24 October 2006 (EDT)"
          },
          "sha1": "5reuze4y62q7c5hb41qql6hsxs7tbt7"
        }
      },
      {
        "title": "Help:Contents",
        "ns": 12,
        "id": 1738,
        "redirect": {
          "@title": "The Twelf Project:Style guide",
          "#text": null
        },
        "revision": {
          "id": 2965,
          "timestamp": "2006-10-20T13:42:10Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "comment": "should have something here at least",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 33,
            "#text": "#REDIRECT [[Project:Style guide]]"
          },
          "sha1": "a2kzphcity4qcdds2s2cyg9r60vft1m"
        }
      },
      {
        "title": "Category:Case studies",
        "ns": 14,
        "id": 1736,
        "revision": {
          "id": 4847,
          "parentid": 4834,
          "timestamp": "2007-09-27T04:17:53Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "rv vandal",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 344,
            "#text": "This category contains all '''[[case studies]]'''. Case studies are more general than [[tutorials]] - whereas tutorials illustrate a specific tool or problem-solving technique; case studies range from \"toy\" examples that illustrate a variety of techniques to larger pieces of Twelf code used for real [[Research projects using Twelf|research]]."
          },
          "sha1": "q4r0o9s0v06tbh4zp38v3x2hukxakye"
        }
      },
      {
        "title": "Category:Keywords",
        "ns": 14,
        "id": 1804,
        "revision": {
          "id": 3788,
          "parentid": 3341,
          "timestamp": "2007-02-28T08:04:44Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "index of keywords",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 168,
            "#text": "This category contains Twelf '''keywords'''.\n\n== See also ==\n\n[http://www.cs.cmu.edu/~twelf/guide-1-4/twelf_17.html#cindex_% Index of keywords] in the [[User's Guide]]."
          },
          "sha1": "29gxjxffjx74omuruetxydp3dcv3nsh"
        }
      },
      {
        "title": "Category:Literate Twelf code",
        "ns": 14,
        "id": 1878,
        "revision": {
          "id": 3846,
          "timestamp": "2007-03-03T05:37:35Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "New page: This category contains all pages that are written using the [[Project:Literate Twelf|]] extension to this wiki.  [[Category:Twelf code]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 150,
            "#text": "This category contains all pages that are written using the [[Project:Literate Twelf|Literate Twelf]] extension to this wiki.\n\n[[Category:Twelf code]]"
          },
          "sha1": "406njcikazr17tnuzwrfxa1t3cob9ez"
        }
      },
      {
        "title": "Category:Pages needing attention",
        "ns": 14,
        "id": 1420,
        "revision": {
          "id": 1492,
          "timestamp": "2006-09-03T05:23:27Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 90,
            "#text": "Pages that need some work - very short pages, pages that aren't completely formatted, etc."
          },
          "sha1": "rhtxvx9optow0nz96zqhp52fgknobeh"
        }
      },
      {
        "title": "Category:Stubs",
        "ns": 14,
        "id": 1405,
        "revision": {
          "id": 1456,
          "parentid": 1455,
          "timestamp": "2006-09-03T00:12:41Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 153,
            "#text": "Short articles that need to be longer. If an article listed here doesn't actually seem like it needs expanding, remove the <nowiki>{{stub}}</nowiki> tag."
          },
          "sha1": "ftb56b22qaf950g953koqs1ii0foj2r"
        }
      },
      {
        "title": "Category:Tutorials",
        "ns": 14,
        "id": 1410,
        "revision": {
          "id": 4850,
          "parentid": 4840,
          "timestamp": "2007-09-27T04:21:17Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "rv vandal",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 365,
            "#text": "This is the category of Twelf tutorials, aimed at addressing a frequently encountered issue with using Twelf. It is one of a number of forms of [[documentation]] available at the Twelf Project wiki. Summaries of these tutorials are covered on the [[tutorial]] page.\n\nTo list your project on this page, add the <nowiki>{{tutorial}}</nowiki> tag at the end of a page."
          },
          "sha1": "9klytersgegjun267lb778v88loeimb"
        }
      },
      {
        "title": "Category:Tutorials needing attention",
        "ns": 14,
        "id": 1404,
        "revision": {
          "id": 1467,
          "parentid": 1466,
          "timestamp": "2006-09-03T01:48:07Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 41,
            "#text": "[[Category:Tutorials| Needing attention]]"
          },
          "sha1": "3vuommmhza6tfw5ujxo3bjvt2rj4azq"
        }
      },
      {
        "title": "Category:Twelf code",
        "ns": 14,
        "id": 1452,
        "revision": {
          "id": 4785,
          "parentid": 4784,
          "timestamp": "2007-09-26T05:28:49Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 255,
            "#text": "This is the category for any Twelf code fragments, signatures, etc. on the site. [[Project:Literate Twelf|Literate Twelf]] pages are automatically placed in this category, and other pages that have a significant amount of code in them probably should too."
          },
          "sha1": "1gqid9nd685dzhechkryoqu2jmtv9n0"
        }
      },
      {
        "title": "Category:Undocumented features",
        "ns": 14,
        "id": 1806,
        "revision": {
          "id": 3353,
          "timestamp": "2006-12-01T18:32:26Z",
          "contributor": {
            "username": "Tom7",
            "id": 4
          },
          "comment": "+cat",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 77,
            "#text": "Twelf contains some '''undocumented features''' that are used by researchers."
          },
          "sha1": "orqxbyqqqdr1a8khznur5t6cw5t08w2"
        }
      },
      {
        "title": "Elves:Main Page",
        "ns": 100,
        "id": 1373,
        "revision": {
          "id": 1765,
          "parentid": 1761,
          "timestamp": "2006-09-22T14:41:22Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "moved wishlist thing to [[Project:To do]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 2776,
            "#text": "This is the \"portal\" page for the Principles of Programming Group at Carnegie Mellon. The entire namespace starting with POPGroup: and POPGroup talk: are restricted to users which I have the special permission \"pop-group\" in their [[Special:Listusers | user profile]]. People listed in that list which are called \"Bureaucrat\" are the people who can give people that permission.\n\nThe RSS feed for recent changes will show edits made on this page, so don't say anything silly. In general the use of this namespace should be avoided in favor of the project namespace (for example, [[Project:To do]]) and should only be used for things like\n\n* Discussing preperation for the [[Elves:Server]]\n* Discussing strategies for releaseing the wiki on an unsuspecting world (that's what this page is for)\n\n\n== Contest? ==\n\nThere are some discussions it might be useful to have in this written-down forum on the [[Elves_talk:Main_Page | talk page]], for instance the idea of having a contest of some sort.\n\n== Things You <strike>Can't</strike> Can Do In Twelf ==\n\nWe talked about in the meeting some of the bits we'd need for having there be some recognizable activity going on. This whole setup comes attached to a [[http://redundancymanman.org/wordpress/ blog]] for which we have lots of RSS subscribable goodness. We need to come up with topics (perhaps over at the talk page?) and get people to write things with a rough completion date. People should probably write in the POPGroup namespace and then move stuff into the main namespace when we put notice up on the blog. Note that the completion date could be long before we put it on the blog, but having estimated completion dates will help plan if/how the blog will work.\n\n* '''TOPIC''' --- '''WRITER''' --- '''EST. DATE'''\n* Context Subtyping --- Rob and Dan Lee --- September 14?\n* Closure Conversion --- ? (karl) --- ?\n\n===Other ideas===\n\n* '''Logical Relations Arguments''' - ''logical relations arguments cannot be carried out (except via heavy encodings)'' [http://fling-l.seas.upenn.edu/~plclub/cgi-bin/poplmark/index.php?title=Submission_from_Carnegie_Mellon]\n* '''Coinduction''' - I'm not even certain what coinduction ''is'', but the poplmark submissions page says ''the status of coinduction is uncertain'' [http://fling-l.seas.upenn.edu/~plclub/cgi-bin/poplmark/index.php?title=Submission_from_Carnegie_Mellon]\n* '''Linear Logic/Type system''' - Unanswered question from The Twelf Wiki: ''How do I represent a linear logic or type system in Twelf?'' [http://fp.logosphere.cs.cmu.edu/twelf/?n=Main.Questions]\n* '''Orderd Linear Logic/Type system''' - Unanswered question from The Twelf Wiki: ''How do I represent an ordered linear logic or type system in Twelf?'' [http://fp.logosphere.cs.cmu.edu/twelf/?n=Main.Questions]"
          },
          "sha1": "ahngjxqivz1emwc74yp4c85lihpofoi"
        }
      },
      {
        "title": "Elves talk:Main Page",
        "ns": 101,
        "id": 1385,
        "revision": {
          "id": 2355,
          "parentid": 2082,
          "timestamp": "2006-10-04T21:46:36Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "Announcement - changing tag system",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 9435,
            "#text": "__FORCETOC__\n== A Contest? ==\n\nEveryone seemed intriuged by the idea of getting a contest going. How could we make something like this work, and perhaps produce something useful. [[User:Rsimmons|Rsimmons]] 20:21, 1 September 2006 (MST)\n\n== Categories ==\n\nI'd like to see categories for \"twelf tricks\"; things like putting a case in your theorem for closed terms, inducing extra subordination clauses, etc. Basically, something for people that understand Twelf but who might not have built a big enough toolbox yet (''e.g.'', almost everyone but Karl). Deciding what is basic Twelf knowledge ([[:Category:tutorials]]) vs. advanced tricks might be an issue... thoughts? Maybe beginner/intermediate/advanced tutorials? &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 14:40, 7 September 2006 (MST)\n: The old wiki did have a general \"beginner/intermediate/advanced\" separation - I think that's a good first-order approximation - having a good number of code examples, plus \"this is a good example of this idea\" notes, will ultimately be a better guide. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 17:02, 7 September 2006 (MST)\n\n== Rephrasing \"equality\" ==\n\nI have been confused about this, and it makes more sense (to me) as a question than asking about [http://fp.logosphere.cs.cmu.edu/twelf/?n=Answers.Equality lebinitz equality] in the metalogic (this was answered, the answer just wasn't linked to from the question so I thought previously that it had not been answered. Is there a way to make the last metatheorem work? If not, is there a good explanation why not that we can put here?\n\nAlso, I don't think I know how to do the equivalent of the ''first'' metalemma in the higher order case, say the untyped lambda calculus, and even if it's not unbelievably difficult, if it's doable it seems like the thing that has been done. If the second metalemma is doable in the first order case, what about in the higher order case? Is one of these definitions of equality superior? My intuition is to want to trust an inductiely defined definition more... — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 17:36, 7 September 2006 (MST)\n\n<twelf>tp : type.\n\nbase : tp.\npair : tp -> tp -> tp.\nlist : tp -> tp.\n\neq1 : tp -> tp -> type.\n\neq1/i : eq1 T T.\n\neq2 : tp -> tp -> type.\n\neq2/base : eq2 base base.\neq2/pair : eq2 (pair T1 T2) (pair T1' T2')\n\t    <- eq2 T1 T1'\n\t    <- eq2 T2 T2'.\neq2/list : eq2 (list T) (list T')\n\t    <- eq2 T T.\n\neq1=>2 : {T1} eq1 T1 T2 -> eq2 T1 T2 -> type.\n%mode eq1=>2 +D0 +D1 -D2.\n\n- : eq1=>2 base _ eq2/base.\n- : eq1=>2 (pair T1 T2) _ (eq2/pair D2 D1)\n     <- eq1=>2 T1 eq1/i D1\n     <- eq1=>2 T2 eq1/i D2.\n- : eq1=>2 (list T) _ (eq2/list D)\n     <- eq1=>2 T eq1/i D.\n\n%worlds () (eq1=>2 _ _ _).\n%total T (eq1=>2 T _ _).\n\neq2=>1 :  eq2 T1 T2 -> eq1 T1 T2 -> type.\n%mode eq2=>1 +D1 -D2.\n\n- : eq2=>1 eq2/base eq1/i.\n- : eq2=>1 (eq2/pair D2 D1) eq1/i\n     <- eq2=>1 D1 _\n     <- eq2=>1 D2 _.\n- : eq2=>1 (eq2/list D) eq1/i\n     <- eq2=>1 D eq1/i.\n\n%worlds () (eq2=>1 _ _).\n% total T (eq2=>1 T _). FAILS (for some obvious reasons)</twelf>\n\n: Here are the proofs of the equivalence of the two definitions. In practice, eq1 is more commonly used (and very flexible), because it is much easier to use the equivalence once you have it (the proofs have one case for eq1/i instead of having to be inductive over the structure of T). I threw in forall, to show how eq2 works in the higher-order case. You need a special block to make the proof of eq1=>2 go through. The trick to showing eq2=>1 is to also have lemmas that are equivalent to the eq2 intro rules. --[[User:DanielKLee|DanielKLee]] 22:59, 7 September 2006 (MST)\n\n<twelf>\ntp : type.\n\nbase    : tp.\npair    : tp -> tp -> tp.\nlist    : tp -> tp.\nforall  : (tp -> tp) -> tp.\n\neq1 : tp -> tp -> type.\n\neq1/i : eq1 T T.\n\neq2 : tp -> tp -> type.\n\neq2/base        : eq2 base base.\neq2/pair        : eq2 (pair T1 T2) (pair T1' T2')\n                   <- eq2 T1 T1'\n                   <- eq2 T2 T2'.\neq2/list        : eq2 (list T) (list T')\n                   <- eq2 T T'.\neq2/forall      : eq2 (forall T) (forall T')\n                   <- ({a} eq2 a a -> eq2 (T a) (T' a)).\n\n\n\n%block tp-block         : block {a : tp}.\n%block eq2-block        : block {a : tp} {eqa: eq2 a a}.\n\n\n\neq1=>2 : {T1} eq1 T1 T2 -> eq2 T1 T2 -> type.\n%mode eq1=>2 +D0 +D1 -D2.\n\n%block eq1=>2-block     : block {a : tp}{eqa:eq2 a a}{_ : eq1=>2 a eq1/i eqa}.\n\n-       : eq1=>2 base _ eq2/base.\n\n-       : eq1=>2 (pair T1 T2) _ (eq2/pair D2 D1)\n           <- eq1=>2 T1 eq1/i D1\n           <- eq1=>2 T2 eq1/i D2.\n\n-       : eq1=>2 (list T) _ (eq2/list D)\n           <- eq1=>2 T eq1/i D.\n\n-       : eq1=>2 (forall T') _ (eq2/forall D)\n           <- ({a}{eqa : eq2 a a} eq1=>2 a eq1/i eqa\n                 -> eq1=>2 (T' a) eq1/i (D a eqa)).\n\n%worlds (eq1=>2-block) (eq1=>2 _ _ _).\n%total T (eq1=>2 T _ _).\n\n\n\neq1-resp-pair   : eq1 T1 T1'\n                   -> eq1 T2 T2'\n                   -> eq1 (pair T1 T2) (pair T1' T2')\n                   -> type.\n%mode eq1-resp-pair +D1 +D2 -D3.\n\n-       : eq1-resp-pair eq1/i eq1/i eq1/i.\n\n%worlds (tp-block) (eq1-resp-pair _ _ _).\n%total {} (eq1-resp-pair _ _ _).\n\n\n\neq1-resp-list   : eq1 T1 T1'\n                   -> eq1 (list T1) (list T1')\n                   -> type.\n%mode eq1-resp-list +D1 -D2.\n\n-       : eq1-resp-list eq1/i eq1/i.\n\n%worlds (tp-block) (eq1-resp-list _ _).\n%total {} (eq1-resp-list _ _).\n\n\n\neq1-resp-forall : ({a} eq1 (T1 a) (T1' a))\n                   -> eq1 (forall T1) (forall T1')\n                   -> type.\n%mode eq1-resp-forall +D1 -D2.\n\n-       : eq1-resp-forall ([a] eq1/i) eq1/i.\n\n%worlds (tp-block) (eq1-resp-forall _ _).\n%total {} (eq1-resp-forall _ _).\n\n\n\neq2=>1  :  eq2 T1 T2 -> eq1 T1 T2 -> type.\n%mode eq2=>1 +D1 -D2.\n\n% the following case is a catch-all for variables and base\n\n-       : eq2=>1 _ eq1/i.\n\n-       : eq2=>1 (eq2/pair D2 D1) D12\n           <- eq2=>1 D1 D1'\n           <- eq2=>1 D2 D2'\n           <- eq1-resp-pair D1' D2' D12.\n\n-       : eq2=>1 (eq2/list D) D''\n           <- eq2=>1 D D'\n           <- eq1-resp-list D' D''.\n\n-       : eq2=>1 (eq2/forall D) D''\n           <- ({a}{eqa}\n                 eq2=>1 (D a eqa) (D' a))\n           <- eq1-resp-forall D' D''.\n\n%worlds (eq2-block) (eq2=>1 _ _).\n%total T (eq2=>1 T _).\n</twelf>\n\n::: Thank you thank you! I'll tutorial-fy this because I'll understand it better if I do :). — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 23:36, 7 September 2006 (MST)\n\n== CMMChallenge and POPLMark and CIVMark oh my ==\n\nhttp://www.cs.berkeley.edu/~adamc/poplmark/compile/compile.pdf - I may give it two hours over the weekend if I get tired of CIVMark again. Please someone else crack it to give me one less way to procrastinate...\n\nEverybody seems to be on the \"Challenge\" bandwagon, as a thought experiment what would we make if we made a <small>underscore</small>Mark? I.E. something that many of us who aren't Karl would be able to do pretty easily, but which is nasty or tricky or just big? — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 23:35, 7 September 2006 (MST)\n\n: I took a look at this benchmark. A lot of it seems pretty straightforward, but proving that a big step semantics is total for well-typed terms will be the biggest challenge. This is essentially a termination/normalization proof. Traditionally, you do this with a logical relations argument. The challenge gives you some leeway in your choice of dynamic semantics, but I imagine you'd either use a big step semantics or the reflexive transitive closure of a small step semantics. In the SVN twelf-lib, Dan Licata has an example of a termination proof using a canonizing substitution argument similar to (but a good deal simpler than) what Karl demonstrated on Thursday, that might be a good starting point. However, I suspect the heap in the imperative target language might make things... interesting. \n\n: As for developing a \"Challenge\", I can't think of anything interesting off the top of my head. The real \"challenge\" in all of this is being able to do your actual day-to-day research in machine-checkable way. So a good challenge problem is something you'd want to do in your day-to-day research that for whatever reason seems rather difficult to mechanize. --[[User:DanielKLee|DanielKLee]] 04:06, 8 September 2006 (MST)\n\n== Competition ==\n\nDid anyone else know this existed? [http://cocorico.cs.ru.nl/coqwiki/Cocorico%21FrontPage Coq Wiki]. I don't know French. What does Cocorico mean? --[[User:DanielKLee|DanielKLee]] 10:41, 28 September 2006 (MST)\n* I think it has something to do with Final Fantasy IV. &nbsp;&mdash;&nbsp;[[User:Tom7|Tom 7]] 11:48, 28 September 2006 (MST)\n:*I'd seen it before, but hadn't put too much thought into its existance I suppose. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 15:10, 28 September 2006 (MST)\n\n== Announcement - changing tag system ==\n\nI'm changing the tag system slightly. This *shouldn't* break anything for more than ten minutes, with one exception. If you used <nowiki><php>, <perl>, <javascript></nowiki> or any other syntax highlighting tags, those have to be changed to <nowiki><code php></code>, <code javascript></code></nowiki> tags. <nowiki><twelf></twelf></nowiki> tags will still work, I'm making these changes to be able to have more control over the Twelf tag-ness. — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 17:46, 4 October 2006 (EDT)"
          },
          "sha1": "m0dui7u8py6ok9ze1gjthbbbnpuje1w"
        }
      },
      {
        "title": "Proving metatheorems:Full LF",
        "ns": 102,
        "id": 1780,
        "revision": {
          "id": 7979,
          "parentid": 5920,
          "timestamp": "2014-01-13T03:38:16Z",
          "contributor": {
            "username": "Peterbb",
            "id": 12884
          },
          "comment": "typo",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 8330,
            "#text": "{{proving metatheorems\n  | prev = Representing the judgements of the natural numbers\n  | prevname = Representing judgements\n  | next = Proving totality assertions about the natural numbers\n  | nextname = Proving totality assertions}}\n\nIn the previous section, we saw how dependently-typed LF can be used to represent object-language judgements. We now discuss dependently-typed LF in more detail.\n\n==Definition of LF==\n\nFull LF has the following syntax:\n\n<math>\nK ::= \\texttt{type} \\, | \\, \\Pi x:A. K \n</math>\n\n<math>\nA ::= b \\, | \\, A \\, M \\, | \\, \\Pi x:A_1. A_2 \n</math>\n\n<math>\nR ::= c \\, | \\, x \\, | \\, R \\, M \n</math>\n\n<math>\nM ::= R \\, | \\, \\lambda x. M\n</math>\n\nIn Twelf's concrete syntax, the type <math>\\texttt{}\\Pi x:A_1.A_2</math> is written <tt>{x:A1} A2</tt>, the kind <math>\\texttt{}\\Pi x:A.K</math> is written <tt>{x:A} K</tt>, and the term <math>\\texttt{}\\lambda x.M</math> is written <tt>[x] M</tt>.  The terms are unchanged from the previous grammar.  The type families now include both dependent function types and applications <math>A \\, M</math> of type families to terms.  The kind level classifies type families. Type families of kind <math>\\texttt{type}</math> classify terms. Type families that are not yet fully instantiated have kinds <tt>{x:A} K</tt>.  In both types and kinds, we use <tt>-></tt> as an abbreviation when the argument is not free in the result.  \n\nFor example, in the previous section, we declared the type family <tt>plus</tt> to have kind <tt>nat -> nat -> nat -> type</tt>.  This means that when  <tt>plus</tt> is applied to three terms of type <tt>nat</tt>, it forms a type.  This kind is syntactic sugar for the kind <tt>{_:nat} {_:nat} {_:nat} type</tt>.  The partial application <tt>plus z</tt> has kind <tt>nat -> nat -> type</tt>.  Below, we will see examples where the type of one index of a type family depends on a previous argument, which motivates permitting general <tt>{x:A} K</tt> kinds in the general case.\n\nWe do not present the typing rules for LF in detail here.  However, we do call attention to the typing rule for application.  In a dependently typed language, the application typing rules must substitute the argument into the body of the dependent function type:\n\n<math>\n{R : \\Pi x : A. B \\;\\;\\;\\; M : A \\over R \\; M : [M/x]B}\n</math>\n\nIn LF, this substitution is in fact a [[hereditary substitution]], ensuring that the terms embedded in the result of the substitution are in canonical form.  \n\nThis typing rule is how constants representing inference rules are specialized to particular instances.  For example, constant <tt>even-s</tt> from the previous section has type <tt>{N:nat} even N -> even (s (s N))</tt>, so the application <tt>even-s z</tt> has type <tt>even z -> even (s (s z))</tt>.\n\nThe typing rule for family applications <math>\\mathsf{}A \\; M</math> has a similar substitution into the result kind.\n\n==Twelf conveniences==\n\nTwelf permits several syntactic conveniences for writing LF signatures.  The purpose of this list is to introduce you to these conveniences;  we will see examples of them later in this introduction or elsewhere on the wiki.\n\n===Definitions===\n\nIn Twelf, you can define an LF constant for later use.  For example:\n<twelf hidden=\"true\">\nnat : type.\nz   : nat.\ns   : nat -> nat.\n\neven    : nat -> type.\neven-z  : even z.\neven-s  : {N:nat} even N -> even (s (s N)).\n</twelf>\n<twelf>\n2 : nat = s (s z).\neven-2 : even 2 = even-s z even-z.\n</twelf>\nThe first constant names a natural number <tt>2</tt>; the second names a derivation that <tt>2</tt> is even.\n\nYou can name terms of higher type as well:\n<twelf>\nss : nat -> nat = [x:nat] s (s x).\n</twelf>\n\nThis constant might be used as follows:\n<twelf>\neven-4 : even (ss 2) = even-s 2 even-2.\n</twelf>\n\nNote that defined constants do not contribute any new inhabitants to the canonical forms of the given types.  \n\n===Non-canonical forms===\n\nTwelf permits non-canonical forms, which are treated as syntactic sugar for the associated canonical form.  Here are some examples:\n\n* [[Beta-equivalence]]: the term <tt>ss 2</tt>, which, if we expand the definitions, reads <tt>([x] (s (s x))) (s (s z))</tt>, has the canonical form <tt>s (s (s (s z)))</tt>.  As an optimization, Twelf tries not to expand definitions, but the defined form should be thought of as another way of writing the expanded canonical form.\n\n* [[Eta-equivalence]]: the term <tt>s</tt>, which has type <tt>nat -> nat</tt> can be used instead of its eta-expansion <tt>[x] s x</tt>.  We will discuss eta-equivalence more in the context of [[Proving metatheorems:Representing the judgements of the STLC|higher-order representations.]]\n\n===Implicit arguments===\n\nWriting out all of the parameters to a constant becomes tedious, so Twelf permits these parameters to be left implicit.  Specifically, if a variable starting with a lower-case letter is left unbound in a constant's type, Twelf reports an error.  If a variable beginning with an upper-case letter is left unbound, Twelf implicitly binds it in a <tt>{N}</tt> at the outside of the type.  For example, the following two ways of declaring the constant <tt>plus-s</tt> give it the same type:\n<twelf discard=\"true\">\n%% explicit\nplus-s : {N1:nat} {N2:nat} {N3:nat} plus N1 N2 N3 -> plus (s N1) N2 (s N3).\n%% implicit\nplus-s : plus N1 N2 N3 -> plus (s N1) N2 (s N3).\n</twelf>\nSimilarly, we can make the parameter to <tt>plus-z</tt> implicit:\n<twelf discard=\"true\">\n%%explicit\nplus-z : {N2:nat} plus z N2 N2.\n%%implicit\nplus-z : plus z N2 N2.\n</twelf>\n\nIn most circumstances, Twelf can infer the types of the implicit parameters from their use in the constant's type.  If it cannot, it reports an error---the type of a constant must be fully determined when the constant is processed.\n\nThe application of a constant to its implicit parameters is then inferred from context.  For example, using the fully explicit definition of <tt>plus</tt>, the derivation that 2 + 1 = 3 is written as follows:\n<twelf>\nd2+1e = plus-s (s z) (s z) (s (s z)) \n        (plus-s z (s z) (s z) \n                (plus-z (s z))).\n</twelf>\nUsing the implicit version, it is much shorter:\n<twelf>\nd2+1i = plus-s (plus-s plus-z).\n</twelf>\nThe type of this term is ambiguous, but Twelf will attempt to use [[unification]] to infer the most general possible type.\n\n===Backwards arrow===\n\nTwelf permits a type <tt>A -> B</tt> to be written <tt>B <- A</tt>.  This makes it easier to see the result of applying a constant to all of its arguments.  For example:\n<twelf discard=\"true\">\nplus-s : plus (s N1) N2 (s N3)\n           <- plus N1 N2 N3.\n</twelf>\n\nWhen we write <tt>C <- Pn <- ... P1</tt>, we will refer to <tt>C</tt> as the ''conclusion'' of the constant and each <tt>Pi</tt> as a ''premise'', by analogy with the terminology for the inference rule that this constant represents.  \n\nThe backwards-arrow also has implications on the logic programming operational semantics for LF, as we discuss below; the conclusion/premise terminology is consistent with the use of these words in logic programming as well.\n\n===Type and term inference===\n\nTwelf permits type annotations, which are written <tt>M:A</tt>, on all terms.  Type annotations can be used for documentation.  Additionally, in some cases they are necessary to help guide type inference.  We can also use a type annotation to determine the type of an implicit parameter: \n<twelf>\nd2+1i' = plus-s (plus-s (plus-z : plus z (s z) (s z))).\n</twelf>\nThis term unambiguously has type <tt>plus (s (s z)) (s z) (s (s (s z)))</tt>\n\nType annotations on the arguments of lambda-terms <tt>[x:A] M</tt> are sometimes necessary, but they can often be elided.  Type annotations on Pi-types <tt>{x:A2} A</tt> can sometimes be elided when the type of the variable is determined by its use.\n\nWhen they are determined from context, terms can be elided by writing an underscore.  For example, if the constants defining <tt>plus</tt> were declared with explicit <tt>nat</tt> parameters, we could still write the derivation of 2+1=3 as follows: \n<twelf>\nd2+1e' = plus-s _ _ _ (plus-s _ _ _ (plus-z (s z))).\n</twelf>\n\n{{proving metatheorems\n  | prev = Representing the judgements of the natural numbers\n  | prevname = Representing judgements\n  | next = Proving totality assertions about the natural numbers\n  | nextname = Proving totality assertions}}"
          },
          "sha1": "ibla4h4sn9up4th52xn7s48lapw5jf7"
        }
      },
      {
        "title": "Proving metatheorems:Natural numbers:Answers to exercises",
        "ns": 102,
        "id": 1991,
        "redirect": {
          "@title": "Proving metatheorems:Natural numbers: Answers to exercises",
          "#text": null
        },
        "revision": {
          "id": 4702,
          "timestamp": "2007-04-11T21:38:02Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "comment": "[[Proving metatheorems:Natural numbers:Answers to exercises]] moved to [[Proving metatheorems:Natural numbers: Answers to exercises]]: consistent with rest of article",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 72,
            "#text": "#REDIRECT [[Proving metatheorems:Natural numbers: Answers to exercises]]"
          },
          "sha1": "dps6rstg2975vw0bput8i58wycry8l8"
        }
      },
      {
        "title": "Proving metatheorems:Natural numbers: Answers to exercises",
        "ns": 102,
        "id": 1990,
        "revision": {
          "id": 6441,
          "parentid": 6440,
          "timestamp": "2011-10-15T23:09:46Z",
          "contributor": {
            "ip": "81.57.94.192"
          },
          "comment": "/* The sum of an odd plus an even number is odd */",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 5160,
            "#text": "This page contains answers to the exercises listed [[Proving metatheorems:Summary: the natural numbers|here]].  If you've solved an exercise that isn't answered on this page, or if you have a different solution to an exercise, please add it here.\n\n== Commutativity of Addition ==\n\n''State and prove a metatheorem showing that <tt>plus</tt> is commutative.''\n\n<twelf import=\"pluscommute\" hidden=\"true\">\nnat : type.\nz   : nat.\ns   : nat -> nat.\n\nplus   : nat -> nat -> nat -> type.\nplus-z : plus z N2 N2.\nplus-s : plus (s N1) N2 (s N3)\n          <- plus N1 N2 N3.\n\neven : nat -> type.\neven-z : even z.\neven-s : even (s (s N)) \n          <- even N.\n</twelf>\nThe theorem may be stated:\n\n<twelf discard=\"true\">\nplus-commutes : plus N1 N2 N3 -> plus N2 N1 N3 -> type.\n%mode plus-commutes +D1 -D2.\n</twelf>\n\nHowever, before we prove this theorem, we first prove two lemmas.  The first says that for any natural number <math>n</math>, <math>n+0=n</math>.  This is similar to the constant <tt>plus-z</tt>, but the order of the arguments to <tt>plus</tt> has been changed:\n\n<twelf import=\"pluscommute\">\nplus-zero-id :  {N1 : nat} plus N1 z N1 -> type.\n%mode plus-zero-id +N -D.\n\npzidz : plus-zero-id\n         z\n         plus-z.\n\npzids : plus-zero-id\n         (s N)\n         (plus-s D : plus (s N) z (s N))\n          <- plus-zero-id N D.\n\n%worlds () (plus-zero-id _ _).\n%total N (plus-zero-id N _).\n</twelf>\n\nOur second lemma states that if <math>\\mathsf{plus}(n_1,n_2,n_3)</math> then <math>\\mathsf{plus}(n_1, \\mathsf{succ}(n_2), \\mathsf{succ}(n_3))</math>.  This lemma is similar to the constant <tt>plus-s</tt>, but the order of the arguments to <tt>plus</tt> has been changed:\n\n<twelf import=\"pluscommute\">\nplus-flip : plus N1 N2 N3 -> plus N1 (s N2) (s N3) -> type.\n%mode plus-flip +D1 -D2.\n\npfz : plus-flip \n       _\n       plus-z.\n\npfs : plus-flip\n       (plus-s Dplus : plus (s N1) N2 (s N3))\n       (plus-s DIH   : plus (s N1) (s N2) (s (s N3)))\n         <- plus-flip Dplus DIH.\n\n%worlds () (plus-flip _ _).\n%total D (plus-flip D _).\n</twelf>\n\nFinally, using these two lemmas, we may prove the theorem itself:\n\n<twelf import=\"pluscommute\">\nplus-commutes : plus N1 N2 N3 -> plus N2 N1 N3 -> type.\n%mode plus-commutes +D1 -D2.\n\npcz : plus-commutes\n       _\n       D\n        <- plus-zero-id N1 D.\n       \npcs : plus-commutes       \n       (plus-s Dplus: plus (s N1') N2 (s N3'))\n       D\n        <- plus-commutes Dplus DIH\n        <- plus-flip DIH D.\n\n%worlds () (plus-commutes _ _).\n%total D (plus-commutes D _).\n</twelf>\n\n== Even/odd numbers and addition ==\n\n=== Define the odd numbers ===\n\n<twelf import=\"pluscommute\">\nodd   : nat -> type.\nodd-1 : odd (s z).\nodd-s : odd N -> odd (s (s N)).\n</twelf>\n\n=== The successor of an even number is an odd number, and vice versa ===\n\n<twelf import=\"pluscommute\">\nsucc-even : even N -> odd (s N) -> type.\n%mode succ-even +D1 -D2.\n\nsez : succ-even even-z odd-1.\n\nses : succ-even (even-s EvenA) (odd-s OddA)\n       <- succ-even EvenA OddA.\n\n%worlds () (succ-even _ _).\n%total D (succ-even D _).\n\nsucc-odd : odd N -> even (s N) -> type.\n%mode succ-odd +D1 -D2.\n\nso1 : succ-odd odd-1 (even-s even-z).\n\nsos : succ-odd (odd-s OddA) (even-s EvenA)\n       <- succ-odd OddA EvenA.\n\n%worlds () (succ-odd _ _).\n%total D (succ-odd D _).\n</twelf>\n\n=== The sum of an even and an odd number is odd ===\n\n<twelf import=\"pluscommute\">\nsum-even-odd : even N1 -> odd N2 -> plus N1 N2 N3 -> odd N3 -> type.\n%mode sum-even-odd +D1 +D2 +D3 -D4.\n\nseoz : sum-even-odd even-z OddN2 plus-z OddN2.\n\nseos : sum-even-odd\n       (even-s EvenN1)\n       OddN2\n       (plus-s (plus-s PlusN1N2N3))\n       (odd-s OddN3)\n       <- sum-even-odd EvenN1 OddN2 PlusN1N2N3 OddN3.\n\n%worlds () (sum-even-odd _ _ _ _).\n%total D (sum-even-odd D _ _ _).\n</twelf>\n\n=== The sum of an odd plus an even number is odd ===\n\n<twelf import=\"pluscommute\">\nsum-odd-even : odd N1 -> even N2 -> plus N1 N2 N3 -> odd N3 -> type.\n%mode sum-odd-even +D1 +D2 +D3 -D4.\n\nsoe1 : sum-odd-even odd-1 EvenN2 _ OddN3\n        <- succ-even EvenN2 OddN3.\n\nsoes : sum-odd-even\n        (odd-s OddN1)\n        EvenN2\n        (plus-s (plus-s PlusN1N2N3))\n        (odd-s OddN3)\n        <- sum-odd-even OddN1 EvenN2 PlusN1N2N3 OddN3.\n\n%worlds () (sum-odd-even _ _ _ _).\n%total D (sum-odd-even D _ _ _).\n</twelf>\n\nor we can use the previously proved commutativity lemma of plus:\n\n<twelf import=\"pluscommute\">\nsum-odd-even : odd M -> even N -> plus M N P -> odd P -> type.\n%mode sum-odd-even +O +E +P -O2.\n\nsoe : sum-odd-even\n       (O : odd M)\n       (E : even N)\n       (A : plus M N P)\n       (O0 : odd P)\n       <- plus-commutes A A0\n       <- sum-even-odd E O A0 O0.\n\n%worlds () (sum-odd-even _ _ _ _).\n%total D (sum-odd-even D _ _ _).\n</twelf>\n\n=== The sum of two odd numbers is even ===\n\n<twelf import=\"pluscommute\" check=\"true\">\nsum-odds : odd N1 -> odd N2 -> plus N1 N2 N3 -> even N3 -> type.\n%mode sum-odds +D1 +D2 +D3 -D4.\n\nsoz : sum-odds odd-1 OddN2 _ EvenN3\n       <- succ-odd OddN2 EvenN3.\n\nsos : sum-odds (odd-s OddN1) OddN2 (plus-s (plus-s PlusN1N2N3)) (even-s\nEvenN3)\n       <- sum-odds OddN1 OddN2 PlusN1N2N3 EvenN3.\n\n%worlds () (sum-odds _ _ _ _).\n%total D (sum-odds D _ _ _).\n</twelf>"
          },
          "sha1": "lyyk9wpdm9gaazbwrd4nhyq7xeavews"
        }
      },
      {
        "title": "Proving metatheorems:Proving metatheorems about the STLC",
        "ns": 102,
        "id": 1891,
        "revision": {
          "id": 5402,
          "parentid": 3998,
          "timestamp": "2008-10-25T05:11:36Z",
          "contributor": {
            "username": "Pronesto",
            "id": 40
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 9753,
            "#text": "{{proving metatheorems\n  | prev = Representing the judgements of the STLC\n  | prevname = Representing judgements\n  | next = Proving totality assertions in non-empty contexts\n  | nextname = Proving totality assertions in non-empty contexts}}\n\nIn this section, we show how to prove type preservation for the STLC.  As you will see, this theorem is really no harder than the metatheorems about the natural numbers that we proved above.  For reference, we recap the entire LF signature representing the STLC:\n\n<twelf>\n%% Syntax\n\ntp    : type.\nunit  : tp.\narrow : tp -> tp -> tp.\n\ntm    : type.\nempty : tm.\napp   : tm -> tm -> tm.\nlam   : tp -> (tm -> tm) -> tm.\n\n%% Static Semantics\n\nof       : tm -> tp -> type.\nof-empty : of empty unit.\nof-lam   : of (lam T2 ([x] E x)) (arrow T2 T)\n            <- ({x: tm} of x T2 -> of (E x) T).\nof-app   : of (app E1 E2) T\n            <- of E1 (arrow T2 T)\n            <- of E2 T2.\n\n%% Dynamic Semantics\n\nvalue       : tm -> type.\nvalue-empty : value empty.\nvalue-lam   : value (lam T ([x] E x)).\n\nstep          : tm -> tm -> type.\nstep-app-1    : step (app E1 E2) (app E1' E2)\n                 <- step E1 E1'.\nstep-app-2    : step (app E1 E2) (app E1 E2') \n                 <- value E1\n                 <- step E2 E2'.\nstep-app-beta : step (app (lam T2 ([x] E x)) E2) (E E2)\n                 <- value E2.\n</twelf>\n\n== Preservation ==\n\nHere is a complete Twelf proof of preservation for the STLC:\n\n<twelf check=\"true\">\npreserv : step E E' -> of E T -> of E' T -> type.                                                                                                                     \n%mode preserv +Dstep +Dof -Dof'.                                                                                                                                      \n                                                                                                                                                                      \npreserv-app-1    : preserv                                                                                                                                            \n                    (step-app-1 (DstepE1 : step E1 E1'))                                                                                                              \n                    (of-app (DofE2 : of E2 T2)                                                                                                                        \n                            (DofE1 : of E1 (arrow T2 T)))                                                                                                             \n                    (of-app DofE2 DofE1')                                                                                                                             \n                    <- preserv DstepE1 DofE1 (DofE1' : of E1' (arrow T2 T)).                                                                                          \n                                                                                                                                                                      \npreserv-app-2    : preserv                                                                                                                                            \n                    (step-app-2 (DstepE2 : step E2 E2') (DvalE1 : value E1))                                                                                          \n                    (of-app (DofE2 : of E2 T2)                                                                                                                        \n                            (DofE1 : of E1 (arrow T2 T)))                                                                                                             \n                    (of-app DofE2' DofE1)                                                                                                                             \n                    <- preserv DstepE2 DofE2 (DofE2' : of E2' T2).                                                                                                    \n                                                                                                                                                                      \npreserv-app-beta : preserv                                                                                                                                            \n                    (step-app-beta (Dval : value E2))                                                                                                                 \n                    (of-app (DofE2 : of E2 T2)                                                                                                                        \n                            (of-lam (([x] [dx] DofE x dx)                                                                                                             \n                                       : {x : tm} {dx : of x T2} of (E x) T)))                                                                                        \n                    (DofE E2 DofE2).                                                                                                                                  \n                                                                                                                                                                      \n%worlds () (preserv _ _ _).                                                                                                                                           \n%total D (preserv D _ _).                                                                                                                                             \n</twelf>\n\nNow, let's examine the pieces of the proof in more detail.\n\n'''Correctness of the theorem statement.''' We should check that this Twelf theorem statement actually corresponds to the notion of type preservation that we have in mind, which is stated as follows:\n\n: If <math>e \\mapsto e'</math> and <math>\\cdot \\vdash e : \\tau</math> then <math>\\cdot \\vdash e' : \\tau</math>.  \n\nThis corresponds to the following statement about LF terms:\n\n: If <tt>Dstep : step E E'</tt> and <tt>Dof : of E T</tt> then <tt>Dof' : of E' T</tt>.\n\nBy adequacy, these two theorem statements are equivalent; note that closed LF terms represent closed object-language terms and typing derivations in the empty object-language context.  \n\nThe above totality assertion for the type family <tt>preserv</tt> clearly implies this statement.  Thus, the Twelf proof proves the informal statement of preservation.\n\n'''Reading the cases.'''  As we have discussed, the LF constants implementing a proof correspond to the cases of an informal proof.  For preservation, the three LF constants correspond to the three cases of an informal proof by induction on the dynamic semantics derivation, where in each case we invert the static semantics derivation.  For example, in the case <tt>preserv-app-1</tt> for <tt>step-app-1</tt>, we invert the typing derivation for the application, appeal to the inductive hypothesis (the premise of type <tt>preserv</tt>), and then use <tt>of-app</tt> to derive the result.  The other two cases use similar inversions.  Because of the higher-order representation of the hypothetical typing judgement, there is no need for a substitution lemma in the case <tt>preserv-app-beta</tt>: the LF term <tt>DofE</tt> representing the hypothetical derivation can simply be applied to the derivation <tt>DofE2</tt>.  \n\nThe <tt>%total</tt> directive asks Twelf to verify that <tt>preserv</tt> defines a total relation—i.e., that it is a correct proof.  We call attention to a few of Twelf's checks:\n* '''Termination:''' In all premises, the dynamic semantics derivation is a subterm of the input dynamic semantics derivation.  In this proof, it happens that the typing derivation is always smaller as well, so we could equivalently have verified totality by induction on the second argument.  \n* '''Input coverage:''' The inversion steps in the above reading of the proof create input-coverage-checking obligations. For example, Twelf's coverage checker justifies the inversion of the typing derivation in <tt>preserv-app-1</tt> by using index information (i.e., that the subject of the derivation is <tt>app E1 E2</tt>) to show that <tt>of-app</tt> is the only way to construct an LF term of the appropriate type.  If there were another way to derive the well-typedness of an application, the inversion of the typing derivation in <tt>step-app-1</tt> would not be justified.  This would manifest itself as an input coverage error, as not all possible inputs would be derived by <tt>of-app</tt>.\n\n== Other theorems ==\n\nOther properties of the STLC are proved elsewhere on this wiki.  Several [[tutorials]] use theorems about the STLC to illustrate various Twelf devices.  For example, proving progress for the STLC uses [[output factoring]]; proving determinacy of the operational semantics is an example of a [[uniqueness lemma]].  You may wish to read these tutorials at this point.  Neither requires any more machinery than what we have already introduced; the tutorials simply show how to use Twelf in a fashion that may be somewhat subtle until you've seen it once.\n\nThe next section of this introduction describes one new piece of Twelf machinery: the ability to prove totality assertions for non-empty contexts.\n\n{{proving metatheorems\n  | prev = Representing the judgements of the STLC\n  | prevname = Representing judgements\n  | next = Proving totality assertions in non-empty contexts\n  | nextname = Proving totality assertions in non-empty contexts}}"
          },
          "sha1": "19l2rm38mwhu8h41p56wybbbq4g08ea"
        }
      },
      {
        "title": "Proving metatheorems:Proving metatheorems about the natural numbers",
        "ns": 102,
        "id": 1853,
        "revision": {
          "id": 8738,
          "parentid": 6182,
          "timestamp": "2019-01-10T16:40:52Z",
          "contributor": {
            "username": "Mcoblenz",
            "id": 14500
          },
          "comment": "Clarified that these examples use the \"implicit arguments\" definitions, not the explicit ones that were presented initially.",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 11183,
            "#text": "{{proving metatheorems\n  | prev = Proving totality assertions about the natural numbers\n  | prevname = Proving totality assertions\n  | next = Summary: the natural numbers\n  | nextname = Summary}}\n\nIn the previous section, we saw how to ask Twelf to verify totality assertions, which are a particular form of statement one can make about a deductive system.  However, not all that many metatheorems are totality assertions about the judgements of an object language.  Moreover, even if a judgement does in fact satisfy a total assertion, the judgement often will not be written in the particular form that allows Twelf to automatically check mode, worlds, termination, and coverage.  So why are totality assertions so important?\n\n== How to prove metatheorems ==\n\nThe reason is that we can use Twelf's ability to ''prove'' totality assertions to ''check'' proofs of more general metatheorems.  Let's illustrate this with an example.  Say we want to prove that the sum of two even numbers is even.  More precisely, let's prove the following statement:\n\n:: If <math>\\mathsf{even}(N_1)</math> and <math>\\mathsf{even}(N_2)</math> and <math>\\mathsf{plus}(N_1,N_2,N_3)</math> then <math>\\mathsf{even}(N_3)</math>.\n\nWe can prove this statement by rule induction on the first premise, the derivation that <math>\\mathsf{even}(N_1)</math>.  The computational content of this proof will be a function that transforms the derivations of the premises into a derivation of the conclusion.  \n\nNow, let's recast this informal theorem statement as a statement about LF terms.  By the adequacy of our LF representations, this informal statement is equivalent to a statement about the canonical forms of the corresponding types:\n\n:: For all <tt>DevenN1 : even N1</tt> and <tt>DevenN2 : even N2</tt> and <tt>Dplus : plus N1 N2 N3</tt> there exists a <tt>DevenN3 : even N3</tt>.  \n\nWe can recast the informal proof by rule induction on the derivation of <math>\\mathsf{even}(N_1)</math> \nas a proof by induction on the canonical forms of type <tt>even N1</tt>.  The computational content of this proof will be a transformation from LF terms of type <tt>even N1</tt>, <tt>even N2</tt>, and <tt>plus N1 N2 N3</tt> \nto an LF term of type <tt>even N3</tt>.\n\nThe key to the way we use Twelf to prove general metatheorems is that ''we can represent this transformation within LF itself''.  Specifically, we represent the theorem statement as a type family, which defines a relation on the subjects of the theorem.  Then, we represent the proof as LF constants inhabiting that type family.  A proof is correct iff it defines a total relation (because the original metatheorem is implied by the totality assertion for the relation).  So we deploy Twelf's ability to verify totality assertions in order to check the proof of the metatheorem.  Thus, you already have all the tools you need to prove metatheorems with Twelf; you just need to use them in the right way.  \n\n== Our first metatheorem ==\nThis will all be clearer once we do an example.\n\n=== Representing the theorem statement ===   \n\nWe represent the above theorem statement in Twelf as a type family relating the appropriate derivations:\n\n<twelf discard=true>\nsum-evens : even N1 -> even N2 -> plus N1 N2 N3 -> even N3 -> type.\n%mode sum-evens +D1 +D2 +Dplus -D3.\n%worlds () (sum-evens _ _ _ _).\n</twelf>\n\nThe kind of <tt>sum-evens</tt> is ''dependent'', unlike all the kinds we have seen so far.  The dependency ensures that the <tt>sum-evens</tt> relation relates derivations of the appropriate facts.  \n\nThe mode declaration for this type family makes the \"for all\" theorem subjects into inputs, and the \"there exists\" theorem subject into an output.  Intuitively, this is the right thing to do because then the relation defined by <tt>sum-evens</tt> will transform these three \"for all\" derivations into the \"there exists\" derivation.  More formally, observe that the mode and worlds declarations declare the following totality assertion:\n\n:: For all <tt>D1 : even N1</tt> and <tt>D2 : even N2</tt> and <tt>Dplus : plus N1 N2 N3</tt> there exist <tt>D3 : even N3</tt> and <tt>D : sum-evens D1 D2 Dplus D3</tt>.  \n\nThe above metatheorem statement is clearly a corollary of this totality assertion.\n\n=== Representing the proof ===\n\nNext, we transcribe the informal proof of the metatheorem as LF constants of the appropriate types.  First, let's review the informal proof.\n\n==== Informal proof ====\nThe proof is by induction over the derivation of <math>\\mathsf{even}(N_1)</math>.  \n\nCase for <math>\\overline{\\mathsf{even}(\\mathsf{zero})}</math>:\n\nIn this case, <math>\\texttt{}N_1</math> is <math>\\texttt{zero}</math>, so by inversion the derivation of <math>\\mathsf{plus}(N_1,N_2,N_3)</math> must derive <math>\\mathsf{plus}(\\mathsf{zero},N_2,N_2)</math>.  Then the assumption of <math>\\mathsf{even}(N_2)</math> gives the result.  \n\nCase for <math>\\mathsf{even}(N_1') \\over \\mathsf{even}(\\mathsf{succ}(\\mathsf{succ}(N_1'))</math>:\n\nIn this case, <math>\\texttt{}N_1</math> is <math>\\mathsf{succ}(\\mathsf{succ}(N_1'))</math>, so we have a derivation of <math>\\mathsf{plus}(\\mathsf{succ}(\\mathsf{succ}(N_1')),N_2,N_3)</math>.  By inversion on this derivation, \n<math>\\texttt{}N_3</math> is <math>\\mathsf{succ}(\\mathsf{succ}(N_3'))</math> and we have a derivation of\n<math>\\mathsf{plus}(N_1',N_2,N_3')</math>.  Then the inductive hypothesis applied to this derivation and the derivation of <math>\\mathsf{even}(N_2)</math> yields a derivation of <math>\\mathsf{even}(N_3')</math>.  So we can derive \n\n<math>\\mathsf{even}(N_3') \\over \\mathsf{even}(\\mathsf{succ}(\\mathsf{succ}(N_3'))</math>\n\nto finish the case.\n\n==== LF Representation ====\n\nWe represent this informal proof as LF constants inhabiting the type family <tt>sum-evens</tt>. We use the implicit-arguments versions of the definitions from [[Proving_metatheorems:Full_LF]].  There will be one constant for each case of the informal proof.  The constant corresponding to the first case is:\n\n<twelf discard=true>\nsez : sum-evens \n       even-z \n       (DevenN2 : even N2)\n       (plus-z : plus z N2 N2)\n       DevenN2.\n</twelf>\n\nWe can read the type of this constant as the above case: when the term of type <tt>even N1</tt> is <tt>even-z</tt>, then <tt>N1</tt> is <tt>z</tt> and the term of type <tt>plus N1 N2 N3</tt> must be <tt>plus-z</tt>.  Then the assumed term of type <tt>even N2</tt> has the appropriate type for the result.  \n\nThe constant corresponding to the second case is:\n\n<twelf discard=true>\nses : sum-evens \n       ( (even-s DevenN1') : even (s (s N1')))\n       (DevenN2 : even N2)\n       ( (plus-s (plus-s Dplus)) : plus (s (s N1')) N2 (s (s N3')))\n       (even-s DevenN3')\n       <- sum-evens DevenN1' DevenN2 Dplus DevenN3'.\n</twelf>\n\nWe invert the derivation of <tt>plus</tt> by pattern-matching it as two applications of the constant <tt>plus-s</tt>.  The inductive call to the theorem is represented as a premise of type <tt>sum-evens</tt> on a term <tt>DevenN1'</tt> that is a subterm of the input term <tt>(even-s DevenN1')</tt>.  The result of the case is created by applying the constant <tt>even-s</tt>, which corresponds to the rule used in the informal case, to the result of the inductive call.  \n\nYou should try to get used to the three equivalent ways of thinking about these constants:\n# '''Informal proof:''' They are a direct transcription of the cases of the informal proof.\n# '''Type inhabitation:''' They define the relation <tt>sum-evens</tt> by type inhabitation, in such a way that Twelf can prove that the family is inhabited for all inputs.\n# '''Logic programming:''' They define a total logic program from the inputs to the outputs.  \n\nNow that we have represented the proof, all that's left is to ask Twelf to verify this proof by induction on the first argument:\n<twelf discard=true>\n%total D (sum-evens D _ _ _).\n</twelf>\n\nWe call attention to a few of Twelf's checks:\n* '''Termination:''' In the premise of the constant <tt>even-s</tt>, the term <tt>DevenN1'</tt> is a subterm of the input derivation, so the termination check succeeds.  In this case, it happens that the term <tt>Dplus</tt> is also smaller, so we could have checked termination on this argument instead.  \n* '''Input Coverage:''' Because Twelf separates termination checking from coverage checking, the constants defining a type family may case-analyze more arguments than just the induction one.  This subsidiary case-analyses correspond to inversion steps in an informal proof.  If an inversion is not justified (e.g., if in <tt>sez</tt> there were another way to derive <tt>plus z N2 N3</tt> besides <tt>plus-z</tt>), Twelf reports an input coverage error—not all possible input terms are covered.\n\n=== Summary ===\n\nHere's the entire Twelf proof:\n<twelf hidden=\"true\">\nnat : type.\nz   : nat.\ns   : nat -> nat.\n\neven   : nat -> type.\neven-z : even z.\neven-s : even (s (s N))\n\t  <- even N.\n\nplus   : nat -> nat -> nat -> type.\nplus-z : plus z N2 N2.\nplus-s : plus (s N1) N2 (s N3)\n\t  <- plus N1 N2 N3.\n</twelf>\n<twelf check=\"true\">\nsum-evens : even N1 -> even N2 -> plus N1 N2 N3 -> even N3 -> type.\n%mode sum-evens +D1 +D2 +D3 -D4.\n\nsez : sum-evens \n       even-z \n       (DevenN2 : even N2)\n       (plus-z : plus z N2 N2)\n       DevenN2.\n\nses : sum-evens \n       ( (even-s DevenN1') : even (s (s N1')))\n       (DevenN2 : even N2)\n       ( (plus-s (plus-s Dplus)) : plus (s (s N1')) N2 (s (s N3')))\n       (even-s DevenN3')\n       <- sum-evens DevenN1' DevenN2 Dplus DevenN3'.\n\n%worlds () (sum-evens _ _ _ _).\n%total D (sum-evens D _ _ _).\n</twelf>\nNote that the type annotations are only for readability of the proof; they are not necessary for Twelf to type-check the constants.\n\n== What metatheorems can we prove this way? ==\n\nThe metatheorems that can be proved in Twelf have the form\n\n: For all LF terms of some input types, there exist LF terms of some output types.\n\nThese metatheorems are called <math>\\forall\\exists</math>-statements, and they are the theorems whose proofs consist of total relations between the input types and the output types.  \n\nThis means that there are many theorems that cannot be mechanized in Twelf (e.g., theorems requiring higher quantifier complexity).  However, in practice, <math>\\forall\\exists</math>-statements have been shown to be a useful class of metatheorems about programming languages (for example, they are enough to prove type safety for all of Standard ML<ref>{{bibtex:lch07ml}}</ref>).    \n\nIt is important to recognize that the restriction to <math>\\forall\\exists</math>-statements is a consequence of  representing proofs of metatheorems as total relations among LF types.  It is ''not'' a consequence of representing object languages in LF.  Any on-paper proof about an informal description of an object language can be translated into an on-paper proof about the associated adequate LF representation.  But only some of these proofs can be mechanically verified in Twelf using the techniques presented above.  \n\n<references />\n\n{{proving metatheorems\n  | prev = Proving totality assertions about the natural numbers\n  | prevname = Proving totality assertions\n  | next = Summary: the natural numbers\n  | nextname = Summary}}"
          },
          "sha1": "q7yomn8jwvc00mc5o43up1isrqn7bbs"
        }
      },
      {
        "title": "Proving metatheorems:Proving metatheorems in non-empty contexts",
        "ns": 102,
        "id": 1887,
        "revision": {
          "id": 6189,
          "parentid": 4999,
          "timestamp": "2010-11-23T03:06:24Z",
          "contributor": {
            "username": "Sully",
            "id": 87
          },
          "comment": "Fix to not use deprecated TwelfTags that produce warnings",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 17259,
            "#text": "{{proving metatheorems\n  | next = Summary: the STLC\n  | nextname = Summary\n  | prev = Proving metatheorems about the STLC\n  | prevname = Proving metatheorems}}\n\nBy using Twelf's ability to prove totality assertions for type families in general worlds, we can mechanize metatheorems about open LF terms.  We prove a simple metatheorem about the judgement <tt>size E N</tt> as an example.  \n<twelf hidden=\"true\">\ntp    : type.\nunit  : tp.\narrow : tp -> tp -> tp.\n\ntm    : type.\nempty : tm.\nlam   : tp -> (tm -> tm) -> tm.\napp   : tm -> tm -> tm.\n\nnat : type.\nz   : nat.\ns   : nat -> nat.\n\nplus   : nat -> nat -> nat -> type.\n%mode plus +X1 +X2 -X3.\n\nplus-z : plus z N2 N2.\nplus-s : plus (s N1) N2 (s N3)\n\t  <- plus N1 N2 N3.\n\n%worlds () (plus _ _ _).\n%total N (plus N _ _).\n</twelf>\n<twelf hidden=\"true\">\nplus-exists : {N1} {N2} plus N1 N2 N3 -> type.\n%mode plus-exists +X1 +X2 -X3.\n\n- : plus-exists z _ plus-z.\n- : plus-exists (s N1) N2 (plus-s D)\n     <- plus-exists N1 N2 D.\n\n%worlds () (plus-exists _ _ _).\n%total N1 (plus-exists N1 _ _).\n\nplus-z-rh : {n:nat} plus n z n -> type.\n%mode plus-z-rh +N -D.\n\n- : plus-z-rh z plus-z.\n- : plus-z-rh (s N) (plus-s D)\n     <- plus-z-rh N (D : plus N z N).\n\n%worlds () (plus-z-rh _ _).\n%total N (plus-z-rh N _).\n\nplus-s-rh : plus N1 N2 N3 -> plus N1 (s N2) (s N3) -> type.\n%mode plus-s-rh +D1 -D2.\n\n- : plus-s-rh plus-z plus-z.\n- : plus-s-rh (plus-s (D : plus N1' N2 N3')) (plus-s D')\n     <- plus-s-rh D (D' : plus N1' (s N2) (s N3')).\n\n%worlds () (plus-s-rh _ _).\n%total D (plus-s-rh D _).\n\nplus-commute : plus N1 N2 N3 -> plus N2 N1 N3 -> type.\n%mode plus-commute +D1 -D2.\n\n-       : plus-commute (plus-z : plus z N N) D\n           <- plus-z-rh N D.\n-       : plus-commute (plus-s D : plus (s N1) N2 (s N3)) D''\n           <- plus-commute D (D' : plus N2 N1 N3)\n           <- plus-s-rh D' (D'' : plus N2 (s N1) (s N3)).\n\n%worlds () (plus-commute _ _).\n%total D (plus-commute D _).\n\nid/nat      : nat -> nat -> type.\nid/nat-refl : id/nat N N.\n\nid/nat-s-cong : id/nat N1 N2\n                 -> id/nat (s N1) (s N2)\n                 -> type.\n%mode id/nat-s-cong +X1 -X2.\n\n- : id/nat-s-cong id/nat-refl  id/nat-refl.\n\n%worlds () (id/nat-s-cong _ _).\n%total {} (id/nat-s-cong _ _).\n\nplus-unique : plus N1 N2 N3\n\t      -> plus N1 N2 N3'\n\t      -> id/nat N3 N3'\n\t      -> type.\n%mode plus-unique +X1 +X2 -X3.\n\n- : plus-unique D D id/nat-refl.\n- : plus-unique (plus-s D) (plus-s D') DidS\n     <- plus-unique D D' Did\n     <- id/nat-s-cong Did DidS.\n\n%worlds () (plus-unique _ _ _).\n%total D (plus-unique D _ _).\n\nplus-respects-id : plus N1 N2 N3\n                   -> id/nat N1 N1'\n                   -> id/nat N2 N2'\n                   -> id/nat N3 N3'\n                   -> plus N1' N2' N3'\n                   -> type.\n%mode plus-respects-id +X1 +X2 +X3 +X4 -X5.\n\n- : plus-respects-id D id/nat-refl id/nat-refl id/nat-refl  D.\n\n%worlds () (plus-respects-id _ _ _ _ _).\n%total {} (plus-respects-id _ _ _ _ _).\n\nid/nat-sym : id/nat N1 N2\n              -> id/nat N2 N1\n              -> type.\n%mode id/nat-sym +X1 -X2.\n\n- : id/nat-sym id/nat-refl  id/nat-refl.\n\n%worlds () (id/nat-sym _ _).\n%total {} (id/nat-sym _ _).\n\nplus-assoc : plus A B AB\n             -> plus B C BC\n             -> plus AB C ABC\n             -> plus A BC ABC\n             -> type.\n%mode plus-assoc +X1 +X2 +X3 -X4.\n\n- : plus-assoc \n     plus-z\n     DplusB-C \n     DplusB-C' \n     Dplus\n     <- plus-unique DplusB-C DplusB-C' Did\n     <- plus-respects-id plus-z id/nat-refl id/nat-refl Did Dplus.\n\n- : plus-assoc \n     (plus-s DplusA'-B)\n     DplusB-C\n     (plus-s DplusA'B-C) \n     (plus-s DplusA'-BC)\n     <- plus-assoc DplusA'-B DplusB-C DplusA'B-C DplusA'-BC.\n\n%worlds () (plus-assoc _ _ _ _).\n%total D (plus-assoc D _ _ _).\n\nplus-assoc2 : plus A B AB\n\t       -> plus B C BC\n\t       -> plus AB C ABC\n\t       -> plus A BC ABC\n\t       -> type.\n%mode plus-assoc2 +X1 +X2 -X3 +X4.\n\n- : plus-assoc2 D1 D2 D3' D4\n     <- plus-exists _ _ D3\n     <- plus-assoc D1 D2 D3 D4'\n     <- plus-unique D4 D4' Did\n     <- id/nat-sym Did Did'\n     <- plus-respects-id D3 id/nat-refl id/nat-refl Did' D3'.\n\n%worlds () (plus-assoc2 _ _ _ _).\n%total {} (plus-assoc2 _ _ _ _).\n\nlemma : plus N1 N2 Nsum\t      \n\t -> plus Ndiff1 N1 N1'\n\t -> plus Ndiff2 N2 N2'\n\t -> plus N1' N2' Nsum'\n\t -> plus Ndiff Nsum  Nsum'\n\t -> type.\n%mode lemma +X1 +X2 +X3 +X4 -X5.\n\n- : lemma \n     (D    : plus N1 N2 Nsum)\n     (D1pre   : plus Ndiff1 N1 N1')\n     (D2pre   : plus Ndiff2 N2 N2')\n     (D'   : plus N1' N2' Nsum')\n     Dres'\n     %% there's probably a way to do without these two commutes\n     %% and the one at the end;\n     %% proof was originally written with the other argument order\n     <- plus-commute D1pre D1\n     <- plus-commute D2pre D2\n     <- plus-exists Ndiff1 N2' (Ddiff1+2' : plus Ndiff1 N2' Ndiff1+2')\n     <- plus-assoc D1 Ddiff1+2' D' (Dassoc : plus N1 Ndiff1+2' Nsum')\n     <- plus-commute D2 (D2' : plus Ndiff2 N2 N2')\n     <- plus-exists Ndiff1 Ndiff2 (Ddiff1+2 : plus Ndiff1 Ndiff2 Ndiff1+2)\n     <- plus-assoc2 Ddiff1+2 D2' \n\t(Dassoc' : plus Ndiff1+2 N2 Ndiff1+2')\n\tDdiff1+2'\n     <- plus-commute Dassoc' \n\t(Dassoc'' : plus N2 Ndiff1+2 Ndiff1+2')\n     <- plus-assoc2 D Dassoc'' Dres Dassoc\n     <- plus-commute Dres Dres'.\n\n%worlds () (lemma _ _ _ _ _).\n%total {}  (lemma _ _ _ _ _).\n</twelf>\n<twelf hidden=\"true\">\nsize       : tm -> nat -> type.\n%mode size +E -N.\n\nsize-empty : size empty (s z). \nsize-lam   : size (lam _ E) (s N)\n\t\t<- ({x} {dx : size x (s z)}\n\t\t      size (E x) N).\nsize-app   : size (app E1 E2) (s N)\n\t\t<- size E1 N1\n\t\t<- size E2 N2 \n\t\t<- plus N1 N2 N.\n\n%block size-block : block {x : tm} {dx : size x (s z)}.\n\n%worlds (size-block) (size _ _).\n%total E (size E _).\n</twelf>\n==Lower bound on size of substitution: Theorem statement==\n\nWe prove that substitution never decreases the size of a term.  The informal theorem statement is as follows:\n\n: For all terms <math>e'</math> and <math>e</math>, <math>|e| \\le |\\{e'/x\\}e|</math>.\n\nWe can restate this theorem relationally as follows:\n\n: For all terms <math>\\mathsf{}e'</math> and <math>\\mathsf{}e</math>, if <math>\\mathsf{}|e| = n</math> and <math>\\mathsf{}|\\{e'/x\\}e| = n'</math> then there exists an <math>\\mathsf{}n''</math> such that <math>\\mathsf{}n'' + n = n'</math>.\n\nFor pedagogical parsimony, we have defined greater-than in terms of addition, so that we do not need to introduce any additional judgements on numbers here.  Additionally, because <tt>size</tt> defines a function, we are free to assume or conclude the derivations of <tt>size</tt> as is convenient; in this case, the proof is slightly simpler if we assume these derivations.  \n\nBy adequacy, this theorem can be recast as the following statement about LF terms:\n\n: For all Γ in <tt>(size-block)*</tt>, if <tt>Γ {{vdash}} E' : tm</tt> and <tt>Γ {{vdash}} D : {x:tm} size x (s z) -> size (E x) N</tt> and <tt>Γ {{vdash}} D' : size (E E') N'</tt> then there exist <tt>Ndiff</tt> and <tt>Dplus</tt> such that <tt>Γ {{vdash}} Dplus : plus Ndiff N N'</tt>.\n\nConsidering arbitrary contexts in the world <tt>(size-block)*</tt> is necessary to capture the informal theorem statement, which ranges over all possibly-open terms <math>\\mathsf{}e</math> and <math>\\mathsf{}e'</math>.  The <tt>size</tt> derivation for the term <math>\\mathsf{}e</math> with a distinguished free variable <math>\\mathsf{}x</math> is represented by an LF term of higher type <tt>{x:tm} size x (s z) -> size (E x) N</tt>.  \n\nWe can prove this theorem in Twelf by giving a relation that satisfies the following totality assertion:\n<twelf discard=true>\nsubst-size : {E' : tm}\n\t       ({x : tm} size x (s z) -> size (E x) N)\n\t       -> size (E E') N'\n\t       -> plus Ndiff N N'\n\t       -> type.\n%mode subst-size +E' +D1 +D2 -DL.\n%worlds (size-block) (subst-size _ _ _ _).\n</twelf>\n\n== Proof attempt ==\n\nFor pedagogical purposes, we first present an incorrect proof attempt; the change required to fix this attempt is small.  The proof uses some straightforward lemmas about arithmetic:\n\n<twelf discard=true>\nplus-s-rh : plus N1 N2 N3 -> plus N1 (s N2) (s N3) -> type.\n%mode plus-s-rh +D1 -D2.\n%worlds () (plus-s-rh _ _).\n\nplus-commute : plus N1 N2 N3 -> plus N2 N1 N3 -> type.\n%mode plus-commute +D1 -D2.\n%worlds () (plus-commute _ _).\n\nlemma : plus N1 N2 Nsum\t      \n\t -> plus Ndiff1 N1 N1'\n\t -> plus Ndiff2 N2 N2'\n\t -> plus N1' N2' Nsum'\n\t -> plus Ndiff Nsum  Nsum'\n\t -> type.\n%mode lemma +X1 +X2 +X3 +X4 -X5.\n%worlds () (lemma _ _ _ _ _).\n</twelf>\n\nThe first two would be part of an arithmetic library; the third is a simple lemma that is proved directly using commutativity and associativity of addition.\n\nAdditionally, the proof of the theorem uses the following easy lemma: \n\n<twelf check=\"true\">\nsize-at-least-one : size E N\n\t\t      -> plus (s z) N' N\n\t\t      -> type.\n%mode size-at-least-one +X1 -X2.\n\n- : size-at-least-one _ (plus-s plus-z).\n\n%worlds (size-block) (size-at-least-one _ _).\n%total {} (size-at-least-one _ _).\n</twelf>\n\nThis relation is total because every way to create a term of type <tt>size E N</tt> syntactically produces a term of type <tt>size E (s N')</tt> for some <tt>N'</tt>.  The input coverage checker notices this fact by splitting and therefore validates this simple proof.  \n\nNext, we attempt a proof of the theorem:\n\n<twelf>\nsubst-size : {E' : tm}\n\t       ({x : tm} size x (s z) -> size (E x) N)\n\t       -> size (E E') N'\n\t       -> plus Ndiff N N'\n\t       -> type.\n%mode subst-size +E' +D1 +D2 -DL.\n\n- : subst-size E'\n     ([x] [dx] dx)\n     D\n     Dplus'\n     <- size-at-least-one D Dplus\n     <- plus-commute Dplus Dplus'.\n     \n- : subst-size E'\n     ([x] [dx] size-empty)\n     size-empty\n     plus-z.\n\n- : subst-size E'\n     ([x] [dx] \n\t(size-lam ([y] [dy] D x dx y dy)\n\t   %% tell reconstruction that T doesn't depend on x\n\t   : size (lam T _) _))\n     (size-lam D')\n     Dplus'\n     <- ({y : tm}\n\t   {dy : size y (s z)}\n\t   subst-size E' ([x] [dx] D x dx y dy) (D' y dy) Dplus)\n     <- plus-s-rh Dplus Dplus'.\n\n- : subst-size E'\n     ([x] [dx] \n\tsize-app \n\t(Dplus : plus N1 N2 Nsum)\n\t((D2 x dx) : size (E2 x) N2)\n\t((D1 x dx) : size (E1 x) N1)\n\t)\n     (size-app \n\t(Dplus' : plus N1' N2' Nsum')\n\t(D2' : size (E2 E') N2')\n\t(D1' : size (E1 E') N1'))\n     DplusRes'\n     <- subst-size E' D1 \n\t(D1' : size (E1 E') N1')\n\t(Dplus1 : plus Ndiff1 N1 N1')\n     <- subst-size E' D2 \n\t(D2' : size (E2 E') N2')\n\t(Dplus2 : plus Ndiff2 N2 N2')\n     <- lemma Dplus Dplus1 Dplus2 Dplus' DplusRes\n     <- plus-s-rh DplusRes DplusRes'.\n\n%worlds (size-block) (subst-size _ _ _ _).\n</twelf>\n\nBy now, you should be getting good at reading relational Twelf proofs of metatheorems as the informal proofs they represent.  This proof is slightly more involved than those that we have seen before, but it involves no new machinery.  We call out some of the tricky parts of the proof:\n* The proof inducts over and case-analyzes the LF term of type <tt>{x:tm} size x (s z) -> size (E x) N</tt>.  By inversion, such a term has the form <tt>[x] [dx] M</tt> where <tt>M : size (E x) N</tt>.  Thus, the proof includes one case for each possible <tt>M</tt>.  This includes each constructor of type <tt>size</tt>, along with the distinguished variable <tt>x</tt>.  \n* Make sure you understand why each constant world checks: The <tt>subst-size</tt> premise of the case for <tt>size-lam</tt> is in an extended context, but that this context stays in the appropriate world.  Additionally, by world subsumption, <tt>(size-block)*</tt> subsumes the world containing only the empty context for the arithmetic lemmas.  \n\nHowever, the totality check fails:\n<twelf check=\"decl\" discard=true>\n%total D (subst-size _ D _ _).\n</twelf>\n\nThis error message tells us that this proof does not cover the case for variables in the context itself.  That is, we forgot to cover the case when the size derivation is a variable (representing the use of a hypothesis) but is not the distinguished variable <tt>x</tt>.\n\n== Corrected proof ==\n\nTo fix the proof, we need to cover the case for other variables in the LF context.  But where can we put such a theorem case, since it needs to talk about the variable in the context?  The answer is that we can use LF hypotheses: we assume a case of the theorem <tt>subst-size</tt> in the LF context along with every assumption of <tt>x:tm,dx:size x (s z)</tt>.  This technique works because proofs of metatheorems are just LF constants of particular types.\n\nTo correct the proof, we work over contexts of a different form.  Only the <tt>size-lam</tt> case needs to change, so we elide the others:\n\n<twelf>\nsubst-size : {E' : tm}\n\t       ({x : tm} size x (s z) -> size (E x) N)\n\t       -> size (E E') N'\n\t       -> plus Ndiff N N'\n\t       -> type.\n%mode subst-size +E' +D1 +D2 -DL.\n\n- : subst-size E'\n     ([x] [dx] \n\t(size-lam ([y] [dy] D x dx y dy)\n\t   %% tell reconstruction that T doesn't depend on x\n\t   : size (lam T _) _))\n     (size-lam D')\n     Dplus'\n     <- ({y : tm}\n\t   {dy : size y (s z)}\n\t   {_ : {E' : tm} subst-size E'\n\t\t ([x : tm] [dx : size x (s z)] dy) \n\t\t dy \n\t\t plus-z}\n\t   subst-size E' ([x] [dx] D x dx y dy) (D' y dy) Dplus)\n     <- plus-s-rh Dplus Dplus'.\n\n%% ...\n</twelf>\n<twelf hidden=\"true\">\n- : subst-size E'\n     ([x] [dx] dx)\n     D\n     Dplus'\n     <- size-at-least-one D Dplus\n     <- plus-commute Dplus Dplus'.\n     \n- : subst-size E'\n     ([x] [dx] size-empty)\n     size-empty\n     plus-z.\n\n- : subst-size E'\n     ([x] [dx] \n\tsize-app \n\t(Dplus : plus N1 N2 Nsum)\n\t((D2 x dx) : size (E2 x) N2)\n\t((D1 x dx) : size (E1 x) N1)\n\t)\n     (size-app \n\t(Dplus' : plus N1' N2' Nsum')\n\t(D2' : size (E2 E') N2')\n\t(D1' : size (E1 E') N1'))\n     DplusRes'\n     <- subst-size E' D1 \n\t(D1' : size (E1 E') N1')\n\t(Dplus1 : plus Ndiff1 N1 N1')\n     <- subst-size E' D2 \n\t(D2' : size (E2 E') N2')\n\t(Dplus2 : plus Ndiff2 N2 N2')\n     <- lemma Dplus Dplus1 Dplus2 Dplus' DplusRes\n     <- plus-s-rh DplusRes DplusRes'.\n</twelf>\n<twelf check=\"decl\">\n%block ssblock : block {y : tm} \n\t\t       {dy : size y (s z)}\n\t\t       {_ : {E' : tm} subst-size E' ([x] [dx] dy) dy plus-z}.\n%worlds (ssblock) (subst-size _ _ _ _).\n%total D (subst-size _ D _ _).\n</twelf>\n\nThe block <tt>ssblock</tt> extends <tt>size-block</tt> with a case of the theorem: when the size derivation is <tt>dy</tt> from the context, the term <tt>E</tt> must be <tt>[_] y</tt>, so by inversion the derivation of <tt>size (([_] y) E') N'</tt> must be <tt>dy</tt> as well, in which case <tt>plus-z</tt> derives <tt>plus z (s z) (s z)</tt>.  The only other change is that the premise of the case for <tt>size-lam</tt> adds this extra assumption to the context.  In this world, the relation is indeed total.  \n\n== Correctness of the revised theorem statement ==\n\nWe set out to prove\n\n: For all Γ in <tt>(size-block)*</tt>, if <tt>Γ {{vdash}} E' : tm</tt> and <tt>Γ {{vdash}} D : {x:tm} size x (s z) -> size (E x) N</tt> and <tt>Γ {{vdash}} D' : size (E E') N'</tt> then there exist <tt>Ndiff</tt> and <tt>Dplus</tt> such that <tt>Γ {{vdash}} Dplus : plus Ndiff N N'</tt>.\n\nBut the corrected Twelf proof actually proves\n\n: For all Γ in <tt>(ssblock)*</tt>, if <tt>Γ {{vdash}} E' : tm</tt> and <tt>Γ {{vdash}} D : {x:tm} size x (s z) -> size (E x) N</tt> and <tt>Γ {{vdash}} D' : size (E E') N'</tt> then there exist <tt>Ndiff</tt> and <tt>Dplus</tt> such that <tt>Γ {{vdash}} Dplus : plus Ndiff N N'</tt>.\n\nDid we prove the right theorem?  Not necessarily: it is possible that the contexts in <tt>(ssblock)*</tt> do not cover all open terms, or that they include inadequate derivations of <tt>plus Ndiff N N'</tt>.  Thus, there is a danger here: we need to check that the second statement implies the first to see that we proved the right theorem.  \n\nIn this case, the implication holds.  The reason is that every context in <tt>(ssblock)*</tt> corresponds to a context in <tt>(size-block)*</tt> when restricted to those declarations subordinate to the types in the theorem statement.  That is, the context extension in <tt>(ssblock)*</tt> does not change the inhabitants of the types in the theorem statement—all it does is add a case of the proof type family <tt>subst-size</tt>, which is not subordinate to any of the subjects of the proof.  This is another argument that can be made formal using [[subordination]].  \n\nWhen you recast an informal theorem statement as a Twelf theorem statement, you need to check that the world of the theorem actually yields the theorem you had in mind.  However, in a large Twelf project, this obligation is usually not very large: Usually, a Twelf proof consists of a few top-level theorems of interest and many supporting lemmas.  In this case, you only need to check that these theorems correspond to what you had in mind; the various lemmas can mean whatever they mean, as long as they are strong enough to prove the overall theorem.\n\n== An even better proof ==\n\nPutting a case of a theorem in the context is a general technique that is useful in many circumstances.  However, in this example, we can avoid putting the theorem case in the context by using a [[catch-all case]], as the tutorial on that Twelf proof device explains.  \n\n{{proving metatheorems\n  | next = Summary: the STLC\n  | nextname = Summary\n  | prev = Proving metatheorems about the STLC\n  | prevname = Proving metatheorems}}"
          },
          "sha1": "az4cy0aefbvb0lvko13okrjug1ceb8l"
        }
      },
      {
        "title": "Proving metatheorems:Proving totality assertions about the natural numbers",
        "ns": 102,
        "id": 1781,
        "revision": {
          "id": 6181,
          "parentid": 4670,
          "timestamp": "2010-11-07T22:29:41Z",
          "contributor": {
            "username": "Sully",
            "id": 87
          },
          "comment": "Fix to not use deprecated TwelfTags that produce warnings",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 16209,
            "#text": "{{proving metatheorems\n  | next = Proving metatheorems about the natural numbers\n  | nextname = Proving metatheorems\n  | prev = Full LF\n  | prevname = Full LF}}\n\nIn this section, we will use Twelf to mechanize proofs of [[metatheorems]], which are statements about an object language.\nFirst, we recap the signature we have defined to this point, using the conveniences afforded by Twelf:\n\n<twelf export=\"base\">\nnat : type.\nz   : nat.\ns   : nat -> nat.\n\neven   : nat -> type.\neven-z : even z.\neven-s : even (s (s N))\n\t  <- even N.\n\nplus   : nat -> nat -> nat -> type.\nplus-z : plus z N2 N2.\nplus-s : plus (s N1) N2 (s N3)\n\t  <- plus N1 N2 N3.\n</twelf>\n\n==Totality assertions==\n\n<!--- ENH: could be better -->\n\nA type family such as <tt>plus</tt> defines a relation among its indices, where indices are related iff their instance of the family is inhabited by an LF term.  For example, <tt>plus</tt> defines a relation between three terms of type <tt>nat</tt>.  The terms (<tt>s (s z)</tt>, <tt>s z</tt>, <tt>s (s (s z))</tt>) are related by this relation (because 2 + 1 = 3), but the terms (<tt>z</tt>, <tt>s z</tt>, <tt>s (s (s z))</tt>) are not.\n\n[[Totality assertions]] are one class of statements about LF type families. A totality assertion for a type family is specified by designating some index positions as inputs and others positions as outputs.  We call this specification the [[%mode|mode]] of the totality assertion.  Given a mode specification, the totality assertion asserts that for all inputs, there exist outputs that stand in the relation. Using <tt>plus</tt> as an example, if we designate the first two positions as inputs and the third position as an output, this specifies the following totality assertion:\n\n: For all <tt>N1:nat</tt> and <tt>N2:nat</tt>, there exist <tt>N3:nat</tt> and <tt>D:plus N1 N2 N3</tt>.\n\nThat is, the sum of any two natural numbers exists.  Designating instead the first position as output and second and third positions as inputs defines the following totality assertion:\n\n: For all <tt>N2:nat</tt> and <tt>N3:nat</tt>, there exist <tt>N1:nat</tt> and <tt>D:plus N1 N2 N3</tt>.\n\nOf course, this totality assertion is false, as <tt>N3 - N2</tt> might not be a natural number.\n\nA totality assertion for an LF type family corresponds with the standard notion of totality for the relation defined by the family.  Proving a relation total is different from showing that the relation defines a function, as the outputs of a total relation are not necessarily unique&mdash;the relation may relate particular inputs to more than one collection of outputs.\n\nWe may prove a totality assertion by induction on canonical forms.  For example, we can prove the first above totality assertion by induction on <tt>N1:nat</tt>.  The second totality assertion above is actually false&mdash;for example, there is no <tt>N1</tt> such that <tt>plus N1 (s z) z</tt> is inhabited. \n\nTotality assertions for LF type families are actually more general than we have discussed so far.  The above examples consider only terms that are well-typed without mentioning LF variables. In general, it is useful to state totality assertions about all terms that are well-typed in any LF context in a particular [[world]], which is a set of LF contexts.  Thus, a totality assertion is specified by both a mode declaration and a world declaration.  For the time being, we will consider totality assertions that are stated for the world containing only the empty LF context (i.e., totality assertions about closed terms), so we defer further discussion of worlds.\n\n==Totality assertions in Twelf==\n\nYou can use Twelf to verify totality assertions about LF type families.  For example, to verify the totality assertion\n\n: For all <tt>N1:nat</tt> and <tt>N2:nat</tt>, there exist <tt>N3:nat</tt> and <tt>D:plus N1 N2 N3</tt>. \n\nyou enter the following Twelf declarations:\n\n<twelf import=\"base\" export=\"mwt\">\n%% declare totality assertion\n%mode plus +N1 +N2 -N3.\n%worlds () (plus _ _ _).\n\n%% check totality assertion\n%total N1 (plus N1 _ _).\n</twelf>\n\nLet's break down what each of these declarations means:\n* The <tt>[[%mode]]</tt> declaration specifies the mode of a type family&mdash;in this case, that <tt>N1</tt> and <tt>N2</tt> are universally quantified (<tt>+</tt>) and that <tt>N3</tt> is existentially quantified (<tt>-</tt>).  We will sometimes refer to the universally-quantified types as ''inputs'' and the existentially-quantified types as ''outputs''.  \n* The <tt>[[%worlds]]</tt> declaration states the totality assertion for LF terms in the empty context, which adequately represent natural numbers and the addition judgement.  \n* The <tt>[[%total]]</tt> declaration asks Twelf to prove the totality assertion by induction on the canonical forms <tt>N1</tt> of type <tt>nat</tt>.  Note that it is the position of the variable named in the <tt>%total</tt> that determines the induction index.\n\nIn this case, Twelf succeeds in proving this assertion.\n\n==How Twelf checks assertions==\n\nTwelf proves a totality assertion for a type family such as <tt>plus</tt> by checking several properties.  These properties, taken together, constitute a proof by induction on canonical forms that the type family defines a total relation.  \n\n===Mode===\n<!-- Do not change the name of this section without fixing the reference in %mode -->\nTwelf checks that each constant inhabiting the type family is ''well-moded''.  Roughly, this means that the inputs to the conclusion of a constant determine the inputs of the first premise, and that these together with the outputs of the first premise determine the inputs of the second premise, and so on, until the outputs of all the premises determine the outputs of the conclusion.  \n\nFor example, the constant\n<twelf discard=\"true\">\nplus-s : plus (s N1) N2 (s N3)\n\t  <- plus N1 N2 N3.\n</twelf>\nhas mode <tt>+N1 +N2 -N3</tt> because the input <tt>N1</tt> and <tt>N2</tt> in the conclusion determine the inputs of the premise, and the <tt>N3</tt> output by the premise determines the output of the conclusion.  On the other hand, a constant \n<twelf import=\"mwt\" export=\"badmode\" check=\"decl\">\nplus-bad-mode : plus N1 N2 N3.\n</twelf>\nis not well-moded&mdash;the output <tt>N3</tt> is not determined by the inputs.  Similarly, \n<twelf import=\"mwt\" export=\"badmode2\" check=\"decl\">\nplus-bad-mode2 : plus N1 N2 N3\n               <- plus N4 N2 N3.\n</twelf>\nis not well-moded&mdash;the first input to the premise is not determined by the inputs of the conclusion.\n\n===Worlds===\n\nTwelf checks that each constant inhabiting the type family obeys the worlds declaration.  Because we are only proving theorems about closed terms in this section, we will not run across any problems with world checks.  Consequently, we defer discussion of world checking until [[Proving metatheorems:Proving totality assertions in non-empty contexts|later]].\n\n===Termination===\n<!-- so that the later total, etc. don't complain -->\n<twelf import=\"base\" export=\"mw\" hidden=\"true\">\n%mode plus +X1 +X2 -X3.\n%worlds () (plus _ _ _).\n</twelf>\nTwelf checks that each constant inhabiting the type family obeys the induction order specified in the <tt>%total</tt> declaration.  In each inductive premise of a constant, the specified induction position must be a strict subterm of the corresponding argument in the conclusion.  For example, the constant\n<twelf discard=\"true\">\nplus-s : plus (s N1) N2 (s N3)\n\t  <- plus N1 N2 N3.\n</twelf>\nobeys the induction order <tt>N1</tt> specified in the above totality assertion because the term <tt>N1</tt> is a strict subterm of the term <tt>(s N1)</tt>.  On the other hand, Twelf would not accept the totality of <tt>plus</tt> if <tt>N2</tt> were used as the induction order&mdash;the same term <tt>N2</tt> in the conclusion of this constant appears in the premise:\n\n<twelf import=\"mw\" export=\"badtotal\" check=\"decl\">\n%total N2 (plus _ N2 _).\n</twelf>\n\nIn addition to the subterm ordering on a single argument, Twelf supports [[mutual induction]] and [[lexicographic induction]].\n\n===Output coverage===\n<twelf export=\"m\" import=\"base\">\n%mode plus +X1 +X2 -X3.\n</twelf>\n\nIn the definition of a type family, you may pattern-match the outputs of a premise.  For example, we might write\n<twelf import=\"m\" export=\"badoutput\" check=\"decl\">\nplus-bad-output : plus (s N1) N2 (s (s N3))\n                   <- plus N1 N2 (s N3).\n%worlds () (plus _ _ _).\n%total N1 (plus N1 N2 N3).\n</twelf>\n\nHere we have insisted that the output of the premise has the form <tt>s N3</tt> for some <tt>N3</tt>.  Twelf correctly reports an output coverage error because this condition can fail (for example, if the premise was <tt>plus-z : plus z z z</tt>).  \n\nPattern-matching the output of a premise is like an [[inversion]] step in a proof: you're insisting that the premise derivation must conclude a particular fact that is more specific than the judgement form itself.   For Twelf to accept a relation as total, Twelf must notice that all of these inversions are permissible.  Twelf permits such inversions when it is readily apparent that they are justified, and those inversions that Twelf does not accept can be proved explicitly.\n\nIn this example, we got an output coverage error because we constrained the output of the premise by insisting it be formed by a particular constant.  The other way to get output coverage errors is to insist that the output of a premise be a variable that occurs elsewhere in the type.  For example:\n<twelf import=\"m\" export=\"badoutputfreeness\" check=\"decl\">\nplus-bad-output-freeness : plus (s N1) N2 (s N2)\n                            <- plus N1 N2 N2.\n%worlds () (plus _ _ _).\n%total N1 (plus N1 N2 N3).\n</twelf>\nHere, we insisted that the output of the premise be the number <tt>N2</tt> that we put in.  Twelf is very conservative in checking [[output freeness]]: a type family will not be judged total if you constrain the outputs of any premise at all in this manner.\n\n===Input coverage===\n\nMode, worlds, termination, and output coverage ensure that each constant really does cover the part of the relation indicated by its conclusion.  For example, if <tt>plus</tt> passes these four checks, we know that <tt>plus-z</tt> and <tt>plus-s</tt> cover <tt>(z, N2, N2)</tt> and <tt>(s N1, N2, s N3)</tt>, respectively.  What else is necessary to know that <tt>plus</tt> defines a total relation?  We need to know that all the constants inhabiting <tt>plus</tt>, taken together, cover all of the inputs.  Input coverage checks exactly this.  \n\nFor example, if we forgot <tt>plus-z</tt>, input coverage for <tt>plus</tt> would fail.  For example:\n\n<twelf import=\"base\" discard=\"true\" check=\"decl\">\nplus' : nat -> nat -> nat -> type.\n%mode plus' +N1 +N2 -X3.\n\nplus-s' : plus' (s N1) N2 (s N3)\n          <- plus' N1 N2 N3.\n\n%worlds () (plus' _ _ _).\n%total N1 (plus' N1 _ _).\n</twelf>\n\nHere's an analogy that might be helpful: You can think of each constant of a type as being a clause in an ML pattern matching declaration.  Then input coverage is like the exhaustiveness checker for pattern matching.\nThe type family <tt>plus</tt> is exhaustive, but this <tt>plus'</tt> is not.\n\nTwelf checks input coverage by [[splitting]] the input types to case-analyze the various constants that could have been used to inhabit them.  For <tt>plus</tt>, Twelf splits the first <tt>nat</tt> argument <tt>N1</tt>, and then checks that the cases <tt>plus z N2 N2</tt> and <tt>plus (s N1) N2 N3</tt> are covered.  Fortunately, these are exactly the cases we wrote down.  If we had case-analyzed further in the definition of the judgement (e.g., if the definition of <tt>plus</tt> case-analyzed the second argument as well), Twelf would continue splitting the input space.  Because Twelf separates termination checking and coverage checking, the constants defining a type family do not need to follow any particular primitive recursion schema—the constants may pattern-match the inputs in a general manner.\n\n==When Twelf checks what==\n\nTo a first approximation, you can think of the <tt>%mode</tt> and <tt>%worlds</tt> declarations as specifying a totality assertion and the <tt>%total</tt> declaration as checking it.  This isn't exactly how Twelf works, though:\n\n# When a <tt>%mode</tt> declaration is entered, Twelf checks that all previous constants inhabiting the specified type family are well-moded; further, it then mode-checks any subsequent constants inhabiting that family.  \n# When a <tt>%worlds</tt> declaration is entered, Twelf world-checks the type family; further, it then reports an error if any new constants contributing to the family at all are added.\n# When a <tt>%total</tt> declaration is entered, Twelf checks termination, then input coverage, then output coverage.  When checking output coverage, Twelf checks for unjustified constant pattern-matching in a first pass and then output freeness problems in a second pass.\n\nThis separation allows you to, for example, check that each constant in a family is well-moded (i.e., takes specified inputs to specified outputs) without checking that the entire type family is total.  You can also use the declarations [[%terminates]] and [[%covers]] to check termination and input coverage independently.\n\nIf any constant in a type family fails mode, worlds, or output coverage, then mode, worlds, or totality checking fails for the whole type family.  One could imagine that Twelf instead would just disregard the offending constant: it is possible that the type family as a whole satisfies a totality assertion without that constant, and, in a mathematical sense, adding additional constants never invalidates the fact a totality assertion is true of a family.    The reason Twelf does not work this way is that <tt>%total</tt> actually has a more specific meaning, as we discuss in the next section.\n\n==Logic programming==\n\nAn LF signature can be interpreted as a logic program, where the constants defining a type family are viewed as rules for searching for derivations of that type family.  For example, we can use Twelf to add numbers as follows:\n<twelf import=\"mwt\" check=\"decl\">\n%solve D : plus (s z) (s z) N.\n</twelf>\nThis [[%solve]] declaration asks Twelf to find an <tt>N</tt> and a derivation <tt>D</tt> that <tt>plus (s z) (s z) N</tt>.  Of course, Twelf responds that 1 + 1 = 2.  \n\nThis logic programming interpretation of an LF signature is very useful: you can directly run the judgements defining your programming language.  However, because the focus of this introduction is proving metatheorems, an interested reader should refer to the tutorial on [[logic programming]].\n\nThe reason for bringing up logic programming here is that, when Twelf proves a totality assertion via <tt>%total</tt>, it actually proves a stronger statement than the totality assertion itself: Twelf proves that the type family defines a total logic program.  The above checks have an operational interpretation:\n* Mode: when called on [[ground]] inputs (i.e., concrete terms without [[unification]] variables), the logic program returns ground outputs.  \n* Worlds: all premises of every constant are in a context in the world specified by the premise's world declaration.\n* Termination: search for a derivation always terminates. \n* Output coverage: the output of a recursive call never fails to unify.  \n* Input coverage: the logic program covers all possible inputs.\n\nTo start proving metatheorems, it is not necessary to have a thorough understanding of the logic programming interpretation of the LF signature.  However, the logic programming view does explain some of the specifics of what Twelf will and will not deem total.  For example, mode checking considers premises in the order that it does (rather than, say, the reverse order) because that is the order in which the logic programming engine searches for derivations.\n\n==Summary==\n\nIn this section, we have seen how to ask Twelf to verify totality assertions for LF type families.  To see why we have spent so much time on totality assertions, proceed to the next section.  \n\n{{proving metatheorems\n  | next = Proving metatheorems about the natural numbers\n  | nextname = Proving metatheorems\n  | prev = Full LF\n  | prevname = Full LF}}"
          },
          "sha1": "k90j9x00koq4kx3h9puvqvj4f3z72n9"
        }
      },
      {
        "title": "Proving metatheorems:Proving totality assertions in non-empty contexts",
        "ns": 102,
        "id": 1893,
        "revision": {
          "id": 6207,
          "parentid": 6206,
          "timestamp": "2011-01-21T14:44:28Z",
          "contributor": {
            "ip": "128.93.60.46"
          },
          "comment": "/* World Checking */",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 12906,
            "#text": "{{proving metatheorems\n  | next = Proving metatheorems in non-empty contexts\n  | nextname = Proving metatheorems in non-empty contexts\n  | prev = Proving metatheorems about the STLC\n  | prevname = Proving metatheorems}}\n\nSo far, we have only proved relations total in the empty LF context.  In this section, we discuss proving totality assertions for relations in more general contexts.  As a motivating example, we define a judgement that computes the size of a STLC term.  \n\n== Definition of Size==\n\nThe definition of size uses the definitions of [[Proving metatheorems:Representing the syntax of the natural numbers|natural numbers]], [[Proving metatheorems:Representing the judgements of the natural numbers|addition judgement]], and [[Proving metatheorems:Representing the syntax of the STLC|STLC term syntax]] from earlier in this article.  \n<twelf export=\"syntax\" hidden=\"true\">\ntp    : type.\nunit  : tp.\narrow : tp -> tp -> tp.\n \ntm    : type.\nempty : tm.\nlam   : tp -> (tm -> tm) -> tm.\napp   : tm -> tm -> tm.\n\nnat : type.\nz   : nat.\ns   : nat -> nat.\n\nplus   : nat -> nat -> nat -> type.\n%mode plus +X1 +X2 -X3.\n\nplus-z : plus z N2 N2.\nplus-s : plus (s N1) N2 (s N3)\n\t  <- plus N1 N2 N3.\n\n%worlds () (plus _ _ _).\n%total N (plus N _ _).\n</twelf>\nInformally, we define the size of a term as follows:\n* <math>\\mathsf{}|x| = 1</math>\n* <math>|\\langle\\rangle| = 1</math>\n* <math>|e_1 \\; e_2| = 1 + |e_1| + |e_2|</math>\n* <math>\\mathsf{}|\\lambda x:\\tau.e| = 1 + |e|</math>\n\nWe define this function in LF using the following judgement:\n\n<twelf check=\"true\" import=\"syntax\" export=\"preworld\">\nsize       : tm -> nat -> type.\n%mode size +E -N.\n\nsize-empty : size empty (s z). \nsize-lam   : size (lam _ E) (s N)\n\t\t<- ({x : tm} \n                    {_ : size x (s z)}\n\t\t      size (E x) N).\nsize-app   : size (app E1 E2) (s N)\n\t\t<- size E1 N1\n\t\t<- size E2 N2 \n\t\t<- plus N1 N2 N.\n</twelf>\n\nThe only subtlety in this judgement is that we have recast size as a hypothetical judgement: each variable <tt>x:tm</tt> in the context is assumed to have size 1.  Correspondingly, the premise of the <tt>lam</tt> case extends the context with such an assumption for the bound variable.  \n\n== World Declarations ==\n\nWe would like to assert that every term has a size.  However, because the definition of the size judgement extends the LF context, our usual worlds declaration fails:\n<twelf import=\"preworld\" discard=true check=\"decl\">\n%worlds () (size _ _).\n</twelf>\n\nThe worlds declaration fails because <tt>size</tt> does not stay in the empty context.\n\nTo give an appropriate worlds declaration for this type family, we must first specify the form of the contexts in which we consider it.  We do so with a block declaration:\n\n<twelf import=\"preworld\" export=\"withworld\">\n%block size-block : block {x : tm} {_ : size x (s z)}.\n%worlds (size-block) (size _ _).\n</twelf>\n\nThe block declaration names a context block comprised of the assumptions <tt>x:tm, _:size x (s z)</tt>.  The world declaration declares <tt>size</tt> for any context composed of any number of <tt>size-blocks</tt>.  That\nis, it specifies that we consider <tt>size</tt> in the [[regular world]] <tt>(size-block)*</tt>.  \n\nIn general, Twelf permits regular world declarations of the form <tt>(b1 | b2 | ... | bn)*</tt> for blocks <tt>b1</tt> through <tt>bn</tt> defined by <tt>%block</tt> declarations.\n\n==World Checking==\n\nUp until this point, we have focused on the role a <tt>%worlds</tt> declaration has in specifying a totality assertion.  However, just as <tt>%mode</tt> both specifies the mode of a totality assertion and mode-checks a type family, <tt>%worlds</tt> both specifies the world of a totality assertion and ''world checks'' a type family.  \n\nWhat property does a world declaration specify?  Intuitively, a world declaration for a type family circumscribes the contexts in which we consider inhabitants of that type family.  For example, the world declaration for <tt>size</tt> says that we should only ever consider terms of type <tt>size</tt> in contexts in <tt>(sizeblock)*</tt>.  Thus, it is a world error if some piece of Twelf code introduces a variable <tt>x:tm</tt> but not a derivation <tt>_:size x (s z)</tt>, or if it introduces a variable <tt>_:size x z</tt>, or if it introduces a variable <tt>_:size empty N</tt>, and so on.  World checking ensures that we only consider a term in the contexts declared for its type.\n\nWhen Twelf processes a <tt>%worlds</tt> declaration, it world checks each constant in the type family. A constant ''world checks'' under the following condition: whenever the ambient LF context is of the form specified by the world declaration, each premise of the constant occurs in an LF context that is within the world specified for the premise's type family.  For example:\n* <tt>size-empty</tt> has no premises, so it vacuously world checks.\n* the <tt>size</tt> premise of <tt>size-lam</tt> is in an extended context, but adding <tt>x:tm,_:size x (s z)</tt> to a context in <tt>(size-block)*</tt> creates another context in <tt>(size-block)*</tt>.\n* the <tt>size</tt> premises of <tt>size-app</tt> do not extend the LF context, so they are in <tt>(size-block)*</tt> whenever the ambient context is.\n* the <tt>plus</tt> premise of <tt>size-app</tt> is '''not''' directly in a context in <tt>plus</tt>'s world (the world containing only the empty context) because the ambient LF context will contain variables of type <tt>tm</tt> and <tt>size</tt>.  However, the call to <tt>plus</tt> is permissible because of something called [[world subsumption]].\n\n===Subordination and world subsumption ===\n\nA context in <tt>(size-block)*</tt> has the form\n\n<tt>x:tm, _:size x (s z), ...</tt>\n\nThese contexts are not in the world for <tt>plus</tt>, which contains only the empty LF context.  Thus, it would seem that the call to <tt>plus</tt> from <tt>size</tt> should be deemed a world violation.  \n\nHowever,  considering derivations of <tt>plus</tt> in contexts of this form is in fact no different from considering these derivations in the empty context, because variables of type <tt>tm</tt> and <tt>size</tt> do not influence the set of terms of type <tt>plus</tt>.  That is, we are considering contexts outside of the world of <tt>plus</tt>, but the extra assumptions in the context are irrelevant to <tt>plus</tt>.  By improving our definition of world checking to account for circumstances like these, we can allow more world correct signatures, while maintaining the property that the world declaration circumcribes the '''relevant''' parts of the contexts in which we consider the terms of that type.  \n\nFormalizing this reasoning requires knowing when terms of one type can appear in terms of another.  This information is tracked by a [[subordination]] relation, which is a pre-order (reflexive and transitive binary relation) on type family constants.  Terms of a type <tt>a</tt> are only permitted to appear in terms of type <tt>b</tt> if <tt>a</tt> is subordinate to <tt>b</tt>.  In practice, Twelf infers a subordination relation from the Twelf signature that permits all relationships implied by the signature.\n\nUsing subordination, we define world subsumption as follows:\n\n: '''World subsumption:''' A world <tt>W'</tt> subsumes a world <tt>W</tt> for a type family <tt>a</tt> iff for all contexts Γ' in <tt>W'</tt>, there exists a context Γ in <tt>W</tt> such that Γ and Γ' are equal when restricted to only the declarations at types subordinate to <tt>a</tt>.\n\nFor example, <tt>(size-block)*</tt> subsumes the world containing only the empty context for <tt>plus</tt>.  On the other hand, the world <tt>({x:nat})*</tt> does not subsume the world containing only the empty context for <tt>plus</tt>, because adding variables representing more natural numbers is relevant to <tt>plus</tt>.\n\nUsing world subsumption, we refine our notion of world checking as follows. A constant world checks iff\n# The world of a type family subsumes the world of each of its premises.\n# Each premise's local assumptions stay in the world for that type family.\nThese conditions ensure that whenever the ambient LF context is of the form specified by the world declaration, for each premise of the constant, the world for the premise contains the restriction of the ambient context to the premise appended with the local assumptions made by the premise.\n\nUnder this more permissive definition, the <tt>plus</tt> premise of <tt>size</tt> is deemed world-correct.\n\n== Totality assertions in non-empty worlds ==\n\nWe now return to the role a world declaration has in specifying totality assertions.  The above mode and world declarations for <tt>size</tt> declare the following totality assertion:\n\n: For all LF contexts Γ in <tt>(size-block)*</tt>, if <tt>Γ {{vdash}} E : tm</tt> then there exist <tt>N</tt> such that <tt>Γ {{vdash}} N : nat</tt> and <tt>D</tt> such that <tt>Γ {{vdash}} D : size E N</tt>.\n\nThere are two things to note about this totality assertion:\n# It generalizes those that we have seen before, where the world always contained only the empty context and consequently the assertion was about closed terms.\n# The context is quantified at the outside and is consistent across all the indices to the type family.  That is, given inputs in a particular context, the relation returns outputs in that same context.\n\nTwelf verifies totality assertions in non-empty contexts in the same manner as before.  If a type family world checks, then the inductive hypothesis of a totality relation for a recursive premise (or the previously established totality assertion for a prior type family) will never fail to apply because of the form of the context.  Thus, the only differences in checking totality assertions for general contexts are that world checking may fail, and that coverage checking must account for variables from the context.  \n\nIn this case, Twelf succeeds in proving the totality of <tt>size</tt>.\n\n<twelf check=\"true\" import=\"withworld\" export=\"withtotal\">\n%total E (size E _).\n</twelf>\n\n== Example world errors ==\n\nIn this section, we show some example world errors.  For comparison, we collect the complete correct definition of <tt>size</tt> here:\n\n<twelf check=\"true\" import=\"syntax\" discard=true>\nsize       : tm -> nat -> type.\n%mode size +E -N.\n\nsize-empty : size empty (s z). \nsize-lam   : size (lam _ E) (s N)\n\t\t<- ({x : tm} \n                    {_ : size x (s z)}\n\t\t      size (E x) N).\nsize-app   : size (app E1 E2) (s N)\n\t\t<- size E1 N1\n\t\t<- size E2 N2 \n\t\t<- plus N1 N2 N.\n\n%block size-block : block {x : tm} {_ : size x (s z)}.\n%worlds (size-block) (size _ _).\n%total E (size E _).\n</twelf>\n\n=== Premise in an incorrect context ===\n\nOne possible world error is to write a premise whose local context extensions do not stay in the appropriate world.   For example, if we forgot the <tt>size</tt> assumption in the <tt>lam</tt> case, Twelf would report an error:\n\n<twelf import=\"preworld\" discard=true check=\"decl\">\nsize-lam   : size (lam _ E) (s N)\n\t\t<- ({x : tm} \t\t   \n                      size (E x) N).\n%block size-block : block {x : tm} {_ : size x (s z)}.\n%worlds (size-block) (size _ _).\n</twelf>\n\n=== World subsumption failure ===\n\nAnother possible world error is that world subsumption could fail.  For example, if <tt>size</tt> were stated for a  world containing natural number assumptions (which of course ruins the adequacy of <tt>nat</tt> for the natural numbers), it would not be permissible to call <tt>plus</tt>:\n\n<twelf import=\"preworld\" discard=true check=\"decl\">\n%block size-block : block {x : tm} {_ : size x (s z)}.\n%block natblock : block {x:nat}.\n%worlds (natblock | size-block) (size _ _).\n</twelf>\n\n=== Totality failure because of a forgotten assumption ===\n\nFinally, a type family can be world correct but fail to define a total relation if we consider the theorem in an improper world.  For example, say we had defined <tt>size</tt> as follows:\n\n<twelf check=\"decl\" import=\"syntax\" discard=true>\nsize       : tm -> nat -> type.\n%mode size +E -N.\n\nsize-empty : size empty (s z). \nsize-lam   : size (lam _ E) (s N)\n\t\t<- ({x : tm} size (E x) N).\nsize-app   : size (app E1 E2) (s N)\n\t\t<- size E1 N1\n\t\t<- size E2 N2 \n\t\t<- plus N1 N2 N.\n\n%block size-block : block {x : tm}.\n%worlds (size-block) (size _ _).\n%total E (size E _).\n</twelf>\n\nThis definition world checks because the context in <tt>size-lam</tt> is of the form specified by the world declaration.  However, the type family <tt>size</tt> does not define a total relation because it does not cover \nvariables <tt>x:tm</tt> in the LF context.  A total relation must cover both the LF constants in the signature and the LF variables in all contexts in the world.\n\n{{proving metatheorems\n  | next = Proving metatheorems in non-empty contexts\n  | nextname = Proving metatheorems in non-empty contexts\n  | prev = Proving metatheorems about the STLC\n  | prevname = Proving metatheorems}}"
          },
          "sha1": "5uwl6050evzbcgnrzzvr3sfx7sdbxr3"
        }
      },
      {
        "title": "Proving metatheorems:Representing the judgements of the STLC",
        "ns": 102,
        "id": 1890,
        "revision": {
          "id": 8152,
          "parentid": 4720,
          "timestamp": "2016-09-09T22:56:59Z",
          "contributor": {
            "username": "Nolrai",
            "id": 13742
          },
          "comment": "/* LF representation */",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 9015,
            "#text": "{{proving metatheorems\n  | prev = Representing the syntax of the STLC\n  | prevname = Representing syntax\n  | next = Proving metatheorems about the STLC\n  | nextname = Proving metatheorems}}\n\n== Static semantics ==\n\n=== Informal definition ===\n\nThe typing rules for the simply typed lambda calculus use a typing context <math>\\texttt{}\\gamma</math> containing assumptions of the form <math>\\mathsf{}x : \\tau</math>. Such a context is well-formed when all variables in it are distinct.\n\n<math>{ \\; \\over \\gamma, x : \\tau, \\gamma' \\vdash x : \\tau}\\,\\mbox{of-var}</math>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \n<math>{ \\gamma , x : \\tau_2 \\vdash e : \\tau \\over \\gamma \\vdash \\lambda x:\\tau_2.e : (\\tau_2 \\rightarrow \\tau)}\\,\\mbox{of-lam}</math>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \n\n\n<math>{ \\; \\over \\gamma \\vdash \\langle\\rangle : \\texttt{unit}}\\,\\mbox{of-empty}</math>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \n<math>{ \\gamma \\vdash e_1 : (\\tau_2 \\rightarrow \\tau) \\qquad \\gamma \\vdash e_2 : \\tau_2 \\over \\gamma \\vdash e_1 e_2 : \\tau}\\,\\mbox{of-app}</math>\n\nThis is a ''hypothetical judgement'', which means that the following structural properties are true:\n* Hypothesis: <math>\\gamma,x : \\tau \\vdash x : \\tau</math>.\n* Weakening: if <math>\\gamma \\vdash e : \\tau</math> and <math>\\mathsf{}x</math> is fresh then <math>\\gamma,x:\\tau' \\vdash e : \\tau</math>.\n* Exchange: if <math>\\gamma,x:\\tau_1,y:\\tau_2 \\vdash e : \\tau</math> then <math>\\gamma,y:\\tau_2,x:\\tau_1 \\vdash e : \\tau</math>.\n* Substitution: if <math>\\gamma,x : \\tau' \\vdash e : \\tau</math> and <math>\\gamma \\vdash e' : \\tau'</math> then <math>\\gamma \\vdash \\{e'/x\\}e : \\tau</math>.\n\nHypothesis is derivable by the rule <math>\\mbox{of-var}</math>.  Weakening, exchange, and substitution are admissible.\n\n=== LF representation ===\n\nIn the previous section, we used LF binding to represent object-language variables.  In this section, we use LF binding to represent object-language hypothetical judgements.  The following LF signature represents the above judgement <math>\\gamma \\vdash e : \\tau</math> with the LF type family <tt>of</tt>.  \n\n<twelf>\nof       : tm -> tp -> type.\nof-empty : of empty unit.\nof-lam   : of (lam T2 ([x] E x)) (arrow T2 T)\n            <- ({x: tm} of x T2 -> of (E x) T).\nof-app   : of (app E1 E2) T\n            <- of E1 (arrow T2 T)\n            <- of E2 T2.\n</twelf>\n\nThe first thing to note is that the type family is indexed by a <tt>tm</tt> and a <tt>tp</tt> but '''not''' a representation of the context <math>\\gamma</math>.  The reason for this is that we identify the object-language context with the LF context.  Specifically, an object-language assumption <math>x:\\tau</math> does two things:\n* It binds the variable <math>\\mathsf{}x</math>.\n* It declares a typing assumption <math>x : \\tau</math>.\n\nThus, an object-language assumption <math>x:\\tau</math> is represented by the following two LF assumptions:\n\n<tt>x : tm,  dx : of x T </tt> (where <tt>T</tt> is the encoding of <math>\\tau</math>).  \n\nThe first LF variable represents an object-language term <tt>x</tt>, as per the encoding of syntax in the previous section.  The second variable represents a derivation that <tt>of x T</tt>.  Consequently, there is no LF constant corresponding to the rule <math>\\mbox{of-var}</math>; uses of this rule are represented by uses of the corresponding LF variable <tt>dx</tt>.\n\nThis representation of hypotheses gives rise to the higher-order premise of the constant <tt>of-lam</tt>, which has type \n\n<tt>{x: tm} of x T2 -> of (E x) T</tt>\n\nAn LF term of this type has the form <tt>([x] [dx: of x T2] M)</tt>, where <tt>M : of (E x) T</tt> ''in an LF context extended with <tt>x : tm,  dx : of x T2</tt>''.  Thus, <tt>M</tt> is the representation of an object-language derivation under the additional assumption <math>\\mathsf{}x:\\tau</math>.\n\nThe constants <tt>of-empty</tt> and <tt>of-app</tt> correspond to the informal inference rules of the same name; they are no more complicated than the rules for the judgements on natural numbers from the previous sections.\n\nSome examples may help clarify the intended representation:\n\n{{needs|examples}}\n\n'''Eta-expansion.''' As we mentioned [[Proving metatheorems:Full LF|before]], Twelf permits programmers to write non-eta-expanded terms, which it treats as syntactic sugar for their eta-expansions.  For example, we could equivalently have written:\n<twelf>\nof-lam  : of (lam T2 E) (arrow T2 T)\n            <- ...\n</twelf>\nThis version differs from <tt>of-lam</tt> above in that the term <tt>E</tt> is not eta-expanded.  Some consider it good Twelf style to write terms in a fully eta-expanded ([[eta-long]]) form, because (1) the eta-expanded terms are the canonical forms of LF, and (2) the eta-expansion makes the binding structure apparent in the syntax, without knowing the types of the involved constants.  On the other hand, readers who know the types of the constants may find the eta-short version easier to read.\n\n=== Theorems for free ===\n\nThere are several advantages to using this higher-order representation of a hypothetical judgement, as opposed to a first-order representation where the context is treated explicitly.  \n\nFirst, the representation is quite succinct: there is no need define and work with auxiliary data structures like lists of distinct assumptions.  \n\nMore importantly, this representation gives the structural properties of the hypothetical judgement for free: the structural properties for the object language are inherited from the corresponding properties of LF.  For instance, there is no need to prove a substitution lemma about the object language. As an example, we can derive\n\n<tt>T:tp, T2:tp. E:tm->tm, E2:tm, D1:({x : tm} of x T2 -> of (E x) T), D2:(of E2 T2) {{vdash}} D1 E2 D2 : of (E E2) T</tt>\n\nThe term <tt>D1 E2 D2</tt> represents a derivation that the substitution <tt>(E E2)</tt> is well-typed.  (We call the LF application  <tt>(E E2)</tt> a substitution because when <tt>E</tt> is substituted by an actual term <tt>[x] M</tt>, the application will reduce to <tt>[E2/x]M</tt>.)\n\n=== Adequacy ===\n\nThe adequate theorem for typing derivations is as follows:\n\n: ''Adequacy for typing:'' There is a compositional bijection between informal derivations of <math>x_1 : \\tau_1 \\ldots \\vdash e : \\tau</math> and LF terms <tt>D</tt> such that <tt>x1 : tm, dx1 : of x1 T1, ... {{vdash}} D : of E T</tt>, where <math>e \\gg \\texttt{E}</math>, <math>\\tau \\gg \\texttt{T}</math>, and <math>\\tau_1 \\gg \\texttt{T1}</math>, ... .\n\nTo prove this adequacy theorem, it is necessary to show that STLC terms and types remain adequately represented when considered in LF contexts of this form.  Intuitively, adding canonical forms of type <tt>of</tt> does not change the canonical forms of types <tt>tp</tt> and <tt>tm</tt> because STLC typing derivations cannot appear in STLC types or terms.  This kind of argument can be made precise using [[subordination]].\n\n== Dynamic semantics ==\n\n=== Informal definition ===\n\nWe define the dynamic semantics of the STLC by a call-by-value, left-to-right structural operational semantics on closed terms.  \n\nThe judgement <math>e \\; \\mathsf{value}</math> identifies the values:\n\n<math>{ \\; \\over \\mathsf{empty} \\; \\mathsf{value}} \\, \\mbox{value-empty}</math>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n<math>{ \\; \\over \\lambda x:\\tau.e \\; \\mathsf{value}} \\, \\mbox{value-lam}</math>\n\nNext, we define the operational semantics with a judgement <math>e \\mapsto e'</math>:\n\n<math>{e_1 \\mapsto e_1' \\over e_1 \\, e_2 \\mapsto e_1' \\, e_2} \\, \\mbox{step-app-1}</math>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n<math>{e_1 \\; \\mathsf{value} \\;\\;\\; e_2 \\mapsto e_2' \\over e_1 \\, e_2 \\mapsto e_1 \\, e_2'} \\, \\mbox{step-app-2}</math>\n\n<math>{e_2 \\; \\mathsf{value} \\over (\\lambda x:\\tau.e) \\, e_2 \\mapsto \\{e_2/x\\} e } \\mbox{step-app-beta}</math>\n\n=== LF representation ===\n\nThese judgements are represented in LF in the usual fashion.  The closed LF terms of these types adequately represent the above judgements.\n\n<twelf>\nvalue       : tm -> type.\nvalue-empty : value empty.\nvalue-lam   : value (lam T ([x] E x)).\n\nstep          : tm -> tm -> type.\nstep-app-1    : step (app E1 E2) (app E1' E2)\n                 <- step E1 E1'.\nstep-app-2    : step (app E1 E2) (app E1 E2') \n                 <- value E1\n                 <- step E2 E2'.\nstep-app-beta : step (app (lam T2 ([x] E x)) E2) (E E2)\n                 <- value E2.\n</twelf>\n\nIn <tt>step-app-beta</tt>, the right-hand term is the application <tt>E E2</tt>, which represents the substitution on the right-hand side of the informal rule.\n\nAnd that completes our representation of the STLC in LF.  Now, we can start proving metatheorems about the language using Twelf.\n\n{{proving metatheorems\n  | prev = Representing the syntax of the STLC\n  | prevname = Representing syntax\n  | next = Proving metatheorems about the STLC\n  | nextname = Proving metatheorems}}"
          },
          "sha1": "s70mhprb4itfwnfn5jlh43e1tt04ks5"
        }
      },
      {
        "title": "Proving metatheorems:Representing the judgements of the natural numbers",
        "ns": 102,
        "id": 1778,
        "revision": {
          "id": 5365,
          "parentid": 4726,
          "timestamp": "2008-07-25T21:13:13Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "comment": "/* Adequacy */",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 7998,
            "#text": "{{proving metatheorems\n  | prev = Simply typed LF\n  | prevname = Simply typed LF\n  | next = Full LF\n  | nextname = Full LF}}\n\nNow that we've seen how to represent the syntax of a deductive system, we turn to representing judgements.  Our first example is the judgement that a number is even.\n\n==Even numbers==\n\n===Informal definition===\n\nThe judgement <math>\\mathsf{even}(n)</math> holds when <math>\\texttt{}n</math> is even.  It is inductively defined by the following inference rules:\n\n<table style=\"margin-left:auto;margin-right:auto\" cellpadding=\"24\">\n<tr><td>\n<math>{\\qquad} \\over {\\mathsf{even}(\\mathsf{zero})}\n</math>\n</td><td>\n<math>\n{\\mathsf{even}(n)} \\over {\\mathsf{even}(\\mathsf{succ}(\\mathsf{succ}(n)))}\n</math>\n</td></tr>\n</table>\n\n===LF representation===\n\nIn the previous sections, we saw how to represent object-language syntax as the inhabitants of LF types.  At a high level, the LF methodology for representing judgements is exactly analogous: we represent an object-language judgement with an LF type, where the inhabitants of this type correspond exactly to derivations of the judgement.\n\nHowever, to adequately represent judgements, we must generalize from simply-typed LF to dependently-typed LF.  A moment's thought reveals why a dependently-typed language is appropriate: Object-language judgements are parametrized by their subjects&mdash;for example <math>\\mathsf{even}(n)</math> is parametrized by the number <math>\\texttt{}n</math> being judged to be even.  Consequently, to represent judgements themselves as LF types, we should consider LF types that are parametrized by the subjects of object-language judgements.  But the judgement subjects&mdash;the syntax of the language&mdash;are represented as LF terms.  Thus, to represent judgements themselves as LF types, it is natural to consider families of LF types parameterized by LF terms.  \n\nFor example, we represent the judgement <math>\\mathsf{even}(n)</math> using the following signature:\n<twelf hidden=\"true\">\nnat : type.\nz   : nat.\ns   : nat -> nat.\n</twelf>\n<twelf>\neven    : nat -> type.\neven-z  : even z.\neven-s  : {N:nat} even N -> even (s (s N)).\n</twelf>\n\nThe first declaration says that <tt>even</tt> is a family of types indexed by a <tt>nat</tt>.  This means that for every term <tt>N : nat</tt>, there is a type <tt>even N</tt>.  Note that the syntax <tt>-></tt> is overloaded: it is used to classify both type-level families and and term-level functions.  We then use this type\nfamily to define the types of two term constants.\n\nThe first term constant, <tt>even-z</tt>, has type <tt>even z</tt>.  This constant represents the derivation that consists of the first inference rule above, which concludes <math>\\mathsf{even}(\\mathsf{zero})</math>.  \n\nThe second term constant <tt>even-s</tt>, corresponds to the second inference rule above, which, for any <math>\\texttt{}n</math>, constructs a derivation of <math>\\mathsf{even}(\\mathsf{succ}(\\mathsf{succ}(n)))</math> from a derivation of <math>\\mathsf{even}(n)</math>.  To encode this inference rule, the constant <tt>even-s</tt> is given a [[dependent type|dependent function type]].  \n\nThe syntax <tt>{x:A1} A2</tt> represents a dependent function type, which is a generalization of the ordinary function type <tt>A1 -> A2</tt> that allows the argument term <tt>x</tt> to appear in <tt>A2</tt>.  We write the ordinary function type <tt>-></tt> as a synonym when the argument is not free in the result type (i.e., <tt>A1 -> A2</tt> means <tt>{_:A1} A2</tt>).  Just as with the ordinary function type, LF terms of dependent function type can be applied to a term of the argument type to form a new term.\n\nAs an example, the constant <tt>even-s</tt> can be applied to a term <tt>N:nat</tt> and then a term of type \n<tt>even N</tt> ''for that <tt>N</tt>'' to create a term of type <tt>even (s (s N))</tt> (again, for that <tt>N</tt>).  The dependent function type is used to bind the variable <tt>N</tt> in the type <tt>(even N -> even (s (s N)))</tt>, expressing that the inference rule is schematic in <math>\\texttt{}n</math>.\n\nWhen a term of dependent function type is applied to an argument, the argument is substituted into the result type.  For example, the term <tt>even-s z</tt> has type <tt>even z -> even (s (s z))</tt>—i.e., it is the specialization of the inference rule to <math>n = \\mathsf{zero}</math>.  Thus, the term\n\n<!-- syntax highlighting looks weird when it's not actually Twelf code -->\n<pre>even-s z even-z\n</pre>\n\n(where we adopt the usual convention that application is left-associative) represents the derivation\n\n<center>\n<math>\n{\\overline{\\mathsf{even}(\\mathsf{zero})}}\n\\over \n{\\mathsf{even}(\\mathsf{succ}(\\mathsf{succ}(\\mathsf{zero})))}\n</math>\n</center>\n\nThe term <tt>even-s (s (s z)) (even-s z even-z)</tt> represents a derivation that 4 is even, and so on.\n\nTo summarize, dependently-typed LF refines the type level of simply-typed LF with dependent function types and families of types parametrized by LF terms.  The terms of LF remain unchanged from the grammar presented in the previous section.  These changes are sufficient for representing judgements as LF type families and derivations as LF terms.\n\n===Adequacy===\n\nTo check that this LF representation is correct ([[adequacy|adequate]]), we must verify that there is a bijection between the derivations of <math>\\mathsf{even}(n)</math> and the LF terms of type <tt>even N</tt> where <math>n \\gg N</math>.  In particular, this LF signature adequately represents natural numbers and derivations of <math>\\mathsf{even}(n)</math> when considered in the empty LF context. It would not be adequate in contexts containing assumptions of the form <tt>x : nat</tt> (which don't correspond to any natural number) or <tt>d : even N</tt> (which don't correspond to any of the rules for deriving <math>\\mathsf{even}(n)</math>.\n\nPart of establishing this bijection requires reasoning by induction on the canonical forms of type <tt>even N</tt>, which corresponds to rule induction on the informal judgement.  The definition of the encoding and the proof of adequacy are simple; interested readers are referred to the literature for examples.\n\n{{needs|references to the literature}}\n\n==Addition==\n\n===Informal definition===\n\nAddition can be represented as a judgement relating two natural numbers to their sum:\n\n<table style=\"margin-left:auto;margin-right:auto\" cellpadding=\"24\">\n<tr><td>\n<math>{\\qquad} \\over {\\mathsf{plus}(\\mathsf{zero},n_2,n_2)}\n</math>\n</td><td>\n<math>\n{\\mathsf{plus}(n_1,n_2,n_3)} \\over\n{\\mathsf{plus}(\\mathsf{succ}(n_1), n_2, \\mathsf{succ}(n_3))}\n</math>\n</td></tr>\n</table>\n\nThis judgement defines addition by induction on the first argument.\n\n===LF representation===\n\nThis judgement is represented by the following LF signature:\n\n<twelf>\nplus   : nat -> nat -> nat -> type.\nplus-z : {N2:nat} plus z N2 N2.\nplus-s : {N1:nat} {N2:nat} {N3:nat} plus N1 N2 N3 -> plus (s N1) N2 (s N3).\n</twelf>\n\nThe type family <tt>plus</tt> is indexed by three terms of type <tt>nat</tt> because the informal judgement has three parameters.  The constants correspond to the two inference rules, inhabiting the type family with terms representing derivations.  For example, the term\n\n<pre>plus-s (s z) (s z) (s (s z)) \n       (plus-s z (s z) (s z) \n               (plus-z (s z)))\n</pre>\n\nwhich has type <tt>plus (s (s z)) (s z) (s (s (s z)))</tt>, represents a derivation that 2 + 1 = 3.\n\n===Adequacy===\n\nTo check correctness of this representation, we must verify that there is a bijection between derivations of <math>\\mathsf{plus}(n_1,n_2,n_3)</math> and LF terms of type\n<tt>plus N1 N2 N3</tt> where <math>n_i \\gg N_i</math>.  Once again, the definition of the encoding judgement and the adequacy proof are simple.\n\nThese adequacy theorems will be more precise after we review the full language of dependently typed LF in the next section.\n\n\n{{proving metatheorems\n  | prev = Simply typed LF\n  | prevname = Simply typed LF\n  | next = Full LF\n  | nextname = Full LF}}"
          },
          "sha1": "334ny7njop0wtvpbjd1ymrqftmtwpte"
        }
      },
      {
        "title": "Proving metatheorems:Representing the syntax of the STLC",
        "ns": 102,
        "id": 1889,
        "revision": {
          "id": 6073,
          "parentid": 4654,
          "timestamp": "2010-04-22T01:22:54Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "comment": "/* Informal definition */",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 7337,
            "#text": "{{proving metatheorems\n  | prev = Summary: the natural numbers\n  | prevname = Summary\n  | next = Representing the judgements of the STLC\n  | nextname = Representing judgements}}\n\nIn this section, we discuss how to represent the syntax of a simply typed λ-calculus in LF.\n\n== Representing STLC types ==\n\nWe consider a λ-calculus with <math>\\mathsf{unit}</math> as a base type:\n\n<math>\\tau ::= \\mathsf{unit} \\,|\\, \\tau_1 \\rightarrow \\tau_2</math>\n\nThe representation of types is no more complicated than the representation of natural numbers in the previous section:\n\n<twelf>\ntp    : type.\nunit  : tp.\narrow : tp -> tp -> tp.\n</twelf>\n\nWe leave it to the reader to formulate an appropriate encoding judgement between STLC types <math>\\texttt{}\\tau</math> and closed LF terms of type <tt>tp</tt> and to prove that this encoding is adequate in the usual sense.  \n\n== Representing STLC terms ==\n\n=== Informal definition ===\n\nThe terms of the STLC are variables <math>\\mathsf{}x</math>, the 0-element tuple, lambda abstraction (with a type annotation), and application:\n\n<math>e ::= x \\,|\\, \\langle\\rangle \\,|\\, \\lambda x :\\tau . e \\,|\\, e_1 \\, e_2</math>\n\nThe variable <math>\\mathsf{}x</math> is considered to be bound by the expression <math>\\lambda x :\\tau . e</math>.  Following standard practice, we implicitly consider terms modulo renaming of bound variables.\n\n=== LF representation ===\n\nWe represent these terms in LF with the following signature:\n\n<twelf>\ntm    : type.\nempty : tm.\napp   : tm -> tm -> tm.\nlam   : tp -> (tm -> tm) -> tm.\n</twelf>\n\nThe representation of <math>\\langle\\rangle</math> as <tt>empty</tt> and application as <tt>app</tt> is standard.  The questions you are probably asking are:\n# How does this LF signature represent variables <math>\\mathsf{}x</math>?, and\n# What's going on with the type of <tt>lam</tt>?\n\nThe answer is that we are using a representation technique called ''higher-order abstract syntax'' (HOAS): we use LF variables to represent object-language variables.  Here are some example representations: \n\n{| border=\"1\" cellpadding=\"5\" cellspacing=\"0\"\n|-\n| '''Informal Syntax''' || '''LF Representation'''\n|-\n| <math>\\mathsf{}x</math>\n| <tt>x</tt>\n|-\n| <math>\\mathsf{}x \\, \\langle\\rangle</math>\n| <tt>app x empty</tt>\n|-\n| <math>\\lambda x:(\\mathsf{unit} \\rightarrow \\mathsf{unit}). x \\, \\langle\\rangle</math>\n| <tt>lam (arrow unit unit) ([x] app x empty)</tt>\n|}\n\nAs you can see, we represent an object-language variable by an LF variable with the same name.  Thus, to represent an object-language term <math>\\lambda x :\\tau . e</math>, we first represent the body <math>\\mathsf{}e</math> as an LF term <tt>M</tt> in which the LF variable <tt>x</tt> occurs free.  Then, we bind this variable using an LF abstraction <tt>[x] M</tt>.  This abstraction, which represents the body of the object-language λ, has LF type <tt>tm -> tm</tt>.  This explains the higher-order type of the constant <tt>lam</tt>.\n\nUsing higher-order abstract syntax (HOAS) in this fashion makes two operations on syntax primitive:\n* '''α-equivalence''': Because LF terms are considered modulo α-renaming of bound variables, and LF bound variables are used to model object-language bound variables, the type <tt>tm</tt> represents α-equivalence classes of object-language terms.  For example, because there is no way to distinguish <tt>([x] app x empty)</tt> and <tt>([y] app y empty)</tt> in LF, so there is no way to distinguish <tt>lam (arrow unit unit) ([x] app x empty)</tt> and <tt>lam (arrow unit unit) ([y] app y empty)</tt>.  \n* '''capture-avoiding substitution''': an object-language substitution, written <math>\\{e_2/x\\}e</math>, is modeled by an LF substitution <tt>[E2/x] E</tt>.  \n\n=== Adequacy ===\n\nThe adequacy theorem for terms shows that the LF operations correctly implement the object-language operations:\n\n: '''Adequacy for terms:''' There is a bijection <math>e \\gg \\texttt{E}</math> between (α-equivalence classes of) STLC terms <math>\\mathsf{}e</math> with free variables in <math>\\mathsf{}x_1,\\ldots,x_n</math> and (α-equivalence classes of) LF terms <tt>E : tm</tt> in the LF context <tt>x1:tm, ..., xn:tm</tt>.  \n\n: Moreover, this bijection is compositional in the following sense: if <math>e \\gg \\texttt{E}</math> and <math>e' \\gg \\texttt{E'}</math> then <math>\\{e'/x\\}e \\gg \\texttt{[E'/x] E}</math>.  \n\nIf you're interested in the details of how this adequacy theorem is stated and proved, you can read more about it in the literature<ref>{{bibtex:hl07mechanizing}}</ref>.  However, there are a few high-level ideas in this proof that we should call out here:\n\n'''Adequacy for terms requires adequacy for types.'''  Because the syntax of terms mentions the syntax of types, the proof of adequacy for terms requires knowing that <tt>tp</tt> adequately represents types <math>\\mathsf{}\\tau</math>.  Above, we (well, you) proved that types <math>\\mathsf{}\\tau</math> are adequately represented by ''closed'' LF terms of type <tt>tp</tt>.  Thus, there is a danger here: the syntax of STLC types might not be adequately represented in the LF contexts we consider here, which have the form <tt>x1:tm, ..., xn:tm</tt>.  \n\nIn fact, the representation of STLC types remains adequate in contexts of this form because adding variables of type <tt>tm</tt> to the context does not change the canonical forms of type <tt>tp</tt>.  This kind of argument can be made precise using [[subordination]], which tracks when terms of one type may appear in terms of another.  Informally, the idea is that the canonical forms of a type only depend on the canonical forms of subordinate types.  Here, <tt>tm</tt> is not subordinate to <tt>tp</tt> (because STLC terms do not appear in STLC types), so adding canonical forms of type <tt>tm</tt> does not change the canonical forms of type <tt>tp</tt>.  We will discuss another application of subordination [[Proving metatheorems:Proving totality assertions in non-empty contexts|later in this article]].\n\n'''The power of weak frameworks.''' When we consider closed LF terms of type <tt>nat</tt> or <tt>tp</tt>, the only possible terms of those types are applications of the appropriate constants.  The reason our higher-order representation of STLC terms works in LF is that, when we consider open LF terms in contexts containing assumptions <tt>x:tm</tt>, the only LF terms of type <tt>tm</tt> are either those variables or applications of the appropriate constants.  \n\nSpecifically, it is important that LF does not provide any elimination forms for constants.  For example, suppose LF provided a <tt>case</tt> construct for case-analyzing the terms of a type, as one would have if <tt>tm</tt> were considered to be an inductive definition within the type theory.  Then the term <tt>([x:tm] case x of empty => empty | ...)</tt> would need to be considered a canonical form of type <tt>tm -> tm</tt> (without knowing what the variable stands for, there is no way to reduce the case).  However, this term does not correspond to any object-language term-with-a-free-variable, so having such a case construct would ruin the adequacy of the representation.  \n\n== References ==\n\n<references/>\n\n{{proving metatheorems\n  | prev = Summary: the natural numbers\n  | prevname = Summary\n  | next = Representing the judgements of the STLC\n  | nextname = Representing judgements}}"
          },
          "sha1": "gvzjjrmfox9clghck82odzhzc2emxqz"
        }
      },
      {
        "title": "Proving metatheorems:Representing the syntax of the natural numbers",
        "ns": 102,
        "id": 1772,
        "revision": {
          "id": 5717,
          "parentid": 5120,
          "timestamp": "2008-12-20T05:19:04Z",
          "contributor": {
            "ip": "208.127.103.162"
          },
          "comment": "/* LF representation */ typo",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 5945,
            "#text": "{{proving metatheorems\n   |noprevious=\n   |next= Simply typed LF\n   |nextname=Simply typed LF}}\n\nTo use Twelf, you need to know how to represent [[deductive systems]] using the LF logical framework.  LF is a very convenient language for representing deductive systems that involve [[variable binding]] and [[hypothetical judgement]]s, such as programming languages and logics. However, we won't see any examples of such uses of LF until [[Proving metatheorems:Representing the syntax of the STLC|later]]. The goal of the first part of this guide is to take a broad sweep through LF and Twelf; you will see how to represent and prove properties of a very simple language, which will prepare you for more sophisticated (and more impressive) content later on.\n\nOur first task is to introduce LF and see how to represent the syntax of a deductive system in it. We refer to a language that we are formalizing in LF as an [[object language]] (i.e., it is the object of our study).  In contrast, we sometimes refer to LF as the [[meta-language]]. To keep things simple, we use the natural numbers as first example object language.\n\n==Natural numbers==\n\n===Informal definition===\n\nIn informal mathematical notation (\"informal\" is used here in the sense of \"not formalized\"), the syntax of the natural numbers is defined by the following grammar:\n\n<math>n ::= \\mathsf{zero} \\, | \\, \\mathsf{succ}(n)</math>\n\nThat is, <math>\\mathsf{zero}</math> is a natural number, and if <math>n</math> is a natural number, then <math>\\mathsf{succ}(n)</math> is as well.\n\n===LF representation===\n\nLF is a typed lambda-calculus. We represent an [[object language]] in LF by writing an LF [[signature]].  A signature declares type and term constants.  For example, this LF [[signature]] defines a type representing the natural numbers:\n\n<twelf>\nnat : type.\nz   : nat.\ns   : nat -> nat.\n</twelf>\n\nIntuitively, the LF type <tt>nat</tt> classifies the LF representations of natural numbers.  The LF constant <tt>z</tt> corresponds to <math>\\mathsf{zero}</math> and the LF constant <tt>s</tt> corresponds to <math>\\mathsf{succ}</math>.  \n\nThe signature declares that <tt>z</tt> has type <tt>nat</tt>, which makes sense because <math>\\mathsf{zero}</math> is a natural number.  \n\nThe signature declares that <tt>s</tt> has function type <tt>nat -> nat</tt>.  An LF term of function type can be applied to another LF term of the appropriate type to form a new term.  For example, the constant <tt>s</tt> can be applied to the constant <tt>z</tt> to form the term <tt>s z</tt> representing the number <math>\\mathsf{succ}(\\mathsf{zero})</math>.  Then <tt>s</tt> can be applied to this term to form <tt>s (s z)</tt>, and so on. An informal natural number <math>\\mathsf{succ}(n)</math> is represented by the LF term <tt>s N</tt> where <math>\\texttt{}n</math> is represented by <tt>N</tt>.\n\nWe can state the relationship between the informal presentation of the object language and its LF representation by giving an encoding judgement relating an informal object with its representation:\n\n<center>\n<math>\n\\, \\over \\mathsf{zero} \\gg \\texttt{z}\n</math>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n<math>\nn \\gg N \\over\n\\mathsf{succ}(n) \\gg \\texttt{s}(N)\n</math>\n</center>\n\n===Adequacy===\n\nIs this a correct encoding of the natural numbers?  In the LF methodology, the correctness criterion for an encoding is called [[adequacy]]:\n\n;Adequacy\n:An encoding is [[adequate]] iff it is an isomorphism between the informal object-language entities and the LF terms of the appropriate type.\n\nAdequacy permits any reasoning in or about an object language to be \"ported\" between the informal and LF descriptions.  For example, if we prove a property about the LF representation, by adequacy, that property holds for the informal description as well.  Adequacy ensures that the work we do using the formalization has bearing on the actual language that we had in mind to begin with.\n\nIn this example, the informal object-language entity is the syntax of the natural numbers, and the appropriate LF type is <tt>nat</tt>.  Thus, to satisfy adequacy, the above encoding judgement must be\nan isomorphism between informal natural numbers <math>\\texttt{}n</math> and LF terms of type <tt>nat</tt>.  In this case, because both the informal and LF representations are first order (there is no binding structure), adequacy requires only a simple bijection. (More complicated examples require the adequacy argument to exhibit a [[compositional bijection]] instead of the simple bijection discussed here - an example like this is discussed [[Proving metatheorems:Representing the syntax of the STLC|later]].)\n\nTo establish a bijection, we must show three things:\n# If <math>n \\gg N</math> then <math>\\texttt{}n</math> is a well-formed number and <math>\\texttt{}N</math> is an LF term of type <tt>nat</tt>.\n# For all <math>\\texttt{}n</math>, there exists a unique LF term <math>\\texttt{}N</math> such that <math>n \\gg N</math>.\n# For all LF terms <tt>N : nat</tt>, there exists a unique <math>\\texttt{}n</math> such that <math>n \\gg N</math>.\n\nThe first part establishes that the judgement\n<math>n \\gg N</math> relates informal numbers to LF terms of the appropriate type.  The second and third show that this relation defines a function in both directions.  Because we show that the same relation is functional in both directions, these functions are mutually inverse, establishing a bijection.\n\nThe first part can be proved by a simple induction on the derivation of the encoding.  The second can be proved by structural induction on <math>\\texttt{}n</math>.  The third part states that all LF terms of type <tt>nat</tt> represent a unique informal number.  It can be proved by induction on the structure of LF terms.  \nTo do so, we will need to give a more precise account of LF.  \n\n{{proving metatheorems\n   |noprevious=\n   |next= Simply typed LF\n   |nextname=Simply typed LF}}"
          },
          "sha1": "mg2s33t1h1sfitgpzf2baej5ojosukg"
        }
      },
      {
        "title": "Proving metatheorems:STLC: Answers to exercises",
        "ns": 102,
        "id": 1992,
        "revision": {
          "id": 4781,
          "parentid": 4780,
          "timestamp": "2007-09-26T04:14:56Z",
          "contributor": {
            "ip": "66.167.91.110"
          },
          "comment": "presumed vandalism",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 394,
            "#text": "\nThis page contains answers to the exercises listed [[Proving metatheorems: Summary: the STLC|here]]. If you've solved an exercise that isn't answered on this page, or if you have a different solution to an exercise, please add it here.\n\n== STLC with products ==\n\n''Add product types (<math>\\tau_1 \\times \\tau_2</math>) to the STLC and extend the proof of preservation to cover this new type.''"
          },
          "sha1": "se3hakg16z6rft69g5bad3cdk77b783"
        }
      },
      {
        "title": "Proving metatheorems:Simply typed LF",
        "ns": 102,
        "id": 1779,
        "revision": {
          "id": 6035,
          "parentid": 5375,
          "timestamp": "2009-12-12T22:17:04Z",
          "contributor": {
            "ip": "71.126.43.195"
          },
          "comment": "/* Canonical forms */ parenthetical suggested by Ron",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 6713,
            "#text": "{{proving metatheorems\n   |prev= Representing the syntax of the natural numbers\n   |prevname= Representing syntax\n   |next=Representing the judgements of the natural numbers\n   |nextname= Representing judgements}}\n\nIn the previous section, we discussed representing object-language syntax in LF.  As we saw, to prove that an LF representation is correct, you need to be able to reason by induction on the [[canonical form]]s of LF.  To do so, you will need a basic understanding of the LF type theory.  This understanding will pay off later on, as we will also use induction on canonical forms to [[Proving metatheorems:Proving totality assertions about the natural numbers|prove metatheorems]] about encoded languages.\n\nIn this section, we present simply-typed LF in more detail.  \n\n==Syntax==\n\nThe syntax of simply-typed LF is as follows:\n\n<math>\nA ::= a \\mid A_1 \\rightarrow A_2 \n</math>\n\n<math>\nR ::= c \\mid x \\mid R \\, M \n</math>\n\n<math>\nM ::= R \\, | \\, \\lambda x.M\n</math>\n\nThe types <math>\\texttt{}A</math> consist of base types (<math>\\texttt{}a</math>), which are declared in the signature (e.g., <tt>nat</tt>), and function types (<math>\\texttt{}A_1 \\rightarrow A_2</math>).  The terms of LF consist of variables (<math>\\texttt{}x</math>), constants (<math>\\texttt{}c</math>) declared in the signature, application (<math>\\texttt{}R \\, M</math>), and lambda-abstractions (<math>\\texttt{}\\lambda x.M</math>), which in Twelf's concrete syntax are written <tt>[x] M</tt>.  This much should be familiar to you if you've seen the simply-typed lambda-calculus before.  What may be unfamiliar to you is that the grammar is stratified into <math>\\texttt{}R</math> and <math>\\texttt{}M</math>.  We discuss the reason for this stratification now.\n\n==Canonical forms==\n\nThe above syntax describes what we call ''[[canonical form]]s'' (as long as they are well-typed, more on this below).  Note what is ''not'' a canonical form: there is no syntactic way to apply a lambda-abstraction <math>\\texttt{}\\lambda x.M</math> to an argument.  Based on your past experience with programming languages, it may seem strange to define LF so that only canonical forms exist—we are not allowed to write down any programs that have any computation left to do.  However, this restriction makes sense if you think about our methodology for representing object languages in LF.  In the previous section, we represented natural numbers with the following LF signature:\n<twelf>\nnat : type.\nz   : nat.\ns   : nat -> nat.\n</twelf>\nFor this representation to be adequate, the only LF terms of type <tt>nat</tt> must be <tt>z</tt>, <tt>s z</tt>, <tt>s (s z)</tt>, and so on.  It is easy to see that non-canonical LF terms interfere with this encoding.  For example, the LF term <math>(\\lambda x. \\texttt{s} \\, x) \\, \\texttt{z}</math> would have type <tt>nat</tt>, but it is not the representation of any informal natural number. This would contradict the third part of the adequacy argument in the previous section, but restricting LF to canonical forms avoids these counterexamples.  \n\nIt is not worth presenting the typing rules for canonical forms here (see, e.g., <ref>{{bibtex:hl07mechanizing}}</ref>).  The only detail we need to note here is that terms <math>\\texttt{}R</math> are only canonical at base type <math>\\texttt{}a</math>, not at function type.  For example, the constant <tt>s</tt> is ''not'' a canonical form of type <tt>nat -> nat</tt>.  However, the term <math>\\lambda x.\\texttt{s} x</math>, which is equivalent, is a canonical form.  \n\nIf you have encountered [[beta-reduction]] and [[eta-expansion]] before in your study of programming languages, it may help your intuition to know that the canonical forms of LF coincide with the beta-normal, eta-long terms of the lambda calculus.  What we were saying above is that the syntax of canonical forms forces them to be beta-normal,  and that the typing rules for canonical forms ensure that they are eta-long.  In logic, canonical forms correspond to normal and neutral natural deduction proofs and cut-free sequent calculus proofs.\n\n=== Hereditary Substitution ===\n\nSubstitution <math>\\mathsf{}[M'/x]M</math> of one canonical form into another does not necessarily produce a canonical result.  For example:\n\n<math>\\mathsf{}[\\lambda y.y/x](x \\; z)  \\; = \\;(\\lambda y.y) \\; z</math>\n\nEven though both terms are canonical forms, the result is beta-reducible.  \n\nHowever, it is possible to define a notion of ''hereditary substitution'', which directly computes the canonical result of an ordinary substitution.  When ordinary substitution would return a non-canonical form, hereditary substitution continues to reduce by substituting the argument into the body of the function.  In the above example, the hereditary substitution \n\n<math>\\mathsf{}[\\lambda y.y/x](x \\; z)  \\; = \\; [z/y] y \\; = \\; z </math>\n\nWhenever we use the notation <math>\\mathsf{}[M'/x]M</math> for LF, we mean hereditary substitution.\n\n==Induction on canonical forms==\n\nThe above syntax constitutes an inductive definition of the canonical forms of LF.  Consequently, we can reason by induction on canonical forms using structural induction over this syntax.  When a type adequately represents some informal object-language syntax, induction on the canonical forms of the type corresponds to the structural induction principle for the informal syntax. For example, the induction principle for the type <tt>nat</tt> defined in the previous section corresponds to the standard induction principle for the natural numbers.  As we discussed in the previous section, induction on canonical forms is used to prove adequacy.  Additionally, as we discuss below, induction on canonical forms is used to prove metatheorems about deductive systems.\n\n==Why a lambda calculus?==\n\nAt this point, you may be wondering what we gain by using a lambda-calculus to represent other deductive systems—to represent the natural numbers, all we needed was constants and application; we never even used a term of the form <math>\\texttt{}\\lambda x.M</math>.  At a high level, the answer is that using a meta-language with variable binding permits clean representations of object languages with variable binding. However, we defer a real answer to this question until we talk about representing the [[Proving metatheorems:representing the syntax of the STLC|syntax]] and [[Proving metatheorems:Representing the judgements of the STLC|judgements]] of a language with binding.\n\n== References ==\n\n<references/>\n\n{{proving metatheorems\n   |prev= Representing the syntax of the natural numbers\n   |prevname= Representing syntax\n   |next=Representing the judgements of the natural numbers\n   |nextname= Representing judgements}}"
          },
          "sha1": "tdu46p94xhips681k3s2z8v1jueui7g"
        }
      },
      {
        "title": "Proving metatheorems:Summary: the STLC",
        "ns": 102,
        "id": 1894,
        "revision": {
          "id": 4845,
          "parentid": 4831,
          "timestamp": "2007-09-27T04:16:42Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "minor": null,
          "comment": "Reverted edits by [[Special:Contributions/141.104.22.222|141.104.22.222]] ([[User_talk:141.104.22.222|Talk]]); changed back to last version by [[User:Drl|Drl]]",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 1717,
            "#text": "{{proving metatheorems\n  | nonext = \n  | prev = Proving metatheorems in non-empty contexts\n  | prevname = Proving metatheorems in non-empty contexts}}\n\n== Take-aways ==\n\nThe lessons you should take from this section are:\n\n# LF's binding structure enables elegant representations of object-language binding and hypothetical judgements.\n# World declarations permit totality assertions about type families in non-empty contexts.\n# Such totality assertions can be used to prove general metatheorems about object-language entities that are represented using higher-order LF encodings.  \n\n== What's next? ==\n\nNow that you've made it through this introduction, you have the basic tools you need to start proving metatheorems with Twelf.  You've seen all of the basic machinery that Twelf provides, and you are in a good position to understand the other documentation on this wiki.  Your next step should be to read some of the [[tutorials]], which describe clever modes of use of the techniques we have talked about here, or to read some of the [[case studies]], which describe interesting applications of Twelf.\n\n== Test yourself ==\n\n''This section is under development; if you try other examples at this point, please add them here.''\n\nBefore going on to the next section, you may wish to test yourself with the following exercises.  Then see the [[Proving metatheorems: STLC: Answers to exercises|answers]].\n\n# Add product types (<math>\\tau_1 \\times \\tau_2</math>) to the STLC and extend the proof of preservation to cover this new type.\n# ''Add your exercises here!''\n\n\n{{proving metatheorems\n  | nonext = \n  | prev = Proving metatheorems in non-empty contexts\n  | prevname = Proving metatheorems in non-empty contexts}}"
          },
          "sha1": "iyf19fyavgeti1gdzr3hyhwkj0dtxwq"
        }
      },
      {
        "title": "Proving metatheorems:Summary: the natural numbers",
        "ns": 102,
        "id": 1888,
        "revision": {
          "id": 5444,
          "parentid": 5443,
          "timestamp": "2008-11-13T15:38:28Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "comment": "/* Test yourself */",
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 2833,
            "#text": "{{proving metatheorems\n  | prev = Proving metatheorems about the natural numbers\n  | prevname = Proving metatheorems\n  | next = Representing the syntax of the STLC\n  | nextname = Higher-order representation of syntax}}\n\n== Take-aways ==\n\nThe three things to remember from this section are:\n\n# Object-language syntax and judgements are represented as LF terms of corresponding types.  These representations are adequate iff they are isomorphic to the original description of the object language.  \n# An LF type family defines a relation on its indices.  Twelf has the ability to verify that a type family represents a total relation.  \n# Proofs of <math>\\forall\\exists</math>-statements can be mechanized and verified in Twelf by representing them as LF type families.  \n\nAt a high level, that's all there is to know about proving metatheorems with Twelf.  \n\n== What's next? ==\n\nSo far, we have used only first-order LF representations (we haven't used LF variables or lambdas for anything yet).  That's reasonable, since the natural numbers and the judgements we defined about them are first-order things.  \n\nHowever, one of the main benefits of LF is that the above methodology scales gracefully to programming languages with binding structure.  This is the subject of the next section.\n\n== Test yourself ==\n\n''This section is under development. If you try other examples at this point, please add them here.  If you try more advanced examples, add them to the [[Proving metatheorems:Summary: the STLC|next section]].''\n\nBefore going on to the next section, you may wish to test yourself with the following exercises.  Then see the [[Proving metatheorems: Natural numbers: Answers to exercises|answers]].\n\n# State and prove a metatheorem showing that <tt>plus</tt> is commutative.\n# Define the odd numbers with a judgement analogous to the <tt>even</tt> judgement defined above. \n# Prove a simple relation between odd and even numbers: \n## State and prove a theorem <tt>succ-even</tt> that shows that the successor of an even number is an odd number.\n## After that, state and prove a Theorem <tt>succ-odd</tt> that shows that the successor of an odd number is an even number.\n# Prove how even/oddness interacts with addition:\n## State and prove the theorem sum-even-odd that shows that the sum of an even and an odd number results in an odd number\n## State and prove a theorem sum-odd-even that shows that the sum of an odd plus an even number produces an odd number\n## Finally, state and prove a theorem sum-odds that shows that the sum of two odd numbers produces an even number\n# ''Add your exercises here!''\n\n\n{{proving metatheorems\n  | prev = Proving metatheorems about the natural numbers\n  | prevname = Proving metatheorems\n  | next = Representing the syntax of the STLC\n  | nextname = Higher-order representation of syntax}}"
          },
          "sha1": "7lch7je6me31o4rmnd2epthr1y1ryvx"
        }
      },
      {
        "title": "Proving metatheorems talk:Representing the judgements of the STLC",
        "ns": 103,
        "id": 1993,
        "revision": {
          "id": 4718,
          "parentid": 4713,
          "timestamp": "2007-04-13T18:13:54Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 4907,
            "#text": "Are the discussion pages live?  Who knows.\n\nOkay, my question is this: why is the eta expansion in the of-lam type necessary?  I believe that it is, but I also believe that it's not obvious why it's there.  In particular, I replaced it with\n\n<twelf>\n of-lam : (of (lam T1 E) (arr T1 T2))                                                     \n           <- ({x : tm} (of x T2) -> of (E x) T).                                         \n</twelf>\nand found that my trivial typecheck of ((\\ x . x) <>) still went through....\n\nOh... FWIW, here it is:\n<twelf>\n bogus : (of (app (lam unit ([x] x)) mt) unit) -> type.                                   \n                                                                                         \n bogusval : (bogus                                                                        \n               (of-app                                                                    \n                  of-unit                                                                 \n                  (of-lam ([x] [DxhasT2 : (of x unit)] DxhasT2)))).\n</twelf>\nI'm guessing that further exploration will make this clear, but if I can formulate simple examples that appear to work without the eta-expansion, then I think it may bear explaining in the text.                 \n: \n[[User:76.209.222.184|76.209.222.184]] 04:15, 13 April 2007 (EDT) John Clements\n\n: Hi John. Yeah, the discussion pages are a great place for questions like this!  This is a good question, and I'm going to figure out where to explain the answer in the text.  For now, the quick answer is that there is no difference between the two types:\n<twelf>\nof-lam : (of (lam T1 E) (arr T1 T2))                                                     \n          <- ...                                          \nof-lam' : (of (lam T1 ([x] E x)) (arr T1 T2))                                                     \n           <- ... \n</twelf>                                        \n\n: More generally, there is no difference between a variable at function type (like <tt>E : tm -> tm</tt> above) and its eta-expansion (<tt>[x] E x</tt>): Twelf treats the first as syntactic sugar for the second.  In the official syntax of canonical forms, everything must be eta-expanded as much as possible (without introducing beta-redices).  There are a couple of reasons why this is a nice thing to do:\n# If you define equality of non-canonical forms by mapping them to a canonical form, this notion of equality will include eta-equivalence.\n# This is important for adequacy: you don't want both the eta-expanded version and the non-eta-expanded version to both be canonical forms. E.g., say we had <tt>first:tm->tm</tt> in the LF signature that we used to represent STLC syntax because we added pairs.  If you don't mod out by eta, then both <tt>lam ([y:tm] first y)</tt> and <tt>lam first</tt> would be different canonical forms, but presumably they would represent the same object-language thing (λx.first(x)).  \n# Technically, when you're working with canonical forms, it's useful to know that every canonical form of function type is a lambda.\n\n: In terms of Twelf style, it's arguably clearer to eta-expand variables of function type, since then you can distinguish terms of function type from terms of base type just by looking at the syntax.  I don't always follow this convention, but I try to do it for the code that's most likely to be read (e.g., the definitions of the most important judgements).  I get sloppy in auxiliary judgements and proofs, though.  \n\n: Also, I like your clever way of type-checking the example typing derivation above by definition a type family indexed by exactly the type that you want to inhabit.  However, there is an easier way, using another feature of Twelf that I haven't figured out where to explain in this intro tutorial: definitions.  That is, you can write\n<twelf>\nderiv : of (app (lam unit ([x] x)) mt) unit =                                                                                        \n        of-app of-unit                                                                 \n           (of-lam ([x] [DxhasT2 : (of x unit)] DxhasT2)))).\n</twelf>\n: Definitions aren't really that useful when you're specifying a language or proving theorems about it (unless you want to name some derived forms), but they are nice for doing examples.  \n\n: Does that answer make sense? [[User:Drl|Drl]] 10:57, 13 April 2007 (EDT)\n: PS: Feel free to make yourself an account on the wiki if you don't want to sign questions like this with your IP address.\n\n:: For now, I added a couple of blurbs about eta-expansion (and definitions, too) [[Proving metatheorems:Full LF|here]] and [[Proving metatheorems:Representing the judgements of the STLC|here]].  Thanks for the suggestions!  I'd appreciate any other comments like this as you work though the article.  [[User:Drl|Drl]] 14:13, 13 April 2007 (EDT)"
          },
          "sha1": "m3cjlt9euu6ifnn38ey2jajsbxi512v"
        }
      },
      {
        "title": "Proving metatheorems talk:Representing the judgements of the natural numbers",
        "ns": 103,
        "id": 1995,
        "revision": {
          "id": 5368,
          "parentid": 5364,
          "timestamp": "2008-07-25T21:16:34Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 936,
            "#text": "Shouldn't \"i.e., it is the specialization of the inference rule to <math>N = \\mathsf{zero}</math>\" read \"i.e., it is the specialization of the inference rule to <math>n = \\mathsf{zero}</math>\", since only a small <math>n</math> appears in the judgements?\n\n: Fixed.  Thanks again! If you like, feel free to fix typos like this directly in the text. [[User:Drl|Drl]] 11:30, 18 April 2007 (EDT)\n\n== %worlds ==\n\nThe [[%worlds]] page said\n\n<blockquote>\nAs discussed in the introduction article on [[Proving metatheorems:Representing the judgments of the natural numbers|Representing the judgments of the natural numbers]], the type <tt>nat</tt> in this signature [[adequacy|adequately]] represents the natural numbers only if the LF context does not contain variables of type <tt>nat</tt>.\n</blockquote>\n\nThis page doesn't mention that now, but I would be very grateful if it did!\n\n: Fixed--thanks! [[User:Drl|Drl]] 17:16, 25 July 2008 (EDT)"
          },
          "sha1": "24prh1pt6gxdzh7fxgv34lns5n1wt78"
        }
      },
      {
        "title": "Proving metatheorems talk:Representing the syntax of the STLC",
        "ns": 103,
        "id": 2222,
        "revision": {
          "id": 6074,
          "parentid": 6072,
          "timestamp": "2010-04-22T01:23:26Z",
          "contributor": {
            "username": "Rsimmons",
            "id": 2
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 289,
            "#text": "why do you call the inhabitant of the unit type \"the empty pair\"? shouldn't it rather be \"the empty tuple\"? in my opinion, pairs always have two components and can not be empty.\n:: Seems reasonable! — [[User:rsimmons|Rob]] (and his [[User talk:rsimmons|talk]]) 21:23, 21 April 2010 (EDT)"
          },
          "sha1": "lrmav6axkcq7knfejknytxzlgze299d"
        }
      },
      {
        "title": "Proving metatheorems talk:Simply typed LF",
        "ns": 103,
        "id": 1994,
        "revision": {
          "id": 4725,
          "parentid": 4722,
          "timestamp": "2007-04-18T15:26:40Z",
          "contributor": {
            "username": "Drl",
            "id": 14
          },
          "model": "wikitext",
          "format": "text/x-wiki",
          "text": {
            "@xml:space": "preserve",
            "@bytes": 136,
            "#text": "[z/y]y = _z_ in the last statement of hereditary substitution?\n\n: Yes, thanks for the catch! [[User:Drl|Drl]] 11:26, 18 April 2007 (EDT)"
          },
          "sha1": "jhaprwjcnmlce0gz8b6fumcex2xvwjr"
        }
      }
    ]
  }
}